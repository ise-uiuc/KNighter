--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -24,11 +24,37 @@ // Register a map in the ProgramState to track upper bounds for symbols.
 REGISTER_MAP_WITH_PROGRAMSTATE(SymbolUpperBoundMap, SymbolRef, llvm::APSInt)

+// Utility declarations provided by the environment.
+template <typename T>
+const T* findSpecificTypeInParents(const Stmt *S, CheckerContext &C);
+
+template <typename T>
+const T* findSpecificTypeInChildren(const Stmt *S);
+
+bool EvaluateExprToInt(llvm::APSInt &EvalRes, const Expr *expr, CheckerContext &C);
+
+const llvm::APSInt *inferSymbolMaxVal(SymbolRef Sym, CheckerContext &C);
+
+bool getArraySizeFromExpr(llvm::APInt &ArraySize, const Expr *E);
+
+bool getStringSize(llvm::APInt &StringSize, const Expr *E);
+
+const MemRegion* getMemRegionFromExpr(const Expr* E, CheckerContext &C);
+
+struct KnownDerefFunction {
+  const char *Name;
+  llvm::SmallVector<unsigned, 4> Params;
+};
+
+bool functionKnownToDeref(const CallEvent &Call, llvm::SmallVectorImpl<unsigned> &DerefParams);
+
+bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C);
+
 namespace {

 // Track per-symbol upper bounds discovered along the path (e.g., from if (n <= K)).
 class SAGenTestChecker
-    : public Checker<check::PreCall, eval::Assume> {
+    : public Checker<check::PreCall, check::PostCall, eval::Assume> {
    mutable std::unique_ptr<BugType> BT;

 public:
@@ -38,6 +64,7 @@                        "Integer Overflow")) {}

   void checkPreCall(const CallEvent &Call, CheckerContext &C) const;
+  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;

   ProgramStateRef evalAssume(ProgramStateRef State, SVal Cond,
                              bool Assumption) const;
@@ -46,6 +73,9 @@   // Return true if this is a target function, and set SizeIdx to the size arg.
   bool isTargetFunction(const CallEvent &Call, CheckerContext &C,
                         unsigned &SizeIdx) const;
+
+  // Return true if this is a copy_from_user() call.
+  bool isCopyFromUserCall(const CallEvent &Call, CheckerContext &C) const;

   // Return true if E is a sizeof(...) expression.
   static bool isSizeofExpr(const Expr *E);
@@ -120,6 +150,13 @@     }
   }
   return false;
+}
+
+bool SAGenTestChecker::isCopyFromUserCall(const CallEvent &Call, CheckerContext &C) const {
+  const Expr *OE = Call.getOriginExpr();
+  if (!OE)
+    return false;
+  return ExprHasName(OE, "copy_from_user", C);
 }

 bool SAGenTestChecker::isSizeofExpr(const Expr *E) {
@@ -326,8 +363,36 @@     return;
   }

-  // Not provably safe -> report to avoid missing real issues, including the target patch.
+  // Only report if the count is tainted by userspace. This focuses the checker
+  // on the intended bug pattern and suppresses kernel-internal bounded patterns.
+  if (!IsTainted)
+    return;
+
+  // Not provably safe and tainted -> report.
   report(SizeE, C);
+}
+
+void SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const {
+  // Taint the destination buffer of copy_from_user() so that subsequent reads
+  // from it (and its fields) are tracked as user-controlled.
+  if (!isCopyFromUserCall(Call, C))
+    return;
+
+  if (Call.getNumArgs() < 1)
+    return;
+
+  const Expr *DstE = Call.getArgExpr(0);
+  if (!DstE)
+    return;
+
+  const MemRegion *DstR = getMemRegionFromExpr(DstE, C);
+  if (!DstR)
+    return;
+
+  ProgramStateRef State = C.getState();
+  State = taint::addTaint(State, DstR);
+  if (State != C.getState())
+    C.addTransition(State);
 }

 ProgramStateRef SAGenTestChecker::recordUpperBoundFromBinarySymExpr(
