### Report Summary

File:| drivers/gpu/drm/v3d/v3d_perfmon.c
---|---
Warning:| line 211, column 6
Size is computed as sizeof(x) * count; use array_size() to avoid overflow

### Annotated Source Code


1     | // SPDX-License-Identifier: GPL-2.0
2     | /*
3     |  * Copyright (C) 2021 Raspberry Pi
4     |  */
5     |
6     | #include "v3d_drv.h"
7     | #include "v3d_regs.h"
8     |
9     | #define V3D_PERFMONID_MIN	1
10    | #define V3D_PERFMONID_MAX U32_MAX
11    |
12    | void v3d_perfmon_get(struct v3d_perfmon *perfmon)
13    | {
14    |  if (perfmon)
15    | 		refcount_inc(&perfmon->refcnt);
16    | }
17    |
18    | void v3d_perfmon_put(struct v3d_perfmon *perfmon)
19    | {
20    |  if (perfmon && refcount_dec_and_test(&perfmon->refcnt)) {
21    | 		mutex_destroy(&perfmon->lock);
22    | 		kfree(perfmon);
23    | 	}
24    | }
25    |
26    | void v3d_perfmon_start(struct v3d_dev *v3d, struct v3d_perfmon *perfmon)
27    | {
28    |  unsigned int i;
29    | 	u32 mask;
30    | 	u8 ncounters;
31    |
32    |  if (WARN_ON_ONCE(!perfmon || v3d->active_perfmon))
33    |  return;
34    |
35    | 	ncounters = perfmon->ncounters;
36    | 	mask = GENMASK(ncounters - 1, 0);
37    |
38    |  for (i = 0; i < ncounters; i++) {
39    | 		u32 source = i / 4;
40    | 		u32 channel = V3D_SET_FIELD(perfmon->counters[i], V3D_PCTR_S0);
41    |
42    | 		i++;
43    | 		channel |= V3D_SET_FIELD(i < ncounters ? perfmon->counters[i] : 0,
44    |  V3D_PCTR_S1);
45    | 		i++;
139   | 	}
140   |
141   | 	perfmon = kzalloc(struct_size(perfmon, values, req->ncounters),
142   |  GFP_KERNEL);
143   |  if (!perfmon)
144   |  return -ENOMEM;
145   |
146   |  for (i = 0; i < req->ncounters; i++)
147   | 		perfmon->counters[i] = req->counters[i];
148   |
149   | 	perfmon->ncounters = req->ncounters;
150   |
151   | 	refcount_set(&perfmon->refcnt, 1);
152   |  mutex_init(&perfmon->lock);
153   |
154   |  mutex_lock(&v3d_priv->perfmon.lock);
155   | 	ret = idr_alloc(&v3d_priv->perfmon.idr, perfmon, V3D_PERFMONID_MIN,
156   |  V3D_PERFMONID_MAX, GFP_KERNEL);
157   | 	mutex_unlock(&v3d_priv->perfmon.lock);
158   |
159   |  if (ret < 0) {
160   | 		mutex_destroy(&perfmon->lock);
161   | 		kfree(perfmon);
162   |  return ret;
163   | 	}
164   |
165   | 	req->id = ret;
166   |
167   |  return 0;
168   | }
169   |
170   | int v3d_perfmon_destroy_ioctl(struct drm_device *dev, void *data,
171   |  struct drm_file *file_priv)
172   | {
173   |  struct v3d_file_priv *v3d_priv = file_priv->driver_priv;
174   |  struct drm_v3d_perfmon_destroy *req = data;
175   |  struct v3d_perfmon *perfmon;
176   |
177   |  mutex_lock(&v3d_priv->perfmon.lock);
178   | 	perfmon = idr_remove(&v3d_priv->perfmon.idr, req->id);
179   | 	mutex_unlock(&v3d_priv->perfmon.lock);
180   |
181   |  if (!perfmon)
182   |  return -EINVAL;
183   |
184   | 	v3d_perfmon_put(perfmon);
185   |
186   |  return 0;
187   | }
188   |
189   | int v3d_perfmon_get_values_ioctl(struct drm_device *dev, void *data,
190   |  struct drm_file *file_priv)
191   | {
192   |  struct v3d_dev *v3d = to_v3d_dev(dev);
193   |  struct v3d_file_priv *v3d_priv = file_priv->driver_priv;
194   |  struct drm_v3d_perfmon_get_values *req = data;
195   |  struct v3d_perfmon *perfmon;
196   |  int ret = 0;
197   |
198   |  if (req->pad != 0)
    1Assuming field 'pad' is equal to 0→
    2←Taking false branch→
199   |  return -EINVAL;
200   |
201   |  mutex_lock(&v3d_priv->perfmon.lock);
202   | 	perfmon = idr_find(&v3d_priv->perfmon.idr, req->id);
203   | 	v3d_perfmon_get(perfmon);
204   | 	mutex_unlock(&v3d_priv->perfmon.lock);
205   |
206   |  if (!perfmon2.1'perfmon' is non-null)
    3←Taking false branch→
207   |  return -EINVAL;
208   |
209   |  v3d_perfmon_stop(v3d, perfmon, true);
210   |
211   |  if (copy_to_user(u64_to_user_ptr(req->values_ptr), perfmon->values,
    4←Size is computed as sizeof(x) * count; use array_size() to avoid overflow
212   |  perfmon->ncounters * sizeof(u64)))
213   | 		ret = -EFAULT;
214   |
215   | 	v3d_perfmon_put(perfmon);
216   |
217   |  return ret;
218   | }
