--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -15,12 +15,11 @@ #include "clang/StaticAnalyzer/Checkers/utility.h"
 #include "clang/AST/Expr.h"
 #include "clang/AST/Stmt.h"
+#include <cstdint>

 using namespace clang;
 using namespace ento;
 using namespace taint;
-
-// No custom program states are required for this checker.

 namespace {

@@ -43,11 +42,40 @@   // Return true if E is a sizeof(...) expression.
   static bool isSizeofExpr(const Expr *E);

+  // Try to evaluate expression to an integer constant.
+  static bool tryEvaluateToAPSInt(const Expr *E, CheckerContext &C,
+                                  llvm::APSInt &Out);
+
+  // Extract the sizeof value (in bytes) from a sizeof expression.
+  static bool getSizeofValueInBytes(const Expr *SizeofE, CheckerContext &C,
+                                    uint64_t &OutBytes);
+
+  // Compute size_t bit width.
+  static unsigned getSizeTBits(CheckerContext &C);
+
+  // Compute a conservative upper bound for CountExpr:
+  // - First from path constraints (ConstraintManager),
+  // - Otherwise from the integral type's maximum.
+  // Returns true if a bound was found. Sets HasConstraintBound if bound came
+  // from constraints (not just raw type).
+  static bool getUpperBoundForCount(const Expr *CountExpr, CheckerContext &C,
+                                    llvm::APInt &MaxCount, bool &HasConstraintBound,
+                                    bool &IsTainted);
+
+  // Returns true if multiplication elemSize * Count cannot overflow size_t
+  // given the known MaxCount bound.
+  static bool productProvablyFitsSizeT(uint64_t ElemSizeBytes,
+                                       const llvm::APInt &MaxCount,
+                                       CheckerContext &C);
+
+  // Helper to suppress reports in provably safe situations.
+  static bool isFalsePositive(const Expr *CountExpr, uint64_t ElemSizeBytes,
+                              CheckerContext &C, bool &IsTainted, bool &HasConstraintBound);
+
   // Report a concise diagnostic on SizeE.
   void report(const Expr *SizeE, CheckerContext &C) const;
 };

-// Determine if the call is to copy_from_user or copy_to_user and set size index.
 bool SAGenTestChecker::isTargetFunction(const CallEvent &Call,
                                         CheckerContext &C,
                                         unsigned &SizeIdx) const {
@@ -55,11 +83,10 @@   if (!OE)
     return false;

-  // Use text-based matching as suggested.
+  // Match Linux copy_to/from_user calls by spelled name.
   if (ExprHasName(OE, "copy_from_user", C) || ExprHasName(OE, "copy_to_user", C)) {
-    // Signature: (dst, src, n) -> size index = 2
     if (Call.getNumArgs() > 2) {
-      SizeIdx = 2;
+      SizeIdx = 2; // (dst, src, size)
       return true;
     }
   }
@@ -73,6 +100,112 @@   if (const auto *U = dyn_cast<UnaryExprOrTypeTraitExpr>(E)) {
     return U->getKind() == UETT_SizeOf;
   }
+  return false;
+}
+
+bool SAGenTestChecker::tryEvaluateToAPSInt(const Expr *E, CheckerContext &C,
+                                           llvm::APSInt &Out) {
+  if (!E)
+    return false;
+  return EvaluateExprToInt(Out, E->IgnoreParenImpCasts(), C);
+}
+
+bool SAGenTestChecker::getSizeofValueInBytes(const Expr *SizeofE, CheckerContext &C,
+                                             uint64_t &OutBytes) {
+  llvm::APSInt V;
+  if (!tryEvaluateToAPSInt(SizeofE, C, V))
+    return false;
+  // Sizeof always yields non-negative, fits into 64-bit for C targets.
+  OutBytes = V.getLimitedValue(/*Max*/UINT64_MAX);
+  return true;
+}
+
+unsigned SAGenTestChecker::getSizeTBits(CheckerContext &C) {
+  ASTContext &ACtx = C.getASTContext();
+  return ACtx.getTypeSize(ACtx.getSizeType()); // in bits
+}
+
+bool SAGenTestChecker::getUpperBoundForCount(const Expr *CountExpr, CheckerContext &C,
+                                             llvm::APInt &MaxCount,
+                                             bool &HasConstraintBound,
+                                             bool &IsTainted) {
+  HasConstraintBound = false;
+  IsTainted = false;
+
+  ProgramStateRef State = C.getState();
+  const LocationContext *LCtx = C.getLocationContext();
+
+  // If CountExpr is a compile-time constant, use that.
+  llvm::APSInt ConstVal;
+  if (tryEvaluateToAPSInt(CountExpr, C, ConstVal)) {
+    unsigned Bits = getSizeTBits(C);
+    uint64_t CV = ConstVal.getLimitedValue(UINT64_MAX);
+    MaxCount = llvm::APInt(Bits, CV, /*isSigned=*/false);
+    return true;
+  }
+
+  SVal CountV = State->getSVal(CountExpr, LCtx);
+  IsTainted = taint::isTainted(State, CountV);
+
+  // Try to retrieve a symbol and ask the constraint manager for a path-sensitive upper bound.
+  if (SymbolRef Sym = CountV.getAsSymbol()) {
+    if (const llvm::APSInt *MaxFromCM = inferSymbolMaxVal(Sym, C)) {
+      unsigned Bits = getSizeTBits(C);
+      uint64_t M = MaxFromCM->getLimitedValue(UINT64_MAX);
+      MaxCount = llvm::APInt(Bits, M, /*isSigned=*/false);
+      HasConstraintBound = true;
+      return true;
+    }
+  }
+
+  // Fallback: use the integer type maximum as a conservative bound.
+  QualType T = CountExpr->getType();
+  if (T->isIntegerType()) {
+    ASTContext &ACtx = C.getASTContext();
+    unsigned TyBits = ACtx.getIntWidth(T);
+    bool IsSigned = T->isSignedIntegerType();
+    // Compute type max: signed -> 2^(bits-1)-1, unsigned -> 2^bits-1.
+    llvm::APInt TypeMax = IsSigned ? (llvm::APInt::getOneBitSet(TyBits, TyBits - 1) - 1)
+                                   : llvm::APInt::getMaxValue(TyBits);
+    unsigned SizeBits = getSizeTBits(C);
+    MaxCount = TypeMax.zextOrTrunc(SizeBits);
+    return true;
+  }
+
+  return false;
+}
+
+bool SAGenTestChecker::productProvablyFitsSizeT(uint64_t ElemSizeBytes,
+                                                const llvm::APInt &MaxCount,
+                                                CheckerContext &C) {
+  if (ElemSizeBytes == 0)
+    return true; // degenerate, but can't overflow size_t
+  unsigned Bits = getSizeTBits(C);
+  llvm::APInt SizeMax = llvm::APInt::getMaxValue(Bits); // SIZE_MAX
+  llvm::APInt Elem(Bits, ElemSizeBytes, /*isSigned=*/false);
+
+  // threshold = SIZE_MAX / ElemSizeBytes
+  llvm::APInt Threshold = SizeMax.udiv(Elem);
+  return MaxCount.ule(Threshold);
+}
+
+bool SAGenTestChecker::isFalsePositive(const Expr *CountExpr, uint64_t ElemSizeBytes,
+                                       CheckerContext &C, bool &IsTainted,
+                                       bool &HasConstraintBound) {
+  llvm::APInt MaxCount(/*bitWidth dummy*/1, 0);
+  IsTainted = false;
+  HasConstraintBound = false;
+
+  if (!getUpperBoundForCount(CountExpr, C, MaxCount, HasConstraintBound, IsTainted)) {
+    // Could not determine any bound; not enough information to prove safety.
+    return false;
+  }
+
+  // If we can prove the product fits into size_t, it's safe â€” suppress warning.
+  if (productProvablyFitsSizeT(ElemSizeBytes, MaxCount, C))
+    return true;
+
+  // Not provably safe -> keep for potential report.
   return false;
 }

@@ -120,16 +253,38 @@     return;

   const Expr *CountExpr = LIsSizeof ? R : L;
-  if (!CountExpr)
+  const Expr *SizeofExpr = LIsSizeof ? L : R;
+
+  if (!CountExpr || !SizeofExpr)
     return;

   // If count is a compile-time constant, skip (low risk).
-  llvm::APSInt Dummy;
-  if (EvaluateExprToInt(Dummy, CountExpr, C))
-    return;
-
-  // Otherwise, this matches the open-coded sizeof * count pattern.
-  report(SizeE, C);
+  llvm::APSInt DummyConst;
+  if (tryEvaluateToAPSInt(CountExpr, C, DummyConst))
+    return;
+
+  // Extract sizeof(...) in bytes.
+  uint64_t ElemSizeBytes = 0;
+  if (!getSizeofValueInBytes(SizeofExpr, C, ElemSizeBytes))
+    return;
+
+  // Suppress when we can prove no overflow in size_t given path constraints or type range.
+  bool IsTainted = false;
+  bool HasConstraintBound = false;
+  if (isFalsePositive(CountExpr, ElemSizeBytes, C, IsTainted, HasConstraintBound)) {
+    // Provably safe product.
+    return;
+  }
+
+  // Not provably safe. To reduce false positives, require either:
+  // - Count is tainted by user input, or
+  // - We couldn't get any constraint-derived upper bound (i.e. unbounded/unknown).
+  if (IsTainted || !HasConstraintBound) {
+    report(SizeE, C);
+  }
+  // Else: we had a constraint-derived upper bound, but couldn't prove safety.
+  // If not tainted, suppress to avoid FPs on internal counts that are not user-controlled.
+  return;
 }

 } // end anonymous namespace
