--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -97,6 +97,12 @@                                                     const BinarySymExpr *BSE,
                                                     bool Assumption,
                                                     const ASTContext &AC) const;
+
+  // Recursively process assumptions on symbolic expressions, including LOr/LAnd.
+  ProgramStateRef processAssumptionOnSymExpr(ProgramStateRef State,
+                                             const SymExpr *SE,
+                                             bool Assumption,
+                                             const ASTContext &AC) const;
 };

 bool SAGenTestChecker::isTargetFunction(const CallEvent &Call,
@@ -313,23 +319,15 @@   if (!getSizeofValueInBytes(SizeofExpr, C, ElemSizeBytes))
     return;

-  // Suppress when we can prove no overflow in size_t given path constraints or type range.
   bool IsTainted = false;
   bool HasConstraintBound = false;
   if (isFalsePositive(CountExpr, ElemSizeBytes, C, IsTainted, HasConstraintBound)) {
-    // Provably safe product.
-    return;
-  }
-
-  // Not provably safe. To reduce false positives, require either:
-  // - Count is tainted by user input, or
-  // - We couldn't get any constraint-derived upper bound (i.e. unbounded/unknown).
-  if (IsTainted || !HasConstraintBound) {
-    report(SizeE, C);
-  }
-  // Else: we had a constraint-derived upper bound, but couldn't prove safety
-  // and count is not tainted â€” suppress to avoid FPs on internal counts.
-  return;
+    // Provably safe product -> suppress.
+    return;
+  }
+
+  // Not provably safe -> report to avoid missing real issues, including the target patch.
+  report(SizeE, C);
 }

 ProgramStateRef SAGenTestChecker::recordUpperBoundFromBinarySymExpr(
@@ -380,8 +378,6 @@           Tmp -= 1;
           llvm::APSInt UB(Tmp, /*isUnsigned=*/true);
           return RecordUB(State, S, UB);
-        } else {
-          // C == 0, S < 0 => for unsigned S no values; ignore
         }
       }
       break;
@@ -394,8 +390,6 @@           Tmp -= 1;
           llvm::APSInt UB(Tmp, /*isUnsigned=*/true);
           return RecordUB(State, S, UB);
-        } else {
-          // S < 0, ignore
         }
       }
       break;
@@ -461,16 +455,54 @@   return State;
 }

+ProgramStateRef SAGenTestChecker::processAssumptionOnSymExpr(ProgramStateRef State,
+                                                             const SymExpr *SE,
+                                                             bool Assumption,
+                                                             const ASTContext &AC) const {
+  if (!SE)
+    return State;
+
+  if (const auto *BSE = dyn_cast<BinarySymExpr>(SE)) {
+    BinaryOperatorKind Op = BSE->getOpcode();
+    switch (Op) {
+    case BO_LOr:
+      // (A || B) is false => A is false and B is false.
+      if (!Assumption) {
+        if (const auto *SSE = dyn_cast<SymSymExpr>(BSE)) {
+          State = processAssumptionOnSymExpr(State, SSE->getLHS(), /*Assumption*/false, AC);
+          State = processAssumptionOnSymExpr(State, SSE->getRHS(), /*Assumption*/false, AC);
+        }
+      }
+      // If true, can't deduce which side => skip.
+      return State;
+    case BO_LAnd:
+      // (A && B) is true => A is true and B is true.
+      if (Assumption) {
+        if (const auto *SSE = dyn_cast<SymSymExpr>(BSE)) {
+          State = processAssumptionOnSymExpr(State, SSE->getLHS(), /*Assumption*/true, AC);
+          State = processAssumptionOnSymExpr(State, SSE->getRHS(), /*Assumption*/true, AC);
+        }
+      }
+      // If false, can't deduce which side => skip.
+      return State;
+    default:
+      // Try to record simple relational constraints.
+      return recordUpperBoundFromBinarySymExpr(State, BSE, Assumption, AC);
+    }
+  }
+
+  // Not a binary symbolic expression; nothing to do.
+  return State;
+}
+
 ProgramStateRef SAGenTestChecker::evalAssume(ProgramStateRef State, SVal Cond,
                                              bool Assumption) const {
-  // Only interested in relational symbolic expressions (NonLoc::SymbolVal over BinarySymExpr).
+  // Only interested in relational/logical symbolic expressions.
   if (auto NL = Cond.getAs<NonLoc>()) {
     if (auto SV = NL->getAs<nonloc::SymbolVal>()) {
       if (const SymExpr *SE = SV->getSymbol()) {
-        if (const auto *BSE = dyn_cast<BinarySymExpr>(SE)) {
-          const ASTContext &AC = State->getStateManager().getContext();
-          return recordUpperBoundFromBinarySymExpr(State, BSE, Assumption, AC);
-        }
+        const ASTContext &AC = State->getStateManager().getContext();
+        return processAssumptionOnSymExpr(State, SE, Assumption, AC);
       }
     }
   }
