--- attempt_3_original.cpp+++ attempt_3.cpp@@ -185,6 +185,21 @@             L == "nr" || L == "cnt");
   }

+  static bool looksLikeIndexName(StringRef Name) {
+    if (Name.empty())
+      return false;
+    std::string L = toLowerCopy(Name);
+    static const char *IndexToks[] = {
+      "idx","index","ind","pos","slot","cursor","off","offset","ix"
+    };
+    for (const char *Tok : IndexToks)
+      if (L.find(Tok) != std::string::npos)
+        return true;
+    if (L == "i" || L == "j" || L == "k")
+      return true;
+    return false;
+  }
+
   static StringRef getIdentNameFromExpr(const Expr *E) {
     E = E ? E->IgnoreParenCasts() : nullptr;
     if (!E)
@@ -261,6 +276,18 @@              L.find("bound") != std::string::npos));
   }

+  static bool rhsTextLooksMinLike(const Expr *RHS, CheckerContext &C) {
+    StringRef Txt = getExprText(RHS, C);
+    std::string L = toLowerCopy(Txt);
+    return (!L.empty() &&
+            (L.find("min") != std::string::npos ||
+             L.find("start") != std::string::npos ||
+             L.find("lower") != std::string::npos ||
+             L.find("lo") != std::string::npos ||
+             L.find("begin") != std::string::npos ||
+             L.find("first") != std::string::npos));
+  }
+
   static bool isPlainMaxLikeBound(const Expr *Bound, CheckerContext &C) {
     if (!Bound)
       return false;
@@ -279,12 +306,33 @@
     StringRef Name = getIdentNameFromExpr(Bound);
     if (!Name.empty())
-      return nameLooksLikeCapacityOrMax(Name); // Do not treat *_count/*_num as MAX-like.
+      return nameLooksLikeCapacityOrMax(Name);

     return rhsTextLooksMaxLike(Bound, C);
   }

-  // Range endpoint detection helpers.
+  static bool isPlainMinLikeBound(const Expr *Bound, CheckerContext &C) {
+    if (!Bound)
+      return false;
+
+    Bound = Bound->IgnoreParenCasts();
+
+    if (isa<IntegerLiteral>(Bound)) {
+      return rhsTextLooksMinLike(Bound, C);
+    }
+
+    if (isUnarySizeOf(Bound))
+      return false;
+
+    if (isCompositeBoundExpr(Bound))
+      return false;
+
+    StringRef Name = getIdentNameFromExpr(Bound);
+    if (!Name.empty())
+      return rhsTextLooksMinLike(Bound, C);
+
+    return rhsTextLooksMinLike(Bound, C);
+  }

   static bool hasUnderscoreToken(StringRef Name, StringRef Tok) {
     SmallVector<StringRef, 8> Parts;
@@ -326,7 +374,7 @@     std::string L = toLowerCopy(Name);
     auto stripPrefix = [&](const char *Tok) {
       std::string P = std::string(Tok) + "_";
-      if (L.rfind(P, 0) == 0) // startswith
+      if (L.rfind(P, 0) == 0)
         L.erase(0, P.size());
     };
     auto stripSuffix = [&](const char *Tok) {
@@ -334,7 +382,6 @@       if (L.size() >= S.size() && L.compare(L.size() - S.size(), S.size(), S) == 0)
         L.erase(L.size() - S.size());
     };
-    // Handle both min-side and max-side tokens.
     const char *MinToks[] = {"min","start","begin","first","lo","low","lower"};
     const char *MaxToks[] = {"max","end","last","hi","high","upper"};

@@ -355,7 +402,6 @@     return rhsTextLooksMaxLike(RHS, C) || textHasMaxLike(getExprText(RHS, C));
   }

-  // Detects comparisons of the form "min_* > max_*" on the same base, which are range guards.
   static bool isMinMaxRangeGuard(const Expr *LHS, const Expr *RHS, CheckerContext &C) {
     StringRef LName = getIdentNameFromExpr(LHS);
     StringRef RName = getIdentNameFromExpr(RHS);
@@ -490,7 +536,7 @@   static bool isEnumIdMaxGuard(const Expr *LHS, const Expr *RHS, CheckerContext &C) {
     StringRef LName = getIdentNameFromExpr(LHS);
     StringRef RName = getIdentNameFromExpr(RHS);
-    StringRef RText = getExprText(RHS, C); // Use source text to catch macros that expand to literals.
+    StringRef RText = getExprText(RHS, C);

     bool LLooksEnum = looksLikeEnumFieldName(LName);
     bool RLooksEnumMax = looksLikeEnumMaxNameOrText(RName) || looksLikeEnumMaxNameOrText(RText);
@@ -516,7 +562,7 @@     if (isEnumIdMaxGuard(LHS, RHS, C))
       return true;

-    // New: Exclude "min vs max" range validity guards.
+    // Exclude min vs max guard on same base
     if (isMinMaxRangeGuard(LHS, RHS, C))
       return true;

@@ -545,6 +591,32 @@       collectGtComparisons(CO->getCond(), Out);
       collectGtComparisons(CO->getTrueExpr(), Out);
       collectGtComparisons(CO->getFalseExpr(), Out);
+      return;
+    }
+  }
+
+  static void collectLtLeComparisons(const Expr *E,
+                                     llvm::SmallVectorImpl<const BinaryOperator*> &Out) {
+    if (!E)
+      return;
+    E = E->IgnoreParenImpCasts();
+
+    if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+      if (BO->getOpcode() == BO_LAnd || BO->getOpcode() == BO_LOr) {
+        collectLtLeComparisons(BO->getLHS(), Out);
+        collectLtLeComparisons(BO->getRHS(), Out);
+        return;
+      }
+      if (BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE) {
+        Out.push_back(BO);
+        return;
+      }
+    }
+
+    if (const auto *CO = dyn_cast<ConditionalOperator>(E)) {
+      collectLtLeComparisons(CO->getCond(), Out);
+      collectLtLeComparisons(CO->getTrueExpr(), Out);
+      collectLtLeComparisons(CO->getFalseExpr(), Out);
       return;
     }
   }
@@ -573,95 +645,204 @@     return false;
   }

-  // Detect the 1-based ordinal guard pattern for the same LHS symbol:
-  // "!x" or "x == 0" or "x <= 0" or "x < 1"
-  static bool hasZeroOrOneGuardForVar(const Expr *E, const Expr *LHSVar, CheckerContext &C) {
-    if (!E || !LHSVar) return false;
-    E = E->IgnoreParenImpCasts();
-
-    if (const auto *UO = dyn_cast<UnaryOperator>(E)) {
-      if (UO->getOpcode() == UO_LNot) {
-        const Expr *Sub = UO->getSubExpr()->IgnoreParenImpCasts();
-        if (sameReferencedVar(Sub, LHSVar))
+  static bool areEquivalentExprs(const Expr *A, const Expr *B, CheckerContext &C) {
+    if (!A || !B) return false;
+    A = A->IgnoreParenCasts();
+    B = B->IgnoreParenCasts();
+
+    if (A == B) return true;
+
+    if (const auto *DA = dyn_cast<DeclRefExpr>(A)) {
+      if (const auto *DB = dyn_cast<DeclRefExpr>(B))
+        return DA->getDecl()->getCanonicalDecl() == DB->getDecl()->getCanonicalDecl();
+    }
+
+    if (const auto *MA = dyn_cast<MemberExpr>(A)) {
+      if (const auto *MB = dyn_cast<MemberExpr>(B)) {
+        if (MA->getMemberDecl()->getCanonicalDecl() != MB->getMemberDecl()->getCanonicalDecl())
+          return false;
+        return areEquivalentExprs(MA->getBase(), MB->getBase(), C);
+      }
+    }
+
+    if (const auto *AA = dyn_cast<ArraySubscriptExpr>(A)) {
+      if (const auto *AB = dyn_cast<ArraySubscriptExpr>(B)) {
+        return areEquivalentExprs(AA->getBase(), AB->getBase(), C) &&
+               areEquivalentExprs(AA->getIdx(), AB->getIdx(), C);
+      }
+    }
+
+    if (const auto *UA = dyn_cast<UnaryOperator>(A)) {
+      if (const auto *UB = dyn_cast<UnaryOperator>(B)) {
+        if (UA->getOpcode() != UB->getOpcode())
+          return false;
+        return areEquivalentExprs(UA->getSubExpr(), UB->getSubExpr(), C);
+      }
+    }
+
+    StringRef TA = getExprText(A, C);
+    StringRef TB = getExprText(B, C);
+    return !TA.empty() && TA == TB;
+  }
+
+  static bool hasPairedLowerBoundGuardForArrayLHS(const Expr *FullCond, const Expr *LHSCand, CheckerContext &C) {
+    const auto *ASE = dyn_cast_or_null<ArraySubscriptExpr>(LHSCand ? LHSCand->IgnoreParenCasts() : nullptr);
+    if (!ASE || !FullCond)
+      return false;
+
+    llvm::SmallVector<const BinaryOperator*, 8> LtComps;
+    collectLtLeComparisons(FullCond, LtComps);
+
+    for (const BinaryOperator *BO : LtComps) {
+      const Expr *L = BO->getLHS()->IgnoreParenCasts();
+      const Expr *R = BO->getRHS()->IgnoreParenCasts();
+
+      if (!areEquivalentExprs(L, ASE, C))
+        continue;
+
+      bool MinLike = isPlainMinLikeBound(R, C);
+      if (!MinLike) {
+        if (const auto *IL = dyn_cast<IntegerLiteral>(R)) {
+          uint64_t V = IL->getValue().getLimitedValue();
+          if (V <= 1)
+            MinLike = true;
+        }
+      }
+      if (MinLike)
+        return true;
+    }
+    return false;
+  }
+
+  static bool hasPairedLowerBoundGuardForSameLHS(const Expr *FullCond, const Expr *LHS, CheckerContext &C) {
+    if (!FullCond || !LHS) return false;
+
+    // Look for: LHS < MIN or LHS <= MIN
+    llvm::SmallVector<const BinaryOperator*, 8> LtComps;
+    collectLtLeComparisons(FullCond, LtComps);
+    for (const BinaryOperator *BO : LtComps) {
+      const Expr *L = BO->getLHS()->IgnoreParenCasts();
+      const Expr *R = BO->getRHS()->IgnoreParenCasts();
+
+      if (areEquivalentExprs(L, LHS, C) && isPlainMinLikeBound(R, C))
+        return true;
+      if (areEquivalentExprs(R, LHS, C) && isPlainMinLikeBound(L, C))
+        return true;
+    }
+
+    // Also accept reversed-form lower bound: MIN > LHS or MIN >= LHS
+    llvm::SmallVector<const BinaryOperator*, 8> GtComps;
+    collectGtComparisons(FullCond, GtComps);
+    for (const BinaryOperator *BO : GtComps) {
+      const Expr *L = BO->getLHS()->IgnoreParenCasts();
+      const Expr *R = BO->getRHS()->IgnoreParenCasts();
+      if (isPlainMinLikeBound(L, C) && areEquivalentExprs(R, LHS, C))
+        return true;
+    }
+
+    return false;
+  }
+
+  static bool isControlValueArrayAccess(const ArraySubscriptExpr *ASE, CheckerContext &C) {
+    if (!ASE) return false;
+    const Expr *Idx = ASE->getIdx()->IgnoreParenCasts();
+    if (!isa<IntegerLiteral>(Idx))
+      return false;
+
+    uint64_t V = cast<IntegerLiteral>(Idx)->getValue().getLimitedValue();
+    if (V != 0)
+      return false;
+
+    StringRef BaseTxt = getExprText(ASE->getBase(), C);
+    std::string L = toLowerCopy(BaseTxt);
+    bool HasControlTok = (L.find("ucontrol") != std::string::npos) ||
+                         (L.find("kcontrol") != std::string::npos) ||
+                         (L.find("control") != std::string::npos) ||
+                         (L.find("ctl") != std::string::npos);
+    bool HasValueTok = (L.find("value") != std::string::npos) ||
+                        (L.find("val") != std::string::npos);
+    return HasControlTok && HasValueTok;
+  }
+
+  static bool exprReferencesVar(const Expr *E, const Decl *Var) {
+    if (!E || !Var) return false;
+    E = E->IgnoreParenCasts();
+    if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {
+      return DRE->getDecl()->getCanonicalDecl() == Var->getCanonicalDecl();
+    }
+    if (const auto *ME = dyn_cast<MemberExpr>(E)) {
+      return ME->getMemberDecl()->getCanonicalDecl() == Var->getCanonicalDecl();
+    }
+    for (const Stmt *Child : E->children()) {
+      if (!Child) continue;
+      if (const auto *CE = dyn_cast<Expr>(Child))
+        if (exprReferencesVar(CE, Var))
           return true;
-      }
-      return hasZeroOrOneGuardForVar(UO->getSubExpr(), LHSVar, C);
-    }
-
-    if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
-      BinaryOperatorKind Op = BO->getOpcode();
-      if (Op == BO_LAnd || Op == BO_LOr) {
-        return hasZeroOrOneGuardForVar(BO->getLHS(), LHSVar, C) ||
-               hasZeroOrOneGuardForVar(BO->getRHS(), LHSVar, C);
-      }
-
-      const Expr *L = BO->getLHS()->IgnoreParenImpCasts();
-      const Expr *R = BO->getRHS()->IgnoreParenImpCasts();
-
-      auto checkVarZero = [&](const Expr *VarSide, const Expr *OtherSide, BinaryOperatorKind Op2) -> bool {
-        if (!sameReferencedVar(VarSide, LHSVar))
-          return false;
-        if (Op2 == BO_EQ && isIntLiteralEqual(OtherSide, 0))
+    }
+    return false;
+  }
+
+  static bool stmtContainsIndexUseOfVar(const Stmt *S, const Decl *Var) {
+    if (!S || !Var) return false;
+    if (const auto *E = dyn_cast<Expr>(S)) {
+      const Expr *EI = E->IgnoreParenCasts();
+      if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(EI)) {
+        const Expr *Idx = ASE->getIdx()->IgnoreParenCasts();
+        if (exprReferencesVar(Idx, Var))
           return true;
-        if (Op2 == BO_LE && isIntLiteralEqual(OtherSide, 0))
-          return true;
-        if (Op2 == BO_LT && isIntLiteralEqual(OtherSide, 1))
-          return true;
-        return false;
-      };
-
-      if (checkVarZero(L, R, Op) || checkVarZero(R, L, Op))
-        return true;
-
-      return hasZeroOrOneGuardForVar(BO->getLHS(), LHSVar, C) ||
-             hasZeroOrOneGuardForVar(BO->getRHS(), LHSVar, C);
-    }
-
-    if (const auto *CO = dyn_cast<ConditionalOperator>(E)) {
-      return hasZeroOrOneGuardForVar(CO->getCond(), LHSVar, C) ||
-             hasZeroOrOneGuardForVar(CO->getTrueExpr(), LHSVar, C) ||
-             hasZeroOrOneGuardForVar(CO->getFalseExpr(), LHSVar, C);
-    }
-
-    return false;
-  }
-
-  // Enhanced to use RHS context for range-endpoint suppression.
-  static bool isLikelyIndexExpr(const Expr *E, const Expr *RHSForContext = nullptr, CheckerContext *PCtx = nullptr) {
-    E = E ? E->IgnoreParenCasts() : nullptr;
-    if (!E)
-      return false;
-
-    if (isa<IntegerLiteral>(E))
-      return false;
-
-    // Array indexing is always index-like.
-    if (isa<ArraySubscriptExpr>(E))
-      return true;
-
-    StringRef Name = getIdentNameFromExpr(E);
-    if (!Name.empty()) {
-      if (nameLooksLikeLengthOrSize(Name))
-        return false;
-      // New: exclude count/ordinal-like names from being treated as indices.
-      if (looksLikeCountOrOrdinalName(Name))
-        return false;
-      // If LHS name looks like a range "min/start/lo" endpoint, and RHS is max-like, suppress.
-      if (nameHasTokenMin(Name)) {
-        if (RHSForContext && PCtx) {
-          if (rhsHasMaxTokenOrText(RHSForContext, *PCtx))
-            return false;
-        }
-      }
-    }
-
-    if (isa<DeclRefExpr>(E) || isa<MemberExpr>(E))
-      return true;
-
-    return false;
-  }
-
-  bool isCandidateGtComparison(const BinaryOperator *BO, CheckerContext &C) const {
+      }
+    }
+    for (const Stmt *Child : S->children()) {
+      if (Child && stmtContainsIndexUseOfVar(Child, Var))
+        return true;
+    }
+    return false;
+  }
+
+  static bool varUsedAsIndexInElseOrAfter(const IfStmt *IS, const Decl *Var, CheckerContext &C) {
+    if (!IS || !Var) return false;
+
+    // Check Else branch
+    if (const Stmt *ElseS = IS->getElse()) {
+      if (stmtContainsIndexUseOfVar(ElseS, Var))
+        return true;
+    }
+
+    // Check subsequent statements in the parent CompoundStmt
+    const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(IS, C);
+    if (!CS) return false;
+    bool SeenIf = false;
+    for (const Stmt *S : CS->body()) {
+      if (!SeenIf) {
+        if (S == IS)
+          SeenIf = true;
+        continue;
+      }
+      if (!S) continue;
+      if (stmtContainsIndexUseOfVar(S, Var))
+        return true;
+    }
+    return false;
+  }
+
+  static const FunctionDecl* getEnclosingFunctionDecl(CheckerContext &C) {
+    const LocationContext *LCtx = C.getLocationContext();
+    while (LCtx) {
+      if (const auto *FD = dyn_cast_or_null<FunctionDecl>(LCtx->getDecl()))
+        return FD;
+      LCtx = LCtx->getParent();
+    }
+    return nullptr;
+  }
+
+  static bool functionContainsIndexUseOfVar(const FunctionDecl *FD, const Decl *Var) {
+    if (!FD || !Var) return false;
+    const Stmt *Body = FD->getBody();
+    if (!Body) return false;
+    return stmtContainsIndexUseOfVar(Body, Var);
+  }
+
+  bool isCandidateGtComparison(const BinaryOperator *BO, const IfStmt *EnclosingIf, const Expr *FullCond, CheckerContext &C) const {
     if (!BO || BO->getOpcode() != BO_GT)
       return false;

@@ -671,21 +852,37 @@     if (!LHS || !RHS)
       return false;

-    // LHS should look like an index. Exclude size/len fields and min/max range endpoints.
-    if (!isLikelyIndexExpr(LHS, RHS, &C))
-      return false;
-
-    // RHS should be a named MAX-like bound (including macros that expand to integers).
+    // Require strong evidence of index-ness:
+    bool LHSIsArray = isa<ArraySubscriptExpr>(LHS);
+
+    const Decl *Var = getReferencedDecl(LHS);
+    bool UsedAsIndexElseOrAfter = Var ? varUsedAsIndexInElseOrAfter(EnclosingIf, Var, C) : false;
+    bool UsedAsIndexSomewhere = Var ? functionContainsIndexUseOfVar(getEnclosingFunctionDecl(C), Var) : false;
+
+    if (!LHSIsArray && !UsedAsIndexElseOrAfter && !UsedAsIndexSomewhere)
+      return false;
+
+    // Suppress if there's also a lower-bound paired guard on the same LHS in the same condition,
+    // unless LHS is an actual array subscript (already passed above).
+    if (hasPairedLowerBoundGuardForArrayLHS(FullCond, LHS, C))
+      return false;
+
     if (!isPlainMaxLikeBound(RHS, C))
       return false;

-    // Avoid comparisons that are about buffer capacity/length, not indexing.
     if (isBufferCapacityComparison(LHS, RHS, C))
       return false;

-    // Exclude known false positives (e.g., bit-width checks, enum ID guards, min/max range).
     if (isFalsePositive(LHS, RHS, C))
       return false;
+
+    // Additional conservative suppression: if LHS is not an array subscript and the LHS name
+    // looks like a size/length metric, don't warn (sizes aren't indices).
+    if (!LHSIsArray) {
+      StringRef LName = getIdentNameFromExpr(LHS);
+      if (nameLooksLikeLengthOrSize(LName))
+        return false;
+    }

     return true;
   }
@@ -710,17 +907,19 @@   if (GtComps.empty())
     return;

-  // The Then branch should look like an errno-style error path.
   if (!thenBranchHasEarlyErrorReturn(IS, C))
     return;

   for (const BinaryOperator *BO : GtComps) {
-    if (!isCandidateGtComparison(BO, C))
+    if (!isCandidateGtComparison(BO, IS, CondE, C))
       continue;

-    // Suppress the common 1-based ordinal check: (!x || x == 0/<=0/<1) || (x > Bound)
-    if (hasZeroOrOneGuardForVar(CondE, BO->getLHS(), C))
-      continue;
+    if (hasPairedLowerBoundGuardForSameLHS(CondE, BO->getLHS(), C)) {
+      // If there's a paired lower-bound guard, we have to be more certain;
+      // LHS will only pass earlier if it's an array or used as index elsewhere.
+      // So we just keep the suppression in isCandidateGtComparison.
+      // Nothing to do here.
+    }

     ExplodedNode *N = C.generateNonFatalErrorNode();
     if (!N)
@@ -732,7 +931,6 @@         N);
     R->addRange(BO->getSourceRange());
     C.emitReport(std::move(R));
-    // Report only once per If condition.
     return;
   }
 }
