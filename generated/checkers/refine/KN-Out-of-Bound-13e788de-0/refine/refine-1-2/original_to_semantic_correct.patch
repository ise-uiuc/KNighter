--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -42,6 +42,7 @@   return maxVal;
 }

+// The expression should be the DeclRefExpr of the array
 bool getArraySizeFromExpr(llvm::APInt &ArraySize, const Expr *E) {
   if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E->IgnoreImplicit())) {
     if (const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl())) {
@@ -325,6 +326,7 @@   }

   // Specific false-positive filters.
+
   static bool containsBitsToken(StringRef S) {
     StringRef L = S.lower();
     return L.contains("bit") || L.contains("bits");
@@ -357,6 +359,92 @@     return (HasBitsToken || LHSCallHasBits) && RHSIsBitWidthLiteral;
   }

+  // Helper to test underscore-delimited token presence without matching substrings like "guid" or "idx".
+  static bool hasUnderscoreToken(StringRef Name, StringRef Tok) {
+    SmallVector<StringRef, 8> Parts;
+    Name.split(Parts, '_', /*MaxSplit*/-1, /*KeepEmpty*/false);
+    for (StringRef P : Parts)
+      if (P.equals_insensitive(Tok))
+        return true;
+    return false;
+  }
+
+  static bool looksLikeEnumFieldName(StringRef Name) {
+    if (Name.empty())
+      return false;
+    // Exact matches commonly used for enums.
+    if (Name.equals_insensitive("id") ||
+        Name.equals_insensitive("type") ||
+        Name.equals_insensitive("mode") ||
+        Name.equals_insensitive("state") ||
+        Name.equals_insensitive("kind") ||
+        Name.equals_insensitive("class") ||
+        Name.equals_insensitive("family") ||
+        Name.equals_insensitive("proto") ||
+        Name.equals_insensitive("protocol") ||
+        Name.equals_insensitive("prio") ||
+        Name.equals_insensitive("level") ||
+        Name.equals_insensitive("opcode") ||
+        Name.equals_insensitive("op"))
+      return true;
+
+    // Underscore-separated suffix/prefix tokens.
+    if (hasUnderscoreToken(Name, "id") ||
+        hasUnderscoreToken(Name, "type") ||
+        hasUnderscoreToken(Name, "mode") ||
+        hasUnderscoreToken(Name, "state") ||
+        hasUnderscoreToken(Name, "kind") ||
+        hasUnderscoreToken(Name, "class") ||
+        hasUnderscoreToken(Name, "family") ||
+        hasUnderscoreToken(Name, "proto") ||
+        hasUnderscoreToken(Name, "protocol") ||
+        hasUnderscoreToken(Name, "prio") ||
+        hasUnderscoreToken(Name, "level") ||
+        hasUnderscoreToken(Name, "opcode") ||
+        hasUnderscoreToken(Name, "op"))
+      return true;
+
+    return false;
+  }
+
+  static bool looksLikeEnumMaxNameOrText(StringRef NOrText) {
+    if (NOrText.empty())
+      return false;
+    StringRef L = NOrText.lower();
+    // Strong signal: contains "id_max".
+    if (L.contains("id_max"))
+      return true;
+
+    // Common enum MAX tokenization: <token>_max or max_<token>.
+    static constexpr const char *EnumTokens[] = {
+        "id","type","mode","state","kind","class","family","proto","protocol","prio","level","opcode","op"
+    };
+    for (const char *Tok : EnumTokens) {
+      std::string pat1 = std::string(Tok) + "_max";
+      std::string pat2 = std::string("max_") + Tok;
+      if (L.contains(pat1) || L.contains(pat2))
+        return true;
+    }
+
+    // Generic fallback: name contains both "id" and "max" tokens (underscore separated preferred).
+    if ((L.contains("max") && hasUnderscoreToken(NOrText, "id")) ||
+        (L.contains("id") && L.contains("max")))
+      return true;
+
+    return false;
+  }
+
+  static bool isEnumIdMaxGuard(const Expr *LHS, const Expr *RHS, CheckerContext &C) {
+    // Determine if this comparison is guarding an enumeration-like ID against its *_ID_MAX sentinel.
+    StringRef LName = getIdentNameFromExpr(LHS);
+    StringRef RName = getIdentNameFromExpr(RHS);
+    StringRef RText = getExprText(RHS, C); // Use source text to catch macros that expand to literals.
+
+    bool LLooksEnum = looksLikeEnumFieldName(LName);
+    bool RLooksEnumMax = looksLikeEnumMaxNameOrText(RName) || looksLikeEnumMaxNameOrText(RText);
+    return LLooksEnum && RLooksEnumMax;
+  }
+
   static bool isFalsePositive(const Expr *LHS, const Expr *RHS, CheckerContext &C) {
     const Expr *R = RHS ? RHS->IgnoreParenCasts() : nullptr;
     if (!R)
@@ -374,6 +462,10 @@
     // Exclude bit-width style guards (e.g., "foo_bits(...) > 32").
     if (isBitWidthStyleGuard(LHS, RHS, C))
+      return true;
+
+    // Exclude enumeration ID guards like "id > ID_MAX" or "type > TYPE_MAX".
+    if (isEnumIdMaxGuard(LHS, RHS, C))
       return true;

     return false;
@@ -427,7 +519,7 @@     if (isBufferCapacityComparison(LHS, RHS, C))
       return false;

-    // Exclude known false positives (e.g., bit-width checks).
+    // Exclude known false positives (e.g., bit-width checks, enum ID guards).
     if (isFalsePositive(LHS, RHS, C))
       return false;
