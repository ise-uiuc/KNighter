--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -189,14 +189,12 @@     if (Name.empty())
       return false;
     std::string L = toLowerCopy(Name);
-    // Strong index-like tokens and common short loop indices.
     static const char *IndexToks[] = {
       "idx","index","ind","pos","slot","cursor","off","offset","ix"
     };
     for (const char *Tok : IndexToks)
       if (L.find(Tok) != std::string::npos)
         return true;
-    // Single-letter loop indices are also index-like.
     if (L == "i" || L == "j" || L == "k")
       return true;
     return false;
@@ -308,7 +306,7 @@
     StringRef Name = getIdentNameFromExpr(Bound);
     if (!Name.empty())
-      return nameLooksLikeCapacityOrMax(Name); // Do not treat *_count/*_num as MAX-like.
+      return nameLooksLikeCapacityOrMax(Name);

     return rhsTextLooksMaxLike(Bound, C);
   }
@@ -335,8 +333,6 @@
     return rhsTextLooksMinLike(Bound, C);
   }
-
-  // Range endpoint detection helpers.

   static bool hasUnderscoreToken(StringRef Name, StringRef Tok) {
     SmallVector<StringRef, 8> Parts;
@@ -378,7 +374,7 @@     std::string L = toLowerCopy(Name);
     auto stripPrefix = [&](const char *Tok) {
       std::string P = std::string(Tok) + "_";
-      if (L.rfind(P, 0) == 0) // startswith
+      if (L.rfind(P, 0) == 0)
         L.erase(0, P.size());
     };
     auto stripSuffix = [&](const char *Tok) {
@@ -406,7 +402,6 @@     return rhsTextLooksMaxLike(RHS, C) || textHasMaxLike(getExprText(RHS, C));
   }

-  // Detects comparisons of the form "min_* > max_*" on the same base, which are range guards.
   static bool isMinMaxRangeGuard(const Expr *LHS, const Expr *RHS, CheckerContext &C) {
     StringRef LName = getIdentNameFromExpr(LHS);
     StringRef RName = getIdentNameFromExpr(RHS);
@@ -541,7 +536,7 @@   static bool isEnumIdMaxGuard(const Expr *LHS, const Expr *RHS, CheckerContext &C) {
     StringRef LName = getIdentNameFromExpr(LHS);
     StringRef RName = getIdentNameFromExpr(RHS);
-    StringRef RText = getExprText(RHS, C); // Use source text to catch macros that expand to literals.
+    StringRef RText = getExprText(RHS, C);

     bool LLooksEnum = looksLikeEnumFieldName(LName);
     bool RLooksEnumMax = looksLikeEnumMaxNameOrText(RName) || looksLikeEnumMaxNameOrText(RText);
@@ -567,7 +562,7 @@     if (isEnumIdMaxGuard(LHS, RHS, C))
       return true;

-    // New: Exclude "min vs max" range validity guards.
+    // Exclude min vs max guard on same base
     if (isMinMaxRangeGuard(LHS, RHS, C))
       return true;

@@ -650,7 +645,6 @@     return false;
   }

-  // Structural equality for expressions used to compare if two LHS expressions are the "same".
   static bool areEquivalentExprs(const Expr *A, const Expr *B, CheckerContext &C) {
     if (!A || !B) return false;
     A = A->IgnoreParenCasts();
@@ -686,13 +680,11 @@       }
     }

-    // Fallback to textual match for common simple cases (macros, etc.).
     StringRef TA = getExprText(A, C);
     StringRef TB = getExprText(B, C);
     return !TA.empty() && TA == TB;
   }

-  // Detect if the current '>' comparison on an ArraySubscriptExpr LHS is paired with a lower-bound guard (x < MIN).
   static bool hasPairedLowerBoundGuardForArrayLHS(const Expr *FullCond, const Expr *LHSCand, CheckerContext &C) {
     const auto *ASE = dyn_cast_or_null<ArraySubscriptExpr>(LHSCand ? LHSCand->IgnoreParenCasts() : nullptr);
     if (!ASE || !FullCond)
@@ -708,7 +700,6 @@       if (!areEquivalentExprs(L, ASE, C))
         continue;

-      // RHS named MIN-like, or small integer literal (0/1)
       bool MinLike = isPlainMinLikeBound(R, C);
       if (!MinLike) {
         if (const auto *IL = dyn_cast<IntegerLiteral>(R)) {
@@ -723,7 +714,36 @@     return false;
   }

-  // Recognize scalar-control-style one-element array access (e.g., ucontrol->value.integer.value[0]).
+  // New: Detect that the same LHS participates in a paired lower-bound range guard within the same condition.
+  static bool hasPairedLowerBoundGuardForSameLHS(const Expr *FullCond, const Expr *LHS, CheckerContext &C) {
+    if (!FullCond || !LHS) return false;
+
+    // Look for: LHS < MIN or LHS <= MIN
+    llvm::SmallVector<const BinaryOperator*, 8> LtComps;
+    collectLtLeComparisons(FullCond, LtComps);
+    for (const BinaryOperator *BO : LtComps) {
+      const Expr *L = BO->getLHS()->IgnoreParenCasts();
+      const Expr *R = BO->getRHS()->IgnoreParenCasts();
+
+      if (areEquivalentExprs(L, LHS, C) && isPlainMinLikeBound(R, C))
+        return true;
+      if (areEquivalentExprs(R, LHS, C) && isPlainMinLikeBound(L, C))
+        return true;
+    }
+
+    // Also accept reversed-form lower bound: MIN > LHS or MIN >= LHS
+    llvm::SmallVector<const BinaryOperator*, 8> GtComps;
+    collectGtComparisons(FullCond, GtComps);
+    for (const BinaryOperator *BO : GtComps) {
+      const Expr *L = BO->getLHS()->IgnoreParenCasts();
+      const Expr *R = BO->getRHS()->IgnoreParenCasts();
+      if (isPlainMinLikeBound(L, C) && areEquivalentExprs(R, LHS, C))
+        return true;
+    }
+
+    return false;
+  }
+
   static bool isControlValueArrayAccess(const ArraySubscriptExpr *ASE, CheckerContext &C) {
     if (!ASE) return false;
     const Expr *Idx = ASE->getIdx()->IgnoreParenCasts();
@@ -734,7 +754,6 @@     if (V != 0)
       return false;

-    // Heuristic: base expression text contains tokens like 'ucontrol'/'control' and 'value'.
     StringRef BaseTxt = getExprText(ASE->getBase(), C);
     std::string L = toLowerCopy(BaseTxt);
     bool HasControlTok = (L.find("ucontrol") != std::string::npos) ||
@@ -746,8 +765,6 @@     return HasControlTok && HasValueTok;
   }

-  // Detect the 1-based ordinal guard pattern for the same LHS symbol:
-  // "!x" or "x == 0" or "x <= 0" or "x < 1"
   static bool hasZeroOrOneGuardForVar(const Expr *E, const Expr *LHSVar, CheckerContext &C) {
     if (!E || !LHSVar) return false;
     E = E->IgnoreParenImpCasts();
@@ -799,7 +816,6 @@     return false;
   }

-  // Enhanced to use RHS context for range-endpoint suppression.
   static bool isLikelyIndexExpr(const Expr *E, const Expr *RHSForContext = nullptr, CheckerContext *PCtx = nullptr) {
     E = E ? E->IgnoreParenCasts() : nullptr;
     if (!E)
@@ -808,18 +824,14 @@     if (isa<IntegerLiteral>(E))
       return false;

-    // Array indexing is typically index-like, but exclude scalar-control idioms.
     if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(E)) {
-      // Exclude constant-subscript forms like arr[0].
       const Expr *Idx = ASE->getIdx()->IgnoreParenCasts();
       if (isa<IntegerLiteral>(Idx))
         return false;

-      // Exclude "ucontrol/kcontrol/...->value[0]" style scalar control arrays.
-      if (isControlValueArrayAccess(ASE, *PCtx))
+      if (PCtx && isControlValueArrayAccess(ASE, *PCtx))
         return false;

-      // If base's terminal name is 'value' or 'val', likely not an index.
       StringRef BaseName = getIdentNameFromExpr(ASE->getBase());
       if (BaseName.equals_insensitive("value") || BaseName.equals_insensitive("val"))
         return false;
@@ -831,10 +843,8 @@     if (!Name.empty()) {
       if (nameLooksLikeLengthOrSize(Name))
         return false;
-      // New: exclude count/ordinal-like names from being treated as indices.
       if (looksLikeCountOrOrdinalName(Name))
         return false;
-      // If LHS name looks like a range "min/start/lo" endpoint, and RHS is max-like, suppress.
       if (nameHasTokenMin(Name)) {
         if (RHSForContext && PCtx) {
           if (rhsHasMaxTokenOrText(RHSForContext, *PCtx))
@@ -849,13 +859,15 @@     return false;
   }

-  // Helper: does expression E reference the given VarDecl (by DeclRefExpr)?
   static bool exprReferencesVar(const Expr *E, const Decl *Var) {
     if (!E || !Var) return false;
     E = E->IgnoreParenCasts();
     if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {
       return DRE->getDecl()->getCanonicalDecl() == Var->getCanonicalDecl();
     }
+    if (const auto *ME = dyn_cast<MemberExpr>(E)) {
+      return ME->getMemberDecl()->getCanonicalDecl() == Var->getCanonicalDecl();
+    }
     for (const Stmt *Child : E->children()) {
       if (!Child) continue;
       if (const auto *CE = dyn_cast<Expr>(Child))
@@ -865,7 +877,6 @@     return false;
   }

-  // Recursively search for array subscript expressions where 'Var' is used as index.
   static bool stmtContainsIndexUseOfVar(const Stmt *S, const Decl *Var) {
     if (!S || !Var) return false;
     if (const auto *E = dyn_cast<Expr>(S)) {
@@ -883,7 +894,6 @@     return false;
   }

-  // Search subsequent statements in the same enclosing compound for 'arr[var]' usage.
   static bool varUsedAsIndexAfterIf(const IfStmt *IS, const Decl *Var, CheckerContext &C) {
     if (!IS || !Var) return false;
     const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(IS, C);
@@ -902,7 +912,6 @@     return false;
   }

-  // Recursively search for assignments of the form "count_like_target = Var".
   static bool stmtHasCountLikeAssignmentFromVar(const Stmt *S, const Decl *Var) {
     if (!S || !Var) return false;
     if (const auto *BO = dyn_cast<BinaryOperator>(S)) {
@@ -923,7 +932,6 @@     return false;
   }

-  // Search subsequent statements in the same enclosing compound for "count_like = Var".
   static bool flowsIntoCountLikeAfterIf(const IfStmt *IS, const Decl *Var, CheckerContext &C) {
     if (!IS || !Var) return false;
     const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(IS, C);
@@ -952,50 +960,47 @@     if (!LHS || !RHS)
       return false;

-    // LHS should look like an index. Exclude size/len fields and min/max range endpoints.
     if (!isLikelyIndexExpr(LHS, RHS, &C))
       return false;

-    // Special suppression: if LHS is an ArraySubscriptExpr and the full condition also
-    // contains a paired lower-bound check on the same LHS (x < MIN), this is likely a
-    // scalar parameter range validation, not index validation.
     if (hasPairedLowerBoundGuardForArrayLHS(FullCond, LHS, C))
       return false;

-    // RHS should be a named MAX-like bound (including macros that expand to integers).
     if (!isPlainMaxLikeBound(RHS, C))
       return false;

-    // Avoid comparisons that are about buffer capacity/length, not indexing.
     if (isBufferCapacityComparison(LHS, RHS, C))
       return false;

-    // Exclude known false positives (e.g., bit-width checks, enum ID guards, min/max range).
     if (isFalsePositive(LHS, RHS, C))
       return false;

-    // Additional suppression to avoid count-setting false positives:
-    // If LHS is a plain variable (not an array subscript), require it to either:
-    //  - be strongly index-like by name, or
-    //  - be used as an array index later in the same scope after the 'if'.
-    // Also, suppress if it clearly flows into a count-like assignment later.
-    if (!isa<ArraySubscriptExpr>(LHS)) {
-      if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS)) {
-        const Decl *Var = DRE->getDecl()->getCanonicalDecl();
+    // New suppression: If the condition also has a paired lower-bound guard on the same LHS,
+    // suppress unless the LHS is clearly index-like or used as an array index later.
+    if (hasPairedLowerBoundGuardForSameLHS(FullCond, LHS, C)) {
+      if (!isa<ArraySubscriptExpr>(LHS)) {
+        const Decl *Var = getReferencedDecl(LHS);
         StringRef LName = getIdentNameFromExpr(LHS);
         bool StrongIndexName = looksLikeIndexName(LName);
-
-        bool UsedAsIndexLater = varUsedAsIndexAfterIf(EnclosingIf, Var, C);
-        bool FlowsToCount = flowsIntoCountLikeAfterIf(EnclosingIf, Var, C);
-
-        // If this value is used to set a count-like field, treat this as capacity validation, not index validation.
-        if (FlowsToCount)
-          return false;
-
-        // If not strongly index-like and not used later as an index, suppress.
+        bool UsedAsIndexLater = Var ? varUsedAsIndexAfterIf(EnclosingIf, Var, C) : false;
         if (!StrongIndexName && !UsedAsIndexLater)
           return false;
       }
+    }
+
+    // For non-array LHS, require strong evidence of index-ness, and check flows-to-count.
+    if (!isa<ArraySubscriptExpr>(LHS)) {
+      const Decl *Var = getReferencedDecl(LHS);
+      StringRef LName = getIdentNameFromExpr(LHS);
+      bool StrongIndexName = looksLikeIndexName(LName);
+      bool UsedAsIndexLater = Var ? varUsedAsIndexAfterIf(EnclosingIf, Var, C) : false;
+      bool FlowsToCount = Var ? flowsIntoCountLikeAfterIf(EnclosingIf, Var, C) : false;
+
+      if (FlowsToCount)
+        return false;
+
+      if (!StrongIndexName && !UsedAsIndexLater)
+        return false;
     }

     return true;
@@ -1021,7 +1026,6 @@   if (GtComps.empty())
     return;

-  // The Then branch should look like an errno-style error path.
   if (!thenBranchHasEarlyErrorReturn(IS, C))
     return;

@@ -1029,7 +1033,6 @@     if (!isCandidateGtComparison(BO, IS, CondE, C))
       continue;

-    // Suppress the common 1-based ordinal check: (!x || x == 0/<=0/<1) || (x > Bound)
     if (hasZeroOrOneGuardForVar(CondE, BO->getLHS(), C))
       continue;

@@ -1043,7 +1046,6 @@         N);
     R->addRange(BO->getSourceRange());
     C.emitReport(std::move(R));
-    // Report only once per If condition.
     return;
   }
 }
