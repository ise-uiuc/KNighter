### Report Summary

File:| /scratch/chenyuan-data/linux-debug/samples/v4l/v4l2-pci-skeleton.c
---|---
Warning:| line 595, column 15
Off-by-one bound check: use '>= MAX' instead of '> MAX' for index validation

### Annotated Source Code


542   | /*
543   |  * Query the current timings as seen by the hardware. This function shall
544   |  * never actually change the timings, it just detects and reports.
545   |  * If no signal is detected, then return -ENOLINK. If the hardware cannot
546   |  * lock to the signal, then return -ENOLCK. If the signal is out of range
547   |  * of the capabilities of the system (e.g., it is possible that the receiver
548   |  * can lock but that the DMA engine it is connected to cannot handle
549   |  * pixelclocks above a certain frequency), then -ERANGE is returned.
550   |  */
551   | static int skeleton_query_dv_timings(struct file *file, void *_fh,
552   |  struct v4l2_dv_timings *timings)
553   | {
554   |  struct skeleton *skel = video_drvdata(file);
555   |
556   |  /* QUERY_DV_TIMINGS is not supported on the S-Video input */
557   |  if (skel->input == 0)
558   |  return -ENODATA;
559   |
560   | #ifdef TODO
561   |  /*
562   |  * Query currently seen timings. This function should look
563   |  * something like this:
564   |  */
565   | 	detect_timings();
566   |  if (no_signal)
567   |  return -ENOLINK;
568   |  if (cannot_lock_to_signal)
569   |  return -ENOLCK;
570   |  if (signal_out_of_range_of_capabilities)
571   |  return -ERANGE;
572   |
573   |  /* Useful for debugging */
574   | 	v4l2_print_dv_timings(skel->v4l2_dev.name, "query_dv_timings:",
575   | 			timings, true);
576   | #endif
577   |  return 0;
578   | }
579   |
580   | static int skeleton_dv_timings_cap(struct file *file, void *fh,
581   |  struct v4l2_dv_timings_cap *cap)
582   | {
583   |  struct skeleton *skel = video_drvdata(file);
584   |
585   |  /* DV_TIMINGS_CAP is not supported on the S-Video input */
586   |  if (skel->input == 0)
587   |  return -ENODATA;
588   | 	*cap = skel_timings_cap;
589   |  return 0;
590   | }
591   |
592   | static int skeleton_enum_input(struct file *file, void *priv,
593   |  struct v4l2_input *i)
594   | {
595   |  if (i->index > 1)
    1Assuming field 'index' is <= 1→
    2←Off-by-one bound check: use '>= MAX' instead of '> MAX' for index validation
596   |  return -EINVAL;
597   |
598   | 	i->type = V4L2_INPUT_TYPE_CAMERA;
599   |  if (i->index == 0) {
600   | 		i->std = SKEL_TVNORMS;
601   |  strscpy(i->name, "S-Video", sizeof(i->name));
602   | 		i->capabilities = V4L2_IN_CAP_STD;
603   | 	} else {
604   | 		i->std = 0;
605   |  strscpy(i->name, "HDMI", sizeof(i->name));
606   | 		i->capabilities = V4L2_IN_CAP_DV_TIMINGS;
607   | 	}
608   |  return 0;
609   | }
610   |
611   | static int skeleton_s_input(struct file *file, void *priv, unsigned int i)
612   | {
613   |  struct skeleton *skel = video_drvdata(file);
614   |
615   |  if (i > 1)
616   |  return -EINVAL;
617   |
618   |  /*
619   |  * Changing the input implies a format change, which is not allowed
620   |  * while buffers for use with streaming have already been allocated.
621   |  */
622   |  if (vb2_is_busy(&skel->queue))
623   |  return -EBUSY;
624   |
625   | 	skel->input = i;
