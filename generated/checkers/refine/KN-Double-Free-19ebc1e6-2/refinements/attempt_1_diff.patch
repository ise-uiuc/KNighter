--- attempt_1_original.cpp+++ attempt_1.cpp@@ -28,8 +28,6 @@ using namespace ento;
 using namespace taint;

-// No custom program states are necessary for this structural checker.
-
 namespace {

 struct LabelInfo {
@@ -63,9 +61,10 @@               std::vector<LabelInfo> &Labels,
               std::vector<GotoInfo> &Gotos,
               std::vector<FreeSite> &Frees,
-              std::vector<AssignInfo> &Assigns)
+              std::vector<AssignInfo> &Assigns,
+              std::vector<SourceLocation> &Returns)
       : Ctx(Ctx), SM(Ctx.getSourceManager()), Labels(Labels), Gotos(Gotos),
-        Frees(Frees), Assigns(Assigns) {}
+        Frees(Frees), Assigns(Assigns), Returns(Returns) {}

   bool VisitLabelStmt(LabelStmt *L) {
     LabelInfo Info;
@@ -138,6 +137,11 @@     return true;
   }

+  bool VisitReturnStmt(ReturnStmt *RS) {
+    Returns.push_back(getExpansionLocSafe(RS->getReturnLoc()));
+    return true;
+  }
+
 private:
   ASTContext &Ctx;
   const SourceManager &SM;
@@ -145,6 +149,7 @@   std::vector<GotoInfo> &Gotos;
   std::vector<FreeSite> &Frees;
   std::vector<AssignInfo> &Assigns;
+  std::vector<SourceLocation> &Returns;

   SourceLocation getExpansionLocSafe(SourceLocation L) const {
     if (L.isInvalid())
@@ -160,7 +165,6 @@     if (!E)
       return false;
     E = E->IgnoreParenImpCasts();
-    // Use Clang's helper to decide null pointer constants
     return E->isNullPointerConstant(Ctx, Expr::NPC_ValueDependentIsNull) !=
            Expr::NPCK_NotNull;
   }
@@ -195,7 +199,6 @@     if (!S)
       return;

-    // Local simple walker to look for CallExprs
     struct LocalVisitor : public RecursiveASTVisitor<LocalVisitor> {
       LocalVisitor(const BodyScanner &Outer, const LabelDecl *L,
                    std::vector<FreeSite> &Frees)
@@ -251,11 +254,46 @@         return before(SM, L, X) && before(SM, X, R);
       }

+      static bool isSelfCleanupJump(const GotoInfo &GR, const FreeSite &FS) {
+        // A goto straight to the same cleanup label is not a restart.
+        return GR.Target && FS.CleanupLabel && (GR.Target == FS.CleanupLabel);
+      }
+
+      static bool hasReturnBarrierBetween(const SourceManager &SM,
+                                          SourceLocation FreeLoc,
+                                          SourceLocation GoLoc,
+                                          const std::vector<SourceLocation> &Returns) {
+        for (const auto &RLoc : Returns) {
+          if (strictlyBetween(SM, RLoc, FreeLoc, GoLoc))
+            return true;
+        }
+        return false;
+      }
+
+      static bool isFalsePositiveLayout(const SourceManager &SM,
+                                        SourceLocation FreeLoc,
+                                        const GotoInfo &GR,
+                                        const std::vector<SourceLocation> &Returns,
+                                        const FreeSite &FS) {
+        // Filter 1: Goto to the same cleanup label is not a restart.
+        if (isSelfCleanupJump(GR, FS))
+          return true;
+
+        // Filter 2: If a return lies between the free and the backward goto,
+        //           then the goto cannot be reached from the cleanup path,
+        //           i.e., this is not a retry/replay scenario.
+        if (hasReturnBarrierBetween(SM, FreeLoc, GR.Loc, Returns))
+          return true;
+
+        return false;
+      }
+
       void detectAndReport(const FunctionDecl *FD,
                            const std::vector<LabelInfo> &Labels,
                            const std::vector<GotoInfo> &Gotos,
                            const std::vector<FreeSite> &Frees,
                            const std::vector<AssignInfo> &Assigns,
+                           const std::vector<SourceLocation> &Returns,
                            BugReporter &BR, ASTContext &AC) const;
 };

@@ -272,11 +310,12 @@   std::vector<GotoInfo> Gotos;
   std::vector<FreeSite> Frees;
   std::vector<AssignInfo> Assigns;
-
-  BodyScanner Scanner(Ctx, Labels, Gotos, Frees, Assigns);
+  std::vector<SourceLocation> Returns;
+
+  BodyScanner Scanner(Ctx, Labels, Gotos, Frees, Assigns, Returns);
   Scanner.TraverseStmt(const_cast<Stmt *>(Body));

-  detectAndReport(FD, Labels, Gotos, Frees, Assigns, BR, Ctx);
+  detectAndReport(FD, Labels, Gotos, Frees, Assigns, Returns, BR, Ctx);
 }

 void SAGenTestChecker::detectAndReport(const FunctionDecl *FD,
@@ -284,6 +323,7 @@                                        const std::vector<GotoInfo> &Gotos,
                                        const std::vector<FreeSite> &Frees,
                                        const std::vector<AssignInfo> &Assigns,
+                                       const std::vector<SourceLocation> &Returns,
                                        BugReporter &BR, ASTContext &AC) const {
   const SourceManager &SM = AC.getSourceManager();

@@ -304,7 +344,7 @@     if (FreeLoc.isInvalid() || CleanupLoc.isInvalid())
       continue;

-    // Find a backward goto (retry) after the free.
+    // Find a backward goto (retry) after the free that does NOT target the cleanup label.
     for (const auto &GR : Gotos) {
       if (!GR.Target)
         continue;
@@ -316,6 +356,11 @@
       // Must be: free ... goto restart_label; where restart_label is before free.
       if (!(before(SM, FreeLoc, GoLoc) && before(SM, TargetLoc, FreeLoc)))
+        continue;
+
+      // Reduce false positives: discard gotos that are either to the same cleanup
+      // label, or blocked by a return between free and goto.
+      if (isFalsePositiveLayout(SM, FreeLoc, GR, Returns, FS))
         continue;

       // Safety check 1: reset to NULL between free and retry goto
@@ -347,9 +392,11 @@       for (const auto &GE : Gotos) {
         if (GE.Target != FS.CleanupLabel)
           continue;
+
         SourceLocation ELoc = GE.Loc;
         if (!before(SM, TargetLoc, ELoc))
           continue;
+
         if (Earliest) {
           if (before(SM, ELoc, Earliest->Loc)) {
             EarlyGotoToCleanup = true;
@@ -363,7 +410,6 @@       }

       if (EarlyGotoToCleanup) {
-        // Report at the free call location using a SourceLocation-based PathDiagnosticLocation.
         auto R = std::make_unique<BasicBugReport>(
             *BT,
             "Pointer freed in cleanup then retried without resetting to NULL; "
@@ -371,7 +417,6 @@             PathDiagnosticLocation(FS.FreeLoc, SM));
         R->addRange(FS.FreeCall->getSourceRange());
         BR.emitReport(std::move(R));
-        // No need to continue for more gotos for this FreeSite; one is enough.
         break;
       }
     }
