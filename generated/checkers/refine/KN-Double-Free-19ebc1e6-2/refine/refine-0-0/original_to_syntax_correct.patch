--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -28,8 +28,6 @@ using namespace ento;
 using namespace taint;

-// No custom program states are necessary for this structural checker.
-
 namespace {

 struct LabelInfo {
@@ -160,7 +158,6 @@     if (!E)
       return false;
     E = E->IgnoreParenImpCasts();
-    // Use Clang's helper to decide null pointer constants
     return E->isNullPointerConstant(Ctx, Expr::NPC_ValueDependentIsNull) !=
            Expr::NPCK_NotNull;
   }
@@ -195,7 +192,6 @@     if (!S)
       return;

-    // Local simple walker to look for CallExprs
     struct LocalVisitor : public RecursiveASTVisitor<LocalVisitor> {
       LocalVisitor(const BodyScanner &Outer, const LabelDecl *L,
                    std::vector<FreeSite> &Frees)
@@ -251,6 +247,13 @@         return before(SM, L, X) && before(SM, X, R);
       }

+      static bool isSelfCleanupJump(const GotoInfo &GR, const FreeSite &FS) {
+        // A restart candidate must not be a goto back to the same cleanup label.
+        // Such a jump cannot form a retry loop and can cause false positives,
+        // e.g. "bail: ... goto out;" which is unrelated to retrying.
+        return GR.Target && FS.CleanupLabel && (GR.Target == FS.CleanupLabel);
+      }
+
       void detectAndReport(const FunctionDecl *FD,
                            const std::vector<LabelInfo> &Labels,
                            const std::vector<GotoInfo> &Gotos,
@@ -304,9 +307,13 @@     if (FreeLoc.isInvalid() || CleanupLoc.isInvalid())
       continue;

-    // Find a backward goto (retry) after the free.
+    // Find a backward goto (retry) after the free that does NOT target the cleanup label.
     for (const auto &GR : Gotos) {
       if (!GR.Target)
+        continue;
+
+      // Important: don't treat a goto to the same cleanup label as a restart.
+      if (isSelfCleanupJump(GR, FS))
         continue;

       SourceLocation GoLoc = GR.Loc;
@@ -347,9 +354,11 @@       for (const auto &GE : Gotos) {
         if (GE.Target != FS.CleanupLabel)
           continue;
+
         SourceLocation ELoc = GE.Loc;
         if (!before(SM, TargetLoc, ELoc))
           continue;
+
         if (Earliest) {
           if (before(SM, ELoc, Earliest->Loc)) {
             EarlyGotoToCleanup = true;
@@ -363,7 +372,6 @@       }

       if (EarlyGotoToCleanup) {
-        // Report at the free call location using a SourceLocation-based PathDiagnosticLocation.
         auto R = std::make_unique<BasicBugReport>(
             *BT,
             "Pointer freed in cleanup then retried without resetting to NULL; "
@@ -371,7 +379,6 @@             PathDiagnosticLocation(FS.FreeLoc, SM));
         R->addRange(FS.FreeCall->getSourceRange());
         BR.emitReport(std::move(R));
-        // No need to continue for more gotos for this FreeSite; one is enough.
         break;
       }
     }
