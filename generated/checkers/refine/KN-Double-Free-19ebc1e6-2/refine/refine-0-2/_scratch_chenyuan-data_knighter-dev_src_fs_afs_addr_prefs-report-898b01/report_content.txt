### Report Summary

File:| fs/afs/addr_prefs.c
---|---
Warning:| line 440, column 2
Pointer freed in cleanup then retried without resetting to NULL; early goto
can double free

### Annotated Source Code


390   |  /* Allocate a candidate new list and initialise it from the old. */
391   | 	old = rcu_dereference_protected(net->address_prefs,
392   |  lockdep_is_held(&file_inode(file)->i_rwsem));
393   |
394   |  if (old)
395   | 		max_prefs = old->nr + 1;
396   |  else
397   | 		max_prefs = 1;
398   |
399   | 	psize = struct_size(old, prefs, max_prefs);
400   | 	psize = roundup_pow_of_two(psize);
401   | 	max_prefs = min_t(size_t, (psize - sizeof(*old)) / sizeof(old->prefs[0]), 255);
402   |
403   | 	ret = -ENOMEM;
404   | 	preflist = kmalloc(struct_size(preflist, prefs, max_prefs), GFP_KERNEL);
405   |  if (!preflist)
406   |  goto done;
407   |
408   |  if (old)
409   |  memcpy(preflist, old, struct_size(preflist, prefs, old->nr));
410   |  else
411   |  memset(preflist, 0, sizeof(*preflist));
412   | 	preflist->max_prefs = max_prefs;
413   |
414   |  do {
415   | 		argc = afs_split_string(&buf, argv, ARRAY_SIZE(argv));
416   |  if (argc < 0)
417   |  return argc;
418   |  if (argc < 2)
419   |  goto inval;
420   |
421   |  if (strcmp(argv[0], "add") == 0)
422   | 			ret = afs_add_address_pref(net, &preflist, argc - 1, argv + 1);
423   |  else if (strcmp(argv[0], "del") == 0)
424   | 			ret = afs_del_address_pref(net, &preflist, argc - 1, argv + 1);
425   |  else
426   |  goto inval;
427   |  if (ret < 0)
428   |  goto done;
429   | 	} while (*buf);
430   |
431   | 	preflist->version++;
432   |  rcu_assign_pointer(net->address_prefs, preflist);
433   |  /* Store prefs before version */
434   |  smp_store_release(&net->address_pref_version, preflist->version);
435   |  kfree_rcu(old, rcu);
436   | 	preflist = NULL;
437   | 	ret = 0;
438   |
439   | done:
440   |  kfree(preflist);
    Pointer freed in cleanup then retried without resetting to NULL; early goto can double free
441   | 	inode_unlock(file_inode(file));
442   |  _leave(" = %d", ret);
443   |  return ret;
444   |
445   | inval:
446   |  pr_warn("Invalid Command\n");
447   | 	ret = -EINVAL;
448   |  goto done;
449   | }
450   |
451   | /*
452   |  * Mark the priorities on an address list if the address preferences table has
453   |  * changed.  The caller must hold the RCU read lock.
454   |  */
455   | void afs_get_address_preferences_rcu(struct afs_net *net, struct afs_addr_list *alist)
456   | {
457   |  const struct afs_addr_preference_list *preflist =
458   |  rcu_dereference(net->address_prefs);
459   |  const struct sockaddr_in6 *sin6;
460   |  const struct sockaddr_in *sin;
461   |  const struct sockaddr *sa;
462   |  struct afs_addr_preference test;
463   |  enum cmp_ret cmp;
464   |  int i, j;
465   |
466   |  if (!preflist || !preflist->nr || !alist->nr_addrs ||
467   |  smp_load_acquire(&alist->addr_pref_version) == preflist->version)
468   |  return;
469   |
470   | 	test.family = AF_INET;
