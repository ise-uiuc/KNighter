--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -55,15 +55,22 @@   bool ResetToNull = false;
 };

+struct AllocInfo {
+  const VarDecl *P = nullptr;
+  const CallExpr *Call = nullptr; // allocation call assigned to P
+  SourceLocation Loc;
+};
+
 class BodyScanner : public RecursiveASTVisitor<BodyScanner> {
 public:
   BodyScanner(ASTContext &Ctx,
               std::vector<LabelInfo> &Labels,
               std::vector<GotoInfo> &Gotos,
               std::vector<FreeSite> &Frees,
-              std::vector<AssignInfo> &Assigns)
+              std::vector<AssignInfo> &Assigns,
+              std::vector<AllocInfo> &Allocs)
       : Ctx(Ctx), SM(Ctx.getSourceManager()), Labels(Labels), Gotos(Gotos),
-        Frees(Frees), Assigns(Assigns) {}
+        Frees(Frees), Assigns(Assigns), Allocs(Allocs) {}

   bool VisitLabelStmt(LabelStmt *L) {
     LabelInfo Info;
@@ -106,12 +113,24 @@     if (!VD->getType()->isAnyPointerType())
       return true;

+    // Track NULL resets
     bool IsNull = isNullPointerExpr(RHS);
     AssignInfo AI;
     AI.P = VD;
     AI.Loc = getExpansionLocSafe(BO->getExprLoc());
     AI.ResetToNull = IsNull;
     Assigns.push_back(AI);
+
+    // Track allocations assigned to the pointer
+    const CallExpr *AllocCall = nullptr;
+    if (isAllocatingExpr(RHS, AllocCall) && AllocCall) {
+      AllocInfo AL;
+      AL.P = VD;
+      AL.Call = AllocCall;
+      AL.Loc = getExpansionLocSafe(AllocCall->getExprLoc());
+      Allocs.push_back(AL);
+    }
+
     return true;
   }

@@ -122,16 +141,28 @@         continue;
       if (!VD->getType()->isAnyPointerType())
         continue;
-      if (!VD->hasInit())
-        continue;
-
-      const Expr *Init = VD->getInit();
-      bool IsNull = isNullPointerExpr(Init);
-      AssignInfo AI;
-      AI.P = VD;
-      AI.Loc = getExpansionLocSafe(VD->getLocation());
-      AI.ResetToNull = IsNull;
-      Assigns.push_back(AI);
+
+      if (VD->hasInit()) {
+        const Expr *Init = VD->getInit();
+
+        // Track NULL-initializations
+        bool IsNull = isNullPointerExpr(Init);
+        AssignInfo AI;
+        AI.P = VD;
+        AI.Loc = getExpansionLocSafe(VD->getLocation());
+        AI.ResetToNull = IsNull;
+        Assigns.push_back(AI);
+
+        // Track allocations in initializers
+        const CallExpr *AllocCall = nullptr;
+        if (isAllocatingExpr(Init, AllocCall) && AllocCall) {
+          AllocInfo AL;
+          AL.P = VD;
+          AL.Call = AllocCall;
+          AL.Loc = getExpansionLocSafe(AllocCall->getExprLoc());
+          Allocs.push_back(AL);
+        }
+      }
     }
     return true;
   }
@@ -143,6 +174,7 @@   std::vector<GotoInfo> &Gotos;
   std::vector<FreeSite> &Frees;
   std::vector<AssignInfo> &Assigns;
+  std::vector<AllocInfo> &Allocs;

   SourceLocation getExpansionLocSafe(SourceLocation L) const {
     if (L.isInvalid())
@@ -154,12 +186,67 @@     return N == "kfree" || N == "kvfree";
   }

+  static bool isAllocName(StringRef N) {
+    // Common Linux allocator names that are freed by kfree/kvfree.
+    // This list is intentionally broad to reduce FNs without
+    // exploding complexity.
+    return N == "kmalloc" ||
+           N == "kzalloc" ||
+           N == "kcalloc" ||
+           N == "kvzalloc" ||
+           N == "kvmalloc" ||
+           N == "kvmalloc_array" ||
+           N == "kmemdup" ||
+           N == "krealloc" ||
+           N == "kstrdup" ||
+           N == "kstrndup" ||
+           N == "kmalloc_array" ||
+           N == "kmemdup_nul";
+  }
+
+  static bool isPointerReturningCall(const CallExpr *CE) {
+    if (!CE)
+      return false;
+    QualType RT = CE->getType();
+    return !RT.isNull() && RT->isAnyPointerType();
+  }
+
   bool isNullPointerExpr(const Expr *E) const {
     if (!E)
       return false;
     E = E->IgnoreParenImpCasts();
     return E->isNullPointerConstant(Ctx, Expr::NPC_ValueDependentIsNull) !=
            Expr::NPCK_NotNull;
+  }
+
+  bool isAllocatingExpr(const Expr *E, const CallExpr *&OutCall) const {
+    OutCall = nullptr;
+    if (!E)
+      return false;
+    E = E->IgnoreParenImpCasts();
+    const auto *CE = dyn_cast<CallExpr>(E);
+    if (!CE)
+      return false;
+
+    const FunctionDecl *FD = CE->getDirectCallee();
+    if (FD) {
+      if (const IdentifierInfo *II = FD->getIdentifier()) {
+        if (isAllocName(II->getName())) {
+          OutCall = CE;
+          return true;
+        }
+      }
+    }
+
+    // Heuristic: any direct call returning a pointer might be an allocation-like
+    // source. Keep this as a fallback to avoid FNs where allocation helpers are
+    // not directly named kmalloc/kzalloc, etc.
+    if (isPointerReturningCall(CE)) {
+      OutCall = CE;
+      return true;
+    }
+
+    return false;
   }

   bool isFreeCallOnVar(const CallExpr *CE, const VarDecl *&OutVD) const {
@@ -249,8 +336,6 @@
       static bool isSelfCleanupJump(const GotoInfo &GR, const FreeSite &FS) {
         // A restart candidate must not be a goto back to the same cleanup label.
-        // Such a jump cannot form a retry loop and can cause false positives,
-        // e.g. "bail: ... goto out;" which is unrelated to retrying.
         return GR.Target && FS.CleanupLabel && (GR.Target == FS.CleanupLabel);
       }

@@ -259,6 +344,7 @@                            const std::vector<GotoInfo> &Gotos,
                            const std::vector<FreeSite> &Frees,
                            const std::vector<AssignInfo> &Assigns,
+                           const std::vector<AllocInfo> &Allocs,
                            BugReporter &BR, ASTContext &AC) const;
 };

@@ -275,11 +361,12 @@   std::vector<GotoInfo> Gotos;
   std::vector<FreeSite> Frees;
   std::vector<AssignInfo> Assigns;
-
-  BodyScanner Scanner(Ctx, Labels, Gotos, Frees, Assigns);
+  std::vector<AllocInfo> Allocs;
+
+  BodyScanner Scanner(Ctx, Labels, Gotos, Frees, Assigns, Allocs);
   Scanner.TraverseStmt(const_cast<Stmt *>(Body));

-  detectAndReport(FD, Labels, Gotos, Frees, Assigns, BR, Ctx);
+  detectAndReport(FD, Labels, Gotos, Frees, Assigns, Allocs, BR, Ctx);
 }

 void SAGenTestChecker::detectAndReport(const FunctionDecl *FD,
@@ -287,6 +374,7 @@                                        const std::vector<GotoInfo> &Gotos,
                                        const std::vector<FreeSite> &Frees,
                                        const std::vector<AssignInfo> &Assigns,
+                                       const std::vector<AllocInfo> &Allocs,
                                        BugReporter &BR, ASTContext &AC) const {
   const SourceManager &SM = AC.getSourceManager();

@@ -298,6 +386,34 @@     return SourceLocation();
   };

+  auto findFirstAllocBetween = [&](const VarDecl *P, SourceLocation L, SourceLocation R)
+      -> const AllocInfo* {
+    const AllocInfo *Best = nullptr;
+    for (const auto &AL : Allocs) {
+      if (AL.P != P)
+        continue;
+      if (!strictlyBetween(SM, AL.Loc, L, R))
+        continue;
+      if (!Best || before(SM, AL.Loc, Best->Loc))
+        Best = &AL;
+    }
+    return Best;
+  };
+
+  auto findFirstNullResetAfter = [&](const VarDecl *P, SourceLocation L)
+      -> const AssignInfo* {
+    const AssignInfo *Best = nullptr;
+    for (const auto &AI : Assigns) {
+      if (AI.P != P || !AI.ResetToNull)
+        continue;
+      if (!before(SM, L, AI.Loc))
+        continue;
+      if (!Best || before(SM, AI.Loc, Best->Loc))
+        Best = &AI;
+    }
+    return Best;
+  };
+
   for (const auto &FS : Frees) {
     if (!FS.P || !FS.CleanupLabel || !FS.FreeCall)
       continue;
@@ -307,12 +423,11 @@     if (FreeLoc.isInvalid() || CleanupLoc.isInvalid())
       continue;

-    // Find a backward goto (retry) after the free that does NOT target the cleanup label.
+    // Find a backward goto (potential retry) after the free that does NOT target the cleanup label.
     for (const auto &GR : Gotos) {
       if (!GR.Target)
         continue;

-      // Important: don't treat a goto to the same cleanup label as a restart.
       if (isSelfCleanupJump(GR, FS))
         continue;

@@ -321,51 +436,52 @@       if (GoLoc.isInvalid() || TargetLoc.isInvalid())
         continue;

-      // Must be: free ... goto restart_label; where restart_label is before free.
+      // Candidate retry if: free ... goto restart_label; and restart_label is before free.
       if (!(before(SM, FreeLoc, GoLoc) && before(SM, TargetLoc, FreeLoc)))
         continue;

-      // Safety check 1: reset to NULL between free and retry goto
-      bool ResetBetween = false;
+      // New FP filter 1: Require at least one allocation of P between restart label and cleanup free.
+      const AllocInfo *FirstAlloc = findFirstAllocBetween(FS.P, TargetLoc, FreeLoc);
+      if (!FirstAlloc)
+        continue; // No allocation between restart and cleanup -> unlikely to be the targeted pattern
+
+      // New FP filter 2: Define mitigation point: earliest of (NULL reset after restart) or (first allocation).
+      const AssignInfo *FirstNullReset = findFirstNullResetAfter(FS.P, TargetLoc);
+
+      SourceLocation MitigationLoc;
+      bool HaveMitigation = false;
+      if (FirstNullReset && before(SM, FirstNullReset->Loc, FirstAlloc->Loc)) {
+        MitigationLoc = FirstNullReset->Loc;
+        HaveMitigation = true;
+      } else {
+        MitigationLoc = FirstAlloc->Loc;
+        HaveMitigation = true;
+      }
+
+      if (!HaveMitigation)
+        continue;
+
+      // Existing safety: if NULL reset occurs between free and the retry goto, it's safe for this retry.
+      bool ResetBetweenFreeAndRetry = false;
       for (const auto &AI : Assigns) {
         if (AI.P != FS.P)
           continue;
         if (AI.ResetToNull && strictlyBetween(SM, AI.Loc, FreeLoc, GoLoc)) {
-          ResetBetween = true;
+          ResetBetweenFreeAndRetry = true;
           break;
         }
       }
-      if (ResetBetween)
-        continue; // safe for this retry goto
-
-      // Safety check 2: earliest assignment after restart label
-      const AssignInfo *Earliest = nullptr;
-      for (const auto &AI : Assigns) {
-        if (AI.P != FS.P)
-          continue;
-        if (before(SM, TargetLoc, AI.Loc)) {
-          if (!Earliest || before(SM, AI.Loc, Earliest->Loc))
-            Earliest = &AI;
-        }
-      }
-
-      // Look for an early goto to the cleanup label between restart label and earliest assignment.
+      if (ResetBetweenFreeAndRetry)
+        continue;
+
+      // Now, look for an early goto to the cleanup label between restart label and the mitigation point.
       bool EarlyGotoToCleanup = false;
       for (const auto &GE : Gotos) {
         if (GE.Target != FS.CleanupLabel)
           continue;

         SourceLocation ELoc = GE.Loc;
-        if (!before(SM, TargetLoc, ELoc))
-          continue;
-
-        if (Earliest) {
-          if (before(SM, ELoc, Earliest->Loc)) {
-            EarlyGotoToCleanup = true;
-            break;
-          }
-        } else {
-          // No assignment after restart; any early goto to cleanup after restart is problematic.
+        if (strictlyBetween(SM, ELoc, TargetLoc, MitigationLoc)) {
           EarlyGotoToCleanup = true;
           break;
         }
