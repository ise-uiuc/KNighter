### Report Summary

File:| fs/overlayfs/namei.c
---|---
Warning:| line 150, column 2
Pointer freed in cleanup then retried without resetting to NULL; early goto
can double free

### Annotated Source Code


100   |
101   |  if (fb->magic != OVL_FH_MAGIC)
102   |  return -EINVAL;
103   |
104   |  /* Treat larger version and unknown flags as "origin unknown" */
105   |  if (fb->version > OVL_FH_VERSION || fb->flags & ~OVL_FH_FLAG_ALL)
106   |  return -ENODATA;
107   |
108   |  /* Treat endianness mismatch as "origin unknown" */
109   |  if (!(fb->flags & OVL_FH_FLAG_ANY_ENDIAN) &&
110   | 	    (fb->flags & OVL_FH_FLAG_BIG_ENDIAN) != OVL_FH_FLAG_CPU_ENDIAN)
111   |  return -ENODATA;
112   |
113   |  return 0;
114   | }
115   |
116   | static struct ovl_fh *ovl_get_fh(struct ovl_fs *ofs, struct dentry *upperdentry,
117   |  enum ovl_xattr ox)
118   | {
119   |  int res, err;
120   |  struct ovl_fh *fh = NULL;
121   |
122   | 	res = ovl_getxattr_upper(ofs, upperdentry, ox, NULL, 0);
123   |  if (res < 0) {
124   |  if (res == -ENODATA || res == -EOPNOTSUPP)
125   |  return NULL;
126   |  goto fail;
127   | 	}
128   |  /* Zero size value means "copied up but origin unknown" */
129   |  if (res == 0)
130   |  return NULL;
131   |
132   | 	fh = kzalloc(res + OVL_FH_WIRE_OFFSET, GFP_KERNEL);
133   |  if (!fh)
134   |  return ERR_PTR(-ENOMEM);
135   |
136   | 	res = ovl_getxattr_upper(ofs, upperdentry, ox, fh->buf, res);
137   |  if (res < 0)
138   |  goto fail;
139   |
140   | 	err = ovl_check_fb_len(&fh->fb, res);
141   |  if (err < 0) {
142   |  if (err == -ENODATA)
143   |  goto out;
144   |  goto invalid;
145   | 	}
146   |
147   |  return fh;
148   |
149   | out:
150   |  kfree(fh);
    Pointer freed in cleanup then retried without resetting to NULL; early goto can double free
151   |  return NULL;
152   |
153   | fail:
154   |  pr_warn_ratelimited("failed to get origin (%i)\n", res);
155   |  goto out;
156   | invalid:
157   |  pr_warn_ratelimited("invalid origin (%*phN)\n", res, fh);
158   |  goto out;
159   | }
160   |
161   | struct dentry *ovl_decode_real_fh(struct ovl_fs *ofs, struct ovl_fh *fh,
162   |  struct vfsmount *mnt, bool connected)
163   | {
164   |  struct dentry *real;
165   |  int bytes;
166   |
167   |  if (!capable(CAP_DAC_READ_SEARCH))
168   |  return NULL;
169   |
170   |  /*
171   |  * Make sure that the stored uuid matches the uuid of the lower
172   |  * layer where file handle will be decoded.
173   |  * In case of uuid=off option just make sure that stored uuid is null.
174   |  */
175   |  if (ovl_origin_uuid(ofs) ?
176   | 	    !uuid_equal(&fh->fb.uuid, &mnt->mnt_sb->s_uuid) :
177   | 	    !uuid_is_null(&fh->fb.uuid))
178   |  return NULL;
179   |
180   | 	bytes = (fh->fb.len - offsetof(struct ovl_fb, fid));
