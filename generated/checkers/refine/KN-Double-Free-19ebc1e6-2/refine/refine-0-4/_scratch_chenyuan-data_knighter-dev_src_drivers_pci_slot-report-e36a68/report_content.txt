### Report Summary

File:| drivers/pci/slot.c
---|---
Warning:| line 296, column 2
Pointer freed in cleanup then retried without resetting to NULL; early goto
can double free

### Annotated Source Code


246   |  if (hotplug) {
247   |  if ((err = slot->hotplug ? -EBUSY : 0)
248   | 			     || (err = rename_slot(slot, name))) {
249   | 				kobject_put(&slot->kobj);
250   | 				slot = NULL;
251   |  goto err;
252   | 			}
253   | 		}
254   |  goto out;
255   | 	}
256   |
257   | placeholder:
258   | 	slot = kzalloc(sizeof(*slot), GFP_KERNEL);
259   |  if (!slot) {
260   | 		err = -ENOMEM;
261   |  goto err;
262   | 	}
263   |
264   | 	slot->bus = parent;
265   | 	slot->number = slot_nr;
266   |
267   | 	slot->kobj.kset = pci_slots_kset;
268   |
269   | 	slot_name = make_slot_name(name);
270   |  if (!slot_name) {
271   | 		err = -ENOMEM;
272   | 		kfree(slot);
273   |  goto err;
274   | 	}
275   |
276   | 	INIT_LIST_HEAD(&slot->list);
277   | 	list_add(&slot->list, &parent->slots);
278   |
279   | 	err = kobject_init_and_add(&slot->kobj, &pci_slot_ktype, NULL,
280   |  "%s", slot_name);
281   |  if (err) {
282   | 		kobject_put(&slot->kobj);
283   |  goto err;
284   | 	}
285   |
286   | 	down_read(&pci_bus_sem);
287   |  list_for_each_entry(dev, &parent->devices, bus_list)
288   |  if (PCI_SLOT(dev->devfn) == slot_nr)
289   | 			dev->slot = slot;
290   | 	up_read(&pci_bus_sem);
291   |
292   |  dev_dbg(&parent->dev, "dev %02x, created physical slot %s\n",
293   |  slot_nr, pci_slot_name(slot));
294   |
295   | out:
296   |  kfree(slot_name);
    Pointer freed in cleanup then retried without resetting to NULL; early goto can double free
297   | 	mutex_unlock(&pci_slot_mutex);
298   |  return slot;
299   | err:
300   | 	slot = ERR_PTR(err);
301   |  goto out;
302   | }
303   | EXPORT_SYMBOL_GPL(pci_create_slot);
304   |
305   | /**
306   |  * pci_destroy_slot - decrement refcount for physical PCI slot
307   |  * @slot: struct pci_slot to decrement
308   |  *
309   |  * %struct pci_slot is refcounted, so destroying them is really easy; we
310   |  * just call kobject_put on its kobj and let our release methods do the
311   |  * rest.
312   |  */
313   | void pci_destroy_slot(struct pci_slot *slot)
314   | {
315   |  dev_dbg(&slot->bus->dev, "dev %02x, dec refcount to %d\n",
316   |  slot->number, kref_read(&slot->kobj.kref) - 1);
317   |
318   |  mutex_lock(&pci_slot_mutex);
319   | 	kobject_put(&slot->kobj);
320   | 	mutex_unlock(&pci_slot_mutex);
321   | }
322   | EXPORT_SYMBOL_GPL(pci_destroy_slot);
323   |
324   | #if defined(CONFIG_HOTPLUG_PCI) || defined(CONFIG_HOTPLUG_PCI_MODULE)
325   | #include <linux/pci_hotplug.h>
326   | /**
