### Report Summary

File:| /scratch/chenyuan-data/linux-debug/drivers/hwmon/adt7475.c
---|---
Warning:| line 692, column 8
Possible off-by-one: loop uses i < bound but also accesses a[i + 1]

### Annotated Source Code


642   |
643   | static ssize_t point2_show(struct device *dev, struct device_attribute *attr,
644   |  char *buf)
645   | {
646   |  struct adt7475_data *data = adt7475_update_device(dev);
647   |  struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
648   |  int out, val;
649   |
650   |  if (IS_ERR(data))
651   |  return PTR_ERR(data);
652   |
653   |  mutex_lock(&data->lock);
654   | 	out = (data->range[sattr->index] >> 4) & 0x0F;
655   | 	val = reg2temp(data, data->temp[AUTOMIN][sattr->index]);
656   | 	mutex_unlock(&data->lock);
657   |
658   |  return sprintf(buf, "%d\n", val + autorange_table[out]);
659   | }
660   |
661   | static ssize_t point2_store(struct device *dev, struct device_attribute *attr,
662   |  const char *buf, size_t count)
663   | {
664   |  struct adt7475_data *data = dev_get_drvdata(dev);
665   |  struct i2c_client *client = data->client;
666   |  struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
667   |  int temp;
668   |  long val;
669   |
670   |  if (kstrtol(buf, 10, &val))
671   |  return -EINVAL;
672   |
673   |  mutex_lock(&data->lock);
674   |
675   |  /* Get a fresh copy of the needed registers */
676   | 	data->config5 = adt7475_read(REG_CONFIG5);
677   | 	data->temp[AUTOMIN][sattr->index] =
678   |  adt7475_read(TEMP_TMIN_REG(sattr->index)) << 2;
679   | 	data->range[sattr->index] =
680   |  adt7475_read(TEMP_TRANGE_REG(sattr->index));
681   |
682   |  /*
683   |  * The user will write an absolute value, so subtract the start point
684   |  * to figure the range
685   |  */
686   | 	temp = reg2temp(data, data->temp[AUTOMIN][sattr->index]);
687   | 	val = clamp_val(val, temp + autorange_table[0],
688   |  temp + autorange_table[ARRAY_SIZE(autorange_table) - 1]);
689   | 	val -= temp;
690   |
691   |  /* Find the nearest table entry to what the user wrote */
692   | 	val = find_closest(val, autorange_table, ARRAY_SIZE(autorange_table));
    Possible off-by-one: loop uses i < bound but also accesses a[i + 1]
693   |
694   | 	data->range[sattr->index] &= ~0xF0;
695   | 	data->range[sattr->index] |= val << 4;
696   |
697   | 	i2c_smbus_write_byte_data(client, TEMP_TRANGE_REG(sattr->index),
698   | 				  data->range[sattr->index]);
699   |
700   | 	mutex_unlock(&data->lock);
701   |  return count;
702   | }
703   |
704   | static ssize_t tach_show(struct device *dev, struct device_attribute *attr,
705   |  char *buf)
706   | {
707   |  struct adt7475_data *data = adt7475_update_device(dev);
708   |  struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
709   |  int out;
710   |
711   |  if (IS_ERR(data))
712   |  return PTR_ERR(data);
713   |
714   |  if (sattr->nr == ALARM)
715   | 		out = (data->alarms >> (sattr->index + 10)) & 1;
716   |  else
717   | 		out = tach2rpm(data->tach[sattr->nr][sattr->index]);
718   |
719   |  return sprintf(buf, "%d\n", out);
720   | }
721   |
722   | static ssize_t tach_store(struct device *dev, struct device_attribute *attr,
