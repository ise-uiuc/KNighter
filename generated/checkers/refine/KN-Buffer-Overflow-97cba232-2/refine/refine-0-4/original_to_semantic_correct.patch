--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -187,132 +187,6 @@     return false;
   }

-  // Extended to also return the bound expression used in the comparison.
-  static bool analyzeLoopCondition(const Expr *Cond, const VarDecl *V,
-                                   bool &IsStrictUpper,
-                                   bool &IsMinusOneAdjusted,
-                                   const Expr *&BoundExprOut) {
-    IsStrictUpper = false;
-    IsMinusOneAdjusted = false;
-    BoundExprOut = nullptr;
-
-    if (!Cond || !V)
-      return false;
-    const auto *BO = dyn_cast<BinaryOperator>(Cond->IgnoreParenImpCasts());
-    if (!BO)
-      return false;
-
-    const Expr *L = BO->getLHS();
-    const Expr *R = BO->getRHS();
-
-    switch (BO->getOpcode()) {
-    case BO_LT:
-      if (isRefToVar(L, V)) {
-        IsStrictUpper = true;
-        if (isMinusOneAdjustedExpr(R))
-          IsMinusOneAdjusted = true;
-        BoundExprOut = R;
-        return true;
-      }
-      break;
-    case BO_GT:
-      if (isRefToVar(R, V)) {
-        IsStrictUpper = true;
-        if (isMinusOneAdjustedExpr(L))
-          IsMinusOneAdjusted = true;
-        BoundExprOut = L;
-        return true;
-      }
-      break;
-    case BO_LE:
-      if (isRefToVar(L, V) && isMinusOneAdjustedExpr(R)) {
-        IsStrictUpper = false;
-        IsMinusOneAdjusted = true;
-        BoundExprOut = R;
-        return true;
-      }
-      break;
-    case BO_GE:
-      if (isRefToVar(R, V) && isMinusOneAdjustedExpr(L)) {
-        IsStrictUpper = false;
-        IsMinusOneAdjusted = true;
-        BoundExprOut = L;
-        return true;
-      }
-      break;
-    default:
-      break;
-    }
-    return false;
-  }
-
-  static bool guardInCondition(const Expr *Cond, const VarDecl *V) {
-    if (!Cond || !V)
-      return false;
-    const Expr *C = Cond->IgnoreParenImpCasts();
-
-    if (const auto *BO = dyn_cast<BinaryOperator>(C)) {
-      // Handle logical-AND by searching either side for a valid guard.
-      if (BO->getOpcode() == BO_LAnd) {
-        return guardInCondition(BO->getLHS(), V) ||
-               guardInCondition(BO->getRHS(), V);
-      }
-
-      const Expr *L = BO->getLHS();
-      const Expr *R = BO->getRHS();
-      // i + 1 < X or i + 1 <= X
-      if ((BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE) &&
-          (isVarPlusOne(L, V))) {
-        return true;
-      }
-      // i < X - 1 or i <= X - 1
-      if ((BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE) &&
-          isRefToVar(L, V) && isMinusOneAdjustedExpr(R)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  static bool hasLocalGuardForASE(ASTContext &Ctx, const ArraySubscriptExpr *ASE,
-                                  const ForStmt *FS, const VarDecl *V) {
-    if (!ASE || !FS || !V)
-      return false;
-
-    llvm::SmallVector<DynTypedNode, 8> Worklist;
-    llvm::SmallPtrSet<const void *, 32> Visited;
-
-    Worklist.push_back(DynTypedNode::create<const Stmt>(*ASE));
-
-    while (!Worklist.empty()) {
-      DynTypedNode Node = Worklist.pop_back_val();
-      auto Parents = Ctx.getParents(Node);
-      for (const auto &P : Parents) {
-        const Stmt *PS = P.get<Stmt>();
-        if (!PS)
-          continue;
-
-        if (Visited.contains(PS))
-          continue;
-        Visited.insert(PS);
-
-        if (const auto *IFS = dyn_cast<IfStmt>(PS)) {
-          const Expr *Cond = IFS->getCond();
-          if (guardInCondition(Cond, V))
-            return true;
-        }
-
-        if (PS == FS)
-          continue; // Reached the loop boundary on this path.
-
-        Worklist.push_back(P);
-      }
-    }
-
-    return false;
-  }
-
-  // Normalize/compare base expressions (array object) for equivalence.
   static const Expr *stripCastsAndParens(const Expr *E) {
     if (!E)
       return nullptr;
@@ -327,6 +201,130 @@     return E;
   }

+  static bool analyzeLoopCondition(const Expr *Cond, const VarDecl *V,
+                                   bool &IsStrictUpper,
+                                   bool &IsMinusOneAdjusted,
+                                   const Expr *&BoundExprOut) {
+    IsStrictUpper = false;
+    IsMinusOneAdjusted = false;
+    BoundExprOut = nullptr;
+
+    if (!Cond || !V)
+      return false;
+    const auto *BO = dyn_cast<BinaryOperator>(Cond->IgnoreParenImpCasts());
+    if (!BO)
+      return false;
+
+    const Expr *L = BO->getLHS();
+    const Expr *R = BO->getRHS();
+
+    switch (BO->getOpcode()) {
+    case BO_LT:
+      if (isRefToVar(L, V)) {
+        IsStrictUpper = true;
+        if (isMinusOneAdjustedExpr(R))
+          IsMinusOneAdjusted = true;
+        BoundExprOut = R;
+        return true;
+      }
+      break;
+    case BO_GT:
+      if (isRefToVar(R, V)) {
+        IsStrictUpper = true;
+        if (isMinusOneAdjustedExpr(L))
+          IsMinusOneAdjusted = true;
+        BoundExprOut = L;
+        return true;
+      }
+      break;
+    case BO_LE:
+      if (isRefToVar(L, V) && isMinusOneAdjustedExpr(R)) {
+        IsStrictUpper = false;
+        IsMinusOneAdjusted = true;
+        BoundExprOut = R;
+        return true;
+      }
+      break;
+    case BO_GE:
+      if (isRefToVar(R, V) && isMinusOneAdjustedExpr(L)) {
+        IsStrictUpper = false;
+        IsMinusOneAdjusted = true;
+        BoundExprOut = L;
+        return true;
+      }
+      break;
+    default:
+      break;
+    }
+    return false;
+  }
+
+  static bool guardInCondition(const Expr *Cond, const VarDecl *V) {
+    if (!Cond || !V)
+      return false;
+    const Expr *C = Cond->IgnoreParenImpCasts();
+
+    if (const auto *BO = dyn_cast<BinaryOperator>(C)) {
+      // Handle logical-AND by searching either side for a valid guard.
+      if (BO->getOpcode() == BO_LAnd) {
+        return guardInCondition(BO->getLHS(), V) ||
+               guardInCondition(BO->getRHS(), V);
+      }
+
+      const Expr *L = BO->getLHS();
+      const Expr *R = BO->getRHS();
+      // i + 1 < X or i + 1 <= X
+      if ((BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE) &&
+          (isVarPlusOne(L, V))) {
+        return true;
+      }
+      // i < X - 1 or i <= X - 1
+      if ((BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE) &&
+          isRefToVar(L, V) && isMinusOneAdjustedExpr(R)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  static bool hasLocalGuardForASE(ASTContext &Ctx, const ArraySubscriptExpr *ASE,
+                                  const ForStmt *FS, const VarDecl *V) {
+    if (!ASE || !FS || !V)
+      return false;
+
+    llvm::SmallVector<DynTypedNode, 8> Worklist;
+    llvm::SmallPtrSet<const void *, 32> Visited;
+
+    Worklist.push_back(DynTypedNode::create<const Stmt>(*ASE));
+
+    while (!Worklist.empty()) {
+      DynTypedNode Node = Worklist.pop_back_val();
+      auto Parents = Ctx.getParents(Node);
+      for (const auto &P : Parents) {
+        const Stmt *PS = P.get<Stmt>();
+        if (!PS)
+          continue;
+
+        if (Visited.contains(PS))
+          continue;
+        Visited.insert(PS);
+
+        if (const auto *IFS = dyn_cast<IfStmt>(PS)) {
+          const Expr *Cond = IFS->getCond();
+          if (guardInCondition(Cond, V))
+            return true;
+        }
+
+        if (PS == FS)
+          continue; // Reached the loop boundary on this path.
+
+        Worklist.push_back(P);
+      }
+    }
+
+    return false;
+  }
+
   static bool sameBaseExpr(const Expr *A, const Expr *B) {
     if (!A || !B)
       return false;
@@ -334,7 +332,6 @@     B = stripCastsAndParens(B);

     if (A->getStmtClass() != B->getStmtClass()) {
-      // Allow MemberExpr through implicit conversion mismatch (dot vs arrow cast).
       const auto *MA = dyn_cast<MemberExpr>(A);
       const auto *MB = dyn_cast<MemberExpr>(B);
       if (!(MA && MB))
@@ -359,7 +356,6 @@       const auto *FB = MB->getMemberDecl();
       if (!FA || !FB || FA->getCanonicalDecl() != FB->getCanonicalDecl())
         return false;
-      // Compare the base of the member.
       return sameBaseExpr(MA->getBase()->IgnoreImpCasts(),
                           MB->getBase()->IgnoreImpCasts());
     }
@@ -370,14 +366,12 @@         return false;
       if (UA->getOpcode() != UB->getOpcode())
         return false;
-      // Only compare address/deref op structurally.
       if (UA->getOpcode() != UO_AddrOf && UA->getOpcode() != UO_Deref)
         return false;
       return sameBaseExpr(UA->getSubExpr()->IgnoreImpCasts(),
-                          UB->getSubExpr()->IgnoreImpCasts());
-    }
-
-    // Fallback: be conservative.
+                          UB->getSubExpr()->IgnoreParenImpCasts());
+    }
+
     return false;
   }

@@ -428,10 +422,6 @@     return F.Found;
   }

-  // Attempt to recover the constant array size from the base expression.
-  // Supports:
-  //  - DeclRefExpr to VarDecl of ConstantArrayType
-  //  - MemberExpr to FieldDecl of ConstantArrayType (e.g., dc->links)
   static bool getConstantArraySizeFromBase(const Expr *Base, llvm::APInt &Size) {
     Base = stripCastsAndParens(Base);
     if (!Base)
@@ -457,7 +447,6 @@     return false;
   }

-  // Evaluate an expression as integer constant. Returns true on success.
   static bool evaluateExprToAPSInt(const Expr *E, ASTContext &Ctx,
                                    llvm::APSInt &Res) {
     if (!E)
@@ -470,25 +459,46 @@     return false;
   }

-  // Additional FP filter: ensure the loop bound equals the constant array size.
-  // Returns true if both values are known and equal.
+  static bool exprsEqualConstInt(const Expr *A, const Expr *B,
+                                 ASTContext &Ctx) {
+    llvm::APSInt VA, VB;
+    if (!evaluateExprToAPSInt(A, Ctx, VA))
+      return false;
+    if (!evaluateExprToAPSInt(B, Ctx, VB))
+      return false;
+    return VA == VB;
+  }
+
+  static bool isExprMinusOneOf(const Expr *E, const Expr *Base, ASTContext &Ctx) {
+    E = stripCastsAndParens(E);
+    Base = stripCastsAndParens(Base);
+    const auto *BO = dyn_cast<BinaryOperator>(E);
+    if (!BO || BO->getOpcode() != BO_Sub)
+      return false;
+    if (!isIntLiteralOne(BO->getRHS()))
+      return false;
+    // Either structural equality is too hard; accept equal constant values.
+    if (exprsEqualConstInt(BO->getLHS(), Base, Ctx))
+      return true;
+    return false;
+  }
+
   static bool loopBoundEqualsArraySize(const Expr *BoundExpr,
                                        const Expr *ArrayBase,
                                        ASTContext &Ctx) {
     llvm::APInt ArrSize(64, 0);
     if (!getConstantArraySizeFromBase(ArrayBase, ArrSize))
-      return false; // Not a constant-sized array: avoid reporting.
+      return false;

     llvm::APSInt BoundVal;
     if (!evaluateExprToAPSInt(BoundExpr, Ctx, BoundVal))
-      return false; // Non-constant bound: avoid reporting.
+      return false;

     uint64_t ArrSz = ArrSize.getLimitedValue(UINT64_MAX);
     uint64_t BVal = BoundVal.getLimitedValue(UINT64_MAX);
     return ArrSz == BVal;
   }

-  // Get the enclosing function body for a statement.
   static const Stmt *getEnclosingFunctionBody(const Stmt *S, ASTContext &Ctx) {
     if (!S)
       return nullptr;
@@ -508,7 +518,6 @@           break;
         }
         if (const auto *DC = P.get<Decl>()) {
-          // Keep climbing through decls if needed.
           N = DynTypedNode::create<const Decl>(*DC);
           Advanced = true;
           break;
@@ -520,14 +529,12 @@     return nullptr;
   }

-  // Check if an expression is "&Base[1]" or "Base + 1" with the same base.
   static bool isAddrOrPtrArithBasePlusOne(const Expr *E, const Expr *Base) {
     if (!E || !Base)
       return false;
     E = E->IgnoreParenImpCasts();
     Base = stripCastsAndParens(Base);

-    // &Base[1]
     if (const auto *UO = dyn_cast<UnaryOperator>(E)) {
       if (UO->getOpcode() == UO_AddrOf) {
         const Expr *Sub = UO->getSubExpr()->IgnoreParenImpCasts();
@@ -540,7 +547,6 @@       }
     }

-    // Base + 1 or 1 + Base
     if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
       if (BO->getOpcode() == BO_Add) {
         const Expr *L = BO->getLHS()->IgnoreParenImpCasts();
@@ -554,7 +560,253 @@     return false;
   }

-  // Detect pre-loop setup like "xfer[1].rx_buf = &Base[1]" that legitimizes Base[i+1] for i < len.
+  static bool branchContainsExitFromLoop(const Stmt *S, const ForStmt *FS,
+                                         ASTContext &Ctx) {
+    if (!S || !FS)
+      return false;
+
+    struct ExitFinder : public RecursiveASTVisitor<ExitFinder> {
+      const ForStmt *FS;
+      ASTContext &Ctx;
+      bool Found = false;
+
+      ExitFinder(const ForStmt *FS, ASTContext &Ctx) : FS(FS), Ctx(Ctx) {}
+
+      bool VisitReturnStmt(ReturnStmt *R) {
+        Found = true;
+        return true;
+      }
+
+      bool VisitBreakStmt(BreakStmt *B) {
+        if (breakTargetsLoop(B, FS, Ctx))
+          Found = true;
+        return true;
+      }
+
+      static bool breakTargetsLoop(const BreakStmt *B, const ForStmt *FS,
+                                   ASTContext &Ctx) {
+        if (!B || !FS)
+          return false;
+        DynTypedNode N = DynTypedNode::create<const Stmt>(*B);
+        while (true) {
+          auto Parents = Ctx.getParents(N);
+          if (Parents.empty())
+            break;
+          bool Advanced = false;
+          for (const DynTypedNode &P : Parents) {
+            if (const Stmt *PS = P.get<Stmt>()) {
+              if (isa<SwitchStmt>(PS)) {
+                // Break will target this switch, not the loop.
+                return false;
+              }
+              if (isa<ForStmt>(PS) || isa<WhileStmt>(PS) || isa<DoStmt>(PS)) {
+                return PS == FS;
+              }
+              N = DynTypedNode::create<const Stmt>(*PS);
+              Advanced = true;
+              break;
+            }
+            if (const Decl *PD = P.get<Decl>()) {
+              N = DynTypedNode::create<const Decl>(*PD);
+              Advanced = true;
+              break;
+            }
+          }
+          if (!Advanced)
+            break;
+        }
+        return false;
+      }
+    };
+
+    ExitFinder EF(FS, Ctx);
+    EF.TraverseStmt(const_cast<Stmt *>(S));
+    return EF.Found;
+  }
+
+  static bool condMatchesEarlyExitGuard(const Expr *Cond, const VarDecl *V,
+                                        const Expr *Bound, ASTContext &Ctx) {
+    if (!Cond || !V || !Bound)
+      return false;
+
+    Cond = stripCastsAndParens(Cond);
+
+    const auto checkPair = [&](const Expr *L, const Expr *R,
+                               BinaryOperatorKind Op) -> bool {
+      // Pattern 1: (i + 1) >= Bound or == Bound
+      if ((Op == BO_GE || Op == BO_EQ) && isVarPlusOne(L, V)) {
+        if (exprsEqualConstInt(R, Bound, Ctx))
+          return true;
+      }
+      // Pattern 2: i >= Bound - 1 or i == Bound - 1
+      if ((Op == BO_GE || Op == BO_EQ) && isRefToVar(L, V) &&
+          isExprMinusOneOf(R, Bound, Ctx)) {
+        return true;
+      }
+      return false;
+    };
+
+    if (const auto *BO = dyn_cast<BinaryOperator>(Cond)) {
+      const Expr *L = stripCastsAndParens(BO->getLHS());
+      const Expr *R = stripCastsAndParens(BO->getRHS());
+      BinaryOperatorKind Op = BO->getOpcode();
+
+      // Direct orientation
+      if (checkPair(L, R, Op))
+        return true;
+
+      // Symmetric orientation: e.g., Bound <= (i + 1) or (Bound - 1) <= i
+      // Convert LE to GE by swapping sides.
+      if (Op == BO_LE || Op == BO_EQ) {
+        if (checkPair(R, L, (Op == BO_LE ? BO_GE : BO_EQ)))
+          return true;
+      }
+      if (Op == BO_GE) {
+        if (checkPair(R, L, BO_GE))
+          return true;
+      }
+    }
+
+    return false;
+  }
+
+  static const Stmt *findTopLevelChildContaining(const Stmt *Body,
+                                                 const Stmt *Inner,
+                                                 ASTContext &Ctx) {
+    if (!Body || !Inner)
+      return nullptr;
+
+    const Stmt *Top = nullptr;
+    DynTypedNode N = DynTypedNode::create<const Stmt>(*Inner);
+    while (true) {
+      auto Parents = Ctx.getParents(N);
+      if (Parents.empty())
+        break;
+      bool Advanced = false;
+      for (const DynTypedNode &P : Parents) {
+        if (const Stmt *PS = P.get<Stmt>()) {
+          if (PS == Body) {
+            if (const Stmt *S = N.get<Stmt>())
+              return S;
+            return nullptr;
+          }
+          N = DynTypedNode::create<const Stmt>(*PS);
+          Advanced = true;
+          break;
+        }
+        if (const Decl *PD = P.get<Decl>()) {
+          N = DynTypedNode::create<const Decl>(*PD);
+          Advanced = true;
+          break;
+        }
+      }
+      if (!Advanced)
+        break;
+    }
+    return Top;
+  }
+
+  static bool stmtContainsTarget(const Stmt *Container, const Stmt *Inner) {
+    if (!Container || !Inner)
+      return false;
+    if (Container == Inner)
+      return true;
+
+    struct Finder : public RecursiveASTVisitor<Finder> {
+      const Stmt *Target;
+      bool Found = false;
+      Finder(const Stmt *T) : Target(T) {}
+      bool VisitStmt(Stmt *S) {
+        if (S == Target)
+          Found = true;
+        return !Found;
+      }
+    } F(Inner);
+
+    F.TraverseStmt(const_cast<Stmt *>(Container));
+    return F.Found;
+  }
+
+  static bool hasDominatingEarlyExitGuard(const ForStmt *FS,
+                                          const ArraySubscriptExpr *ASE,
+                                          const VarDecl *IVar,
+                                          const Expr *BoundExpr,
+                                          ASTContext &Ctx) {
+    if (!FS || !ASE || !IVar || !BoundExpr)
+      return false;
+
+    const Stmt *Body = FS->getBody();
+    if (!Body)
+      return false;
+
+    const CompoundStmt *CS = dyn_cast<CompoundStmt>(Body);
+    if (!CS)
+      return false;
+
+    const Stmt *Top = findTopLevelChildContaining(Body, ASE, Ctx);
+    if (!Top)
+      return false;
+
+    for (const Stmt *S : CS->body()) {
+      if (!S)
+        continue;
+      if (S == Top)
+        break;
+
+      // Search all IfStmts within S. If any matches guard and exits loop, suppress.
+      struct IfFinder : public RecursiveASTVisitor<IfFinder> {
+        const ForStmt *FS;
+        const VarDecl *IVar;
+        const Expr *BoundExpr;
+        ASTContext &Ctx;
+        bool Found = false;
+
+        IfFinder(const ForStmt *FS, const VarDecl *IVar, const Expr *BoundExpr,
+                 ASTContext &Ctx)
+            : FS(FS), IVar(IVar), BoundExpr(BoundExpr), Ctx(Ctx) {}
+
+        bool VisitIfStmt(IfStmt *IF) {
+          if (Found)
+            return true;
+          const Expr *Cond = IF->getCond();
+          if (condMatchesEarlyExitGuard(Cond, IVar, BoundExpr, Ctx)) {
+            const Stmt *Then = IF->getThen();
+            if (branchContainsExitFromLoop(Then, FS, Ctx)) {
+              Found = true;
+            }
+          }
+          return true;
+        }
+      } FF(FS, IVar, BoundExpr, Ctx);
+
+      FF.TraverseStmt(const_cast<Stmt *>(S));
+      if (FF.Found)
+        return true;
+    }
+
+    return false;
+  }
+
+  bool isFalsePositive(const ArraySubscriptExpr *ASE,
+                       const ForStmt *FS,
+                       const VarDecl *IVar,
+                       const Expr *BoundExpr,
+                       ASTContext &Ctx) const {
+    if (hasLocalGuardForASE(Ctx, ASE, FS, IVar))
+      return true;
+
+    const Expr *Base = ASE->getBase()->IgnoreParenImpCasts();
+    if (hasRxBufOffsetOneSetupBefore(Base, FS, Ctx))
+      return true;
+
+    // New FP filter: if there's a dominating early-exit guard that ensures
+    // i+1 will not be used when out of bounds, suppress.
+    if (hasDominatingEarlyExitGuard(FS, ASE, IVar, BoundExpr, Ctx))
+      return true;
+
+    return false;
+  }
+
   static bool hasRxBufOffsetOneSetupBefore(const Expr *Base,
                                            const ForStmt *FS,
                                            ASTContext &Ctx) {
@@ -587,7 +839,6 @@         if (!BO || BO->getOpcode() != BO_Assign)
           return true;

-        // Only consider statements textually before the loop.
         if (!BO->getBeginLoc().isValid() || !LoopLoc.isValid())
           return true;
         if (!SM.isBeforeInTranslationUnit(BO->getBeginLoc(), LoopLoc))
@@ -596,14 +847,12 @@         const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();
         const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();

-        // Match LHS '.rx_buf' or '->rx_buf'
         bool LHSMatchesRxBuf = false;
         if (const auto *ME = dyn_cast<MemberExpr>(LHS)) {
           if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl())) {
             LHSMatchesRxBuf = FD->getName().equals("rx_buf");
           }
         } else if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS)) {
-          // Very conservative: allow a standalone variable named rx_buf too.
           if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {
             LHSMatchesRxBuf = VD->getName().equals("rx_buf");
           }
@@ -623,24 +872,6 @@     Finder F(Base, FS, Ctx);
     F.TraverseStmt(const_cast<Stmt *>(Body));
     return F.Found;
-  }
-
-  // Aggregate FP checks into a single helper for clarity.
-  bool isFalsePositive(const ArraySubscriptExpr *ASE,
-                       const ForStmt *FS,
-                       const VarDecl *IVar,
-                       const Expr *BoundExpr,
-                       ASTContext &Ctx) const {
-    // 1) Local guard present: i + 1 < X or i < X - 1
-    if (hasLocalGuardForASE(Ctx, ASE, FS, IVar))
-      return true;
-
-    // 2) SPI-like pre-loop setup: rx_buf points to &Base[1] or Base + 1
-    const Expr *Base = ASE->getBase()->IgnoreParenImpCasts();
-    if (hasRxBufOffsetOneSetupBefore(Base, FS, Ctx))
-      return true;
-
-    return false;
   }

   void analyzeForStmt(const ForStmt *FS, ASTContext &Ctx,
@@ -652,8 +883,6 @@     if (!IVar)
       return;

-    // Require loop to start from 0 to match the target bug pattern and
-    // avoid stencil/edge-handling loops that often start from 1.
     if (!isInitZero(FS->getInit(), IVar))
       return;

@@ -667,19 +896,15 @@                               BoundExpr))
       return;

-    // Skip loops that already use (bound - 1).
     if (IsMinusOneAdjusted)
       return;

-    // We only flag loops with strict upper bounds like i < N or N > i.
     if (!IsStrictUpper)
       return;

-    // Ensure unit-step increment on i.
     if (!isUnitStepIncrement(FS->getInc(), IVar))
       return;

-    // Traverse the loop body and find a[i + 1] with required paired access a[i].
     struct BodyVisitor : public RecursiveASTVisitor<BodyVisitor> {
       const SAGenTestChecker *Checker;
       const ForStmt *FS;
@@ -699,33 +924,26 @@         if (!ASE)
           return true;
         const Expr *Idx = ASE->getIdx()->IgnoreParenImpCasts();
-        // Only consider indices of the form i + 1 or 1 + i.
         if (!Checker->isVarPlusOne(Idx, IVar))
           return true;

-        // False-positive filters (local guard, I/O rx_buf offset setup).
         if (Checker->isFalsePositive(ASE, FS, IVar, BoundExpr, Ctx))
           return true;

-        // Additional FP filter: ensure the loop bound is the actual size of this array base.
         const Expr *Base = ASE->getBase()->IgnoreParenImpCasts();
         if (!Base || !BoundExpr)
           return true;

         if (!SAGenTestChecker::loopBoundEqualsArraySize(BoundExpr, Base, Ctx))
-          return true; // The loop bound doesn't tie to this array's size; likely false positive.
-
-        // Only warn if the same base array is also accessed with index [i]
-        // within the same loop body (matches the target bug pattern and
-        // suppresses stencil-style code accessing neighbor elements).
+          return true;
+
         const Stmt *Body = FS->getBody();
         if (!Body)
           return true;

         if (!Checker->hasPairedIndexAccessToSameBase(Body, Base, IVar, ASE))
-          return true; // Not the targeted pattern; likely benign or out of scope.
-
-        // Report the potential off-by-one.
+          return true;
+
         PathDiagnosticLocation ELoc =
             PathDiagnosticLocation::createBegin(ASE, BR.getSourceManager(),
                                                 nullptr);
@@ -736,7 +954,6 @@             ELoc);
         R->addRange(ASE->getSourceRange());

-        // Highlight the loop condition too.
         if (const Expr *Cond = FS->getCond()) {
           R->addRange(Cond->getSourceRange());
         }
