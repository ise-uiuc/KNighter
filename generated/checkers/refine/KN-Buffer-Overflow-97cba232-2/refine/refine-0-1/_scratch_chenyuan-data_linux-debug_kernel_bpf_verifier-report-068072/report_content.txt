### Report Summary

File:| /scratch/chenyuan-data/linux-debug/kernel/bpf/verifier.c
---|---
Warning:| line 11626, column 55
Possible off-by-one: loop uses i < bound but also accesses a[i + 1]

### Annotated Source Code


11576 | {
11577 |  return __process_kf_arg_ptr_to_graph_node(env, reg, regno, meta,
11578 | 						  BPF_RB_ROOT, BPF_RB_NODE,
11579 | 						  &meta->arg_rbtree_root.field);
11580 | }
11581 |
11582 | /*
11583 |  * css_task iter allowlist is needed to avoid dead locking on css_set_lock.
11584 |  * LSM hooks and iters (both sleepable and non-sleepable) are safe.
11585 |  * Any sleepable progs are also safe since bpf_check_attach_target() enforce
11586 |  * them can only be attached to some specific hook points.
11587 |  */
11588 | static bool check_css_task_iter_allowlist(struct bpf_verifier_env *env)
11589 | {
11590 |  enum bpf_prog_type prog_type = resolve_prog_type(env->prog);
11591 |
11592 |  switch (prog_type) {
11593 |  case BPF_PROG_TYPE_LSM:
11594 |  return true;
11595 |  case BPF_PROG_TYPE_TRACING:
11596 |  if (env->prog->expected_attach_type == BPF_TRACE_ITER)
11597 |  return true;
11598 |  fallthrough;
11599 |  default:
11600 |  return in_sleepable(env);
11601 | 	}
11602 | }
11603 |
11604 | static int check_kfunc_args(struct bpf_verifier_env *env, struct bpf_kfunc_call_arg_meta *meta,
11605 |  int insn_idx)
11606 | {
11607 |  const char *func_name = meta->func_name, *ref_tname;
11608 |  const struct btf *btf = meta->btf;
11609 |  const struct btf_param *args;
11610 |  struct btf_record *rec;
11611 | 	u32 i, nargs;
11612 |  int ret;
11613 |
11614 | 	args = (const struct btf_param *)(meta->func_proto + 1);
11615 | 	nargs = btf_type_vlen(meta->func_proto);
11616 |  if (nargs > MAX_BPF_FUNC_REG_ARGS) {
11617 | 		verbose(env, "Function %s has %d > %d args\n", func_name, nargs,
11618 |  MAX_BPF_FUNC_REG_ARGS);
11619 |  return -EINVAL;
11620 | 	}
11621 |
11622 |  /* Check that BTF function arguments match actual types that the
11623 |  * verifier sees.
11624 |  */
11625 |  for (i = 0; i < nargs; i++) {
11626 |  struct bpf_reg_state *regs = cur_regs(env), *reg = Â®s[i + 1];
    Possible off-by-one: loop uses i < bound but also accesses a[i + 1]
11627 |  const struct btf_type *t, *ref_t, *resolve_ret;
11628 |  enum bpf_arg_type arg_type = ARG_DONTCARE;
11629 | 		u32 regno = i + 1, ref_id, type_size;
11630 | 		bool is_ret_buf_sz = false;
11631 |  int kf_arg_type;
11632 |
11633 | 		t = btf_type_skip_modifiers(btf, args[i].type, NULL);
11634 |
11635 |  if (is_kfunc_arg_ignore(btf, &args[i]))
11636 |  continue;
11637 |
11638 |  if (btf_type_is_scalar(t)) {
11639 |  if (reg->type != SCALAR_VALUE) {
11640 | 				verbose(env, "R%d is not a scalar\n", regno);
11641 |  return -EINVAL;
11642 | 			}
11643 |
11644 |  if (is_kfunc_arg_constant(meta->btf, &args[i])) {
11645 |  if (meta->arg_constant.found) {
11646 | 					verbose(env, "verifier internal error: only one constant argument permitted\n");
11647 |  return -EFAULT;
11648 | 				}
11649 |  if (!tnum_is_const(reg->var_off)) {
11650 | 					verbose(env, "R%d must be a known constant\n", regno);
11651 |  return -EINVAL;
11652 | 				}
11653 | 				ret = mark_chain_precision(env, regno);
11654 |  if (ret < 0)
11655 |  return ret;
11656 | 				meta->arg_constant.found = true;
