### Report Summary

File:| /scratch/chenyuan-data/linux-debug/drivers/net/ethernet/8390/lib8390.c
---|---
Warning:| line 1048, column 3
Possible off-by-one: loop uses i < bound but also accesses a[i + 1]

### Annotated Source Code


998   | }
999   |
1000  |
1001  |
1002  |
1003  | /* This page of functions should be 8390 generic */
1004  | /* Follow National Semi's recommendations for initializing the "NIC". */
1005  |
1006  | /**
1007  |  * NS8390_init - initialize 8390 hardware
1008  |  * @dev: network device to initialize
1009  |  * @startp: boolean.  non-zero value to initiate chip processing
1010  |  *
1011  |  *	Must be called with lock held.
1012  |  */
1013  |
1014  | static void __NS8390_init(struct net_device *dev, int startp)
1015  | {
1016  |  unsigned long e8390_base = dev->base_addr;
1017  |  struct ei_device *ei_local = netdev_priv(dev);
1018  |  int i;
1019  |  int endcfg = ei_local->word16
1020  | 	    ? (0x48 | ENDCFG_WTS | (ei_local->bigendian ? ENDCFG_BOS : 0))
1021  | 	    : 0x48;
1022  |
1023  |  BUILD_BUG_ON(sizeof(struct e8390_pkt_hdr) != 4);
1024  |  /* Follow National Semi's recommendations for initing the DP83902. */
1025  |  ei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD); /* 0x21 */
1026  |  ei_outb_p(endcfg, e8390_base + EN0_DCFG);	/* 0x48 or 0x49 */
1027  |  /* Clear the remote byte count registers. */
1028  |  ei_outb_p(0x00,  e8390_base + EN0_RCNTLO);
1029  |  ei_outb_p(0x00,  e8390_base + EN0_RCNTHI);
1030  |  /* Set to monitor and loopback mode -- this is vital!. */
1031  |  ei_outb_p(E8390_RXOFF, e8390_base + EN0_RXCR); /* 0x20 */
1032  |  ei_outb_p(E8390_TXOFF, e8390_base + EN0_TXCR); /* 0x02 */
1033  |  /* Set the transmit page and receive ring. */
1034  |  ei_outb_p(ei_local->tx_start_page, e8390_base + EN0_TPSR);
1035  | 	ei_local->tx1 = ei_local->tx2 = 0;
1036  |  ei_outb_p(ei_local->rx_start_page, e8390_base + EN0_STARTPG);
1037  |  ei_outb_p(ei_local->stop_page-1, e8390_base + EN0_BOUNDARY);	/* 3c503 says 0x3f,NS0x26*/
1038  | 	ei_local->current_page = ei_local->rx_start_page;		/* assert boundary+1 */
1039  |  ei_outb_p(ei_local->stop_page, e8390_base + EN0_STOPPG);
1040  |  /* Clear the pending interrupts and mask. */
1041  |  ei_outb_p(0xFF, e8390_base + EN0_ISR);
1042  |  ei_outb_p(0x00,  e8390_base + EN0_IMR);
1043  |
1044  |  /* Copy the station address into the DS8390 registers. */
1045  |
1046  |  ei_outb_p(E8390_NODMA + E8390_PAGE1 + E8390_STOP, e8390_base+E8390_CMD); /* 0x61 */
1047  |  for (i = 0; i < 6; i++) {
1048  |  ei_outb_p(dev->dev_addr[i], e8390_base + EN1_PHYS_SHIFT(i));
    Possible off-by-one: loop uses i < bound but also accesses a[i + 1]
1049  |  if ((netif_msg_probe(ei_local)) &&
1050  |  ei_inb_p(e8390_base + EN1_PHYS_SHIFT(i)) != dev->dev_addr[i])
1051  | 			netdev_err(dev,
1052  |  "Hw. address read/write mismap %d\n", i);
1053  | 	}
1054  |
1055  |  ei_outb_p(ei_local->rx_start_page, e8390_base + EN1_CURPAG);
1056  |  ei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);
1057  |
1058  | 	ei_local->tx1 = ei_local->tx2 = 0;
1059  | 	ei_local->txing = 0;
1060  |
1061  |  if (startp) {
1062  |  ei_outb_p(0xff,  e8390_base + EN0_ISR);
1063  |  ei_outb_p(ENISR_ALL,  e8390_base + EN0_IMR);
1064  |  ei_outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base+E8390_CMD);
1065  |  ei_outb_p(E8390_TXCONFIG, e8390_base + EN0_TXCR); /* xmit on. */
1066  |  /* 3c503 TechMan says rxconfig only after the NIC is started. */
1067  |  ei_outb_p(E8390_RXCONFIG, e8390_base + EN0_RXCR); /* rx on,  */
1068  | 		do_set_multicast_list(dev);	/* (re)load the mcast table */
1069  | 	}
1070  | }
1071  |
1072  | /* Trigger a transmit start, assuming the length is valid.
1073  |  Always called with the page lock held */
1074  |
1075  | static void NS8390_trigger_send(struct net_device *dev, unsigned int length,
1076  |  int start_page)
1077  | {
1078  |  unsigned long e8390_base = dev->base_addr;
