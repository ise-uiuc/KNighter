### Report Summary

File:| /scratch/chenyuan-data/linux-debug/drivers/input/mouse/appletouch.c
---|---
Warning:| line 405, column 12
Possible off-by-one: loop uses i < bound but also accesses a[i + 1]

### Annotated Source Code


355   |  /*
356   |  * Makes the finger detection more versatile.  For example,
357   |  * two fingers with no gap will be detected.  Also, my
358   |  * tests show it less likely to have intermittent loss
359   |  * of multiple finger readings while moving around (scrolling).
360   |  *
361   |  * Changes the multiple finger detection to counting humps on
362   |  * sensors (transitions from nonincreasing to increasing)
363   |  * instead of counting transitions from low sensors (no
364   |  * finger reading) to high sensors (finger above
365   |  * sensor)
366   |  *
367   |  * - Jason Parekh <jasonparekh@gmail.com>
368   |  */
369   |
370   | 		} else if (i < 1 ||
371   | 		    (!is_increasing && xy_sensors[i - 1] < xy_sensors[i])) {
372   | 			(*fingers)++;
373   | 			is_increasing = 1;
374   | 		} else if (i > 0 && (xy_sensors[i - 1] - xy_sensors[i] > threshold)) {
375   | 			is_increasing = 0;
376   | 		}
377   | 	}
378   |
379   |  if (*fingers < 1)     /* No need to continue if no fingers are found. */
380   |  return 0;
381   |
382   |  /*
383   |  * Use a smoothed version of sensor data for movement calculations, to
384   |  * combat noise without needing to rely so heavily on a threshold.
385   |  * This improves tracking.
386   |  *
387   |  * The smoothed array is bigger than the original so that the smoothing
388   |  * doesn't result in edge values being truncated.
389   |  */
390   |
391   |  memset(dev->smooth, 0, 4 * sizeof(dev->smooth[0]));
392   |  /* Pull base values, scaled up to help avoid truncation errors. */
393   |  for (i = 0; i < nb_sensors; i++)
394   | 		dev->smooth[i + 4] = xy_sensors[i] << ATP_SCALE;
395   |  memset(&dev->smooth[nb_sensors + 4], 0, 4 * sizeof(dev->smooth[0]));
396   |
397   |  for (pass = 0; pass < 4; pass++) {
398   |  /* Handle edge. */
399   | 		dev->smooth_tmp[0] = (dev->smooth[0] + dev->smooth[1]) / 2;
400   |
401   |  /* Average values with neighbors. */
402   |  for (i = 1; i < nb_sensors + 7; i++)
403   | 			dev->smooth_tmp[i] = (dev->smooth[i - 1] +
404   | 					      dev->smooth[i] * 2 +
405   |  dev->smooth[i + 1]) / 4;
    Possible off-by-one: loop uses i < bound but also accesses a[i + 1]
406   |
407   |  /* Handle other edge. */
408   | 		dev->smooth_tmp[i] = (dev->smooth[i - 1] + dev->smooth[i]) / 2;
409   |
410   |  memcpy(dev->smooth, dev->smooth_tmp, sizeof(dev->smooth));
411   | 	}
412   |
413   |  for (i = 0; i < nb_sensors + 8; i++) {
414   |  /*
415   |  * Skip values if they're small enough to be truncated to 0
416   |  * by scale. Mostly noise.
417   |  */
418   |  if ((dev->smooth[i] >> ATP_SCALE) > 0) {
419   | 			pcum += dev->smooth[i] * i;
420   | 			psum += dev->smooth[i];
421   | 		}
422   | 	}
423   |
424   |  if (psum > 0) {
425   | 		*z = psum >> ATP_SCALE;        /* Scale down pressure output. */
426   |  return pcum * fact / psum;
427   | 	}
428   |
429   |  return 0;
430   | }
431   |
432   | static inline void atp_report_fingers(struct input_dev *input, int fingers)
433   | {
434   | 	input_report_key(input, BTN_TOOL_FINGER, fingers == 1);
435   | 	input_report_key(input, BTN_TOOL_DOUBLETAP, fingers == 2);
