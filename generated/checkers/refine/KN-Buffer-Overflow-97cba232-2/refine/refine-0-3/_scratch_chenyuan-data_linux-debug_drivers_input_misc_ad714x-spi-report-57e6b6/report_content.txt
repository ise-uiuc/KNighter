### Report Summary

File:| /scratch/chenyuan-data/linux-debug/drivers/input/misc/ad714x-spi.c
---|---
Warning:| line 47, column 13
Possible off-by-one: loop uses i < bound but also accesses a[i + 1]

### Annotated Source Code


1     | // SPDX-License-Identifier: GPL-2.0-or-later
2     | /*
3     |  * AD714X CapTouch Programmable Controller driver (SPI bus)
4     |  *
5     |  * Copyright 2009-2011 Analog Devices Inc.
6     |  */
7     |
8     | #include <linux/input.h>	/* BUS_SPI */
9     | #include <linux/module.h>
10    | #include <linux/spi/spi.h>
11    | #include <linux/pm.h>
12    | #include <linux/types.h>
13    | #include "ad714x.h"
14    |
15    | #define AD714x_SPI_CMD_PREFIX      0xE000   /* bits 15:11 */
16    | #define AD714x_SPI_READ BIT(10)
17    |
18    | static int ad714x_spi_read(struct ad714x_chip *chip,
19    |  unsigned short reg, unsigned short *data, size_t len)
20    | {
21    |  struct spi_device *spi = to_spi_device(chip->dev);
22    |  struct spi_message message;
23    |  struct spi_transfer xfer[2];
24    |  int i;
25    |  int error;
26    |
27    | 	spi_message_init(&message);
28    |  memset(xfer, 0, sizeof(xfer));
29    |
30    | 	chip->xfer_buf[0] = cpu_to_be16(AD714x_SPI_CMD_PREFIX |
31    |  AD714x_SPI_READ | reg);
32    | 	xfer[0].tx_buf = &chip->xfer_buf[0];
33    | 	xfer[0].len = sizeof(chip->xfer_buf[0]);
34    | 	spi_message_add_tail(&xfer[0], &message);
35    |
36    | 	xfer[1].rx_buf = &chip->xfer_buf[1];
37    | 	xfer[1].len = sizeof(chip->xfer_buf[1]) * len;
38    | 	spi_message_add_tail(&xfer[1], &message);
39    |
40    | 	error = spi_sync(spi, &message);
41    |  if (unlikely(error)) {
42    |  dev_err(chip->dev, "SPI read error: %d\n", error);
43    |  return error;
44    | 	}
45    |
46    |  for (i = 0; i < len; i++)
47    | 		data[i] = be16_to_cpu(chip->xfer_buf[i + 1]);
    Possible off-by-one: loop uses i < bound but also accesses a[i + 1]
48    |
49    |  return 0;
50    | }
51    |
52    | static int ad714x_spi_write(struct ad714x_chip *chip,
53    |  unsigned short reg, unsigned short data)
54    | {
55    |  struct spi_device *spi = to_spi_device(chip->dev);
56    |  int error;
57    |
58    | 	chip->xfer_buf[0] = cpu_to_be16(AD714x_SPI_CMD_PREFIX | reg);
59    | 	chip->xfer_buf[1] = cpu_to_be16(data);
60    |
61    | 	error = spi_write(spi, (u8 *)chip->xfer_buf,
62    | 			  2 * sizeof(*chip->xfer_buf));
63    |  if (unlikely(error)) {
64    |  dev_err(chip->dev, "SPI write error: %d\n", error);
65    |  return error;
66    | 	}
67    |
68    |  return 0;
69    | }
70    |
71    | static int ad714x_spi_probe(struct spi_device *spi)
72    | {
73    |  struct ad714x_chip *chip;
74    |  int err;
75    |
76    | 	spi->bits_per_word = 8;
77    | 	err = spi_setup(spi);
