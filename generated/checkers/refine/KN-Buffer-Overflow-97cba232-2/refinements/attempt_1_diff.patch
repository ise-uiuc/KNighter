--- attempt_1_original.cpp+++ attempt_1.cpp@@ -23,322 +23,967 @@ using namespace ento;
 using namespace taint;

-// No custom program states are required for this checker.
-
 namespace {
-/* The checker callbacks are to be decided. */
+
 class SAGenTestChecker : public Checker<check::ASTCodeBody> {
-   mutable std::unique_ptr<BugType> BT;
-
-   public:
-      SAGenTestChecker() : BT(new BugType(this, "Off-by-one array access", "Array bounds")) {}
-
-      void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter &BR) const;
-
-   private:
-
-      // Helper predicates and analyzers
-      static const VarDecl *getCanonicalVarDecl(const VarDecl *V) {
-        return V ? V->getCanonicalDecl() : nullptr;
-      }
-
-      static bool isIntLiteralOne(const Expr *E) {
-        if (!E) return false;
-        E = E->IgnoreParenImpCasts();
-        if (const auto *IL = dyn_cast<IntegerLiteral>(E)) {
-          return IL->getValue() == 1;
-        }
+  mutable std::unique_ptr<BugType> BT;
+
+public:
+  SAGenTestChecker()
+      : BT(new BugType(this, "Off-by-one array access", "Array bounds")) {}
+
+  void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr,
+                        BugReporter &BR) const;
+
+private:
+  static const VarDecl *getCanonicalVarDecl(const VarDecl *V) {
+    return V ? V->getCanonicalDecl() : nullptr;
+  }
+
+  static bool isIntLiteralValue(const Expr *E, uint64_t V) {
+    if (!E)
+      return false;
+    E = E->IgnoreParenImpCasts();
+    if (const auto *IL = dyn_cast<IntegerLiteral>(E)) {
+      return IL->getValue() == V;
+    }
+    return false;
+  }
+
+  static bool isIntLiteralZero(const Expr *E) { return isIntLiteralValue(E, 0); }
+  static bool isIntLiteralOne(const Expr *E) { return isIntLiteralValue(E, 1); }
+
+  static bool isRefToVar(const Expr *E, const VarDecl *V) {
+    if (!E || !V)
+      return false;
+    E = E->IgnoreParenImpCasts();
+    if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {
+      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))
+        return VD->getCanonicalDecl() == getCanonicalVarDecl(V);
+    }
+    return false;
+  }
+
+  static bool isVarPlusOne(const Expr *E, const VarDecl *V) {
+    if (!E || !V)
+      return false;
+    E = E->IgnoreParenImpCasts();
+    const auto *BO = dyn_cast<BinaryOperator>(E);
+    if (!BO)
+      return false;
+    if (BO->getOpcode() != BO_Add)
+      return false;
+    const Expr *L = BO->getLHS();
+    const Expr *R = BO->getRHS();
+    if ((isRefToVar(L, V) && isIntLiteralOne(R)) ||
+        (isIntLiteralOne(L) && isRefToVar(R, V)))
+      return true;
+    return false;
+  }
+
+  static bool isMinusOneAdjustedExpr(const Expr *E) {
+    if (!E)
+      return false;
+    E = E->IgnoreParenImpCasts();
+    const auto *BO = dyn_cast<BinaryOperator>(E);
+    if (!BO)
+      return false;
+    if (BO->getOpcode() != BO_Sub)
+      return false;
+    return isIntLiteralOne(BO->getRHS());
+  }
+
+  static const VarDecl *getInductionVarFromInit(const Stmt *Init) {
+    if (!Init)
+      return nullptr;
+
+    if (const auto *DS = dyn_cast<DeclStmt>(Init)) {
+      if (!DS->isSingleDecl())
+        return nullptr;
+      const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());
+      if (!VD)
+        return nullptr;
+      if (!VD->getType()->isIntegerType())
+        return nullptr;
+      return getCanonicalVarDecl(VD);
+    }
+
+    if (const auto *BO = dyn_cast<BinaryOperator>(Init)) {
+      if (BO->getOpcode() != BO_Assign)
+        return nullptr;
+      const Expr *LHS = BO->getLHS();
+      const auto *DRE = dyn_cast<DeclRefExpr>(LHS->IgnoreParenImpCasts());
+      if (!DRE)
+        return nullptr;
+      const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());
+      if (!VD)
+        return nullptr;
+      if (!VD->getType()->isIntegerType())
+        return nullptr;
+      return getCanonicalVarDecl(VD);
+    }
+
+    return nullptr;
+  }
+
+  static bool isInitZero(const Stmt *Init, const VarDecl *V) {
+    if (!Init || !V)
+      return false;
+
+    if (const auto *DS = dyn_cast<DeclStmt>(Init)) {
+      if (!DS->isSingleDecl())
         return false;
-      }
-
-      static bool isRefToVar(const Expr *E, const VarDecl *V) {
-        if (!E || !V) return false;
-        E = E->IgnoreParenImpCasts();
-        if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {
-          if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))
-            return VD->getCanonicalDecl() == getCanonicalVarDecl(V);
-        }
+      if (const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl())) {
+        if (VD->getCanonicalDecl() != getCanonicalVarDecl(V))
+          return false;
+        const Expr *InitExpr = VD->getInit();
+        return InitExpr && isIntLiteralZero(InitExpr);
+      }
+      return false;
+    }
+
+    if (const auto *BO = dyn_cast<BinaryOperator>(Init)) {
+      if (BO->getOpcode() != BO_Assign)
         return false;
-      }
-
-      static bool isVarPlusOne(const Expr *E, const VarDecl *V) {
-        if (!E || !V) return false;
-        E = E->IgnoreParenImpCasts();
-        const auto *BO = dyn_cast<BinaryOperator>(E);
-        if (!BO) return false;
-        if (BO->getOpcode() != BO_Add) return false;
-        const Expr *L = BO->getLHS();
-        const Expr *R = BO->getRHS();
-        if ((isRefToVar(L, V) && isIntLiteralOne(R)) ||
-            (isIntLiteralOne(L) && isRefToVar(R, V)))
-          return true;
+      if (!isRefToVar(BO->getLHS(), V))
         return false;
-      }
-
-      static bool isMinusOneAdjustedExpr(const Expr *E) {
-        if (!E) return false;
-        E = E->IgnoreParenImpCasts();
-        const auto *BO = dyn_cast<BinaryOperator>(E);
-        if (!BO) return false;
-        if (BO->getOpcode() != BO_Sub) return false;
-        return isIntLiteralOne(BO->getRHS());
-      }
-
-      static const VarDecl *getInductionVarFromInit(const Stmt *Init) {
-        if (!Init) return nullptr;
-
-        if (const auto *DS = dyn_cast<DeclStmt>(Init)) {
-          if (!DS->isSingleDecl()) return nullptr;
-          const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());
-          if (!VD) return nullptr;
-          if (!VD->getType()->isIntegerType()) return nullptr;
-          return getCanonicalVarDecl(VD);
-        }
-
-        if (const auto *BO = dyn_cast<BinaryOperator>(Init)) {
-          if (BO->getOpcode() != BO_Assign) return nullptr;
-          const Expr *LHS = BO->getLHS();
-          const auto *DRE = dyn_cast<DeclRefExpr>(LHS->IgnoreParenImpCasts());
-          if (!DRE) return nullptr;
-          const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());
-          if (!VD) return nullptr;
-          if (!VD->getType()->isIntegerType()) return nullptr;
-          return getCanonicalVarDecl(VD);
-        }
-
-        return nullptr;
-      }
-
-      static bool isUnitStepIncrement(const Expr *Inc, const VarDecl *V) {
-        if (!Inc || !V) return false;
-        Inc = Inc->IgnoreParenImpCasts();
-
-        if (const auto *UO = dyn_cast<UnaryOperator>(Inc)) {
-          if (UO->isIncrementOp() && isRefToVar(UO->getSubExpr(), V))
+      return isIntLiteralZero(BO->getRHS());
+    }
+
+    return false;
+  }
+
+  static bool isUnitStepIncrement(const Expr *Inc, const VarDecl *V) {
+    if (!Inc || !V)
+      return false;
+    Inc = Inc->IgnoreParenImpCasts();
+
+    if (const auto *UO = dyn_cast<UnaryOperator>(Inc)) {
+      if (UO->isIncrementOp() && isRefToVar(UO->getSubExpr(), V))
+        return true;
+    }
+
+    if (const auto *CAO = dyn_cast<CompoundAssignOperator>(Inc)) {
+      if (CAO->getOpcode() == BO_AddAssign && isRefToVar(CAO->getLHS(), V) &&
+          isIntLiteralOne(CAO->getRHS()))
+        return true;
+    }
+
+    if (const auto *BO = dyn_cast<BinaryOperator>(Inc)) {
+      if (BO->getOpcode() == BO_Assign && isRefToVar(BO->getLHS(), V)) {
+        const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();
+        if (const auto *BO2 = dyn_cast<BinaryOperator>(RHS)) {
+          if (BO2->getOpcode() == BO_Add) {
+            const Expr *L = BO2->getLHS();
+            const Expr *R = BO2->getRHS();
+            if ((isRefToVar(L, V) && isIntLiteralOne(R)) ||
+                (isRefToVar(R, V) && isIntLiteralOne(L)))
+              return true;
+          }
+        }
+      }
+    }
+
+    return false;
+  }
+
+  static const Expr *stripCastsAndParens(const Expr *E) {
+    if (!E)
+      return nullptr;
+    E = E->IgnoreImpCasts();
+    while (true) {
+      if (const auto *PE = dyn_cast<ParenExpr>(E)) {
+        E = PE->getSubExpr()->IgnoreImpCasts();
+        continue;
+      }
+      break;
+    }
+    return E;
+  }
+
+  static bool analyzeLoopCondition(const Expr *Cond, const VarDecl *V,
+                                   bool &IsStrictUpper,
+                                   bool &IsMinusOneAdjusted,
+                                   const Expr *&BoundExprOut) {
+    IsStrictUpper = false;
+    IsMinusOneAdjusted = false;
+    BoundExprOut = nullptr;
+
+    if (!Cond || !V)
+      return false;
+    const auto *BO = dyn_cast<BinaryOperator>(Cond->IgnoreParenImpCasts());
+    if (!BO)
+      return false;
+
+    const Expr *L = BO->getLHS();
+    const Expr *R = BO->getRHS();
+
+    switch (BO->getOpcode()) {
+    case BO_LT:
+      if (isRefToVar(L, V)) {
+        IsStrictUpper = true;
+        if (isMinusOneAdjustedExpr(R))
+          IsMinusOneAdjusted = true;
+        BoundExprOut = R;
+        return true;
+      }
+      break;
+    case BO_GT:
+      if (isRefToVar(R, V)) {
+        IsStrictUpper = true;
+        if (isMinusOneAdjustedExpr(L))
+          IsMinusOneAdjusted = true;
+        BoundExprOut = L;
+        return true;
+      }
+      break;
+    case BO_LE:
+      if (isRefToVar(L, V) && isMinusOneAdjustedExpr(R)) {
+        IsStrictUpper = false;
+        IsMinusOneAdjusted = true;
+        BoundExprOut = R;
+        return true;
+      }
+      break;
+    case BO_GE:
+      if (isRefToVar(R, V) && isMinusOneAdjustedExpr(L)) {
+        IsStrictUpper = false;
+        IsMinusOneAdjusted = true;
+        BoundExprOut = L;
+        return true;
+      }
+      break;
+    default:
+      break;
+    }
+    return false;
+  }
+
+  static bool guardInCondition(const Expr *Cond, const VarDecl *V) {
+    if (!Cond || !V)
+      return false;
+    const Expr *C = Cond->IgnoreParenImpCasts();
+
+    if (const auto *BO = dyn_cast<BinaryOperator>(C)) {
+      // Handle logical-AND by searching either side for a valid guard.
+      if (BO->getOpcode() == BO_LAnd) {
+        return guardInCondition(BO->getLHS(), V) ||
+               guardInCondition(BO->getRHS(), V);
+      }
+
+      const Expr *L = BO->getLHS();
+      const Expr *R = BO->getRHS();
+      // i + 1 < X or i + 1 <= X
+      if ((BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE) &&
+          (isVarPlusOne(L, V))) {
+        return true;
+      }
+      // i < X - 1 or i <= X - 1
+      if ((BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE) &&
+          isRefToVar(L, V) && isMinusOneAdjustedExpr(R)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  static bool hasLocalGuardForASE(ASTContext &Ctx, const ArraySubscriptExpr *ASE,
+                                  const ForStmt *FS, const VarDecl *V) {
+    if (!ASE || !FS || !V)
+      return false;
+
+    llvm::SmallVector<DynTypedNode, 8> Worklist;
+    llvm::SmallPtrSet<const void *, 32> Visited;
+
+    Worklist.push_back(DynTypedNode::create<const Stmt>(*ASE));
+
+    while (!Worklist.empty()) {
+      DynTypedNode Node = Worklist.pop_back_val();
+      auto Parents = Ctx.getParents(Node);
+      for (const auto &P : Parents) {
+        const Stmt *PS = P.get<Stmt>();
+        if (!PS)
+          continue;
+
+        if (Visited.contains(PS))
+          continue;
+        Visited.insert(PS);
+
+        if (const auto *IFS = dyn_cast<IfStmt>(PS)) {
+          const Expr *Cond = IFS->getCond();
+          if (guardInCondition(Cond, V))
             return true;
         }

-        if (const auto *CAO = dyn_cast<CompoundAssignOperator>(Inc)) {
-          if (CAO->getOpcode() == BO_AddAssign && isRefToVar(CAO->getLHS(), V) &&
-              isIntLiteralOne(CAO->getRHS()))
+        if (PS == FS)
+          continue; // Reached the loop boundary on this path.
+
+        Worklist.push_back(P);
+      }
+    }
+
+    return false;
+  }
+
+  static bool sameBaseExpr(const Expr *A, const Expr *B) {
+    if (!A || !B)
+      return false;
+    A = stripCastsAndParens(A);
+    B = stripCastsAndParens(B);
+
+    if (A->getStmtClass() != B->getStmtClass()) {
+      const auto *MA = dyn_cast<MemberExpr>(A);
+      const auto *MB = dyn_cast<MemberExpr>(B);
+      if (!(MA && MB))
+        return false;
+    }
+
+    if (const auto *DA = dyn_cast<DeclRefExpr>(A)) {
+      if (const auto *DB = dyn_cast<DeclRefExpr>(B)) {
+        const auto *VA = dyn_cast<ValueDecl>(DA->getDecl());
+        const auto *VB = dyn_cast<ValueDecl>(DB->getDecl());
+        return VA && VB &&
+               VA->getCanonicalDecl() == VB->getCanonicalDecl();
+      }
+      return false;
+    }
+
+    if (const auto *MA = dyn_cast<MemberExpr>(A)) {
+      const auto *MB = dyn_cast<MemberExpr>(B);
+      if (!MB)
+        return false;
+      const auto *FA = MA->getMemberDecl();
+      const auto *FB = MB->getMemberDecl();
+      if (!FA || !FB || FA->getCanonicalDecl() != FB->getCanonicalDecl())
+        return false;
+      return sameBaseExpr(MA->getBase()->IgnoreImpCasts(),
+                          MB->getBase()->IgnoreImpCasts());
+    }
+
+    if (const auto *UA = dyn_cast<UnaryOperator>(A)) {
+      const auto *UB = dyn_cast<UnaryOperator>(B);
+      if (!UB)
+        return false;
+      if (UA->getOpcode() != UB->getOpcode())
+        return false;
+      if (UA->getOpcode() != UO_AddrOf && UA->getOpcode() != UO_Deref)
+        return false;
+      return sameBaseExpr(UA->getSubExpr()->IgnoreImpCasts(),
+                          UB->getSubExpr()->IgnoreParenImpCasts());
+    }
+
+    return false;
+  }
+
+  static bool isIndexVarOnly(const Expr *E, const VarDecl *V) {
+    return isRefToVar(E, V);
+  }
+
+  static bool hasPairedIndexAccessToSameBase(const Stmt *Scope,
+                                             const Expr *TargetBase,
+                                             const VarDecl *IVar,
+                                             const ArraySubscriptExpr *Skip) {
+    if (!Scope || !TargetBase || !IVar)
+      return false;
+
+    struct Finder : public RecursiveASTVisitor<Finder> {
+      const Expr *TargetBase;
+      const VarDecl *IVar;
+      const ArraySubscriptExpr *Skip;
+      bool Found = false;
+      static const Expr *strip(const Expr *E) {
+        return E ? E->IgnoreParenImpCasts() : nullptr;
+      }
+      Finder(const Expr *TargetBase, const VarDecl *IVar,
+             const ArraySubscriptExpr *Skip)
+          : TargetBase(TargetBase), IVar(IVar), Skip(Skip) {}
+
+      bool VisitArraySubscriptExpr(ArraySubscriptExpr *ASE) {
+        if (Found)
+          return true;
+        if (ASE == Skip)
+          return true;
+
+        const Expr *Base = strip(ASE->getBase());
+        const Expr *Idx = strip(ASE->getIdx());
+        if (!Base || !Idx)
+          return true;
+
+        if (sameBaseExpr(TargetBase, Base) && isRefToVar(Idx, IVar)) {
+          Found = true;
+        }
+
+        return true;
+      }
+    };
+
+    Finder F(TargetBase, IVar, Skip);
+    F.TraverseStmt(const_cast<Stmt *>(Scope));
+    return F.Found;
+  }
+
+  static bool getConstantArraySizeFromBase(const Expr *Base, llvm::APInt &Size) {
+    Base = stripCastsAndParens(Base);
+    if (!Base)
+      return false;
+
+    if (const auto *DRE = dyn_cast<DeclRefExpr>(Base)) {
+      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {
+        QualType QT = VD->getType();
+        if (const auto *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr())) {
+          Size = CAT->getSize();
+          return true;
+        }
+      }
+    } else if (const auto *ME = dyn_cast<MemberExpr>(Base)) {
+      if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl())) {
+        QualType FT = FD->getType();
+        if (const auto *CAT = dyn_cast<ConstantArrayType>(FT.getTypePtr())) {
+          Size = CAT->getSize();
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  static bool evaluateExprToAPSInt(const Expr *E, ASTContext &Ctx,
+                                   llvm::APSInt &Res) {
+    if (!E)
+      return false;
+    Expr::EvalResult ER;
+    if (E->EvaluateAsInt(ER, Ctx)) {
+      Res = ER.Val.getInt();
+      return true;
+    }
+    return false;
+  }
+
+  static bool exprsEqualConstInt(const Expr *A, const Expr *B,
+                                 ASTContext &Ctx) {
+    llvm::APSInt VA, VB;
+    if (!evaluateExprToAPSInt(A, Ctx, VA))
+      return false;
+    if (!evaluateExprToAPSInt(B, Ctx, VB))
+      return false;
+    return VA == VB;
+  }
+
+  static bool isExprMinusOneOf(const Expr *E, const Expr *Base, ASTContext &Ctx) {
+    E = stripCastsAndParens(E);
+    Base = stripCastsAndParens(Base);
+    const auto *BO = dyn_cast<BinaryOperator>(E);
+    if (!BO || BO->getOpcode() != BO_Sub)
+      return false;
+    if (!isIntLiteralOne(BO->getRHS()))
+      return false;
+    // Either structural equality is too hard; accept equal constant values.
+    if (exprsEqualConstInt(BO->getLHS(), Base, Ctx))
+      return true;
+    return false;
+  }
+
+  static bool loopBoundEqualsArraySize(const Expr *BoundExpr,
+                                       const Expr *ArrayBase,
+                                       ASTContext &Ctx) {
+    llvm::APInt ArrSize(64, 0);
+    if (!getConstantArraySizeFromBase(ArrayBase, ArrSize))
+      return false;
+
+    llvm::APSInt BoundVal;
+    if (!evaluateExprToAPSInt(BoundExpr, Ctx, BoundVal))
+      return false;
+
+    uint64_t ArrSz = ArrSize.getLimitedValue(UINT64_MAX);
+    uint64_t BVal = BoundVal.getLimitedValue(UINT64_MAX);
+    return ArrSz == BVal;
+  }
+
+  static const Stmt *getEnclosingFunctionBody(const Stmt *S, ASTContext &Ctx) {
+    if (!S)
+      return nullptr;
+    DynTypedNode N = DynTypedNode::create<const Stmt>(*S);
+    while (true) {
+      auto Parents = Ctx.getParents(N);
+      if (Parents.empty())
+        break;
+      bool Advanced = false;
+      for (const DynTypedNode &P : Parents) {
+        if (const auto *FD = P.get<FunctionDecl>()) {
+          return FD->getBody();
+        }
+        if (const Stmt *PS = P.get<Stmt>()) {
+          N = DynTypedNode::create<const Stmt>(*PS);
+          Advanced = true;
+          break;
+        }
+        if (const auto *DC = P.get<Decl>()) {
+          N = DynTypedNode::create<const Decl>(*DC);
+          Advanced = true;
+          break;
+        }
+      }
+      if (!Advanced)
+        break;
+    }
+    return nullptr;
+  }
+
+  static bool isAddrOrPtrArithBasePlusOne(const Expr *E, const Expr *Base) {
+    if (!E || !Base)
+      return false;
+    E = E->IgnoreParenImpCasts();
+    Base = stripCastsAndParens(Base);
+
+    if (const auto *UO = dyn_cast<UnaryOperator>(E)) {
+      if (UO->getOpcode() == UO_AddrOf) {
+        const Expr *Sub = UO->getSubExpr()->IgnoreParenImpCasts();
+        if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(Sub)) {
+          const Expr *ASEBase = ASE->getBase()->IgnoreParenImpCasts();
+          const Expr *Idx = ASE->getIdx()->IgnoreParenImpCasts();
+          if (sameBaseExpr(Base, ASEBase) && isIntLiteralOne(Idx))
             return true;
         }
-
-        if (const auto *BO = dyn_cast<BinaryOperator>(Inc)) {
-          if (BO->getOpcode() == BO_Assign && isRefToVar(BO->getLHS(), V)) {
-            const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();
-            if (const auto *BO2 = dyn_cast<BinaryOperator>(RHS)) {
-              if (BO2->getOpcode() == BO_Add) {
-                const Expr *L = BO2->getLHS();
-                const Expr *R = BO2->getRHS();
-                if ((isRefToVar(L, V) && isIntLiteralOne(R)) ||
-                    (isRefToVar(R, V) && isIntLiteralOne(L)))
-                  return true;
+      }
+    }
+
+    if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+      if (BO->getOpcode() == BO_Add) {
+        const Expr *L = BO->getLHS()->IgnoreParenImpCasts();
+        const Expr *R = BO->getRHS()->IgnoreParenImpCasts();
+        if ((sameBaseExpr(Base, L) && isIntLiteralOne(R)) ||
+            (sameBaseExpr(Base, R) && isIntLiteralOne(L)))
+          return true;
+      }
+    }
+
+    return false;
+  }
+
+  static bool branchContainsExitFromLoop(const Stmt *S, const ForStmt *FS,
+                                         ASTContext &Ctx) {
+    if (!S || !FS)
+      return false;
+
+    struct ExitFinder : public RecursiveASTVisitor<ExitFinder> {
+      const ForStmt *FS;
+      ASTContext &Ctx;
+      bool Found = false;
+
+      ExitFinder(const ForStmt *FS, ASTContext &Ctx) : FS(FS), Ctx(Ctx) {}
+
+      bool VisitReturnStmt(ReturnStmt *R) {
+        Found = true;
+        return true;
+      }
+
+      bool VisitBreakStmt(BreakStmt *B) {
+        if (breakTargetsLoop(B, FS, Ctx))
+          Found = true;
+        return true;
+      }
+
+      static bool breakTargetsLoop(const BreakStmt *B, const ForStmt *FS,
+                                   ASTContext &Ctx) {
+        if (!B || !FS)
+          return false;
+        DynTypedNode N = DynTypedNode::create<const Stmt>(*B);
+        while (true) {
+          auto Parents = Ctx.getParents(N);
+          if (Parents.empty())
+            break;
+          bool Advanced = false;
+          for (const DynTypedNode &P : Parents) {
+            if (const Stmt *PS = P.get<Stmt>()) {
+              if (isa<SwitchStmt>(PS)) {
+                // Break will target this switch, not the loop.
+                return false;
               }
+              if (isa<ForStmt>(PS) || isa<WhileStmt>(PS) || isa<DoStmt>(PS)) {
+                return PS == FS;
+              }
+              N = DynTypedNode::create<const Stmt>(*PS);
+              Advanced = true;
+              break;
+            }
+            if (const Decl *PD = P.get<Decl>()) {
+              N = DynTypedNode::create<const Decl>(*PD);
+              Advanced = true;
+              break;
             }
           }
-        }
-
+          if (!Advanced)
+            break;
+        }
         return false;
       }
-
-      static bool analyzeLoopCondition(const Expr *Cond, const VarDecl *V,
-                                       bool &IsStrictUpper, bool &IsMinusOneAdjusted) {
-        IsStrictUpper = false;
-        IsMinusOneAdjusted = false;
-
-        if (!Cond || !V) return false;
-        const auto *BO = dyn_cast<BinaryOperator>(Cond->IgnoreParenImpCasts());
-        if (!BO) return false;
-
-        const Expr *L = BO->getLHS();
-        const Expr *R = BO->getRHS();
-
-        switch (BO->getOpcode()) {
-        case BO_LT:
-          if (isRefToVar(L, V)) {
-            IsStrictUpper = true;
-            if (isMinusOneAdjustedExpr(R))
-              IsMinusOneAdjusted = true;
+    };
+
+    ExitFinder EF(FS, Ctx);
+    EF.TraverseStmt(const_cast<Stmt *>(S));
+    return EF.Found;
+  }
+
+  static bool condMatchesEarlyExitGuard(const Expr *Cond, const VarDecl *V,
+                                        const Expr *Bound, ASTContext &Ctx) {
+    if (!Cond || !V || !Bound)
+      return false;
+
+    Cond = stripCastsAndParens(Cond);
+
+    const auto checkPair = [&](const Expr *L, const Expr *R,
+                               BinaryOperatorKind Op) -> bool {
+      // Pattern 1: (i + 1) >= Bound or == Bound
+      if ((Op == BO_GE || Op == BO_EQ) && isVarPlusOne(L, V)) {
+        if (exprsEqualConstInt(R, Bound, Ctx))
+          return true;
+      }
+      // Pattern 2: i >= Bound - 1 or i == Bound - 1
+      if ((Op == BO_GE || Op == BO_EQ) && isRefToVar(L, V) &&
+          isExprMinusOneOf(R, Bound, Ctx)) {
+        return true;
+      }
+      return false;
+    };
+
+    if (const auto *BO = dyn_cast<BinaryOperator>(Cond)) {
+      const Expr *L = stripCastsAndParens(BO->getLHS());
+      const Expr *R = stripCastsAndParens(BO->getRHS());
+      BinaryOperatorKind Op = BO->getOpcode();
+
+      // Direct orientation
+      if (checkPair(L, R, Op))
+        return true;
+
+      // Symmetric orientation: e.g., Bound <= (i + 1) or (Bound - 1) <= i
+      // Convert LE to GE by swapping sides.
+      if (Op == BO_LE || Op == BO_EQ) {
+        if (checkPair(R, L, (Op == BO_LE ? BO_GE : BO_EQ)))
+          return true;
+      }
+      if (Op == BO_GE) {
+        if (checkPair(R, L, BO_GE))
+          return true;
+      }
+    }
+
+    return false;
+  }
+
+  static const Stmt *findTopLevelChildContaining(const Stmt *Body,
+                                                 const Stmt *Inner,
+                                                 ASTContext &Ctx) {
+    if (!Body || !Inner)
+      return nullptr;
+
+    const Stmt *Top = nullptr;
+    DynTypedNode N = DynTypedNode::create<const Stmt>(*Inner);
+    while (true) {
+      auto Parents = Ctx.getParents(N);
+      if (Parents.empty())
+        break;
+      bool Advanced = false;
+      for (const DynTypedNode &P : Parents) {
+        if (const Stmt *PS = P.get<Stmt>()) {
+          if (PS == Body) {
+            if (const Stmt *S = N.get<Stmt>())
+              return S;
+            return nullptr;
+          }
+          N = DynTypedNode::create<const Stmt>(*PS);
+          Advanced = true;
+          break;
+        }
+        if (const Decl *PD = P.get<Decl>()) {
+          N = DynTypedNode::create<const Decl>(*PD);
+          Advanced = true;
+          break;
+        }
+      }
+      if (!Advanced)
+        break;
+    }
+    return Top;
+  }
+
+  static bool stmtContainsTarget(const Stmt *Container, const Stmt *Inner) {
+    if (!Container || !Inner)
+      return false;
+    if (Container == Inner)
+      return true;
+
+    struct Finder : public RecursiveASTVisitor<Finder> {
+      const Stmt *Target;
+      bool Found = false;
+      Finder(const Stmt *T) : Target(T) {}
+      bool VisitStmt(Stmt *S) {
+        if (S == Target)
+          Found = true;
+        return !Found;
+      }
+    } F(Inner);
+
+    F.TraverseStmt(const_cast<Stmt *>(Container));
+    return F.Found;
+  }
+
+  static bool hasDominatingEarlyExitGuard(const ForStmt *FS,
+                                          const ArraySubscriptExpr *ASE,
+                                          const VarDecl *IVar,
+                                          const Expr *BoundExpr,
+                                          ASTContext &Ctx) {
+    if (!FS || !ASE || !IVar || !BoundExpr)
+      return false;
+
+    const Stmt *Body = FS->getBody();
+    if (!Body)
+      return false;
+
+    const CompoundStmt *CS = dyn_cast<CompoundStmt>(Body);
+    if (!CS)
+      return false;
+
+    const Stmt *Top = findTopLevelChildContaining(Body, ASE, Ctx);
+    if (!Top)
+      return false;
+
+    for (const Stmt *S : CS->body()) {
+      if (!S)
+        continue;
+      if (S == Top)
+        break;
+
+      // Search all IfStmts within S. If any matches guard and exits loop, suppress.
+      struct IfFinder : public RecursiveASTVisitor<IfFinder> {
+        const ForStmt *FS;
+        const VarDecl *IVar;
+        const Expr *BoundExpr;
+        ASTContext &Ctx;
+        bool Found = false;
+
+        IfFinder(const ForStmt *FS, const VarDecl *IVar, const Expr *BoundExpr,
+                 ASTContext &Ctx)
+            : FS(FS), IVar(IVar), BoundExpr(BoundExpr), Ctx(Ctx) {}
+
+        bool VisitIfStmt(IfStmt *IF) {
+          if (Found)
             return true;
+          const Expr *Cond = IF->getCond();
+          if (condMatchesEarlyExitGuard(Cond, IVar, BoundExpr, Ctx)) {
+            const Stmt *Then = IF->getThen();
+            if (branchContainsExitFromLoop(Then, FS, Ctx)) {
+              Found = true;
+            }
           }
-          break;
-        case BO_GT:
-          if (isRefToVar(R, V)) {
-            IsStrictUpper = true;
-            if (isMinusOneAdjustedExpr(L))
-              IsMinusOneAdjusted = true;
-            return true;
+          return true;
+        }
+      } FF(FS, IVar, BoundExpr, Ctx);
+
+      FF.TraverseStmt(const_cast<Stmt *>(S));
+      if (FF.Found)
+        return true;
+    }
+
+    return false;
+  }
+
+  bool isFalsePositive(const ArraySubscriptExpr *ASE,
+                       const ForStmt *FS,
+                       const VarDecl *IVar,
+                       const Expr *BoundExpr,
+                       ASTContext &Ctx) const {
+    if (hasLocalGuardForASE(Ctx, ASE, FS, IVar))
+      return true;
+
+    const Expr *Base = ASE->getBase()->IgnoreParenImpCasts();
+    if (hasRxBufOffsetOneSetupBefore(Base, FS, Ctx))
+      return true;
+
+    // New FP filter: if there's a dominating early-exit guard that ensures
+    // i+1 will not be used when out of bounds, suppress.
+    if (hasDominatingEarlyExitGuard(FS, ASE, IVar, BoundExpr, Ctx))
+      return true;
+
+    return false;
+  }
+
+  static bool hasRxBufOffsetOneSetupBefore(const Expr *Base,
+                                           const ForStmt *FS,
+                                           ASTContext &Ctx) {
+    if (!Base || !FS)
+      return false;
+
+    const Stmt *Body = getEnclosingFunctionBody(FS, Ctx);
+    if (!Body)
+      return false;
+
+    const SourceManager &SM = Ctx.getSourceManager();
+    SourceLocation LoopLoc = FS->getBeginLoc();
+
+    struct Finder : public RecursiveASTVisitor<Finder> {
+      const Expr *Base;
+      const ForStmt *FS;
+      ASTContext &Ctx;
+      const SourceManager &SM;
+      SourceLocation LoopLoc;
+      bool Found = false;
+
+      Finder(const Expr *Base, const ForStmt *FS,
+             ASTContext &Ctx)
+          : Base(Base), FS(FS), Ctx(Ctx), SM(Ctx.getSourceManager()),
+            LoopLoc(FS->getBeginLoc()) {}
+
+      bool VisitBinaryOperator(BinaryOperator *BO) {
+        if (Found)
+          return true;
+        if (!BO || BO->getOpcode() != BO_Assign)
+          return true;
+
+        if (!BO->getBeginLoc().isValid() || !LoopLoc.isValid())
+          return true;
+        if (!SM.isBeforeInTranslationUnit(BO->getBeginLoc(), LoopLoc))
+          return true;
+
+        const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();
+        const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();
+
+        bool LHSMatchesRxBuf = false;
+        if (const auto *ME = dyn_cast<MemberExpr>(LHS)) {
+          if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl())) {
+            LHSMatchesRxBuf = FD->getName().equals("rx_buf");
           }
-          break;
-        case BO_LE:
-          if (isRefToVar(L, V) && isMinusOneAdjustedExpr(R)) {
-            IsStrictUpper = false;
-            IsMinusOneAdjusted = true;
-            return true;
+        } else if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS)) {
+          if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {
+            LHSMatchesRxBuf = VD->getName().equals("rx_buf");
           }
-          break;
-        case BO_GE:
-          if (isRefToVar(R, V) && isMinusOneAdjustedExpr(L)) {
-            IsStrictUpper = false;
-            IsMinusOneAdjusted = true;
-            return true;
-          }
-          break;
-        default:
-          break;
-        }
-        return false;
-      }
-
-      static bool guardInCondition(const Expr *Cond, const VarDecl *V) {
-        if (!Cond || !V) return false;
-        const Expr *C = Cond->IgnoreParenImpCasts();
-
-        if (const auto *BO = dyn_cast<BinaryOperator>(C)) {
-          // Handle logical-AND by searching either side for a valid guard.
-          if (BO->getOpcode() == BO_LAnd) {
-            return guardInCondition(BO->getLHS(), V) || guardInCondition(BO->getRHS(), V);
-          }
-
-          const Expr *L = BO->getLHS();
-          const Expr *R = BO->getRHS();
-          // i + 1 < X or i + 1 <= X
-          if ((BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE) &&
-              (isVarPlusOne(L, V))) {
-            return true;
-          }
-          // i < X - 1 or i <= X - 1
-          if ((BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE) &&
-              isRefToVar(L, V) && isMinusOneAdjustedExpr(R)) {
-            return true;
-          }
-        }
-        return false;
-      }
-
-      static bool hasLocalGuardForASE(ASTContext &Ctx, const ArraySubscriptExpr *ASE,
-                                      const ForStmt *FS, const VarDecl *V) {
-        if (!ASE || !FS || !V) return false;
-
-        llvm::SmallVector<DynTypedNode, 8> Worklist;
-        llvm::SmallPtrSet<const void *, 32> Visited;
-
-        Worklist.push_back(DynTypedNode::create<const Stmt>(*ASE));
-
-        while (!Worklist.empty()) {
-          DynTypedNode Node = Worklist.pop_back_val();
-          auto Parents = Ctx.getParents(Node);
-          for (const auto &P : Parents) {
-            const Stmt *PS = P.get<Stmt>();
-            if (!PS) continue;
-
-            if (Visited.contains(PS))
-              continue;
-            Visited.insert(PS);
-
-            if (const auto *IFS = dyn_cast<IfStmt>(PS)) {
-              const Expr *Cond = IFS->getCond();
-              if (guardInCondition(Cond, V))
-                return true;
-            }
-
-            if (PS == FS)
-              continue; // Reached the loop boundary on this path.
-
-            Worklist.push_back(P);
-          }
-        }
-
-        return false;
-      }
-
-      void analyzeForStmt(const ForStmt *FS, ASTContext &Ctx, BugReporter &BR) const {
-        if (!FS) return;
-
-        const VarDecl *IVar = getInductionVarFromInit(FS->getInit());
-        if (!IVar) return;
-
-        bool IsStrictUpper = false;
-        bool IsMinusOneAdjusted = false;
-        const Expr *Cond = FS->getCond();
-        if (!Cond) return;
-        if (!analyzeLoopCondition(Cond, IVar, IsStrictUpper, IsMinusOneAdjusted))
-          return;
-
-        // Skip loops that already use (bound - 1).
-        if (IsMinusOneAdjusted) return;
-
-        // We only flag loops with strict upper bounds like i < N or N > i.
-        if (!IsStrictUpper) return;
-
-        // Ensure unit-step increment on i.
-        if (!isUnitStepIncrement(FS->getInc(), IVar))
-          return;
-
-        // Traverse the loop body and find a[i + 1]
-        struct BodyVisitor : public RecursiveASTVisitor<BodyVisitor> {
-          const SAGenTestChecker *Checker;
-          const ForStmt *FS;
-          const VarDecl *IVar;
-          ASTContext &Ctx;
-          BugReporter &BR;
-          const BugType &BT;
-
-          BodyVisitor(const SAGenTestChecker *Checker, const ForStmt *FS,
-                      const VarDecl *IVar, ASTContext &Ctx,
-                      BugReporter &BR, const BugType &BT)
-              : Checker(Checker), FS(FS), IVar(IVar), Ctx(Ctx), BR(BR), BT(BT) {}
-
-          bool VisitArraySubscriptExpr(ArraySubscriptExpr *ASE) {
-            if (!ASE) return true;
-            const Expr *Idx = ASE->getIdx()->IgnoreParenImpCasts();
-            // Only consider indices of the form i + 1 or 1 + i.
-            if (!Checker->isVarPlusOne(Idx, IVar))
-              return true;
-
-            // Check for a local guard like "if (i + 1 < X)" or "if (i < X - 1)".
-            if (Checker->hasLocalGuardForASE(Ctx, ASE, FS, IVar))
-              return true;
-
-            // Report the potential off-by-one.
-            PathDiagnosticLocation ELoc =
-                PathDiagnosticLocation::createBegin(ASE, BR.getSourceManager(), nullptr);
-
-            auto R = std::make_unique<BasicBugReport>(
-                BT,
-                "Possible off-by-one: loop uses i < bound but also accesses a[i + 1]",
-                ELoc);
-            R->addRange(ASE->getSourceRange());
-
-            // Optionally, highlight the loop condition too.
-            if (const Expr *Cond = FS->getCond()) {
-              R->addRange(Cond->getSourceRange());
-            }
-
-            BR.emitReport(std::move(R));
-            return true;
-          }
-        };
-
-        BodyVisitor V(this, FS, IVar, Ctx, BR, *BT);
-        if (const Stmt *Body = FS->getBody())
-          V.TraverseStmt(const_cast<Stmt *>(Body));
-      }
+        }
+
+        if (!LHSMatchesRxBuf)
+          return true;
+
+        if (SAGenTestChecker::isAddrOrPtrArithBasePlusOne(RHS, Base)) {
+          Found = true;
+        }
+
+        return true;
+      }
+    };
+
+    Finder F(Base, FS, Ctx);
+    F.TraverseStmt(const_cast<Stmt *>(Body));
+    return F.Found;
+  }
+
+  void analyzeForStmt(const ForStmt *FS, ASTContext &Ctx,
+                      BugReporter &BR) const {
+    if (!FS)
+      return;
+
+    const VarDecl *IVar = getInductionVarFromInit(FS->getInit());
+    if (!IVar)
+      return;
+
+    if (!isInitZero(FS->getInit(), IVar))
+      return;
+
+    bool IsStrictUpper = false;
+    bool IsMinusOneAdjusted = false;
+    const Expr *Cond = FS->getCond();
+    const Expr *BoundExpr = nullptr;
+    if (!Cond)
+      return;
+    if (!analyzeLoopCondition(Cond, IVar, IsStrictUpper, IsMinusOneAdjusted,
+                              BoundExpr))
+      return;
+
+    if (IsMinusOneAdjusted)
+      return;
+
+    if (!IsStrictUpper)
+      return;
+
+    if (!isUnitStepIncrement(FS->getInc(), IVar))
+      return;
+
+    struct BodyVisitor : public RecursiveASTVisitor<BodyVisitor> {
+      const SAGenTestChecker *Checker;
+      const ForStmt *FS;
+      const VarDecl *IVar;
+      ASTContext &Ctx;
+      BugReporter &BR;
+      const BugType &BT;
+      const Expr *BoundExpr;
+
+      BodyVisitor(const SAGenTestChecker *Checker, const ForStmt *FS,
+                  const VarDecl *IVar, ASTContext &Ctx, BugReporter &BR,
+                  const BugType &BT, const Expr *BoundExpr)
+          : Checker(Checker), FS(FS), IVar(IVar), Ctx(Ctx), BR(BR), BT(BT),
+            BoundExpr(BoundExpr) {}
+
+      bool VisitArraySubscriptExpr(ArraySubscriptExpr *ASE) {
+        if (!ASE)
+          return true;
+        const Expr *Idx = ASE->getIdx()->IgnoreParenImpCasts();
+        if (!Checker->isVarPlusOne(Idx, IVar))
+          return true;
+
+        if (Checker->isFalsePositive(ASE, FS, IVar, BoundExpr, Ctx))
+          return true;
+
+        const Expr *Base = ASE->getBase()->IgnoreParenImpCasts();
+        if (!Base || !BoundExpr)
+          return true;
+
+        if (!SAGenTestChecker::loopBoundEqualsArraySize(BoundExpr, Base, Ctx))
+          return true;
+
+        const Stmt *Body = FS->getBody();
+        if (!Body)
+          return true;
+
+        if (!Checker->hasPairedIndexAccessToSameBase(Body, Base, IVar, ASE))
+          return true;
+
+        PathDiagnosticLocation ELoc =
+            PathDiagnosticLocation::createBegin(ASE, BR.getSourceManager(),
+                                                nullptr);
+
+        auto R = std::make_unique<BasicBugReport>(
+            BT, "Possible off-by-one: loop uses i < bound but also accesses "
+                "a[i + 1]",
+            ELoc);
+        R->addRange(ASE->getSourceRange());
+
+        if (const Expr *Cond = FS->getCond()) {
+          R->addRange(Cond->getSourceRange());
+        }
+
+        BR.emitReport(std::move(R));
+        return true;
+      }
+    };
+
+    BodyVisitor V(this, FS, IVar, Ctx, BR, *BT, BoundExpr);
+    if (const Stmt *Body = FS->getBody())
+      V.TraverseStmt(const_cast<Stmt *>(Body));
+  }
 };

-void SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter &BR) const {
-  if (!D) return;
+void SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager &Mgr,
+                                        BugReporter &BR) const {
+  if (!D)
+    return;
   const Stmt *Body = D->getBody();
-  if (!Body) return;
-
-  // Visit all ForStmt nodes and analyze them.
+  if (!Body)
+    return;
+
   struct TopVisitor : public RecursiveASTVisitor<TopVisitor> {
     const SAGenTestChecker *Checker;
     ASTContext &Ctx;
     BugReporter &BR;

-    TopVisitor(const SAGenTestChecker *Checker, ASTContext &Ctx, BugReporter &BR)
+    TopVisitor(const SAGenTestChecker *Checker, ASTContext &Ctx,
+               BugReporter &BR)
         : Checker(Checker), Ctx(Ctx), BR(BR) {}

     bool VisitForStmt(ForStmt *FS) {
@@ -356,8 +1001,7 @@ extern "C" void clang_registerCheckers(CheckerRegistry &registry) {
   registry.addChecker<SAGenTestChecker>(
       "custom.SAGenTestChecker",
-      "Detects off-by-one array access in loops (i < N with a[i + 1])",
-      "");
+      "Detects off-by-one array access in loops (i < N with a[i + 1])", "");
 }

 extern "C" const char clang_analyzerAPIVersionString[] =
