### Report Summary

File:| /scratch/chenyuan-data/linux-debug/net/dsa/user.c
---|---
Warning:| line 2695, column 13
Use of netdev priv after free_netdev

### Annotated Source Code


18    | #include <net/selftests.h>
19    | #include <net/tc_act/tc_mirred.h>
20    | #include <linux/if_bridge.h>
21    | #include <linux/if_hsr.h>
22    | #include <net/dcbnl.h>
23    | #include <linux/netpoll.h>
24    | #include <linux/string.h>
25    |
26    | #include "conduit.h"
27    | #include "dsa.h"
28    | #include "netlink.h"
29    | #include "port.h"
30    | #include "switch.h"
31    | #include "tag.h"
32    | #include "user.h"
33    |
34    | struct dsa_switchdev_event_work {
35    |  struct net_device *dev;
36    |  struct net_device *orig_dev;
37    |  struct work_struct work;
38    |  unsigned long event;
39    |  /* Specific for SWITCHDEV_FDB_ADD_TO_DEVICE and
40    |  * SWITCHDEV_FDB_DEL_TO_DEVICE
41    |  */
42    |  unsigned char addr[ETH_ALEN];
43    | 	u16 vid;
44    | 	bool host_addr;
45    | };
46    |
47    | enum dsa_standalone_event {
48    | 	DSA_UC_ADD,
49    | 	DSA_UC_DEL,
50    | 	DSA_MC_ADD,
51    | 	DSA_MC_DEL,
52    | };
53    |
54    | struct dsa_standalone_event_work {
55    |  struct work_struct work;
56    |  struct net_device *dev;
57    |  enum dsa_standalone_event event;
58    |  unsigned char addr[ETH_ALEN];
59    | 	u16 vid;
60    | };
61    |
62    | struct dsa_host_vlan_rx_filtering_ctx {
63    |  struct net_device *dev;
64    |  const unsigned char *addr;
65    |  enum dsa_standalone_event event;
66    | };
67    |
68    | static bool dsa_switch_supports_uc_filtering(struct dsa_switch *ds)
69    | {
70    |  return ds->ops->port_fdb_add && ds->ops->port_fdb_del &&
71    | 	       ds->fdb_isolation && !ds->vlan_filtering_is_global &&
72    | 	       !ds->needs_standalone_vlan_filtering;
73    | }
74    |
75    | static bool dsa_switch_supports_mc_filtering(struct dsa_switch *ds)
76    | {
77    |  return ds->ops->port_mdb_add && ds->ops->port_mdb_del &&
78    | 	       ds->fdb_isolation && !ds->vlan_filtering_is_global &&
79    | 	       !ds->needs_standalone_vlan_filtering;
80    | }
81    |
82    | static void dsa_user_standalone_event_work(struct work_struct *work)
83    | {
84    |  struct dsa_standalone_event_work *standalone_work =
85    |  container_of(work, struct dsa_standalone_event_work, work);
86    |  const unsigned char *addr = standalone_work->addr;
87    |  struct net_device *dev = standalone_work->dev;
88    |  struct dsa_port *dp = dsa_user_to_port(dev);
89    |  struct switchdev_obj_port_mdb mdb;
90    |  struct dsa_switch *ds = dp->ds;
91    | 	u16 vid = standalone_work->vid;
92    |  int err;
93    |
94    |  switch (standalone_work->event) {
95    |  case DSA_UC_ADD:
96    | 		err = dsa_port_standalone_host_fdb_add(dp, addr, vid);
97    |  if (err) {
98    |  dev_err(ds->dev,
99    |  "port %d failed to add %pM vid %d to fdb: %d\n",
100   |  dp->index, addr, vid, err);
2528  |  /* Try to save one extra realloc later in the TX path (in the conduit)
2529  |  * by also inheriting the conduit's needed headroom and tailroom.
2530  |  * The 8021q driver also does this.
2531  |  */
2532  | 	user->needed_headroom += conduit->needed_headroom;
2533  | 	user->needed_tailroom += conduit->needed_tailroom;
2534  |
2535  | 	p->xmit = cpu_dp->tag_ops->xmit;
2536  |
2537  | 	user->features = conduit->vlan_features | NETIF_F_HW_TC;
2538  | 	user->hw_features |= NETIF_F_HW_TC;
2539  | 	user->features |= NETIF_F_LLTX;
2540  |  if (user->needed_tailroom)
2541  | 		user->features &= ~(NETIF_F_SG | NETIF_F_FRAGLIST);
2542  |  if (ds->needs_standalone_vlan_filtering)
2543  | 		user->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
2544  | }
2545  |
2546  | int dsa_user_suspend(struct net_device *user_dev)
2547  | {
2548  |  struct dsa_port *dp = dsa_user_to_port(user_dev);
2549  |
2550  |  if (!netif_running(user_dev))
2551  |  return 0;
2552  |
2553  | 	netif_device_detach(user_dev);
2554  |
2555  | 	rtnl_lock();
2556  | 	phylink_stop(dp->pl);
2557  | 	rtnl_unlock();
2558  |
2559  |  return 0;
2560  | }
2561  |
2562  | int dsa_user_resume(struct net_device *user_dev)
2563  | {
2564  |  struct dsa_port *dp = dsa_user_to_port(user_dev);
2565  |
2566  |  if (!netif_running(user_dev))
2567  |  return 0;
2568  |
2569  | 	netif_device_attach(user_dev);
2570  |
2571  | 	rtnl_lock();
2572  | 	phylink_start(dp->pl);
2573  | 	rtnl_unlock();
2574  |
2575  |  return 0;
2576  | }
2577  |
2578  | int dsa_user_create(struct dsa_port *port)
2579  | {
2580  |  struct net_device *conduit = dsa_port_to_conduit(port);
2581  |  struct dsa_switch *ds = port->ds;
2582  |  struct net_device *user_dev;
2583  |  struct dsa_user_priv *p;
2584  |  const char *name;
2585  |  int assign_type;
2586  |  int ret;
2587  |
2588  |  if (!ds->num_tx_queues)
    1Assuming field 'num_tx_queues' is not equal to 0→
    2←Taking false branch→
2589  | 		ds->num_tx_queues = 1;
2590  |
2591  |  if (port->name) {
    3←Assuming field 'name' is null→
    4←Taking false branch→
2592  | 		name = port->name;
2593  | 		assign_type = NET_NAME_PREDICTABLE;
2594  | 	} else {
2595  |  name = "eth%d";
2596  |  assign_type = NET_NAME_ENUM;
2597  | 	}
2598  |
2599  |  user_dev = alloc_netdev_mqs(sizeof(struct dsa_user_priv), name,
2600  | 				    assign_type, ether_setup,
2601  | 				    ds->num_tx_queues, 1);
2602  |  if (user_dev == NULL)
    5←Assuming 'user_dev' is not equal to NULL→
    6←Taking false branch→
2603  |  return -ENOMEM;
2604  |
2605  |  user_dev->rtnl_link_ops = &dsa_link_ops;
2606  | 	user_dev->ethtool_ops = &dsa_user_ethtool_ops;
2607  | #if IS_ENABLED(CONFIG_DCB)
2608  |  user_dev->dcbnl_ops = &dsa_user_dcbnl_ops;
2609  | #endif
2610  |  if (!is_zero_ether_addr(port->mac))
    7←Taking true branch→
2611  |  eth_hw_addr_set(user_dev, port->mac);
2612  |  else
2613  | 		eth_hw_addr_inherit(user_dev, conduit);
2614  |  user_dev->priv_flags |= IFF_NO_QUEUE;
2615  |  if (dsa_switch_supports_uc_filtering(ds))
    8←Taking false branch→
2616  | 		user_dev->priv_flags |= IFF_UNICAST_FLT;
2617  |  user_dev->netdev_ops = &dsa_user_netdev_ops;
2618  |  if (ds->ops->port_max_mtu)
    9←Assuming field 'port_max_mtu' is null→
    10←Taking false branch→
2619  | 		user_dev->max_mtu = ds->ops->port_max_mtu(ds, port->index);
2620  |  SET_NETDEV_DEVTYPE(user_dev, &dsa_type);
2621  |
2622  |  SET_NETDEV_DEV(user_dev, port->ds->dev);
2623  |  SET_NETDEV_DEVLINK_PORT(user_dev, &port->devlink_port);
    11←Assuming field 'reg_state' is equal to NETREG_UNINITIALIZED→
    12←Taking false branch→
2624  | 	user_dev->dev.of_node = port->dn;
2625  | 	user_dev->vlan_features = conduit->vlan_features;
2626  |
2627  | 	p = netdev_priv(user_dev);
2628  | 	user_dev->pcpu_stat_type = NETDEV_PCPU_STAT_TSTATS;
2629  |
2630  | 	ret = gro_cells_init(&p->gcells, user_dev);
2631  |  if (ret)
    13←Assuming 'ret' is not equal to 0→
    14←Taking true branch→
2632  |  goto out_free;
    15←Control jumps to line 2694→
2633  |
2634  | 	p->dp = port;
2635  | 	INIT_LIST_HEAD(&p->mall_tc_list);
2636  | 	port->user = user_dev;
2637  | 	dsa_user_setup_tagger(user_dev);
2638  |
2639  | 	netif_carrier_off(user_dev);
2640  |
2641  | 	ret = dsa_user_phy_setup(user_dev);
2642  |  if (ret) {
2643  | 		netdev_err(user_dev,
2644  |  "error %d setting up PHY for tree %d, switch %d, port %d\n",
2645  | 			   ret, ds->dst->index, ds->index, port->index);
2646  |  goto out_gcells;
2647  | 	}
2648  |
2649  | 	rtnl_lock();
2650  |
2651  | 	ret = dsa_user_change_mtu(user_dev, ETH_DATA_LEN);
2652  |  if (ret && ret != -EOPNOTSUPP)
2653  |  dev_warn(ds->dev, "nonfatal error %d setting MTU to %d on port %d\n",
2654  |  ret, ETH_DATA_LEN, port->index);
2655  |
2656  | 	ret = register_netdevice(user_dev);
2657  |  if (ret) {
2658  | 		netdev_err(conduit, "error %d registering interface %s\n",
2659  | 			   ret, user_dev->name);
2660  | 		rtnl_unlock();
2661  |  goto out_phy;
2662  | 	}
2663  |
2664  |  if (IS_ENABLED(CONFIG_DCB)) {
2665  | 		ret = dsa_user_dcbnl_init(user_dev);
2666  |  if (ret) {
2667  | 			netdev_err(user_dev,
2668  |  "failed to initialize DCB: %pe\n",
2669  | 				   ERR_PTR(ret));
2670  | 			rtnl_unlock();
2671  |  goto out_unregister;
2672  | 		}
2673  | 	}
2674  |
2675  | 	ret = netdev_upper_dev_link(conduit, user_dev, NULL);
2676  |
2677  | 	rtnl_unlock();
2678  |
2679  |  if (ret)
2680  |  goto out_unregister;
2681  |
2682  |  return 0;
2683  |
2684  | out_unregister:
2685  | 	unregister_netdev(user_dev);
2686  | out_phy:
2687  | 	rtnl_lock();
2688  | 	phylink_disconnect_phy(p->dp->pl);
2689  | 	rtnl_unlock();
2690  | 	dsa_port_phylink_destroy(p->dp);
2691  | out_gcells:
2692  | 	gro_cells_destroy(&p->gcells);
2693  | out_free:
2694  |  free_netdev(user_dev);
2695  |  port->user = NULL;
    16←Use of netdev priv after free_netdev
2696  |  return ret;
2697  | }
2698  |
2699  | void dsa_user_destroy(struct net_device *user_dev)
2700  | {
2701  |  struct net_device *conduit = dsa_user_to_conduit(user_dev);
2702  |  struct dsa_port *dp = dsa_user_to_port(user_dev);
2703  |  struct dsa_user_priv *p = netdev_priv(user_dev);
2704  |
2705  | 	netif_carrier_off(user_dev);
2706  | 	rtnl_lock();
2707  | 	netdev_upper_dev_unlink(conduit, user_dev);
2708  | 	unregister_netdevice(user_dev);
2709  | 	phylink_disconnect_phy(dp->pl);
2710  | 	rtnl_unlock();
2711  |
2712  | 	dsa_port_phylink_destroy(dp);
2713  | 	gro_cells_destroy(&p->gcells);
2714  | 	free_netdev(user_dev);
2715  | }
2716  |
2717  | int dsa_user_change_conduit(struct net_device *dev, struct net_device *conduit,
2718  |  struct netlink_ext_ack *extack)
2719  | {
2720  |  struct net_device *old_conduit = dsa_user_to_conduit(dev);
2721  |  struct dsa_port *dp = dsa_user_to_port(dev);
2722  |  struct dsa_switch *ds = dp->ds;
2723  |  struct net_device *upper;
2724  |  struct list_head *iter;
2725  |  int err;
