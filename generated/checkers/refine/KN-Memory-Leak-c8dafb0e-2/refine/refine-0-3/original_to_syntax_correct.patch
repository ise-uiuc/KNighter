--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -22,50 +22,75 @@
 // Map: return-symbol of hwrm_req_init() -> req MemRegion*
 REGISTER_MAP_WITH_PROGRAMSTATE(PendingInitMap, SymbolRef, const MemRegion *)
-// Set: Acquired req MemRegion*s that require hwrm_req_drop() before exit
-REGISTER_SET_WITH_PROGRAMSTATE(AcquiredReqs, const MemRegion *)
+
+// Map: req MemRegion* -> owning StackFrameContext*, meaning the req was
+// successfully acquired (hwrm_req_init succeeded) in that stack frame and
+// requires hwrm_req_drop() before exiting the frame.
+REGISTER_MAP_WITH_PROGRAMSTATE(AcquiredReqsMap, const MemRegion *, const StackFrameContext *)

 namespace {

-static bool isCallTo(const CallEvent &Call, StringRef Name, CheckerContext &C) {
-  const Expr *Origin = Call.getOriginExpr();
-  if (!Origin)
-    return false;
-  return ExprHasName(Origin, Name, C);
-}
-
-/* The checker callbacks are to be decided. */
+static bool isCallToExact(const CallEvent &Call, StringRef Name) {
+  if (const IdentifierInfo *ID = Call.getCalleeIdentifier())
+    return ID->getName() == Name;
+  return false;
+}
+
+static const StackFrameContext *getRegionOwnerFrame(const MemRegion *MR) {
+  if (!MR)
+    return nullptr;
+
+  // Use the base region to strip element/field offsets.
+  MR = MR->getBaseRegion();
+
+  if (const auto *VR = dyn_cast<VarRegion>(MR))
+    return VR->getStackFrame();
+
+  // If it's not a VarRegion (e.g., globals), we can't attribute it to a frame.
+  // Return nullptr so we won't report on unrelated frames.
+  return nullptr;
+}
+
+static bool belongsToFrame(const MemRegion *MR, const StackFrameContext *SFC) {
+  const StackFrameContext *Owner = getRegionOwnerFrame(MR);
+  return Owner && Owner == SFC;
+}
+
 class SAGenTestChecker : public Checker<
     check::PostCall,
     check::PreStmt<ReturnStmt>,
     check::EndFunction,
     eval::Assume> {
-   mutable std::unique_ptr<BugType> BT;
-
-   public:
-      SAGenTestChecker() {
-        BT = std::make_unique<BugType>(
-            this,
-            "Missing hwrm_req_drop() after hwrm_req_init()",
-            "Resource management");
-      }
-
-      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;
-      void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;
-      void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;
-      ProgramStateRef evalAssume(ProgramStateRef State, SVal Cond, bool Assumption) const;
-
-   private:
-
-      void reportLeak(CheckerContext &C, const Stmt *S) const;
+  mutable std::unique_ptr<BugType> BT;
+
+public:
+  SAGenTestChecker() {
+    BT = std::make_unique<BugType>(
+        this,
+        "Missing hwrm_req_drop() after hwrm_req_init()",
+        "Resource management");
+  }
+
+  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;
+  void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;
+  void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;
+  ProgramStateRef evalAssume(ProgramStateRef State, SVal Cond, bool Assumption) const;
+
+private:
+  // Helper that answers whether we have any acquired reqs in the current frame.
+  bool hasAcquiredInCurrentFrame(ProgramStateRef State, const StackFrameContext *CurSFC) const;
+
+  // Helper to purge all acquired reqs owned by the current frame from state.
+  ProgramStateRef removeAllInCurrentFrame(ProgramStateRef State, const StackFrameContext *CurSFC) const;
+
+  void reportLeak(CheckerContext &C, const Stmt *S) const;
 };

 void SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const {
   ProgramStateRef State = C.getState();

   // Track hwrm_req_init(bp, req, ...)
-  if (isCallTo(Call, "hwrm_req_init", C)) {
-    // Ensure we have at least 2 args: 0: bp, 1: req
+  if (isCallToExact(Call, "hwrm_req_init")) {
     if (Call.getNumArgs() < 2)
       return;

@@ -73,9 +98,10 @@     if (!ReqExpr)
       return;

-    const MemRegion *ReqMR = getMemRegionFromExpr(ReqExpr, C);
-    if (!ReqMR)
-      return;
+    const MemRegion *ReqMR = State->getSVal(ReqExpr, C.getLocationContext()).getAsRegion();
+    if (!ReqMR)
+      return;
+
     ReqMR = ReqMR->getBaseRegion();
     if (!ReqMR)
       return;
@@ -84,14 +110,14 @@     if (!RetSym)
       return;

-    // Record pending init: we'll determine success in evalAssume
+    // Record pending init keyed by the return symbol.
     State = State->set<PendingInitMap>(RetSym, ReqMR);
     C.addTransition(State);
     return;
   }

   // Track hwrm_req_drop(bp, req)
-  if (isCallTo(Call, "hwrm_req_drop", C)) {
+  if (isCallToExact(Call, "hwrm_req_drop")) {
     if (Call.getNumArgs() < 2)
       return;

@@ -99,17 +125,16 @@     if (!ReqExpr)
       return;

-    const MemRegion *ReqMR = getMemRegionFromExpr(ReqExpr, C);
+    const MemRegion *ReqMR = State->getSVal(ReqExpr, C.getLocationContext()).getAsRegion();
     if (!ReqMR)
       return;
     ReqMR = ReqMR->getBaseRegion();
     if (!ReqMR)
       return;

-    // On drop, remove from acquired set (if present)
-    auto Set = State->get<AcquiredReqs>();
-    if (Set.contains(ReqMR)) {
-      State = State->remove<AcquiredReqs>(ReqMR);
+    // Remove from acquired map if present.
+    if (State->get<AcquiredReqsMap>(ReqMR)) {
+      State = State->remove<AcquiredReqsMap>(ReqMR);
       C.addTransition(State);
     }
     return;
@@ -120,39 +145,44 @@   if (!State)
     return State;

-  // Handle pattern: if (rc) or if (!rc) or if (rc == 0) / if (rc != 0)
+  // Case 1: plain symbolic condition like 'if (rc)'
   if (std::optional<NonLoc> NL = Cond.getAs<NonLoc>()) {
-    // Case 1: plain symbolic value 'rc'
     if (SymbolRef Sym = NL->getAsSymbol()) {
-      const MemRegion *const *PendingReq = State->get<PendingInitMap>(Sym);
-      if (PendingReq) {
-        // if (rc) with Assumption == false means rc == 0 (success)
+      if (const MemRegion *const *PendingReq = State->get<PendingInitMap>(Sym)) {
+        // For 'if (rc)': Assumption == false means rc == 0 (success branch)
         if (!Assumption) {
-          State = State->add<AcquiredReqs>(*PendingReq);
+          const MemRegion *ReqMR = *PendingReq;
+          const StackFrameContext *Owner = getRegionOwnerFrame(ReqMR);
+          if (Owner)
+            State = State->set<AcquiredReqsMap>(ReqMR, Owner);
         }
-        // Consume the pending mapping either way
+        // Remove the pending mapping regardless of branch outcome.
         State = State->remove<PendingInitMap>(Sym);
       }
       return State;
     }

-    // Case 2: symbolic comparison with integer, usually rc == 0 or rc != 0
+    // Case 2: comparison like (rc == 0) or (rc != 0)
     if (SymbolRef SE = Cond.getAsSymbol()) {
       if (const auto *SIE = dyn_cast<SymIntExpr>(SE)) {
         BinaryOperator::Opcode Op = SIE->getOpcode();
         SymbolRef Sym = SIE->getLHS();
         const llvm::APSInt &RHS = SIE->getRHS();
         if (Sym) {
-          const MemRegion *const *PendingReq = State->get<PendingInitMap>(Sym);
-          if (PendingReq && RHS == 0) {
-            bool SuccessBranch = false;
-            if (Op == BO_EQ && Assumption)
-              SuccessBranch = true;        // (rc == 0) assumed true
-            else if (Op == BO_NE && !Assumption)
-              SuccessBranch = true;        // (rc != 0) assumed false
-
-            if (SuccessBranch) {
-              State = State->add<AcquiredReqs>(*PendingReq);
+          if (const MemRegion *const *PendingReq = State->get<PendingInitMap>(Sym)) {
+            if (RHS.isZero()) {
+              bool SuccessBranch = false;
+              if (Op == BO_EQ && Assumption)
+                SuccessBranch = true;     // (rc == 0) assumed true
+              else if (Op == BO_NE && !Assumption)
+                SuccessBranch = true;     // (rc != 0) assumed false
+
+              if (SuccessBranch) {
+                const MemRegion *ReqMR = *PendingReq;
+                const StackFrameContext *Owner = getRegionOwnerFrame(ReqMR);
+                if (Owner)
+                  State = State->set<AcquiredReqsMap>(ReqMR, Owner);
+              }
             }
             State = State->remove<PendingInitMap>(Sym);
           }
@@ -164,22 +194,65 @@   return State;
 }

+bool SAGenTestChecker::hasAcquiredInCurrentFrame(ProgramStateRef State,
+                                                 const StackFrameContext *CurSFC) const {
+  if (!CurSFC)
+    return false;
+
+  auto Map = State->get<AcquiredReqsMap>();
+  for (auto I = Map.begin(), E = Map.end(); I != E; ++I) {
+    const MemRegion *MR = I->first;
+    const StackFrameContext *Owner = I->second;
+    if (Owner == CurSFC && MR)
+      return true;
+  }
+  return false;
+}
+
+ProgramStateRef SAGenTestChecker::removeAllInCurrentFrame(ProgramStateRef State,
+                                                          const StackFrameContext *CurSFC) const {
+  if (!CurSFC)
+    return State;
+
+  auto Map = State->get<AcquiredReqsMap>();
+  for (auto I = Map.begin(), E = Map.end(); I != E; ++I) {
+    const MemRegion *MR = I->first;
+    const StackFrameContext *Owner = I->second;
+    if (Owner == CurSFC && MR)
+      State = State->remove<AcquiredReqsMap>(MR);
+  }
+  return State;
+}
+
 void SAGenTestChecker::checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const {
   if (!RS)
     return;

   ProgramStateRef State = C.getState();
-  // If any acquired req is still live, report a leak.
-  if (!State->get<AcquiredReqs>().isEmpty()) {
+  const StackFrameContext *CurSFC = C.getLocationContext()->getStackFrame();
+
+  // Only consider acquisitions owned by the current frame; this prevents
+  // reporting in unrelated inlined callees (e.g., page_pool helpers).
+  if (hasAcquiredInCurrentFrame(State, CurSFC)) {
     reportLeak(C, RS);
+    // Clean up current frame acquisitions to avoid polluting outer frames.
+    State = removeAllInCurrentFrame(State, CurSFC);
+    C.addTransition(State);
   }
 }

 void SAGenTestChecker::checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const {
   ProgramStateRef State = C.getState();
-  if (!State->get<AcquiredReqs>().isEmpty()) {
+  const StackFrameContext *CurSFC = C.getLocationContext()->getStackFrame();
+
+  if (hasAcquiredInCurrentFrame(State, CurSFC)) {
     reportLeak(C, nullptr);
   }
+
+  // Always purge current frame acquisitions at end of function to prevent
+  // state bleed into callers/callees.
+  State = removeAllInCurrentFrame(State, CurSFC);
+  C.addTransition(State);
 }

 void SAGenTestChecker::reportLeak(CheckerContext &C, const Stmt *S) const {
