--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -22,49 +22,85 @@
 // Map: return-symbol of hwrm_req_init() -> req MemRegion*
 REGISTER_MAP_WITH_PROGRAMSTATE(PendingInitMap, SymbolRef, const MemRegion *)
-// Set: Acquired req MemRegion*s that require hwrm_req_drop() before exit
-REGISTER_SET_WITH_PROGRAMSTATE(AcquiredReqs, const MemRegion *)
+// Map: return-symbol of hwrm_req_init() -> owning StackFrameContext*
+REGISTER_MAP_WITH_PROGRAMSTATE(PendingInitFrameMap, SymbolRef, const StackFrameContext *)
+// Map: Acquired req MemRegion* -> owning StackFrameContext*
+REGISTER_MAP_WITH_PROGRAMSTATE(ReqOwnerMap, const MemRegion *, const StackFrameContext *)

 namespace {

-static bool isCallTo(const CallEvent &Call, StringRef Name, CheckerContext &C) {
-  const Expr *Origin = Call.getOriginExpr();
-  if (!Origin)
-    return false;
-  return ExprHasName(Origin, Name, C);
-}
-
-/* The checker callbacks are to be decided. */
+static bool isCallNamed(const CallEvent &Call, StringRef Name) {
+  if (const IdentifierInfo *II = Call.getCalleeIdentifier())
+    return II->getName() == Name;
+  return false;
+}
+
+static const StackFrameContext *getCurrentSFC(CheckerContext &C) {
+  if (const auto *LC = C.getLocationContext())
+    return LC->getStackFrame();
+  return nullptr;
+}
+
 class SAGenTestChecker : public Checker<
     check::PostCall,
     check::PreStmt<ReturnStmt>,
     check::EndFunction,
+    check::DeadSymbols,
     eval::Assume> {
    mutable std::unique_ptr<BugType> BT;

-   public:
-      SAGenTestChecker() {
-        BT = std::make_unique<BugType>(
-            this,
-            "Missing hwrm_req_drop() after hwrm_req_init()",
-            "Resource management");
-      }
-
-      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;
-      void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;
-      void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;
-      ProgramStateRef evalAssume(ProgramStateRef State, SVal Cond, bool Assumption) const;
-
-   private:
-
-      void reportLeak(CheckerContext &C, const Stmt *S) const;
+public:
+  SAGenTestChecker() {
+    BT = std::make_unique<BugType>(
+        this,
+        "Missing hwrm_req_drop() after successful hwrm_req_init()",
+        "Resource management");
+  }
+
+  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;
+  void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;
+  void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;
+  ProgramStateRef evalAssume(ProgramStateRef State, SVal Cond, bool Assumption) const;
+  void checkDeadSymbols(SymbolReaper &SR, CheckerContext &C) const;
+
+private:
+  void reportLeak(CheckerContext &C, const Stmt *S) const;
+
+  static ProgramStateRef addOwned(ProgramStateRef State, const MemRegion *ReqMR,
+                                  const StackFrameContext *Owner) {
+    // Overwrite or set ownership of ReqMR to current Owner frame.
+    return State->set<ReqOwnerMap>(ReqMR, Owner);
+  }
+
+  static ProgramStateRef removeOwned(ProgramStateRef State, const MemRegion *ReqMR) {
+    return State->remove<ReqOwnerMap>(ReqMR);
+  }
+
+  static bool frameOwnsAny(ProgramStateRef State, const StackFrameContext *SFC) {
+    auto Map = State->get<ReqOwnerMap>();
+    for (const auto &E : Map) {
+      if (E.second == SFC)
+        return true;
+    }
+    return false;
+  }
+
+  static ProgramStateRef clearFrameOwned(ProgramStateRef State, const StackFrameContext *SFC) {
+    auto Map = State->get<ReqOwnerMap>();
+    for (const auto &E : Map) {
+      if (E.second == SFC) {
+        State = State->remove<ReqOwnerMap>(E.first);
+      }
+    }
+    return State;
+  }
 };

 void SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const {
   ProgramStateRef State = C.getState();

   // Track hwrm_req_init(bp, req, ...)
-  if (isCallTo(Call, "hwrm_req_init", C)) {
+  if (isCallNamed(Call, "hwrm_req_init")) {
     // Ensure we have at least 2 args: 0: bp, 1: req
     if (Call.getNumArgs() < 2)
       return;
@@ -84,14 +120,19 @@     if (!RetSym)
       return;

-    // Record pending init: we'll determine success in evalAssume
+    const StackFrameContext *SFC = getCurrentSFC(C);
+    if (!SFC)
+      return;
+
+    // Record pending init: success/failure will be determined in evalAssume.
     State = State->set<PendingInitMap>(RetSym, ReqMR);
+    State = State->set<PendingInitFrameMap>(RetSym, SFC);
     C.addTransition(State);
     return;
   }

   // Track hwrm_req_drop(bp, req)
-  if (isCallTo(Call, "hwrm_req_drop", C)) {
+  if (isCallNamed(Call, "hwrm_req_drop")) {
     if (Call.getNumArgs() < 2)
       return;

@@ -106,12 +147,9 @@     if (!ReqMR)
       return;

-    // On drop, remove from acquired set (if present)
-    auto Set = State->get<AcquiredReqs>();
-    if (Set.contains(ReqMR)) {
-      State = State->remove<AcquiredReqs>(ReqMR);
-      C.addTransition(State);
-    }
+    // On drop, remove from owner map (if present)
+    State = removeOwned(State, ReqMR);
+    C.addTransition(State);
     return;
   }
 }
@@ -120,42 +158,46 @@   if (!State)
     return State;

-  // Handle pattern: if (rc) or if (!rc) or if (rc == 0) / if (rc != 0)
+  // Helper lambda to process a symbol 'rc' used in the branch condition.
+  auto handleSym = [&](SymbolRef Sym, bool SuccessBranch) -> ProgramStateRef {
+    if (!Sym)
+      return State;
+    const MemRegion *const *PendingReq = State->get<PendingInitMap>(Sym);
+    const StackFrameContext *const *PendingSFC = State->get<PendingInitFrameMap>(Sym);
+    if (!PendingReq || !PendingSFC)
+      return State;
+
+    if (SuccessBranch) {
+      State = addOwned(State, *PendingReq, *PendingSFC);
+    }
+    // Consume the pending mapping in either case.
+    State = State->remove<PendingInitMap>(Sym);
+    State = State->remove<PendingInitFrameMap>(Sym);
+    return State;
+  };
+
+  // Handle common patterns: if (rc), if (!rc), if (rc == 0), if (rc != 0)
   if (std::optional<NonLoc> NL = Cond.getAs<NonLoc>()) {
-    // Case 1: plain symbolic value 'rc'
+    // Case 1: plain symbolic 'rc'
     if (SymbolRef Sym = NL->getAsSymbol()) {
-      const MemRegion *const *PendingReq = State->get<PendingInitMap>(Sym);
-      if (PendingReq) {
-        // if (rc) with Assumption == false means rc == 0 (success)
-        if (!Assumption) {
-          State = State->add<AcquiredReqs>(*PendingReq);
-        }
-        // Consume the pending mapping either way
-        State = State->remove<PendingInitMap>(Sym);
-      }
-      return State;
-    }
-
-    // Case 2: symbolic comparison with integer, usually rc == 0 or rc != 0
+      // if (rc) -> SuccessBranch is when Assumption == false (rc == 0)
+      bool SuccessBranch = !Assumption;
+      return handleSym(Sym, SuccessBranch);
+    }
+
+    // Case 2: symbolic integer comparisons: rc == 0 or rc != 0
     if (SymbolRef SE = Cond.getAsSymbol()) {
       if (const auto *SIE = dyn_cast<SymIntExpr>(SE)) {
         BinaryOperator::Opcode Op = SIE->getOpcode();
         SymbolRef Sym = SIE->getLHS();
         const llvm::APSInt &RHS = SIE->getRHS();
-        if (Sym) {
-          const MemRegion *const *PendingReq = State->get<PendingInitMap>(Sym);
-          if (PendingReq && RHS == 0) {
-            bool SuccessBranch = false;
-            if (Op == BO_EQ && Assumption)
-              SuccessBranch = true;        // (rc == 0) assumed true
-            else if (Op == BO_NE && !Assumption)
-              SuccessBranch = true;        // (rc != 0) assumed false
-
-            if (SuccessBranch) {
-              State = State->add<AcquiredReqs>(*PendingReq);
-            }
-            State = State->remove<PendingInitMap>(Sym);
-          }
+        if (RHS == 0 && Sym) {
+          bool SuccessBranch = false;
+          if (Op == BO_EQ && Assumption)
+            SuccessBranch = true;       // (rc == 0) assumed true
+          else if (Op == BO_NE && !Assumption)
+            SuccessBranch = true;       // (rc != 0) assumed false
+          return handleSym(Sym, SuccessBranch);
         }
       }
     }
@@ -169,17 +211,63 @@     return;

   ProgramStateRef State = C.getState();
-  // If any acquired req is still live, report a leak.
-  if (!State->get<AcquiredReqs>().isEmpty()) {
+  const StackFrameContext *SFC = getCurrentSFC(C);
+  if (!SFC)
+    return;
+
+  // Only report if the current frame owns any acquired req.
+  if (frameOwnsAny(State, SFC)) {
     reportLeak(C, RS);
+    // Prevent cascading reports by clearing ownership for this frame.
+    State = clearFrameOwned(State, SFC);
+    C.addTransition(State);
   }
 }

 void SAGenTestChecker::checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const {
   ProgramStateRef State = C.getState();
-  if (!State->get<AcquiredReqs>().isEmpty()) {
+  const StackFrameContext *SFC = getCurrentSFC(C);
+  if (!SFC)
+    return;
+
+  // Report if current function is ending and still owns any acquired req.
+  if (frameOwnsAny(State, SFC)) {
     reportLeak(C, nullptr);
   }
+
+  // Always clear ownership for this frame to avoid state leaking into callers.
+  State = clearFrameOwned(State, SFC);
+  C.addTransition(State);
+}
+
+void SAGenTestChecker::checkDeadSymbols(SymbolReaper &SR, CheckerContext &C) const {
+  ProgramStateRef State = C.getState();
+
+  // Clean up pending-inits whose return symbols died.
+  {
+    auto Map = State->get<PendingInitMap>();
+    for (const auto &E : Map) {
+      SymbolRef Sym = E.first;
+      if (SR.isDead(Sym)) {
+        State = State->remove<PendingInitMap>(Sym);
+        State = State->remove<PendingInitFrameMap>(Sym);
+      }
+    }
+  }
+
+  // Opportunistically remove owned entries whose regions are dead.
+  {
+    auto Map = State->get<ReqOwnerMap>();
+    for (const auto &E : Map) {
+      const MemRegion *MR = E.first;
+      if (!SR.isLiveRegion(MR)) {
+        State = State->remove<ReqOwnerMap>(MR);
+      }
+    }
+  }
+
+  if (State != C.getState())
+    C.addTransition(State);
 }

 void SAGenTestChecker::reportLeak(CheckerContext &C, const Stmt *S) const {
