### Report Summary

File:| /scratch/chenyuan-data/linux-debug/drivers/video/backlight/qcom-wled.c
---|---
Warning:| line 1412, column 10
Missing NULL-check after devm_kasprintf(); pointer may be NULL and is
dereferenced

### Annotated Source Code


1255  | }
1256  |
1257  | static const struct wled_var_cfg wled5_ovp_cfg = {
1258  | 	.fn = wled5_ovp_values_fn,
1259  | 	.size = 16,
1260  | };
1261  |
1262  | static u32 wled3_switch_freq_values_fn(u32 idx)
1263  | {
1264  |  return 19200 / (2 * (1 + idx));
1265  | }
1266  |
1267  | static const struct wled_var_cfg wled3_switch_freq_cfg = {
1268  | 	.fn = wled3_switch_freq_values_fn,
1269  | 	.size = 16,
1270  | };
1271  |
1272  | static const struct wled_var_cfg wled3_string_i_limit_cfg = {
1273  | 	.size = 26,
1274  | };
1275  |
1276  | static const u32 wled4_string_i_limit_values[] = {
1277  | 	0, 2500, 5000, 7500, 10000, 12500, 15000, 17500, 20000,
1278  | 	22500, 25000, 27500, 30000,
1279  | };
1280  |
1281  | static const struct wled_var_cfg wled4_string_i_limit_cfg = {
1282  | 	.values = wled4_string_i_limit_values,
1283  | 	.size = ARRAY_SIZE(wled4_string_i_limit_values),
1284  | };
1285  |
1286  | static const struct wled_var_cfg wled5_mod_sel_cfg = {
1287  | 	.size = 2,
1288  | };
1289  |
1290  | static const struct wled_var_cfg wled5_cabc_sel_cfg = {
1291  | 	.size = 4,
1292  | };
1293  |
1294  | static u32 wled_values(const struct wled_var_cfg *cfg, u32 idx)
1295  | {
1296  |  if (idx >= cfg->size)
1297  |  return UINT_MAX;
1298  |  if (cfg->fn)
1299  |  return cfg->fn(idx);
1300  |  if (cfg->values)
1301  |  return cfg->values[idx];
1302  |  return idx;
1303  | }
1304  |
1305  | static int wled_configure(struct wled *wled)
1306  | {
1307  |  struct wled_config *cfg = &wled->cfg;
1308  |  struct device *dev = wled->dev;
1309  |  const __be32 *prop_addr;
1310  | 	u32 size, val, c;
1311  |  int rc, i, j, string_len;
1312  |
1313  |  const struct wled_u32_opts *u32_opts = NULL;
1314  |  const struct wled_u32_opts wled3_opts[] = {
1315  | 		{
1316  | 			.name = "qcom,current-boost-limit",
1317  | 			.val_ptr = &cfg->boost_i_limit,
1318  | 			.cfg = &wled3_boost_i_limit_cfg,
1319  | 		},
1320  | 		{
1321  | 			.name = "qcom,current-limit",
1322  | 			.val_ptr = &cfg->string_i_limit,
1323  | 			.cfg = &wled3_string_i_limit_cfg,
1324  | 		},
1325  | 		{
1326  | 			.name = "qcom,ovp",
1327  | 			.val_ptr = &cfg->ovp,
1328  | 			.cfg = &wled3_ovp_cfg,
1329  | 		},
1330  | 		{
1331  | 			.name = "qcom,switching-freq",
1332  | 			.val_ptr = &cfg->switch_freq,
1333  | 			.cfg = &wled3_switch_freq_cfg,
1334  | 		},
1335  | 	};
1336  |
1337  |  const struct wled_u32_opts wled4_opts[] = {
1338  | 		{
1339  | 			.name = "qcom,current-boost-limit",
1340  | 			.val_ptr = &cfg->boost_i_limit,
1341  | 			.cfg = &wled4_boost_i_limit_cfg,
1342  | 		},
1343  | 		{
1344  | 			.name = "qcom,current-limit-microamp",
1345  | 			.val_ptr = &cfg->string_i_limit,
1346  | 			.cfg = &wled4_string_i_limit_cfg,
1347  | 		},
1348  | 		{
1349  | 			.name = "qcom,ovp-millivolt",
1350  | 			.val_ptr = &cfg->ovp,
1351  | 			.cfg = &wled4_ovp_cfg,
1352  | 		},
1353  | 		{
1354  | 			.name = "qcom,switching-freq",
1355  | 			.val_ptr = &cfg->switch_freq,
1356  | 			.cfg = &wled3_switch_freq_cfg,
1357  | 		},
1358  | 	};
1359  |
1360  |  const struct wled_u32_opts wled5_opts[] = {
1361  | 		{
1362  | 			.name = "qcom,current-boost-limit",
1363  | 			.val_ptr = &cfg->boost_i_limit,
1364  | 			.cfg = &wled5_boost_i_limit_cfg,
1365  | 		},
1366  | 		{
1367  | 			.name = "qcom,current-limit-microamp",
1368  | 			.val_ptr = &cfg->string_i_limit,
1369  | 			.cfg = &wled4_string_i_limit_cfg,
1370  | 		},
1371  | 		{
1372  | 			.name = "qcom,ovp-millivolt",
1373  | 			.val_ptr = &cfg->ovp,
1374  | 			.cfg = &wled5_ovp_cfg,
1375  | 		},
1376  | 		{
1377  | 			.name = "qcom,switching-freq",
1378  | 			.val_ptr = &cfg->switch_freq,
1379  | 			.cfg = &wled3_switch_freq_cfg,
1380  | 		},
1381  | 		{
1382  | 			.name = "qcom,modulator-sel",
1383  | 			.val_ptr = &cfg->mod_sel,
1384  | 			.cfg = &wled5_mod_sel_cfg,
1385  | 		},
1386  | 		{
1387  | 			.name = "qcom,cabc-sel",
1388  | 			.val_ptr = &cfg->cabc_sel,
1389  | 			.cfg = &wled5_cabc_sel_cfg,
1390  | 		},
1391  | 	};
1392  |
1393  |  const struct wled_bool_opts bool_opts[] = {
1394  | 		{ "qcom,cs-out", &cfg->cs_out_en, },
1395  | 		{ "qcom,ext-gen", &cfg->ext_gen, },
1396  | 		{ "qcom,cabc", &cfg->cabc, },
1397  | 		{ "qcom,external-pfet", &cfg->external_pfet, },
1398  | 		{ "qcom,auto-string-detection", &cfg->auto_detection_enabled, },
1399  | 	};
1400  |
1401  | 	prop_addr = of_get_address(dev->of_node, 0, NULL, NULL);
1402  |  if (!prop_addr) {
    1Assuming 'prop_addr' is non-null→
    2←Taking false branch→
1403  |  dev_err(wled->dev, "invalid IO resources\n");
1404  |  return -EINVAL;
1405  | 	}
1406  |  wled->ctrl_addr = be32_to_cpu(*prop_addr);
1407  |
1408  | 	rc = of_property_read_string(dev->of_node, "label", &wled->name);
1409  |  if (rc)
    3←Assuming 'rc' is not equal to 0→
    4←Taking true branch→
1410  |  wled->name = devm_kasprintf(dev, GFP_KERNEL, "%pOFn", dev->of_node);
1411  |
1412  |  switch (wled->version) {
    5←Missing NULL-check after devm_kasprintf(); pointer may be NULL and is dereferenced
1413  |  case 3:
1414  | 		u32_opts = wled3_opts;
1415  | 		size = ARRAY_SIZE(wled3_opts);
1416  | 		*cfg = wled3_config_defaults;
1417  | 		wled->wled_set_brightness = wled3_set_brightness;
1418  | 		wled->wled_sync_toggle = wled3_sync_toggle;
1419  | 		wled->max_string_count = 3;
1420  | 		wled->sink_addr = wled->ctrl_addr;
1421  |  break;
1422  |
1423  |  case 4:
1424  | 		u32_opts = wled4_opts;
1425  | 		size = ARRAY_SIZE(wled4_opts);
1426  | 		*cfg = wled4_config_defaults;
1427  | 		wled->wled_set_brightness = wled4_set_brightness;
1428  | 		wled->wled_sync_toggle = wled3_sync_toggle;
1429  | 		wled->wled_cabc_config = wled4_cabc_config;
1430  | 		wled->wled_ovp_delay = wled4_ovp_delay;
1431  | 		wled->wled_auto_detection_required =
1432  | 					wled4_auto_detection_required;
1433  | 		wled->max_string_count = 4;
1434  |
1435  | 		prop_addr = of_get_address(dev->of_node, 1, NULL, NULL);
1436  |  if (!prop_addr) {
1437  |  dev_err(wled->dev, "invalid IO resources\n");
1438  |  return -EINVAL;
1439  | 		}
1440  | 		wled->sink_addr = be32_to_cpu(*prop_addr);
1441  |  break;
1442  |
