--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -20,19 +20,96 @@ #include "clang/AST/ASTContext.h"
 #include "clang/AST/Expr.h"
 #include "clang/AST/Stmt.h"
+#include "clang/Lex/Lexer.h"

 using namespace clang;
 using namespace ento;
 using namespace taint;

-// Program-state: track pointers returned by devm_kasprintf that might be NULL and unchecked.
-// Key: base MemRegion* of the pointer; Value: false = not checked yet, true = checked.
-REGISTER_MAP_WITH_PROGRAMSTATE(PossibleNullPtrMap, const MemRegion*, bool)
-// Track simple pointer aliases (bidirectional, we store both directions).
-REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*, const MemRegion*)
+// Program-state: Track symbols returned by devm_kasprintf that might be NULL and are unchecked.
+// Key: SymbolRef of the pointer value; Value: false = not checked yet, true = checked.
+REGISTER_MAP_WITH_PROGRAMSTATE(PossibleNullSymMap, SymbolRef, bool)
+
+// Track which pointer SymbolRef is currently stored in a specific region (e.g., a variable or field).
+REGISTER_MAP_WITH_PROGRAMSTATE(Region2SymMap, const MemRegion*, SymbolRef)
+
+// Utility Functions (provided)
+// Going upward in an AST tree, and find the Stmt of a specific type
+template <typename T>
+const T* findSpecificTypeInParents(const Stmt *S, CheckerContext &C);
+
+// Going downward in an AST tree, and find the Stmt of a secific type
+// Only return one of the statements if there are many
+template <typename T>
+const T* findSpecificTypeInChildren(const Stmt *S);
+
+bool EvaluateExprToInt(llvm::APSInt &EvalRes, const Expr *expr, CheckerContext &C) {
+  Expr::EvalResult ExprRes;
+  if (expr->EvaluateAsInt(ExprRes, C.getASTContext())) {
+    EvalRes = ExprRes.Val.getInt();
+    return true;
+  }
+  return false;
+}
+
+const llvm::APSInt *inferSymbolMaxVal(SymbolRef Sym, CheckerContext &C) {
+  ProgramStateRef State = C.getState();
+  const llvm::APSInt *maxVal = State->getConstraintManager().getSymMaxVal(State, Sym);
+  return maxVal;
+}
+
+// The expression should be the DeclRefExpr of the array
+bool getArraySizeFromExpr(llvm::APInt &ArraySize, const Expr *E) {
+  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E->IgnoreImplicit())) {
+    if (const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl())) {
+      QualType QT = VD->getType();
+      if (const ConstantArrayType *ArrayType = dyn_cast<ConstantArrayType>(QT.getTypePtr())) {
+        ArraySize = ArrayType->getSize();
+        return true;
+      }
+    }
+  }
+  return false;
+}
+
+bool getStringSize(llvm::APInt &StringSize, const Expr *E) {
+  if (const auto *SL = dyn_cast<StringLiteral>(E->IgnoreImpCasts())) {
+    StringSize = llvm::APInt(32, SL->getLength());
+    return true;
+  }
+  return false;
+}
+
+const MemRegion* getMemRegionFromExpr(const Expr* E, CheckerContext &C) {
+  ProgramStateRef State = C.getState();
+  return State->getSVal(E, C.getLocationContext()).getAsRegion();
+}
+
+struct KnownDerefFunction {
+  const char *Name;                    ///< The function name.
+  llvm::SmallVector<unsigned, 4> Params; ///< The parameter indices that get dereferenced.
+};
+
+bool functionKnownToDeref(const CallEvent &Call,
+                          llvm::SmallVectorImpl<unsigned> &DerefParams) {
+  // No external table is provided; conservatively return false.
+  (void)Call;
+  (void)DerefParams;
+  return false;
+}
+
+bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C) {
+  if (!E)
+    return false;
+
+  const SourceManager &SM = C.getSourceManager();
+  const LangOptions &LangOpts = C.getLangOpts();
+  CharSourceRange Range = CharSourceRange::getTokenRange(E->getSourceRange());
+  StringRef ExprText = Lexer::getSourceText(Range, SM, LangOpts);
+  return ExprText.contains(Name);
+}

 namespace {
-/* The checker callbacks are to be decided. */
 class SAGenTestChecker : public Checker<
     check::PostCall,
     check::PreCall,
@@ -57,17 +134,24 @@
       // Helpers
       static bool isDevmKasprintf(const CallEvent &Call, CheckerContext &C);
-      static const MemRegion *getRegionFromSValOrExpr(SVal SV, const Expr *E, CheckerContext &C);
-      static const MemRegion *canonicalize(const MemRegion *R);
-      static ProgramStateRef setChecked(ProgramStateRef State, const MemRegion *R);
-      static bool isUncheckedPossiblyNull(ProgramStateRef State, const MemRegion *R);
-      static ProgramStateRef addAlias(ProgramStateRef State, const MemRegion *Dst, const MemRegion *Src);
-      void report(CheckerContext &C, const Stmt *UseSite, const MemRegion *R, StringRef Why) const;
+      static SymbolRef getSymbolFromSValOrExpr(SVal SV, const Expr *E, CheckerContext &C);
+      static ProgramStateRef setChecked(ProgramStateRef State, SymbolRef Sym);
+      static bool isUncheckedPossiblyNull(ProgramStateRef State, SymbolRef Sym);
+      static ProgramStateRef bindRegionToSymbol(ProgramStateRef State, const MemRegion *Dst, SymbolRef Sym);
+      static SymbolRef getSymbolFromRegion(ProgramStateRef State, const MemRegion *R);
+      void report(CheckerContext &C, const Stmt *UseSite, StringRef Why) const;

       // Determine if this call is known to dereference certain param indices.
       static bool callIsKnownToDeref(const CallEvent &Call,
                                      CheckerContext &C,
                                      llvm::SmallVectorImpl<unsigned> &Params);
+
+      // Specialized detection for dev_* and printk* to reduce FPs:
+      // Consider deref only if a literal format contains "%s".
+      static bool loggingFormatDereferencesString(const CallEvent &Call, CheckerContext &C, unsigned &FormatIndex);
+
+      // Light-weight FP guard
+      static bool isFalsePositiveContext(const Stmt *S);
 };

 ///////////////////////
@@ -80,71 +164,56 @@   return ExprHasName(Origin, "devm_kasprintf", C);
 }

-const MemRegion *SAGenTestChecker::getRegionFromSValOrExpr(SVal SV, const Expr *E, CheckerContext &C) {
-  const MemRegion *MR = SV.getAsRegion();
-  if (!MR && E) {
+SymbolRef SAGenTestChecker::getSymbolFromSValOrExpr(SVal SV, const Expr *E, CheckerContext &C) {
+  if (SymbolRef S = SV.getAsSymbol())
+    return S;
+
+  const MemRegion *MR = nullptr;
+  if (E)
     MR = getMemRegionFromExpr(E, C);
-  }
+  if (!MR)
+    MR = SV.getAsRegion();
+
   if (!MR)
     return nullptr;
-  return MR->getBaseRegion();
-}
-
-const MemRegion *SAGenTestChecker::canonicalize(const MemRegion *R) {
+
+  ProgramStateRef State = C.getState();
+  if (SymbolRef const *PS = State->get<Region2SymMap>(MR))
+    return *PS;
+
+  return nullptr;
+}
+
+ProgramStateRef SAGenTestChecker::setChecked(ProgramStateRef State, SymbolRef Sym) {
+  if (!Sym) return State;
+  if (const bool *Checked = State->get<PossibleNullSymMap>(Sym)) {
+    if (!*Checked)
+      State = State->set<PossibleNullSymMap>(Sym, true);
+  }
+  return State;
+}
+
+bool SAGenTestChecker::isUncheckedPossiblyNull(ProgramStateRef State, SymbolRef Sym) {
+  if (!Sym) return false;
+  if (const bool *Checked = State->get<PossibleNullSymMap>(Sym)) {
+    return *Checked == false;
+  }
+  return false;
+}
+
+ProgramStateRef SAGenTestChecker::bindRegionToSymbol(ProgramStateRef State, const MemRegion *Dst, SymbolRef Sym) {
+  if (!Dst || !Sym) return State;
+  return State->set<Region2SymMap>(Dst, Sym);
+}
+
+SymbolRef SAGenTestChecker::getSymbolFromRegion(ProgramStateRef State, const MemRegion *R) {
   if (!R) return nullptr;
-  return R->getBaseRegion();
-}
-
-ProgramStateRef SAGenTestChecker::setChecked(ProgramStateRef State, const MemRegion *R) {
-  if (!R) return State;
-  R = R->getBaseRegion();
-  if (!R) return State;
-
-  if (const bool *Checked = State->get<PossibleNullPtrMap>(R)) {
-    if (!*Checked) {
-      State = State->set<PossibleNullPtrMap>(R, true);
-    }
-  }
-  // Propagate to alias (both directions recorded in map).
-  if (const MemRegion * const *Alias = State->get<PtrAliasMap>(R)) {
-    if (const bool *AliasChecked = State->get<PossibleNullPtrMap>(*Alias)) {
-      if (!*AliasChecked)
-        State = State->set<PossibleNullPtrMap>(*Alias, true);
-    }
-  }
-  return State;
-}
-
-bool SAGenTestChecker::isUncheckedPossiblyNull(ProgramStateRef State, const MemRegion *R) {
-  if (!R) return false;
-  R = R->getBaseRegion();
-  if (!R) return false;
-
-  if (const bool *Checked = State->get<PossibleNullPtrMap>(R)) {
-    return *Checked == false;
-  }
-
-  // Check alias mapping
-  if (const MemRegion * const *Alias = State->get<PtrAliasMap>(R)) {
-    if (const bool *CheckedAlias = State->get<PossibleNullPtrMap>(*Alias)) {
-      return *CheckedAlias == false;
-    }
-  }
-  return false;
-}
-
-ProgramStateRef SAGenTestChecker::addAlias(ProgramStateRef State, const MemRegion *Dst, const MemRegion *Src) {
-  if (!Dst || !Src) return State;
-  Dst = Dst->getBaseRegion();
-  Src = Src->getBaseRegion();
-  if (!Dst || !Src) return State;
-  if (Dst == Src) return State;
-  State = State->set<PtrAliasMap>(Dst, Src);
-  State = State->set<PtrAliasMap>(Src, Dst);
-  return State;
-}
-
-void SAGenTestChecker::report(CheckerContext &C, const Stmt *UseSite, const MemRegion *R, StringRef Why) const {
+  if (SymbolRef const *PS = State->get<Region2SymMap>(R))
+    return *PS;
+  return nullptr;
+}
+
+void SAGenTestChecker::report(CheckerContext &C, const Stmt *UseSite, StringRef Why) const {
   ExplodedNode *N = C.generateNonFatalErrorNode();
   if (!N) return;

@@ -158,8 +227,46 @@   C.emitReport(std::move(Rpt));
 }

+bool SAGenTestChecker::loggingFormatDereferencesString(const CallEvent &Call,
+                                                       CheckerContext &C,
+                                                       unsigned &FormatIndex) {
+  const Expr *Origin = Call.getOriginExpr();
+  if (!Origin)
+    return false;
+
+  bool IsDev = ExprHasName(Origin, "dev_err", C) ||
+               ExprHasName(Origin, "dev_warn", C) ||
+               ExprHasName(Origin, "dev_info", C) ||
+               ExprHasName(Origin, "dev_dbg", C);
+  bool IsPrintk = ExprHasName(Origin, "printk", C) ||
+                  ExprHasName(Origin, "pr_err", C) ||
+                  ExprHasName(Origin, "pr_warn", C) ||
+                  ExprHasName(Origin, "pr_info", C) ||
+                  ExprHasName(Origin, "pr_debug", C);
+  if (!IsDev && !IsPrintk)
+    return false;
+
+  FormatIndex = IsDev ? 1u : 0u;
+  if (Call.getNumArgs() <= FormatIndex)
+    return false;
+
+  const Expr *FmtE = Call.getArgExpr(FormatIndex);
+  if (!FmtE)
+    return false;
+
+  if (const auto *SL = dyn_cast<StringLiteral>(FmtE->IgnoreImpCasts())) {
+    StringRef S = SL->getString();
+    // If format contains "%s", string arguments are dereferenced.
+    return S.contains("%s");
+  }
+
+  // Non-literal format: be conservative and RETURN FALSE to reduce FPs.
+  // Kernel logs almost always use string literals for formats.
+  return false;
+}
+
 // Heuristic: determine known-deref functions and which argument indices are dereferenced.
-// We use source-text matching (ExprHasName) to be robust to macros.
+// We use source-text matching (ExprHasName) and limited format parsing for logs.
 bool SAGenTestChecker::callIsKnownToDeref(const CallEvent &Call,
                                           CheckerContext &C,
                                           llvm::SmallVectorImpl<unsigned> &Params) {
@@ -177,27 +284,13 @@   if (ExprHasName(Origin, "strcat", C)) { Params.push_back(1); return true; }
   if (ExprHasName(Origin, "strncat", C)) { Params.push_back(1); return true; }

-  // Kernel logging helpers: dev_err/dev_warn/dev_info/dev_dbg and printk-like:
-  // We conservatively assume arguments after the format may be dereferenced,
-  // but we include the format itself too.
-  if (ExprHasName(Origin, "dev_err", C) ||
-      ExprHasName(Origin, "dev_warn", C) ||
-      ExprHasName(Origin, "dev_info", C) ||
-      ExprHasName(Origin, "dev_dbg", C) ||
-      ExprHasName(Origin, "printk", C) ||
-      ExprHasName(Origin, "pr_err", C) ||
-      ExprHasName(Origin, "pr_warn", C) ||
-      ExprHasName(Origin, "pr_info", C) ||
-      ExprHasName(Origin, "pr_debug", C)) {
+  // Kernel logging helpers: consider deref only if format literal contains "%s"
+  unsigned FmtIdx = 0;
+  if (loggingFormatDereferencesString(Call, C, FmtIdx)) {
     unsigned N = Call.getNumArgs();
     // For dev_*: index 1 is format, >=2 are varargs.
     // For printk/pr_*: first arg is format, varargs follow.
-    unsigned StartIdx = 0;
-    if (ExprHasName(Origin, "dev_err", C) ||
-        ExprHasName(Origin, "dev_warn", C) ||
-        ExprHasName(Origin, "dev_info", C) ||
-        ExprHasName(Origin, "dev_dbg", C))
-      StartIdx = 1;
+    unsigned StartIdx = FmtIdx + 1;
     for (unsigned i = StartIdx; i < N; ++i)
       Params.push_back(i);
     return !Params.empty();
@@ -212,18 +305,34 @@     }
   }

-  // A few formatting helpers
+  // snprintf-like: format at index 2; varargs can deref string pointers, but
+  // we only consider if format literal contains "%s".
   if (ExprHasName(Origin, "snprintf", C) || ExprHasName(Origin, "vsnprintf", C)) {
-    // Format at index 2 for snprintf(char*, size_t, const char*, ...)
     if (Call.getNumArgs() >= 3) {
-      Params.push_back(2);
-      // varargs are possible derefs; include them conservatively
-      for (unsigned i = 3; i < Call.getNumArgs(); ++i)
-        Params.push_back(i);
-      return true;
-    }
-  }
-
+      const Expr *FmtE = Call.getArgExpr(2);
+      if (const auto *SL = FmtE ? dyn_cast<StringLiteral>(FmtE->IgnoreImpCasts()) : nullptr) {
+        if (SL->getString().contains("%s")) {
+          Params.push_back(2);
+          for (unsigned i = 3; i < Call.getNumArgs(); ++i)
+            Params.push_back(i);
+          return true;
+        }
+      }
+    }
+  }
+
+  // Allow external knowledge table if provided by user (disabled in this build).
+  if (functionKnownToDeref(Call, Params))
+    return true;
+
+  return false;
+}
+
+// Very small FP guard: currently unused but kept for extensibility.
+bool SAGenTestChecker::isFalsePositiveContext(const Stmt *S) {
+  // We could ignore contexts that are control-only and can't deref,
+  // but we've already restricted deref reporting elsewhere.
+  (void)S;
   return false;
 }

@@ -237,17 +346,13 @@
   ProgramStateRef State = C.getState();

-  // Track the return value region as possibly NULL and unchecked.
+  // Track the return value symbol as possibly NULL and unchecked.
   SVal Ret = Call.getReturnValue();
-  const MemRegion *MR = getRegionFromSValOrExpr(Ret, Call.getOriginExpr(), C);
-  if (!MR)
-    return;
-
-  MR = canonicalize(MR);
-  if (!MR)
-    return;
-
-  State = State->set<PossibleNullPtrMap>(MR, false);
+  SymbolRef Sym = Ret.getAsSymbol();
+  if (!Sym)
+    return;
+
+  State = State->set<PossibleNullSymMap>(Sym, false);
   C.addTransition(State);
 }

@@ -264,18 +369,17 @@
     const Expr *ArgE = Call.getArgExpr(Idx);
     SVal ArgSV = Call.getArgSVal(Idx);
-    const MemRegion *MR = getRegionFromSValOrExpr(ArgSV, ArgE, C);
-    MR = canonicalize(MR);
-
-    if (!MR)
+    SymbolRef Sym = getSymbolFromSValOrExpr(ArgSV, ArgE, C);
+
+    if (!Sym)
       continue;

-    if (isUncheckedPossiblyNull(State, MR)) {
-      report(C, Call.getOriginExpr(), MR, "pointer may be NULL and is dereferenced");
-      // Optionally mark as checked to avoid duplicate reports on the same path.
-      State = setChecked(State, MR);
+    if (isUncheckedPossiblyNull(State, Sym)) {
+      report(C, Call.getOriginExpr(), "pointer may be NULL and is dereferenced");
+      // Mark as checked to avoid duplicate reports on the same path.
+      State = setChecked(State, Sym);
       C.addTransition(State);
-      // Do not return early; continue to check other args.
+      // Continue to check other args.
     }
   }
 }
@@ -296,11 +400,9 @@       const Expr *SubE = UO->getSubExpr();
       if (SubE) {
         SVal SubSV = State->getSVal(SubE, C.getLocationContext());
-        const MemRegion *MR = getRegionFromSValOrExpr(SubSV, SubE, C);
-        MR = canonicalize(MR);
-        if (MR) {
-          State = setChecked(State, MR);
-        }
+        SymbolRef Sym = getSymbolFromSValOrExpr(SubSV, SubE, C);
+        if (Sym)
+          State = setChecked(State, Sym);
       }
     }
   }
@@ -321,21 +423,18 @@
       if (PtrE) {
         SVal PSV = State->getSVal(PtrE, C.getLocationContext());
-        const MemRegion *MR = getRegionFromSValOrExpr(PSV, PtrE, C);
-        MR = canonicalize(MR);
-        if (MR) {
-          State = setChecked(State, MR);
-        }
+        SymbolRef Sym = getSymbolFromSValOrExpr(PSV, PtrE, C);
+        if (Sym)
+          State = setChecked(State, Sym);
       }
     }
   }
   // Pattern: if (ptr)
   else {
     SVal CSV = State->getSVal(CondE, C.getLocationContext());
-    const MemRegion *MR = getRegionFromSValOrExpr(CSV, CondE, C);
-    MR = canonicalize(MR);
-    if (MR) {
-      State = setChecked(State, MR);
+    SymbolRef Sym = getSymbolFromSValOrExpr(CSV, CondE, C);
+    if (Sym) {
+      State = setChecked(State, Sym);
     }
   }

@@ -343,16 +442,36 @@ }

 void SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const {
-  ProgramStateRef State = C.getState();
-
-  const MemRegion *MR = Loc.getAsRegion();
-  if (!MR) return;
-  MR = canonicalize(MR);
-  if (!MR) return;
-
-  if (isUncheckedPossiblyNull(State, MR)) {
-    report(C, S, MR, "pointer may be NULL and is dereferenced");
-    State = setChecked(State, MR);
+  // Only report on clear dereference expressions to avoid FPs from generic loads.
+  if (!IsLoad || !S)
+    return;
+
+  ProgramStateRef State = C.getState();
+  const Expr *E = dyn_cast<Expr>(S);
+  if (!E)
+    return;
+  E = E->IgnoreParenCasts();
+
+  const Expr *PtrE = nullptr;
+
+  if (const auto *UO = dyn_cast<UnaryOperator>(E)) {
+    if (UO->getOpcode() == UO_Deref)
+      PtrE = UO->getSubExpr();
+  } else if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(E)) {
+    PtrE = ASE->getBase();
+  }
+
+  if (!PtrE)
+    return;
+
+  SVal PSV = State->getSVal(PtrE, C.getLocationContext());
+  SymbolRef Sym = getSymbolFromSValOrExpr(PSV, PtrE, C);
+  if (!Sym)
+    return;
+
+  if (isUncheckedPossiblyNull(State, Sym)) {
+    report(C, S, "pointer may be NULL and is dereferenced");
+    State = setChecked(State, Sym);
     C.addTransition(State);
   }
 }
@@ -362,21 +481,27 @@   ProgramStateRef State = C.getState();

   const MemRegion *LHS = Loc.getAsRegion();
-  if (!LHS) {
-    C.addTransition(State);
-    return;
-  }
-  LHS = canonicalize(LHS);
-
-  const MemRegion *RHS = Val.getAsRegion();
-  if (!RHS && StoreE) {
-    if (const Expr *E = dyn_cast<Expr>(StoreE))
-      RHS = getMemRegionFromExpr(E, C);
-  }
-  RHS = canonicalize(RHS);
-
-  if (LHS && RHS) {
-    State = addAlias(State, LHS, RHS);
+  // Try to learn the symbol on RHS.
+  SymbolRef RHSym = Val.getAsSymbol();
+
+  if (!RHSym && StoreE) {
+    // If RHS is not a symbol directly, but it's a variable/field holding a tracked symbol, propagate it.
+    if (const Expr *E = dyn_cast<Expr>(StoreE)) {
+      if (const auto *BO = dyn_cast<BinaryOperator>(E->IgnoreParenCasts())) {
+        if (BO->isAssignmentOp()) {
+          const Expr *RHSExpr = BO->getRHS();
+          const MemRegion *RHSRegion = getMemRegionFromExpr(RHSExpr, C);
+          if (RHSRegion) {
+            if (SymbolRef S = getSymbolFromRegion(State, RHSRegion))
+              RHSym = S;
+          }
+        }
+      }
+    }
+  }
+
+  if (LHS && RHSym) {
+    State = bindRegionToSymbol(State, LHS, RHSym);
   }

   C.addTransition(State);
