--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -159,8 +159,8 @@       // Handle IS_ERR / IS_ERR_OR_NULL wrappers to mark checks.
       static bool isIS_ERR_LikeCall(const Expr *E, CheckerContext &C, const Expr *&PtrArg);

-      // Light-weight FP guard
-      static bool isFalsePositiveContext(const Stmt *S);
+      // Helper: compute pointer depth (number of pointer-indirections)
+      static unsigned pointerDepth(QualType T);
 };

 ///////////////////////
@@ -168,9 +168,10 @@ ///////////////////////

 bool SAGenTestChecker::isDevmKasprintf(const CallEvent &Call, CheckerContext &C) {
-  const Expr *Origin = Call.getOriginExpr();
-  if (!Origin) return false;
-  return ExprHasName(Origin, "devm_kasprintf", C);
+  (void)C;
+  if (const IdentifierInfo *ID = Call.getCalleeIdentifier())
+    return ID->getName() == "devm_kasprintf";
+  return false;
 }

 SymbolRef SAGenTestChecker::getSymbolFromSValOrExpr(SVal SV, const Expr *E, CheckerContext &C) {
@@ -249,10 +250,8 @@         ++i;
         continue;
       }
-      // Very lightweight: specifically look for "%s"
       if (S[i + 1] == 's')
         ++Cnt;
-      // skip next char anyway
       ++i;
     }
   }
@@ -388,8 +387,7 @@   // Strip parens, implicit casts, cleanups.
   const Expr *Cur = E->IgnoreParenImpCasts();

-  // Strip likely/unlikely/__builtin_expect wrappers: likely/unlikely are macros,
-  // often result in a call expression with a single argument.
+  // Strip likely/unlikely/__builtin_expect wrappers.
   while (true) {
     Cur = Cur->IgnoreParenImpCasts();
     const auto *CE = dyn_cast<CallExpr>(Cur);
@@ -405,16 +403,19 @@         continue;
       }
     }
-    // Not a known wrapper
     break;
   }
   return Cur;
 }

-// Very small FP guard: currently unused but kept for extensibility.
-bool SAGenTestChecker::isFalsePositiveContext(const Stmt *S) {
-  (void)S;
-  return false;
+unsigned SAGenTestChecker::pointerDepth(QualType T) {
+  unsigned Depth = 0;
+  QualType Cur = T;
+  while (!Cur.isNull() && Cur->isPointerType()) {
+    ++Depth;
+    Cur = Cur->getPointeeType();
+  }
+  return Depth;
 }

 //////////////////////
@@ -560,19 +561,32 @@   E = E->IgnoreParenCasts();

   const Expr *PtrE = nullptr;
+  bool IsArraySubscript = false;

   if (const auto *UO = dyn_cast<UnaryOperator>(E)) {
     if (UO->getOpcode() == UO_Deref)
-      PtrE = UO->getSubExpr();
+      PtrE = UO->getSubExpr()->IgnoreParenCasts();
   } else if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(E)) {
-    PtrE = ASE->getBase();
+    PtrE = ASE->getBase()->IgnoreParenCasts();
+    IsArraySubscript = true;
   }

   if (!PtrE)
     return;

+  // Only consider dereference of a single-level pointer. This avoids treating
+  // loads through a double-pointer (e.g., "*out") as dereferences of the tracked
+  // pointer value stored in that memory.
+  if (pointerDepth(PtrE->getType()) != 1)
+    return;
+
+  // Get the symbol of the pointer value we are dereferencing: either directly
+  // from the SVal, or from a tracked region binding of the base expression.
   SVal PSV = State->getSVal(PtrE, C.getLocationContext());
-  SymbolRef Sym = getSymbolFromSValOrExpr(PSV, PtrE, C);
+  SymbolRef Sym = PSV.getAsSymbol();
+  if (!Sym)
+    Sym = getSymbolFromSValOrExpr(PSV, PtrE, C);
+
   if (!Sym)
     return;
