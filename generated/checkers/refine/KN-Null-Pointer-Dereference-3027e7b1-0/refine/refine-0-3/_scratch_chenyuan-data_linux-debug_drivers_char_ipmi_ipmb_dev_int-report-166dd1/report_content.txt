### Report Summary

File:| /scratch/chenyuan-data/linux-debug/drivers/char/ipmi/ipmb_dev_int.c
---|---
Warning:| line 324, column 25
Missing NULL-check after devm_kasprintf(); pointer may be NULL and is
dereferenced

### Annotated Source Code


252   |  struct ipmb_dev *ipmb_dev = i2c_get_clientdata(client);
253   | 	u8 *buf = (u8 *)&ipmb_dev->request;
254   |  unsigned long flags;
255   |
256   |  spin_lock_irqsave(&ipmb_dev->lock, flags);
257   |  switch (event) {
258   |  case I2C_SLAVE_WRITE_REQUESTED:
259   |  memset(&ipmb_dev->request, 0, sizeof(ipmb_dev->request));
260   | 		ipmb_dev->msg_idx = 0;
261   |
262   |  /*
263   |  * At index 0, ipmb_msg stores the length of msg,
264   |  * skip it for now.
265   |  * The len will be populated once the whole
266   |  * buf is populated.
267   |  *
268   |  * The I2C bus driver's responsibility is to pass the
269   |  * data bytes to the backend driver; it does not
270   |  * forward the i2c slave address.
271   |  * Since the first byte in the IPMB message is the
272   |  * address of the responder, it is the responsibility
273   |  * of the IPMB driver to format the message properly.
274   |  * So this driver prepends the address of the responder
275   |  * to the received i2c data before the request message
276   |  * is handled in userland.
277   |  */
278   | 		buf[++ipmb_dev->msg_idx] = GET_8BIT_ADDR(client->addr);
279   |  break;
280   |
281   |  case I2C_SLAVE_WRITE_RECEIVED:
282   |  if (ipmb_dev->msg_idx >= sizeof(struct ipmb_msg) - 1)
283   |  break;
284   |
285   | 		buf[++ipmb_dev->msg_idx] = *val;
286   |  break;
287   |
288   |  case I2C_SLAVE_STOP:
289   | 		ipmb_dev->request.len = ipmb_dev->msg_idx;
290   |  if (is_ipmb_msg(ipmb_dev, GET_8BIT_ADDR(client->addr)))
291   | 			ipmb_handle_request(ipmb_dev);
292   |  break;
293   |
294   |  default:
295   |  break;
296   | 	}
297   | 	spin_unlock_irqrestore(&ipmb_dev->lock, flags);
298   |
299   |  return 0;
300   | }
301   |
302   | static int ipmb_probe(struct i2c_client *client)
303   | {
304   |  struct ipmb_dev *ipmb_dev;
305   |  int ret;
306   |
307   | 	ipmb_dev = devm_kzalloc(&client->dev, sizeof(*ipmb_dev),
308   |  GFP_KERNEL);
309   |  if (!ipmb_dev)
    1Assuming 'ipmb_dev' is non-null→
    2←Taking false branch→
310   |  return -ENOMEM;
311   |
312   |  spin_lock_init(&ipmb_dev->lock);
    3←Loop condition is false.  Exiting loop→
313   |  init_waitqueue_head(&ipmb_dev->wait_queue);
    4←Loop condition is false.  Exiting loop→
314   |  atomic_set(&ipmb_dev->request_queue_len, 0);
315   |  INIT_LIST_HEAD(&ipmb_dev->request_queue);
316   |
317   |  mutex_init(&ipmb_dev->file_mutex);
    5←Loop condition is false.  Exiting loop→
318   |
319   |  ipmb_dev->miscdev.minor = MISC_DYNAMIC_MINOR;
320   |
321   | 	ipmb_dev->miscdev.name = devm_kasprintf(&client->dev, GFP_KERNEL,
322   |  "%s%d", "ipmb-",
323   | 						client->adapter->nr);
324   |  ipmb_dev->miscdev.fops = &ipmb_fops;
    6←Missing NULL-check after devm_kasprintf(); pointer may be NULL and is dereferenced
325   | 	ipmb_dev->miscdev.parent = &client->dev;
326   | 	ret = misc_register(&ipmb_dev->miscdev);
327   |  if (ret)
328   |  return ret;
329   |
330   | 	ipmb_dev->is_i2c_protocol
331   | 		= device_property_read_bool(&client->dev, "i2c-protocol");
332   |
333   | 	ipmb_dev->client = client;
334   | 	i2c_set_clientdata(client, ipmb_dev);
335   | 	ret = i2c_slave_register(client, ipmb_slave_cb);
336   |  if (ret) {
337   | 		misc_deregister(&ipmb_dev->miscdev);
338   |  return ret;
339   | 	}
340   |
341   |  return 0;
342   | }
343   |
344   | static void ipmb_remove(struct i2c_client *client)
345   | {
346   |  struct ipmb_dev *ipmb_dev = i2c_get_clientdata(client);
347   |
348   | 	i2c_slave_unregister(client);
349   | 	misc_deregister(&ipmb_dev->miscdev);
350   | }
351   |
352   | static const struct i2c_device_id ipmb_id[] = {
353   | 	{ "ipmb-dev", 0 },
354   | 	{},
