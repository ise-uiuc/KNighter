--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -55,10 +55,16 @@                                                 const BinaryOperator *&OutMul,
                                                 CheckerContext &C);

-  // Optional post-filter for special-casing known false positives (extensible).
+  // Extract a variable/field identifier name from an expression if possible.
+  static std::string extractIdentifierLikeName(const Expr *E);
+
+  // Heuristic: detect known-timeout/jiffies contexts to avoid FPs.
   static bool isFalsePositiveContext(const Expr *Root,
                                      const BinaryOperator *MulBO,
                                      CheckerContext &C);
+
+  static bool nameContains(StringRef TextLower,
+                           std::initializer_list<StringRef> Needles);

   void emitReport(const BinaryOperator *MulBO, QualType LHSType,
                   CheckerContext &C) const;
@@ -187,15 +193,68 @@   return false;
 }

-// Secondary guard: currently we filter via value-path traversal, but we keep
-// this extensibility point if later special cases need to be whitelisted.
+// Extract identifier-like name from an expression (variable or field), else empty.
+std::string SAGenTestChecker::extractIdentifierLikeName(const Expr *E) {
+  if (!E)
+    return {};
+  E = E->IgnoreParenImpCasts();
+
+  if (const auto *ME = dyn_cast<MemberExpr>(E)) {
+    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl()))
+      return FD->getNameAsString();
+  }
+  if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {
+    if (const auto *ND = dyn_cast<NamedDecl>(DRE->getDecl()))
+      return ND->getNameAsString();
+  }
+  return {};
+}
+
+bool SAGenTestChecker::nameContains(StringRef TextLower,
+                                    std::initializer_list<StringRef> Needles) {
+  for (StringRef N : Needles) {
+    if (TextLower.contains(N))
+      return true;
+  }
+  return false;
+}
+
+// Secondary guard: filter known jiffies/timeout contexts to avoid false positives.
 bool SAGenTestChecker::isFalsePositiveContext(const Expr *Root,
                                               const BinaryOperator *MulBO,
                                               CheckerContext &C) {
-  (void)Root;
   (void)MulBO;
-  (void)C;
-  // No extra filters for now beyond value-path traversal.
+
+  // 1) If the RHS/root expression text contains "jiffies", we treat this as
+  //    time arithmetic; suppress the report.
+  if (ExprHasName(Root, "jiffies", C))
+    return true;
+
+  // 2) If the parent assignment/compound-assignment LHS name implies timeout-like field,
+  //    suppress as well.
+  //    Common patterns: expires, expiry, timeout, deadline, jiffies.
+  const CompoundAssignOperator *CAO =
+      findSpecificTypeInParents<CompoundAssignOperator>(Root, C);
+  const BinaryOperator *AssignBO =
+      findSpecificTypeInParents<BinaryOperator>(Root, C);
+
+  const Expr *LHSExpr = nullptr;
+  if (CAO) {
+    LHSExpr = CAO->getLHS();
+  } else if (AssignBO && AssignBO->getOpcode() == BO_Assign) {
+    LHSExpr = AssignBO->getLHS();
+  }
+
+  if (LHSExpr) {
+    std::string LHSName = extractIdentifierLikeName(LHSExpr);
+    if (!LHSName.empty()) {
+      std::string Lower = LHSName;
+      std::transform(Lower.begin(), Lower.end(), Lower.begin(), ::tolower);
+      if (nameContains(Lower, {"expire", "expiry", "timeout", "deadline", "jiffies"}))
+        return true;
+    }
+  }
+
   return false;
 }
