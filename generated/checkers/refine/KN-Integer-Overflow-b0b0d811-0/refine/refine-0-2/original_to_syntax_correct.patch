--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -22,7 +22,20 @@ using namespace ento;
 using namespace taint;

-// No program state traits required for this checker.
+// Utility functions provided in the prompt.
+template <typename T>
+const T* findSpecificTypeInParents(const Stmt *S, CheckerContext &C);
+
+template <typename T>
+const T* findSpecificTypeInChildren(const Stmt *S);
+
+bool EvaluateExprToInt(llvm::APSInt &EvalRes, const Expr *expr, CheckerContext &C);
+const llvm::APSInt *inferSymbolMaxVal(SymbolRef Sym, CheckerContext &C);
+bool getArraySizeFromExpr(llvm::APInt &ArraySize, const Expr *E);
+bool getStringSize(llvm::APInt &StringSize, const Expr *E);
+const MemRegion* getMemRegionFromExpr(const Expr* E, CheckerContext &C);
+bool functionKnownToDeref(const CallEvent &Call, llvm::SmallVectorImpl<unsigned> &DerefParams);
+bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C);

 namespace {

@@ -58,13 +71,44 @@   // Extract a variable/field identifier name from an expression if possible.
   static std::string extractIdentifierLikeName(const Expr *E);

-  // Heuristic: detect known-timeout/jiffies contexts to avoid FPs.
-  static bool isFalsePositiveContext(const Expr *Root,
-                                     const BinaryOperator *MulBO,
-                                     CheckerContext &C);
-
   static bool nameContains(StringRef TextLower,
                            std::initializer_list<StringRef> Needles);
+
+  static std::string toLowerCopy(StringRef S);
+
+  // Additional helper: obtain current function name if available.
+  static std::string getCurrentFunctionName(CheckerContext &C);
+
+  // Additional helper: check if a type is (typedef) named as the given Name
+  // along the typedef chain.
+  static bool isTypedefNamedInChain(QualType QT, StringRef Name);
+
+  // Risky LHS names we never suppress for.
+  static bool isRiskyWideAccumulatorLHS(const Expr *LHS);
+
+  // Heuristic: index-like vs stride-like names for ALSA PCM offset computations.
+  static bool isIndexLikeName(StringRef LowerName);
+  static bool isStrideLikeName(StringRef LowerName);
+
+  // Extract something name-like from an operand to examine.
+  static std::string extractOperandName(const Expr *Op);
+
+  // Known benign contexts (time arithmetic).
+  static bool isFalsePositiveContext_Time(const Expr *Root,
+                                          const BinaryOperator *MulBO,
+                                          CheckerContext &C);
+
+  // Heuristic FP filter for index * stride patterns used in PCM pointer getters.
+  static bool isFalsePositiveContext_IndexTimesStride(const Expr *Root,
+                                                      const BinaryOperator *MulBO,
+                                                      const Expr *LHS,
+                                                      CheckerContext &C);
+
+  // Unified FP predicate invoking specific filters.
+  static bool isFalsePositive(const Expr *Root,
+                              const BinaryOperator *MulBO,
+                              const Expr *LHS,
+                              CheckerContext &C);

   void emitReport(const BinaryOperator *MulBO, QualType LHSType,
                   CheckerContext &C) const;
@@ -219,10 +263,85 @@   return false;
 }

+std::string SAGenTestChecker::toLowerCopy(StringRef S) {
+  std::string Out = S.str();
+  std::transform(Out.begin(), Out.end(), Out.begin(), ::tolower);
+  return Out;
+}
+
+std::string SAGenTestChecker::getCurrentFunctionName(CheckerContext &C) {
+  const LocationContext *LC = C.getLocationContext();
+  if (!LC)
+    return {};
+  const Decl *D = LC->getDecl();
+  if (!D)
+    return {};
+  if (const auto *FD = dyn_cast<FunctionDecl>(D))
+    return FD->getNameAsString();
+  return {};
+}
+
+bool SAGenTestChecker::isTypedefNamedInChain(QualType QT, StringRef Name) {
+  // Walk through typedef sugar chain to see if any typedef matches Name.
+  QualType Cur = QT;
+  // Limit the iteration to avoid pathological cases.
+  for (int i = 0; i < 8; ++i) {
+    if (const auto *TDT = dyn_cast<TypedefType>(Cur.getTypePtrOrNull())) {
+      if (TDT->getDecl() && TDT->getDecl()->getName() == Name)
+        return true;
+      Cur = TDT->getDecl()->getUnderlyingType();
+      continue;
+    }
+    break;
+  }
+  return false;
+}
+
+bool SAGenTestChecker::isRiskyWideAccumulatorLHS(const Expr *LHS) {
+  if (!LHS)
+    return false;
+  std::string N = extractIdentifierLikeName(LHS);
+  std::string NL = toLowerCopy(N);
+  // Fields/variables like size, addr, dma_addr, iova, len, length, bytes, count are risky accumulators.
+  if (nameContains(NL, {"size", "addr", "dma_addr", "iova", "offset", "ofs",
+                        "length", "len", "bytes", "nbytes", "count", "total"}))
+    return true;
+
+  // Also treat dma_addr_t explicitly as risky by typedef name on LHS type.
+  QualType LT = LHS->getType();
+  if (isTypedefNamedInChain(LT, "dma_addr_t"))
+    return true;
+
+  return false;
+}
+
+bool SAGenTestChecker::isIndexLikeName(StringRef LowerName) {
+  return nameContains(LowerName, {"idx", "index", "ind", "buffer", "buf",
+                                  "currentbuffer", "ring", "page"});
+}
+
+bool SAGenTestChecker::isStrideLikeName(StringRef LowerName) {
+  return nameContains(LowerName, {"frame", "frames", "stride", "period",
+                                  "chunk", "pitch", "bpp", "cpp"});
+}
+
+std::string SAGenTestChecker::extractOperandName(const Expr *Op) {
+  if (!Op)
+    return {};
+  // Try to get an identifier/field name.
+  std::string N = extractIdentifierLikeName(Op);
+  if (!N.empty())
+    return N;
+
+  // Fall back to a short source snippet when no identifier is present.
+  // Only use it for name probing via substrings.
+  return {};
+}
+
 // Secondary guard: filter known jiffies/timeout contexts to avoid false positives.
-bool SAGenTestChecker::isFalsePositiveContext(const Expr *Root,
-                                              const BinaryOperator *MulBO,
-                                              CheckerContext &C) {
+bool SAGenTestChecker::isFalsePositiveContext_Time(const Expr *Root,
+                                                   const BinaryOperator *MulBO,
+                                                   CheckerContext &C) {
   (void)MulBO;

   // 1) If the RHS/root expression text contains "jiffies", we treat this as
@@ -248,12 +367,89 @@   if (LHSExpr) {
     std::string LHSName = extractIdentifierLikeName(LHSExpr);
     if (!LHSName.empty()) {
-      std::string Lower = LHSName;
-      std::transform(Lower.begin(), Lower.end(), Lower.begin(), ::tolower);
+      std::string Lower = toLowerCopy(LHSName);
       if (nameContains(Lower, {"expire", "expiry", "timeout", "deadline", "jiffies"}))
         return true;
     }
   }
+
+  return false;
+}
+
+// Heuristic FP filter for ALSA-like index*stride multiplication used inside
+// PCM pointer getters that return a frame position.
+// Conditions (any strong subset is enough):
+//  - Function name contains "pointer" AND
+//  - LHS type is snd_pcm_uframes_t OR LHS name is "pos"
+//  - RHS mul has one index-like operand and one stride-like operand
+// Do NOT suppress if the LHS looks like a risky wide accumulator (size/addr/len/etc.).
+bool SAGenTestChecker::isFalsePositiveContext_IndexTimesStride(const Expr *Root,
+                                                               const BinaryOperator *MulBO,
+                                                               const Expr *LHS,
+                                                               CheckerContext &C) {
+  if (!MulBO)
+    return false;
+
+  if (!LHS)
+    return false;
+
+  // Never suppress risky accumulators.
+  if (isRiskyWideAccumulatorLHS(LHS))
+    return false;
+
+  // Check function name context.
+  std::string FnName = getCurrentFunctionName(C);
+  std::string FnLower = toLowerCopy(FnName);
+  bool InPointerGetter = !FnLower.empty() && FnLower.find("pointer") != std::string::npos;
+
+  // LHS type/name hints (common in ALSA).
+  QualType LT = LHS->getType();
+  bool IsUFrames = isTypedefNamedInChain(LT, "snd_pcm_uframes_t");
+  std::string LHSName = extractIdentifierLikeName(LHS);
+  std::string LHSNameLower = toLowerCopy(LHSName);
+  bool IsPosLHS = nameContains(LHSNameLower, {"pos", "position"});
+
+  // Require at least some function/LHS context.
+  if (!(InPointerGetter || IsUFrames || IsPosLHS))
+    return false;
+
+  // Names of operands.
+  const Expr *L = MulBO->getLHS();
+  const Expr *R = MulBO->getRHS();
+  std::string LName = extractOperandName(L);
+  std::string RName = extractOperandName(R);
+  std::string LLower = toLowerCopy(LName);
+  std::string RLower = toLowerCopy(RName);
+
+  bool IndexStridePattern =
+      (isIndexLikeName(LLower) && isStrideLikeName(RLower)) ||
+      (isIndexLikeName(RLower) && isStrideLikeName(LLower));
+
+  if (!IndexStridePattern) {
+    // As a fallback, scan the expression text for "buffer" and "frame".
+    bool HasBuffer = ExprHasName(Root, "buffer", C);
+    bool HasFrame = ExprHasName(Root, "frame", C) || ExprHasName(Root, "frames", C);
+    IndexStridePattern = HasBuffer && HasFrame;
+  }
+
+  if (!IndexStridePattern)
+    return false;
+
+  // If we reached here, it's very likely a benign frames position computation.
+  return true;
+}
+
+bool SAGenTestChecker::isFalsePositive(const Expr *Root,
+                                       const BinaryOperator *MulBO,
+                                       const Expr *LHS,
+                                       CheckerContext &C) {
+  // Time arithmetic/jiffies is benign.
+  if (isFalsePositiveContext_Time(Root, MulBO, C))
+    return true;
+
+  // ALSA PCM pointer index*stride pattern.
+  if (isFalsePositiveContext_IndexTimesStride(Root, MulBO, LHS, C))
+    return true;

   return false;
 }
@@ -296,7 +492,7 @@       const Expr *RHS = CAO->getRHS();
       if (findFirstSuspiciousMulOnValuePath(RHS, getTypeBitWidth(LT, C), MulBO, C)) {
         if (MulBO && !isConstantFolded(MulBO, C) &&
-            !isFalsePositiveContext(RHS, MulBO, C)) {
+            !isFalsePositive(RHS, MulBO, LHS, C)) {
           emitReport(MulBO, LT, C);
         }
       }
@@ -320,7 +516,7 @@     const BinaryOperator *MulBO = nullptr;
     if (findFirstSuspiciousMulOnValuePath(RHS, getTypeBitWidth(LT, C), MulBO, C)) {
       if (MulBO && !isConstantFolded(MulBO, C) &&
-          !isFalsePositiveContext(RHS, MulBO, C)) {
+          !isFalsePositive(RHS, MulBO, LHS, C)) {
         emitReport(MulBO, LT, C);
       }
     }
@@ -346,8 +542,26 @@     const Expr *Init = VD->getInit();
     const BinaryOperator *MulBO = nullptr;
     if (findFirstSuspiciousMulOnValuePath(Init, getTypeBitWidth(T, C), MulBO, C)) {
-      if (MulBO && !isConstantFolded(MulBO, C) &&
-          !isFalsePositiveContext(Init, MulBO, C)) {
+      // Build a fake LHS Expr interface via a DeclRefExpr-like context is not necessary,
+      // but we can still pass nullptr or special-case the name via VD.
+      // Construct a minimal LHS proxy: reuse VD->getInit() parent search for assignment name.
+      // For name filtering we can use VD directly.
+      // Here, create a small shim Expr pointer: we will not rely on it; pass nullptr and
+      // rely on time/jiffies-only filter.
+      const Expr *LHSExpr = nullptr;
+      // However, we still want the risk-name filter; emulate via a small check:
+      // If variable name is risky, we don't suppress benign contexts.
+      bool RiskyName = false;
+      {
+        std::string VN = VD->getNameAsString();
+        std::string VNL = toLowerCopy(VN);
+        if (nameContains(VNL, {"size", "addr", "dma_addr", "iova", "offset", "ofs",
+                               "length", "len", "bytes", "nbytes", "count", "total"}))
+          RiskyName = true;
+      }
+
+      bool Suppress = !RiskyName && isFalsePositive(Init, MulBO, LHSExpr, C);
+      if (MulBO && !isConstantFolded(MulBO, C) && !Suppress) {
         emitReport(MulBO, T, C);
       }
     }
