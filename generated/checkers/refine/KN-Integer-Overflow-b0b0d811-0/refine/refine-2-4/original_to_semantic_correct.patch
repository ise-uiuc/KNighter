--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -96,7 +96,7 @@   // Address/size-like LHS filter for intended bug surface.
   static bool isAddressOrSizeLikeLHS(const Expr *LHS);

-  // IRQ-like and jiffies contexts suppression.
+  // IRQ-like context suppression.
   static bool isIrqLikeContext(const Expr *Root, const Expr *LHS, CheckerContext &C);

   // Kernel block/folio I/O math suppression helpers
@@ -139,6 +139,11 @@   static bool isBenignNdwDiv2TimesIncrAddrPattern(const BinaryOperator *MulBO,
                                                   const Expr *LHSExpr,
                                                   CheckerContext &C);
+
+  // New: Memory unit scaling suppression (e.g., size = gb * 1024).
+  static bool isMemoryUnitScaleConversion(const BinaryOperator *MulBO,
+                                          const Expr *LHSExpr,
+                                          CheckerContext &C);

   // Aggregated FP gate.
   static bool isFalsePositive(const Expr *Root,
@@ -973,6 +978,65 @@   return false;
 }

+// Identify var * constant unit scaling for memory units, e.g.:
+//   size = gb * 1024;   // GB -> MB
+// Suppress only when:
+// - one side is a small constant typical for unit conversion (1000, 1024, 1e6, 2^20, 1e9, 2^30)
+// - the other side name suggests a larger memory unit (gb/gib/gig)
+// - LHS name is size/capacity/bytes-like (address-size sinks)
+bool SAGenTestChecker::isMemoryUnitScaleConversion(const BinaryOperator *MulBO,
+                                                   const Expr *LHSExpr,
+                                                   CheckerContext &C) {
+  if (!MulBO || MulBO->getOpcode() != BO_Mul || !LHSExpr)
+    return false;
+
+  auto ConstValOf = [&](const Expr *E, uint64_t &Out) -> bool {
+    llvm::APSInt APS;
+    if (!EvaluateExprToInt(APS, E->IgnoreParenImpCasts(), C))
+      return false;
+    // Only accept non-negative smallish constants.
+    if (APS.isSigned() && APS.isNegative())
+      return false;
+    Out = (uint64_t)APS.getExtValue();
+    return true;
+  };
+
+  uint64_t CVal = 0;
+  const Expr *Other = nullptr;
+
+  if (ConstValOf(MulBO->getLHS(), CVal)) {
+    Other = MulBO->getRHS();
+  } else if (ConstValOf(MulBO->getRHS(), CVal)) {
+    Other = MulBO->getLHS();
+  } else {
+    return false;
+  }
+
+  // Allowed constants for common memory unit scaling.
+  switch (CVal) {
+    case 1000ULL:         // decimal KB/MB/GB scaling
+    case 1024ULL:         // binary KiB/MiB/GiB scaling
+    case 1000000ULL:      // decimal MB scaling
+    case 1048576ULL:      // 1024*1024
+    case 1000000000ULL:   // decimal GB scaling
+    case 1073741824ULL:   // 1024*1024*1024
+      break;
+    default:
+      return false;
+  }
+
+  // Check names: RHS non-const side mentions GB/GiB/Gig, and LHS is size-like.
+  bool OtherHasGB = exprNameContains(Other, {"gb", "gib", "gig"}, C);
+  if (!OtherHasGB)
+    return false;
+
+  bool LHSIsSizeLike = exprNameContains(LHSExpr, {"size", "capacity", "bytes", "nbytes"}, C);
+  if (!LHSIsSizeLike)
+    return false;
+
+  return true;
+}
+
 // Aggregated FP logic.
 bool SAGenTestChecker::isFalsePositive(const Expr *Root,
                                        const BinaryOperator *MulBO,
@@ -1001,6 +1065,10 @@
   // Targeted suppression: Radeon DMA PTE benign pattern addr += (ndw/2) * incr;
   if (isBenignNdwDiv2TimesIncrAddrPattern(MulBO, LHSExpr, C))
+    return true;
+
+  // Targeted suppression: Memory unit scaling like size = gb * 1024.
+  if (isMemoryUnitScaleConversion(MulBO, LHSExpr, C))
     return true;

   return false;
