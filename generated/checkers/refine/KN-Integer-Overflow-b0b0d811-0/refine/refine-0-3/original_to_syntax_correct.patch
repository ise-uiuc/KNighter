--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -17,6 +17,7 @@ #include "clang/AST/Expr.h"
 #include "clang/AST/Stmt.h"
 #include "clang/AST/Type.h"
+#include <algorithm>

 using namespace clang;
 using namespace ento;
@@ -62,6 +63,19 @@   static bool isFalsePositiveContext(const Expr *Root,
                                      const BinaryOperator *MulBO,
                                      CheckerContext &C);
+
+  // FP suppressors for cases where '*' is not contributing directly to the value
+  // assigned/added to the wide type.
+  static bool isMulUnderCallArg(const BinaryOperator *MulBO,
+                                const Expr *Root,
+                                CheckerContext &C);
+  static bool isMulUnderArrayIndex(const BinaryOperator *MulBO,
+                                   CheckerContext &C);
+
+  // Aggregated FP gate.
+  static bool isFalsePositive(const Expr *Root,
+                              const BinaryOperator *MulBO,
+                              CheckerContext &C);

   static bool nameContains(StringRef TextLower,
                            std::initializer_list<StringRef> Needles);
@@ -225,7 +239,7 @@                                               CheckerContext &C) {
   (void)MulBO;

-  // 1) If the RHS/root expression text contains "jiffies", we treat this as
+  // 1) If the RHS/root expression text contains "jiffies", treat this as
   //    time arithmetic; suppress the report.
   if (ExprHasName(Root, "jiffies", C))
     return true;
@@ -254,6 +268,44 @@         return true;
     }
   }
+
+  return false;
+}
+
+// Return true if the '*' is nested under a CallExpr (i.e., used as a call argument)
+// relative to the current assignment/addition root.
+bool SAGenTestChecker::isMulUnderCallArg(const BinaryOperator *MulBO,
+                                         const Expr *Root,
+                                         CheckerContext &C) {
+  (void)Root; // Root can be used for stricter checks if needed.
+  const CallExpr *CE = findSpecificTypeInParents<CallExpr>(MulBO, C);
+  return CE != nullptr;
+}
+
+// Return true if '*' is used solely as part of an ArraySubscriptExpr (index).
+bool SAGenTestChecker::isMulUnderArrayIndex(const BinaryOperator *MulBO,
+                                            CheckerContext &C) {
+  const ArraySubscriptExpr *ASE = findSpecificTypeInParents<ArraySubscriptExpr>(MulBO, C);
+  return ASE != nullptr;
+}
+
+// Aggregated FP logic.
+bool SAGenTestChecker::isFalsePositive(const Expr *Root,
+                                       const BinaryOperator *MulBO,
+                                       CheckerContext &C) {
+  if (!MulBO)
+    return true;
+
+  // Suppress when:
+  // - The context is time/jiffies-like.
+  // - The multiplication is under a CallExpr (argument), e.g., MSR index macros.
+  // - The multiplication is under an ArraySubscriptExpr (index computation).
+  if (isFalsePositiveContext(Root, MulBO, C))
+    return true;
+  if (isMulUnderCallArg(MulBO, Root, C))
+    return true;
+  if (isMulUnderArrayIndex(MulBO, C))
+    return true;

   return false;
 }
@@ -296,7 +348,7 @@       const Expr *RHS = CAO->getRHS();
       if (findFirstSuspiciousMulOnValuePath(RHS, getTypeBitWidth(LT, C), MulBO, C)) {
         if (MulBO && !isConstantFolded(MulBO, C) &&
-            !isFalsePositiveContext(RHS, MulBO, C)) {
+            !isFalsePositive(RHS, MulBO, C)) {
           emitReport(MulBO, LT, C);
         }
       }
@@ -320,7 +372,7 @@     const BinaryOperator *MulBO = nullptr;
     if (findFirstSuspiciousMulOnValuePath(RHS, getTypeBitWidth(LT, C), MulBO, C)) {
       if (MulBO && !isConstantFolded(MulBO, C) &&
-          !isFalsePositiveContext(RHS, MulBO, C)) {
+          !isFalsePositive(RHS, MulBO, C)) {
         emitReport(MulBO, LT, C);
       }
     }
@@ -347,7 +399,7 @@     const BinaryOperator *MulBO = nullptr;
     if (findFirstSuspiciousMulOnValuePath(Init, getTypeBitWidth(T, C), MulBO, C)) {
       if (MulBO && !isConstantFolded(MulBO, C) &&
-          !isFalsePositiveContext(Init, MulBO, C)) {
+          !isFalsePositive(Init, MulBO, C)) {
         emitReport(MulBO, T, C);
       }
     }
