--- attempt_2_original.cpp+++ attempt_2.cpp@@ -17,13 +17,15 @@ #include "clang/AST/Expr.h"
 #include "clang/AST/Stmt.h"
 #include "clang/AST/Type.h"
+#include "llvm/ADT/SmallString.h"
 #include <algorithm>
+#include <memory>

 using namespace clang;
 using namespace ento;
 using namespace taint;

-// Utility functions provided in the prompt.
+// Utility functions provided externally.
 template <typename T>
 const T* findSpecificTypeInParents(const Stmt *S, CheckerContext &C);
 template <typename T>
@@ -38,7 +40,7 @@   llvm::SmallVector<unsigned, 4> Params;
 };
 bool functionKnownToDeref(const CallEvent &Call,
-                                 llvm::SmallVectorImpl<unsigned> &DerefParams);
+                          llvm::SmallVectorImpl<unsigned> &DerefParams);
 bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C);

 namespace {
@@ -66,6 +68,15 @@   static bool isWideTargetType(QualType QT, CheckerContext &C);
   static bool isConstantFolded(const Expr *E, CheckerContext &C);

+  // Range reasoning helpers to suppress FPs when product fits in the mul's type.
+  static void getTypeRange128(QualType QT, CheckerContext &C,
+                              llvm::APInt &Min, llvm::APInt &Max);
+  static bool getExprRange128(const Expr *E, CheckerContext &C,
+                              llvm::APInt &Min, llvm::APInt &Max,
+                              unsigned Depth = 0);
+  static bool productDefinitelyFitsInType(const Expr *L, const Expr *R,
+                                          QualType MulType, CheckerContext &C);
+
   // Finds a suspicious '*' on the value-producing path of Root.
   static bool findFirstSuspiciousMulOnValuePath(const Expr *Root,
                                                 unsigned TargetBits,
@@ -75,11 +86,30 @@   // Extract a variable/field identifier name from an expression if possible.
   static std::string extractIdentifierLikeName(const Expr *E);

-  // Semantic filters to reduce false positives.
+  static bool nameContains(StringRef TextLower,
+                           std::initializer_list<StringRef> Needles);
+
+  // Address/size-like LHS filter for intended bug surface.
   static bool isAddressOrSizeLikeLHS(const Expr *LHS);
+
+  // IRQ-like and jiffies contexts suppression.
   static bool isIrqLikeContext(const Expr *Root, const Expr *LHS, CheckerContext &C);

-  // Heuristic: detect known-timeout/jiffies contexts to avoid FPs.
+  // Kernel block/folio I/O math suppression helpers
+  static bool isShiftOfOne(const Expr *E);
+  static bool exprNameContains(const Expr *E, std::initializer_list<StringRef> Needles,
+                               CheckerContext &C);
+  static bool isBlockSizeLikeExpr(const Expr *E, CheckerContext &C);
+  static bool isAddSubChainRec(const Expr *E,
+                               std::initializer_list<StringRef> Needles,
+                               CheckerContext &C);
+  static bool isAddSubChainOfNames(const Expr *E,
+                                   std::initializer_list<StringRef> Needles,
+                                   CheckerContext &C);
+  static bool isBlockCountLikeExpr(const Expr *E, CheckerContext &C);
+  static bool isPageOrFolioContext(const Expr *Root, CheckerContext &C);
+
+  // Heuristic: detect known-timeout/jiffies/IRQ contexts to avoid FPs.
   static bool isFalsePositiveContext(const Expr *Root,
                                      const BinaryOperator *MulBO,
                                      const Expr *LHSExpr,
@@ -99,9 +129,6 @@                               const Expr *LHSExpr,
                               CheckerContext &C);

-  static bool nameContains(StringRef TextLower,
-                           std::initializer_list<StringRef> Needles);
-
   void emitReport(const BinaryOperator *MulBO, QualType LHSType,
                   CheckerContext &C) const;
 };
@@ -117,9 +144,13 @@   return QT->isIntegerType() || QT->isEnumeralType();
 }

-// Wide target: integer-like and width >= 64 bits (covers u64, dma_addr_t on 64-bit).
+// Wide target: unsigned integer-like and width >= 64 bits (covers u64, dma_addr_t on 64-bit).
+// Narrowing to unsigned eliminates benign signed long "size" temporaries like ALSA's private_size.
 bool SAGenTestChecker::isWideTargetType(QualType QT, CheckerContext &C) {
   if (!isIntegerLike(QT))
+    return false;
+
+  if (!QT->isUnsignedIntegerOrEnumerationType())
     return false;

   unsigned Bits = getTypeBitWidth(QT, C);
@@ -132,6 +163,209 @@     return false;
   llvm::APSInt EvalRes;
   return EvaluateExprToInt(EvalRes, E, C);
+}
+
+// Compute min and max representable by a type in 128-bit APInt.
+void SAGenTestChecker::getTypeRange128(QualType QT, CheckerContext &C,
+                                       llvm::APInt &Min, llvm::APInt &Max) {
+  unsigned Bits = getTypeBitWidth(QT, C);
+  bool IsUnsigned = QT->isUnsignedIntegerOrEnumerationType();
+  if (IsUnsigned) {
+    llvm::APInt TMin(Bits, 0, /*isSigned=*/false);
+    llvm::APInt TMax = llvm::APInt::getMaxValue(Bits);
+    Min = TMin.zextOrTrunc(128);
+    Max = TMax.zextOrTrunc(128);
+  } else {
+    llvm::APInt TMin = llvm::APInt::getSignedMinValue(Bits);
+    llvm::APInt TMax = llvm::APInt::getSignedMaxValue(Bits);
+    Min = TMin.sextOrTrunc(128);
+    Max = TMax.sextOrTrunc(128);
+  }
+}
+
+// Lightweight interval analysis for expressions. Always returns true,
+// providing a conservative range, falling back to type-based ranges.
+// Depth-limited to avoid pathological recursion.
+bool SAGenTestChecker::getExprRange128(const Expr *E, CheckerContext &C,
+                                       llvm::APInt &Min, llvm::APInt &Max,
+                                       unsigned Depth) {
+  const unsigned MaxDepth = 8;
+  if (!E || Depth > MaxDepth) {
+    getTypeRange128(E ? E->getType() : C.getASTContext().IntTy, C, Min, Max);
+    return true;
+  }
+
+  // If this expression folds to a constant, use that precise value.
+  llvm::APSInt Folded;
+  if (EvaluateExprToInt(Folded, E->IgnoreParenImpCasts(), C)) {
+    llvm::APInt V = Folded.extOrTrunc(128);
+    Min = V;
+    Max = V;
+    return true;
+  }
+
+  // Parens: skip
+  if (const auto *PE = dyn_cast<ParenExpr>(E)) {
+    return getExprRange128(PE->getSubExpr(), C, Min, Max, Depth + 1);
+  }
+
+  // Casts: get sub-range and clamp to destination type.
+  if (const auto *CE = dyn_cast<CastExpr>(E)) {
+    llvm::APInt SMin(128, 0), SMax(128, 0);
+    (void)getExprRange128(CE->getSubExpr(), C, SMin, SMax, Depth + 1);
+    llvm::APInt TMin(128, 0), TMax(128, 0);
+    getTypeRange128(CE->getType(), C, TMin, TMax);
+    // Intersect [SMin, SMax] with [TMin, TMax].
+    Min = SMin;
+    Max = SMax;
+    if (Min.slt(TMin)) Min = TMin;
+    if (Max.sgt(TMax)) Max = TMax;
+    if (Min.sgt(Max)) { Min = TMin; Max = TMax; }
+    return true;
+  }
+
+  // Integer literal
+  if (const auto *IL = dyn_cast<IntegerLiteral>(E->IgnoreParenCasts())) {
+    llvm::APInt V = IL->getValue();
+    V = V.sextOrTrunc(128);
+    Min = V;
+    Max = V;
+    return true;
+  }
+
+  // Character literal
+  if (const auto *CL = dyn_cast<CharacterLiteral>(E->IgnoreParenCasts())) {
+    uint64_t V = static_cast<uint64_t>(CL->getValue());
+    llvm::APInt A(128, V, /*isSigned=*/false);
+    Min = A;
+    Max = A;
+    return true;
+  }
+
+  // Unary operator handling
+  if (const auto *UO = dyn_cast<UnaryOperator>(E)) {
+    UnaryOperatorKind K = UO->getOpcode();
+    if (K == UO_Plus) {
+      return getExprRange128(UO->getSubExpr(), C, Min, Max, Depth + 1);
+    }
+    if (K == UO_Minus) {
+      llvm::APInt SMin(128, 0), SMax(128, 0);
+      (void)getExprRange128(UO->getSubExpr(), C, SMin, SMax, Depth + 1);
+      // Negate reverses bounds: [-b, -a]
+      Min = -SMax;
+      Max = -SMin;
+      return true;
+    }
+    // Address/deref or other: fallback to type range
+    getTypeRange128(UO->getType(), C, Min, Max);
+    return true;
+  }
+
+  // Binary operators
+  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+    BinaryOperatorKind Op = BO->getOpcode();
+
+    // RHS path for comma
+    if (Op == BO_Comma) {
+      return getExprRange128(BO->getRHS(), C, Min, Max, Depth + 1);
+    }
+
+    // Assign: resulting value is RHS
+    if (Op == BO_Assign) {
+      return getExprRange128(BO->getRHS(), C, Min, Max, Depth + 1);
+    }
+
+    llvm::APInt LMin(128, 0), LMax(128, 0), RMin(128, 0), RMax(128, 0);
+    (void)getExprRange128(BO->getLHS(), C, LMin, LMax, Depth + 1);
+    (void)getExprRange128(BO->getRHS(), C, RMin, RMax, Depth + 1);
+
+    switch (Op) {
+    case BO_Add: {
+      Min = LMin + RMin;
+      Max = LMax + RMax;
+      return true;
+    }
+    case BO_Sub: {
+      Min = LMin - RMax;
+      Max = LMax - RMin;
+      return true;
+    }
+    case BO_Mul: {
+      // Conservative: range of product = hull of endpoints.
+      llvm::APInt Cands[4] = { LMin * RMin, LMin * RMax, LMax * RMin, LMax * RMax };
+      Min = Cands[0];
+      Max = Cands[0];
+      for (int i = 1; i < 4; ++i) {
+        if (Cands[i].slt(Min)) Min = Cands[i];
+        if (Cands[i].sgt(Max)) Max = Cands[i];
+      }
+      return true;
+    }
+    case BO_Shl:
+    case BO_Shr:
+    case BO_And:
+    case BO_Or:
+    case BO_Xor:
+    default:
+      // Fallback for complex ops
+      getTypeRange128(BO->getType(), C, Min, Max);
+      return true;
+    }
+  }
+
+  // Conditional operator ?:
+  if (const auto *CO = dyn_cast<ConditionalOperator>(E)) {
+    llvm::APInt TMin(128, 0), TMax(128, 0), FMin(128, 0), FMax(128, 0);
+    (void)getExprRange128(CO->getTrueExpr(), C, TMin, TMax, Depth + 1);
+    (void)getExprRange128(CO->getFalseExpr(), C, FMin, FMax, Depth + 1);
+    Min = TMin.slt(FMin) ? TMin : FMin;
+    Max = TMax.sgt(FMax) ? TMax : FMax;
+    return true;
+  }
+
+  // Array subscripts: use element type range.
+  if (isa<ArraySubscriptExpr>(E)) {
+    getTypeRange128(E->getType(), C, Min, Max);
+    return true;
+  }
+
+  // Member access / decl ref: use their type ranges.
+  if (isa<MemberExpr>(E) || isa<DeclRefExpr>(E)) {
+    getTypeRange128(E->getType(), C, Min, Max);
+    return true;
+  }
+
+  // CallExpr or anything else: fallback to type-based range.
+  getTypeRange128(E->getType(), C, Min, Max);
+  return true;
+}
+
+// If we can bound both operands, compute the product interval and verify it fits
+// entirely in the multiplication's result type. No non-negativity requirement.
+bool SAGenTestChecker::productDefinitelyFitsInType(const Expr *L, const Expr *R,
+                                                   QualType MulType, CheckerContext &C) {
+  llvm::APInt LMin(128, 0), LMax(128, 0), RMin(128, 0), RMax(128, 0);
+  (void)getExprRange128(L, C, LMin, LMax);
+  (void)getExprRange128(R, C, RMin, RMax);
+
+  // Compute product bounds (signed).
+  llvm::APInt Cands[4] = { LMin * RMin, LMin * RMax, LMax * RMin, LMax * RMax };
+  llvm::APInt PMin = Cands[0];
+  llvm::APInt PMax = Cands[0];
+  for (int i = 1; i < 4; ++i) {
+    if (Cands[i].slt(PMin)) PMin = Cands[i];
+    if (Cands[i].sgt(PMax)) PMax = Cands[i];
+  }
+
+  // MulType range.
+  llvm::APInt TMin(128, 0), TMax(128, 0);
+  getTypeRange128(MulType, C, TMin, TMax);
+
+  // Product definitely fits if entire [PMin, PMax] within [TMin, TMax].
+  if (PMin.sge(TMin) && PMax.sle(TMax))
+    return true;
+
+  return false;
 }

 // Restrict traversal to the value-producing path of Root.
@@ -153,11 +387,14 @@       if (isIntegerLike(ResT)) {
         unsigned MulBits = getTypeBitWidth(ResT, C);
         if (MulBits < TargetBits) {
-          OutMul = BO;
-          return true;
+          // Guard: if we can prove the product cannot overflow in ResT, skip.
+          if (!productDefinitelyFitsInType(BO->getLHS(), BO->getRHS(), ResT, C)) {
+            OutMul = BO;
+            return true;
+          }
         }
       }
-      // Even if not suspicious, do not stop searching; sub-operands might contain another mul.
+      // Continue searching sub-expressions.
       if (findFirstSuspiciousMulOnValuePath(BO->getLHS(), TargetBits, OutMul, C))
         return true;
       if (findFirstSuspiciousMulOnValuePath(BO->getRHS(), TargetBits, OutMul, C))
@@ -253,7 +490,8 @@   return false;
 }

-// Address/size-like LHS filter for intended bug surface.
+// Address/size-like LHS filter for intended bug surface (narrowed).
+// Focus on addr/size/pitch/stride-like sinks. Avoid generic "len", "offset" to reduce FPs.
 bool SAGenTestChecker::isAddressOrSizeLikeLHS(const Expr *LHS) {
   std::string Name = extractIdentifierLikeName(LHS);
   if (Name.empty())
@@ -262,11 +500,10 @@   std::transform(Lower.begin(), Lower.end(), Lower.begin(), ::tolower);

   // Heuristic keywords that map to memory/byte/size/address semantics.
-  // This keeps detection focused on the intended bug pattern.
   return nameContains(Lower,
                       {"addr", "address", "dma_addr",
-                       "size", "len", "length", "bytes", "nbytes",
-                       "count", "pitch", "stride", "offset", "ofs"});
+                       "size", "bytes", "nbytes",
+                       "pitch", "stride"});
 }

 // IRQ-like context suppression.
@@ -290,28 +527,121 @@   }

   // Source expression text heuristic.
-  if (ExprHasName(Root, "intspec", C) || ExprHasName(Root, "irq", C) ||
+  if (ExprHasName(Root, "jiffies", C) || ExprHasName(Root, "irq", C) ||
       ExprHasName(Root, "hwirq", C))
     return true;

   return false;
 }

-// Secondary guard: filter known jiffies/timeout contexts to avoid false positives.
+// Returns true if expression is of the form (1 << X) or (1U << X).
+bool SAGenTestChecker::isShiftOfOne(const Expr *E) {
+  if (!E) return false;
+  E = E->IgnoreParenImpCasts();
+  const auto *BO = dyn_cast<BinaryOperator>(E);
+  if (!BO || BO->getOpcode() != BO_Shl)
+    return false;
+  const auto *LHS_IL = dyn_cast<IntegerLiteral>(BO->getLHS()->IgnoreParenCasts());
+  if (!LHS_IL) return false;
+  return LHS_IL->getValue() == 1;
+}
+
+bool SAGenTestChecker::exprNameContains(const Expr *E,
+                                        std::initializer_list<StringRef> Needles,
+                                        CheckerContext &C) {
+  if (!E) return false;
+  // Try identifier name first.
+  std::string Name = extractIdentifierLikeName(E);
+  std::string Lower = Name;
+  std::transform(Lower.begin(), Lower.end(), Lower.begin(), ::tolower);
+  if (!Lower.empty() && nameContains(Lower, Needles))
+    return true;
+  // Fallback to source text.
+  for (StringRef N : Needles) {
+    if (ExprHasName(E, N, C))
+      return true;
+  }
+  return false;
+}
+
+// block-size-like: variable named block_size/blksize/bsize/fs_block_size
+// OR an expression like (1 << block_bits) or (1U << blkbits)
+bool SAGenTestChecker::isBlockSizeLikeExpr(const Expr *E, CheckerContext &C) {
+  if (!E) return false;
+  if (exprNameContains(E, {"block_size", "blksize", "bsize", "fs_block_size",
+                           "page_size", "blocksize"}, C))
+    return true;
+  if (isShiftOfOne(E))
+    return true;
+  // Also accept (1 << something) nested within parens/casts.
+  return false;
+}
+
+// recursively check if E is a +/- chain composed of names from Needles and integer literals
+bool SAGenTestChecker::isAddSubChainRec(const Expr *E,
+                                        std::initializer_list<StringRef> Needles,
+                                        CheckerContext &C) {
+  if (!E) return false;
+  E = E->IgnoreParenImpCasts();
+  if (isa<IntegerLiteral>(E))
+    return true;
+  if (exprNameContains(E, Needles, C))
+    return true;
+  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+    if (BO->getOpcode() == BO_Add || BO->getOpcode() == BO_Sub) {
+      return isAddSubChainRec(BO->getLHS(), Needles, C) &&
+             isAddSubChainRec(BO->getRHS(), Needles, C);
+    }
+  }
+  return false;
+}
+
+// count-like: combinations like (last - i + 1), (nr_blks), (blocks), etc.
+bool SAGenTestChecker::isAddSubChainOfNames(const Expr *E,
+                                            std::initializer_list<StringRef> Needles,
+                                            CheckerContext &C) {
+  return isAddSubChainRec(E, Needles, C);
+}
+
+bool SAGenTestChecker::isBlockCountLikeExpr(const Expr *E, CheckerContext &C) {
+  // Common identifiers in block/folio counting contexts.
+  return isAddSubChainOfNames(
+      E,
+      {"first", "last", "end", "i", "j", "k", "count", "nr", "nr_blks",
+       "nr_blocks", "blocks", "blks", "nblocks", "nblks", "block"},
+      C);
+}
+
+// Identify iomap/folio/page context from function name or expression text.
+bool SAGenTestChecker::isPageOrFolioContext(const Expr *Root, CheckerContext &C) {
+  const FunctionDecl *FD = nullptr;
+  if (const auto *LC = C.getLocationContext())
+    FD = dyn_cast_or_null<FunctionDecl>(LC->getDecl());
+  if (FD) {
+    std::string FName = FD->getNameAsString();
+    std::transform(FName.begin(), FName.end(), FName.begin(), ::tolower);
+    if (nameContains(FName, {"iomap", "folio", "readahead", "readpage"}))
+      return true;
+  }
+  // Fallback to textual hints.
+  if (ExprHasName(Root, "folio", C) || ExprHasName(Root, "iomap", C) ||
+      ExprHasName(Root, "page", C))
+    return true;
+  return false;
+}
+
+// Secondary guard: filter known benign contexts to avoid false positives.
 bool SAGenTestChecker::isFalsePositiveContext(const Expr *Root,
                                               const BinaryOperator *MulBO,
                                               const Expr *LHSExpr,
                                               CheckerContext &C) {
   (void)MulBO;

-  // 1) If the RHS/root expression text contains "jiffies", treat this as
-  //    time arithmetic; suppress the report.
+  // 1) Time arithmetic.
   if (ExprHasName(Root, "jiffies", C))
     return true;

-  // 2) If the parent assignment/compound-assignment LHS name implies timeout-like field,
-  //    suppress as well.
-  //    Common patterns: expires, expiry, timeout, deadline, jiffies.
+  // 2) Timeout-like LHS names.
   const CompoundAssignOperator *CAO =
       findSpecificTypeInParents<CompoundAssignOperator>(Root, C);
   const BinaryOperator *AssignBO =
@@ -335,9 +665,20 @@     }
   }

-  // 3) IRQ-like contexts (e.g., hwirq math) commonly wide-typed but safe.
+  // 3) IRQ-like contexts.
   if (LHS && isIrqLikeContext(Root, LHS, C))
     return true;
+
+  // 4) Kernel iomap/folio math: count-like * block-size-like, in page/folio context.
+  if (MulBO && isPageOrFolioContext(Root, C)) {
+    const Expr *ML = MulBO->getLHS()->IgnoreParenImpCasts();
+    const Expr *MR = MulBO->getRHS()->IgnoreParenImpCasts();
+    bool IsBlockGeom =
+        (isBlockSizeLikeExpr(ML, C) && isBlockCountLikeExpr(MR, C)) ||
+        (isBlockSizeLikeExpr(MR, C) && isBlockCountLikeExpr(ML, C));
+    if (IsBlockGeom)
+      return true;
+  }

   return false;
 }
@@ -347,7 +688,7 @@ bool SAGenTestChecker::isMulUnderCallArg(const BinaryOperator *MulBO,
                                          const Expr *Root,
                                          CheckerContext &C) {
-  (void)Root; // Root can be used for stricter checks if needed.
+  (void)Root;
   const CallExpr *CE = findSpecificTypeInParents<CallExpr>(MulBO, C);
   return CE != nullptr;
 }
@@ -367,20 +708,17 @@   if (!MulBO)
     return true;

-  // Suppress when:
-  // - The LHS is not address/size-like (we only target addr/size/len/offset/pitch/stride).
+  // Suppress when LHS is not address/size-like (we target addr/size/pitch/stride).
   if (!isAddressOrSizeLikeLHS(LHSExpr))
     return true;

-  // - The context is time/jiffies-like or irq-domain-like.
+  // Suppress known benign contexts.
   if (isFalsePositiveContext(Root, MulBO, LHSExpr, C))
     return true;

-  // - The multiplication is under a CallExpr (argument), e.g., MSR index macros.
+  // Suppress when '*' is under a call arg or an array index.
   if (isMulUnderCallArg(MulBO, Root, C))
     return true;
-
-  // - The multiplication is under an ArraySubscriptExpr (index computation).
   if (isMulUnderArrayIndex(MulBO, C))
     return true;

@@ -396,7 +734,7 @@   if (!N)
     return;

-  SmallString<128> Msg;
+  llvm::SmallString<128> Msg;
   Msg += "Multiplication occurs in a narrower type and is widened after; ";
   Msg += "possible overflow before assignment/addition to wide type";
   auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);
@@ -424,6 +762,11 @@       const BinaryOperator *MulBO = nullptr;
       const Expr *RHS = CAO->getRHS();
       if (findFirstSuspiciousMulOnValuePath(RHS, getTypeBitWidth(LT, C), MulBO, C)) {
+        // Extra safety: if multiplication definitely fits in its own type, skip.
+        if (MulBO && productDefinitelyFitsInType(MulBO->getLHS(), MulBO->getRHS(),
+                                                 MulBO->getType(), C)) {
+          return;
+        }
         if (MulBO && !isConstantFolded(MulBO, C) &&
             !isFalsePositive(RHS, MulBO, LHS, C)) {
           emitReport(MulBO, LT, C);
@@ -448,6 +791,10 @@     const Expr *RHS = BO->getRHS();
     const BinaryOperator *MulBO = nullptr;
     if (findFirstSuspiciousMulOnValuePath(RHS, getTypeBitWidth(LT, C), MulBO, C)) {
+      if (MulBO && productDefinitelyFitsInType(MulBO->getLHS(), MulBO->getRHS(),
+                                               MulBO->getType(), C)) {
+        return;
+      }
       if (MulBO && !isConstantFolded(MulBO, C) &&
           !isFalsePositive(RHS, MulBO, LHS, C)) {
         emitReport(MulBO, LT, C);
@@ -475,23 +822,22 @@     const Expr *Init = VD->getInit();
     const BinaryOperator *MulBO = nullptr;
     if (findFirstSuspiciousMulOnValuePath(Init, getTypeBitWidth(T, C), MulBO, C)) {
-      // For initialization, synthesize a pseudo-LHS using the VarDecl's name.
-      // We'll build a simple DeclRefExpr-like name via VD.
-      // Here we create a very small shim: we pass nullptr for LHSExpr, but handle
-      // it in isFalsePositiveContext by scanning jiffies/irq in Root and using
-      // the VarDecl's name as a proxy for LHS semantics.
-      // Simpler: construct a fake DeclRefExpr is heavy; instead check name here.
-      // If VD name isn't address/size-like, suppress.
+      // For initialization, ensure the variable name is address/size-like.
       std::string Name = VD->getNameAsString();
       std::string Lower = Name;
       std::transform(Lower.begin(), Lower.end(), Lower.begin(), ::tolower);
       bool IsAddrSizeLike =
           nameContains(Lower,
                        {"addr", "address", "dma_addr",
-                        "size", "len", "length", "bytes", "nbytes",
-                        "count", "pitch", "stride", "offset", "ofs"});
+                        "size", "bytes", "nbytes",
+                        "pitch", "stride"});
       if (!IsAddrSizeLike)
         continue;
+
+      if (MulBO && productDefinitelyFitsInType(MulBO->getLHS(), MulBO->getRHS(),
+                                               MulBO->getType(), C)) {
+        continue;
+      }

       if (MulBO && !isConstantFolded(MulBO, C) &&
           !isFalsePositive(Init, MulBO, nullptr, C)) {
