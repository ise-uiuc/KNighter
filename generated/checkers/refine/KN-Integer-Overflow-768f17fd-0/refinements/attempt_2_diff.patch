--- attempt_2_original.cpp+++ attempt_2.cpp@@ -15,7 +15,12 @@ #include "clang/StaticAnalyzer/Checkers/utility.h"
 #include "clang/AST/Expr.h"
 #include "clang/AST/ExprCXX.h"
+#include "clang/AST/Type.h"
 #include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/ImmutableMap.h"
+#include <algorithm>
+#include <cctype>
+#include <optional>

 using namespace clang;
 using namespace ento;
@@ -34,6 +39,25 @@ bool functionKnownToDeref(const CallEvent &Call, llvm::SmallVectorImpl<unsigned> &DerefParams);
 bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C);

+// Track per-variable coarse upper bounds learned from assignments.
+// Key: VarDecl*, Value: APSInt upper bound (unsigned).
+namespace {
+struct VarUpperBoundMap {};
+}
+
+namespace clang {
+namespace ento {
+template <>
+struct ProgramStateTrait<VarUpperBoundMap>
+    : public ProgramStatePartialTrait<llvm::ImmutableMap<const VarDecl *, llvm::APSInt>> {
+  static void *GDMIndex() {
+    static int Index;
+    return &Index;
+  }
+};
+} // namespace ento
+} // namespace clang
+
 namespace {

 class SAGenTestChecker
@@ -60,12 +84,18 @@   static const BinaryOperator *findShiftInTree(const Stmt *S);
   static bool hasExplicitCastToWide64(const Expr *E, ASTContext &ACtx);

-  // Helpers to refine and reduce false positives.
   static const Expr *peel(const Expr *E) {
     return E ? E->IgnoreParenImpCasts() : nullptr;
   }

-  // Report only if the shift is the top-level expression reaching the 64-bit destination.
+  static const BinaryOperator *asShift(const Stmt *S) {
+    if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S)) {
+      if (BO->getOpcode() == BO_Shl)
+        return BO;
+    }
+    return nullptr;
+  }
+
   static bool isTopLevelShiftExpr(const Expr *ContainerE, const BinaryOperator *Shl) {
     if (!ContainerE || !Shl)
       return false;
@@ -73,8 +103,6 @@     return Top == static_cast<const Expr *>(Shl);
   }

-  // Precise constant-safety check: if both LHS and RHS are constant and the result
-  // provably fits into the LHS bitwidth, we suppress.
   static bool constantShiftFitsInLHSWidth(const Expr *L, const Expr *R,
                                           unsigned LHSW, CheckerContext &C) {
     llvm::APSInt LHSEval, RHSEval;
@@ -83,42 +111,295 @@     if (!EvaluateExprToInt(RHSEval, R, C))
       return false;

-    // Be conservative for negative LHS.
     if (LHSEval.isSigned() && LHSEval.isNegative())
       return false;

-    // Active bits of the non-negative LHS.
-    unsigned LBits = LHSEval.getActiveBits(); // 0 if value == 0
+    unsigned LBits = LHSEval.getActiveBits();
     uint64_t ShiftAmt = RHSEval.getZExtValue();
-
-    // Safe if highest set bit after shifting still fits in LHS width.
-    // LBits == 0 is always safe (0 << n == 0).
     if (LBits == 0)
       return true;
-
-    // Example: a 32-bit LHS can hold results where (LBits + ShiftAmt) <= 32.
     return (uint64_t)LBits + ShiftAmt <= (uint64_t)LHSW;
   }

-  // Centralized FP gate
+  static bool isAnyLongType(QualType QT) {
+    return QT->isSpecificBuiltinType(BuiltinType::Long) ||
+           QT->isSpecificBuiltinType(BuiltinType::ULong);
+  }
+
+  static bool isFixed64Builtin(QualType QT) {
+    return QT->isSpecificBuiltinType(BuiltinType::LongLong) ||
+           QT->isSpecificBuiltinType(BuiltinType::ULongLong);
+  }
+
+  static bool calleeNameLooksLikeIOOrReg(StringRef Name) {
+    llvm::SmallString<64> Lower(Name);
+    for (char &c : Lower)
+      c = static_cast<char>(tolower(static_cast<unsigned char>(c)));
+    StringRef S(Lower);
+    return S.contains("read") || S.contains("write") || S.contains("peek") ||
+           S.contains("poke") || S.contains("in") || S.contains("out") ||
+           S.contains("io") || S.contains("reg");
+  }
+
+  static bool paramNameLooksLikeAddrOffset(const ParmVarDecl *P) {
+    if (!P)
+      return false;
+    StringRef N = P->getName();
+    if (N.empty())
+      return false;
+
+    llvm::SmallString<64> Lower(N);
+    for (char &c : Lower)
+      c = static_cast<char>(tolower(static_cast<unsigned char>(c)));
+    StringRef S(Lower);
+    return S.contains("addr") || S.contains("address") || S.contains("offset") ||
+           S.contains("ofs") || S.contains("reg") || S.contains("index") ||
+           S.contains("port") || S.contains("bar");
+  }
+
+  static bool tryGetConstShiftAmount(const Expr *R, CheckerContext &C, uint64_t &Out) {
+    llvm::APSInt RHSEval;
+    if (!EvaluateExprToInt(RHSEval, R, C))
+      return false;
+    Out = RHSEval.getZExtValue();
+    return true;
+  }
+
+  static bool findCallParentAndArgIndex(const Expr *E, CheckerContext &C,
+                                        const CallExpr *&OutCE, unsigned &OutIdx) {
+    OutCE = findSpecificTypeInParents<CallExpr>(E, C);
+    if (!OutCE)
+      return false;
+
+    const Expr *PE = peel(E);
+    unsigned ArgCount = OutCE->getNumArgs();
+    for (unsigned i = 0; i < ArgCount; ++i) {
+      const Expr *AE = OutCE->getArg(i);
+      if (peel(AE) == PE) {
+        OutIdx = i;
+        return true;
+      }
+    }
+       return false;
+  }
+
   static bool isFalsePositiveContext(const Expr *WholeExpr,
                                      const BinaryOperator *Shl,
-                                     CheckerContext &C) {
-    // Suppress if the shift isn't the top-level expression being assigned/returned/passed.
+                                     QualType DestTy,
+                                     CheckerContext &C,
+                                     StringRef Ctx) {
     if (!isTopLevelShiftExpr(WholeExpr, Shl))
       return true;

+    if (Ctx == "argument") {
+      const CallExpr *CE = nullptr;
+      unsigned ArgIdx = 0;
+      if (findCallParentAndArgIndex(WholeExpr, C, CE, ArgIdx)) {
+        const FunctionDecl *FD = CE->getDirectCallee();
+        const ParmVarDecl *PVD = nullptr;
+        if (FD && ArgIdx < FD->getNumParams())
+          PVD = FD->getParamDecl(ArgIdx);
+
+        if (isAnyLongType(DestTy))
+          return true;
+
+        if (PVD && paramNameLooksLikeAddrOffset(PVD))
+          return true;
+
+        if (FD) {
+          if (const IdentifierInfo *ID = FD->getIdentifier()) {
+            if (calleeNameLooksLikeIOOrReg(ID->getName()))
+              return true;
+          }
+        }
+
+        uint64_t K = 0;
+        if (tryGetConstShiftAmount(Shl->getRHS(), C, K) && K <= 3)
+          return true;
+      }
+    }
+
     return false;
   }
+
+  // Extract a coarse upper bound from an assignment RHS by scanning integer literals.
+  // Intended to capture patterns like min(x, CONST) where CONST is the controlling bound.
+  static bool extractUpperBoundLiteralFromRHS(const Expr *RHS, CheckerContext &C,
+                                              llvm::APSInt &Out) {
+    if (!RHS)
+      return false;
+
+    // Walk the subtree, find the maximum integer literal value.
+    llvm::APSInt MaxVal(64, true); // unsigned
+    bool Found = false;
+
+    llvm::SmallVector<const Stmt *, 16> Worklist;
+    Worklist.push_back(RHS);
+    while (!Worklist.empty()) {
+      const Stmt *Cur = Worklist.pop_back_val();
+      if (!Cur) continue;
+
+      if (const auto *IL = dyn_cast<IntegerLiteral>(Cur)) {
+        llvm::APInt V = IL->getValue();
+        if (!Found || V.ugt(MaxVal))
+          MaxVal = llvm::APSInt(V, /*isUnsigned=*/true);
+        Found = true;
+      } else if (const auto *CharL = dyn_cast<CharacterLiteral>(Cur)) {
+        llvm::APInt V(64, CharL->getValue());
+        if (!Found || V.ugt(MaxVal))
+          MaxVal = llvm::APSInt(V, /*isUnsigned=*/true);
+        Found = true;
+      } else if (const auto *UO = dyn_cast<UnaryOperator>(Cur)) {
+        // Try to handle sizeof-like folds that may appear as integral casts.
+        // We still just traverse.
+        if (const Expr *SubE = UO->getSubExpr())
+          Worklist.push_back(SubE);
+      } else {
+        for (const Stmt *Child : Cur->children())
+          if (Child)
+            Worklist.push_back(Child);
+      }
+    }
+
+    if (Found) {
+      Out = MaxVal;
+      return true;
+    }
+    return false;
+  }
+
+  // Get a recorded per-variable upper bound from program state.
+  static bool getRecordedVarUpperBound(const Expr *E, CheckerContext &C,
+                                       llvm::APSInt &Out) {
+    const auto *DRE = dyn_cast_or_null<DeclRefExpr>(peel(E));
+    if (!DRE)
+      return false;
+    const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());
+    if (!VD)
+      return false;
+
+    ProgramStateRef State = C.getState();
+    const llvm::APSInt *Stored = State->get<VarUpperBoundMap>(VD);
+    if (!Stored)
+      return false;
+    Out = *Stored;
+    return true;
+  }
+
+  // Compute an upper bound for an expression based on:
+  // - Exact constant evaluation
+  // - Recorded per-variable upper bounds
+  // - Simple addition of sub-bounds
+  static bool computeExprUpperBound(const Expr *E, CheckerContext &C,
+                                    llvm::APSInt &Out) {
+    if (!E)
+      return false;
+    E = peel(E);
+
+    // Constant?
+    llvm::APSInt Val;
+    if (EvaluateExprToInt(Val, E, C)) {
+      if (Val.isSigned() && Val.isNegative())
+        return false; // not handling negative bounds here
+      Out = Val.extOrTrunc(64);
+      Out.setIsUnsigned(true);
+      return true;
+    }
+
+    // Variable with recorded bound?
+    if (getRecordedVarUpperBound(E, C, Out))
+      return true;
+
+    // Symbolic? Try constraint manager max.
+    ProgramStateRef State = C.getState();
+    SVal SV = State->getSVal(E, C.getLocationContext());
+    if (std::optional<nonloc::ConcreteInt> CI = SV.getAs<nonloc::ConcreteInt>()) {
+      llvm::APSInt CIVal = CI->getValue();
+      if (CIVal.isSigned() && CIVal.isNegative())
+        return false;
+      Out = CIVal.extOrTrunc(64);
+      Out.setIsUnsigned(true);
+      return true;
+    }
+    if (SymbolRef Sym = SV.getAsSymbol()) {
+      if (const llvm::APSInt *Max = inferSymbolMaxVal(Sym, C)) {
+        llvm::APSInt M = *Max;
+        if (M.isSigned() && M.isNegative())
+          return false;
+        Out = M.extOrTrunc(64);
+        Out.setIsUnsigned(true);
+        return true;
+      }
+    }
+
+    // Composite expressions: try L + R for additions
+    if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+      if (BO->getOpcode() == BO_Add) {
+        llvm::APSInt LUB, RUB;
+        if (computeExprUpperBound(BO->getLHS(), C, LUB) &&
+            computeExprUpperBound(BO->getRHS(), C, RUB)) {
+          unsigned BW = std::max(LUB.getBitWidth(), RUB.getBitWidth());
+          llvm::APSInt L2 = LUB.extOrTrunc(BW);
+          llvm::APSInt R2 = RUB.extOrTrunc(BW);
+          L2.setIsUnsigned(true);
+          R2.setIsUnsigned(true);
+          Out = L2 + R2;
+          Out.setIsUnsigned(true);
+          return true;
+        }
+      }
+      // Other ops: give up (conservative)
+    }
+
+    return false;
+  }
+
+  // Compute maximum number of active bits an expression's value can have,
+  // using constants or recorded/symbolic upper bounds.
+  static bool computeExprMaxActiveBits(const Expr *E, CheckerContext &C,
+                                       unsigned &OutBits) {
+    if (!E)
+      return false;
+    E = peel(E);
+
+    llvm::APSInt Val;
+    if (EvaluateExprToInt(Val, E, C)) {
+      if (Val.isSigned() && Val.isNegative())
+        return false;
+      OutBits = Val.getActiveBits();
+      return true;
+    }
+
+    llvm::APSInt UB;
+    if (computeExprUpperBound(E, C, UB)) {
+      // Active bits of the upper bound is an upper bound on the active bits.
+      OutBits = UB.getActiveBits();
+      return true;
+    }
+
+    return false;
+  }
+
+  // Decide if the shift is provably safe within the LHS bitwidth (e.g., 32-bit)
+  // under computed upper bounds for L and R.
+  static bool shiftSafeUnderUpperBounds(const Expr *L, const Expr *R,
+                                        unsigned LHSW, CheckerContext &C) {
+    unsigned MaxLBits = 0;
+    if (!computeExprMaxActiveBits(L, C, MaxLBits))
+      return false;
+
+    llvm::APSInt RMax;
+    if (!computeExprUpperBound(R, C, RMax))
+      return false;
+
+    uint64_t ShiftMax = RMax.getZExtValue();
+
+    if (MaxLBits == 0)
+      return true;
+
+    return (uint64_t)MaxLBits + ShiftMax <= (uint64_t)LHSW;
+  }
 };
-
-static const BinaryOperator *asShift(const Stmt *S) {
-  if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S)) {
-    if (BO->getOpcode() == BO_Shl)
-      return BO;
-  }
-  return nullptr;
-}

 const BinaryOperator *SAGenTestChecker::findShiftInTree(const Stmt *S) {
   if (!S)
@@ -156,7 +437,7 @@ }

 void SAGenTestChecker::analyzeAndReportShiftToWide(const Expr *E, QualType DestTy,
-                                                   CheckerContext &C, StringRef) const {
+                                                   CheckerContext &C, StringRef Ctx) const {
   if (!E)
     return;

@@ -186,24 +467,27 @@   if (ShlW >= 64)
     return; // Shift already performed in 64-bit, OK.

-  // LHS must be integer and narrower than 64.
   if (!L->getType()->isIntegerType())
     return;

   unsigned LHSW = ACtx.getIntWidth(L->getType());
   if (LHSW >= 64)
-    return; // LHS is already wide enough.
-
-  // If there is an explicit cast to >=64-bit within the LHS subtree, suppress.
+    return; // LHS already wide.
+
   if (hasExplicitCastToWide64(L, ACtx))
     return;

-  // Suppress known false-positive contexts.
-  if (isFalsePositiveContext(E, Shl, C))
-    return;
-
-  // Precise constant-bound suppression: only if both sides are constants and safe.
+  if (isFalsePositiveContext(E, Shl, DestTy, C, Ctx))
+    return;
+
+  // Constant proof: safely fits.
   if (constantShiftFitsInLHSWidth(L, R, LHSW, C))
+    return;
+
+  // New: Symbolic upper-bound proof: if we can prove the result fits in 32-bit,
+  // suppress. This addresses cases like: pool_size = 1 << (PAGE_SHIFT + order),
+  // where 'order' was clamped by min(..., MAX_PAGE_ORDER).
+  if (shiftSafeUnderUpperBounds(L, R, LHSW, C))
     return;

   // Report
@@ -234,7 +518,7 @@   }
 }

-void SAGenTestChecker::checkBind(SVal, SVal, const Stmt *S, CheckerContext &C) const {
+void SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const {
   const auto *BO = dyn_cast_or_null<BinaryOperator>(S);
   if (!BO || !BO->isAssignmentOp())
     return;
@@ -244,8 +528,30 @@   if (!LHS || !RHS)
     return;

+  // First, perform shift-to-wide analysis for assignment context.
   QualType DestTy = LHS->getType();
   analyzeAndReportShiftToWide(RHS, DestTy, C, "assignment");
+
+  // Second, update per-variable upper bounds when possible to help suppress FPs.
+  const auto *DRE = dyn_cast<DeclRefExpr>(peel(LHS));
+  if (!DRE)
+    return;
+  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());
+  if (!VD)
+    return;
+
+  llvm::APSInt BoundLit;
+  if (extractUpperBoundLiteralFromRHS(RHS, C, BoundLit)) {
+    // Store or update with the maximum bound seen.
+    ProgramStateRef State = C.getState();
+    const llvm::APSInt *Cur = State->get<VarUpperBoundMap>(VD);
+    llvm::APSInt NewBound = BoundLit;
+    if (Cur && Cur->ugt(NewBound))
+      NewBound = *Cur;
+    ProgramStateRef NewState = State->set<VarUpperBoundMap>(VD, NewBound);
+    if (NewState != State)
+      C.addTransition(NewState);
+  }
 }

 void SAGenTestChecker::checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const {
@@ -279,9 +585,14 @@     const ParmVarDecl *P = FD->getParamDecl(i);
     if (!P)
       continue;
+
     QualType DestTy = P->getType();
     const Expr *ArgE = Call.getArgExpr(i);
     if (!ArgE)
+      continue;
+
+    ASTContext &ACtx = C.getASTContext();
+    if (!DestTy->isIntegerType() || ACtx.getIntWidth(DestTy) < 64)
       continue;

     analyzeAndReportShiftToWide(ArgE, DestTy, C, "argument");
