### Report Summary

File:| /scratch/chenyuan-data/linux-debug/crypto/ecdh.c
---|---
Warning:| line 60, column 9
Shift done in 32-bit, widened after; cast left operand to 64-bit before <<

### Annotated Source Code


1     | // SPDX-License-Identifier: GPL-2.0-or-later
2     | /* ECDH key-agreement protocol
3     |  *
4     |  * Copyright (c) 2016, Intel Corporation
5     |  * Authors: Salvator Benedetto <salvatore.benedetto@intel.com>
6     |  */
7     |
8     | #include <linux/module.h>
9     | #include <crypto/internal/ecc.h>
10    | #include <crypto/internal/kpp.h>
11    | #include <crypto/kpp.h>
12    | #include <crypto/ecdh.h>
13    | #include <linux/scatterlist.h>
14    |
15    | struct ecdh_ctx {
16    |  unsigned int curve_id;
17    |  unsigned int ndigits;
18    | 	u64 private_key[ECC_MAX_DIGITS];
19    | };
20    |
21    | static inline struct ecdh_ctx *ecdh_get_ctx(struct crypto_kpp *tfm)
22    | {
23    |  return kpp_tfm_ctx(tfm);
24    | }
25    |
26    | static int ecdh_set_secret(struct crypto_kpp *tfm, const void *buf,
27    |  unsigned int len)
28    | {
29    |  struct ecdh_ctx *ctx = ecdh_get_ctx(tfm);
30    |  struct ecdh params;
31    |
32    |  if (crypto_ecdh_decode_key(buf, len, Â¶ms) < 0 ||
33    | 	    params.key_size > sizeof(u64) * ctx->ndigits)
34    |  return -EINVAL;
35    |
36    |  if (!params.key || !params.key_size)
37    |  return ecc_gen_privkey(ctx->curve_id, ctx->ndigits,
38    | 				       ctx->private_key);
39    |
40    |  memcpy(ctx->private_key, params.key, params.key_size);
41    |
42    |  if (ecc_is_key_valid(ctx->curve_id, ctx->ndigits,
43    | 			     ctx->private_key, params.key_size) < 0) {
44    | 		memzero_explicit(ctx->private_key, params.key_size);
45    |  return -EINVAL;
46    | 	}
47    |  return 0;
48    | }
49    |
50    | static int ecdh_compute_value(struct kpp_request *req)
51    | {
52    |  struct crypto_kpp *tfm = crypto_kpp_reqtfm(req);
53    |  struct ecdh_ctx *ctx = ecdh_get_ctx(tfm);
54    | 	u64 *public_key;
55    | 	u64 *shared_secret = NULL;
56    |  void *buf;
57    | 	size_t copied, nbytes, public_key_sz;
58    |  int ret = -ENOMEM;
59    |
60    |  nbytes = ctx->ndigits << ECC_DIGITS_TO_BYTES_SHIFT;
    Shift done in 32-bit, widened after; cast left operand to 64-bit before <<
61    |  /* Public part is a point thus it has both coordinates */
62    | 	public_key_sz = 2 * nbytes;
63    |
64    | 	public_key = kmalloc(public_key_sz, GFP_KERNEL);
65    |  if (!public_key)
66    |  return -ENOMEM;
67    |
68    |  if (req->src) {
69    | 		shared_secret = kmalloc(nbytes, GFP_KERNEL);
70    |  if (!shared_secret)
71    |  goto free_pubkey;
72    |
73    |  /* from here on it's invalid parameters */
74    | 		ret = -EINVAL;
75    |
76    |  /* must have exactly two points to be on the curve */
77    |  if (public_key_sz != req->src_len)
78    |  goto free_all;
79    |
80    | 		copied = sg_copy_to_buffer(req->src,
81    | 					   sg_nents_for_len(req->src,
82    | 							    public_key_sz),
83    | 					   public_key, public_key_sz);
84    |  if (copied != public_key_sz)
85    |  goto free_all;
86    |
87    | 		ret = crypto_ecdh_shared_secret(ctx->curve_id, ctx->ndigits,
88    | 						ctx->private_key, public_key,
89    | 						shared_secret);
90    |
