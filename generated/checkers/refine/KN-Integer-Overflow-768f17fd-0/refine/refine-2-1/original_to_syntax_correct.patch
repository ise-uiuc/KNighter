--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -43,6 +43,9 @@ // Key: VarDecl*, Value: APSInt upper bound (unsigned).
 namespace {
 struct VarUpperBoundMap {};
+// Track exact integer-constant assignments for variables within a function.
+// Key: VarDecl*, Value: exact APSInt value assigned via literal/constant expression.
+struct VarConstMap {};
 }

 namespace clang {
@@ -55,6 +58,15 @@     return &Index;
   }
 };
+
+template <>
+struct ProgramStateTrait<VarConstMap>
+    : public ProgramStatePartialTrait<llvm::ImmutableMap<const VarDecl *, llvm::APSInt>> {
+  static void *GDMIndex() {
+    static int Index;
+    return &Index;
+  }
+};
 } // namespace ento
 } // namespace clang

@@ -103,8 +115,10 @@     return Top == static_cast<const Expr *>(Shl);
   }

-  static bool constantShiftFitsInLHSWidth(const Expr *L, const Expr *R,
-                                          unsigned LHSW, CheckerContext &C) {
+  // Check if constant L and R guarantee that (L << R) fits within OpW bits (the
+  // promoted width of the shift expression).
+  static bool constantShiftFitsInWidth(const Expr *L, const Expr *R,
+                                       unsigned OpW, CheckerContext &C) {
     llvm::APSInt LHSEval, RHSEval;
     if (!EvaluateExprToInt(LHSEval, L, C))
       return false;
@@ -118,7 +132,7 @@     uint64_t ShiftAmt = RHSEval.getZExtValue();
     if (LBits == 0)
       return true;
-    return (uint64_t)LBits + ShiftAmt <= (uint64_t)LHSW;
+    return (uint64_t)LBits + ShiftAmt <= (uint64_t)OpW;
   }

   static bool isAnyLongType(QualType QT) {
@@ -180,7 +194,7 @@         return true;
       }
     }
-       return false;
+    return false;
   }

   static bool isFalsePositiveContext(const Expr *WholeExpr,
@@ -191,6 +205,7 @@     if (!isTopLevelShiftExpr(WholeExpr, Shl))
       return true;

+    // Keep argument-context heuristics.
     if (Ctx == "argument") {
       const CallExpr *CE = nullptr;
       unsigned ArgIdx = 0;
@@ -223,7 +238,6 @@   }

   // Extract a coarse upper bound from an assignment RHS by scanning integer literals.
-  // Intended to capture patterns like min(x, CONST) where CONST is the controlling bound.
   static bool extractUpperBoundLiteralFromRHS(const Expr *RHS, CheckerContext &C,
                                               llvm::APSInt &Out) {
     if (!RHS)
@@ -250,8 +264,6 @@           MaxVal = llvm::APSInt(V, /*isUnsigned=*/true);
         Found = true;
       } else if (const auto *UO = dyn_cast<UnaryOperator>(Cur)) {
-        // Try to handle sizeof-like folds that may appear as integral casts.
-        // We still just traverse.
         if (const Expr *SubE = UO->getSubExpr())
           Worklist.push_back(SubE);
       } else {
@@ -268,7 +280,24 @@     return false;
   }

-  // Get a recorded per-variable upper bound from program state.
+  // Exact constant for variables from program state
+  static bool getRecordedVarExactConst(const Expr *E, CheckerContext &C,
+                                       llvm::APSInt &Out) {
+    const auto *DRE = dyn_cast_or_null<DeclRefExpr>(peel(E));
+    if (!DRE)
+      return false;
+    const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());
+    if (!VD)
+      return false;
+
+    ProgramStateRef State = C.getState();
+    const llvm::APSInt *Stored = State->get<VarConstMap>(VD);
+    if (!Stored)
+      return false;
+    Out = *Stored;
+    return true;
+  }
+
   static bool getRecordedVarUpperBound(const Expr *E, CheckerContext &C,
                                        llvm::APSInt &Out) {
     const auto *DRE = dyn_cast_or_null<DeclRefExpr>(peel(E));
@@ -286,10 +315,7 @@     return true;
   }

-  // Compute an upper bound for an expression based on:
-  // - Exact constant evaluation
-  // - Recorded per-variable upper bounds
-  // - Simple addition of sub-bounds
+  // Compute an upper bound for an expression.
   static bool computeExprUpperBound(const Expr *E, CheckerContext &C,
                                     llvm::APSInt &Out) {
     if (!E)
@@ -302,6 +328,13 @@       if (Val.isSigned() && Val.isNegative())
         return false; // not handling negative bounds here
       Out = Val.extOrTrunc(64);
+      Out.setIsUnsigned(true);
+      return true;
+    }
+
+    // Exact variable constant?
+    if (getRecordedVarExactConst(E, C, Out)) {
+      Out = Out.extOrTrunc(64);
       Out.setIsUnsigned(true);
       return true;
     }
@@ -332,7 +365,7 @@       }
     }

-    // Composite expressions: try L + R for additions
+    // Simple additions
     if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
       if (BO->getOpcode() == BO_Add) {
         llvm::APSInt LUB, RUB;
@@ -348,14 +381,27 @@           return true;
         }
       }
-      // Other ops: give up (conservative)
+      // Optional: handle LHS << RHS when both bounds known
+      if (BO->getOpcode() == BO_Shl) {
+        llvm::APSInt LUB, RUB;
+        if (computeExprUpperBound(BO->getLHS(), C, LUB) &&
+            computeExprUpperBound(BO->getRHS(), C, RUB)) {
+          uint64_t Sh = RUB.getZExtValue();
+          Sh = std::min<uint64_t>(Sh, 63);
+          llvm::APSInt L2 = LUB.extOrTrunc(64);
+          L2.setIsUnsigned(true);
+          llvm::APInt Tmp = static_cast<const llvm::APInt &>(L2);
+          Tmp = Tmp.shl((unsigned)Sh);
+          Out = llvm::APSInt(Tmp, true);
+          return true;
+        }
+      }
     }

     return false;
   }

-  // Compute maximum number of active bits an expression's value can have,
-  // using constants or recorded/symbolic upper bounds.
+  // Compute maximum number of active bits an expression's value can have.
   static bool computeExprMaxActiveBits(const Expr *E, CheckerContext &C,
                                        unsigned &OutBits) {
     if (!E)
@@ -372,7 +418,6 @@
     llvm::APSInt UB;
     if (computeExprUpperBound(E, C, UB)) {
-      // Active bits of the upper bound is an upper bound on the active bits.
       OutBits = UB.getActiveBits();
       return true;
     }
@@ -380,10 +425,79 @@     return false;
   }

-  // Decide if the shift is provably safe within the LHS bitwidth (e.g., 32-bit)
+  // Lightweight "forced-one" bits mask for an expression (64-bit).
+  // Attempts to derive bits that are guaranteed 1, to get a minimum active-bits lower bound.
+  static llvm::APInt computeForcedOneMask(const Expr *E, CheckerContext &C) {
+    E = peel(E);
+    llvm::APInt Zero(64, 0);
+
+    if (!E)
+      return Zero;
+
+    // Integer constant
+    if (const auto *IL = dyn_cast<IntegerLiteral>(E))
+      return IL->getValue().zextOrTrunc(64);
+
+    // Exact variable constant
+    llvm::APSInt Exact;
+    if (getRecordedVarExactConst(E, C, Exact)) {
+      llvm::APSInt E2 = Exact.extOrTrunc(64);
+      E2.setIsUnsigned(true);
+      return static_cast<const llvm::APInt &>(E2);
+    }
+
+    // Implicit/explicit casts, parens
+    if (const auto *CE = dyn_cast<CastExpr>(E))
+      return computeForcedOneMask(CE->getSubExpr(), C);
+
+    if (const auto *PE = dyn_cast<ParenExpr>(E))
+      return computeForcedOneMask(PE->getSubExpr(), C);
+
+    // Binary ops
+    if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+      switch (BO->getOpcode()) {
+      case BO_Or: {
+        llvm::APInt LMask = computeForcedOneMask(BO->getLHS(), C);
+        llvm::APInt RMask = computeForcedOneMask(BO->getRHS(), C);
+        return LMask | RMask;
+      }
+      case BO_Shl: {
+        llvm::APInt LMask = computeForcedOneMask(BO->getLHS(), C);
+        // Need exact shift amount
+        llvm::APSInt ShAmt;
+        if (EvaluateExprToInt(ShAmt, BO->getRHS(), C) ||
+            getRecordedVarExactConst(BO->getRHS(), C, ShAmt)) {
+          uint64_t K = ShAmt.getZExtValue();
+          if (K >= 64)
+            return Zero;
+          return LMask.shl((unsigned)K);
+        }
+        return Zero;
+      }
+      case BO_And: {
+        llvm::APInt LMask = computeForcedOneMask(BO->getLHS(), C);
+        llvm::APSInt RConst;
+        if (EvaluateExprToInt(RConst, BO->getRHS(), C) ||
+            getRecordedVarExactConst(BO->getRHS(), C, RConst)) {
+          llvm::APSInt RC2 = RConst.extOrTrunc(64);
+          RC2.setIsUnsigned(true);
+          llvm::APInt RMask = static_cast<const llvm::APInt &>(RC2);
+          return LMask & RMask;
+        }
+        return Zero;
+      }
+      default:
+        break;
+      }
+    }
+
+    return Zero;
+  }
+
+  // Decide if the shift is provably safe within the operation width (e.g., 32-bit)
   // under computed upper bounds for L and R.
   static bool shiftSafeUnderUpperBounds(const Expr *L, const Expr *R,
-                                        unsigned LHSW, CheckerContext &C) {
+                                        unsigned OpW, CheckerContext &C) {
     unsigned MaxLBits = 0;
     if (!computeExprMaxActiveBits(L, C, MaxLBits))
       return false;
@@ -397,7 +511,52 @@     if (MaxLBits == 0)
       return true;

-    return (uint64_t)MaxLBits + ShiftMax <= (uint64_t)LHSW;
+    return (uint64_t)MaxLBits + ShiftMax <= (uint64_t)OpW;
+  }
+
+  // Small-constant-shift FP filter: suppress when RHS is a tiny constant (<= 5)
+  // and we cannot prove risk from L.
+  static bool smallConstantShiftBenign(const Expr *L, const Expr *R,
+                                       unsigned OpW, CheckerContext &C) {
+    llvm::APSInt RC;
+    if (!(EvaluateExprToInt(RC, R, C)))
+      return false;
+    uint64_t K = RC.getZExtValue();
+    const uint64_t SmallKThreshold = 5;
+    if (K > SmallKThreshold)
+      return false;
+
+    // If L is constant, check exactly.
+    llvm::APSInt LC;
+    if (EvaluateExprToInt(LC, L, C)) {
+      if (LC.isSigned() && LC.isNegative())
+        return false;
+      unsigned LBits = LC.getActiveBits();
+      return (uint64_t)LBits + K <= (uint64_t)OpW;
+    }
+
+    // Use forced-one bits to get a lower bound on L's active bits.
+    llvm::APInt Forced = computeForcedOneMask(L, C);
+    unsigned MinLBits = Forced.getActiveBits();
+    if (MinLBits == 0) {
+      // With no evidence of large L, treat tiny shifts as benign to reduce FP.
+      return true;
+    }
+    // If even the minimum L would overflow with K, do not suppress.
+    return (uint64_t)MinLBits + K <= (uint64_t)OpW;
+  }
+
+  // Update VarConstMap for exact constant assignment
+  static ProgramStateRef setOrClearVarConst(ProgramStateRef State,
+                                            const VarDecl *VD,
+                                            const Expr *RHS,
+                                            CheckerContext &C) {
+    llvm::APSInt Exact;
+    if (EvaluateExprToInt(Exact, RHS, C)) {
+      return State->set<VarConstMap>(VD, Exact);
+    }
+    // Not a constant: clear any existing entry.
+    return State->remove<VarConstMap>(VD);
   }
 };

@@ -463,31 +622,30 @@   if (!ShlTy->isIntegerType())
     return;

-  unsigned ShlW = ACtx.getIntWidth(ShlTy);
-  if (ShlW >= 64)
+  // Width of the shift expression after usual promotions.
+  unsigned OpW = ACtx.getIntWidth(ShlTy);
+  if (OpW >= 64)
     return; // Shift already performed in 64-bit, OK.

   if (!L->getType()->isIntegerType())
     return;

-  unsigned LHSW = ACtx.getIntWidth(L->getType());
-  if (LHSW >= 64)
-    return; // LHS already wide.
-
   if (hasExplicitCastToWide64(L, ACtx))
     return;

   if (isFalsePositiveContext(E, Shl, DestTy, C, Ctx))
     return;

-  // Constant proof: safely fits.
-  if (constantShiftFitsInLHSWidth(L, R, LHSW, C))
-    return;
-
-  // New: Symbolic upper-bound proof: if we can prove the result fits in 32-bit,
-  // suppress. This addresses cases like: pool_size = 1 << (PAGE_SHIFT + order),
-  // where 'order' was clamped by min(..., MAX_PAGE_ORDER).
-  if (shiftSafeUnderUpperBounds(L, R, LHSW, C))
+  // If L and R are constants and fit within OpW, suppress.
+  if (constantShiftFitsInWidth(L, R, OpW, C))
+    return;
+
+  // If using symbolic UB we can prove it fits within OpW, suppress.
+  if (shiftSafeUnderUpperBounds(L, R, OpW, C))
+    return;
+
+  // Suppress tiny constant shifts unless we can prove risk.
+  if (smallConstantShiftBenign(L, R, OpW, C))
     return;

   // Report
@@ -509,12 +667,29 @@     const auto *VD = dyn_cast<VarDecl>(D);
     if (!VD)
       continue;
-    if (!VD->hasInit())
-      continue;
-
-    QualType DestTy = VD->getType();
-    const Expr *Init = VD->getInit();
-    analyzeAndReportShiftToWide(Init, DestTy, C, "initialization");
+
+    if (VD->hasInit()) {
+      QualType DestTy = VD->getType();
+      const Expr *Init = VD->getInit();
+      analyzeAndReportShiftToWide(Init, DestTy, C, "initialization");
+
+      // Update VarConstMap if initializer is a constant.
+      ProgramStateRef State = C.getState();
+      ProgramStateRef NewState = setOrClearVarConst(State, VD, Init, C);
+
+      // Also maintain coarse upper bound map
+      llvm::APSInt BoundLit;
+      if (extractUpperBoundLiteralFromRHS(Init, C, BoundLit)) {
+        const llvm::APSInt *Cur = State->get<VarUpperBoundMap>(VD);
+        llvm::APSInt NewBound = BoundLit;
+        if (Cur && Cur->ugt(NewBound))
+          NewBound = *Cur;
+        NewState = NewState->set<VarUpperBoundMap>(VD, NewBound);
+      }
+
+      if (NewState != State)
+        C.addTransition(NewState);
+    }
   }
 }

@@ -532,7 +707,7 @@   QualType DestTy = LHS->getType();
   analyzeAndReportShiftToWide(RHS, DestTy, C, "assignment");

-  // Second, update per-variable upper bounds when possible to help suppress FPs.
+  // Update per-variable maps.
   const auto *DRE = dyn_cast<DeclRefExpr>(peel(LHS));
   if (!DRE)
     return;
@@ -540,18 +715,20 @@   if (!VD)
     return;

+  ProgramStateRef State = C.getState();
+  ProgramStateRef NewState = setOrClearVarConst(State, VD, RHS, C);
+
   llvm::APSInt BoundLit;
   if (extractUpperBoundLiteralFromRHS(RHS, C, BoundLit)) {
-    // Store or update with the maximum bound seen.
-    ProgramStateRef State = C.getState();
-    const llvm::APSInt *Cur = State->get<VarUpperBoundMap>(VD);
+    const llvm::APSInt *Cur = NewState->get<VarUpperBoundMap>(VD);
     llvm::APSInt NewBound = BoundLit;
     if (Cur && Cur->ugt(NewBound))
       NewBound = *Cur;
-    ProgramStateRef NewState = State->set<VarUpperBoundMap>(VD, NewBound);
-    if (NewState != State)
-      C.addTransition(NewState);
-  }
+    NewState = NewState->set<VarUpperBoundMap>(VD, NewBound);
+  }
+
+  if (NewState != State)
+    C.addTransition(NewState);
 }

 void SAGenTestChecker::checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const {
