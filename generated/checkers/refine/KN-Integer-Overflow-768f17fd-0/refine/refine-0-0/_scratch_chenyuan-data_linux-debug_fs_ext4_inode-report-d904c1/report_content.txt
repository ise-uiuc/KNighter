### Report Summary

File:| /scratch/chenyuan-data/linux-debug/fs/ext4/inode.c
---|---
Warning:| line 357, column 3
Shift done in 32-bit, widened after; cast left operand to 64-bit before <<

### Annotated Source Code


282   |  * Kill off the orphan record which ext4_truncate created.
283   |  * AKPM: I think this can be inside the above `if'.
284   |  * Note that ext4_orphan_del() has to be able to cope with the
285   |  * deletion of a non-existent orphan - this is because we don't
286   |  * know if ext4_truncate() actually created an orphan record.
287   |  * (Well, we could do this if we need to, but heck - it works)
288   |  */
289   | 	ext4_orphan_del(handle, inode);
290   |  EXT4_I(inode)->i_dtime	= (__u32)ktime_get_real_seconds();
291   |
292   |  /*
293   |  * One subtle ordering requirement: if anything has gone wrong
294   |  * (transaction abort, IO errors, whatever), then we can still
295   |  * do these next steps (the fs will already have been marked as
296   |  * having errors), but we can't free the inode if the mark_dirty
297   |  * fails.
298   |  */
299   |  if (ext4_mark_inode_dirty(handle, inode))
300   |  /* If that failed, just do the required in-core inode clear. */
301   | 		ext4_clear_inode(inode);
302   |  else
303   | 		ext4_free_inode(handle, inode);
304   |  ext4_journal_stop(handle);
305   |  if (freeze_protected)
306   | 		sb_end_intwrite(inode->i_sb);
307   | 	ext4_xattr_inode_array_free(ea_inode_array);
308   |  return;
309   | no_delete:
310   |  /*
311   |  * Check out some where else accidentally dirty the evicting inode,
312   |  * which may probably cause inode use-after-free issues later.
313   |  */
314   |  WARN_ON_ONCE(!list_empty_careful(&inode->i_io_list));
315   |
316   |  if (!list_empty(&EXT4_I(inode)->i_fc_list))
317   | 		ext4_fc_mark_ineligible(inode->i_sb, EXT4_FC_REASON_NOMEM, NULL);
318   | 	ext4_clear_inode(inode);	/* We must guarantee clearing of inode... */
319   | }
320   |
321   | #ifdef CONFIG_QUOTA
322   | qsize_t *ext4_get_reserved_space(struct inode *inode)
323   | {
324   |  return &EXT4_I(inode)->i_reserved_quota;
325   | }
326   | #endif
327   |
328   | /*
329   |  * Called with i_data_sem down, which is important since we can call
330   |  * ext4_discard_preallocations() from here.
331   |  */
332   | void ext4_da_update_reserve_space(struct inode *inode,
333   |  int used, int quota_claim)
334   | {
335   |  struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
336   |  struct ext4_inode_info *ei = EXT4_I(inode);
337   |
338   | 	spin_lock(&ei->i_block_reservation_lock);
339   | 	trace_ext4_da_update_reserve_space(inode, used, quota_claim);
340   |  if (unlikely(used > ei->i_reserved_data_blocks)) {
    1Assuming 'used' is <= field 'i_reserved_data_blocks'→
    2←Taking false branch→
341   |  ext4_warning(inode->i_sb, "%s: ino %lu, used %d "
342   |  "with only %d reserved data blocks",
343   |  __func__, inode->i_ino, used,
344   |  ei->i_reserved_data_blocks);
345   |  WARN_ON(1);
346   | 		used = ei->i_reserved_data_blocks;
347   | 	}
348   |
349   |  /* Update per-inode reservations */
350   |  ei->i_reserved_data_blocks -= used;
351   | 	percpu_counter_sub(&sbi->s_dirtyclusters_counter, used);
352   |
353   | 	spin_unlock(&ei->i_block_reservation_lock);
354   |
355   |  /* Update quota subsystem for data blocks */
356   |  if (quota_claim)
    3←Assuming 'quota_claim' is not equal to 0→
    4←Taking true branch→
357   |  dquot_claim_block(inode, EXT4_C2B(sbi, used));
    5←Assuming right operand of bit shift is less than 32→
    6←Shift done in 32-bit, widened after; cast left operand to 64-bit before <<
358   |  else {
359   |  /*
360   |  * We did fallocate with an offset that is already delayed
361   |  * allocated. So on delayed allocated writeback we should
362   |  * not re-claim the quota for fallocated blocks.
363   |  */
364   | 		dquot_release_reservation_block(inode, EXT4_C2B(sbi, used));
365   | 	}
366   |
367   |  /*
368   |  * If we have done all the pending block allocations and if
369   |  * there aren't any writers on the inode, we can discard the
370   |  * inode's preallocations.
371   |  */
372   |  if ((ei->i_reserved_data_blocks == 0) &&
373   | 	    !inode_is_open_for_write(inode))
374   | 		ext4_discard_preallocations(inode);
375   | }
376   |
377   | static int __check_block_validity(struct inode *inode, const char *func,
378   |  unsigned int line,
379   |  struct ext4_map_blocks *map)
380   | {
381   |  if (ext4_has_feature_journal(inode->i_sb) &&
382   | 	    (inode->i_ino ==
383   |  le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
384   |  return 0;
385   |  if (!ext4_inode_block_valid(inode, map->m_pblk, map->m_len)) {
386   |  ext4_error_inode(inode, func, line, map->m_pblk,
387   |  "lblock %lu mapped to illegal pblock %llu "
