--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -15,7 +15,10 @@ #include "clang/StaticAnalyzer/Checkers/utility.h"
 #include "clang/AST/Expr.h"
 #include "clang/AST/ExprCXX.h"
+#include "clang/AST/Type.h"
 #include "llvm/ADT/StringRef.h"
+#include <algorithm>
+#include <cctype>

 using namespace clang;
 using namespace ento;
@@ -100,13 +103,118 @@     return (uint64_t)LBits + ShiftAmt <= (uint64_t)LHSW;
   }

-  // Centralized FP gate
+  // New: return true if type is a "long" (signed or unsigned).
+  static bool isAnyLongType(QualType QT) {
+    return QT->isSpecificBuiltinType(BuiltinType::Long) ||
+           QT->isSpecificBuiltinType(BuiltinType::ULong);
+  }
+
+  // New: return true if type is a fixed 64-bit builtin (long long or unsigned long long).
+  static bool isFixed64Builtin(QualType QT) {
+    return QT->isSpecificBuiltinType(BuiltinType::LongLong) ||
+           QT->isSpecificBuiltinType(BuiltinType::ULongLong);
+  }
+
+  // New: determine if a function name looks like I/O or register access
+  static bool calleeNameLooksLikeIOOrReg(StringRef Name) {
+    // Heuristics commonly seen in low-level code: read/write/peek/poke/io/in/out/reg
+    // Lowercase for robust matching.
+    llvm::SmallString<64> Lower(Name);
+    for (char &c : Lower)
+      c = static_cast<char>(tolower(static_cast<unsigned char>(c)));
+    StringRef S(Lower);
+    return S.contains("read") || S.contains("write") || S.contains("peek") ||
+           S.contains("poke") || S.contains("in") || S.contains("out") ||
+           S.contains("io") || S.contains("reg");
+  }
+
+  // New: determine if parameter name suggests address/offset/register
+  static bool paramNameLooksLikeAddrOffset(const ParmVarDecl *P) {
+    if (!P)
+      return false;
+    StringRef N = P->getName();
+    if (N.empty())
+      return false;
+
+    llvm::SmallString<64> Lower(N);
+    for (char &c : Lower)
+      c = static_cast<char>(tolower(static_cast<unsigned char>(c)));
+    StringRef S(Lower);
+    return S.contains("addr") || S.contains("address") || S.contains("offset") ||
+           S.contains("ofs") || S.contains("reg") || S.contains("index") ||
+           S.contains("port") || S.contains("bar");
+  }
+
+  // New: Evaluate RHS constant shift amount if any
+  static bool tryGetConstShiftAmount(const Expr *R, CheckerContext &C, uint64_t &Out) {
+    llvm::APSInt RHSEval;
+    if (!EvaluateExprToInt(RHSEval, R, C))
+      return false;
+    Out = RHSEval.getZExtValue();
+    return true;
+  }
+
+  // Helper: find the CallExpr parent and argument index for an expression E.
+  static bool findCallParentAndArgIndex(const Expr *E, CheckerContext &C,
+                                        const CallExpr *&OutCE, unsigned &OutIdx) {
+    OutCE = findSpecificTypeInParents<CallExpr>(E, C);
+    if (!OutCE)
+      return false;
+
+    const Expr *PE = peel(E);
+    unsigned ArgCount = OutCE->getNumArgs();
+    for (unsigned i = 0; i < ArgCount; ++i) {
+      const Expr *AE = OutCE->getArg(i);
+      if (peel(AE) == PE) {
+        OutIdx = i;
+        return true;
+      }
+    }
+    return false;
+  }
+
+  // Centralized FP gate. Now with call-argument heuristics.
   static bool isFalsePositiveContext(const Expr *WholeExpr,
                                      const BinaryOperator *Shl,
-                                     CheckerContext &C) {
+                                     QualType DestTy,
+                                     CheckerContext &C,
+                                     StringRef Ctx) {
     // Suppress if the shift isn't the top-level expression being assigned/returned/passed.
     if (!isTopLevelShiftExpr(WholeExpr, Shl))
       return true;
+
+    // Additional filtering only for call-argument contexts.
+    if (Ctx == "argument") {
+      const CallExpr *CE = nullptr;
+      unsigned ArgIdx = 0;
+      if (findCallParentAndArgIndex(WholeExpr, C, CE, ArgIdx)) {
+        const FunctionDecl *FD = CE->getDirectCallee();
+        const ParmVarDecl *PVD = nullptr;
+        if (FD && ArgIdx < FD->getNumParams())
+          PVD = FD->getParamDecl(ArgIdx);
+
+        // If destination type is a 'long' (LP64 64-bit), suppress: often address/offset.
+        if (isAnyLongType(DestTy))
+          return true;
+
+        // If parameter name looks like address/offset/register, suppress.
+        if (PVD && paramNameLooksLikeAddrOffset(PVD))
+          return true;
+
+        // If callee name suggests register/I/O helpers, suppress.
+        if (FD) {
+          if (const IdentifierInfo *ID = FD->getIdentifier()) {
+            if (calleeNameLooksLikeIOOrReg(ID->getName()))
+              return true;
+          }
+        }
+
+        // Small constant shifts (<= 3) in arguments are typically word/byte conversions.
+        uint64_t K = 0;
+        if (tryGetConstShiftAmount(Shl->getRHS(), C, K) && K <= 3)
+          return true;
+      }
+    }

     return false;
   }
@@ -156,7 +264,7 @@ }

 void SAGenTestChecker::analyzeAndReportShiftToWide(const Expr *E, QualType DestTy,
-                                                   CheckerContext &C, StringRef) const {
+                                                   CheckerContext &C, StringRef Ctx) const {
   if (!E)
     return;

@@ -198,8 +306,8 @@   if (hasExplicitCastToWide64(L, ACtx))
     return;

-  // Suppress known false-positive contexts.
-  if (isFalsePositiveContext(E, Shl, C))
+  // Suppress known false-positive contexts (not top-level or filtered call-argument cases).
+  if (isFalsePositiveContext(E, Shl, DestTy, C, Ctx))
     return;

   // Precise constant-bound suppression: only if both sides are constants and safe.
@@ -279,9 +387,15 @@     const ParmVarDecl *P = FD->getParamDecl(i);
     if (!P)
       continue;
+
     QualType DestTy = P->getType();
     const Expr *ArgE = Call.getArgExpr(i);
     if (!ArgE)
+      continue;
+
+    // Only analyze arguments with integer destination types of width >= 64.
+    ASTContext &ACtx = C.getASTContext();
+    if (!DestTy->isIntegerType() || ACtx.getIntWidth(DestTy) < 64)
       continue;

     analyzeAndReportShiftToWide(ArgE, DestTy, C, "argument");
