--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -17,8 +17,10 @@ #include "clang/AST/ExprCXX.h"
 #include "clang/AST/Type.h"
 #include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/ImmutableMap.h"
 #include <algorithm>
 #include <cctype>
+#include <optional>

 using namespace clang;
 using namespace ento;
@@ -37,6 +39,25 @@ bool functionKnownToDeref(const CallEvent &Call, llvm::SmallVectorImpl<unsigned> &DerefParams);
 bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C);

+// Track per-variable coarse upper bounds learned from assignments.
+// Key: VarDecl*, Value: APSInt upper bound (unsigned).
+namespace {
+struct VarUpperBoundMap {};
+}
+
+namespace clang {
+namespace ento {
+template <>
+struct ProgramStateTrait<VarUpperBoundMap>
+    : public ProgramStatePartialTrait<llvm::ImmutableMap<const VarDecl *, llvm::APSInt>> {
+  static void *GDMIndex() {
+    static int Index;
+    return &Index;
+  }
+};
+} // namespace ento
+} // namespace clang
+
 namespace {

 class SAGenTestChecker
@@ -63,12 +84,18 @@   static const BinaryOperator *findShiftInTree(const Stmt *S);
   static bool hasExplicitCastToWide64(const Expr *E, ASTContext &ACtx);

-  // Helpers to refine and reduce false positives.
   static const Expr *peel(const Expr *E) {
     return E ? E->IgnoreParenImpCasts() : nullptr;
   }

-  // Report only if the shift is the top-level expression reaching the 64-bit destination.
+  static const BinaryOperator *asShift(const Stmt *S) {
+    if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S)) {
+      if (BO->getOpcode() == BO_Shl)
+        return BO;
+    }
+    return nullptr;
+  }
+
   static bool isTopLevelShiftExpr(const Expr *ContainerE, const BinaryOperator *Shl) {
     if (!ContainerE || !Shl)
       return false;
@@ -76,8 +103,6 @@     return Top == static_cast<const Expr *>(Shl);
   }

-  // Precise constant-safety check: if both LHS and RHS are constant and the result
-  // provably fits into the LHS bitwidth, we suppress.
   static bool constantShiftFitsInLHSWidth(const Expr *L, const Expr *R,
                                           unsigned LHSW, CheckerContext &C) {
     llvm::APSInt LHSEval, RHSEval;
@@ -86,39 +111,27 @@     if (!EvaluateExprToInt(RHSEval, R, C))
       return false;

-    // Be conservative for negative LHS.
     if (LHSEval.isSigned() && LHSEval.isNegative())
       return false;

-    // Active bits of the non-negative LHS.
-    unsigned LBits = LHSEval.getActiveBits(); // 0 if value == 0
+    unsigned LBits = LHSEval.getActiveBits();
     uint64_t ShiftAmt = RHSEval.getZExtValue();
-
-    // Safe if highest set bit after shifting still fits in LHS width.
-    // LBits == 0 is always safe (0 << n == 0).
     if (LBits == 0)
       return true;
-
-    // Example: a 32-bit LHS can hold results where (LBits + ShiftAmt) <= 32.
     return (uint64_t)LBits + ShiftAmt <= (uint64_t)LHSW;
   }

-  // New: return true if type is a "long" (signed or unsigned).
   static bool isAnyLongType(QualType QT) {
     return QT->isSpecificBuiltinType(BuiltinType::Long) ||
            QT->isSpecificBuiltinType(BuiltinType::ULong);
   }

-  // New: return true if type is a fixed 64-bit builtin (long long or unsigned long long).
   static bool isFixed64Builtin(QualType QT) {
     return QT->isSpecificBuiltinType(BuiltinType::LongLong) ||
            QT->isSpecificBuiltinType(BuiltinType::ULongLong);
   }

-  // New: determine if a function name looks like I/O or register access
   static bool calleeNameLooksLikeIOOrReg(StringRef Name) {
-    // Heuristics commonly seen in low-level code: read/write/peek/poke/io/in/out/reg
-    // Lowercase for robust matching.
     llvm::SmallString<64> Lower(Name);
     for (char &c : Lower)
       c = static_cast<char>(tolower(static_cast<unsigned char>(c)));
@@ -128,7 +141,6 @@            S.contains("io") || S.contains("reg");
   }

-  // New: determine if parameter name suggests address/offset/register
   static bool paramNameLooksLikeAddrOffset(const ParmVarDecl *P) {
     if (!P)
       return false;
@@ -145,7 +157,6 @@            S.contains("port") || S.contains("bar");
   }

-  // New: Evaluate RHS constant shift amount if any
   static bool tryGetConstShiftAmount(const Expr *R, CheckerContext &C, uint64_t &Out) {
     llvm::APSInt RHSEval;
     if (!EvaluateExprToInt(RHSEval, R, C))
@@ -154,7 +165,6 @@     return true;
   }

-  // Helper: find the CallExpr parent and argument index for an expression E.
   static bool findCallParentAndArgIndex(const Expr *E, CheckerContext &C,
                                         const CallExpr *&OutCE, unsigned &OutIdx) {
     OutCE = findSpecificTypeInParents<CallExpr>(E, C);
@@ -170,20 +180,17 @@         return true;
       }
     }
-    return false;
-  }
-
-  // Centralized FP gate. Now with call-argument heuristics.
+       return false;
+  }
+
   static bool isFalsePositiveContext(const Expr *WholeExpr,
                                      const BinaryOperator *Shl,
                                      QualType DestTy,
                                      CheckerContext &C,
                                      StringRef Ctx) {
-    // Suppress if the shift isn't the top-level expression being assigned/returned/passed.
     if (!isTopLevelShiftExpr(WholeExpr, Shl))
       return true;

-    // Additional filtering only for call-argument contexts.
     if (Ctx == "argument") {
       const CallExpr *CE = nullptr;
       unsigned ArgIdx = 0;
@@ -193,15 +200,12 @@         if (FD && ArgIdx < FD->getNumParams())
           PVD = FD->getParamDecl(ArgIdx);

-        // If destination type is a 'long' (LP64 64-bit), suppress: often address/offset.
         if (isAnyLongType(DestTy))
           return true;

-        // If parameter name looks like address/offset/register, suppress.
         if (PVD && paramNameLooksLikeAddrOffset(PVD))
           return true;

-        // If callee name suggests register/I/O helpers, suppress.
         if (FD) {
           if (const IdentifierInfo *ID = FD->getIdentifier()) {
             if (calleeNameLooksLikeIOOrReg(ID->getName()))
@@ -209,7 +213,6 @@           }
         }

-        // Small constant shifts (<= 3) in arguments are typically word/byte conversions.
         uint64_t K = 0;
         if (tryGetConstShiftAmount(Shl->getRHS(), C, K) && K <= 3)
           return true;
@@ -218,15 +221,185 @@
     return false;
   }
+
+  // Extract a coarse upper bound from an assignment RHS by scanning integer literals.
+  // Intended to capture patterns like min(x, CONST) where CONST is the controlling bound.
+  static bool extractUpperBoundLiteralFromRHS(const Expr *RHS, CheckerContext &C,
+                                              llvm::APSInt &Out) {
+    if (!RHS)
+      return false;
+
+    // Walk the subtree, find the maximum integer literal value.
+    llvm::APSInt MaxVal(64, true); // unsigned
+    bool Found = false;
+
+    llvm::SmallVector<const Stmt *, 16> Worklist;
+    Worklist.push_back(RHS);
+    while (!Worklist.empty()) {
+      const Stmt *Cur = Worklist.pop_back_val();
+      if (!Cur) continue;
+
+      if (const auto *IL = dyn_cast<IntegerLiteral>(Cur)) {
+        llvm::APInt V = IL->getValue();
+        if (!Found || V.ugt(MaxVal))
+          MaxVal = llvm::APSInt(V, /*isUnsigned=*/true);
+        Found = true;
+      } else if (const auto *CharL = dyn_cast<CharacterLiteral>(Cur)) {
+        llvm::APInt V(64, CharL->getValue());
+        if (!Found || V.ugt(MaxVal))
+          MaxVal = llvm::APSInt(V, /*isUnsigned=*/true);
+        Found = true;
+      } else if (const auto *UO = dyn_cast<UnaryOperator>(Cur)) {
+        // Try to handle sizeof-like folds that may appear as integral casts.
+        // We still just traverse.
+        if (const Expr *SubE = UO->getSubExpr())
+          Worklist.push_back(SubE);
+      } else {
+        for (const Stmt *Child : Cur->children())
+          if (Child)
+            Worklist.push_back(Child);
+      }
+    }
+
+    if (Found) {
+      Out = MaxVal;
+      return true;
+    }
+    return false;
+  }
+
+  // Get a recorded per-variable upper bound from program state.
+  static bool getRecordedVarUpperBound(const Expr *E, CheckerContext &C,
+                                       llvm::APSInt &Out) {
+    const auto *DRE = dyn_cast_or_null<DeclRefExpr>(peel(E));
+    if (!DRE)
+      return false;
+    const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());
+    if (!VD)
+      return false;
+
+    ProgramStateRef State = C.getState();
+    const llvm::APSInt *Stored = State->get<VarUpperBoundMap>(VD);
+    if (!Stored)
+      return false;
+    Out = *Stored;
+    return true;
+  }
+
+  // Compute an upper bound for an expression based on:
+  // - Exact constant evaluation
+  // - Recorded per-variable upper bounds
+  // - Simple addition of sub-bounds
+  static bool computeExprUpperBound(const Expr *E, CheckerContext &C,
+                                    llvm::APSInt &Out) {
+    if (!E)
+      return false;
+    E = peel(E);
+
+    // Constant?
+    llvm::APSInt Val;
+    if (EvaluateExprToInt(Val, E, C)) {
+      if (Val.isSigned() && Val.isNegative())
+        return false; // not handling negative bounds here
+      Out = Val.extOrTrunc(64);
+      Out.setIsUnsigned(true);
+      return true;
+    }
+
+    // Variable with recorded bound?
+    if (getRecordedVarUpperBound(E, C, Out))
+      return true;
+
+    // Symbolic? Try constraint manager max.
+    ProgramStateRef State = C.getState();
+    SVal SV = State->getSVal(E, C.getLocationContext());
+    if (std::optional<nonloc::ConcreteInt> CI = SV.getAs<nonloc::ConcreteInt>()) {
+      llvm::APSInt CIVal = CI->getValue();
+      if (CIVal.isSigned() && CIVal.isNegative())
+        return false;
+      Out = CIVal.extOrTrunc(64);
+      Out.setIsUnsigned(true);
+      return true;
+    }
+    if (SymbolRef Sym = SV.getAsSymbol()) {
+      if (const llvm::APSInt *Max = inferSymbolMaxVal(Sym, C)) {
+        llvm::APSInt M = *Max;
+        if (M.isSigned() && M.isNegative())
+          return false;
+        Out = M.extOrTrunc(64);
+        Out.setIsUnsigned(true);
+        return true;
+      }
+    }
+
+    // Composite expressions: try L + R for additions
+    if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+      if (BO->getOpcode() == BO_Add) {
+        llvm::APSInt LUB, RUB;
+        if (computeExprUpperBound(BO->getLHS(), C, LUB) &&
+            computeExprUpperBound(BO->getRHS(), C, RUB)) {
+          unsigned BW = std::max(LUB.getBitWidth(), RUB.getBitWidth());
+          llvm::APSInt L2 = LUB.extOrTrunc(BW);
+          llvm::APSInt R2 = RUB.extOrTrunc(BW);
+          L2.setIsUnsigned(true);
+          R2.setIsUnsigned(true);
+          Out = L2 + R2;
+          Out.setIsUnsigned(true);
+          return true;
+        }
+      }
+      // Other ops: give up (conservative)
+    }
+
+    return false;
+  }
+
+  // Compute maximum number of active bits an expression's value can have,
+  // using constants or recorded/symbolic upper bounds.
+  static bool computeExprMaxActiveBits(const Expr *E, CheckerContext &C,
+                                       unsigned &OutBits) {
+    if (!E)
+      return false;
+    E = peel(E);
+
+    llvm::APSInt Val;
+    if (EvaluateExprToInt(Val, E, C)) {
+      if (Val.isSigned() && Val.isNegative())
+        return false;
+      OutBits = Val.getActiveBits();
+      return true;
+    }
+
+    llvm::APSInt UB;
+    if (computeExprUpperBound(E, C, UB)) {
+      // Active bits of the upper bound is an upper bound on the active bits.
+      OutBits = UB.getActiveBits();
+      return true;
+    }
+
+    return false;
+  }
+
+  // Decide if the shift is provably safe within the LHS bitwidth (e.g., 32-bit)
+  // under computed upper bounds for L and R.
+  static bool shiftSafeUnderUpperBounds(const Expr *L, const Expr *R,
+                                        unsigned LHSW, CheckerContext &C) {
+    unsigned MaxLBits = 0;
+    if (!computeExprMaxActiveBits(L, C, MaxLBits))
+      return false;
+
+    llvm::APSInt RMax;
+    if (!computeExprUpperBound(R, C, RMax))
+      return false;
+
+    uint64_t ShiftMax = RMax.getZExtValue();
+
+    if (MaxLBits == 0)
+      return true;
+
+    return (uint64_t)MaxLBits + ShiftMax <= (uint64_t)LHSW;
+  }
 };
-
-static const BinaryOperator *asShift(const Stmt *S) {
-  if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S)) {
-    if (BO->getOpcode() == BO_Shl)
-      return BO;
-  }
-  return nullptr;
-}

 const BinaryOperator *SAGenTestChecker::findShiftInTree(const Stmt *S) {
   if (!S)
@@ -294,24 +467,27 @@   if (ShlW >= 64)
     return; // Shift already performed in 64-bit, OK.

-  // LHS must be integer and narrower than 64.
   if (!L->getType()->isIntegerType())
     return;

   unsigned LHSW = ACtx.getIntWidth(L->getType());
   if (LHSW >= 64)
-    return; // LHS is already wide enough.
-
-  // If there is an explicit cast to >=64-bit within the LHS subtree, suppress.
+    return; // LHS already wide.
+
   if (hasExplicitCastToWide64(L, ACtx))
     return;

-  // Suppress known false-positive contexts (not top-level or filtered call-argument cases).
   if (isFalsePositiveContext(E, Shl, DestTy, C, Ctx))
     return;

-  // Precise constant-bound suppression: only if both sides are constants and safe.
+  // Constant proof: safely fits.
   if (constantShiftFitsInLHSWidth(L, R, LHSW, C))
+    return;
+
+  // New: Symbolic upper-bound proof: if we can prove the result fits in 32-bit,
+  // suppress. This addresses cases like: pool_size = 1 << (PAGE_SHIFT + order),
+  // where 'order' was clamped by min(..., MAX_PAGE_ORDER).
+  if (shiftSafeUnderUpperBounds(L, R, LHSW, C))
     return;

   // Report
@@ -342,7 +518,7 @@   }
 }

-void SAGenTestChecker::checkBind(SVal, SVal, const Stmt *S, CheckerContext &C) const {
+void SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const {
   const auto *BO = dyn_cast_or_null<BinaryOperator>(S);
   if (!BO || !BO->isAssignmentOp())
     return;
@@ -352,8 +528,30 @@   if (!LHS || !RHS)
     return;

+  // First, perform shift-to-wide analysis for assignment context.
   QualType DestTy = LHS->getType();
   analyzeAndReportShiftToWide(RHS, DestTy, C, "assignment");
+
+  // Second, update per-variable upper bounds when possible to help suppress FPs.
+  const auto *DRE = dyn_cast<DeclRefExpr>(peel(LHS));
+  if (!DRE)
+    return;
+  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());
+  if (!VD)
+    return;
+
+  llvm::APSInt BoundLit;
+  if (extractUpperBoundLiteralFromRHS(RHS, C, BoundLit)) {
+    // Store or update with the maximum bound seen.
+    ProgramStateRef State = C.getState();
+    const llvm::APSInt *Cur = State->get<VarUpperBoundMap>(VD);
+    llvm::APSInt NewBound = BoundLit;
+    if (Cur && Cur->ugt(NewBound))
+      NewBound = *Cur;
+    ProgramStateRef NewState = State->set<VarUpperBoundMap>(VD, NewBound);
+    if (NewState != State)
+      C.addTransition(NewState);
+  }
 }

 void SAGenTestChecker::checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const {
@@ -393,7 +591,6 @@     if (!ArgE)
       continue;

-    // Only analyze arguments with integer destination types of width >= 64.
     ASTContext &ACtx = C.getASTContext();
     if (!DestTy->isIntegerType() || ACtx.getIntWidth(DestTy) < 64)
       continue;
