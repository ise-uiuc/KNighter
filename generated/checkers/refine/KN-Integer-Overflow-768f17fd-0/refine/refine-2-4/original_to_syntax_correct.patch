--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -799,6 +799,72 @@     return false;
   }

+  // New: check if RHS looks like PAGE_SHIFT and LHS looks like a page/entry count.
+  static bool isPageShiftExpr(const Expr *R, CheckerContext &C) {
+    if (!R) return false;
+    // Prefer direct textual match to avoid matching generic constants unrelated to pages.
+    if (ExprHasName(R, "PAGE_SHIFT", C))
+      return true;
+
+    // Sometimes PAGE_SHIFT folds to an integer constant. Restrict to common ranges [9..16]
+    // but only if the original text still contains PAGE_SHIFT to avoid over-suppression.
+    // If text isn't available, don't assume page-shift based only on value.
+    llvm::APSInt K;
+    if (EvaluateExprToInt(K, R, C)) {
+      uint64_t V = K.getZExtValue();
+      if (V >= 9 && V <= 16 && ExprHasName(R, "PAGE_SHIFT", C))
+        return true;
+    }
+    return false;
+  }
+
+  static bool nameLooksLikePageCountOrEntries(const Expr *L, CheckerContext &C) {
+    if (!L) return false;
+    // Use source text substring matching to catch patterns like "gtt_mappable_entries",
+    // "total_entries", "nr_pages", "npages", etc.
+    return ExprHasName(L, "entries", C) ||
+           ExprHasName(L, "entry", C)   || // e.g., gtt_total_entry_count
+           ExprHasName(L, "pages", C)   ||
+           ExprHasName(L, "npages", C)  ||
+           ExprHasName(L, "nr_pages", C)||
+           ExprHasName(L, "page_count", C) ||
+           ExprHasName(L, "n_pages", C);
+  }
+
+  // New: Targeted false-positive filter for PAGE_SHIFT conversions of page counts.
+  // Suppress when:
+  //  - RHS is PAGE_SHIFT (textual),
+  //  - LHS name suggests a page/entry count,
+  //  - and we don't have a precise (expression-derived) upper bound for LHS
+  //    other than generic symbolic/type constraints.
+  static bool isFalsePositive_PageCountToBytes(const Expr *L, const Expr *R,
+                                               unsigned OpW, QualType DestTy,
+                                               CheckerContext &C) {
+    if (!isPageShiftExpr(R, C))
+      return false;
+    if (!nameLooksLikePageCountOrEntries(L, C))
+      return false;
+
+    // If we can prove safety under upper bounds, suppress anyway.
+    if (shiftSafeUnderUpperBounds(L, R, OpW, C))
+      return true;
+
+    // If we only have a generic symbolic upper bound (e.g., type max) for LHS (or no UB),
+    // treat this as a benign PAGE_SHIFT conversion of a bounded page count and suppress.
+    llvm::APSInt LUB;
+    UpperBoundOrigin LOrigin = UBO_None;
+    bool HaveLUB = computeExprUpperBoundEx(L, C, LUB, LOrigin);
+    if (!HaveLUB)
+      return true;
+    // If UB is derived purely from the state (i.e., not from expression structure or literals),
+    // assume it's a generic type-bound and suppress.
+    if (LOrigin == UBO_FromState)
+      return true;
+
+    // Otherwise, do not suppress (we might have precise info coming from expression structure).
+    return false;
+  }
+
   // Update VarConstMap for exact constant assignment
   static ProgramStateRef setOrClearVarConst(ProgramStateRef State,
                                             const VarDecl *VD,
@@ -897,6 +963,10 @@   if (bitfieldConstShiftSafe(L, R, OpW, C))
     return;

+  // New targeted FP filter: PAGE_SHIFT conversion of page counts (e.g., entries << PAGE_SHIFT).
+  if (isFalsePositive_PageCountToBytes(L, R, OpW, DestTy, C))
+    return;
+
   // Compute provable risk using upper bounds.
   // 1) Compute maximum active bits for L.
   unsigned MaxLBits = 0;
