### Report Summary

File:| /scratch/chenyuan-data/linux-debug/mm/compaction.c
---|---
Warning:| line 1880, column 7
Shift done in 32-bit, widened after; cast left operand to 64-bit before <<

### Annotated Source Code


1804  |
1805  |  /* Found a block suitable for isolating free pages from. */
1806  | 		nr_isolated = isolate_freepages_block(cc, &isolate_start_pfn,
1807  | 					block_end_pfn, cc->freepages, stride, false);
1808  |
1809  |  /* Update the skip hint if the full pageblock was scanned */
1810  |  if (isolate_start_pfn == block_end_pfn)
1811  | 			update_pageblock_skip(cc, page, block_start_pfn -
1812  |  pageblock_nr_pages);
1813  |
1814  |  /* Are enough freepages isolated? */
1815  |  if (cc->nr_freepages >= cc->nr_migratepages) {
1816  |  if (isolate_start_pfn >= block_end_pfn) {
1817  |  /*
1818  |  * Restart at previous pageblock if more
1819  |  * freepages can be isolated next time.
1820  |  */
1821  | 				isolate_start_pfn =
1822  | 					block_start_pfn - pageblock_nr_pages;
1823  | 			}
1824  |  break;
1825  | 		} else if (isolate_start_pfn < block_end_pfn) {
1826  |  /*
1827  |  * If isolation failed early, do not continue
1828  |  * needlessly.
1829  |  */
1830  |  break;
1831  | 		}
1832  |
1833  |  /* Adjust stride depending on isolation */
1834  |  if (nr_isolated) {
1835  | 			stride = 1;
1836  |  continue;
1837  | 		}
1838  | 		stride = min_t(unsigned int, COMPACT_CLUSTER_MAX, stride << 1);
1839  | 	}
1840  |
1841  |  /*
1842  |  * Record where the free scanner will restart next time. Either we
1843  |  * broke from the loop and set isolate_start_pfn based on the last
1844  |  * call to isolate_freepages_block(), or we met the migration scanner
1845  |  * and the loop terminated due to isolate_start_pfn < low_pfn
1846  |  */
1847  | 	cc->free_pfn = isolate_start_pfn;
1848  | }
1849  |
1850  | /*
1851  |  * This is a migrate-callback that "allocates" freepages by taking pages
1852  |  * from the isolated freelists in the block we are migrating to.
1853  |  */
1854  | static struct folio *compaction_alloc(struct folio *src, unsigned long data)
1855  | {
1856  |  struct compact_control *cc = (struct compact_control *)data;
1857  |  struct folio *dst;
1858  |  int order = folio_order(src);
1859  | 	bool has_isolated_pages = false;
1860  |  int start_order;
1861  |  struct page *freepage;
1862  |  unsigned long size;
1863  |
1864  | again:
1865  |  for (start_order = order; start_order < NR_PAGE_ORDERS; start_order++)
    1Assuming the condition is false→
    2←Loop condition is false. Execution continues on line 1870→
1866  |  if (!list_empty(&cc->freepages[start_order]))
1867  |  break;
1868  |
1869  |  /* no free pages in the list */
1870  |  if (start_order == NR_PAGE_ORDERS) {
    3←Assuming the condition is false→
    4←Taking false branch→
1871  |  if (has_isolated_pages)
1872  |  return NULL;
1873  | 		isolate_freepages(cc);
1874  | 		has_isolated_pages = true;
1875  |  goto again;
1876  | 	}
1877  |
1878  | 	freepage = list_first_entry(&cc->freepages[start_order], struct page,
1879  |  lru);
1880  |  size = 1 << start_order;
    5←Assuming right operand of bit shift is less than 32→
    6←Shift done in 32-bit, widened after; cast left operand to 64-bit before <<
1881  |
1882  | 	list_del(&freepage->lru);
1883  |
1884  |  while (start_order > order) {
1885  | 		start_order--;
1886  | 		size >>= 1;
1887  |
1888  | 		list_add(&freepage[size].lru, &cc->freepages[start_order]);
1889  | 		set_page_private(&freepage[size], start_order);
1890  | 	}
1891  | 	dst = (struct folio *)freepage;
1892  |
1893  | 	post_alloc_hook(&dst->page, order, __GFP_MOVABLE);
1894  |  if (order)
1895  | 		prep_compound_page(&dst->page, order);
1896  | 	cc->nr_freepages -= 1 << order;
1897  | 	cc->nr_migratepages -= 1 << order;
1898  |  return page_rmappable_folio(&dst->page);
1899  | }
1900  |
1901  | /*
1902  |  * This is a migrate-callback that "frees" freepages back to the isolated
1903  |  * freelist.  All pages on the freelist are from the same zone, so there is no
1904  |  * special handling needed for NUMA.
1905  |  */
1906  | static void compaction_free(struct folio *dst, unsigned long data)
1907  | {
1908  |  struct compact_control *cc = (struct compact_control *)data;
1909  |  int order = folio_order(dst);
1910  |  struct page *page = &dst->page;
