--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -339,6 +339,21 @@     return false;
   }

+  // Helper: bitfield info for MemberExpr
+  static bool getBitfieldInfo(const Expr *E, CheckerContext &C,
+                              unsigned &Width, bool &IsUnsigned) {
+    E = peel(E);
+    const auto *ME = dyn_cast_or_null<MemberExpr>(E);
+    if (!ME)
+      return false;
+    const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());
+    if (!FD || !FD->isBitField())
+      return false;
+    Width = FD->getBitWidthValue(C.getASTContext());
+    IsUnsigned = FD->getType()->isUnsignedIntegerType();
+    return true;
+  }
+
   // Compute an upper bound for an expression. Also report where it comes from.
   static bool computeExprUpperBoundEx(const Expr *E, CheckerContext &C,
                                       llvm::APSInt &Out, UpperBoundOrigin &Origin) {
@@ -352,6 +367,21 @@         return false;
       Out = Out.extOrTrunc(64);
       Out.setIsUnsigned(true);
+      return true;
+    }
+
+    // Bitfield member expression: compute UB from declared width.
+    unsigned BFWidth = 0;
+    bool BFUnsigned = false;
+    if (getBitfieldInfo(E, C, BFWidth, BFUnsigned)) {
+      unsigned EffWidth = BFUnsigned ? BFWidth : (BFWidth ? BFWidth - 1 : 0);
+      llvm::APInt MaxVal(64, 0);
+      if (EffWidth > 0) {
+        llvm::APInt Ones = llvm::APInt::getMaxValue(EffWidth);
+        MaxVal = Ones.zextOrTrunc(64);
+      }
+      Out = llvm::APSInt(MaxVal, /*isUnsigned=*/true);
+      Origin = UBO_FromExpr;
       return true;
     }

@@ -585,6 +615,14 @@       return true;
     }

+    // Bitfield exact bound
+    unsigned BFWidth = 0;
+    bool BFUnsigned = false;
+    if (getBitfieldInfo(E, C, BFWidth, BFUnsigned)) {
+      OutBits = BFUnsigned ? BFWidth : (BFWidth ? BFWidth - 1 : 0);
+      return true;
+    }
+
     llvm::APSInt UB;
     if (computeExprUpperBound(E, C, UB)) {
       OutBits = UB.getActiveBits();
@@ -612,6 +650,12 @@       llvm::APSInt E2 = Exact.extOrTrunc(64);
       E2.setIsUnsigned(true);
       return static_cast<const llvm::APInt &>(E2);
+    }
+
+    // Bitfield: unknown forced-one mask; return zeros (conservative).
+    unsigned BFWidth = 0; bool BFUnsigned = false;
+    if (getBitfieldInfo(E, C, BFWidth, BFUnsigned)) {
+      return Zero;
     }

     // Implicit/explicit casts, parens
@@ -703,6 +747,12 @@       return (uint64_t)LBits + K <= (uint64_t)OpW;
     }

+    // Special-case: L is an unsigned bitfield of width W: check W + K
+    unsigned BFWidth = 0; bool BFUnsigned = false;
+    if (getBitfieldInfo(L, C, BFWidth, BFUnsigned) && BFUnsigned) {
+      return (uint64_t)BFWidth + K <= (uint64_t)OpW;
+    }
+
     // Use forced-one bits to get a lower bound on L's active bits.
     llvm::APInt Forced = computeForcedOneMask(L, C);
     unsigned MinLBits = Forced.getActiveBits();
@@ -712,6 +762,20 @@     }
     // If even the minimum L would overflow with K, do not suppress.
     return (uint64_t)MinLBits + K <= (uint64_t)OpW;
+  }
+
+  // Targeted FP filter: if L is an unsigned bitfield of width W and RHS is a
+  // constant K such that W + K <= OpW, the shift is safe in 32-bit.
+  static bool bitfieldConstShiftSafe(const Expr *L, const Expr *R,
+                                     unsigned OpW, CheckerContext &C) {
+    unsigned W = 0; bool IsU = false;
+    if (!getBitfieldInfo(L, C, W, IsU) || !IsU)
+      return false;
+    llvm::APSInt RC;
+    if (!EvaluateExprToInt(RC, R, C))
+      return false;
+    uint64_t K = RC.getZExtValue();
+    return (uint64_t)W + K <= (uint64_t)OpW;
   }

   static bool isFunctionParamExpr(const Expr *E) {
@@ -829,6 +893,10 @@   if (constantShiftFitsInWidth(L, R, OpW, C))
     return;

+  // FP filter: L is an unsigned bitfield and RHS is a constant; if bounded within OpW, suppress.
+  if (bitfieldConstShiftSafe(L, R, OpW, C))
+    return;
+
   // Compute provable risk using upper bounds.
   // 1) Compute maximum active bits for L.
   unsigned MaxLBits = 0;
@@ -1003,4 +1071,3 @@
 extern "C" const char clang_analyzerAPIVersionString[] =
     CLANG_ANALYZER_API_VERSION_STRING;
-
