### Report Summary

File:| fs/ocfs2/dlm/dlmmaster.c
---|---
Warning:| line 1938, column 5
Invalid-checked pointer is logged but not aborted; later dereferenced under
lock

### Annotated Source Code


1709  | 				__dlm_put_mle(mle);
1710  | 			}
1711  | 			spin_unlock(&dlm->master_lock);
1712  | 			spin_unlock(&dlm->spinlock);
1713  |  BUG();
1714  | 		}
1715  |
1716  |  if (r & DLM_ASSERT_RESPONSE_REASSERT &&
1717  | 		    !(r & DLM_ASSERT_RESPONSE_MASTERY_REF)) {
1718  |  mlog(ML_ERROR, "%.*s: very strange, "
1719  |  "master MLE but no lockres on %u\n",
1720  |  namelen, lockname, to);
1721  | 		}
1722  |
1723  |  if (r & DLM_ASSERT_RESPONSE_REASSERT) {
1724  |  mlog(0, "%.*s: node %u create mles on other "
1725  |  "nodes and requests a re-assert\n",
1726  |  namelen, lockname, to);
1727  | 			reassert = 1;
1728  | 		}
1729  |  if (r & DLM_ASSERT_RESPONSE_MASTERY_REF) {
1730  |  mlog(0, "%.*s: node %u has a reference to this "
1731  |  "lockres, set the bit in the refmap\n",
1732  |  namelen, lockname, to);
1733  | 			spin_lock(&res->spinlock);
1734  | 			dlm_lockres_set_refmap_bit(dlm, res, to);
1735  | 			spin_unlock(&res->spinlock);
1736  | 		}
1737  | 	}
1738  |
1739  |  if (reassert)
1740  |  goto again;
1741  |
1742  | 	spin_lock(&res->spinlock);
1743  | 	res->state &= ~DLM_LOCK_RES_SETREF_INPROG;
1744  | 	spin_unlock(&res->spinlock);
1745  |  wake_up(&res->wq);
1746  |
1747  |  return ret;
1748  | }
1749  |
1750  | /*
1751  |  * locks that can be taken here:
1752  |  * dlm->spinlock
1753  |  * res->spinlock
1754  |  * mle->spinlock
1755  |  * dlm->master_list
1756  |  *
1757  |  * if possible, TRIM THIS DOWN!!!
1758  |  */
1759  | int dlm_assert_master_handler(struct o2net_msg *msg, u32 len, void *data,
1760  |  void **ret_data)
1761  | {
1762  |  struct dlm_ctxt *dlm = data;
1763  |  struct dlm_master_list_entry *mle = NULL;
1764  |  struct dlm_assert_master *assert = (struct dlm_assert_master *)msg->buf;
1765  |  struct dlm_lock_resource *res = NULL;
1766  |  char *name;
1767  |  unsigned int namelen, hash;
1768  | 	u32 flags;
1769  |  int master_request = 0, have_lockres_ref = 0;
1770  |  int ret = 0;
1771  |
1772  |  if (!dlm_grab(dlm))
    1Assuming the condition is false→
    2←Taking false branch→
1773  |  return 0;
1774  |
1775  |  name = assert->name;
1776  | 	namelen = assert->namelen;
1777  | 	hash = dlm_lockid_hash(name, namelen);
1778  | 	flags = be32_to_cpu(assert->flags);
1779  |
1780  |  if (namelen > DLM_LOCKID_NAME_MAX) {
    3←Assuming 'namelen' is <= DLM_LOCKID_NAME_MAX→
    4←Taking false branch→
1781  |  mlog(ML_ERROR, "Invalid name length!");
1782  |  goto done;
1783  | 	}
1784  |
1785  |  spin_lock(&dlm->spinlock);
1786  |
1787  |  if (flags)
    5←Assuming 'flags' is 0→
    6←Taking false branch→
1788  |  mlog(0, "assert_master with flags: %u\n", flags);
1789  |
1790  |  /* find the MLE */
1791  |  spin_lock(&dlm->master_lock);
1792  |  if (!dlm_find_mle(dlm, &mle, name, namelen)) {
    7←Assuming the condition is false→
    8←Taking false branch→
1793  |  /* not an error, could be master just re-asserting */
1794  |  mlog(0, "just got an assert_master from %u, but no "
1795  |  "MLE for it! (%.*s)\n", assert->node_idx,
1796  |  namelen, name);
1797  | 	} else {
1798  |  int bit = find_first_bit(mle->maybe_map, O2NM_MAX_NODES);
1799  |  if (bit >= O2NM_MAX_NODES) {
    9←Assuming 'bit' is >= O2NM_MAX_NODES→
    10←Taking true branch→
1800  |  /* not necessarily an error, though less likely.
1801  |  * could be master just re-asserting. */
1802  |  mlog(0, "no bits set in the maybe_map, but %u "
    11←Taking true branch→
    12←Loop condition is false.  Exiting loop→
1803  |  "is asserting! (%.*s)\n", assert->node_idx,
1804  |  namelen, name);
1805  | 		} else if (bit != assert->node_idx) {
1806  |  if (flags & DLM_ASSERT_MASTER_MLE_CLEANUP) {
1807  |  mlog(0, "master %u was found, %u should "
1808  |  "back off\n", assert->node_idx, bit);
1809  | 			} else {
1810  |  /* with the fix for bug 569, a higher node
1811  |  * number winning the mastery will respond
1812  |  * YES to mastery requests, but this node
1813  |  * had no way of knowing.  let it pass. */
1814  |  mlog(0, "%u is the lowest node, "
1815  |  "%u is asserting. (%.*s)  %u must "
1816  |  "have begun after %u won.\n", bit,
1817  |  assert->node_idx, namelen, name, bit,
1818  |  assert->node_idx);
1819  | 			}
1820  | 		}
1821  |  if (mle->type == DLM_MLE_MIGRATION) {
    13←Assuming field 'type' is not equal to DLM_MLE_MIGRATION→
    14←Taking false branch→
1822  |  if (flags & DLM_ASSERT_MASTER_MLE_CLEANUP) {
1823  |  mlog(0, "%s:%.*s: got cleanup assert"
1824  |  " from %u for migration\n",
1825  |  dlm->name, namelen, name,
1826  |  assert->node_idx);
1827  | 			} else if (!(flags & DLM_ASSERT_MASTER_FINISH_MIGRATION)) {
1828  |  mlog(0, "%s:%.*s: got unrelated assert"
1829  |  " from %u for migration, ignoring\n",
1830  |  dlm->name, namelen, name,
1831  |  assert->node_idx);
1832  | 				__dlm_put_mle(mle);
1833  | 				spin_unlock(&dlm->master_lock);
1834  | 				spin_unlock(&dlm->spinlock);
1835  |  goto done;
1836  | 			}
1837  | 		}
1838  | 	}
1839  |  spin_unlock(&dlm->master_lock);
1840  |
1841  |  /* ok everything checks out with the MLE
1842  |  * now check to see if there is a lockres */
1843  | 	res = __dlm_lookup_lockres(dlm, name, namelen, hash);
1844  |  if (res) {
    15←Assuming 'res' is non-null→
    16←Taking true branch→
1845  |  spin_lock(&res->spinlock);
1846  |  if (res->state & DLM_LOCK_RES_RECOVERING)  {
    17←Assuming the condition is false→
    18←Taking false branch→
1847  |  mlog(ML_ERROR, "%u asserting but %.*s is "
1848  |  "RECOVERING!\n", assert->node_idx, namelen, name);
1849  |  goto kill;
1850  | 		}
1851  |  if (!mle18.1'mle' is non-null) {
    19←Taking false branch→
1852  |  if (res->owner != DLM_LOCK_RES_OWNER_UNKNOWN &&
1853  | 			    res->owner != assert->node_idx) {
1854  |  mlog(ML_ERROR, "DIE! Mastery assert from %u, "
1855  |  "but current owner is %u! (%.*s)\n",
1856  |  assert->node_idx, res->owner, namelen,
1857  |  name);
1858  | 				__dlm_print_one_lock_resource(res);
1859  |  BUG();
1860  | 			}
1861  | 		} else if (mle->type19.1Field 'type' is not equal to DLM_MLE_MIGRATION != DLM_MLE_MIGRATION) {
    20←Taking true branch→
1862  |  if (res->owner != DLM_LOCK_RES_OWNER_UNKNOWN) {
    21←Assuming field 'owner' is equal to DLM_LOCK_RES_OWNER_UNKNOWN→
    22←Taking false branch→
1863  |  /* owner is just re-asserting */
1864  |  if (res->owner == assert->node_idx) {
1865  |  mlog(0, "owner %u re-asserting on "
1866  |  "lock %.*s\n", assert->node_idx,
1867  |  namelen, name);
1868  |  goto ok;
1869  | 				}
1870  |  mlog(ML_ERROR, "got assert_master from "
1871  |  "node %u, but %u is the owner! "
1872  |  "(%.*s)\n", assert->node_idx,
1873  |  res->owner, namelen, name);
1874  |  goto kill;
1875  | 			}
1876  |  if (!(res->state & DLM_LOCK_RES_IN_PROGRESS)) {
    23←Assuming the condition is false→
    24←Taking false branch→
1877  |  mlog(ML_ERROR, "got assert from %u, but lock "
1878  |  "with no owner should be "
1879  |  "in-progress! (%.*s)\n",
1880  |  assert->node_idx,
1881  |  namelen, name);
1882  |  goto kill;
1883  | 			}
1884  | 		} else /* mle->type == DLM_MLE_MIGRATION */ {
1885  |  /* should only be getting an assert from new master */
1886  |  if (assert->node_idx != mle->new_master) {
1887  |  mlog(ML_ERROR, "got assert from %u, but "
1888  |  "new master is %u, and old master "
1889  |  "was %u (%.*s)\n",
1890  |  assert->node_idx, mle->new_master,
1891  |  mle->master, namelen, name);
1892  |  goto kill;
1893  | 			}
1894  |
1895  | 		}
1896  | ok:
1897  |  spin_unlock(&res->spinlock);
1898  | 	}
1899  |
1900  |  // mlog(0, "woo!  got an assert_master from node %u!\n",
1901  |  // 	     assert->node_idx);
1902  |  if (mle24.1'mle' is non-null) {
    25←Taking true branch→
1903  |  int extra_ref = 0;
1904  |  int nn = -1;
1905  |  int rr, err = 0;
1906  |
1907  | 		spin_lock(&mle->spinlock);
1908  |  if (mle->type == DLM_MLE_BLOCK || mle->type == DLM_MLE_MIGRATION)
    26←Assuming field 'type' is equal to DLM_MLE_BLOCK→
1909  |  extra_ref = 1;
1910  |  else {
1911  |  /* MASTER mle: if any bits set in the response map
1912  |  * then the calling node needs to re-assert to clear
1913  |  * up nodes that this node contacted */
1914  |  while ((nn = find_next_bit (mle->response_map, O2NM_MAX_NODES,
1915  | 						    nn+1)) < O2NM_MAX_NODES) {
1916  |  if (nn != dlm->node_num && nn != assert->node_idx) {
1917  | 					master_request = 1;
1918  |  break;
1919  | 				}
1920  | 			}
1921  | 		}
1922  |  mle->master = assert->node_idx;
1923  | 		atomic_set(&mle->woken, 1);
1924  |  wake_up(&mle->wq);
1925  | 		spin_unlock(&mle->spinlock);
1926  |
1927  |  if (res26.1'res' is non-null) {
    27←Taking true branch→
1928  |  int wake = 0;
1929  | 			spin_lock(&res->spinlock);
1930  |  if (mle->type == DLM_MLE_MIGRATION) {
    28←Assuming field 'type' is equal to DLM_MLE_MIGRATION→
    29←Taking true branch→
1931  |  mlog(0, "finishing off migration of lockres %.*s, "
    30←Taking true branch→
    31←Loop condition is false.  Exiting loop→
1932  |  "from %u to %u\n",
1933  |  res->lockname.len, res->lockname.name,
1934  |  dlm->node_num, mle->new_master);
1935  |  res->state &= ~DLM_LOCK_RES_MIGRATING;
1936  | 				wake = 1;
1937  |  dlm_change_lockres_owner(dlm, res, mle->new_master);
1938  |  BUG_ON(res->state & DLM_LOCK_RES_DIRTY);
    32←Invalid-checked pointer is logged but not aborted; later dereferenced under lock
1939  | 			} else {
1940  | 				dlm_change_lockres_owner(dlm, res, mle->master);
1941  | 			}
1942  | 			spin_unlock(&res->spinlock);
1943  | 			have_lockres_ref = 1;
1944  |  if (wake)
1945  |  wake_up(&res->wq);
1946  | 		}
1947  |
1948  |  /* master is known, detach if not already detached.
1949  |  * ensures that only one assert_master call will happen
1950  |  * on this mle. */
1951  | 		spin_lock(&dlm->master_lock);
1952  |
1953  | 		rr = kref_read(&mle->mle_refs);
1954  |  if (mle->inuse > 0) {
1955  |  if (extra_ref && rr < 3)
1956  | 				err = 1;
1957  |  else if (!extra_ref && rr < 2)
1958  | 				err = 1;
1959  | 		} else {
1960  |  if (extra_ref && rr < 2)
1961  | 				err = 1;
1962  |  else if (!extra_ref && rr < 1)
1963  | 				err = 1;
1964  | 		}
1965  |  if (err) {
1966  |  mlog(ML_ERROR, "%s:%.*s: got assert master from %u "
1967  |  "that will mess up this node, refs=%d, extra=%d, "
1968  |  "inuse=%d\n", dlm->name, namelen, name,
