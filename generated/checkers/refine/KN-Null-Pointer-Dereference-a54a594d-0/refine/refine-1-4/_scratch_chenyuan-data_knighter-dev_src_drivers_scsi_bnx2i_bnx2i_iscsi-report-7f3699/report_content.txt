### Report Summary

File:| drivers/scsi/bnx2i/bnx2i_iscsi.c
---|---
Warning:| line 2068, column 8
Invalid-checked pointer is logged but not aborted; later dereferenced under
lock

### Annotated Source Code


1934  |  return ERR_PTR(rc);
1935  | }
1936  |
1937  |
1938  | /**
1939  |  * bnx2i_ep_poll - polls for TCP connection establishement
1940  |  * @ep:			TCP connection (endpoint) handle
1941  |  * @timeout_ms:		timeout value in milli secs
1942  |  *
1943  |  * polls for TCP connect request to complete
1944  |  */
1945  | static int bnx2i_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)
1946  | {
1947  |  struct bnx2i_endpoint *bnx2i_ep;
1948  |  int rc = 0;
1949  |
1950  | 	bnx2i_ep = ep->dd_data;
1951  |  if ((bnx2i_ep->state == EP_STATE_IDLE) ||
1952  | 	    (bnx2i_ep->state == EP_STATE_CONNECT_FAILED) ||
1953  | 	    (bnx2i_ep->state == EP_STATE_OFLD_FAILED))
1954  |  return -1;
1955  |  if (bnx2i_ep->state == EP_STATE_CONNECT_COMPL)
1956  |  return 1;
1957  |
1958  | 	rc = wait_event_interruptible_timeout(bnx2i_ep->ofld_wait,
1959  |  ((bnx2i_ep->state ==
1960  |  EP_STATE_OFLD_FAILED) ||
1961  |  (bnx2i_ep->state ==
1962  |  EP_STATE_CONNECT_FAILED) ||
1963  |  (bnx2i_ep->state ==
1964  |  EP_STATE_CONNECT_COMPL)),
1965  |  msecs_to_jiffies(timeout_ms));
1966  |  if (bnx2i_ep->state == EP_STATE_OFLD_FAILED)
1967  | 		rc = -1;
1968  |
1969  |  if (rc > 0)
1970  |  return 1;
1971  |  else if (!rc)
1972  |  return 0;	/* timeout */
1973  |  else
1974  |  return rc;
1975  | }
1976  |
1977  |
1978  | /**
1979  |  * bnx2i_ep_tcp_conn_active - check EP state transition
1980  |  * @bnx2i_ep:		endpoint pointer
1981  |  *
1982  |  * check if underlying TCP connection is active
1983  |  */
1984  | static int bnx2i_ep_tcp_conn_active(struct bnx2i_endpoint *bnx2i_ep)
1985  | {
1986  |  int ret;
1987  |  int cnic_dev_10g = 0;
1988  |
1989  |  if (test_bit(BNX2I_NX2_DEV_57710, &bnx2i_ep->hba->cnic_dev_type))
1990  | 		cnic_dev_10g = 1;
1991  |
1992  |  switch (bnx2i_ep->state) {
1993  |  case EP_STATE_CLEANUP_FAILED:
1994  |  case EP_STATE_OFLD_FAILED:
1995  |  case EP_STATE_DISCONN_TIMEDOUT:
1996  | 		ret = 0;
1997  |  break;
1998  |  case EP_STATE_CONNECT_START:
1999  |  case EP_STATE_CONNECT_FAILED:
2000  |  case EP_STATE_CONNECT_COMPL:
2001  |  case EP_STATE_ULP_UPDATE_START:
2002  |  case EP_STATE_ULP_UPDATE_COMPL:
2003  |  case EP_STATE_TCP_FIN_RCVD:
2004  |  case EP_STATE_LOGOUT_SENT:
2005  |  case EP_STATE_LOGOUT_RESP_RCVD:
2006  |  case EP_STATE_ULP_UPDATE_FAILED:
2007  | 		ret = 1;
2008  |  break;
2009  |  case EP_STATE_TCP_RST_RCVD:
2010  |  if (cnic_dev_10g)
2011  | 			ret = 0;
2012  |  else
2013  | 			ret = 1;
2014  |  break;
2015  |  default:
2016  | 		ret = 0;
2017  | 	}
2018  |
2019  |  return ret;
2020  | }
2021  |
2022  |
2023  | /**
2024  |  * bnx2i_hw_ep_disconnect - executes TCP connection teardown process in the hw
2025  |  * @bnx2i_ep:		TCP connection (bnx2i endpoint) handle
2026  |  *
2027  |  * executes  TCP connection teardown process
2028  |  */
2029  | int bnx2i_hw_ep_disconnect(struct bnx2i_endpoint *bnx2i_ep)
2030  | {
2031  |  struct bnx2i_hba *hba = bnx2i_ep->hba;
2032  |  struct cnic_dev *cnic;
2033  |  struct iscsi_session *session = NULL;
2034  |  struct iscsi_conn *conn = NULL;
2035  |  int ret = 0;
2036  |  int close = 0;
2037  |  int close_ret = 0;
2038  |
2039  |  if (!hba12.1'hba' is non-null)
    13←Taking false branch→
2040  |  return 0;
2041  |
2042  |  cnic = hba->cnic;
2043  |  if (!cnic)
    14←Assuming 'cnic' is non-null→
2044  |  return 0;
2045  |
2046  |  if (bnx2i_ep->state14.1Field 'state' is not equal to EP_STATE_IDLE == EP_STATE_IDLE ||
    15←Taking false branch→
2047  |  bnx2i_ep->state14.2Field 'state' is not equal to EP_STATE_DISCONN_TIMEDOUT == EP_STATE_DISCONN_TIMEDOUT)
2048  |  return 0;
2049  |
2050  |  if (!bnx2i_ep_tcp_conn_active(bnx2i_ep))
    16←Taking false branch→
2051  |  goto destroy_conn;
2052  |
2053  |  if (bnx2i_ep->conn16.1Field 'conn' is non-null) {
    17←Taking true branch→
2054  |  conn = bnx2i_ep->conn->cls_conn->dd_data;
2055  |  session = conn->session;
2056  | 	}
2057  |
2058  |  timer_setup(&bnx2i_ep->ofld_timer, bnx2i_ep_ofld_timer, 0);
    18←Loop condition is false.  Exiting loop→
2059  |  bnx2i_ep->ofld_timer.expires = hba->conn_teardown_tmo + jiffies;
2060  | 	add_timer(&bnx2i_ep->ofld_timer);
2061  |
2062  |  if (!test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic))
    19←Assuming the condition is false→
    20←Taking false branch→
2063  |  goto out;
2064  |
2065  |  if (session) {
    21←Assuming 'session' is non-null→
    22←Taking true branch→
2066  |  spin_lock_bh(&session->frwd_lock);
2067  |  if (bnx2i_ep->state != EP_STATE_TCP_FIN_RCVD) {
    23←Assuming field 'state' is not equal to EP_STATE_TCP_FIN_RCVD→
    24←Taking true branch→
2068  |  if (session->state == ISCSI_STATE_LOGGING_OUT) {
    25←Invalid-checked pointer is logged but not aborted; later dereferenced under lock
2069  |  if (bnx2i_ep->state == EP_STATE_LOGOUT_SENT) {
2070  |  /* Logout sent, but no resp */
2071  |  printk(KERN_ALERT "bnx2i (%s): WARNING"
2072  |  " logout response was not "
2073  |  "received!\n",
2074  |  bnx2i_ep->hba->netdev->name);
2075  | 				} else if (bnx2i_ep->state ==
2076  | 					   EP_STATE_LOGOUT_RESP_RCVD)
2077  | 					close = 1;
2078  | 			}
2079  | 		} else
2080  | 			close = 1;
2081  |
2082  | 		spin_unlock_bh(&session->frwd_lock);
2083  | 	}
2084  |
2085  | 	bnx2i_ep->state = EP_STATE_DISCONN_START;
2086  |
2087  |  if (close)
2088  | 		close_ret = cnic->cm_close(bnx2i_ep->cm_sk);
2089  |  else
2090  | 		close_ret = cnic->cm_abort(bnx2i_ep->cm_sk);
2091  |
2092  |  if (close_ret)
2093  |  printk(KERN_ALERT "bnx2i (%s): close/abort(%d) returned %d\n",
2094  |  bnx2i_ep->hba->netdev->name, close, close_ret);
2095  |  else
2096  |  /* wait for option-2 conn teardown */
2097  |  wait_event_interruptible(bnx2i_ep->ofld_wait,
2098  |  ((bnx2i_ep->state != EP_STATE_DISCONN_START)
2099  |  && (bnx2i_ep->state != EP_STATE_TCP_FIN_RCVD)));
2100  |
2101  |  if (signal_pending(current))
2102  | 		flush_signals(current);
2103  | 	del_timer_sync(&bnx2i_ep->ofld_timer);
2104  |
2105  | destroy_conn:
2106  | 	bnx2i_ep_active_list_del(hba, bnx2i_ep);
2107  |  if (bnx2i_tear_down_conn(hba, bnx2i_ep))
2108  |  return -EINVAL;
2109  | out:
2110  | 	bnx2i_ep->state = EP_STATE_IDLE;
2111  |  return ret;
2112  | }
2113  |
2114  |
2115  | /**
2116  |  * bnx2i_ep_disconnect - executes TCP connection teardown process
2117  |  * @ep:		TCP connection (iscsi endpoint) handle
2118  |  *
2119  |  * executes  TCP connection teardown process
2120  |  */
2121  | static void bnx2i_ep_disconnect(struct iscsi_endpoint *ep)
2122  | {
2123  |  struct bnx2i_endpoint *bnx2i_ep;
2124  |  struct bnx2i_conn *bnx2i_conn = NULL;
2125  |  struct bnx2i_hba *hba;
2126  |
2127  | 	bnx2i_ep = ep->dd_data;
2128  |
2129  |  /* driver should not attempt connection cleanup until TCP_CONNECT
2130  |  * completes either successfully or fails. Timeout is 9-secs, so
2131  |  * wait for it to complete
2132  |  */
2133  |  while ((bnx2i_ep->state == EP_STATE_CONNECT_START) &&
    1Assuming field 'state' is not equal to EP_STATE_CONNECT_START→
2134  | 		!time_after(jiffies, bnx2i_ep->timestamp + (12 * HZ)))
2135  | 		msleep(250);
2136  |
2137  |  if (bnx2i_ep->conn)
    2←Assuming field 'conn' is non-null→
    3←Taking true branch→
2138  |  bnx2i_conn = bnx2i_ep->conn;
2139  |  hba = bnx2i_ep->hba;
2140  |
2141  |  mutex_lock(&hba->net_dev_lock);
2142  |
2143  |  if (bnx2i_ep->state == EP_STATE_DISCONN_TIMEDOUT)
    4←Assuming field 'state' is not equal to EP_STATE_DISCONN_TIMEDOUT→
    5←Taking false branch→
2144  |  goto out;
2145  |
2146  |  if (bnx2i_ep->state == EP_STATE_IDLE)
    6←Assuming field 'state' is not equal to EP_STATE_IDLE→
2147  |  goto free_resc;
2148  |
2149  |  if (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state) ||
    7←Taking false branch→
    8←Assuming the condition is true→
    9←Assuming the condition is false→
    11←Taking false branch→
2150  | 	    (bnx2i_ep->hba_age != hba->age)) {
    10←Assuming field 'hba_age' is equal to field 'age'→
2151  | 		bnx2i_ep_active_list_del(hba, bnx2i_ep);
2152  |  goto free_resc;
2153  | 	}
2154  |
2155  |  /* Do all chip cleanup here */
2156  |  if (bnx2i_hw_ep_disconnect(bnx2i_ep)) {
    12←Calling 'bnx2i_hw_ep_disconnect'→
2157  | 		mutex_unlock(&hba->net_dev_lock);
2158  |  return;
2159  | 	}
2160  | free_resc:
2161  | 	bnx2i_free_qp_resc(hba, bnx2i_ep);
2162  |
2163  |  if (bnx2i_conn)
2164  | 		bnx2i_conn->ep = NULL;
2165  |
2166  | 	bnx2i_free_ep(ep);
2167  | out:
2168  | 	mutex_unlock(&hba->net_dev_lock);
2169  |
2170  |  wake_up_interruptible(&hba->eh_wait);
2171  | }
2172  |
2173  |
2174  | /**
2175  |  * bnx2i_nl_set_path - ISCSI_UEVENT_PATH_UPDATE user message handler
2176  |  * @shost:	scsi host pointer
2177  |  * @params:	pointer to buffer containing iscsi path message
2178  |  */
2179  | static int bnx2i_nl_set_path(struct Scsi_Host *shost, struct iscsi_path *params)
2180  | {
2181  |  struct bnx2i_hba *hba = iscsi_host_priv(shost);
2182  |  char *buf = (char *) params;
2183  | 	u16 len = sizeof(*params);
2184  |
2185  |  /* handled by cnic driver */
2186  | 	hba->cnic->iscsi_nl_msg_recv(hba->cnic, ISCSI_UEVENT_PATH_UPDATE, buf,
