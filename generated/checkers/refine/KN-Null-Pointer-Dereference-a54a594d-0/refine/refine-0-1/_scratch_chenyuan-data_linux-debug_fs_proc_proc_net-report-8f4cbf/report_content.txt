### Report Summary

File:| /scratch/chenyuan-data/linux-debug/fs/proc/proc_net.c
---|---
Warning:| line 277, column 8
Invalid-checked pointer is logged but not aborted; later dereferenced under
lock

### Annotated Source Code


217   | 	p->proc_ops = &proc_net_single_ops;
218   | 	p->single_show = show;
219   |  return proc_register(parent, p);
220   | }
221   | EXPORT_SYMBOL_GPL(proc_create_net_single);
222   |
223   | /**
224   |  * proc_create_net_single_write - Create a writable net_ns-specific proc file
225   |  * @name: The name of the file.
226   |  * @mode: The file's access mode.
227   |  * @parent: The parent directory in which to create.
228   |  * @show: The seqfile show method with which to read the file.
229   |  * @write: The write method with which to 'modify' the file.
230   |  * @data: Data for retrieval by pde_data().
231   |  *
232   |  * Create a network-namespaced proc file in the @parent directory with the
233   |  * specified @name and @mode that allows reading of a file that displays a
234   |  * single element rather than a series and also provides for the file accepting
235   |  * writes that have some arbitrary effect.
236   |  *
237   |  * The @show function is called to extract the readable content via the
238   |  * seq_file interface.
239   |  *
240   |  * The @write function is called with the data copied into a kernel space
241   |  * scratch buffer and has a NUL appended for convenience.  The buffer may be
242   |  * modified by the @write function.  @write should return 0 on success.
243   |  *
244   |  * The @data value is accessible from the @show and @write functions by calling
245   |  * pde_data() on the file inode.  The network namespace must be accessed by
246   |  * calling seq_file_single_net() on the seq_file struct.
247   |  */
248   | struct proc_dir_entry *proc_create_net_single_write(const char *name, umode_t mode,
249   |  struct proc_dir_entry *parent,
250   |  int (*show)(struct seq_file *, void *),
251   | 						    proc_write_t write,
252   |  void *data)
253   | {
254   |  struct proc_dir_entry *p;
255   |
256   | 	p = proc_create_reg(name, mode, &parent, data);
257   |  if (!p)
258   |  return NULL;
259   | 	pde_force_lookup(p);
260   | 	p->proc_ops = &proc_net_single_ops;
261   | 	p->single_show = show;
262   | 	p->write = write;
263   |  return proc_register(parent, p);
264   | }
265   | EXPORT_SYMBOL_GPL(proc_create_net_single_write);
266   |
267   | static struct net *get_proc_task_net(struct inode *dir)
268   | {
269   |  struct task_struct *task;
270   |  struct nsproxy *ns;
271   |  struct net *net = NULL;
272   |
273   | 	rcu_read_lock();
274   | 	task = pid_task(proc_pid(dir), PIDTYPE_PID);
275   |  if (task2.1'task' is not equal to NULL != NULL) {
    2←Assuming 'task' is not equal to NULL→
    3←Taking true branch→
276   |  task_lock(task);
277   |  ns = task->nsproxy;
    4←Invalid-checked pointer is logged but not aborted; later dereferenced under lock
278   |  if (ns != NULL)
279   | 			net = get_net(ns->net_ns);
280   | 		task_unlock(task);
281   | 	}
282   | 	rcu_read_unlock();
283   |
284   |  return net;
285   | }
286   |
287   | static struct dentry *proc_tgid_net_lookup(struct inode *dir,
288   |  struct dentry *dentry, unsigned int flags)
289   | {
290   |  struct dentry *de;
291   |  struct net *net;
292   |
293   | 	de = ERR_PTR(-ENOENT);
294   | 	net = get_proc_task_net(dir);
295   |  if (net != NULL) {
296   | 		de = proc_lookup_de(dir, dentry, net->proc_net);
297   | 		put_net(net);
298   | 	}
299   |  return de;
300   | }
301   |
302   | static int proc_tgid_net_getattr(struct mnt_idmap *idmap,
303   |  const struct path *path, struct kstat *stat,
304   | 				 u32 request_mask, unsigned int query_flags)
305   | {
306   |  struct inode *inode = d_inode(path->dentry);
307   |  struct net *net;
308   |
309   | 	net = get_proc_task_net(inode);
310   |
311   | 	generic_fillattr(&nop_mnt_idmap, request_mask, inode, stat);
312   |
313   |  if (net != NULL) {
314   | 		stat->nlink = net->proc_net->nlink;
315   | 		put_net(net);
316   | 	}
317   |
318   |  return 0;
319   | }
320   |
321   | const struct inode_operations proc_net_inode_operations = {
322   | 	.lookup		= proc_tgid_net_lookup,
323   | 	.getattr	= proc_tgid_net_getattr,
324   | 	.setattr        = proc_setattr,
325   | };
326   |
327   | static int proc_tgid_net_readdir(struct file *file, struct dir_context *ctx)
328   | {
329   |  int ret;
330   |  struct net *net;
331   |
332   | 	ret = -EINVAL;
333   |  net = get_proc_task_net(file_inode(file));
    1Calling 'get_proc_task_net'→
334   |  if (net != NULL) {
335   | 		ret = proc_readdir_de(file, ctx, net->proc_net);
336   | 		put_net(net);
337   | 	}
338   |  return ret;
339   | }
340   |
341   | const struct file_operations proc_net_operations = {
342   | 	.llseek		= generic_file_llseek,
343   | 	.read		= generic_read_dir,
344   | 	.iterate_shared	= proc_tgid_net_readdir,
345   | };
346   |
347   | static __net_init int proc_net_ns_init(struct net *net)
348   | {
349   |  struct proc_dir_entry *netd, *net_statd;
350   | 	kuid_t uid;
351   | 	kgid_t gid;
352   |  int err;
353   |
354   |  /*
355   |  * This PDE acts only as an anchor for /proc/${pid}/net hierarchy.
356   |  * Corresponding inode (PDE(inode) == net->proc_net) is never
357   |  * instantiated therefore blanket zeroing is fine.
358   |  * net->proc_net_stat inode is instantiated normally.
359   |  */
360   | 	err = -ENOMEM;
361   | 	netd = kmem_cache_zalloc(proc_dir_entry_cache, GFP_KERNEL);
362   |  if (!netd)
363   |  goto out;
