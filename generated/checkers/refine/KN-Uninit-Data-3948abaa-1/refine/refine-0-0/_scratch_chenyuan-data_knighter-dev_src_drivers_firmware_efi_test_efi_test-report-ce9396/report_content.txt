### Report Summary

File:| drivers/firmware/efi/test/efi_test.c
---|---
Warning:| line 209, column 7
copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use
kzalloc or memset

### Annotated Source Code


89    | get_ucs2_strsize_from_user(efi_char16_t __user *src, size_t *len)
90    | {
91    | 	*len = user_ucs2_strsize(src);
92    |  if (*len == 0)
93    |  return -EFAULT;
94    |
95    |  return 0;
96    | }
97    |
98    | /*
99    |  * Calculate the required buffer allocation size and copy a ucs2 string
100   |  * from user space into it.
101   |  *
102   |  * This function differs from copy_ucs2_from_user_len() because it
103   |  * calculates the size of the buffer to allocate by taking the length of
104   |  * the string 'src'.
105   |  *
106   |  * If a non-zero value is returned, the caller MUST NOT access 'dst'.
107   |  *
108   |  * It is the caller's responsibility to free 'dst'.
109   |  */
110   | static inline int
111   | copy_ucs2_from_user(efi_char16_t **dst, efi_char16_t __user *src)
112   | {
113   | 	size_t len;
114   |
115   | 	len = user_ucs2_strsize(src);
116   |  if (len == 0)
117   |  return -EFAULT;
118   |  return copy_ucs2_from_user_len(dst, src, len);
119   | }
120   |
121   | /*
122   |  * Copy a ucs2 string to a user buffer.
123   |  *
124   |  * This function is a simple wrapper around copy_to_user() that does
125   |  * nothing if 'src' is NULL, which is useful for reducing the amount of
126   |  * NULL checking the caller has to do.
127   |  *
128   |  * 'len' specifies the number of bytes to copy.
129   |  */
130   | static inline int
131   | copy_ucs2_to_user_len(efi_char16_t __user *dst, efi_char16_t *src, size_t len)
132   | {
133   |  if (!src)
134   |  return 0;
135   |
136   |  return copy_to_user(dst, src, len);
137   | }
138   |
139   | static long efi_runtime_get_variable(unsigned long arg)
140   | {
141   |  struct efi_getvariable __user *getvariable_user;
142   |  struct efi_getvariable getvariable;
143   |  unsigned long datasize = 0, prev_datasize, *dz;
144   | 	efi_guid_t vendor_guid, *vd = NULL;
145   | 	efi_status_t status;
146   | 	efi_char16_t *name = NULL;
147   | 	u32 attr, *at;
148   |  void *data = NULL;
149   |  int rv = 0;
150   |
151   | 	getvariable_user = (struct efi_getvariable __user *)arg;
152   |
153   |  if (copy_from_user(&getvariable, getvariable_user,
    3←Assuming the condition is false→
154   |  sizeof(getvariable)))
155   |  return -EFAULT;
156   |  if (getvariable.data_size &&
    4←Assuming field 'data_size' is non-null→
    6←Taking false branch→
157   |  get_user(datasize, getvariable.data_size))
    5←Assuming the condition is false→
158   |  return -EFAULT;
159   |  if (getvariable.vendor_guid) {
    7←Assuming field 'vendor_guid' is null→
    8←Taking false branch→
160   |  if (copy_from_user(&vendor_guid, getvariable.vendor_guid,
161   |  sizeof(vendor_guid)))
162   |  return -EFAULT;
163   | 		vd = &vendor_guid;
164   | 	}
165   |
166   |  if (getvariable.variable_name) {
    9←Assuming field 'variable_name' is null→
167   | 		rv = copy_ucs2_from_user(&name, getvariable.variable_name);
168   |  if (rv)
169   |  return rv;
170   | 	}
171   |
172   |  at = getvariable.attributes ? &attr : NULL;
    10←Taking false branch→
    11←Assuming field 'attributes' is null→
    12←'?' condition is false→
173   |  dz = getvariable.data_size12.1Field 'data_size' is non-null ? &datasize : NULL;
    13←'?' condition is true→
174   |
175   |  if (getvariable.data_size13.1Field 'data_size' is non-null && getvariable.data) {
    14←Assuming field 'data' is non-null→
    15←Taking true branch→
176   |  data = kmalloc(datasize, GFP_KERNEL);
177   |  if (!data) {
    16←Assuming 'data' is non-null→
    17←Taking false branch→
178   | 			kfree(name);
179   |  return -ENOMEM;
180   | 		}
181   | 	}
182   |
183   |  prev_datasize = datasize;
184   | 	status = efi.get_variable(name, vd, at, dz, data);
185   | 	kfree(name);
186   |
187   |  if (put_user(status, getvariable.status)) {
    18←Assuming the condition is false→
    19←Taking false branch→
188   | 		rv = -EFAULT;
189   |  goto out;
190   | 	}
191   |
192   |  if (status != EFI_SUCCESS) {
    20←Assuming 'status' is equal to EFI_SUCCESS→
    21←Taking false branch→
193   |  if (status == EFI_BUFFER_TOO_SMALL) {
194   |  if (dz && put_user(datasize, getvariable.data_size)) {
195   | 				rv = -EFAULT;
196   |  goto out;
197   | 			}
198   | 		}
199   | 		rv = -EINVAL;
200   |  goto out;
201   | 	}
202   |
203   |  if (prev_datasize < datasize) {
    22←Assuming 'prev_datasize' is >= 'datasize'→
    23←Taking false branch→
204   | 		rv = -EINVAL;
205   |  goto out;
206   | 	}
207   |
208   |  if (data23.1'data' is non-null) {
    24←Taking true branch→
209   |  if (copy_to_user(getvariable.data, data, datasize)) {
    25←copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use kzalloc or memset
210   | 			rv = -EFAULT;
211   |  goto out;
212   | 		}
213   | 	}
214   |
215   |  if (at && put_user(attr, getvariable.attributes)) {
216   | 		rv = -EFAULT;
217   |  goto out;
218   | 	}
219   |
220   |  if (dz && put_user(datasize, getvariable.data_size))
221   | 		rv = -EFAULT;
222   |
223   | out:
224   | 	kfree(data);
225   |  return rv;
226   |
227   | }
228   |
229   | static long efi_runtime_set_variable(unsigned long arg)
230   | {
231   |  struct efi_setvariable __user *setvariable_user;
232   |  struct efi_setvariable setvariable;
233   | 	efi_guid_t vendor_guid;
234   | 	efi_status_t status;
235   | 	efi_char16_t *name = NULL;
236   |  void *data;
237   |  int rv = 0;
238   |
239   | 	setvariable_user = (struct efi_setvariable __user *)arg;
629   |  if (copy_from_user(&capsules[i], c,
630   |  sizeof(efi_capsule_header_t))) {
631   | 			rv = -EFAULT;
632   |  goto out;
633   | 		}
634   | 	}
635   |
636   | 	qcaps.capsule_header_array = &capsules;
637   |
638   | 	status = efi.query_capsule_caps((efi_capsule_header_t **)
639   | 					qcaps.capsule_header_array,
640   | 					qcaps.capsule_count,
641   | 					&max_size, &reset_type);
642   |
643   |  if (put_user(status, qcaps.status)) {
644   | 		rv = -EFAULT;
645   |  goto out;
646   | 	}
647   |
648   |  if (status != EFI_SUCCESS) {
649   | 		rv = -EINVAL;
650   |  goto out;
651   | 	}
652   |
653   |  if (put_user(max_size, qcaps.maximum_capsule_size)) {
654   | 		rv = -EFAULT;
655   |  goto out;
656   | 	}
657   |
658   |  if (put_user(reset_type, qcaps.reset_type))
659   | 		rv = -EFAULT;
660   |
661   | out:
662   | 	kfree(capsules);
663   |  return rv;
664   | }
665   |
666   | static long efi_runtime_get_supported_mask(unsigned long arg)
667   | {
668   |  unsigned int __user *supported_mask;
669   |  int rv = 0;
670   |
671   | 	supported_mask = (unsigned int *)arg;
672   |
673   |  if (put_user(efi.runtime_supported_mask, supported_mask))
674   | 		rv = -EFAULT;
675   |
676   |  return rv;
677   | }
678   |
679   | static long efi_test_ioctl(struct file *file, unsigned int cmd,
680   |  unsigned long arg)
681   | {
682   |  switch (cmd) {
    1Control jumps to 'case 3224399873:'  at line 683→
683   |  case EFI_RUNTIME_GET_VARIABLE:
684   |  return efi_runtime_get_variable(arg);
    2←Calling 'efi_runtime_get_variable'→
685   |
686   |  case EFI_RUNTIME_SET_VARIABLE:
687   |  return efi_runtime_set_variable(arg);
688   |
689   |  case EFI_RUNTIME_GET_TIME:
690   |  return efi_runtime_get_time(arg);
691   |
692   |  case EFI_RUNTIME_SET_TIME:
693   |  return efi_runtime_set_time(arg);
694   |
695   |  case EFI_RUNTIME_GET_WAKETIME:
696   |  return efi_runtime_get_waketime(arg);
697   |
698   |  case EFI_RUNTIME_SET_WAKETIME:
699   |  return efi_runtime_set_waketime(arg);
700   |
701   |  case EFI_RUNTIME_GET_NEXTVARIABLENAME:
702   |  return efi_runtime_get_nextvariablename(arg);
703   |
704   |  case EFI_RUNTIME_GET_NEXTHIGHMONOTONICCOUNT:
705   |  return efi_runtime_get_nexthighmonocount(arg);
706   |
707   |  case EFI_RUNTIME_QUERY_VARIABLEINFO:
708   |  return efi_runtime_query_variableinfo(arg);
709   |
710   |  case EFI_RUNTIME_QUERY_CAPSULECAPABILITIES:
711   |  return efi_runtime_query_capsulecaps(arg);
712   |
713   |  case EFI_RUNTIME_RESET_SYSTEM:
714   |  return efi_runtime_reset_system(arg);
