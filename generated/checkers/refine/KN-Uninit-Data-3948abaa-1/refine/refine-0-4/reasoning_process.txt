Refinement Plan:
- Root cause: The checker reports a leak when copy_to_user’s length is a non-constant variable the analyzer can’t evaluate, even when path constraints guarantee the length is zero (as in the false positive). The checker only trusts constant lengths or explicit zero-inits, and doesn’t use the constraint manager for the length.
- Fix strategy:
  1. Use the constraint manager to detect when the copy length is definitely zero and suppress the report in that case.
  2. If we have recorded an explicit zero-initialization length (e.g., via memset or memzero_explicit), and we can prove the maximum possible copy length is less than or equal to that, suppress the report using inferSymbolMaxVal.
  3. Keep existing producer modeling and zero-init logic intact so true positives (like the kmalloc buffer in do_sys_name_to_handle) are still reported.
- Edge cases and regressions:
  - Suppression only when the length is proven to be exactly zero or bounded by previously observed memzero length. This should not mask real issues where non-zero bytes are copied or explicit zero-init coverage is unknown.
  - Works with Clang-18: uses standard SValBuilder/evalEQ/assume and getSymMaxVal.
- Implementation details:
  - Add isCopyLenDefinitelyZero(...) to query constraints.
  - Add isCopyLenCoveredByZeroInit(...) to compare symbolic max length to recorded ZeroInitSizeMap.
  - Add isFalsePositive(...) wrapper to combine zero-length, producer-based, and zero-init-coverage suppressions and use in checkPreCall.
  - Do not remove any includes and keep API compatibility.

Refined Code:
```cpp
```
