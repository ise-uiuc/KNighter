### Report Summary

File:| net/atm/resources.c
---|---
Warning:| line 220, column 12
copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use
kzalloc or memset

### Annotated Source Code


144   |  * with same number can appear, such we need deregister proc,
145   |  * release async all vccs and remove them from vccs list too
146   |  */
147   |  mutex_lock(&atm_dev_mutex);
148   | 	list_del(&dev->dev_list);
149   | 	mutex_unlock(&atm_dev_mutex);
150   |
151   | 	atm_dev_release_vccs(dev);
152   | 	atm_unregister_sysfs(dev);
153   | 	atm_proc_dev_deregister(dev);
154   |
155   | 	atm_dev_put(dev);
156   | }
157   | EXPORT_SYMBOL(atm_dev_deregister);
158   |
159   | static void copy_aal_stats(struct k_atm_aal_stats *from,
160   |  struct atm_aal_stats *to)
161   | {
162   | #define __HANDLE_ITEM(i) to->i = atomic_read(&from->i)
163   |  __AAL_STAT_ITEMS
164   | #undef __HANDLE_ITEM
165   | }
166   |
167   | static void subtract_aal_stats(struct k_atm_aal_stats *from,
168   |  struct atm_aal_stats *to)
169   | {
170   | #define __HANDLE_ITEM(i) atomic_sub(to->i, &from->i)
171   |  __AAL_STAT_ITEMS
172   | #undef __HANDLE_ITEM
173   | }
174   |
175   | static int fetch_stats(struct atm_dev *dev, struct atm_dev_stats __user *arg,
176   |  int zero)
177   | {
178   |  struct atm_dev_stats tmp;
179   |  int error = 0;
180   |
181   | 	copy_aal_stats(&dev->stats.aal0, &tmp.aal0);
182   | 	copy_aal_stats(&dev->stats.aal34, &tmp.aal34);
183   | 	copy_aal_stats(&dev->stats.aal5, &tmp.aal5);
184   |  if (arg)
185   | 		error = copy_to_user(arg, &tmp, sizeof(tmp));
186   |  if (zero && !error) {
187   | 		subtract_aal_stats(&dev->stats.aal0, &tmp.aal0);
188   | 		subtract_aal_stats(&dev->stats.aal34, &tmp.aal34);
189   | 		subtract_aal_stats(&dev->stats.aal5, &tmp.aal5);
190   | 	}
191   |  return error ? -EFAULT : 0;
192   | }
193   |
194   | int atm_getnames(void __user *buf, int __user *iobuf_len)
195   | {
196   |  int error, len, size = 0;
197   |  struct atm_dev *dev;
198   |  struct list_head *p;
199   |  int *tmp_buf, *tmp_p;
200   |
201   |  if (get_user(len, iobuf_len))
    1Assuming the condition is false→
    2←Taking false branch→
202   |  return -EFAULT;
203   |  mutex_lock(&atm_dev_mutex);
204   |  list_for_each(p, &atm_devs)
    3←Loop condition is false. Execution continues on line 206→
205   | 		size += sizeof(int);
206   |  if (size > len) {
    4←Assuming 'size' is <= 'len'→
    5←Taking false branch→
207   | 		mutex_unlock(&atm_dev_mutex);
208   |  return -E2BIG;
209   | 	}
210   |  tmp_buf = kmalloc(size, GFP_ATOMIC);
211   |  if (!tmp_buf) {
    6←Assuming 'tmp_buf' is non-null→
    7←Taking false branch→
212   | 		mutex_unlock(&atm_dev_mutex);
213   |  return -ENOMEM;
214   | 	}
215   |  tmp_p = tmp_buf;
216   |  list_for_each_entry(dev, &atm_devs, dev_list) {
    8←Loop condition is false. Execution continues on line 219→
217   | 		*tmp_p++ = dev->number;
218   | 	}
219   |  mutex_unlock(&atm_dev_mutex);
220   |  error = ((copy_to_user(buf, tmp_buf, size)) ||
    9←copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use kzalloc or memset
221   |  put_user(size, iobuf_len))
222   | 		? -EFAULT : 0;
223   | 	kfree(tmp_buf);
224   |  return error;
225   | }
226   |
227   | int atm_dev_ioctl(unsigned int cmd, void __user *buf, int __user *sioc_len,
228   |  int number, int compat)
229   | {
230   |  int error, len, size = 0;
231   |  struct atm_dev *dev;
232   |
233   |  if (get_user(len, sioc_len))
234   |  return -EFAULT;
235   |
236   | 	dev = try_then_request_module(atm_dev_lookup(number), "atm-device-%d",
237   |  number);
238   |  if (!dev)
239   |  return -ENODEV;
240   |
241   |  switch (cmd) {
242   |  case ATM_GETTYPE:
243   | 		size = strlen(dev->type) + 1;
244   |  if (copy_to_user(buf, dev->type, size)) {
245   | 			error = -EFAULT;
246   |  goto done;
247   | 		}
248   |  break;
249   |  case ATM_GETESI:
250   | 		size = ESI_LEN;
