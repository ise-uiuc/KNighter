### Report Summary

File:| drivers/gpu/drm/i915/i915_gpu_error.c
---|---
Warning:| line 2403, column 7
copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use
kzalloc or memset

### Annotated Source Code


2333  |  for (pos = MAX_CHUNK; pos < count; pos += MAX_CHUNK) {
2334  |  char chr = ptr[pos];
2335  |
2336  | 					ptr[pos] = 0;
2337  |  drm_info(&i915->drm, "[Capture/%d.%d] }%s{\n",
2338  |  l_count, line++, ptr2);
2339  | 					ptr[pos] = chr;
2340  | 					ptr2 = ptr + pos;
2341  |
2342  |  /*
2343  |  * If spewing large amounts of data via a serial console,
2344  |  * this can be a very slow process. So be friendly and try
2345  |  * not to cause 'softlockup on CPU' problems.
2346  |  */
2347  |  cond_resched();
2348  | 				}
2349  |
2350  |  if (ptr2 < (ptr + count))
2351  |  drm_info(&i915->drm, "[Capture/%d.%d] %c%s%c\n",
2352  |  l_count, line++, tag[0], ptr2, tag[1]);
2353  |  else if (tag[0] == '>')
2354  |  drm_info(&i915->drm, "[Capture/%d.%d] ><\n",
2355  |  l_count, line++);
2356  | 			} else {
2357  |  drm_info(&i915->drm, "[Capture/%d.%d] %c%s%c\n",
2358  |  l_count, line++, tag[0], ptr, tag[1]);
2359  | 			}
2360  |
2361  | 			ptr = next;
2362  | 			got -= count;
2363  |  if (next) {
2364  | 				ptr++;
2365  | 				got--;
2366  | 			}
2367  |
2368  |  /* As above. */
2369  |  cond_resched();
2370  | 		}
2371  |
2372  |  if (got)
2373  |  drm_info(&i915->drm, "[Capture/%d.%d] Got %zd bytes remaining!\n",
2374  |  l_count, line++, got);
2375  | 	}
2376  |
2377  | 	kvfree(buf);
2378  |
2379  |  drm_info(&i915->drm, "[Capture/%d.%d] Dumped %zd bytes\n", l_count, line++, pos_err);
2380  | }
2381  | #endif
2382  |
2383  | static ssize_t gpu_state_read(struct file *file, char __user *ubuf,
2384  | 			      size_t count, loff_t *pos)
2385  | {
2386  |  struct i915_gpu_coredump *error;
2387  | 	ssize_t ret;
2388  |  void *buf;
2389  |
2390  | 	error = file->private_data;
2391  |  if (!error)
    1Assuming 'error' is non-null→
    2←Taking false branch→
2392  |  return 0;
2393  |
2394  |  /* Bounce buffer required because of kernfs __user API convenience. */
2395  |  buf = kmalloc(count, GFP_KERNEL);
2396  |  if (!buf)
    3←Assuming 'buf' is non-null→
    4←Taking false branch→
2397  |  return -ENOMEM;
2398  |
2399  |  ret = i915_gpu_coredump_copy_to_buffer(error, buf, *pos, count);
2400  |  if (ret <= 0)
    5←Assuming 'ret' is > 0→
    6←Taking false branch→
2401  |  goto out;
2402  |
2403  |  if (!copy_to_user(ubuf, buf, ret))
    7←copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use kzalloc or memset
2404  | 		*pos += ret;
2405  |  else
2406  | 		ret = -EFAULT;
2407  |
2408  | out:
2409  | 	kfree(buf);
2410  |  return ret;
2411  | }
2412  |
2413  | static int gpu_state_release(struct inode *inode, struct file *file)
2414  | {
2415  | 	i915_gpu_coredump_put(file->private_data);
2416  |  return 0;
2417  | }
2418  |
2419  | static int i915_gpu_info_open(struct inode *inode, struct file *file)
2420  | {
2421  |  struct drm_i915_private *i915 = inode->i_private;
2422  |  struct i915_gpu_coredump *gpu;
2423  | 	intel_wakeref_t wakeref;
2424  |
2425  | 	gpu = NULL;
2426  |  with_intel_runtime_pm(&i915->runtime_pm, wakeref)
2427  | 		gpu = i915_gpu_coredump(to_gt(i915), ALL_ENGINES, CORE_DUMP_FLAG_NONE);
2428  |
2429  |  if (IS_ERR(gpu))
2430  |  return PTR_ERR(gpu);
2431  |
2432  | 	file->private_data = gpu;
2433  |  return 0;
