### Report Summary

File:| drivers/tty/vt/keyboard.c
---|---
Warning:| line 2087, column 9
copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use
kzalloc or memset

### Annotated Source Code


2008  |  return -EPERM;
2009  | 	}
2010  |
2011  | 	key_map[idx] = U(val);
2012  |  if (!map && (KTYP(oldval) == KT_SHIFT || KTYP(val) == KT_SHIFT))
2013  | 		do_compute_shiftstate();
2014  | out:
2015  | 	spin_unlock_irqrestore(&kbd_event_lock, flags);
2016  |
2017  |  return 0;
2018  | }
2019  |
2020  | int vt_do_kdsk_ioctl(int cmd, struct kbentry __user *user_kbe, int perm,
2021  |  unsigned int console)
2022  | {
2023  |  struct kbd_struct *kb = &kbd_table[console];
2024  |  struct kbentry kbe;
2025  |
2026  |  if (copy_from_user(&kbe, user_kbe, sizeof(struct kbentry)))
2027  |  return -EFAULT;
2028  |
2029  |  switch (cmd) {
2030  |  case KDGKBENT:
2031  |  return put_user(vt_kdgkbent(kb->kbdmode, kbe.kb_index,
2032  |  kbe.kb_table),
2033  |  &user_kbe->kb_value);
2034  |  case KDSKBENT:
2035  |  if (!perm || !capable(CAP_SYS_TTY_CONFIG))
2036  |  return -EPERM;
2037  |  return vt_kdskbent(kb->kbdmode, kbe.kb_index, kbe.kb_table,
2038  | 				kbe.kb_value);
2039  | 	}
2040  |  return 0;
2041  | }
2042  |
2043  | static char *vt_kdskbsent(char *kbs, unsigned char cur)
2044  | {
2045  |  static DECLARE_BITMAP(is_kmalloc, MAX_NR_FUNC);
2046  |  char *cur_f = func_table[cur];
2047  |
2048  |  if (cur_f && strlen(cur_f) >= strlen(kbs)) {
2049  | 		strcpy(cur_f, kbs);
2050  |  return kbs;
2051  | 	}
2052  |
2053  | 	func_table[cur] = kbs;
2054  |
2055  |  return __test_and_set_bit(cur, is_kmalloc) ? cur_f : NULL;
2056  | }
2057  |
2058  | int vt_do_kdgkb_ioctl(int cmd, struct kbsentry __user *user_kdgkb, int perm)
2059  | {
2060  |  unsigned char kb_func;
2061  |  unsigned long flags;
2062  |  char *kbs;
2063  |  int ret;
2064  |
2065  |  if (get_user(kb_func, &user_kdgkb->kb_func))
    1Assuming the condition is false→
    2←Taking false branch→
2066  |  return -EFAULT;
2067  |
2068  |  kb_func = array_index_nospec(kb_func, MAX_NR_FUNC);
    3←Taking false branch→
    4←Loop condition is false.  Exiting loop→
    5←Taking false branch→
    6←Loop condition is false.  Exiting loop→
2069  |
2070  |  switch (cmd) {
    7←Control jumps to 'case 19272:'  at line 2071→
2071  |  case KDGKBSENT: {
2072  |  /* size should have been a struct member */
2073  |  ssize_t len = sizeof(user_kdgkb->kb_string);
2074  |
2075  | 		kbs = kmalloc(len, GFP_KERNEL);
2076  |  if (!kbs)
    8←Assuming 'kbs' is non-null→
    9←Taking false branch→
2077  |  return -ENOMEM;
2078  |
2079  |  spin_lock_irqsave(&func_buf_lock, flags);
    10←Loop condition is false.  Exiting loop→
    11←Loop condition is false.  Exiting loop→
2080  |  len = strscpy(kbs, func_table[kb_func] ? : "", len);
    12←'?' condition is true→
2081  | 		spin_unlock_irqrestore(&func_buf_lock, flags);
2082  |
2083  |  if (len < 0) {
    13←Assuming 'len' is >= 0→
2084  | 			ret = -ENOSPC;
2085  |  break;
2086  | 		}
2087  |  ret = copy_to_user(user_kdgkb->kb_string, kbs, len + 1) ?
    14←Taking false branch→
    15←copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use kzalloc or memset
2088  | 			-EFAULT : 0;
2089  |  break;
2090  | 	}
2091  |  case KDSKBSENT:
2092  |  if (!perm || !capable(CAP_SYS_TTY_CONFIG))
2093  |  return -EPERM;
2094  |
2095  | 		kbs = strndup_user(user_kdgkb->kb_string,
2096  |  sizeof(user_kdgkb->kb_string));
2097  |  if (IS_ERR(kbs))
2098  |  return PTR_ERR(kbs);
2099  |
2100  |  spin_lock_irqsave(&func_buf_lock, flags);
2101  | 		kbs = vt_kdskbsent(kbs, kb_func);
2102  | 		spin_unlock_irqrestore(&func_buf_lock, flags);
2103  |
2104  | 		ret = 0;
2105  |  break;
2106  | 	}
2107  |
2108  | 	kfree(kbs);
2109  |
2110  |  return ret;
2111  | }
2112  |
2113  | int vt_do_kdskled(unsigned int console, int cmd, unsigned long arg, int perm)
2114  | {
2115  |  struct kbd_struct *kb = &kbd_table[console];
2116  |  unsigned long flags;
2117  |  unsigned char ucval;
