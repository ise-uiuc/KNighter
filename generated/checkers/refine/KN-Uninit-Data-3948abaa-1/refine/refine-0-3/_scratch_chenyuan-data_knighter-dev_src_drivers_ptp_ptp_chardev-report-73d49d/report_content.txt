### Report Summary

File:| drivers/ptp/ptp_chardev.c
---|---
Warning:| line 584, column 6
copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use
kzalloc or memset

### Annotated Source Code


473   |  return -ERESTARTSYS;
474   | 		err = ptp_set_pinfunc(ptp, pin_index, pd.func, pd.chan);
475   | 		mutex_unlock(&ptp->pincfg_mux);
476   |  break;
477   |
478   |  case PTP_MASK_CLEAR_ALL:
479   | 		bitmap_clear(tsevq->mask, 0, PTP_MAX_CHANNELS);
480   |  break;
481   |
482   |  case PTP_MASK_EN_SINGLE:
483   |  if (copy_from_user(&i, (void __user *)arg, sizeof(i))) {
484   | 			err = -EFAULT;
485   |  break;
486   | 		}
487   |  if (i >= PTP_MAX_CHANNELS) {
488   | 			err = -EFAULT;
489   |  break;
490   | 		}
491   | 		set_bit(i, tsevq->mask);
492   |  break;
493   |
494   |  default:
495   | 		err = -ENOTTY;
496   |  break;
497   | 	}
498   |
499   | out:
500   | 	kfree(extoff);
501   | 	kfree(sysoff);
502   |  return err;
503   | }
504   |
505   | __poll_t ptp_poll(struct posix_clock_context *pccontext, struct file *fp,
506   | 		  poll_table *wait)
507   | {
508   |  struct ptp_clock *ptp =
509   |  container_of(pccontext->clk, struct ptp_clock, clock);
510   |  struct timestamp_event_queue *queue;
511   |
512   | 	queue = pccontext->private_clkdata;
513   |  if (!queue)
514   |  return EPOLLERR;
515   |
516   | 	poll_wait(fp, &ptp->tsev_wq, wait);
517   |
518   |  return queue_cnt(queue) ? EPOLLIN : 0;
519   | }
520   |
521   | #define EXTTS_BUFSIZE (PTP_BUF_TIMESTAMPS * sizeof(struct ptp_extts_event))
522   |
523   | ssize_t ptp_read(struct posix_clock_context *pccontext, uint rdflags,
524   |  char __user *buf, size_t cnt)
525   | {
526   |  struct ptp_clock *ptp =
527   |  container_of(pccontext->clk, struct ptp_clock, clock);
528   |  struct timestamp_event_queue *queue;
529   |  struct ptp_extts_event *event;
530   |  unsigned long flags;
531   | 	size_t qcnt, i;
532   |  int result;
533   |
534   | 	queue = pccontext->private_clkdata;
535   |  if (!queue) {
    1Assuming 'queue' is non-null→
    2←Taking false branch→
536   | 		result = -EINVAL;
537   |  goto exit;
538   | 	}
539   |
540   |  if (cnt % sizeof(struct ptp_extts_event) != 0) {
    3←Assuming the condition is false→
    4←Taking false branch→
541   | 		result = -EINVAL;
542   |  goto exit;
543   | 	}
544   |
545   |  if (cnt > EXTTS_BUFSIZE)
    5←Assuming the condition is false→
    6←Taking false branch→
546   | 		cnt = EXTTS_BUFSIZE;
547   |
548   |  cnt = cnt / sizeof(struct ptp_extts_event);
549   |
550   |  if (wait_event_interruptible(ptp->tsev_wq,
    7←Loop condition is false.  Exiting loop→
    8←Assuming field 'defunct' is 0→
    9←Assuming the condition is false→
    10←Taking false branch→
    11←Taking false branch→
551   |  ptp->defunct || queue_cnt(queue))) {
552   |  return -ERESTARTSYS;
553   | 	}
554   |
555   |  if (ptp->defunct11.1Field 'defunct' is 0) {
    12←Taking false branch→
556   | 		result = -ENODEV;
557   |  goto exit;
558   | 	}
559   |
560   |  event = kmalloc(EXTTS_BUFSIZE, GFP_KERNEL);
561   |  if (!event) {
    13←Assuming 'event' is non-null→
    14←Taking false branch→
562   | 		result = -ENOMEM;
563   |  goto exit;
564   | 	}
565   |
566   |  spin_lock_irqsave(&queue->lock, flags);
    15←Loop condition is false.  Exiting loop→
    16←Loop condition is false.  Exiting loop→
567   |
568   |  qcnt = queue_cnt(queue);
569   |
570   |  if (cnt > qcnt)
    17←Assuming 'cnt' is <= 'qcnt'→
    18←Taking false branch→
571   | 		cnt = qcnt;
572   |
573   |  for (i = 0; i < cnt; i++) {
    19←Assuming 'i' is >= 'cnt'→
    20←Loop condition is false. Execution continues on line 579→
574   | 		event[i] = queue->buf[queue->head];
575   |  /* Paired with READ_ONCE() in queue_cnt() */
576   |  WRITE_ONCE(queue->head, (queue->head + 1) % PTP_MAX_TIMESTAMPS);
577   | 	}
578   |
579   |  spin_unlock_irqrestore(&queue->lock, flags);
580   |
581   | 	cnt = cnt * sizeof(struct ptp_extts_event);
582   |
583   | 	result = cnt;
584   |  if (copy_to_user(buf, event, cnt)) {
    21←copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use kzalloc or memset
585   | 		result = -EFAULT;
586   |  goto free_event;
587   | 	}
588   |
589   | free_event:
590   | 	kfree(event);
591   | exit:
592   |  return result;
593   | }
