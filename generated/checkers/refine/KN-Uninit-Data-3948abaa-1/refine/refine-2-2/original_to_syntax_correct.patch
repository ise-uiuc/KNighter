--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -48,6 +48,12 @@ // Tracks the last write destination offset (in bytes) from the base region.
 REGISTER_MAP_WITH_PROGRAMSTATE(LastWriteOffsetMap, const MemRegion*, uint64_t)

+// New state to correlate memcpy len symbol with an accumulator used in copy_to_user.
+// Map: length SymbolRef used in last memcpy -> kmalloc base region written
+REGISTER_MAP_WITH_PROGRAMSTATE(LenSymToBaseMap, SymbolRef, const MemRegion*)
+// Map: kmalloc base region -> accumulator variable region (the integer that accumulates copied bytes)
+REGISTER_MAP_WITH_PROGRAMSTATE(AccumLenVarForBaseMap, const MemRegion*, const MemRegion*)
+
 // Utility function declarations (provided externally in the prompt)
 template <typename T>
 const T* findSpecificTypeInParents(const Stmt *S, CheckerContext &C);
@@ -88,6 +94,7 @@       ProgramStateRef setAllocKind(ProgramStateRef State, const MemRegion *R, unsigned Kind) const;
       bool callNamed(const CallEvent &Call, CheckerContext &C, StringRef Name) const;
       const MemRegion *getArgBaseRegion(const CallEvent &Call, unsigned Idx, CheckerContext &C) const;
+      const MemRegion *getPointeeRegionForPointerArg(const CallEvent &Call, unsigned Idx, CheckerContext &C) const;
       void noteExplicitInitLen(const CallEvent &Call, CheckerContext &C, unsigned PtrArgIndex, unsigned LenArgIndex) const;
       void reportLeak(const CallEvent &Call, CheckerContext &C, const MemRegion *SrcReg) const;

@@ -105,8 +112,11 @@       void noteWriteCallWithLen(const CallEvent &Call, CheckerContext &C, unsigned PtrArgIdx, unsigned LenArgIdx) const;

       // Additional helpers for symbol-based suppression
-      void recordSymbolicWrite(const MemRegion *DstR, SymbolRef LenSym, uint64_t Offset, CheckerContext &C) const;
+      void recordSymbolicWrite(const MemRegion *DstR, SymbolRef LenSym, std::optional<uint64_t> OffsetOpt, CheckerContext &C) const;
       bool suppressDueToLastWriteSymbol(const CallEvent &CopyToUserCall, CheckerContext &C, const MemRegion *FromReg) const;
+
+      // New FP suppression for memcpy-accumulate-copy_to_user pattern
+      bool suppressDueToAccumulatorPattern(const CallEvent &CopyToUserCall, CheckerContext &C, const MemRegion *FromReg) const;
 };

 const MemRegion *SAGenTestChecker::canonical(ProgramStateRef State, const MemRegion *R) const {
@@ -151,6 +161,8 @@   // Clear last-write symbol-based info.
   State = State->remove<LastWriteLenSymMap>(Canon);
   State = State->remove<LastWriteOffsetMap>(Canon);
+  // Clear accumulator related info.
+  State = State->remove<AccumLenVarForBaseMap>(Canon);
   return State;
 }

@@ -177,6 +189,42 @@     return nullptr;
   ProgramStateRef State = C.getState();
   return canonical(State, MR);
+}
+
+// Return the pointee region for a pointer argument to a call.
+const MemRegion *SAGenTestChecker::getPointeeRegionForPointerArg(const CallEvent &Call, unsigned Idx, CheckerContext &C) const {
+  const Expr *ArgE = Call.getArgExpr(Idx);
+  ProgramStateRef State = C.getState();
+
+  // Prefer using the expression path to get the runtime value region.
+  if (ArgE) {
+    SVal ArgSV = State->getSVal(ArgE, C.getLocationContext());
+    if (const MemRegion *AsRegion = ArgSV.getAsRegion()) {
+      // If this is already a pointee region (MemRegionVal), return it.
+      // Otherwise, if this is a region of the pointer variable, read its value.
+      if (isa<SubRegion>(AsRegion) || isa<SymbolicRegion>(AsRegion)) {
+        return AsRegion;
+      } else {
+        SValBuilder &SVB = C.getSValBuilder();
+        Loc PtrLoc = SVB.makeLoc(AsRegion);
+        SVal PointeeV = State->getSVal(PtrLoc);
+        if (const MemRegion *PointeeR = PointeeV.getAsRegion())
+          return PointeeR;
+      }
+    }
+  }
+
+  // Fallback through SVal
+  SVal PtrSV = Call.getArgSVal(Idx);
+  if (const MemRegion *PtrR = PtrSV.getAsRegion()) {
+    SValBuilder &SVB = C.getSValBuilder();
+    Loc PtrLoc = SVB.makeLoc(PtrR);
+    SVal PointeeV = State->getSVal(PtrLoc);
+    if (const MemRegion *PointeeR = PointeeV.getAsRegion())
+      return PointeeR;
+  }
+
+  return nullptr;
 }

 uint64_t SAGenTestChecker::getTypeSizeInBytes(QualType T, ASTContext &ASTC) const {
@@ -195,7 +243,12 @@                                            unsigned PtrArgIndex, unsigned LenArgIndex) const {
   ProgramStateRef State = C.getState();

-  const MemRegion *DstReg = getArgBaseRegion(Call, PtrArgIndex, C);
+  const MemRegion *DstReg = getPointeeRegionForPointerArg(Call, PtrArgIndex, C);
+  if (!DstReg)
+    return;
+
+  DstReg = DstReg->getBaseRegion();
+  DstReg = canonical(State, DstReg);
   if (!DstReg)
     return;

@@ -321,9 +374,12 @@ }

 // Compute offset to base and base region for a subregion.
+// Returns true only if a concrete byte offset is known; returns false otherwise.
 bool SAGenTestChecker::getRegionOffsetAndBase(const MemRegion *R, const MemRegion *&Base, uint64_t &ByteOffset) const {
   if (!R)
     return false;
+
+  // For explicit subregions try to compute concrete offset.
   if (const auto *SR = dyn_cast<SubRegion>(R)) {
     std::optional<RegionOffset> RO = SR->getAsOffset();
     if (!RO.has_value())
@@ -332,16 +388,21 @@     int64_t BitOff = RO->getOffset();
     if (BitOff < 0)
       return false;
+    if ((uint64_t)BitOff % 8 != 0)
+      return false; // ignore bitfield or non-byte aligned
     ByteOffset = (uint64_t)BitOff / 8;
-    // Ignore bitfield writes (non-byte-aligned)
-    if ((uint64_t)BitOff % 8 != 0)
-      return false;
     return true;
   }
-  // If it's not a SubRegion, treat it as base with zero offset.
-  Base = R->getBaseRegion();
-  ByteOffset = 0;
-  return Base != nullptr;
+
+  // If it's not a SubRegion but is the base object itself, treat as offset 0.
+  const MemRegion *B = R->getBaseRegion();
+  if (B && B == R) {
+    Base = B;
+    ByteOffset = 0;
+    return true;
+  }
+
+  return false;
 }

 // Record that [Offset, Offset+Len) bytes in the base region have been written,
@@ -385,43 +446,17 @@   C.addTransition(State);
 }

-// Try to record a direct store's effect on initialized-prefix based on the LHS region type and offset.
-void SAGenTestChecker::tryRecordDirectStore(const MemRegion *StoreR, CheckerContext &C) const {
-  if (!StoreR)
-    return;
-
-  // Skip bit-field stores; they won't give us full-byte coverage.
-  if (const auto *FR = dyn_cast<FieldRegion>(StoreR)) {
-    if (FR->getDecl()->isBitField())
-      return;
-  }
-
-  QualType VT;
-  if (const auto *TVR = dyn_cast<TypedValueRegion>(StoreR)) {
-    VT = TVR->getValueType();
-  }
-  if (VT.isNull())
-    return;
-
-  uint64_t SizeBytes = getTypeSizeInBytes(VT, C.getASTContext());
-  if (SizeBytes == 0)
-    return;
-
-  markBytesWrittenToRegion(StoreR, SizeBytes, C);
-}
-
-// Record symbolic writes for functions like memcpy/memmove/memcpy_fromio/copy_from_user when len is non-constant.
-void SAGenTestChecker::recordSymbolicWrite(const MemRegion *DstR, SymbolRef LenSym, uint64_t Offset, CheckerContext &C) const {
+// Record symbolic writes for functions like memcpy/memmove/memcpy_fromio/copy_from_user.
+// We increment write-count for the base, and only record a last offset if it is concretely known.
+void SAGenTestChecker::recordSymbolicWrite(const MemRegion *DstR, SymbolRef LenSym, std::optional<uint64_t> OffsetOpt, CheckerContext &C) const {
   if (!DstR || !LenSym)
     return;

   ProgramStateRef State = C.getState();
-  const MemRegion *Base = nullptr;
-  uint64_t Off = 0;
-  if (!getRegionOffsetAndBase(DstR, Base, Off))
-    return;
-
-  const MemRegion *CanonBase = canonical(State, Base ? Base->getBaseRegion() : nullptr);
+
+  // Identify base region even if offset is unknown.
+  const MemRegion *BaseR = DstR->getBaseRegion();
+  const MemRegion *CanonBase = canonical(State, BaseR);
   if (!CanonBase)
     return;

@@ -434,18 +469,24 @@   unsigned NewCnt = OldCnt ? (*OldCnt + 1) : 1u;
   State = State->set<WriteCountMap>(CanonBase, NewCnt);

-  // Set last write symbol and offset.
+  // Record last write len sym; record offset only if known.
   State = State->set<LastWriteLenSymMap>(CanonBase, LenSym);
-  State = State->set<LastWriteOffsetMap>(CanonBase, Off);
+  if (OffsetOpt.has_value())
+    State = State->set<LastWriteOffsetMap>(CanonBase, *OffsetOpt);
+  else
+    State = State->remove<LastWriteOffsetMap>(CanonBase);
+
+  // Remember that this length symbol was used to write into this base.
+  State = State->set<LenSymToBaseMap>(LenSym, CanonBase);

   C.addTransition(State);
 }

 // Note a write-by-call pattern like memcpy/memmove/memcpy_fromio/copy_from_user where len is provided explicitly.
 void SAGenTestChecker::noteWriteCallWithLen(const CallEvent &Call, CheckerContext &C, unsigned PtrArgIdx, unsigned LenArgIdx) const {
-  SVal DstSV = Call.getArgSVal(PtrArgIdx);
-  const MemRegion *DstR = DstSV.getAsRegion();
-  if (!DstR)
+  // Get destination pointee region of the write (not the pointer variable itself).
+  const MemRegion *DstPointeeR = getPointeeRegionForPointerArg(Call, PtrArgIdx, C);
+  if (!DstPointeeR)
     return;

   // Try constant evaluation first.
@@ -456,7 +497,7 @@     if (EvaluateExprToInt(EvalRes, LenE, C)) {
       uint64_t Len = EvalRes.getZExtValue();
       if (Len != 0) {
-        markBytesWrittenToRegion(DstR, Len, C);
+        markBytesWrittenToRegion(DstPointeeR, Len, C);
         Recorded = true;
       }
     }
@@ -468,8 +509,14 @@   // Fall back to symbol-based recording.
   SVal LenSV = Call.getArgSVal(LenArgIdx);
   if (SymbolRef LenSym = LenSV.getAsSymbol()) {
-    // Offset is computed by recordSymbolicWrite.
-    recordSymbolicWrite(DstR, LenSym, /*Offset*/0, C);
+    // Try to compute concrete offset if possible.
+    const MemRegion *Base = nullptr;
+    uint64_t Off = 0;
+    std::optional<uint64_t> OffsetOpt;
+    if (getRegionOffsetAndBase(DstPointeeR, Base, Off))
+      OffsetOpt = Off;
+
+    recordSymbolicWrite(DstPointeeR, LenSym, OffsetOpt, C);
   }
 }

@@ -600,6 +647,29 @@   return (CopyLenSym == *LastLenSymP);
 }

+// Suppress when we have seen memcpy(..., lenSym) into this base, immediately followed by "<accum> += lenSym",
+// and copy_to_user length is exactly that <accum> variable.
+bool SAGenTestChecker::suppressDueToAccumulatorPattern(const CallEvent &CopyToUserCall, CheckerContext &C, const MemRegion *FromReg) const {
+  ProgramStateRef State = C.getState();
+
+  // copy_to_user(to, from, len)
+  const Expr *LenE = CopyToUserCall.getArgExpr(2);
+  if (!LenE)
+    return false;
+
+  // The length should be a variable region (e.g., "bytes_copied").
+  const MemRegion *LenVarReg = getMemRegionFromExpr(LenE, C);
+  if (!LenVarReg)
+    return false;
+  LenVarReg = LenVarReg->getBaseRegion();
+
+  const MemRegion *const *AccumVarP = State->get<AccumLenVarForBaseMap>(FromReg);
+  if (!AccumVarP || !*AccumVarP)
+    return false;
+
+  return (*AccumVarP == LenVarReg);
+}
+
 void SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const {
   if (!callNamed(Call, C, "copy_to_user"))
     return;
@@ -625,6 +695,10 @@
   // Recognize and suppress false positives when a known producer initialized exactly the copied bytes.
   if (isFalsePositiveDueToProducer(Call, C, FromReg))
+    return;
+
+  // Suppress when there is clear memcpy-accumulator pattern: memcpy(lenSym) followed by accum += lenSym and then copying accum.
+  if (suppressDueToAccumulatorPattern(Call, C, FromReg))
     return;

   // Suppress when the most recent write into the source buffer used exactly the same length symbol from offset 0.
@@ -696,6 +770,35 @@   // Record direct store to subregions (fields/elements) to update initialized prefix.
   tryRecordDirectStore(LHS, C);

+  // Detect "accum += lenSym" immediately after memcpy(..., lenSym)
+  if (const auto *CAO = dyn_cast_or_null<CompoundAssignOperator>(StoreE)) {
+    if (CAO->getOpcode() == BO_AddAssign) {
+      // RHS symbol
+      const Expr *RHS = CAO->getRHS();
+      if (RHS) {
+        SVal RHSSV = State->getSVal(RHS, C.getLocationContext());
+        if (SymbolRef LenSym = RHSSV.getAsSymbol()) {
+          // Do we know which base was last written with this length?
+          if (const MemRegion *const *BaseP = State->get<LenSymToBaseMap>(LenSym)) {
+            const MemRegion *Base = *BaseP;
+            if (Base) {
+              // Map base -> accumulator variable region
+              const MemRegion *LBase = LHS->getBaseRegion();
+              if (LBase) {
+                const MemRegion *CanonBase = canonical(State, Base);
+                const MemRegion *CanonLBase = canonical(State, LBase);
+                if (CanonBase && CanonLBase) {
+                  State = State->set<AccumLenVarForBaseMap>(CanonBase, CanonLBase);
+                  C.addTransition(State);
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
   // Track pointer aliasing for future canonicalization.
   const MemRegion *LBase = LHS->getBaseRegion();
   const MemRegion *RHS = Val.getAsRegion();
@@ -713,6 +816,30 @@   State = State->set<PtrAliasMap>(LC, RC);
   State = State->set<PtrAliasMap>(RC, LC);
   C.addTransition(State);
+}
+
+void SAGenTestChecker::tryRecordDirectStore(const MemRegion *StoreR, CheckerContext &C) const {
+  if (!StoreR)
+    return;
+
+  // Skip bit-field stores; they won't give us full-byte coverage.
+  if (const auto *FR = dyn_cast<FieldRegion>(StoreR)) {
+    if (FR->getDecl()->isBitField())
+      return;
+  }
+
+  QualType VT;
+  if (const auto *TVR = dyn_cast<TypedValueRegion>(StoreR)) {
+    VT = TVR->getValueType();
+  }
+  if (VT.isNull())
+    return;
+
+  uint64_t SizeBytes = getTypeSizeInBytes(VT, C.getASTContext());
+  if (SizeBytes == 0)
+    return;
+
+  markBytesWrittenToRegion(StoreR, SizeBytes, C);
 }

 } // end anonymous namespace
