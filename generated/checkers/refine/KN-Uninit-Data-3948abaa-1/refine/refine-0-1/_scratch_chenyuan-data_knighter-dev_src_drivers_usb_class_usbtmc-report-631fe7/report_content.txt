### Report Summary

File:| drivers/usb/class/usbtmc.c
---|---
Warning:| line 1971, column 9
copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use
kzalloc or memset

### Annotated Source Code


1865  | capability_attribute(device_capabilities);
1866  | capability_attribute(usb488_interface_capabilities);
1867  | capability_attribute(usb488_device_capabilities);
1868  |
1869  | static struct attribute *usbtmc_attrs[] = {
1870  | 	&dev_attr_interface_capabilities.attr,
1871  | 	&dev_attr_device_capabilities.attr,
1872  | 	&dev_attr_usb488_interface_capabilities.attr,
1873  | 	&dev_attr_usb488_device_capabilities.attr,
1874  |  NULL,
1875  | };
1876  | ATTRIBUTE_GROUPS(usbtmc);
1877  |
1878  | static int usbtmc_ioctl_indicator_pulse(struct usbtmc_device_data *data)
1879  | {
1880  |  struct device *dev;
1881  | 	u8 *buffer;
1882  |  int rv;
1883  |
1884  | 	dev = &data->intf->dev;
1885  |
1886  | 	buffer = kmalloc(2, GFP_KERNEL);
1887  |  if (!buffer)
1888  |  return -ENOMEM;
1889  |
1890  | 	rv = usb_control_msg(data->usb_dev,
1891  |  usb_rcvctrlpipe(data->usb_dev, 0),
1892  |  USBTMC_REQUEST_INDICATOR_PULSE,
1893  |  USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
1894  | 			     0, 0, buffer, 0x01, USB_CTRL_GET_TIMEOUT);
1895  |
1896  |  if (rv < 0) {
1897  |  dev_err(dev, "usb_control_msg returned %d\n", rv);
1898  |  goto exit;
1899  | 	}
1900  |
1901  |  dev_dbg(dev, "INDICATOR_PULSE returned %x\n", buffer[0]);
1902  |
1903  |  if (buffer[0] != USBTMC_STATUS_SUCCESS) {
1904  |  dev_err(dev, "INDICATOR_PULSE returned %x\n", buffer[0]);
1905  | 		rv = -EPERM;
1906  |  goto exit;
1907  | 	}
1908  | 	rv = 0;
1909  |
1910  | exit:
1911  | 	kfree(buffer);
1912  |  return rv;
1913  | }
1914  |
1915  | static int usbtmc_ioctl_request(struct usbtmc_device_data *data,
1916  |  void __user *arg)
1917  | {
1918  |  struct device *dev = &data->intf->dev;
1919  |  struct usbtmc_ctrlrequest request;
1920  | 	u8 *buffer = NULL;
1921  |  int rv;
1922  |  unsigned int is_in, pipe;
1923  |  unsigned long res;
1924  |
1925  | 	res = copy_from_user(&request, arg, sizeof(struct usbtmc_ctrlrequest));
1926  |  if (res)
    5←Assuming 'res' is 0→
    6←Taking false branch→
1927  |  return -EFAULT;
1928  |
1929  |  if (request.req.wLength > USBTMC_BUFSIZE)
    7←Assuming field 'wLength' is <= USBTMC_BUFSIZE→
    8←Taking false branch→
1930  |  return -EMSGSIZE;
1931  |  if (request.req.wLength == 0)	/* Length-0 requests are never IN */
    9←Assuming field 'wLength' is not equal to 0→
    10←Taking false branch→
1932  | 		request.req.bRequestType &= ~USB_DIR_IN;
1933  |
1934  |  is_in = request.req.bRequestType & USB_DIR_IN;
1935  |
1936  |  if (request.req.wLength10.1Field 'wLength' is not equal to 0) {
    11←Taking true branch→
1937  |  buffer = kmalloc(request.req.wLength, GFP_KERNEL);
1938  |  if (!buffer)
    12←Assuming 'buffer' is non-null→
    13←Taking false branch→
1939  |  return -ENOMEM;
1940  |
1941  |  if (!is_in) {
    14←Assuming 'is_in' is not equal to 0→
    15←Taking false branch→
1942  |  /* Send control data to device */
1943  | 			res = copy_from_user(buffer, request.data,
1944  | 					     request.req.wLength);
1945  |  if (res) {
1946  | 				rv = -EFAULT;
1947  |  goto exit;
1948  | 			}
1949  | 		}
1950  | 	}
1951  |
1952  |  if (is_in15.1'is_in' is not equal to 0)
    16←Taking true branch→
1953  |  pipe = usb_rcvctrlpipe(data->usb_dev, 0);
1954  |  else
1955  | 		pipe = usb_sndctrlpipe(data->usb_dev, 0);
1956  |  rv = usb_control_msg(data->usb_dev,
1957  | 			pipe,
1958  | 			request.req.bRequest,
1959  | 			request.req.bRequestType,
1960  | 			request.req.wValue,
1961  | 			request.req.wIndex,
1962  | 			buffer, request.req.wLength, USB_CTRL_GET_TIMEOUT);
1963  |
1964  |  if (rv < 0) {
    17←Assuming 'rv' is >= 0→
1965  |  dev_err(dev, "%s failed %d\n", __func__, rv);
1966  |  goto exit;
1967  | 	}
1968  |
1969  |  if (rv && is_in18.1'is_in' is not equal to 0) {
    18←Assuming 'rv' is not equal to 0→
    19←Taking true branch→
1970  |  /* Read control data from device */
1971  |  res = copy_to_user(request.data, buffer, rv);
    20←copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use kzalloc or memset
1972  |  if (res)
1973  | 			rv = -EFAULT;
1974  | 	}
1975  |
1976  |  exit:
1977  | 	kfree(buffer);
1978  |  return rv;
1979  | }
1980  |
1981  | /*
1982  |  * Get the usb timeout value
1983  |  */
1984  | static int usbtmc_ioctl_get_timeout(struct usbtmc_file_data *file_data,
1985  |  void __user *arg)
1986  | {
1987  | 	u32 timeout;
1988  |
1989  | 	timeout = file_data->timeout;
1990  |
1991  |  return put_user(timeout, (__u32 __user *)arg);
1992  | }
1993  |
1994  | /*
1995  |  * Set the usb timeout value
1996  |  */
1997  | static int usbtmc_ioctl_set_timeout(struct usbtmc_file_data *file_data,
1998  |  void __user *arg)
1999  | {
2000  | 	u32 timeout;
2001  |
2007  |  */
2008  |  if (timeout < USBTMC_MIN_TIMEOUT)
2009  |  return -EINVAL;
2010  |
2011  | 	file_data->timeout = timeout;
2012  |
2013  |  return 0;
2014  | }
2015  |
2016  | /*
2017  |  * enables/disables sending EOM on write
2018  |  */
2019  | static int usbtmc_ioctl_eom_enable(struct usbtmc_file_data *file_data,
2020  |  void __user *arg)
2021  | {
2022  | 	u8 eom_enable;
2023  |
2024  |  if (copy_from_user(&eom_enable, arg, sizeof(eom_enable)))
2025  |  return -EFAULT;
2026  |
2027  |  if (eom_enable > 1)
2028  |  return -EINVAL;
2029  |
2030  | 	file_data->eom_val = eom_enable;
2031  |
2032  |  return 0;
2033  | }
2034  |
2035  | /*
2036  |  * Configure termination character for read()
2037  |  */
2038  | static int usbtmc_ioctl_config_termc(struct usbtmc_file_data *file_data,
2039  |  void __user *arg)
2040  | {
2041  |  struct usbtmc_termchar termc;
2042  |
2043  |  if (copy_from_user(&termc, arg, sizeof(termc)))
2044  |  return -EFAULT;
2045  |
2046  |  if ((termc.term_char_enabled > 1) ||
2047  | 		(termc.term_char_enabled &&
2048  | 		!(file_data->data->capabilities.device_capabilities & 1)))
2049  |  return -EINVAL;
2050  |
2051  | 	file_data->term_char = termc.term_char;
2052  | 	file_data->term_char_enabled = termc.term_char_enabled;
2053  |
2054  |  return 0;
2055  | }
2056  |
2057  | static long usbtmc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
2058  | {
2059  |  struct usbtmc_file_data *file_data;
2060  |  struct usbtmc_device_data *data;
2061  |  int retval = -EBADRQC;
2062  | 	__u8 tmp_byte;
2063  |
2064  | 	file_data = file->private_data;
2065  | 	data = file_data->data;
2066  |
2067  |  mutex_lock(&data->io_mutex);
2068  |  if (data->zombie) {
    1Assuming field 'zombie' is false→
    2←Taking false branch→
2069  | 		retval = -ENODEV;
2070  |  goto skip_io_on_zombie;
2071  | 	}
2072  |
2073  |  switch (cmd) {
    3←Control jumps to 'case 3222297352:'  at line 2098→
2074  |  case USBTMC_IOCTL_CLEAR_OUT_HALT:
2075  | 		retval = usbtmc_ioctl_clear_out_halt(data);
2076  |  break;
2077  |
2078  |  case USBTMC_IOCTL_CLEAR_IN_HALT:
2079  | 		retval = usbtmc_ioctl_clear_in_halt(data);
2080  |  break;
2081  |
2082  |  case USBTMC_IOCTL_INDICATOR_PULSE:
2083  | 		retval = usbtmc_ioctl_indicator_pulse(data);
2084  |  break;
2085  |
2086  |  case USBTMC_IOCTL_CLEAR:
2087  | 		retval = usbtmc_ioctl_clear(data);
2088  |  break;
2089  |
2090  |  case USBTMC_IOCTL_ABORT_BULK_OUT:
2091  | 		retval = usbtmc_ioctl_abort_bulk_out(data);
2092  |  break;
2093  |
2094  |  case USBTMC_IOCTL_ABORT_BULK_IN:
2095  | 		retval = usbtmc_ioctl_abort_bulk_in(data);
2096  |  break;
2097  |
2098  |  case USBTMC_IOCTL_CTRL_REQUEST:
2099  |  retval = usbtmc_ioctl_request(data, (void __user *)arg);
    4←Calling 'usbtmc_ioctl_request'→
2100  |  break;
2101  |
2102  |  case USBTMC_IOCTL_GET_TIMEOUT:
2103  | 		retval = usbtmc_ioctl_get_timeout(file_data,
2104  | 						  (void __user *)arg);
2105  |  break;
2106  |
2107  |  case USBTMC_IOCTL_SET_TIMEOUT:
2108  | 		retval = usbtmc_ioctl_set_timeout(file_data,
2109  | 						  (void __user *)arg);
2110  |  break;
2111  |
2112  |  case USBTMC_IOCTL_EOM_ENABLE:
2113  | 		retval = usbtmc_ioctl_eom_enable(file_data,
2114  | 						 (void __user *)arg);
2115  |  break;
2116  |
2117  |  case USBTMC_IOCTL_CONFIG_TERMCHAR:
2118  | 		retval = usbtmc_ioctl_config_termc(file_data,
2119  | 						   (void __user *)arg);
2120  |  break;
2121  |
2122  |  case USBTMC_IOCTL_WRITE:
2123  | 		retval = usbtmc_ioctl_generic_write(file_data,
2124  | 						    (void __user *)arg);
2125  |  break;
2126  |
2127  |  case USBTMC_IOCTL_READ:
2128  | 		retval = usbtmc_ioctl_generic_read(file_data,
2129  | 						   (void __user *)arg);
