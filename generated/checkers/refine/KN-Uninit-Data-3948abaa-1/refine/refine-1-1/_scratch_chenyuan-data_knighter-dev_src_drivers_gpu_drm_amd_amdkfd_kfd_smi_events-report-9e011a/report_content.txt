### Report Summary

File:| drivers/gpu/drm/amd/amdgpu/../amdkfd/kfd_smi_events.c
---|---
Warning:| line 111, column 8
copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use
kzalloc or memset

### Annotated Source Code


30    | #include "kfd_priv.h"
31    | #include "kfd_smi_events.h"
32    |
33    | struct kfd_smi_client {
34    |  struct list_head list;
35    |  struct kfifo fifo;
36    | 	wait_queue_head_t wait_queue;
37    |  /* events enabled */
38    | 	uint64_t events;
39    |  struct kfd_node *dev;
40    | 	spinlock_t lock;
41    |  struct rcu_head rcu;
42    | 	pid_t pid;
43    | 	bool suser;
44    | };
45    |
46    | #define MAX_KFIFO_SIZE	1024
47    |
48    | static __poll_t kfd_smi_ev_poll(struct file *, struct poll_table_struct *);
49    | static ssize_t kfd_smi_ev_read(struct file *, char __user *, size_t, loff_t *);
50    | static ssize_t kfd_smi_ev_write(struct file *, const char __user *, size_t,
51    | 				loff_t *);
52    | static int kfd_smi_ev_release(struct inode *, struct file *);
53    |
54    | static const char kfd_smi_name[] = "kfd_smi_ev";
55    |
56    | static const struct file_operations kfd_smi_ev_fops = {
57    | 	.owner = THIS_MODULE,
58    | 	.poll = kfd_smi_ev_poll,
59    | 	.read = kfd_smi_ev_read,
60    | 	.write = kfd_smi_ev_write,
61    | 	.release = kfd_smi_ev_release
62    | };
63    |
64    | static __poll_t kfd_smi_ev_poll(struct file *filep,
65    |  struct poll_table_struct *wait)
66    | {
67    |  struct kfd_smi_client *client = filep->private_data;
68    | 	__poll_t mask = 0;
69    |
70    | 	poll_wait(filep, &client->wait_queue, wait);
71    |
72    | 	spin_lock(&client->lock);
73    |  if (!kfifo_is_empty(&client->fifo))
74    | 		mask = EPOLLIN | EPOLLRDNORM;
75    | 	spin_unlock(&client->lock);
76    |
77    |  return mask;
78    | }
79    |
80    | static ssize_t kfd_smi_ev_read(struct file *filep, char __user *user,
81    | 			       size_t size, loff_t *offset)
82    | {
83    |  int ret;
84    | 	size_t to_copy;
85    |  struct kfd_smi_client *client = filep->private_data;
86    |  unsigned char *buf;
87    |
88    |  size = min_t(size_t, size, MAX_KFIFO_SIZE);
    1Assuming '__UNIQUE_ID___x1344' is >= '__UNIQUE_ID___y1345'→
    2←'?' condition is false→
89    | 	buf = kmalloc(size, GFP_KERNEL);
90    |  if (!buf)
    3←Assuming 'buf' is non-null→
    4←Taking false branch→
91    |  return -ENOMEM;
92    |
93    |  /* kfifo_to_user can sleep so we can't use spinlock protection around
94    |  * it. Instead, we kfifo out as spinlocked then copy them to the user.
95    |  */
96    |  spin_lock(&client->lock);
97    | 	to_copy = kfifo_len(&client->fifo);
98    |  if (!to_copy) {
    5←Assuming 'to_copy' is not equal to 0→
    6←Taking false branch→
99    | 		spin_unlock(&client->lock);
100   | 		ret = -EAGAIN;
101   |  goto ret_err;
102   | 	}
103   |  to_copy = min(size, to_copy);
    7←Assuming '__UNIQUE_ID___x1346' is >= '__UNIQUE_ID___y1347'→
    8←'?' condition is false→
104   |  ret = kfifo_out(&client->fifo, buf, to_copy);
    9←'?' condition is false→
105   | 	spin_unlock(&client->lock);
106   |  if (ret <= 0) {
    10←Assuming 'ret' is > 0→
    11←Taking false branch→
107   | 		ret = -EAGAIN;
108   |  goto ret_err;
109   | 	}
110   |
111   |  ret = copy_to_user(user, buf, to_copy);
    12←copy_to_user may leak uninitialized kernel memory from kmalloc buffer; use kzalloc or memset
112   |  if (ret) {
113   | 		ret = -EFAULT;
114   |  goto ret_err;
115   | 	}
116   |
117   | 	kfree(buf);
118   |  return to_copy;
119   |
120   | ret_err:
121   | 	kfree(buf);
122   |  return ret;
123   | }
124   |
125   | static ssize_t kfd_smi_ev_write(struct file *filep, const char __user *user,
126   | 				size_t size, loff_t *offset)
127   | {
128   |  struct kfd_smi_client *client = filep->private_data;
129   | 	uint64_t events;
130   |
131   |  if (!access_ok(user, size) || size < sizeof(events))
132   |  return -EFAULT;
133   |  if (copy_from_user(&events, user, sizeof(events)))
134   |  return -EFAULT;
135   |
136   |  WRITE_ONCE(client->events, events);
137   |
138   |  return sizeof(events);
139   | }
140   |
141   | static void kfd_smi_ev_client_free(struct rcu_head *p)
