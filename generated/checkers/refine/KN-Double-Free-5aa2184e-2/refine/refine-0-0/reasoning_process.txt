Refinement Plan:
- Root cause: The checker flags any kfree of a parameter’s field inside a shared error label unless it can prove the function owns it. In the false positive, dd->port is allocated in the same function with kzalloc_node, but the checker did not recognize kzalloc_node as an allocator and thus failed to mark ownership. Additionally, on paths that jump to the label before the assignment executes, there’s no path-sensitive ownership state, even though this function clearly manages dd->port.
- Fixes:
  1) Recognize more kernel allocator names (including kzalloc_node, kmalloc_node, kcalloc_node, kmalloc_array, etc.) so path-sensitive ownership is marked when binding the allocator result.
  2) Add a per-function AST pre-scan that records fields directly assigned from allocator calls (e.g., dd->port = kzalloc_node(...)). Use this as a path-insensitive ownership hint to suppress warnings in shared labels even if the specific path didn’t execute the assignment.
  3) Add a consolidated isFalsePositive(...) that also suppresses when argument is proven NULL or when program state indicates ownership.
- Edge cases and regressions:
  - The new suppression only applies if a field is directly assigned from an allocator inside the same function. The original target bug (mt->fc) has no such direct assignment; the field is managed by a callee and freed on a shared label. We still report it.
  - We maintain the existing shared-label requirement and ownership tracking to avoid muting real positives.
  - Keep compatibility with Clang-18 APIs and do not remove any includes.

Refined Code:
```cpp
```
