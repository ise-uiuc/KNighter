### Report Summary

File:| fs/isofs/rock.c
---|---
Warning:| line 130, column 2
Freeing unowned field in shared error label; possible double free

### Annotated Source Code


3     |  *  linux/fs/isofs/rock.c
4     |  *
5     |  *  (C) 1992, 1993  Eric Youngdale
6     |  *
7     |  *  Rock Ridge Extensions to iso9660
8     |  */
9     |
10    | #include <linux/slab.h>
11    | #include <linux/pagemap.h>
12    |
13    | #include "isofs.h"
14    | #include "rock.h"
15    |
16    | /*
17    |  * These functions are designed to read the system areas of a directory record
18    |  * and extract relevant information.  There are different functions provided
19    |  * depending upon what information we need at the time.  One function fills
20    |  * out an inode structure, a second one extracts a filename, a third one
21    |  * returns a symbolic link name, and a fourth one returns the extent number
22    |  * for the file.
23    |  */
24    |
25    | #define SIG(A,B) ((A) | ((B) << 8))	/* isonum_721() */
26    |
27    | struct rock_state {
28    |  void *buffer;
29    |  unsigned char *chr;
30    |  int len;
31    |  int cont_size;
32    |  int cont_extent;
33    |  int cont_offset;
34    |  int cont_loops;
35    |  struct inode *inode;
36    | };
37    |
38    | /*
39    |  * This is a way of ensuring that we have something in the system
40    |  * use fields that is compatible with Rock Ridge.  Return zero on success.
41    |  */
42    |
43    | static int check_sp(struct rock_ridge *rr, struct inode *inode)
44    | {
45    |  if (rr->u.SP.magic[0] != 0xbe)
46    |  return -1;
47    |  if (rr->u.SP.magic[1] != 0xef)
48    |  return -1;
49    | 	ISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;
50    |  return 0;
51    | }
52    |
53    | static void setup_rock_ridge(struct iso_directory_record *de,
54    |  struct inode *inode, struct rock_state *rs)
55    | {
56    | 	rs->len = sizeof(struct iso_directory_record) + de->name_len[0];
57    |  if (rs->len & 1)
58    | 		(rs->len)++;
59    | 	rs->chr = (unsigned char *)de + rs->len;
60    | 	rs->len = *((unsigned char *)de) - rs->len;
61    |  if (rs->len < 0)
62    | 		rs->len = 0;
63    |
64    |  if (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {
65    | 		rs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;
66    | 		rs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;
67    |  if (rs->len < 0)
68    | 			rs->len = 0;
69    | 	}
70    | }
71    |
72    | static void init_rock_state(struct rock_state *rs, struct inode *inode)
73    | {
74    |  memset(rs, 0, sizeof(*rs));
75    | 	rs->inode = inode;
76    | }
77    |
78    | /* Maximum number of Rock Ridge continuation entries */
79    | #define RR_MAX_CE_ENTRIES 32
80    |
81    | /*
82    |  * Returns 0 if the caller should continue scanning, 1 if the scan must end
83    |  * and -ve on error.
84    |  */
85    | static int rock_continue(struct rock_state *rs)
86    | {
87    |  int ret = 1;
88    |  int blocksize = 1 << rs->inode->i_blkbits;
    10←Assuming right operand of bit shift is less than 32→
89    |  const int min_de_size = offsetof(struct rock_ridge, u);
90    |
91    | 	kfree(rs->buffer);
92    | 	rs->buffer = NULL;
93    |
94    |  if ((unsigned)rs->cont_offset > blocksize - min_de_size ||
    11←Assuming the condition is false→
    14←Taking false branch→
95    |  (unsigned)rs->cont_size > blocksize ||
    12←Assuming 'blocksize' is >= field 'cont_size'→
96    |  (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {
    13←Assuming the condition is false→
97    |  printk(KERN_NOTICE "rock: corrupted directory entry. "
98    |  "extent=%d, offset=%d, size=%d\n",
99    |  rs->cont_extent, rs->cont_offset, rs->cont_size);
100   | 		ret = -EIO;
101   |  goto out;
102   | 	}
103   |
104   |  if (rs->cont_extent) {
    15←Assuming field 'cont_extent' is not equal to 0→
    16←Taking true branch→
105   |  struct buffer_head *bh;
106   |
107   | 		rs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);
108   |  if (!rs->buffer) {
    17←Assuming field 'buffer' is non-null→
    18←Taking false branch→
109   | 			ret = -ENOMEM;
110   |  goto out;
111   | 		}
112   |  ret = -EIO;
113   |  if (++rs->cont_loops >= RR_MAX_CE_ENTRIES)
    19←Assuming the condition is true→
    20←Taking true branch→
114   |  goto out;
    21←Control jumps to line 130→
115   | 		bh = sb_bread(rs->inode->i_sb, rs->cont_extent);
116   |  if (bh) {
117   |  memcpy(rs->buffer, bh->b_data + rs->cont_offset,
118   |  rs->cont_size);
119   | 			put_bh(bh);
120   | 			rs->chr = rs->buffer;
121   | 			rs->len = rs->cont_size;
122   | 			rs->cont_extent = 0;
123   | 			rs->cont_size = 0;
124   | 			rs->cont_offset = 0;
125   |  return 0;
126   | 		}
127   |  printk("Unable to read rock-ridge attributes\n");
128   | 	}
129   | out:
130   |  kfree(rs->buffer);
    22←Freeing unowned field in shared error label; possible double free
131   | 	rs->buffer = NULL;
132   |  return ret;
133   | }
134   |
135   | /*
136   |  * We think there's a record of type `sig' at rs->chr.  Parse the signature
137   |  * and make sure that there's really room for a record of that type.
138   |  */
139   | static int rock_check_overflow(struct rock_state *rs, int sig)
140   | {
141   |  int len;
142   |
143   |  switch (sig) {
144   |  case SIG('S', 'P'):
145   | 		len = sizeof(struct SU_SP_s);
146   |  break;
147   |  case SIG('C', 'E'):
148   | 		len = sizeof(struct SU_CE_s);
149   |  break;
150   |  case SIG('E', 'R'):
151   | 		len = sizeof(struct SU_ER_s);
152   |  break;
153   |  case SIG('R', 'R'):
154   | 		len = sizeof(struct RR_RR_s);
155   |  break;
156   |  case SIG('P', 'X'):
157   | 		len = sizeof(struct RR_PX_s);
158   |  break;
159   |  case SIG('P', 'N'):
160   | 		len = sizeof(struct RR_PN_s);
639   | 		slp = (struct SL_component *)((char *)slp + slp->len + 2);
640   |
641   |  if (slen < 2) {
642   |  /*
643   |  * If there is another SL record, and this component
644   |  * record isn't continued, then add a slash.
645   |  */
646   |  if ((!rootflag) && (rr->u.SL.flags & 1) &&
647   | 			    !(oldslp->flags & 1)) {
648   |  if (rpnt >= plimit)
649   |  return NULL;
650   | 				*rpnt++ = '/';
651   | 			}
652   |  break;
653   | 		}
654   |
655   |  /*
656   |  * If this component record isn't continued, then append a '/'.
657   |  */
658   |  if (!rootflag && !(oldslp->flags & 1)) {
659   |  if (rpnt >= plimit)
660   |  return NULL;
661   | 			*rpnt++ = '/';
662   | 		}
663   | 	}
664   |  return rpnt;
665   | }
666   |
667   | int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,
668   |  int relocated)
669   | {
670   |  int flags = relocated ? RR_RELOC_DE : 0;
671   |  int result = parse_rock_ridge_inode_internal(de, inode, flags);
672   |
673   |  /*
674   |  * if rockridge flag was reset and we didn't look for attributes
675   |  * behind eventual XA attributes, have a look there
676   |  */
677   |  if ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)
678   | 	    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {
679   | 		result = parse_rock_ridge_inode_internal(de, inode,
680   | 							 flags | RR_REGARD_XA);
681   | 	}
682   |  return result;
683   | }
684   |
685   | /*
686   |  * read_folio() for symlinks: reads symlink contents into the folio and either
687   |  * makes it uptodate and returns 0 or returns error (-EIO)
688   |  */
689   | static int rock_ridge_symlink_read_folio(struct file *file, struct folio *folio)
690   | {
691   |  struct page *page = &folio->page;
692   |  struct inode *inode = page->mapping->host;
693   |  struct iso_inode_info *ei = ISOFS_I(inode);
694   |  struct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);
695   |  char *link = page_address(page);
696   |  unsigned long bufsize = ISOFS_BUFFER_SIZE(inode);
697   |  struct buffer_head *bh;
698   |  char *rpnt = link;
699   |  unsigned char *pnt;
700   |  struct iso_directory_record *raw_de;
701   |  unsigned long block, offset;
702   |  int sig;
703   |  struct rock_ridge *rr;
704   |  struct rock_state rs;
705   |  int ret;
706   |
707   |  if (!sbi->s_rock)
    1Assuming field 's_rock' is not equal to 0→
    2←Taking false branch→
708   |  goto error;
709   |
710   |  init_rock_state(&rs, inode);
711   | 	block = ei->i_iget5_block;
712   | 	bh = sb_bread(inode->i_sb, block);
713   |  if (!bh)
    3←Assuming 'bh' is non-null→
    4←Taking false branch→
714   |  goto out_noread;
715   |
716   |  offset = ei->i_iget5_offset;
717   | 	pnt = (unsigned char *)bh->b_data + offset;
718   |
719   | 	raw_de = (struct iso_directory_record *)pnt;
720   |
721   |  /*
722   |  * If we go past the end of the buffer, there is some sort of error.
723   |  */
724   |  if (offset + *pnt > bufsize)
    5←Assuming the condition is false→
    6←Taking false branch→
725   |  goto out_bad_span;
726   |
727   |  /*
728   |  * Now test for possible Rock Ridge extensions which will override
729   |  * some of these numbers in the inode structure.
730   |  */
731   |
732   |  setup_rock_ridge(raw_de, inode, &rs);
733   |
734   | repeat:
735   |  while (rs.len > 2) { /* There may be one byte for padding somewhere */
    7←Assuming field 'len' is <= 2→
    8←Loop condition is false. Execution continues on line 772→
736   | 		rr = (struct rock_ridge *)rs.chr;
737   |  if (rr->len < 3)
738   |  goto out;	/* Something got screwed up here */
739   | 		sig = isonum_721(rs.chr);
740   |  if (rock_check_overflow(&rs, sig))
741   |  goto out;
742   | 		rs.chr += rr->len;
743   | 		rs.len -= rr->len;
744   |  if (rs.len < 0)
745   |  goto out;	/* corrupted isofs */
746   |
747   |  switch (sig) {
748   |  case SIG('R', 'R'):
749   |  if ((rr->u.RR.flags[0] & RR_SL) == 0)
750   |  goto out;
751   |  break;
752   |  case SIG('S', 'P'):
753   |  if (check_sp(rr, inode))
754   |  goto out;
755   |  break;
756   |  case SIG('S', 'L'):
757   | 			rpnt = get_symlink_chunk(rpnt, rr,
758   | 						 link + (PAGE_SIZE - 1));
759   |  if (rpnt == NULL)
760   |  goto out;
761   |  break;
762   |  case SIG('C', 'E'):
763   |  /* This tells is if there is a continuation record */
764   | 			rs.cont_extent = isonum_733(rr->u.CE.extent);
765   | 			rs.cont_offset = isonum_733(rr->u.CE.offset);
766   | 			rs.cont_size = isonum_733(rr->u.CE.size);
767   |  break;
768   |  default:
769   |  break;
770   | 		}
771   | 	}
772   |  ret = rock_continue(&rs);
    9←Calling 'rock_continue'→
773   |  if (ret == 0)
774   |  goto repeat;
775   |  if (ret < 0)
776   |  goto fail;
777   |
778   |  if (rpnt == link)
779   |  goto fail;
780   | 	brelse(bh);
781   | 	*rpnt = '\0';
782   | 	SetPageUptodate(page);
783   | 	unlock_page(page);
784   |  return 0;
785   |
786   |  /* error exit from macro */
787   | out:
788   | 	kfree(rs.buffer);
789   |  goto fail;
790   | out_noread:
791   |  printk("unable to read i-node block");
792   |  goto fail;
793   | out_bad_span:
794   |  printk("symlink spans iso9660 blocks\n");
795   | fail:
796   | 	brelse(bh);
797   | error:
798   | 	SetPageError(page);
799   | 	unlock_page(page);
800   |  return -EIO;
801   | }
802   |
