Refinement Plan:
- Root cause: The checker treated any field freed in a shared error label as suspicious, without distinguishing between fields of function parameters (callee-managed/externally owned) and fields of local on-stack objects (owned by the current function). This led to a false positive in map_write() for kfree(new_map.forward) and kfree(new_map.reverse), which are fields of a local struct new_map.
- Fixes:
  - Gate reporting to only consider frees of fields whose ultimate base is a function parameter (e.g., mt->fc). This matches the buggy pattern and excludes locals like new_map.forward.
  - Strengthen base resolution to walk through nested MemberExpr and unary operators, so we correctly identify the ultimate base (parameter vs. local).
  - Keep existing path-sensitive ownership tracking and label/goto analysis. Add an additional false-positive guard: if the freed field belongs to a local automatic variable, suppress the warning.
  - Keep heuristic suppression when all gotos to the label occur after the earliest local allocator assignment to the field.
  - Improve free-call and allocator-call identification using the CallEventâ€™s callee identifier when possible, retaining the existing source-text fallback.
- Edge cases/regressions:
  - Deep member chains (e.g., mt->sub.fc) are now handled by walking to the ultimate base.
  - Suppression remains if the argument is definitely NULL (kfree(NULL)).
  - Ownership inference continues to work via AllocSymSet/OwnedRegionSet; no change in API usage, compatible with Clang-18.
  - The target buggy code (kfree(mt->fc) under a shared label) still triggers because the base is a function parameter, and there are multiple gotos into the label before any proven allocation.

Refined Code:
```cpp
```
