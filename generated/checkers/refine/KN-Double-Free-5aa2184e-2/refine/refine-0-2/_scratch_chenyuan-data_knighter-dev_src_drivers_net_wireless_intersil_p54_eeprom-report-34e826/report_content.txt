### Report Summary

File:| drivers/net/wireless/intersil/p54/eeprom.c
---|---
Warning:| line 932, column 2
Freeing unowned field in shared error label; possible double free

### Annotated Source Code


679   |  return -EINVAL;
680   |
681   | 	priv->output_limit = kmalloc(data[1] *
682   |  sizeof(struct pda_channel_output_limit) +
683   |  sizeof(*priv->output_limit), GFP_KERNEL);
684   |
685   |  if (!priv->output_limit)
686   |  return -ENOMEM;
687   |
688   | 	priv->output_limit->offset = 0;
689   | 	priv->output_limit->entries = data[1];
690   | 	priv->output_limit->entry_size =
691   |  sizeof(struct pda_channel_output_limit);
692   | 	priv->output_limit->len = priv->output_limit->entry_size *
693   | 				  priv->output_limit->entries +
694   | 				  priv->output_limit->offset;
695   |
696   |  memcpy(priv->output_limit->data, &data[2],
697   |  data[1] * sizeof(struct pda_channel_output_limit));
698   |
699   |  return 0;
700   | }
701   |
702   | static struct p54_cal_database *p54_convert_db(struct pda_custom_wrapper *src,
703   | 					       size_t total_len)
704   | {
705   |  struct p54_cal_database *dst;
706   | 	size_t payload_len, entries, entry_size, offset;
707   |
708   | 	payload_len = le16_to_cpu(src->len);
709   | 	entries = le16_to_cpu(src->entries);
710   | 	entry_size = le16_to_cpu(src->entry_size);
711   | 	offset = le16_to_cpu(src->offset);
712   |  if (((entries * entry_size + offset) != payload_len) ||
713   | 	     (payload_len + sizeof(*src) != total_len))
714   |  return NULL;
715   |
716   | 	dst = kmalloc(sizeof(*dst) + payload_len, GFP_KERNEL);
717   |  if (!dst)
718   |  return NULL;
719   |
720   | 	dst->entries = entries;
721   | 	dst->entry_size = entry_size;
722   | 	dst->offset = offset;
723   | 	dst->len = payload_len;
724   |
725   |  memcpy(dst->data, src->data, payload_len);
726   |  return dst;
727   | }
728   |
729   | int p54_parse_eeprom(struct ieee80211_hw *dev, void *eeprom, int len)
730   | {
731   |  struct p54_common *priv = dev->priv;
732   |  struct eeprom_pda_wrap *wrap;
733   |  struct pda_entry *entry;
734   |  unsigned int data_len, entry_len;
735   |  void *tmp;
736   |  int err;
737   | 	u8 *end = (u8 *)eeprom + len;
738   | 	u16 synth = 0;
739   | 	u16 crc16 = ~0;
740   |
741   | 	wrap = (struct eeprom_pda_wrap *) eeprom;
742   | 	entry = (void *)wrap->data + le16_to_cpu(wrap->len);
743   |
744   |  /* verify that at least the entry length/code fits */
745   |  while ((u8 *)entry <= end - sizeof(*entry)) {
746   | 		entry_len = le16_to_cpu(entry->len);
747   | 		data_len = ((entry_len - 1) << 1);
748   |
749   |  /* abort if entry exceeds whole structure */
750   |  if ((u8 *)entry + sizeof(*entry) + data_len > end)
751   |  break;
752   |
753   |  switch (le16_to_cpu(entry->code)) {
754   |  case PDR_MAC_ADDRESS:
755   |  if (data_len != ETH_ALEN)
756   |  break;
757   | 			SET_IEEE80211_PERM_ADDR(dev, entry->data);
758   |  break;
759   |  case PDR_PRISM_PA_CAL_OUTPUT_POWER_LIMITS:
760   |  if (priv->output_limit)
761   |  break;
762   | 			err = p54_convert_output_limits(dev, entry->data,
763   | 							data_len);
764   |  if (err)
765   |  goto err;
766   |  break;
767   |  case PDR_PRISM_PA_CAL_CURVE_DATA: {
768   |  struct pda_pa_curve_data *curve_data =
769   | 				(struct pda_pa_curve_data *)entry->data;
770   |  if (data_len < sizeof(*curve_data)) {
771   | 				err = -EINVAL;
772   |  goto err;
773   | 			}
774   |
775   |  switch (curve_data->cal_method_rev) {
832   |  int i;
833   |
834   |  if (priv->rssi_db || data_len < sizeof(*pda))
835   |  break;
836   |
837   | 			priv->rssi_db = p54_convert_db(pda, data_len);
838   |  if (!priv->rssi_db)
839   |  break;
840   |
841   | 			src = (void *) priv->rssi_db->data;
842   | 			dst = (void *) priv->rssi_db->data;
843   |
844   |  for (i = 0; i < priv->rssi_db->entries; i++)
845   | 				*(dst++) = (s16) le16_to_cpu(*(src++));
846   |
847   | 			}
848   |  break;
849   |  case PDR_PRISM_PA_CAL_OUTPUT_POWER_LIMITS_CUSTOM: {
850   |  struct pda_custom_wrapper *pda = (void *) entry->data;
851   |  if (priv->output_limit || data_len < sizeof(*pda))
852   |  break;
853   | 			priv->output_limit = p54_convert_db(pda, data_len);
854   | 			}
855   |  break;
856   |  case PDR_PRISM_PA_CAL_CURVE_DATA_CUSTOM: {
857   |  struct pda_custom_wrapper *pda = (void *) entry->data;
858   |  if (priv->curve_data || data_len < sizeof(*pda))
859   |  break;
860   | 			priv->curve_data = p54_convert_db(pda, data_len);
861   | 			}
862   |  break;
863   |  case PDR_END:
864   | 			crc16 = ~crc_ccitt(crc16, (u8 *) entry, sizeof(*entry));
865   |  if (crc16 != le16_to_cpup((__le16 *)entry->data)) {
866   |  wiphy_err(dev->wiphy, "eeprom failed checksum "
867   |  "test!\n");
868   | 				err = -ENOMSG;
869   |  goto err;
870   | 			} else {
871   |  goto good_eeprom;
872   | 			}
873   |  break;
874   |  default:
875   |  break;
876   | 		}
877   |
878   | 		crc16 = crc_ccitt(crc16, (u8 *)entry, (entry_len + 1) * 2);
879   | 		entry = (void *)entry + (entry_len + 1) * 2;
880   | 	}
881   |
882   |  wiphy_err(dev->wiphy, "unexpected end of eeprom data.\n");
    1Loop condition is false. Execution continues on line 882→
    2←Taking true branch→
    3←'?' condition is true→
    4←'?' condition is true→
    5←Loop condition is false.  Exiting loop→
883   | 	err = -ENODATA;
884   |  goto err;
    6←Control jumps to line 932→
885   |
886   | good_eeprom:
887   |  if (!synth || !priv->iq_autocal || !priv->output_limit ||
888   | 	    !priv->curve_data) {
889   |  wiphy_err(dev->wiphy,
890   |  "not all required entries found in eeprom!\n");
891   | 		err = -EINVAL;
892   |  goto err;
893   | 	}
894   |
895   | 	priv->rxhw = synth & PDR_SYNTH_FRONTEND_MASK;
896   |
897   | 	err = p54_generate_channel_lists(dev);
898   |  if (err)
899   |  goto err;
900   |
901   |  if (priv->rxhw == PDR_SYNTH_FRONTEND_XBOW)
902   | 		p54_init_xbow_synth(priv);
903   |  if (!(synth & PDR_SYNTH_24_GHZ_DISABLED))
904   | 		dev->wiphy->bands[NL80211_BAND_2GHZ] =
905   | 			priv->band_table[NL80211_BAND_2GHZ];
906   |  if (!(synth & PDR_SYNTH_5_GHZ_DISABLED))
907   | 		dev->wiphy->bands[NL80211_BAND_5GHZ] =
908   | 			priv->band_table[NL80211_BAND_5GHZ];
909   |  if ((synth & PDR_SYNTH_RX_DIV_MASK) == PDR_SYNTH_RX_DIV_SUPPORTED)
910   | 		priv->rx_diversity_mask = 3;
911   |  if ((synth & PDR_SYNTH_TX_DIV_MASK) == PDR_SYNTH_TX_DIV_SUPPORTED)
912   | 		priv->tx_diversity_mask = 3;
913   |
914   |  if (!is_valid_ether_addr(dev->wiphy->perm_addr)) {
915   | 		u8 perm_addr[ETH_ALEN];
916   |
917   |  wiphy_warn(dev->wiphy,
918   |  "Invalid hwaddr! Using randomly generated MAC addr\n");
919   | 		eth_random_addr(perm_addr);
920   | 		SET_IEEE80211_PERM_ADDR(dev, perm_addr);
921   | 	}
922   |
923   | 	priv->cur_rssi = &p54_rssi_default;
924   |
925   |  wiphy_info(dev->wiphy, "hwaddr %pM, MAC:isl38%02x RF:%s\n",
926   |  dev->wiphy->perm_addr, priv->version,
927   |  p54_rf_chips[priv->rxhw]);
928   |
929   |  return 0;
930   |
931   | err:
932   |  kfree(priv->iq_autocal);
    7←Freeing unowned field in shared error label; possible double free
933   | 	kfree(priv->output_limit);
934   | 	kfree(priv->curve_data);
935   | 	kfree(priv->rssi_db);
936   | 	kfree(priv->survey);
937   | 	priv->iq_autocal = NULL;
938   | 	priv->output_limit = NULL;
939   | 	priv->curve_data = NULL;
940   | 	priv->rssi_db = NULL;
941   | 	priv->survey = NULL;
942   |
943   |  wiphy_err(dev->wiphy, "eeprom parse failed!\n");
944   |  return err;
945   | }
946   | EXPORT_SYMBOL_GPL(p54_parse_eeprom);
947   |
948   | int p54_read_eeprom(struct ieee80211_hw *dev)
949   | {
950   |  struct p54_common *priv = dev->priv;
951   | 	size_t eeprom_size = 0x2020, offset = 0, blocksize, maxblocksize;
952   |  int ret = -ENOMEM;
953   |  void *eeprom;
954   |
955   | 	maxblocksize = EEPROM_READBACK_LEN;
956   |  if (priv->fw_var >= 0x509)
957   | 		maxblocksize -= 0xc;
958   |  else
959   | 		maxblocksize -= 0x4;
960   |
961   | 	eeprom = kzalloc(eeprom_size, GFP_KERNEL);
962   |  if (unlikely(!eeprom))
