--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -54,7 +54,7 @@
 public:
   SAGenTestChecker()
-      : BT(new BugType(this, "Double free in shared error label", "Memory Management")) {}
+      : BT(new BugType(this, "Freeing unowned field in shared error label; possible double free", "Memory Management")) {}

   void checkBeginFunction(CheckerContext &C) const;
   void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;
@@ -154,8 +154,12 @@   bool isAllocatorCall(const CallEvent &Call, CheckerContext &C) const;
   bool isFreeLikeCall(const CallEvent &Call, CheckerContext &C) const;

+  // Returns true if the reported scenario is a false positive and should be suppressed.
   bool isFalsePositive(const MemberExpr *FreedME, const CallEvent &Call,
                        const LabelStmt *EnclosingLabel, CheckerContext &C) const;
+
+  // Gating heuristic: return the ParmVarDecl if the base of a MemberExpr resolves directly to a function parameter.
+  const ParmVarDecl *getDirectBaseParam(const Expr *BaseE) const;

   void reportFreeUnownedInSharedLabel(const CallEvent &Call, CheckerContext &C) const;
 };
@@ -201,7 +205,6 @@   if (!E)
     return false;

-  // Typical Linux allocators (expanded to include _node and array variants).
   static const char *Names[] = {
       "kmalloc", "kzalloc", "kcalloc", "kvzalloc", "kvmalloc", "krealloc",
       "kmalloc_node", "kzalloc_node", "kcalloc_node", "kmalloc_array",
@@ -287,11 +290,38 @@   }
 }

+const ParmVarDecl *SAGenTestChecker::getDirectBaseParam(const Expr *BaseE) const {
+  if (!BaseE)
+    return nullptr;
+
+  const Expr *E = BaseE;
+  while (true) {
+    E = E->IgnoreParenImpCasts();
+    if (const auto *UO = dyn_cast<UnaryOperator>(E)) {
+      UnaryOperatorKind Op = UO->getOpcode();
+      if (Op == UO_Deref || Op == UO_AddrOf) {
+        E = UO->getSubExpr();
+        continue;
+      }
+    }
+    if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(E)) {
+      E = ASE->getBase();
+      continue;
+    }
+    break;
+  }
+
+  if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {
+    return dyn_cast<ParmVarDecl>(DRE->getDecl());
+  }
+  return nullptr;
+}
+
 bool SAGenTestChecker::isFalsePositive(const MemberExpr *FreedME,
                                        const CallEvent &Call,
                                        const LabelStmt *EnclosingLabel,
                                        CheckerContext &C) const {
-  // 1) If the argument is definitely NULL at this point, kfree(NULL) is a no-op.
+  // 1) If the argument is definitely the literal NULL at this point, kfree(NULL) is a no-op.
   SVal ArgVal = C.getSVal(Call.getArgExpr(0));
   if (ArgVal.isZeroConstant())
     return true;
@@ -379,6 +409,13 @@   if (!FreedME)
     return;

+  // New gating: Only warn when the freed field belongs directly to a function parameter.
+  // This matches the target buggy pattern (e.g., mt->fc) and suppresses common cleanup of local/private state (e.g., priv->...).
+  const Expr *BaseE = FreedME->getBase();
+  const ParmVarDecl *BaseParam = getDirectBaseParam(BaseE);
+  if (!BaseParam)
+    return;
+
   // Determine if the call is under a label with multiple incoming gotos.
   const Expr *Origin = Call.getOriginExpr();
   if (!Origin)
