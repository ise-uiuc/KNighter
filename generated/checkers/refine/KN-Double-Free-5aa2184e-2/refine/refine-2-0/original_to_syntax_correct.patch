--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -99,6 +99,9 @@     FieldParmLocsMap NullSetLocs;
     FieldParmLocsMap AllocAssignLocs;

+    // New: Variables assigned from allocator-like calls: VarDecl -> locations.
+    llvm::DenseMap<const VarDecl*, llvm::SmallVector<SourceLocation, 4>> VarAllocLocs;
+
     FuncInfoCollector(CheckerContext &Ctx) : C(Ctx) {}

     static const Expr *ignoreCastsAndWrappers(const Expr *E) {
@@ -218,8 +221,11 @@
       const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();
       const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();
-
-      // Track fields assigned from call expressions (potential allocators).
+      const SourceLocation CurLoc = BO->getBeginLoc();
+      const SourceManager &SM = C.getSourceManager();
+
+      // Track fields assigned from call expressions (potential allocators),
+      // and record the earliest location.
       if (const auto *ME = dyn_cast<MemberExpr>(LHS)) {
         const ValueDecl *VD = ME->getMemberDecl();
         if (const auto *FD = dyn_cast_or_null<FieldDecl>(VD)) {
@@ -227,13 +233,44 @@           if (BaseP) {
             // NULL set tracking.
             if (isExplicitNullExpr(RHS)) {
-              NullSetLocs[FD->getCanonicalDecl()][BaseP].push_back(BO->getBeginLoc());
+              NullSetLocs[FD->getCanonicalDecl()][BaseP].push_back(CurLoc);
             }
-            // Allocator-assignment tracking.
-            if (const auto *CE = dyn_cast<CallExpr>(RHS)) {
-              if (callExprLooksLikeAllocator(CE, C)) {
-                AllocAssignLocs[FD->getCanonicalDecl()][BaseP].push_back(BO->getBeginLoc());
+            // Allocator-assignment tracking when RHS is a call.
+            if (const auto *RCE = dyn_cast<CallExpr>(RHS)) {
+              if (callExprLooksLikeAllocator(RCE, C)) {
+                AllocAssignLocs[FD->getCanonicalDecl()][BaseP].push_back(CurLoc);
               }
+            }
+            // New: Allocator-assignment tracking when RHS is a variable previously
+            //       assigned from an allocator in this function.
+            if (const auto *RDRE = dyn_cast<DeclRefExpr>(RHS)) {
+              if (const auto *RVD = dyn_cast<VarDecl>(RDRE->getDecl())) {
+                auto It = VarAllocLocs.find(RVD->getCanonicalDecl());
+                if (It != VarAllocLocs.end()) {
+                  const auto &ALocs = It->second;
+                  bool HasPriorAlloc = false;
+                  for (SourceLocation LA : ALocs) {
+                    if (SM.isBeforeInTranslationUnit(LA, CurLoc)) {
+                      HasPriorAlloc = true;
+                      break;
+                    }
+                  }
+                  if (HasPriorAlloc) {
+                    AllocAssignLocs[FD->getCanonicalDecl()][BaseP].push_back(CurLoc);
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+
+      // Track variables assigned from allocator calls: var = kmalloc(...);
+      if (const auto *LDRE = dyn_cast<DeclRefExpr>(LHS)) {
+        if (const auto *LVD = dyn_cast<VarDecl>(LDRE->getDecl())) {
+          if (const auto *RCE = dyn_cast<CallExpr>(RHS)) {
+            if (callExprLooksLikeAllocator(RCE, C)) {
+              VarAllocLocs[LVD->getCanonicalDecl()].push_back(CurLoc);
             }
           }
         }
@@ -256,12 +293,10 @@       if (const auto *FD = dyn_cast<FieldDecl>(VD)) {
         const FieldDecl *CanonFD = FD->getCanonicalDecl();
         LocallySetByCallFields.insert(CanonFD);
-        SourceLocation CurLoc = BO->getBeginLoc();
         auto It = FirstSetLoc.find(CanonFD);
         if (It == FirstSetLoc.end()) {
           FirstSetLoc[CanonFD] = CurLoc;
         } else {
-          const SourceManager &SM = C.getSourceManager();
           if (SM.isBeforeInTranslationUnit(CurLoc, It->second))
             It->second = CurLoc;
         }
