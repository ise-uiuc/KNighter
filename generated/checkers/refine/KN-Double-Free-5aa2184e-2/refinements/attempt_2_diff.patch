--- attempt_2_original.cpp+++ attempt_2.cpp@@ -45,14 +45,25 @@   // Per-function: how many gotos target each label.
   mutable llvm::DenseMap<const FunctionDecl*, llvm::DenseMap<const LabelStmt*, unsigned>> FuncLabelIncoming;

-  // Per-function: fields directly assigned from allocator calls within this function.
-  mutable llvm::DenseMap<const FunctionDecl*, llvm::SmallPtrSet<const FieldDecl*, 16>> FuncLocallyAllocFields;
+  // Per-function: fields directly assigned from ANY function call within this function.
+  mutable llvm::DenseMap<const FunctionDecl*, llvm::SmallPtrSet<const FieldDecl*, 16>> FuncLocallySetByCallFields;

   // Per-function: for each label, keep the list of concrete goto statements targeting it.
   mutable llvm::DenseMap<const FunctionDecl*, llvm::DenseMap<const LabelStmt*, llvm::SmallVector<const GotoStmt*, 4>>> FuncLabelGotos;

-  // Per-function: earliest source location where a given FieldDecl is assigned from an allocator call.
-  mutable llvm::DenseMap<const FunctionDecl*, llvm::DenseMap<const FieldDecl*, SourceLocation>> FuncFieldFirstAllocLoc;
+  // Per-function: earliest source location where a given FieldDecl is assigned from a function call.
+  mutable llvm::DenseMap<const FunctionDecl*, llvm::DenseMap<const FieldDecl*, SourceLocation>> FuncFieldFirstSetByCallLoc;
+
+  // New: Per-function maps keyed by FieldDecl -> ParmVarDecl -> locations.
+  using ParmToLocsMap = llvm::DenseMap<const ParmVarDecl*, llvm::SmallVector<SourceLocation, 4>>;
+  using FieldParmLocsMap = llvm::DenseMap<const FieldDecl*, ParmToLocsMap>;
+
+  // Locations of kfree-like calls on param-field.
+  mutable llvm::DenseMap<const FunctionDecl*, FieldParmLocsMap> FuncFieldFreeLocs;
+  // Locations of param-field = NULL (or 0).
+  mutable llvm::DenseMap<const FunctionDecl*, FieldParmLocsMap> FuncFieldNullSetLocs;
+  // Locations where param-field is assigned from allocator-like calls.
+  mutable llvm::DenseMap<const FunctionDecl*, FieldParmLocsMap> FuncFieldAllocAssignLocs;

 public:
   SAGenTestChecker()
@@ -65,59 +76,92 @@   void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;

 private:
-  // Helper to collect labels, gotos, and fields locally assigned from allocators.
+  // Helper to perform case-insensitive substring search using lowercase conversion.
+  static bool containsLower(StringRef Haystack, StringRef Needle) {
+    std::string Lower = Haystack.lower();
+    return StringRef(Lower).contains(Needle);
+  }
+
+  static bool isPointerType(QualType QT) {
+    return QT->isPointerType() || QT->isAnyPointerType();
+  }
+
+  // Helper to collect labels, gotos, and fields locally assigned from function calls,
+  // as well as free/nullset/allocator-assign locations per (param, field).
   struct FuncInfoCollector : public RecursiveASTVisitor<FuncInfoCollector> {
     CheckerContext &C;
     llvm::DenseMap<const LabelDecl *, const LabelStmt *> LabelMap;
     llvm::SmallVector<const GotoStmt *, 16> Gotos;
-    llvm::SmallPtrSet<const FieldDecl*, 16> LocallyAllocFields;
-    llvm::DenseMap<const FieldDecl*, SourceLocation> FirstAllocLoc;
+    llvm::SmallPtrSet<const FieldDecl*, 16> LocallySetByCallFields;
+    llvm::DenseMap<const FieldDecl*, SourceLocation> FirstSetLoc;
+
+    FieldParmLocsMap FreeLocs;
+    FieldParmLocsMap NullSetLocs;
+    FieldParmLocsMap AllocAssignLocs;

     FuncInfoCollector(CheckerContext &Ctx) : C(Ctx) {}

-    bool VisitLabelStmt(const LabelStmt *LS) {
-      if (const LabelDecl *LD = LS->getDecl())
-        LabelMap[LD] = LS;
-      return true;
-    }
-
-    bool VisitGotoStmt(const GotoStmt *GS) {
-      Gotos.push_back(GS);
-      return true;
-    }
-
-    bool VisitBinaryOperator(const BinaryOperator *BO) {
-      if (!BO || !BO->isAssignmentOp())
-        return true;
-
-      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();
-      const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();
-
-      const auto *ME = dyn_cast<MemberExpr>(LHS);
-      const auto *CE = dyn_cast<CallExpr>(RHS);
-      if (!ME || !CE)
-        return true;
-
-      // If RHS call looks like an allocator, record the assigned field and earliest loc.
-      if (callExprLooksLikeAllocator(CE, C)) {
-        if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl())) {
-          const FieldDecl *CanonFD = FD->getCanonicalDecl();
-          LocallyAllocFields.insert(CanonFD);
-          SourceLocation CurLoc = BO->getBeginLoc();
-          auto It = FirstAllocLoc.find(CanonFD);
-          if (It == FirstAllocLoc.end()) {
-            FirstAllocLoc[CanonFD] = CurLoc;
-          } else {
-            const SourceManager &SM = C.getSourceManager();
-            if (SM.isBeforeInTranslationUnit(CurLoc, It->second))
-              It->second = CurLoc;
+    static const Expr *ignoreCastsAndWrappers(const Expr *E) {
+      if (!E) return nullptr;
+      const Expr *Cur = E->IgnoreParenImpCasts();
+      while (true) {
+        if (const auto *UO = dyn_cast<UnaryOperator>(Cur)) {
+          if (UO->getOpcode() == UO_AddrOf || UO->getOpcode() == UO_Deref) {
+            Cur = UO->getSubExpr()->IgnoreParenImpCasts();
+            continue;
           }
         }
-      }
-      return true;
-    }
-
-    // Heuristic allocator detection for CallExpr using source text/Callee name.
+        if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(Cur)) {
+          Cur = ASE->getBase()->IgnoreParenImpCasts();
+          continue;
+        }
+        break;
+      }
+      return Cur->IgnoreParenImpCasts();
+    }
+
+    static bool isExplicitNullExpr(const Expr *E) {
+      if (!E) return false;
+      E = E->IgnoreParenImpCasts();
+      if (isa<GNUNullExpr>(E)) return true;
+#if CLANG_VERSION_MAJOR >= 4
+      if (isa<CXXNullPtrLiteralExpr>(E)) return true;
+#endif
+      if (const auto *IL = dyn_cast<IntegerLiteral>(E))
+        return IL->getValue().isZero();
+      return false;
+    }
+
+    static const MemberExpr* getMemberExprFromExpr(const Expr *E) {
+      const Expr *S = ignoreCastsAndWrappers(E);
+      return dyn_cast_or_null<MemberExpr>(S);
+    }
+
+    // Resolve base to a function parameter if possible.
+    static const ParmVarDecl *getDirectBaseParam(const Expr *BaseE) {
+      if (!BaseE) return nullptr;
+      const Expr *E = BaseE;
+      while (true) {
+        E = E->IgnoreParenImpCasts();
+        if (const auto *UO = dyn_cast<UnaryOperator>(E)) {
+          UnaryOperatorKind Op = UO->getOpcode();
+          if (Op == UO_Deref || Op == UO_AddrOf) {
+            E = UO->getSubExpr();
+            continue;
+          }
+        }
+        if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(E)) {
+          E = ASE->getBase();
+          continue;
+        }
+        break;
+      }
+      if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {
+        return dyn_cast<ParmVarDecl>(DRE->getDecl());
+      }
+      return nullptr;
+    }
+
     static bool callExprLooksLikeAllocator(const CallExpr *CE, CheckerContext &C) {
       if (!CE)
         return false;
@@ -142,6 +186,113 @@       }
       return false;
     }
+
+    static bool getFreeLikeArgIndex(const CallExpr *CE, unsigned &OutIdx) {
+      OutIdx = 0;
+      if (!CE) return false;
+      const FunctionDecl *FD = CE->getDirectCallee();
+      if (!FD) return false;
+      StringRef Name = FD->getName();
+      if (Name.equals("kfree") || Name.equals("kvfree") || Name.equals("vfree")) {
+        if (CE->getNumArgs() >= 1) { OutIdx = 0; return true; }
+      } else if (Name.equals("devm_kfree")) {
+        if (CE->getNumArgs() >= 2) { OutIdx = 1; return true; }
+      }
+      return false;
+    }
+
+    bool VisitLabelStmt(const LabelStmt *LS) {
+      if (const LabelDecl *LD = LS->getDecl())
+        LabelMap[LD] = LS;
+      return true;
+    }
+
+    bool VisitGotoStmt(const GotoStmt *GS) {
+      Gotos.push_back(GS);
+      return true;
+    }
+
+    bool VisitBinaryOperator(const BinaryOperator *BO) {
+      if (!BO || !BO->isAssignmentOp())
+        return true;
+
+      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();
+      const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();
+
+      // Track fields assigned from call expressions (potential allocators).
+      if (const auto *ME = dyn_cast<MemberExpr>(LHS)) {
+        const ValueDecl *VD = ME->getMemberDecl();
+        if (const auto *FD = dyn_cast_or_null<FieldDecl>(VD)) {
+          const ParmVarDecl *BaseP = getDirectBaseParam(ME->getBase());
+          if (BaseP) {
+            // NULL set tracking.
+            if (isExplicitNullExpr(RHS)) {
+              NullSetLocs[FD->getCanonicalDecl()][BaseP].push_back(BO->getBeginLoc());
+            }
+            // Allocator-assignment tracking.
+            if (const auto *CE = dyn_cast<CallExpr>(RHS)) {
+              if (callExprLooksLikeAllocator(CE, C)) {
+                AllocAssignLocs[FD->getCanonicalDecl()][BaseP].push_back(BO->getBeginLoc());
+              }
+            }
+          }
+        }
+      }
+
+      // Existing tracking of "assigned from any call" for other heuristics.
+      const auto *ME = dyn_cast<MemberExpr>(LHS);
+      const auto *CE = dyn_cast<CallExpr>(RHS);
+      if (!ME || !CE)
+        return true;
+
+      // Only consider assignments of pointer-typed fields from function calls.
+      const ValueDecl *VD = ME->getMemberDecl();
+      if (!VD)
+        return true;
+      QualType LT = VD->getType();
+      if (!isPointerType(LT))
+        return true;
+
+      if (const auto *FD = dyn_cast<FieldDecl>(VD)) {
+        const FieldDecl *CanonFD = FD->getCanonicalDecl();
+        LocallySetByCallFields.insert(CanonFD);
+        SourceLocation CurLoc = BO->getBeginLoc();
+        auto It = FirstSetLoc.find(CanonFD);
+        if (It == FirstSetLoc.end()) {
+          FirstSetLoc[CanonFD] = CurLoc;
+        } else {
+          const SourceManager &SM = C.getSourceManager();
+          if (SM.isBeforeInTranslationUnit(CurLoc, It->second))
+            It->second = CurLoc;
+        }
+      }
+      return true;
+    }
+
+    bool VisitCallExpr(const CallExpr *CE) {
+      unsigned ArgIdx = 0;
+      if (!getFreeLikeArgIndex(CE, ArgIdx))
+        return true;
+
+      if (ArgIdx >= CE->getNumArgs())
+        return true;
+
+      const Expr *ArgE = CE->getArg(ArgIdx);
+      const MemberExpr *ME = getMemberExprFromExpr(ArgE);
+      if (!ME)
+        return true;
+
+      const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());
+      if (!FD)
+        return true;
+
+      const ParmVarDecl *BaseP = getDirectBaseParam(ME->getBase());
+      if (!BaseP)
+        return true;
+
+      FreeLocs[FD->getCanonicalDecl()][BaseP].push_back(CE->getBeginLoc());
+      return true;
+    }
   };

   const FunctionDecl *getCurrentFunction(const CheckerContext &C) const {
@@ -159,11 +310,21 @@
   // Returns true if the reported scenario is a false positive and should be suppressed.
   bool isFalsePositive(const Expr *FreedArgE, const MemberExpr *FreedME,
+                       const ParmVarDecl *BaseParam,
                        const CallEvent &Call, const LabelStmt *EnclosingLabel,
                        CheckerContext &C) const;

   // Gating heuristic: return the ParmVarDecl if the base of a MemberExpr resolves directly to a function parameter.
   const ParmVarDecl *getDirectBaseParam(const Expr *BaseE) const;
+
+  // Additional gating: check whether the target label has any error-like incoming goto.
+  bool labelHasErrorishIncoming(const FunctionDecl *FD, const LabelStmt *LS, CheckerContext &C) const;
+
+  // Helpers for "error-ish" classification.
+  bool labelNameLooksErrorish(const LabelStmt *LS) const;
+  bool gotoLooksErrorish(const GotoStmt *GS, CheckerContext &C) const;
+  bool condLooksErrorish(const Expr *Cond, CheckerContext &C) const;
+  const Expr *stripWrapperCalls(const Expr *E, CheckerContext &C) const;

   void reportFreeUnownedInSharedLabel(const CallEvent &Call, CheckerContext &C) const;
 };
@@ -194,14 +355,20 @@   }

   FuncLabelIncoming[FD] = std::move(IncomingCount);
-  FuncLocallyAllocFields[FD] = std::move(Collector.LocallyAllocFields);
+  FuncLocallySetByCallFields[FD] = std::move(Collector.LocallySetByCallFields);
   FuncLabelGotos[FD] = std::move(LabelToGotos);
-  // Store earliest allocator-assignment locations for fields.
+
+  // Store earliest assignment-from-call locations for fields.
   llvm::DenseMap<const FieldDecl*, SourceLocation> Earliest;
-  for (const auto &P : Collector.FirstAllocLoc) {
+  for (const auto &P : Collector.FirstSetLoc) {
     Earliest[P.first->getCanonicalDecl()] = P.second;
   }
-  FuncFieldFirstAllocLoc[FD] = std::move(Earliest);
+  FuncFieldFirstSetByCallLoc[FD] = std::move(Earliest);
+
+  // Store fine-grained per-(param,field) location data for FP suppression.
+  FuncFieldFreeLocs[FD] = std::move(Collector.FreeLocs);
+  FuncFieldNullSetLocs[FD] = std::move(Collector.NullSetLocs);
+  FuncFieldAllocAssignLocs[FD] = std::move(Collector.AllocAssignLocs);
 }

 bool SAGenTestChecker::isAllocatorCall(const CallEvent &Call, CheckerContext &C) const {
@@ -247,7 +414,7 @@   const FunctionDecl *FD = getCurrentFunction(C);
   if (!FD)
     return;
-  // Build per-function metadata (labels and locally-allocated fields).
+  // Build per-function metadata (labels and locally-assigned-from-call fields).
   buildPerFunctionInfo(FD, C);
 }

@@ -257,9 +424,12 @@     return;
   // Clean per-function metadata.
   FuncLabelIncoming.erase(FD);
-  FuncLocallyAllocFields.erase(FD);
+  FuncLocallySetByCallFields.erase(FD);
   FuncLabelGotos.erase(FD);
-  FuncFieldFirstAllocLoc.erase(FD);
+  FuncFieldFirstSetByCallLoc.erase(FD);
+  FuncFieldFreeLocs.erase(FD);
+  FuncFieldNullSetLocs.erase(FD);
+  FuncFieldAllocAssignLocs.erase(FD);
 }

 void SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const {
@@ -330,11 +500,159 @@   return nullptr;
 }

+const Expr *SAGenTestChecker::stripWrapperCalls(const Expr *E, CheckerContext &C) const {
+  const Expr *Cur = E ? E->IgnoreParenImpCasts() : nullptr;
+  while (const auto *CE = dyn_cast_or_null<CallExpr>(Cur)) {
+    const FunctionDecl *FD = CE->getDirectCallee();
+    StringRef Name = FD ? FD->getName() : StringRef();
+    // Common kernel wrappers/macros lowered as calls we want to peel.
+    if (Name.equals("unlikely") || Name.equals("likely") ||
+        Name.equals("__builtin_expect")) {
+      if (CE->getNumArgs() > 0) {
+        Cur = CE->getArg(0)->IgnoreParenImpCasts();
+        continue;
+      }
+    }
+    break;
+  }
+  return Cur ? Cur->IgnoreParenImpCasts() : nullptr;
+}
+
+bool SAGenTestChecker::condLooksErrorish(const Expr *Cond, CheckerContext &C) const {
+  if (!Cond)
+    return false;
+
+  const Expr *E = stripWrapperCalls(Cond, C);
+  if (!E)
+    return false;
+
+  // if (ret) or if (!ret) patterns where 'ret' is a typical error code variable.
+  auto LooksLikeErrVar = [](StringRef N) {
+    return N.equals("ret") || N.equals("rc") || N.equals("err") || N.equals("error") || N.equals("status");
+  };
+
+  if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {
+    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {
+      if (LooksLikeErrVar(VD->getName()))
+        return true;
+    }
+  }
+
+  if (const auto *UO = dyn_cast<UnaryOperator>(E)) {
+    if (UO->getOpcode() == UO_LNot) {
+      if (const auto *D = dyn_cast<DeclRefExpr>(UO->getSubExpr()->IgnoreParenImpCasts()))
+        if (const auto *VD = dyn_cast<VarDecl>(D->getDecl()))
+          if (LooksLikeErrVar(VD->getName()))
+            return true;
+    }
+  }
+
+  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+    if (BO->isComparisonOp() || BO->getOpcode() == BO_NE || BO->getOpcode() == BO_EQ) {
+      const Expr *L = BO->getLHS()->IgnoreParenImpCasts();
+      const Expr *R = BO->getRHS()->IgnoreParenImpCasts();
+      auto IsZeroOrNegConst = [](const Expr *X) -> bool {
+        if (const auto *IL = dyn_cast<IntegerLiteral>(X)) {
+          return IL->getValue().isZero(); // zero
+        }
+        return false;
+      };
+      auto IsErrVar = [&](const Expr *X) -> bool {
+        if (const auto *DR = dyn_cast<DeclRefExpr>(X))
+          if (const auto *VD = dyn_cast<VarDecl>(DR->getDecl()))
+            return LooksLikeErrVar(VD->getName());
+        return false;
+      };
+      // ret != 0, ret < 0, 0 != ret, etc.
+      if ((IsErrVar(L) && IsZeroOrNegConst(R)) || (IsErrVar(R) && IsZeroOrNegConst(L)))
+        return true;
+    }
+  }
+
+  // if (IS_ERR(ptr)) or IS_ERR_OR_NULL(ptr)
+  if (const auto *CE = dyn_cast<CallExpr>(E)) {
+    if (const FunctionDecl *FD = CE->getDirectCallee()) {
+      StringRef N = FD->getName();
+      if (N.equals("IS_ERR") || N.equals("IS_ERR_OR_NULL") || N.equals("IS_ERR_VALUE"))
+        return true;
+    } else {
+      // Fallback: text search in the expression for kernel helpers.
+      if (ExprHasName(E, "IS_ERR", C) || ExprHasName(E, "IS_ERR_OR_NULL", C) || ExprHasName(E, "IS_ERR_VALUE", C))
+        return true;
+    }
+  }
+
+  return false;
+}
+
+bool SAGenTestChecker::labelNameLooksErrorish(const LabelStmt *LS) const {
+  if (!LS || !LS->getDecl())
+    return false;
+  StringRef N = LS->getDecl()->getName();
+  // Common error cleanup labels in kernel code.
+  return containsLower(N, "err") || containsLower(N, "error") ||
+         containsLower(N, "fail") || containsLower(N, "free") ||
+         containsLower(N, "cleanup") || containsLower(N, "out_err");
+}
+
+bool SAGenTestChecker::gotoLooksErrorish(const GotoStmt *GS, CheckerContext &C) const {
+  if (!GS)
+    return false;
+
+  // If there's an enclosing if-statement, examine its condition.
+  if (const IfStmt *IS = findSpecificTypeInParents<IfStmt>(GS, C)) {
+    if (const Expr *Cond = IS->getCond()) {
+      if (condLooksErrorish(Cond, C))
+        return true;
+    }
+  }
+
+  // Otherwise, fall back to label name being errorish.
+  const LabelDecl *LD = GS->getLabel();
+  if (LD) {
+    StringRef N = LD->getName();
+    if (containsLower(N, "err") || containsLower(N, "error") ||
+        containsLower(N, "fail") || containsLower(N, "free") ||
+        containsLower(N, "cleanup") || containsLower(N, "out_err"))
+      return true;
+  }
+  return false;
+}
+
+bool SAGenTestChecker::labelHasErrorishIncoming(const FunctionDecl *FD, const LabelStmt *LS, CheckerContext &C) const {
+  if (!FD || !LS)
+    return false;
+  auto ItF = FuncLabelGotos.find(FD);
+  if (ItF == FuncLabelGotos.end())
+    return false;
+  auto It = ItF->second.find(LS);
+  if (It == ItF->second.end())
+    return false;
+
+  // If label name looks errorish, that's sufficient.
+  if (labelNameLooksErrorish(LS))
+    return true;
+
+  const auto &Gotos = It->second;
+  for (const GotoStmt *GS : Gotos) {
+    if (gotoLooksErrorish(GS, C))
+      return true;
+  }
+  return false;
+}
+
 bool SAGenTestChecker::isFalsePositive(const Expr *FreedArgE,
                                        const MemberExpr *FreedME,
+                                       const ParmVarDecl *BaseParam,
                                        const CallEvent &Call,
                                        const LabelStmt *EnclosingLabel,
                                        CheckerContext &C) const {
+  // 0) If the label does not look like an error path for any of its incoming gotos,
+  //    this is very likely a normal cleanup label (e.g. "out") -> suppress.
+  const FunctionDecl *FD = getCurrentFunction(C);
+  if (FD && EnclosingLabel && !labelHasErrorishIncoming(FD, EnclosingLabel, C))
+    return true;
+
   // 1) If the argument is definitely the literal NULL at this point, kfree(NULL) is a no-op.
   if (FreedArgE) {
     SVal ArgVal = C.getSVal(FreedArgE);
@@ -355,38 +673,94 @@     }
   }

-  // 3) If all incoming gotos to this label lexically occur after the earliest allocator
-  //    assignment to this field in the same function, then the shared label is safe.
-  const FunctionDecl *FD = getCurrentFunction(C);
-  if (FD && FreedME) {
-    const FieldDecl *FreedFD = dyn_cast<FieldDecl>(FreedME->getMemberDecl());
-    if (FreedFD) {
-      const FieldDecl *CanonFD = FreedFD->getCanonicalDecl();
-
-      auto AllocItF = FuncFieldFirstAllocLoc.find(FD);
-      auto GotoItF  = FuncLabelGotos.find(FD);
-      if (AllocItF != FuncFieldFirstAllocLoc.end() &&
-          GotoItF  != FuncLabelGotos.end()) {
-        auto AllocIt = AllocItF->second.find(CanonFD);
-        auto GLabelIt = GotoItF->second.find(EnclosingLabel);
-        if (AllocIt != AllocItF->second.end() &&
-            GLabelIt != GotoItF->second.end()) {
-          SourceLocation AllocLoc = AllocIt->second;
-          const auto &Gotos = GLabelIt->second;
-          if (!Gotos.empty()) {
-            const SourceManager &SM = C.getSourceManager();
-            bool AnyBefore = false;
-            for (const GotoStmt *GS : Gotos) {
-              SourceLocation GLoc = GS->getGotoLoc();
-              if (SM.isBeforeInTranslationUnit(GLoc, AllocLoc)) {
-                AnyBefore = true;
-                break;
+  // 2.5) Intrafunction allocator-assignment suppression:
+  // If this same param-field was assigned from an allocator in this function
+  // before the current free call, treat it as locally-owned and suppress.
+  if (FD && FreedME && BaseParam) {
+    const FieldDecl *CanonFD = dyn_cast<FieldDecl>(FreedME->getMemberDecl());
+    if (CanonFD) {
+      CanonFD = CanonFD->getCanonicalDecl();
+      auto ItAllocF = FuncFieldAllocAssignLocs.find(FD);
+      if (ItAllocF != FuncFieldAllocAssignLocs.end()) {
+        const auto &AllocMapField = ItAllocF->second;
+        auto ItAllocParmMap = AllocMapField.find(CanonFD);
+        if (ItAllocParmMap != AllocMapField.end()) {
+          auto ItLocs = ItAllocParmMap->second.find(BaseParam);
+          if (ItLocs != ItAllocParmMap->second.end()) {
+            const llvm::SmallVector<SourceLocation,4> &AllocLocs = ItLocs->second;
+            if (!AllocLocs.empty()) {
+              const SourceManager &SM = C.getSourceManager();
+              SourceLocation CurLoc = Call.getOriginExpr()
+                                          ? Call.getOriginExpr()->getBeginLoc()
+                                          : Call.getSourceRange().getBegin();
+              for (SourceLocation Lalloc : AllocLocs) {
+                if (SM.isBeforeInTranslationUnit(Lalloc, CurLoc)) {
+                  return true;
+                }
               }
             }
-            if (!AnyBefore) {
-              // All incoming gotos occur after allocator assignment to this field.
-              // The shared label free is consistent with local ownership.
-              return true;
+          }
+        }
+      }
+    }
+  }
+
+  // 3) AST-based suppression for the "reset and reallocate" idiom:
+  //    If there exists a prior free(field) followed by field = NULL (or 0) and then
+  //    an allocator assignment to the same field, all before this free -> suppress.
+  if (FD && FreedME && BaseParam) {
+    const FieldDecl *CanonFD = dyn_cast<FieldDecl>(FreedME->getMemberDecl());
+    if (CanonFD) {
+      CanonFD = CanonFD->getCanonicalDecl();
+      auto ItFreeF = FuncFieldFreeLocs.find(FD);
+      auto ItNullF = FuncFieldNullSetLocs.find(FD);
+      auto ItAllocF = FuncFieldAllocAssignLocs.find(FD);
+      if (ItFreeF != FuncFieldFreeLocs.end() &&
+          ItNullF != FuncFieldNullSetLocs.end() &&
+          ItAllocF != FuncFieldAllocAssignLocs.end()) {
+
+        const auto &FreeMapField = ItFreeF->second;
+        const auto &NullMapField = ItNullF->second;
+        const auto &AllocMapField = ItAllocF->second;
+
+        auto ItFreeParmMap  = FreeMapField.find(CanonFD);
+        auto ItNullParmMap  = NullMapField.find(CanonFD);
+        auto ItAllocParmMap = AllocMapField.find(CanonFD);
+
+        if (ItFreeParmMap != FreeMapField.end() &&
+            ItNullParmMap != NullMapField.end() &&
+            ItAllocParmMap != AllocMapField.end()) {
+          const auto &FreeVec  = ItFreeParmMap->second.lookup(BaseParam);
+          const auto &NullVec  = ItNullParmMap->second.lookup(BaseParam);
+          const auto &AllocVec = ItAllocParmMap->second.lookup(BaseParam);
+
+          if (!FreeVec.empty() && !NullVec.empty() && !AllocVec.empty()) {
+            const SourceManager &SM = C.getSourceManager();
+            SourceLocation CurLoc = Call.getOriginExpr()
+                                        ? Call.getOriginExpr()->getBeginLoc()
+                                        : Call.getSourceRange().getBegin();
+            // Check for free < null < alloc < current
+            for (SourceLocation Lfree : FreeVec) {
+              if (!SM.isBeforeInTranslationUnit(Lfree, CurLoc))
+                continue;
+              for (SourceLocation Lnull : NullVec) {
+                if (!SM.isBeforeInTranslationUnit(Lfree, Lnull))
+                  continue;
+                if (!SM.isBeforeInTranslationUnit(Lnull, CurLoc))
+                  continue;
+                bool HasAllocBetween = false;
+                for (SourceLocation Lalloc : AllocVec) {
+                  if (SM.isBeforeInTranslationUnit(Lnull, Lalloc) &&
+                      SM.isBeforeInTranslationUnit(Lalloc, CurLoc)) {
+                    HasAllocBetween = true;
+                    break;
+                  }
+                }
+                if (HasAllocBetween) {
+                  // All three conditions satisfied for this path -> suppress.
+                  return true;
+                }
+              }
             }
           }
         }
@@ -433,8 +807,12 @@   auto Lit = IncomingMap.find(EnclosingLabel);
   unsigned Count = (Lit == IncomingMap.end()) ? 0u : Lit->second;

-  // Only warn for shared labels (2 or more incoming gotos).
+  // Only consider shared labels (2 or more incoming gotos).
   if (Count < 2)
+    return;
+
+  // Only consider labels that look like error paths.
+  if (!labelHasErrorishIncoming(FD, EnclosingLabel, C))
     return;

   // Check each freed argument.
@@ -449,15 +827,15 @@     if (!FreedME)
       continue;

-    // New gating: Only warn when the freed field belongs directly to a function parameter.
+    // Only warn when the freed field belongs directly to a function parameter.
     // This matches the target buggy pattern (e.g., mt->fc) and suppresses cleanup of local/private state.
     const Expr *BaseE = FreedME->getBase();
     const ParmVarDecl *BaseParam = getDirectBaseParam(BaseE);
     if (!BaseParam)
       continue;

-    // Suppress known false positives.
-    if (isFalsePositive(ArgE, FreedME, Call, EnclosingLabel, C))
+    // Suppress known false positives (ownership known on path, non-error labels, or reset+realloc/local-alloc idioms).
+    if (isFalsePositive(ArgE, FreedME, BaseParam, Call, EnclosingLabel, C))
       continue;

     reportFreeUnownedInSharedLabel(Call, C);
