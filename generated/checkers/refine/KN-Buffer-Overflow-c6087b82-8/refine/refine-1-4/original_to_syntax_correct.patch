--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -16,6 +16,7 @@ #include "clang/AST/Stmt.h"
 #include "clang/AST/Type.h"
 #include "clang/Lex/Lexer.h"
+#include "clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h"

 using namespace clang;
 using namespace ento;
@@ -27,6 +28,11 @@ // Optional fallback: symbols that we heuristically believe are bounded by some sizeof()
 REGISTER_SET_WITH_PROGRAMSTATE(BoundedLenSyms, SymbolRef)

+// New: Track by array VarDecl as key to avoid MemRegion shape/availability issues under sizeof().
+REGISTER_MAP_WITH_PROGRAMSTATE(ArraySafeLenByVD, const VarDecl*, const MemRegion*)
+// New: Reverse mapping to clear stale entries when the length variable gets reassigned.
+REGISTER_MAP_WITH_PROGRAMSTATE(LenRegToArrayVD, const MemRegion*, const VarDecl*)
+
 namespace {

 class SAGenTestChecker
@@ -43,14 +49,15 @@   // Helper functions
   bool isCopyFromUser(const CallEvent &Call, CheckerContext &C) const;

-  // Try to identify destination as a fixed-size array. Returns true on success and fills ArraySize, ArrReg, ArrName.
+  // Try to identify destination as a fixed-size array. Returns true on success and fills ArraySize, ArrReg, ArrName, ArrVD.
   bool getDestArrayInfo(const Expr *DstArg, CheckerContext &C,
                         llvm::APInt &ArraySize, const MemRegion* &ArrReg,
-                        std::string &ArrName) const;
-
-  // Determine if expression E contains sizeof() on the destination array.
+                        std::string &ArrName, const VarDecl* &ArrVD) const;
+
+  // Determine if expression E contains sizeof() on the destination array (by VarDecl or region/name heuristic).
   bool exprContainsSizeofOfArray(const Expr *E, const MemRegion *ArrReg,
-                                 StringRef ArrName, CheckerContext &C) const;
+                                 StringRef ArrName, const VarDecl *ArrVD,
+                                 CheckerContext &C) const;

   // Extract region and/or symbol for length expression.
   void getLenArgRegionOrSymbol(const Expr *LenArg, CheckerContext &C,
@@ -58,6 +65,19 @@
   void reportUnbounded(const CallEvent &Call, const Expr *Dst,
                        const Expr *Len, CheckerContext &C) const;
+
+  // Return array VarDecl if expression references a fixed-size array variable.
+  const VarDecl* getArrayVarDeclFromExpr(const Expr *E) const;
+
+  // Get array size from VarDecl (ConstantArrayType).
+  static bool getArraySizeFromVarDecl(llvm::APInt &ArraySize, const VarDecl *VD);
+
+  // Build VarRegion for a given VarDecl.
+  const MemRegion* getVarRegionForDecl(const VarDecl *VD, CheckerContext &C) const;
+
+  // Clear stale mapping if LHS length variable previously associated with an array is now assigned a non-sizeof value.
+  ProgramStateRef clearStaleLenVarMappings(ProgramStateRef State, const MemRegion *LHSReg,
+                                           CheckerContext &C) const;
 };

 bool SAGenTestChecker::isCopyFromUser(const CallEvent &Call, CheckerContext &C) const {
@@ -74,12 +94,63 @@   return false;
 }

+const VarDecl* SAGenTestChecker::getArrayVarDeclFromExpr(const Expr *E) const {
+  if (!E) return nullptr;
+  const Expr *X = E->IgnoreParenImpCasts();
+  if (const auto *DRE = dyn_cast<DeclRefExpr>(X)) {
+    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {
+      if (isa<ConstantArrayType>(VD->getType().getTypePtr()))
+        return VD;
+    }
+  }
+  if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(X)) {
+    return getArrayVarDeclFromExpr(ASE->getBase());
+  }
+  if (const auto *UO = dyn_cast<UnaryOperator>(X)) {
+    if (UO->getOpcode() == UO_AddrOf || UO->getOpcode() == UO_Deref)
+      return getArrayVarDeclFromExpr(UO->getSubExpr());
+  }
+  return nullptr;
+}
+
+bool SAGenTestChecker::getArraySizeFromVarDecl(llvm::APInt &ArraySize, const VarDecl *VD) {
+  if (!VD) return false;
+  QualType QT = VD->getType();
+  if (const auto *ArrayType = dyn_cast<ConstantArrayType>(QT.getTypePtr())) {
+    ArraySize = ArrayType->getSize();
+    return true;
+  }
+  return false;
+}
+
+const MemRegion* SAGenTestChecker::getVarRegionForDecl(const VarDecl *VD, CheckerContext &C) const {
+  if (!VD) return nullptr;
+  MemRegionManager &RM = C.getSValBuilder().getRegionManager();
+  // VarRegion in current LocationContext is sufficient for identity comparison within this path.
+  return RM.getVarRegion(VD, C.getLocationContext());
+}
+
 bool SAGenTestChecker::getDestArrayInfo(const Expr *DstArg, CheckerContext &C,
                                         llvm::APInt &ArraySize, const MemRegion* &ArrReg,
-                                        std::string &ArrName) const {
+                                        std::string &ArrName, const VarDecl* &ArrVD) const {
   ArrReg = nullptr;
   ArrName.clear();
-
+  ArrVD = nullptr;
+
+  // First, try to identify the array VarDecl directly (more robust across sizeof()/decay).
+  if (const VarDecl *VD = getArrayVarDeclFromExpr(DstArg)) {
+    llvm::APInt SizeTmp;
+    if (!getArraySizeFromVarDecl(SizeTmp, VD))
+      return false;
+    ArraySize = SizeTmp;
+    ArrVD = VD;
+    ArrName = VD->getNameAsString();
+    // Build region from the VarDecl for stable identity.
+    ArrReg = getVarRegionForDecl(VD, C);
+    return true;
+  }
+
+  // Fallback to the original approach if VarDecl lookup failed.
   // Identify that DstArg is a fixed-size array and retrieve its size
   if (!getArraySizeFromExpr(ArraySize, DstArg))
     return false;
@@ -95,8 +166,9 @@
   // Try extracting the array variable name
   if (const auto *DRE = dyn_cast<DeclRefExpr>(DstArg->IgnoreImplicit())) {
-    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {
-      ArrName = VD->getNameAsString();
+    if (const auto *VD2 = dyn_cast<VarDecl>(DRE->getDecl())) {
+      ArrName = VD2->getNameAsString();
+      ArrVD = VD2;
     }
   }

@@ -104,19 +176,27 @@ }

 bool SAGenTestChecker::exprContainsSizeofOfArray(const Expr *E, const MemRegion *ArrReg,
-                                                 StringRef ArrName, CheckerContext &C) const {
-  if (!E || !ArrReg)
+                                                 StringRef ArrName, const VarDecl *ArrVD,
+                                                 CheckerContext &C) const {
+  if (!E)
     return false;

   // AST-based check: find a sizeof(...) inside E that references the same array
   if (const auto *UE = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(E)) {
     if (UE->getKind() == UETT_SizeOf) {
       if (const Expr *Arg = UE->getArgumentExpr()) {
-        const MemRegion *SizeofMR = getMemRegionFromExpr(Arg, C);
-        if (SizeofMR) {
-          SizeofMR = SizeofMR->getBaseRegion();
-          if (SizeofMR == ArrReg)
+        // Prefer matching by VarDecl for robustness in unevaluated contexts.
+        if (const VarDecl *VD = getArrayVarDeclFromExpr(Arg)) {
+          if (ArrVD && VD == ArrVD)
             return true;
+        }
+        // Fallback: region equivalence if available.
+        if (ArrReg) {
+          if (const MemRegion *SizeofMR = getMemRegionFromExpr(Arg, C)) {
+            SizeofMR = SizeofMR->getBaseRegion();
+            if (SizeofMR == ArrReg)
+              return true;
+          }
         }
       }
     }
@@ -166,6 +246,24 @@   C.emitReport(std::move(R));
 }

+ProgramStateRef SAGenTestChecker::clearStaleLenVarMappings(ProgramStateRef State,
+                                                           const MemRegion *LHSReg,
+                                                           CheckerContext &C) const {
+  if (!State || !LHSReg)
+    return State;
+  // If LHSReg was previously registered as "safe length" for some array, remove it.
+  if (const VarDecl *const *PrevArrPtr = State->get<LenRegToArrayVD>(LHSReg)) {
+    const VarDecl *PrevArr = *PrevArrPtr;
+    State = State->remove<LenRegToArrayVD>(LHSReg);
+    State = State->remove<ArraySafeLenByVD>(PrevArr);
+    // Also remove region-based mapping if possible
+    if (const MemRegion *ArrReg = getVarRegionForDecl(PrevArr, C)) {
+      State = State->remove<ArraySafeLenMap>(ArrReg);
+    }
+  }
+  return State;
+}
+
 void SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const {
   if (!S)
     return;
@@ -187,31 +285,40 @@   if (!RHS)
     return;

-  // Look for sizeof(array) in RHS; if found, associate the array with this LHS length variable
+  // Look for sizeof(array) in RHS; if found, associate the array with this LHS length variable.
   if (const auto *UE = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(RHS)) {
     if (UE->getKind() == UETT_SizeOf) {
       if (const Expr *Arg = UE->getArgumentExpr()) {
-        // Confirm it's an array decl ref
-        llvm::APInt DummySize;
-        if (getArraySizeFromExpr(DummySize, Arg)) {
-          const MemRegion *ArrMR = getMemRegionFromExpr(Arg, C);
-          if (ArrMR) {
-            ArrMR = ArrMR->getBaseRegion();
-            if (ArrMR) {
-              State = State->set<ArraySafeLenMap>(ArrMR, LHSReg);
-            }
-          }
+        // Confirm it's an array decl ref (prefer VarDecl for stability)
+        const VarDecl *ArrVD = getArrayVarDeclFromExpr(Arg);
+        if (ArrVD) {
+          // Build ArrReg if possible
+          const MemRegion *ArrMR = getVarRegionForDecl(ArrVD, C);
+          // Clear any stale association for this LHS first
+          State = clearStaleLenVarMappings(State, LHSReg, C);
+          // Record new associations (by VarDecl and region if available)
+          State = State->set<ArraySafeLenByVD>(ArrVD, LHSReg);
+          State = State->set<LenRegToArrayVD>(LHSReg, ArrVD);
+          if (ArrMR)
+            State = State->set<ArraySafeLenMap>(ArrMR, LHSReg);
+          C.addTransition(State);
+          return;
         }
       }
     }
-  } else {
-    // Weak heuristic: if RHS contains both min and sizeof, consider LHS symbol bounded
-    if (ExprHasName(RHS, "min", C) && ExprHasName(RHS, "sizeof", C)) {
-      if (SymbolRef Sym = Val.getAsSymbol())
-        State = State->add<BoundedLenSyms>(Sym);
-    }
-  }
-
+  }
+
+  // Weak heuristic: if RHS contains both min and sizeof, consider LHS symbol bounded
+  if (ExprHasName(RHS, "min", C) && ExprHasName(RHS, "sizeof", C)) {
+    if (SymbolRef Sym = Val.getAsSymbol()) {
+      State = State->add<BoundedLenSyms>(Sym);
+      C.addTransition(State);
+      return;
+    }
+  }
+
+  // If we got here, we didn't assign a sizeof()-based value. Clear stale mapping if any.
+  State = clearStaleLenVarMappings(State, LHSReg, C);
   C.addTransition(State);
 }

@@ -227,29 +334,41 @@   if (!DstArg || !LenArg)
     return;

-  // Identify destination as a fixed-size array
+  // Identify destination as a provable fixed-size array
   llvm::APInt ArraySizeAP;
   const MemRegion *ArrReg = nullptr;
   std::string ArrName;
-  if (!getDestArrayInfo(DstArg, C, ArraySizeAP, ArrReg, ArrName))
+  const VarDecl *ArrVD = nullptr;
+  if (!getDestArrayInfo(DstArg, C, ArraySizeAP, ArrReg, ArrName, ArrVD))
     return; // Only warn when destination is a provable fixed-size array

   uint64_t ArraySize = ArraySizeAP.getZExtValue();
   uint64_t SafeCopyLimit = (ArraySize > 0) ? (ArraySize - 1) : 0;

   // 1) Len directly contains sizeof(array)
-  if (exprContainsSizeofOfArray(LenArg, ArrReg, ArrName, C))
+  if (exprContainsSizeofOfArray(LenArg, ArrReg, ArrName, ArrVD, C))
     return;

   ProgramStateRef State = C.getState();

-  // 2) Len is a variable that we already recorded as safe for this array
-  const MemRegion *const *BoundRegForArrayPtr = State->get<ArraySafeLenMap>(ArrReg);
-  const MemRegion *BoundRegForArray = BoundRegForArrayPtr ? *BoundRegForArrayPtr : nullptr;
+  // 2) Len is a variable that we already recorded as safe for this array (by region or by VarDecl)
+  const MemRegion *BoundRegForArray = nullptr;
+  if (ArrReg) {
+    if (const MemRegion *const *Ptr = State->get<ArraySafeLenMap>(ArrReg))
+      BoundRegForArray = *Ptr;
+  }
+  const MemRegion *BoundRegForArrayByVD = nullptr;
+  if (ArrVD) {
+    if (const MemRegion *const *PtrVD = State->get<ArraySafeLenByVD>(ArrVD))
+      BoundRegForArrayByVD = *PtrVD;
+  }
+
   const MemRegion *LenReg = nullptr;
   SymbolRef LenSym = nullptr;
   getLenArgRegionOrSymbol(LenArg, C, LenReg, LenSym);
-  if (BoundRegForArray && LenReg && (BoundRegForArray == LenReg))
+
+  if (LenReg && ((BoundRegForArray && (BoundRegForArray == LenReg)) ||
+                 (BoundRegForArrayByVD && (BoundRegForArrayByVD == LenReg))))
     return;

   // 3) Try to infer if Len is constant and exceeds the array size
@@ -269,12 +388,13 @@     // Otherwise, do not early report here; continue checks.
   }

-  // 4) Infer maximal value for symbolic Len
+  // 4) Infer maximal value for symbolic Len using constraints from prior branches
   if (LenSym) {
     if (const llvm::APSInt *MaxV = inferSymbolMaxVal(LenSym, C)) {
-      uint64_t MaxVal = MaxV->isSigned() ? (uint64_t)MaxV->getSExtValue() : MaxV->getZExtValue();
+      uint64_t MaxVal = MaxV->isSigned() ? (uint64_t)MaxV->getSExtValue()
+                                         : MaxV->getZExtValue();
       if (MaxVal <= SafeCopyLimit)
-        return; // safely bounded
+        return; // safely bounded by sizeof(array) - 1
       if (MaxVal > ArraySize) {
         // Definitely can exceed buffer size.
         reportUnbounded(Call, DstArg, LenArg, C);
