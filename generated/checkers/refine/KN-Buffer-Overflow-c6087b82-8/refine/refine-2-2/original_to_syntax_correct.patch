--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -16,6 +16,7 @@ #include "clang/AST/Stmt.h"
 #include "clang/AST/Type.h"
 #include "clang/Lex/Lexer.h"
+#include "clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h"

 using namespace clang;
 using namespace ento;
@@ -26,6 +27,9 @@ REGISTER_MAP_WITH_PROGRAMSTATE(ArraySafeLenMap, const MemRegion*, const MemRegion*)
 // Optional fallback: symbols that we heuristically believe are bounded by some sizeof()
 REGISTER_SET_WITH_PROGRAMSTATE(BoundedLenSyms, SymbolRef)
+// Reverse map: for a given length variable region, remember which array region it safely bounds.
+// This helps us drop stale associations on reassignment.
+REGISTER_MAP_WITH_PROGRAMSTATE(LenToArrayMap, const MemRegion*, const MemRegion*)

 namespace {

@@ -56,6 +60,24 @@   void getLenArgRegionOrSymbol(const Expr *LenArg, CheckerContext &C,
                                const MemRegion* &LenReg, SymbolRef &LenSym) const;

+  // Analyze RHS expression to decide whether it establishes upper bound based on sizeof(Arr).
+  bool rhsEstablishesUpperBoundForArray(const Expr *RHS,
+                                        const MemRegion* &ArrRegOut,
+                                        CheckerContext &C) const;
+
+  // Helpers for rhsEstablishesUpperBoundForArray
+  const Expr* ignoreParenImpCasts(const Expr *E) const {
+    return E ? E->IgnoreParenImpCasts() : nullptr;
+  }
+  bool isSizeofOfArrayExpr(const Expr *E, const MemRegion* &ArrRegOut,
+                           CheckerContext &C) const;
+  bool isSizeofMinusConstExpr(const Expr *E, const MemRegion* &ArrRegOut,
+                              CheckerContext &C) const;
+  bool extractUpperBoundExprArr(const Expr *E, const MemRegion* &ArrRegOut,
+                                CheckerContext &C) const;
+  bool isMinLikeTernaryWithUB(const Expr *RHS, const MemRegion* &ArrRegOut,
+                              CheckerContext &C) const;
+
   void reportUnbounded(const CallEvent &Call, const Expr *Dst,
                        const Expr *Len, CheckerContext &C) const;
 };
@@ -64,7 +86,6 @@   const Expr *OE = Call.getOriginExpr();
   if (!OE)
     return false;
-  // Use textual match as recommended to be robust with macros and wrappers.
   if (ExprHasName(OE, "copy_from_user", C))
     return true;
   if (ExprHasName(OE, "__copy_from_user", C))
@@ -80,11 +101,9 @@   ArrReg = nullptr;
   ArrName.clear();

-  // Identify that DstArg is a fixed-size array and retrieve its size
   if (!getArraySizeFromExpr(ArraySize, DstArg))
     return false;

-  // Retrieve the region of the destination and normalize to base region
   const MemRegion *MR = getMemRegionFromExpr(DstArg, C);
   if (!MR)
     return false;
@@ -93,7 +112,6 @@     return false;
   ArrReg = MR;

-  // Try extracting the array variable name
   if (const auto *DRE = dyn_cast<DeclRefExpr>(DstArg->IgnoreImplicit())) {
     if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {
       ArrName = VD->getNameAsString();
@@ -108,7 +126,6 @@   if (!E || !ArrReg)
     return false;

-  // AST-based check: find a sizeof(...) inside E that references the same array
   if (const auto *UE = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(E)) {
     if (UE->getKind() == UETT_SizeOf) {
       if (const Expr *Arg = UE->getArgumentExpr()) {
@@ -122,7 +139,6 @@     }
   }

-  // Textual fallback heuristic: expression contains both "sizeof" and the array's name
   if (!ArrName.empty() && ExprHasName(E, "sizeof", C) && ExprHasName(E, ArrName, C))
     return true;

@@ -136,8 +152,18 @@
   ProgramStateRef State = C.getState();

-  // Try to get region
+  // Try to get region through the usual SVal lvalue path.
   const MemRegion *MR = getMemRegionFromExpr(LenArg, C);
+  if (!MR) {
+    // If LenArg is a DeclRefExpr (rvalue), construct its VarRegion to obtain the region.
+    if (const auto *DRE = dyn_cast_or_null<DeclRefExpr>(LenArg ? LenArg->IgnoreImplicit() : nullptr)) {
+      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {
+        MemRegionManager &MRMgr = C.getSValBuilder().getRegionManager();
+        const MemRegion *VarR = MRMgr.getVarRegion(VD, C.getLocationContext());
+        MR = VarR;
+      }
+    }
+  }
   if (MR) {
     MR = MR->getBaseRegion();
     LenReg = MR;
@@ -146,6 +172,180 @@   // Try to get symbol
   SVal SV = State->getSVal(LenArg, C.getLocationContext());
   LenSym = SV.getAsSymbol();
+}
+
+bool SAGenTestChecker::isSizeofOfArrayExpr(const Expr *E, const MemRegion* &ArrRegOut,
+                                           CheckerContext &C) const {
+  ArrRegOut = nullptr;
+  const Expr *IE = ignoreParenImpCasts(E);
+  const auto *UE = dyn_cast_or_null<UnaryExprOrTypeTraitExpr>(IE);
+  if (!UE || UE->getKind() != UETT_SizeOf)
+    return false;
+  const Expr *Arg = UE->getArgumentExpr();
+  if (!Arg)
+    return false;
+  llvm::APInt DummySize;
+  if (!getArraySizeFromExpr(DummySize, Arg))
+    return false;
+  const MemRegion *MR = getMemRegionFromExpr(Arg, C);
+  if (!MR)
+    return false;
+  MR = MR->getBaseRegion();
+  if (!MR)
+    return false;
+  ArrRegOut = MR;
+  return true;
+}
+
+bool SAGenTestChecker::isSizeofMinusConstExpr(const Expr *E, const MemRegion* &ArrRegOut,
+                                              CheckerContext &C) const {
+  ArrRegOut = nullptr;
+  const Expr *IE = ignoreParenImpCasts(E);
+  const auto *BO = dyn_cast_or_null<BinaryOperator>(IE);
+  if (!BO || BO->getOpcode() != BO_Sub)
+    return false;
+  const Expr *L = ignoreParenImpCasts(BO->getLHS());
+  const Expr *R = ignoreParenImpCasts(BO->getRHS());
+  const auto *UE = dyn_cast<UnaryExprOrTypeTraitExpr>(L);
+  if (!UE || UE->getKind() != UETT_SizeOf)
+    return false;
+
+  // RHS must be an integer constant (>= 0)
+  llvm::APSInt EvalRes;
+  if (!EvaluateExprToInt(EvalRes, R, C))
+    return false;
+
+  const Expr *Arg = UE->getArgumentExpr();
+  if (!Arg)
+    return false;
+  llvm::APInt DummySize;
+  if (!getArraySizeFromExpr(DummySize, Arg))
+    return false;
+  const MemRegion *MR = getMemRegionFromExpr(Arg, C);
+  if (!MR)
+    return false;
+  MR = MR->getBaseRegion();
+  if (!MR)
+    return false;
+
+  ArrRegOut = MR;
+  return true;
+}
+
+bool SAGenTestChecker::extractUpperBoundExprArr(const Expr *E, const MemRegion* &ArrRegOut,
+                                                CheckerContext &C) const {
+  // UB is sizeof(arr) or sizeof(arr) - const
+  if (isSizeofOfArrayExpr(E, ArrRegOut, C))
+    return true;
+  if (isSizeofMinusConstExpr(E, ArrRegOut, C))
+    return true;
+  return false;
+}
+
+bool SAGenTestChecker::isMinLikeTernaryWithUB(const Expr *RHS, const MemRegion* &ArrRegOut,
+                                              CheckerContext &C) const {
+  ArrRegOut = nullptr;
+  const auto *CO = dyn_cast_or_null<ConditionalOperator>(ignoreParenImpCasts(RHS));
+  if (!CO)
+    return false;
+
+  const Expr *Cond = ignoreParenImpCasts(CO->getCond());
+  const Expr *TrueE = ignoreParenImpCasts(CO->getTrueExpr());
+  const Expr *FalseE = ignoreParenImpCasts(CO->getFalseExpr());
+
+  const auto *BO = dyn_cast_or_null<BinaryOperator>(Cond);
+  if (!BO)
+    return false;
+
+  const Expr *CL = ignoreParenImpCasts(BO->getLHS());
+  const Expr *CR = ignoreParenImpCasts(BO->getRHS());
+
+  const MemRegion *UBArrL = nullptr, *UBArrR = nullptr;
+  bool LIsUB = extractUpperBoundExprArr(CL, UBArrL, C);
+  bool RIsUB = extractUpperBoundExprArr(CR, UBArrR, C);
+
+  BinaryOperatorKind Op = BO->getOpcode();
+
+  // Helper lambda: check if branch selection matches min pattern
+  auto matchPattern = [&](bool UBIsRHS, BinaryOperatorKind OpK,
+                          const Expr *TrueB, const Expr *FalseB,
+                          const MemRegion *UBArr) -> bool {
+    if (!UBArr)
+      return false;
+    // If UB is RHS:
+    //   X > UB  ? UB : X   (True branch = UB)
+    //   X >= UB ? UB : X
+    //   X < UB  ? X  : UB  (False branch = UB)
+    //   X <= UB ? X  : UB
+    if (UBIsRHS) {
+      if ((OpK == BO_GT || OpK == BO_GE)) {
+        if (extractUpperBoundExprArr(TrueB, ArrRegOut, C) && ArrRegOut == UBArr)
+          return true;
+      } else if ((OpK == BO_LT || OpK == BO_LE)) {
+        if (extractUpperBoundExprArr(FalseB, ArrRegOut, C) && ArrRegOut == UBArr)
+          return true;
+      }
+    } else {
+      // If UB is LHS:
+      //   UB < X  ? UB : X  (True branch = UB)
+      //   UB <= X ? UB : X
+      //   UB > X  ? X  : UB (False branch = UB)
+      //   UB >= X ? X  : UB
+      if ((OpK == BO_LT || OpK == BO_LE)) {
+        if (extractUpperBoundExprArr(TrueB, ArrRegOut, C) && ArrRegOut == UBArr)
+          return true;
+      } else if ((OpK == BO_GT || OpK == BO_GE)) {
+        if (extractUpperBoundExprArr(FalseB, ArrRegOut, C) && ArrRegOut == UBArr)
+          return true;
+      }
+    }
+    ArrRegOut = nullptr;
+    return false;
+  };
+
+  if (RIsUB && matchPattern(/*UBIsRHS=*/true, Op, TrueE, FalseE, UBArrR))
+    return true;
+  if (LIsUB && matchPattern(/*UBIsRHS=*/false, Op, TrueE, FalseE, UBArrL))
+    return true;
+
+  return false;
+}
+
+bool SAGenTestChecker::rhsEstablishesUpperBoundForArray(const Expr *RHS,
+                                                        const MemRegion* &ArrRegOut,
+                                                        CheckerContext &C) const {
+  ArrRegOut = nullptr;
+  const Expr *IE = ignoreParenImpCasts(RHS);
+
+  // Direct bound: sizeof(arr) or sizeof(arr) - const
+  if (extractUpperBoundExprArr(IE, ArrRegOut, C))
+    return true;
+
+  // Ternary min pattern: (X > sizeof(arr)-k ? sizeof(arr)-k : X) etc.
+  if (isMinLikeTernaryWithUB(IE, ArrRegOut, C))
+    return true;
+
+  // Heuristic: min(...) macro with sizeof(array)
+  if (ExprHasName(RHS, "min", C) || ExprHasName(RHS, "min_t", C)) {
+    // Try to confirm sizeof refers to an array and extract it
+    const auto *UE = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(RHS);
+    if (UE && UE->getKind() == UETT_SizeOf) {
+      const Expr *Arg = UE->getArgumentExpr();
+      llvm::APInt DummySize;
+      if (Arg && getArraySizeFromExpr(DummySize, Arg)) {
+        const MemRegion *MR = getMemRegionFromExpr(Arg, C);
+        if (MR) {
+          MR = MR->getBaseRegion();
+          if (MR) {
+            ArrRegOut = MR;
+            return true;
+          }
+        }
+      }
+    }
+  }
+
+  return false;
 }

 void SAGenTestChecker::reportUnbounded(const CallEvent &Call, const Expr *Dst,
@@ -187,25 +387,25 @@   if (!RHS)
     return;

-  // Look for sizeof(array) in RHS; if found, associate the array with this LHS length variable
-  if (const auto *UE = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(RHS)) {
-    if (UE->getKind() == UETT_SizeOf) {
-      if (const Expr *Arg = UE->getArgumentExpr()) {
-        // Confirm it's an array decl ref
-        llvm::APInt DummySize;
-        if (getArraySizeFromExpr(DummySize, Arg)) {
-          const MemRegion *ArrMR = getMemRegionFromExpr(Arg, C);
-          if (ArrMR) {
-            ArrMR = ArrMR->getBaseRegion();
-            if (ArrMR) {
-              State = State->set<ArraySafeLenMap>(ArrMR, LHSReg);
-            }
-          }
-        }
-      }
+  // Drop stale association if this length variable was previously tied to some array.
+  if (const MemRegion *const *OldArrPtr = State->get<LenToArrayMap>(LHSReg)) {
+    const MemRegion *OldArr = *OldArrPtr;
+    // Remove both sides of the mapping.
+    State = State->remove<ArraySafeLenMap>(OldArr);
+    State = State->remove<LenToArrayMap>(LHSReg);
+  }
+
+  // Try to see if RHS establishes a bound based on sizeof(array)
+  const MemRegion *ArrMR = nullptr;
+  if (rhsEstablishesUpperBoundForArray(RHS, ArrMR, C)) {
+    if (ArrMR) {
+      State = State->set<ArraySafeLenMap>(ArrMR, LHSReg);
+      State = State->set<LenToArrayMap>(LHSReg, ArrMR);
+      C.addTransition(State);
+      return;
     }
   } else {
-    // Weak heuristic: if RHS contains both min and sizeof, consider LHS symbol bounded
+    // Weak heuristic: if RHS contains both min and sizeof, consider LHS symbol bounded (fallback).
     if (ExprHasName(RHS, "min", C) && ExprHasName(RHS, "sizeof", C)) {
       if (SymbolRef Sym = Val.getAsSymbol())
         State = State->add<BoundedLenSyms>(Sym);
@@ -237,7 +437,7 @@   uint64_t ArraySize = ArraySizeAP.getZExtValue();
   uint64_t SafeCopyLimit = (ArraySize > 0) ? (ArraySize - 1) : 0;

-  // 1) Len directly contains sizeof(array)
+  // 1) Len directly contains sizeof(array) (e.g., min in-call)
   if (exprContainsSizeofOfArray(LenArg, ArrReg, ArrName, C))
     return;

@@ -255,18 +455,16 @@   // 3) Try to infer if Len is constant and exceeds the array size
   llvm::APSInt ConstLen;
   if (EvaluateExprToInt(ConstLen, LenArg, C)) {
-    // If definitely larger than the array, report.
     if (ConstLen.isSigned() ? ConstLen.getSExtValue() > (int64_t)ArraySize
                             : ConstLen.getZExtValue() > ArraySize) {
       reportUnbounded(Call, DstArg, LenArg, C);
       return;
     }
-    // If definitely <= SafeCopyLimit, consider safe.
     if (ConstLen.isSigned() ? ConstLen.getSExtValue() <= (int64_t)SafeCopyLimit
                             : ConstLen.getZExtValue() <= SafeCopyLimit) {
       return;
     }
-    // Otherwise, do not early report here; continue checks.
+    // Otherwise, continue checks.
   }

   // 4) Infer maximal value for symbolic Len
@@ -281,7 +479,6 @@         return;
       }
     }
-    // Weak heuristic: if we heuristically said the symbol is bounded, accept it.
     if (State->contains<BoundedLenSyms>(LenSym))
       return;
   }
