### Report Summary

File:| net/bridge/br_ioctl.c
---|---
Warning:| line 382, column 7
copy_from_user length not bounded by destination buffer size

### Annotated Source Code


57    |  unsigned long maxnum, unsigned long offset)
58    | {
59    |  int num;
60    |  void *buf;
61    | 	size_t size;
62    |
63    |  /* Clamp size to PAGE_SIZE, test maxnum to avoid overflow */
64    |  if (maxnum > PAGE_SIZE/sizeof(struct __fdb_entry))
65    | 		maxnum = PAGE_SIZE/sizeof(struct __fdb_entry);
66    |
67    | 	size = maxnum * sizeof(struct __fdb_entry);
68    |
69    | 	buf = kmalloc(size, GFP_USER);
70    |  if (!buf)
71    |  return -ENOMEM;
72    |
73    | 	num = br_fdb_fillbuf(br, buf, maxnum, offset);
74    |  if (num > 0) {
75    |  if (copy_to_user(userbuf, buf,
76    |  array_size(num, sizeof(struct __fdb_entry))))
77    | 			num = -EFAULT;
78    | 	}
79    | 	kfree(buf);
80    |
81    |  return num;
82    | }
83    |
84    | /* called with RTNL */
85    | static int add_del_if(struct net_bridge *br, int ifindex, int isadd)
86    | {
87    |  struct net *net = dev_net(br->dev);
88    |  struct net_device *dev;
89    |  int ret;
90    |
91    |  if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
92    |  return -EPERM;
93    |
94    | 	dev = __dev_get_by_index(net, ifindex);
95    |  if (dev == NULL)
96    |  return -EINVAL;
97    |
98    |  if (isadd)
99    | 		ret = br_add_if(br, dev, NULL);
100   |  else
101   | 		ret = br_del_if(br, dev);
102   |
103   |  return ret;
104   | }
105   |
106   | #define BR_UARGS_MAX 4
107   | static int br_dev_read_uargs(unsigned long *args, size_t nr_args,
108   |  void __user **argp, void __user *data)
109   | {
110   |  int ret;
111   |
112   |  if (nr_args < 2 || nr_args > BR_UARGS_MAX)
113   |  return -EINVAL;
114   |
115   |  if (in_compat_syscall()) {
116   |  unsigned int cargs[BR_UARGS_MAX];
117   |  int i;
118   |
119   | 		ret = copy_from_user(cargs, data, nr_args * sizeof(*cargs));
120   |  if (ret)
121   |  goto fault;
122   |
123   |  for (i = 0; i < nr_args; ++i)
124   | 			args[i] = cargs[i];
125   |
126   | 		*argp = compat_ptr(args[1]);
127   | 	} else {
128   | 		ret = copy_from_user(args, data, nr_args * sizeof(*args));
129   |  if (ret)
130   |  goto fault;
131   | 		*argp = (void __user *)args[1];
132   | 	}
133   |
134   |  return 0;
135   | fault:
136   |  return -EFAULT;
137   | }
138   |
139   | /*
140   |  * Legacy ioctl's through SIOCDEVPRIVATE
141   |  * This interface is deprecated because it was too difficult
142   |  * to do the translation for 32/64bit ioctl compatibility.
143   |  */
144   | int br_dev_siocdevprivate(struct net_device *dev, struct ifreq *rq,
145   |  void __user *data, int cmd)
146   | {
147   |  struct net_bridge *br = netdev_priv(dev);
148   |  struct net_bridge_port *p = NULL;
149   |  unsigned long args[4];
150   |  void __user *argp;
151   |  int ret;
152   |
153   | 	ret = br_dev_read_uargs(args, ARRAY_SIZE(args), &argp, data);
154   |  if (ret)
155   |  return ret;
156   |
157   |  switch (args[0]) {
158   |  case BRCTL_ADD_IF:
159   |  case BRCTL_DEL_IF:
160   |  return add_del_if(br, args[1], args[0] == BRCTL_ADD_IF);
161   |
162   |  case BRCTL_GET_BRIDGE_INFO:
163   | 	{
164   |  struct __bridge_info b;
289   |
290   | 		br_stp_set_bridge_priority(br, args[1]);
291   | 		ret = 0;
292   |  break;
293   |
294   |  case BRCTL_SET_PORT_PRIORITY:
295   | 	{
296   |  if (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))
297   |  return -EPERM;
298   |
299   | 		spin_lock_bh(&br->lock);
300   |  if ((p = br_get_port(br, args[1])) == NULL)
301   | 			ret = -EINVAL;
302   |  else
303   | 			ret = br_stp_set_port_priority(p, args[2]);
304   | 		spin_unlock_bh(&br->lock);
305   |  break;
306   | 	}
307   |
308   |  case BRCTL_SET_PATH_COST:
309   | 	{
310   |  if (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))
311   |  return -EPERM;
312   |
313   | 		spin_lock_bh(&br->lock);
314   |  if ((p = br_get_port(br, args[1])) == NULL)
315   | 			ret = -EINVAL;
316   |  else
317   | 			ret = br_stp_set_path_cost(p, args[2]);
318   | 		spin_unlock_bh(&br->lock);
319   |  break;
320   | 	}
321   |
322   |  case BRCTL_GET_FDB_ENTRIES:
323   |  return get_fdb_entries(br, argp, args[2], args[3]);
324   |
325   |  default:
326   | 		ret = -EOPNOTSUPP;
327   | 	}
328   |
329   |  if (!ret) {
330   |  if (p)
331   | 			br_ifinfo_notify(RTM_NEWLINK, NULL, p);
332   |  else
333   | 			netdev_state_change(br->dev);
334   | 	}
335   |
336   |  return ret;
337   | }
338   |
339   | static int old_deviceless(struct net *net, void __user *data)
340   | {
341   |  unsigned long args[3];
342   |  void __user *argp;
343   |  int ret;
344   |
345   | 	ret = br_dev_read_uargs(args, ARRAY_SIZE(args), &argp, data);
346   |  if (ret2.1'ret' is 0)
    3←Taking false branch→
347   |  return ret;
348   |
349   |  switch (args[0]) {
    4←Control jumps to 'case 3:'  at line 375→
350   |  case BRCTL_GET_VERSION:
351   |  return BRCTL_VERSION;
352   |
353   |  case BRCTL_GET_BRIDGES:
354   | 	{
355   |  int *indices;
356   |  int ret = 0;
357   |
358   |  if (args[2] >= 2048)
359   |  return -ENOMEM;
360   | 		indices = kcalloc(args[2], sizeof(int), GFP_KERNEL);
361   |  if (indices == NULL)
362   |  return -ENOMEM;
363   |
364   | 		args[2] = get_bridge_ifindices(net, indices, args[2]);
365   |
366   | 		ret = copy_to_user(argp, indices,
367   |  array_size(args[2], sizeof(int)))
368   | 			? -EFAULT : args[2];
369   |
370   | 		kfree(indices);
371   |  return ret;
372   | 	}
373   |
374   |  case BRCTL_ADD_BRIDGE:
375   |  case BRCTL_DEL_BRIDGE:
376   | 	{
377   |  char buf[IFNAMSIZ];
378   |
379   |  if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
    5←Assuming the condition is false→
    6←Taking false branch→
380   |  return -EPERM;
381   |
382   |  if (copy_from_user(buf, argp, IFNAMSIZ))
    7←copy_from_user length not bounded by destination buffer size
383   |  return -EFAULT;
384   |
385   | 		buf[IFNAMSIZ-1] = 0;
386   |
387   |  if (args[0] == BRCTL_ADD_BRIDGE)
388   |  return br_add_bridge(net, buf);
389   |
390   |  return br_del_bridge(net, buf);
391   | 	}
392   | 	}
393   |
394   |  return -EOPNOTSUPP;
395   | }
396   |
397   | int br_ioctl_stub(struct net *net, struct net_bridge *br, unsigned int cmd,
398   |  struct ifreq *ifr, void __user *uarg)
399   | {
400   |  int ret = -EOPNOTSUPP;
401   |
402   | 	rtnl_lock();
403   |
404   |  switch (cmd) {
    1Control jumps to 'case 35137:'  at line 406→
405   |  case SIOCGIFBR:
406   |  case SIOCSIFBR:
407   |  ret = old_deviceless(net, uarg);
    2←Calling 'old_deviceless'→
408   |  break;
409   |  case SIOCBRADDBR:
410   |  case SIOCBRDELBR:
411   | 	{
412   |  char buf[IFNAMSIZ];
413   |
414   |  if (!ns_capable(net->user_ns, CAP_NET_ADMIN)) {
415   | 			ret = -EPERM;
416   |  break;
417   | 		}
418   |
419   |  if (copy_from_user(buf, uarg, IFNAMSIZ)) {
420   | 			ret = -EFAULT;
421   |  break;
422   | 		}
423   |
424   | 		buf[IFNAMSIZ-1] = 0;
425   |  if (cmd == SIOCBRADDBR)
426   | 			ret = br_add_bridge(net, buf);
427   |  else
428   | 			ret = br_del_bridge(net, buf);
429   | 	}
430   |  break;
431   |  case SIOCBRADDIF:
432   |  case SIOCBRDELIF:
433   | 		ret = add_del_if(br, ifr->ifr_ifindex, cmd == SIOCBRADDIF);
434   |  break;
435   | 	}
436   |
437   | 	rtnl_unlock();
