### Report Summary

File:| fs/proc/task_mmu.c
---|---
Warning:| line 1258, column 6
copy_from_user length not bounded by destination buffer size

### Annotated Source Code


1195  |  if (cp->type == CLEAR_REFS_SOFT_DIRTY) {
1196  | 			clear_soft_dirty(vma, addr, pte);
1197  |  continue;
1198  | 		}
1199  |
1200  |  if (!pte_present(ptent))
1201  |  continue;
1202  |
1203  | 		page = vm_normal_page(vma, addr, ptent);
1204  |  if (!page)
1205  |  continue;
1206  |
1207  |  /* Clear accessed and referenced bits. */
1208  | 		ptep_test_and_clear_young(vma, addr, pte);
1209  | 		test_and_clear_page_young(page);
1210  | 		ClearPageReferenced(page);
1211  | 	}
1212  |  pte_unmap_unlock(pte - 1, ptl);
1213  |  cond_resched();
1214  |  return 0;
1215  | }
1216  |
1217  | static int clear_refs_test_walk(unsigned long start, unsigned long end,
1218  |  struct mm_walk *walk)
1219  | {
1220  |  struct clear_refs_private *cp = walk->private;
1221  |  struct vm_area_struct *vma = walk->vma;
1222  |
1223  |  if (vma->vm_flags & VM_PFNMAP)
1224  |  return 1;
1225  |
1226  |  /*
1227  |  * Writing 1 to /proc/pid/clear_refs affects all pages.
1228  |  * Writing 2 to /proc/pid/clear_refs only affects anonymous pages.
1229  |  * Writing 3 to /proc/pid/clear_refs only affects file mapped pages.
1230  |  * Writing 4 to /proc/pid/clear_refs affects all pages.
1231  |  */
1232  |  if (cp->type == CLEAR_REFS_ANON && vma->vm_file)
1233  |  return 1;
1234  |  if (cp->type == CLEAR_REFS_MAPPED && !vma->vm_file)
1235  |  return 1;
1236  |  return 0;
1237  | }
1238  |
1239  | static const struct mm_walk_ops clear_refs_walk_ops = {
1240  | 	.pmd_entry		= clear_refs_pte_range,
1241  | 	.test_walk		= clear_refs_test_walk,
1242  | 	.walk_lock		= PGWALK_WRLOCK,
1243  | };
1244  |
1245  | static ssize_t clear_refs_write(struct file *file, const char __user *buf,
1246  | 				size_t count, loff_t *ppos)
1247  | {
1248  |  struct task_struct *task;
1249  |  char buffer[PROC_NUMBUF] = {};
1250  |  struct mm_struct *mm;
1251  |  struct vm_area_struct *vma;
1252  |  enum clear_refs_types type;
1253  |  int itype;
1254  |  int rv;
1255  |
1256  |  if (count > sizeof(buffer) - 1)
    1Assuming the condition is true→
    2←Taking true branch→
1257  |  count = sizeof(buffer) - 1;
1258  |  if (copy_from_user(buffer, buf, count))
    3←copy_from_user length not bounded by destination buffer size
1259  |  return -EFAULT;
1260  | 	rv = kstrtoint(strstrip(buffer), 10, &itype);
1261  |  if (rv < 0)
1262  |  return rv;
1263  | 	type = (enum clear_refs_types)itype;
1264  |  if (type < CLEAR_REFS_ALL || type >= CLEAR_REFS_LAST)
1265  |  return -EINVAL;
1266  |
1267  | 	task = get_proc_task(file_inode(file));
1268  |  if (!task)
1269  |  return -ESRCH;
1270  | 	mm = get_task_mm(task);
1271  |  if (mm) {
1272  |  VMA_ITERATOR(vmi, mm, 0);
1273  |  struct mmu_notifier_range range;
1274  |  struct clear_refs_private cp = {
1275  | 			.type = type,
1276  | 		};
1277  |
1278  |  if (mmap_write_lock_killable(mm)) {
1279  | 			count = -EINTR;
1280  |  goto out_mm;
1281  | 		}
1282  |  if (type == CLEAR_REFS_MM_HIWATER_RSS) {
1283  |  /*
1284  |  * Writing 5 to /proc/pid/clear_refs resets the peak
1285  |  * resident set size to this mm's current rss value.
1286  |  */
1287  | 			reset_mm_hiwater_rss(mm);
1288  |  goto out_unlock;
