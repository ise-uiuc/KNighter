--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -56,6 +56,10 @@   void getLenArgRegionOrSymbol(const Expr *LenArg, CheckerContext &C,
                                const MemRegion* &LenReg, SymbolRef &LenSym) const;

+  // Check via path-sensitive constraints if LenArg is proven <= SafeCopyLimit.
+  bool isLenProvedLEViaState(const Expr *LenArg, uint64_t SafeCopyLimit,
+                             CheckerContext &C) const;
+
   void reportUnbounded(const CallEvent &Call, const Expr *Dst,
                        const Expr *Len, CheckerContext &C) const;
 };
@@ -146,6 +150,37 @@   // Try to get symbol
   SVal SV = State->getSVal(LenArg, C.getLocationContext());
   LenSym = SV.getAsSymbol();
+}
+
+bool SAGenTestChecker::isLenProvedLEViaState(const Expr *LenArg, uint64_t SafeCopyLimit,
+                                             CheckerContext &C) const {
+  ProgramStateRef State = C.getState();
+  if (!State || !LenArg)
+    return false;
+
+  SValBuilder &SB = C.getSValBuilder();
+  SVal LenV = State->getSVal(LenArg, C.getLocationContext());
+  if (LenV.isUnknownOrUndef())
+    return false;
+
+  // Build the limit value in the correct type domain to avoid cast issues.
+  QualType LenTy = LenArg->getType();
+  SVal LimitV = SB.makeIntVal(SafeCopyLimit, LenTy);
+
+  // Construct comparison: (LenV > LimitV)
+  SVal Cmp = SB.evalBinOp(State, BO_GT, LenV, LimitV, SB.getConditionType());
+  if (Cmp.isUnknownOrUndef())
+    return false;
+
+  DefinedOrUnknownSVal DCmp = Cmp.castAs<DefinedOrUnknownSVal>();
+
+  // If (LenV > LimitV) is infeasible, then LenV <= LimitV is proven.
+  ProgramStateRef StGT = State->assume(DCmp, true);
+  if (!StGT)
+    return true; // cannot be greater than limit -> safe
+
+  // Otherwise, not proven safe by constraints.
+  return false;
 }

 void SAGenTestChecker::reportUnbounded(const CallEvent &Call, const Expr *Dst,
@@ -243,6 +278,10 @@
   ProgramStateRef State = C.getState();

+  // 1.5) Path-sensitive proof: if we can prove Len <= SafeCopyLimit via constraints, accept as safe.
+  if (isLenProvedLEViaState(LenArg, SafeCopyLimit, C))
+    return;
+
   // 2) Len is a variable that we already recorded as safe for this array
   const MemRegion *const *BoundRegForArrayPtr = State->get<ArraySafeLenMap>(ArrReg);
   const MemRegion *BoundRegForArray = BoundRegForArrayPtr ? *BoundRegForArrayPtr : nullptr;
