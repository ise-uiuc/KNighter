--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -365,6 +365,15 @@   void reportIssue(const ArraySubscriptExpr *ASE, const VarDecl *IVar,
                    uint64_t UBExclusive, uint64_t Cap,
                    BugReporter &BR, const ASTContext &Ctx) const;
+
+  // Helper: detect kernel-style for_each_* macro loops with enum induction variables.
+  static bool isEnumMacroLoop(const ForStmt *FS, const VarDecl *IVar) {
+    if (!FS || !IVar) return false;
+    if (!FS->getForLoc().isMacroID())
+      return false;
+    QualType T = IVar->getType();
+    return T->isEnumeralType();
+  }
 };

 //====================== Helper implementations ======================
@@ -638,7 +647,7 @@   }

   // We only handle LB == 0
-  if (InitVal != 0) return false;
+  if (InitVal.getLimitedValue() != 0) return false;

   // Parse condition: i < N or i <= N
   const Expr *Cond = FS->getCond();
@@ -661,7 +670,8 @@     UBExclusive = RHSVal;
   } else {
     // i <= N  => UBExclusive = N + 1
-    UBExclusive = RHSVal + 1;
+    UBExclusive = RHSVal;
+    ++UBExclusive;
   }

   LB = InitVal;
@@ -693,6 +703,11 @@   llvm::APSInt LB, UBEx, RHSVal;
   BinaryOperator::Opcode CondOp;
   if (!getLoopIndexAndBounds(FS, Ctx, IVar, LB, UBEx, CondOp, RHSVal))
+    return;
+
+  // Suppress enumeration-style, macro-expanded loop patterns (e.g., for_each_pipe),
+  // which are known to be safe and otherwise produce false positives.
+  if (isEnumMacroLoop(FS, IVar))
     return;

   // Only consider LB == 0 (already filtered)
