--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -20,8 +20,6 @@ using namespace clang;
 using namespace ento;
 using namespace taint;
-
-// No custom program states are necessary for this AST-only checker.

 namespace {

@@ -39,6 +37,33 @@                                      const VarDecl *IVar, uint64_t Cap);
 static bool isGuardedBeforeUse(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
                                const VarDecl *IVar, uint64_t Cap);
+
+// New helpers to eliminate macro-originated false positives
+static bool isFromMacro(const SourceRange &SR) {
+  if (SR.isInvalid())
+    return false;
+  SourceLocation B = SR.getBegin();
+  SourceLocation E = SR.getEnd();
+  return (B.isMacroID() || E.isMacroID());
+}
+
+static bool isFromMacro(const Expr *E) {
+  if (!E) return false;
+  return isFromMacro(E->getSourceRange()) || E->getExprLoc().isMacroID();
+}
+
+// A single place to decide whether this ASE is a known false positive.
+// Currently filters macro-originated subscripts, which covers the reported case
+// (e.g., IF_ISSET-style bitset helpers).
+static bool isFalsePositive(const ArraySubscriptExpr *ASE) {
+  if (!ASE) return false;
+  // If either the subscript expression itself, its base, or its index come from
+  // a macro expansion, skip. Macros often hide bitset/packing tricks that the
+  // AST-only checker cannot reason about safely.
+  if (isFromMacro(ASE) || isFromMacro(ASE->getBase()) || isFromMacro(ASE->getIdx()))
+    return true;
+  return false;
+}

 class SAGenTestChecker : public Checker<check::ASTCodeBody> {
    mutable std::unique_ptr<BugType> BT;
@@ -418,6 +443,10 @@       const Expr *Idx = ASE->getIdx();
       if (!Idx) return true;

+      // Filter out known false positives early.
+      if (isFalsePositive(ASE))
+        return true;
+
       // Only consider subscripts where the index is directly the loop variable.
       if (!indexIsDirectLoopVar(Idx, IVar))
         return true;
