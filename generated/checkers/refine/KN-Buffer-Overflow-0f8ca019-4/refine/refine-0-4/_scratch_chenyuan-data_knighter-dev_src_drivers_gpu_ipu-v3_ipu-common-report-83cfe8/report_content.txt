### Report Summary

File:| drivers/gpu/ipu-v3/ipu-common.c
---|---
Warning:| line 1234, column 25
Loop bound exceeds array capacity: index 'i' goes up to 479 but array size is
15

### Annotated Source Code


1184  |
1185  |  return 0;
1186  |
1187  | err_register:
1188  | 	platform_device_unregister_children(to_platform_device(dev));
1189  |
1190  |  return ret;
1191  | }
1192  |
1193  |
1194  | static int ipu_irq_init(struct ipu_soc *ipu)
1195  | {
1196  |  struct irq_chip_generic *gc;
1197  |  struct irq_chip_type *ct;
1198  |  unsigned long unused[IPU_NUM_IRQS / 32] = {
1199  | 		0x400100d0, 0xffe000fd,
1200  | 		0x400100d0, 0xffe000fd,
1201  | 		0x400100d0, 0xffe000fd,
1202  | 		0x4077ffff, 0xffe7e1fd,
1203  | 		0x23fffffe, 0x8880fff0,
1204  | 		0xf98fe7d0, 0xfff81fff,
1205  | 		0x400100d0, 0xffe000fd,
1206  | 		0x00000000,
1207  | 	};
1208  |  int ret, i;
1209  |
1210  | 	ipu->domain = irq_domain_add_linear(ipu->dev->of_node, IPU_NUM_IRQS,
1211  | 					    &irq_generic_chip_ops, ipu);
1212  |  if (!ipu->domain) {
1213  |  dev_err(ipu->dev, "failed to add irq domain\n");
1214  |  return -ENODEV;
1215  | 	}
1216  |
1217  | 	ret = irq_alloc_domain_generic_chips(ipu->domain, 32, 1, "IPU",
1218  |  handle_level_irq, 0, 0, 0);
1219  |  if (ret < 0) {
1220  |  dev_err(ipu->dev, "failed to alloc generic irq chips\n");
1221  | 		irq_domain_remove(ipu->domain);
1222  |  return ret;
1223  | 	}
1224  |
1225  |  /* Mask and clear all interrupts */
1226  |  for (i = 0; i < IPU_NUM_IRQS; i += 32) {
1227  | 		ipu_cm_write(ipu, 0, IPU_INT_CTRL(i / 32));
1228  | 		ipu_cm_write(ipu, ~unused[i / 32], IPU_INT_STAT(i / 32));
1229  | 	}
1230  |
1231  |  for (i = 0; i < IPU_NUM_IRQS; i += 32) {
1232  | 		gc = irq_get_domain_generic_chip(ipu->domain, i);
1233  | 		gc->reg_base = ipu->cm_reg;
1234  | 		gc->unused = unused[i / 32];
    Loop bound exceeds array capacity: index 'i' goes up to 479 but array size is 15
1235  | 		ct = gc->chip_types;
1236  | 		ct->chip.irq_ack = irq_gc_ack_set_bit;
1237  | 		ct->chip.irq_mask = irq_gc_mask_clr_bit;
1238  | 		ct->chip.irq_unmask = irq_gc_mask_set_bit;
1239  | 		ct->regs.ack = IPU_INT_STAT(i / 32);
1240  | 		ct->regs.mask = IPU_INT_CTRL(i / 32);
1241  | 	}
1242  |
1243  | 	irq_set_chained_handler_and_data(ipu->irq_sync, ipu_irq_handler, ipu);
1244  | 	irq_set_chained_handler_and_data(ipu->irq_err, ipu_err_irq_handler,
1245  | 					 ipu);
1246  |
1247  |  return 0;
1248  | }
1249  |
1250  | static void ipu_irq_exit(struct ipu_soc *ipu)
1251  | {
1252  |  int i, irq;
1253  |
1254  | 	irq_set_chained_handler_and_data(ipu->irq_err, NULL, NULL);
1255  | 	irq_set_chained_handler_and_data(ipu->irq_sync, NULL, NULL);
1256  |
1257  |  /* TODO: remove irq_domain_generic_chips */
1258  |
1259  |  for (i = 0; i < IPU_NUM_IRQS; i++) {
1260  | 		irq = irq_linear_revmap(ipu->domain, i);
1261  |  if (irq)
1262  | 			irq_dispose_mapping(irq);
1263  | 	}
1264  |
