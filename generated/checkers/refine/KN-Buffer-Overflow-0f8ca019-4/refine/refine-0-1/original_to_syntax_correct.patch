--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -21,7 +21,7 @@ using namespace ento;
 using namespace taint;

-// No custom program states are necessary for this AST-only checker.
+// This is an AST-only checker.

 namespace {

@@ -31,12 +31,18 @@ static bool indexIsDirectLoopVar(const Expr *Idx, const VarDecl *IVar);
 static bool getArrayConstSizeFromBase(const ASTContext &Ctx, const Expr *Base, uint64_t &CapOut);
 static bool stmtContains(const Stmt *Root, const Stmt *Target);
-static bool parseGuardCondition(const ASTContext &Ctx, const Expr *Cond, const VarDecl *IVar,
-                                uint64_t Cap, bool &IsLTorLE, bool &IsGEorGT);
-static bool isGuardedByEnclosingIfLtCap(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
-                                        const VarDecl *IVar, uint64_t Cap);
-static bool isGuardedByPrevIfGeBreak(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
-                                     const VarDecl *IVar, uint64_t Cap);
+
+// Guard analysis helpers
+static bool extractIVarCmpConst(const ASTContext &Ctx, const Expr *Cond,
+                                const VarDecl *IVar, BinaryOperatorKind &OpOut,
+                                llvm::APSInt &KOut);
+static bool findAnyIVarCmpInBoolExpr(const ASTContext &Ctx, const Expr *Cond,
+                                     const VarDecl *IVar, BinaryOperatorKind &OpOut,
+                                     llvm::APSInt &KOut);
+static bool isGuardedByEnclosingIfLtK(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
+                                      const VarDecl *IVar, uint64_t Cap);
+static bool isGuardedByPrevIfGeKTerminator(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
+                                           const VarDecl *IVar, uint64_t Cap);
 static bool isGuardedBeforeUse(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
                                const VarDecl *IVar, uint64_t Cap);

@@ -104,7 +110,7 @@   if (const auto *DRE = dyn_cast<DeclRefExpr>(E))
     return DRE->getDecl() == IVar;

-  // Allow trivial unary plus on the variable (rare in C, but harmless).
+  // Allow trivial unary plus on the variable.
   if (const auto *UO = dyn_cast<UnaryOperator>(E)) {
     if (UO->getOpcode() == UO_Plus) {
       const Expr *Sub = UO->getSubExpr()->IgnoreParenImpCasts();
@@ -152,62 +158,85 @@   return false;
 }

-static bool parseGuardCondition(const ASTContext &Ctx, const Expr *Cond, const VarDecl *IVar,
-                                uint64_t Cap, bool &IsLTorLE, bool &IsGEorGT) {
-  IsLTorLE = false;
-  IsGEorGT = false;
+// Normalize a comparison so that it is always in the form: (IVar <op> K)
+static bool extractIVarCmpConst(const ASTContext &Ctx, const Expr *Cond,
+                                const VarDecl *IVar, BinaryOperatorKind &OpOut,
+                                llvm::APSInt &KOut) {
   if (!Cond) return false;
   Cond = Cond->IgnoreParenImpCasts();
   const auto *BO = dyn_cast<BinaryOperator>(Cond);
   if (!BO) return false;

+  BinaryOperatorKind Op = BO->getOpcode();
+  // Only consider comparison ops.
+  if (Op != BO_LT && Op != BO_LE && Op != BO_GT && Op != BO_GE &&
+      Op != BO_EQ && Op != BO_NE)
+    return false;
+
   const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();
   const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();

-  const Expr *PtrSide = nullptr;
-  const Expr *ConstSide = nullptr;
-  // We expect the loop variable on one side and a constant on the other.
-  if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS)) {
-    if (DRE->getDecl() == IVar) {
-      PtrSide = LHS;
-      ConstSide = RHS;
-    }
-  } else if (const auto *DRE = dyn_cast<DeclRefExpr>(RHS)) {
-    if (DRE->getDecl() == IVar) {
-      PtrSide = RHS;
-      ConstSide = LHS;
-    }
-  }
-  if (!PtrSide || !ConstSide) return false;
-
-  llvm::APSInt CVal;
-  if (!evalInt(Ctx, ConstSide, CVal)) return false;
-  uint64_t Num = CVal.getLimitedValue();
-
-  // Must match the same Cap
-  if (Num != Cap) return false;
-
-  switch (BO->getOpcode()) {
-  case BO_LT:
-  case BO_LE:
-    IsLTorLE = true;
+  const DeclRefExpr *LHSVar = dyn_cast<DeclRefExpr>(LHS);
+  const DeclRefExpr *RHSVar = dyn_cast<DeclRefExpr>(RHS);
+
+  llvm::APSInt K;
+  // Case: IVar on LHS.
+  if (LHSVar && LHSVar->getDecl() == IVar) {
+    if (!evalInt(Ctx, RHS, K)) return false;
+    OpOut = Op;
+    KOut = K;
     return true;
-  case BO_GE:
-  case BO_GT:
-    IsGEorGT = true;
+  }
+  // Case: IVar on RHS -> normalize by flipping operator.
+  if (RHSVar && RHSVar->getDecl() == IVar) {
+    if (!evalInt(Ctx, LHS, K)) return false;
+
+    // Flip operator: K ? i  -> i ?' K
+    switch (Op) {
+      case BO_LT: OpOut = BO_GT; break; // K < i  -> i > K
+      case BO_LE: OpOut = BO_GE; break; // K <= i -> i >= K
+      case BO_GT: OpOut = BO_LT; break; // K > i  -> i < K
+      case BO_GE: OpOut = BO_LE; break; // K >= i -> i <= K
+      case BO_EQ: OpOut = BO_EQ; break;
+      case BO_NE: OpOut = BO_NE; break;
+      default: return false;
+    }
+    KOut = K;
     return true;
-  default:
-    break;
-  }
-  return false;
-}
-
-static bool isGuardedByEnclosingIfLtCap(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
-                                        const VarDecl *IVar, uint64_t Cap) {
+  }
+
+  return false;
+}
+
+// Search inside a boolean expression tree (handling && and ||) for any comparison
+// involving IVar and an integer constant. Returns the first match found.
+static bool findAnyIVarCmpInBoolExpr(const ASTContext &Ctx, const Expr *Cond,
+                                     const VarDecl *IVar, BinaryOperatorKind &OpOut,
+                                     llvm::APSInt &KOut) {
+  if (!Cond) return false;
+  Cond = Cond->IgnoreParenImpCasts();
+  // Try direct comparison first.
+  if (extractIVarCmpConst(Ctx, Cond, IVar, OpOut, KOut))
+    return true;
+
+  if (const auto *BO = dyn_cast<BinaryOperator>(Cond)) {
+    if (BO->getOpcode() == BO_LAnd || BO->getOpcode() == BO_LOr) {
+      // Search both sides; prefer left-to-right occurrence.
+      if (findAnyIVarCmpInBoolExpr(Ctx, BO->getLHS(), IVar, OpOut, KOut))
+        return true;
+      if (findAnyIVarCmpInBoolExpr(Ctx, BO->getRHS(), IVar, OpOut, KOut))
+        return true;
+    }
+    // We ignore other ops.
+  }
+  return false;
+}
+
+// Enclosing guard: if (i < K) { ... ASE ... } is safe if K <= Cap.
+static bool isGuardedByEnclosingIfLtK(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
+                                      const VarDecl *IVar, uint64_t Cap) {
   if (!ASE) return false;

-  // Walk up the parents and look for an IfStmt where ASE is located within the 'then' branch
-  // and the condition is i < Cap (or i <= Cap).
   const Stmt *Curr = ASE;
   while (true) {
     const Stmt *ParentS = nullptr;
@@ -217,11 +246,15 @@     if (!ParentS) break;

     if (const auto *IS = dyn_cast<IfStmt>(ParentS)) {
-      bool IsLTorLE = false, IsGEorGT = false;
-      if (parseGuardCondition(Ctx, IS->getCond(), IVar, Cap, IsLTorLE, IsGEorGT)) {
-        if (IsLTorLE) {
+      BinaryOperatorKind Op;
+      llvm::APSInt K;
+      if (findAnyIVarCmpInBoolExpr(Ctx, IS->getCond(), IVar, Op, K)) {
+        // Normalize safety condition for '<' and '<='
+        if ((Op == BO_LT || Op == BO_LE)) {
+          uint64_t KVal = K.getLimitedValue();
+          // If the if-then branch (where ASE resides) enforces i < K and K <= Cap, it's safe.
           const Stmt *Then = IS->getThen();
-          if (Then && stmtContains(Then, ASE))
+          if (Then && stmtContains(Then, ASE) && KVal <= Cap)
             return true;
         }
       }
@@ -232,14 +265,15 @@   return false;
 }

-static bool isGuardedByPrevIfGeBreak(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
-                                     const VarDecl *IVar, uint64_t Cap) {
+// Previous sibling guard: if (i >= K) { break/continue/return; } before ASE is safe if K >= Cap.
+// Also accept 'i > K' as equivalent to 'i >= K+1'.
+static bool isGuardedByPrevIfGeKTerminator(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
+                                           const VarDecl *IVar, uint64_t Cap) {
   if (!ASE) return false;

   // Find the nearest enclosing CompoundStmt and check previous siblings.
-  const Stmt *Containing = ASE;
   const CompoundStmt *CS = nullptr;
-  const Stmt *Tmp = Containing;
+  const Stmt *Tmp = ASE;
   while (true) {
     auto Parents = const_cast<ASTContext &>(Ctx).getParentMapContext().getParents(*Tmp);
     if (Parents.empty()) break;
@@ -251,7 +285,7 @@   }
   if (!CS) return false;

-  // Find which immediate child statement of CS contains ASE.
+  // Find the immediate child statement of CS that contains ASE.
   const Stmt *ContainerChild = nullptr;
   unsigned Index = 0, FoundIndex = 0;
   for (const Stmt *Child : CS->body()) {
@@ -264,7 +298,7 @@   }
   if (!ContainerChild) return false;

-  // Scan previous statements for if (i >= Cap) { break; } or return; or continue;
+  // Scan previous statements for if (i >= K) { break/continue/return; }
   Index = 0;
   for (const Stmt *Child : CS->body()) {
     if (Index >= FoundIndex) break;
@@ -273,17 +307,28 @@     const auto *IS = dyn_cast<IfStmt>(Child);
     if (!IS) continue;

-    bool IsLTorLE = false, IsGEorGT = false;
-    if (!parseGuardCondition(Ctx, IS->getCond(), IVar, Cap, IsLTorLE, IsGEorGT))
+    BinaryOperatorKind Op;
+    llvm::APSInt K;
+    if (!findAnyIVarCmpInBoolExpr(Ctx, IS->getCond(), IVar, Op, K))
       continue;

-    if (!IsGEorGT)
+    uint64_t Threshold = 0;
+    bool IsGeKind = false;
+    if (Op == BO_GE) {
+      Threshold = K.getLimitedValue();
+      IsGeKind = true;
+    } else if (Op == BO_GT) {
+      // i > K  -> effectively i >= K+1 for termination
+      Threshold = (K + 1).getLimitedValue();
+      IsGeKind = true;
+    } else {
+      // Only >= or > form are used for this guard
       continue;
+    }

     const Stmt *Then = IS->getThen();
     if (!Then) continue;

-    // Look for a BreakStmt, ContinueStmt or ReturnStmt inside the then-branch.
     struct FindTerminator : public RecursiveASTVisitor<FindTerminator> {
       bool Found = false;
       bool VisitBreakStmt(BreakStmt *) { Found = true; return false; }
@@ -292,7 +337,11 @@     } Finder;
     Finder.TraverseStmt(const_cast<Stmt*>(Then));

-    if (Finder.Found)
+    if (!Finder.Found)
+      continue;
+
+    // Guard is sufficient iff Threshold >= Cap
+    if (IsGeKind && Threshold >= Cap)
       return true;
   }

@@ -301,13 +350,16 @@
 static bool isGuardedBeforeUse(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
                                const VarDecl *IVar, uint64_t Cap) {
-  // Two heuristics:
-  // 1) ASE is inside an enclosing if (i < Cap) { ... ASE ... }
-  if (isGuardedByEnclosingIfLtCap(Ctx, ASE, IVar, Cap))
+  // Heuristic 1:
+  // ASE is inside an enclosing if (i < K) { ... ASE ... } with K <= Cap.
+  if (isGuardedByEnclosingIfLtK(Ctx, ASE, IVar, Cap))
     return true;

-  // 2) Just before ASE in the same block, there is if (i >= Cap) { break; } or return; or continue;
-  if (isGuardedByPrevIfGeBreak(Ctx, ASE, IVar, Cap))
+  // Heuristic 2:
+  // Just before ASE in the same block, there is:
+  //   if (i >= K [or i > K]) { break; / continue; / return; }
+  // with K (or K+1 for >) >= Cap.
+  if (isGuardedByPrevIfGeKTerminator(Ctx, ASE, IVar, Cap))
     return true;

   return false;
