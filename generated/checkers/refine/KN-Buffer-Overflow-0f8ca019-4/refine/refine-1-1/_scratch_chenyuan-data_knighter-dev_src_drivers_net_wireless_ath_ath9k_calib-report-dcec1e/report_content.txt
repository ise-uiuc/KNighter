### Report Summary

File:| drivers/net/wireless/ath/ath9k/calib.c
---|---
Warning:| line 274, column 47
Loop bound exceeds array capacity: index 'i' goes up to 5 but array size is 3

### Annotated Source Code


224   |
225   |  return false;
226   | }
227   | EXPORT_SYMBOL(ath9k_hw_reset_calvalid);
228   |
229   | void ath9k_hw_start_nfcal(struct ath_hw *ah, bool update)
230   | {
231   |  if (ah->caldata)
232   | 		set_bit(NFCAL_PENDING, &ah->caldata->cal_flags);
233   |
234   |  REG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah),
235   |  AR_PHY_AGC_CONTROL_ENABLE_NF);
236   |
237   |  if (update)
238   |  REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah),
239   |  AR_PHY_AGC_CONTROL_NO_UPDATE_NF);
240   |  else
241   |  REG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah),
242   |  AR_PHY_AGC_CONTROL_NO_UPDATE_NF);
243   |
244   |  REG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah), AR_PHY_AGC_CONTROL_NF);
245   | }
246   |
247   | int ath9k_hw_loadnf(struct ath_hw *ah, struct ath9k_channel *chan)
248   | {
249   |  struct ath9k_nfcal_hist *h = NULL;
250   |  unsigned i, j;
251   | 	u8 chainmask = (ah->rxchainmask << 3) | ah->rxchainmask;
252   |  struct ath_common *common = ath9k_hw_common(ah);
253   | 	s16 default_nf = ath9k_hw_get_nf_limits(ah, chan)->nominal;
254   | 	u32 bb_agc_ctl = REG_READ(ah, AR_PHY_AGC_CONTROL(ah));
255   |
256   |  if (ah->caldata)
257   | 		h = ah->caldata->nfCalHist;
258   |
259   |  ENABLE_REG_RMW_BUFFER(ah);
260   |  for (i = 0; i < NUM_NF_READINGS; i++) {
261   |  if (chainmask & (1 << i)) {
262   | 			s16 nfval;
263   |
264   |  if ((i >= AR5416_MAX_CHAINS) && !IS_CHAN_HT40(chan))
265   |  continue;
266   |
267   |  if (ah->nf_override)
268   | 				nfval = ah->nf_override;
269   |  else if (h)
270   | 				nfval = h[i].privNF;
271   |  else {
272   |  /* Try to get calibrated noise floor value */
273   | 				nfval =
274   |  ath9k_hw_get_nf_limits(ah, chan)->cal[i];
    Loop bound exceeds array capacity: index 'i' goes up to 5 but array size is 3
275   |  if (nfval > -60 || nfval < -127)
276   | 					nfval = default_nf;
277   | 			}
278   |
279   |  REG_RMW(ah, ah->nf_regs[i],
280   |  (((u32) nfval << 1) & 0x1ff), 0x1ff);
281   | 		}
282   | 	}
283   |
284   |  /*
285   |  * stop NF cal if ongoing to ensure NF load completes immediately
286   |  * (or after end rx/tx frame if ongoing)
287   |  */
288   |  if (bb_agc_ctl & AR_PHY_AGC_CONTROL_NF) {
289   |  REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah), AR_PHY_AGC_CONTROL_NF);
290   |  REG_RMW_BUFFER_FLUSH(ah);
291   |  ENABLE_REG_RMW_BUFFER(ah);
292   | 	}
293   |
294   |  /*
295   |  * Load software filtered NF value into baseband internal minCCApwr
296   |  * variable.
297   |  */
298   |  REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah),
299   |  AR_PHY_AGC_CONTROL_ENABLE_NF);
300   |  REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah),
301   |  AR_PHY_AGC_CONTROL_NO_UPDATE_NF);
302   |  REG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah), AR_PHY_AGC_CONTROL_NF);
303   |  REG_RMW_BUFFER_FLUSH(ah);
304   |
