--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -52,7 +52,7 @@   return isFromMacro(E->getSourceRange()) || E->getExprLoc().isMacroID();
 }

-// A single place to decide whether this ASE is a known false positive.
+// A single place to decide whether this ASE is a known false positive by syntax alone.
 static bool isFalsePositive(const ArraySubscriptExpr *ASE) {
   if (!ASE) return false;
   // If either the subscript expression itself, its base, or its index come from
@@ -359,7 +359,8 @@                                     llvm::APSInt &RHSValueOut);

   // Process a single ForStmt: find array subscripts using IVar and check against Cap.
-  void processForStmt(const ForStmt *FS, const ASTContext &Ctx, BugReporter &BR) const;
+  void processForStmt(const ForStmt *FS, const ASTContext &Ctx, BugReporter &BR,
+                      const Decl *CurD) const;

   // Emit a report for a problematic array access.
   void reportIssue(const ArraySubscriptExpr *ASE, const VarDecl *IVar,
@@ -373,6 +374,31 @@       return false;
     QualType T = IVar->getType();
     return T->isEnumeralType();
+  }
+
+  // Helper: detect LKDTM self-test harness (intentional fault injection)
+  static bool isIntentionalKernelTest(const Decl *D, const ASTContext &Ctx) {
+    if (!D) return false;
+
+    // Try to detect by function name.
+    if (const auto *FD = dyn_cast<FunctionDecl>(D)) {
+      if (FD->getIdentifier()) {
+        StringRef Name = FD->getName();
+        if (Name.startswith("lkdtm_"))
+          return true;
+      }
+    }
+
+    // Additionally detect by source file path containing "lkdtm".
+    SourceLocation Loc = D->getBeginLoc();
+    if (Loc.isValid()) {
+      const SourceManager &SM = Ctx.getSourceManager();
+      StringRef Path = SM.getFilename(Loc);
+      if (!Path.empty() && Path.contains("lkdtm"))
+        return true;
+    }
+
+    return false;
   }
 };

@@ -698,7 +724,12 @@   BR.emitReport(std::move(R));
 }

-void SAGenTestChecker::processForStmt(const ForStmt *FS, const ASTContext &Ctx, BugReporter &BR) const {
+void SAGenTestChecker::processForStmt(const ForStmt *FS, const ASTContext &Ctx, BugReporter &BR,
+                                      const Decl *CurD) const {
+  // Suppress intentional kernel test harness code (e.g., LKDTM's lkdtm_* tests).
+  if (isIntentionalKernelTest(CurD, Ctx))
+    return;
+
   const VarDecl *IVar = nullptr;
   llvm::APSInt LB, UBEx, RHSVal;
   BinaryOperator::Opcode CondOp;
@@ -787,17 +818,18 @@     const ASTContext &Ctx;
     BugReporter &BR;
     const SAGenTestChecker *Checker;
-
-    ForVisitor(const ASTContext &C, BugReporter &B, const SAGenTestChecker *Ch)
-      : Ctx(C), BR(B), Checker(Ch) {}
+    const Decl *CurD;
+
+    ForVisitor(const ASTContext &C, BugReporter &B, const SAGenTestChecker *Ch, const Decl *D)
+      : Ctx(C), BR(B), Checker(Ch), CurD(D) {}

     bool VisitForStmt(ForStmt *FS) {
-      Checker->processForStmt(FS, Ctx, BR);
+      Checker->processForStmt(FS, Ctx, BR, CurD);
       return true;
     }
   };

-  ForVisitor V(Ctx, BR, this);
+  ForVisitor V(Ctx, BR, this, D);
   V.TraverseStmt(const_cast<Stmt*>(Body));
 }
