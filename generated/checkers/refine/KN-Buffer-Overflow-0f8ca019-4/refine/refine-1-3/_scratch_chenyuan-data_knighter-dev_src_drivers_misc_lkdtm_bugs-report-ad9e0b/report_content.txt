### Report Summary

File:| drivers/misc/lkdtm/bugs.c
---|---
Warning:| line 377, column 17
Loop bound exceeds array capacity: index 'i' goes up to 8 but array size is 8

### Annotated Source Code


327   |  pr_info("Normal unsigned addition ...\n");
328   | 	value += 1;
329   | 	ignored = value;
330   |
331   |  pr_info("Overflowing unsigned addition ...\n");
332   | 	value += 4;
333   | 	ignored = value;
334   | }
335   |
336   | /* Intentionally using unannotated flex array definition. */
337   | struct array_bounds_flex_array {
338   |  int one;
339   |  int two;
340   |  char data[];
341   | };
342   |
343   | struct array_bounds {
344   |  int one;
345   |  int two;
346   |  char data[8];
347   |  int three;
348   | };
349   |
350   | static void lkdtm_ARRAY_BOUNDS(void)
351   | {
352   |  struct array_bounds_flex_array *not_checked;
353   |  struct array_bounds *checked;
354   |  volatile int i;
355   |
356   | 	not_checked = kmalloc(sizeof(*not_checked) * 2, GFP_KERNEL);
357   | 	checked = kmalloc(sizeof(*checked) * 2, GFP_KERNEL);
358   |  if (!not_checked || !checked) {
359   | 		kfree(not_checked);
360   | 		kfree(checked);
361   |  return;
362   | 	}
363   |
364   |  pr_info("Array access within bounds ...\n");
365   |  /* For both, touch all bytes in the actual member size. */
366   |  for (i = 0; i < sizeof(checked->data); i++)
367   | 		checked->data[i] = 'A';
368   |  /*
369   |  * For the uninstrumented flex array member, also touch 1 byte
370   |  * beyond to verify it is correctly uninstrumented.
371   |  */
372   |  for (i = 0; i < 2; i++)
373   | 		not_checked->data[i] = 'A';
374   |
375   |  pr_info("Array access beyond bounds ...\n");
376   |  for (i = 0; i < sizeof(checked->data) + 1; i++)
377   |  checked->data[i] = 'B';
    Loop bound exceeds array capacity: index 'i' goes up to 8 but array size is 8
378   |
379   | 	kfree(not_checked);
380   | 	kfree(checked);
381   |  pr_err("FAIL: survived array bounds overflow!\n");
382   |  if (IS_ENABLED(CONFIG_UBSAN_BOUNDS))
383   |  pr_expected_config(CONFIG_UBSAN_TRAP);
384   |  else
385   |  pr_expected_config(CONFIG_UBSAN_BOUNDS);
386   | }
387   |
388   | struct lkdtm_annotated {
389   |  unsigned long flags;
390   |  int count;
391   |  int array[] __counted_by(count);
392   | };
393   |
394   | static volatile int fam_count = 4;
395   |
396   | static void lkdtm_FAM_BOUNDS(void)
397   | {
398   |  struct lkdtm_annotated *inst;
399   |
400   | 	inst = kzalloc(struct_size(inst, array, fam_count + 1), GFP_KERNEL);
401   |  if (!inst) {
402   |  pr_err("FAIL: could not allocate test struct!\n");
403   |  return;
404   | 	}
405   |
406   | 	inst->count = fam_count;
407   |  pr_info("Array access within bounds ...\n");
