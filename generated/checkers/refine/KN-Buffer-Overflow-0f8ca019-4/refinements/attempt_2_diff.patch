--- attempt_2_original.cpp+++ attempt_2.cpp@@ -36,7 +36,7 @@ static bool isGuardedByPrevIfGeBreak(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
                                      const VarDecl *IVar, uint64_t Cap);
 static bool isGuardedBeforeUse(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
-                               const VarDecl *IVar, uint64_t Cap);
+                               const VarDecl *IVar, uint64_t Cap, uint64_t UBExclusive);

 // New helpers to eliminate macro-originated false positives
 static bool isFromMacro(const SourceRange &SR) {
@@ -52,7 +52,7 @@   return isFromMacro(E->getSourceRange()) || E->getExprLoc().isMacroID();
 }

-// A single place to decide whether this ASE is a known false positive.
+// A single place to decide whether this ASE is a known false positive by syntax alone.
 static bool isFalsePositive(const ArraySubscriptExpr *ASE) {
   if (!ASE) return false;
   // If either the subscript expression itself, its base, or its index come from
@@ -179,6 +179,179 @@   return (A + B - 1) / B;
 }

+// Parse a comparator "IVar <op> Const" or "Const <op> IVar".
+// Returns true and fills ConstVal (unsigned) and OpOut if matches; otherwise false.
+static bool parseIVarVsConst(const ASTContext &Ctx, const Expr *Cond, const VarDecl *IVar,
+                             uint64_t &ConstVal, BinaryOperator::Opcode &OpOut) {
+  if (!Cond) return false;
+  Cond = Cond->IgnoreParenImpCasts();
+
+  // Recurse into logical-and to find the comparator among conjuncts.
+  if (const auto *BO0 = dyn_cast<BinaryOperator>(Cond)) {
+    if (BO0->getOpcode() == BO_LAnd) {
+      if (parseIVarVsConst(Ctx, BO0->getLHS(), IVar, ConstVal, OpOut))
+        return true;
+      if (parseIVarVsConst(Ctx, BO0->getRHS(), IVar, ConstVal, OpOut))
+        return true;
+      return false;
+    }
+  }
+
+  const auto *BO = dyn_cast<BinaryOperator>(Cond);
+  if (!BO) return false;
+
+  BinaryOperator::Opcode Op = BO->getOpcode();
+  switch (Op) {
+  case BO_LT: case BO_LE:
+  case BO_GT: case BO_GE:
+  case BO_EQ: case BO_NE:
+    break;
+  default:
+    return false;
+  }
+
+  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();
+  const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();
+
+  // IVar on LHS, constant on RHS
+  if (const auto *DL = dyn_cast<DeclRefExpr>(LHS)) {
+    if (DL->getDecl() == IVar) {
+      llvm::APSInt Val;
+      if (!evalInt(Ctx, RHS, Val)) return false;
+      ConstVal = Val.getLimitedValue();
+      OpOut = Op;
+      return true;
+    }
+  }
+
+  // IVar on RHS, constant on LHS: reverse comparison
+  if (const auto *DR = dyn_cast<DeclRefExpr>(RHS)) {
+    if (DR->getDecl() == IVar) {
+      llvm::APSInt Val;
+      if (!evalInt(Ctx, LHS, Val)) return false;
+      ConstVal = Val.getLimitedValue();
+
+      // Reverse the operator
+      switch (Op) {
+      case BO_LT: OpOut = BO_GT; break;
+      case BO_LE: OpOut = BO_GE; break;
+      case BO_GT: OpOut = BO_LT; break;
+      case BO_GE: OpOut = BO_LE; break;
+      case BO_EQ: OpOut = BO_EQ; break;
+      case BO_NE: OpOut = BO_NE; break;
+      default: return false;
+      }
+      return true;
+    }
+  }
+
+  return false;
+}
+
+// Determine if ASE is guarded by an enclosing IfStmt using a comparator between IVar and Cap.
+// Additionally considers '==' and '!=' cases. For '!=' we require UBExclusive <= Cap + 1.
+static bool isGuardedByEnclosingIfComparator(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
+                                             const VarDecl *IVar, uint64_t Cap, uint64_t UBExclusive) {
+  if (!ASE) return false;
+
+  const Stmt *Curr = ASE;
+  while (true) {
+    const Stmt *ParentS = nullptr;
+    auto Parents = const_cast<ASTContext &>(Ctx).getParentMapContext().getParents(*Curr);
+    if (Parents.empty()) break;
+    ParentS = Parents[0].get<Stmt>();
+    if (!ParentS) break;
+
+    if (const auto *IS = dyn_cast<IfStmt>(ParentS)) {
+      uint64_t CVal = 0;
+      BinaryOperator::Opcode Op;
+      if (parseIVarVsConst(Ctx, IS->getCond(), IVar, CVal, Op)) {
+        if (CVal == Cap) {
+          const Stmt *Then = IS->getThen();
+          const Stmt *Else = IS->getElse();
+
+          auto InThen = Then && stmtContains(Then, ASE);
+          auto InElse = Else && stmtContains(Else, ASE);
+
+          switch (Op) {
+          case BO_LT:
+          case BO_LE:
+            if (InThen) return true;
+            break;
+          case BO_GT:
+          case BO_GE:
+            if (InElse) return true;
+            break;
+          case BO_EQ:
+            if (InElse) return true;
+            break;
+          case BO_NE:
+            if (InThen && UBExclusive <= Cap + 1) return true;
+            break;
+          default:
+            break;
+          }
+        }
+      }
+    }
+    Curr = ParentS;
+  }
+
+  return false;
+}
+
+// Determine if ASE is guarded by a ConditionalOperator (?:) that compares IVar against Cap,
+// and the branch containing ASE is safe. For '!=' we require UBExclusive <= Cap + 1.
+static bool isGuardedByConditionalOperator(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
+                                           const VarDecl *IVar, uint64_t Cap, uint64_t UBExclusive) {
+  if (!ASE) return false;
+
+  const Stmt *Curr = ASE;
+  while (true) {
+    const Stmt *ParentS = nullptr;
+    auto Parents = const_cast<ASTContext &>(Ctx).getParentMapContext().getParents(*Curr);
+    if (Parents.empty()) break;
+    ParentS = Parents[0].get<Stmt>();
+    if (!ParentS) break;
+
+    if (const auto *CO = dyn_cast<ConditionalOperator>(ParentS)) {
+      uint64_t CVal = 0;
+      BinaryOperator::Opcode Op;
+      if (parseIVarVsConst(Ctx, CO->getCond(), IVar, CVal, Op)) {
+        if (CVal == Cap) {
+          const Expr *TrueE = CO->getTrueExpr();
+          const Expr *FalseE = CO->getFalseExpr();
+          bool InTrue = TrueE && stmtContains(TrueE, ASE);
+          bool InFalse = FalseE && stmtContains(FalseE, ASE);
+
+          switch (Op) {
+          case BO_LT:
+          case BO_LE:
+            if (InTrue) return true;
+            break;
+          case BO_GT:
+          case BO_GE:
+            if (InFalse) return true;
+            break;
+          case BO_EQ:
+            if (InFalse) return true;
+            break;
+          case BO_NE:
+            if (InTrue && UBExclusive <= Cap + 1) return true;
+            break;
+          default:
+            break;
+          }
+        }
+      }
+    }
+
+    Curr = ParentS;
+  }
+
+  return false;
+}
+
 class SAGenTestChecker : public Checker<check::ASTCodeBody> {
    mutable std::unique_ptr<BugType> BT;

@@ -198,12 +371,47 @@                                     llvm::APSInt &RHSValueOut);

   // Process a single ForStmt: find array subscripts using IVar and check against Cap.
-  void processForStmt(const ForStmt *FS, const ASTContext &Ctx, BugReporter &BR) const;
+  void processForStmt(const ForStmt *FS, const ASTContext &Ctx, BugReporter &BR,
+                      const Decl *CurD) const;

   // Emit a report for a problematic array access.
   void reportIssue(const ArraySubscriptExpr *ASE, const VarDecl *IVar,
                    uint64_t UBExclusive, uint64_t Cap,
                    BugReporter &BR, const ASTContext &Ctx) const;
+
+  // Helper: detect kernel-style for_each_* macro loops with enum induction variables.
+  static bool isEnumMacroLoop(const ForStmt *FS, const VarDecl *IVar) {
+    if (!FS || !IVar) return false;
+    if (!FS->getForLoc().isMacroID())
+      return false;
+    QualType T = IVar->getType();
+    return T->isEnumeralType();
+  }
+
+  // Helper: detect LKDTM self-test harness (intentional fault injection)
+  static bool isIntentionalKernelTest(const Decl *D, const ASTContext &Ctx) {
+    if (!D) return false;
+
+    // Try to detect by function name.
+    if (const auto *FD = dyn_cast<FunctionDecl>(D)) {
+      if (FD->getIdentifier()) {
+        StringRef Name = FD->getName();
+        if (Name.startswith("lkdtm_"))
+          return true;
+      }
+    }
+
+    // Additionally detect by source file path containing "lkdtm".
+    SourceLocation Loc = D->getBeginLoc();
+    if (Loc.isValid()) {
+      const SourceManager &SM = Ctx.getSourceManager();
+      StringRef Path = SM.getFilename(Loc);
+      if (!Path.empty() && Path.contains("lkdtm"))
+        return true;
+    }
+
+    return false;
+  }
 };

 //====================== Helper implementations ======================
@@ -278,6 +486,23 @@   IsGEorGT = false;
   if (!Cond) return false;
   Cond = Cond->IgnoreParenImpCasts();
+
+  // Recurse into logical-and to find relevant comparator subexpressions.
+  if (const auto *B = dyn_cast<BinaryOperator>(Cond)) {
+    if (B->getOpcode() == BO_LAnd) {
+      bool L_LT = false, L_GE = false, R_LT = false, R_GE = false;
+      bool LFound = parseGuardCondition(Ctx, B->getLHS(), IVar, Cap, L_LT, L_GE);
+      bool RFound = parseGuardCondition(Ctx, B->getRHS(), IVar, Cap, R_LT, R_GE);
+      if (LFound || RFound) {
+        IsLTorLE = L_LT || R_LT;
+        IsGEorGT = L_GE || R_GE;
+        return true;
+      }
+      // Not found in either conjunct.
+      return false;
+    }
+  }
+
   const auto *BO = dyn_cast<BinaryOperator>(Cond);
   if (!BO) return false;

@@ -327,7 +552,7 @@   if (!ASE) return false;

   // Walk up the parents and look for an IfStmt where ASE is located within the 'then' branch
-  // and the condition is i < Cap (or i <= Cap).
+  // and the condition is i < Cap (or i <= Cap), possibly as part of a logical-and.
   const Stmt *Curr = ASE;
   while (true) {
     const Stmt *ParentS = nullptr;
@@ -420,18 +645,27 @@ }

 static bool isGuardedBeforeUse(const ASTContext &Ctx, const ArraySubscriptExpr *ASE,
-                               const VarDecl *IVar, uint64_t Cap) {
-  // Two heuristics:
-  // 1) ASE is inside an enclosing if (i < Cap) { ... ASE ... }
+                               const VarDecl *IVar, uint64_t Cap, uint64_t UBExclusive) {
+  // Heuristic A: ASE is inside an enclosing if (i < Cap) { ... ASE ... }
   if (isGuardedByEnclosingIfLtCap(Ctx, ASE, IVar, Cap))
     return true;

-  // 2) Just before ASE in the same block, there is if (i >= Cap) { break; } or return; or continue;
+  // Heuristic B: Just before ASE in the same block, there is if (i >= Cap) { break; } or return; or continue;
   if (isGuardedByPrevIfGeBreak(Ctx, ASE, IVar, Cap))
     return true;

-  return false;
-}
+  // Heuristic C: ASE is in a safe branch of a ConditionalOperator (?:) comparing i with Cap.
+  if (isGuardedByConditionalOperator(Ctx, ASE, IVar, Cap, UBExclusive))
+    return true;
+
+  // Heuristic D: ASE is in a safe branch of an enclosing IfStmt using a comparator (==, !=, <, <=, >, >=) with Cap.
+  if (isGuardedByEnclosingIfComparator(Ctx, ASE, IVar, Cap, UBExclusive))
+    return true;
+
+  return false;
+}
+
+//====================== Checker implementations ======================

 bool SAGenTestChecker::getLoopIndexAndBounds(const ForStmt *FS, const ASTContext &Ctx,
                                              const VarDecl *&IVar, llvm::APSInt &LB,
@@ -468,7 +702,7 @@   }

   // We only handle LB == 0
-  if (InitVal != 0) return false;
+  if (InitVal.getLimitedValue() != 0) return false;

   // Parse condition: i < N or i <= N
   const Expr *Cond = FS->getCond();
@@ -491,7 +725,8 @@     UBExclusive = RHSVal;
   } else {
     // i <= N  => UBExclusive = N + 1
-    UBExclusive = RHSVal + 1;
+    UBExclusive = RHSVal;
+    ++UBExclusive;
   }

   LB = InitVal;
@@ -518,11 +753,21 @@   BR.emitReport(std::move(R));
 }

-void SAGenTestChecker::processForStmt(const ForStmt *FS, const ASTContext &Ctx, BugReporter &BR) const {
+void SAGenTestChecker::processForStmt(const ForStmt *FS, const ASTContext &Ctx, BugReporter &BR,
+                                      const Decl *CurD) const {
+  // Suppress intentional kernel test harness code (e.g., LKDTM's lkdtm_* tests).
+  if (isIntentionalKernelTest(CurD, Ctx))
+    return;
+
   const VarDecl *IVar = nullptr;
   llvm::APSInt LB, UBEx, RHSVal;
   BinaryOperator::Opcode CondOp;
   if (!getLoopIndexAndBounds(FS, Ctx, IVar, LB, UBEx, CondOp, RHSVal))
+    return;
+
+  // Suppress enumeration-style, macro-expanded loop patterns (e.g., for_each_pipe),
+  // which are known to be safe and otherwise produce false positives.
+  if (isEnumMacroLoop(FS, IVar))
     return;

   // Only consider LB == 0 (already filtered)
@@ -562,8 +807,8 @@       if (!extractIndexDivAndOffset(Ctx, Idx, IVar, Div, Offset))
         return true;

-      // If guarded appropriately, skip.
-      if (isGuardedBeforeUse(Ctx, ASE, IVar, Cap))
+      // If guarded appropriately (via if/?:), skip.
+      if (isGuardedBeforeUse(Ctx, ASE, IVar, Cap, UBExclusive))
         return true;

       // Preserve the existing conservative suppression for "<=" when RHS equals the capacity
@@ -602,17 +847,18 @@     const ASTContext &Ctx;
     BugReporter &BR;
     const SAGenTestChecker *Checker;
-
-    ForVisitor(const ASTContext &C, BugReporter &B, const SAGenTestChecker *Ch)
-      : Ctx(C), BR(B), Checker(Ch) {}
+    const Decl *CurD;
+
+    ForVisitor(const ASTContext &C, BugReporter &B, const SAGenTestChecker *Ch, const Decl *D)
+      : Ctx(C), BR(B), Checker(Ch), CurD(D) {}

     bool VisitForStmt(ForStmt *FS) {
-      Checker->processForStmt(FS, Ctx, BR);
+      Checker->processForStmt(FS, Ctx, BR, CurD);
       return true;
     }
   };

-  ForVisitor V(Ctx, BR, this);
+  ForVisitor V(Ctx, BR, this, D);
   V.TraverseStmt(const_cast<Stmt*>(Body));
 }
