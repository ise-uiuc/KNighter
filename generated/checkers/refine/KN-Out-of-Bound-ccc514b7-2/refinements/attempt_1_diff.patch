--- attempt_1_original.cpp+++ attempt_1.cpp@@ -21,14 +21,18 @@ #include "clang/Lex/Lexer.h"
 #include "llvm/ADT/DenseMap.h"
 #include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/SmallPtrSet.h"
+#include "llvm/ADT/SmallString.h"
 #include <optional>
+
+// Added for parent queries and dyn typed nodes
+#include "clang/AST/ASTTypeTraits.h"
+#include "clang/AST/ParentMapContext.h"

 using namespace clang;
 using namespace ento;
 using namespace taint;

-// No custom program state is needed.
-
 namespace {

 class SAGenTestChecker : public Checker< check::ASTCodeBody > {
@@ -41,22 +45,60 @@
    private:
       struct ArrayUseInfo {
-        const ValueDecl *VD = nullptr;               // VarDecl or FieldDecl
-        uint64_t Size = 0;                           // Constant array size
-        const ArraySubscriptExpr *ExampleUse = nullptr; // Example use site for diagnostics
+        const ValueDecl *VD = nullptr;                  // VarDecl or FieldDecl
+        uint64_t Size = 0;                              // Constant array size
+        const ArraySubscriptExpr *ExampleUse = nullptr; // Earliest example use site for diagnostics
       };

+      enum class GuardKind { None, Lt, Le, Gt, Ge, Eq, Ne };
+      enum class ExitKind { None, Continue, Break, Return };
+
       static bool evalToUInt64(const Expr *E, ASTContext &ACtx, uint64_t &Out);
+      static bool evalToInt64(const Expr *E, ASTContext &ACtx, int64_t &Out);
       static bool isSimpleIncreasingIncrement(const Stmt *Inc, const VarDecl *IVar, ASTContext &ACtx);
       static bool isZeroInitOfVar(const Stmt *InitS, const VarDecl *IVar, ASTContext &ACtx);
       static bool isVarRefTo(const Expr *E, const VarDecl *VD);
+      static bool exprContainsVarRef(const Expr *E, const VarDecl *VD);
       static bool getArrayDeclAndSizeFromBase(const Expr *Base, uint64_t &Size, const ValueDecl *&OutDecl);

       void processForStmt(const ForStmt *FS, ASTContext &ACtx, BugReporter &BR) const;
       void collectArrayUsesIndexedBy(const Stmt *Body, const VarDecl *IVar, ASTContext &ACtx,
                                      llvm::DenseMap<const ValueDecl*, ArrayUseInfo> &Out) const;
+
+      // Existing simple loop-level guard heuristic (kept for compatibility).
       bool hasGuardForBound(const Stmt *Body, const VarDecl *IVar, uint64_t SmallSize, ASTContext &ACtx) const;
+
+      // General helpers
+      static bool containsStmt(const Stmt *Parent, const Stmt *Target);
+
+      // Robust condition parsing: find relational on IVar anywhere in the condition subtree (handles StmtExpr, wrappers).
+      static bool matchRelationalOnIVar(const BinaryOperator *BO, const VarDecl *IVar,
+                                        uint64_t &Const, GuardKind &Kind, ASTContext &ACtx);
+      static bool findRelationalOnIVarInStmt(const Stmt *S, const VarDecl *IVar,
+                                             uint64_t &Const, GuardKind &Kind, ASTContext &ACtx);
+      static bool parseCondOnIVar(const Expr *Cond, const VarDecl *IVar, uint64_t &Const, GuardKind &Kind, ASTContext &ACtx);
       static bool condHasIVarAgainstConst(const Expr *CondE, const VarDecl *IVar, uint64_t ConstVal, ASTContext &ACtx);
+
+      // Parent-branch guard heuristic: if use is in a branch that ensures i < SmallSize
+      static bool branchImpliesIndexInRange(GuardKind Kind, uint64_t Const, bool BranchWhenCondTrue,
+                                            uint64_t SmallSize, uint64_t UB);
+      static bool isIndexUseGuardedByBranch(const ArraySubscriptExpr *ASE, const VarDecl *IVar,
+                                            uint64_t SmallSize, uint64_t UB, ASTContext &ACtx);
+
+      // Mapping-guard suppression heuristic
+      static const IfStmt *findEnclosingIfWithBranch(const Stmt *S, const Stmt *&OutBranch, ASTContext &ACtx);
+      static bool parseMappingGuard(const Expr *Cond, const VarDecl *&InstVar, bool &ValidWhenTrue, ASTContext &ACtx);
+      static const CompoundStmt *findDirectCompoundParent(const Stmt *S, ASTContext &ACtx);
+      static bool hasPriorAssignFromIVar(const CompoundStmt *CS, const IfStmt *IS, const VarDecl *InstVar, const VarDecl *IVar);
+      static bool branchContainsArrayIndexWithVar(const Stmt *Branch, const VarDecl *IdxVar);
+      static bool isGuardedByIndexMapping(const ArraySubscriptExpr *ASE, const VarDecl *IVar, ASTContext &ACtx);
+
+      // New: Early-exit-before-use guard heuristic to handle "if (i > S-1) continue;" style guards
+      static ExitKind getSimpleEarlyExit(const Stmt *S);
+      static bool branchImpliesIndexOutOfRange(GuardKind Kind, uint64_t Const, bool BranchWhenCondTrue,
+                                               uint64_t SmallSize, ExitKind EK);
+      static bool hasEarlyExitGuardBeforeUse(const ArraySubscriptExpr *Use, const VarDecl *IVar,
+                                             uint64_t SmallSize, ASTContext &ACtx);
 };

 bool SAGenTestChecker::evalToUInt64(const Expr *E, ASTContext &ACtx, uint64_t &Out) {
@@ -70,11 +112,37 @@   return false;
 }

+bool SAGenTestChecker::evalToInt64(const Expr *E, ASTContext &ACtx, int64_t &Out) {
+  if (!E) return false;
+  Expr::EvalResult R;
+  if (E->EvaluateAsInt(R, ACtx)) {
+    const llvm::APSInt &V = R.Val.getInt();
+    Out = V.getSExtValue();
+    return true;
+  }
+  return false;
+}
+
 bool SAGenTestChecker::isVarRefTo(const Expr *E, const VarDecl *VD) {
   if (!E || !VD) return false;
   E = E->IgnoreParenImpCasts();
   if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {
     return DRE->getDecl() == VD;
+  }
+  return false;
+}
+
+bool SAGenTestChecker::exprContainsVarRef(const Expr *E, const VarDecl *VD) {
+  if (!E || !VD) return false;
+  E = E->IgnoreParenImpCasts();
+  if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {
+    return DRE->getDecl() == VD;
+  }
+  for (const Stmt *Child : E->children()) {
+    if (const auto *CE = dyn_cast_or_null<Expr>(Child)) {
+      if (exprContainsVarRef(CE, VD))
+        return true;
+    }
   }
   return false;
 }
@@ -186,7 +254,6 @@                                                  llvm::DenseMap<const ValueDecl*, ArrayUseInfo> &Out) const {
   if (!Body || !IVar) return;

-  // Recursive walk
   for (const Stmt *Child : Body->children()) {
     if (!Child) continue;

@@ -205,9 +272,17 @@             AU.ExampleUse = ASE;
             Out.insert({V, AU});
           } else {
-            // Sizes should match for the same decl; keep the example if not set.
-            if (!It->second.ExampleUse)
+            // Keep the earliest example use (by source order).
+            const SourceManager &SM = ACtx.getSourceManager();
+            if (It->second.ExampleUse) {
+              SourceLocation CurLoc = It->second.ExampleUse->getBeginLoc();
+              SourceLocation NewLoc = ASE->getBeginLoc();
+              if (SM.isBeforeInTranslationUnit(NewLoc, CurLoc)) {
+                It->second.ExampleUse = ASE;
+              }
+            } else {
               It->second.ExampleUse = ASE;
+            }
           }
         }
       }
@@ -218,28 +293,113 @@   }
 }

+// New: robust matcher for relational operators on the loop index variable.
+bool SAGenTestChecker::matchRelationalOnIVar(const BinaryOperator *BO, const VarDecl *IVar,
+                                             uint64_t &Const, GuardKind &Kind, ASTContext &ACtx) {
+  if (!BO || !IVar) return false;
+
+  auto Op = BO->getOpcode();
+  switch (Op) {
+    case BO_LT: case BO_LE: case BO_GT: case BO_GE:
+    case BO_EQ: case BO_NE:
+      break;
+    default:
+      return false;
+  }
+
+  const Expr *L = BO->getLHS()->IgnoreParenImpCasts();
+  const Expr *R = BO->getRHS()->IgnoreParenImpCasts();
+
+  // i op Const
+  if (isVarRefTo(L, IVar)) {
+    uint64_t C;
+    if (!evalToUInt64(R, ACtx, C))
+      return false;
+    Const = C;
+    switch (Op) {
+      case BO_LT: Kind = GuardKind::Lt; break;
+      case BO_LE: Kind = GuardKind::Le; break;
+      case BO_GT: Kind = GuardKind::Gt; break;
+      case BO_GE: Kind = GuardKind::Ge; break;
+      case BO_EQ: Kind = GuardKind::Eq; break;
+      case BO_NE: Kind = GuardKind::Ne; break;
+      default: return false;
+    }
+    return true;
+  }
+
+  // Const op i  => normalize to i op' Const
+  if (isVarRefTo(R, IVar)) {
+    uint64_t C;
+    if (!evalToUInt64(L, ACtx, C))
+      return false;
+    Const = C;
+    switch (Op) {
+      case BO_LT: Kind = GuardKind::Gt; break; // Const < i  => i > Const
+      case BO_LE: Kind = GuardKind::Ge; break; // Const <= i => i >= Const
+      case BO_GT: Kind = GuardKind::Lt; break; // Const > i  => i < Const
+      case BO_GE: Kind = GuardKind::Le; break; // Const >= i => i <= Const
+      case BO_EQ: Kind = GuardKind::Eq; break;
+      case BO_NE: Kind = GuardKind::Ne; break;
+      default: return false;
+    }
+    return true;
+  }
+
+  return false;
+}
+
+// Generic DFS over Stmt (handles StmtExpr body, wrapper expressions) to find a relational on IVar.
+bool SAGenTestChecker::findRelationalOnIVarInStmt(const Stmt *S, const VarDecl *IVar,
+                                                  uint64_t &Const, GuardKind &Kind, ASTContext &ACtx) {
+  if (!S || !IVar) return false;
+
+  if (const auto *E = dyn_cast<Expr>(S)) {
+    const Expr *IE = E->IgnoreParenImpCasts();
+    if (const auto *BO = dyn_cast<BinaryOperator>(IE)) {
+      if (matchRelationalOnIVar(BO, IVar, Const, Kind, ACtx))
+        return true;
+    }
+    // Fallthrough: inspect children of the expression
+  }
+
+  for (const Stmt *Ch : S->children()) {
+    if (!Ch) continue;
+    if (findRelationalOnIVarInStmt(Ch, IVar, Const, Kind, ACtx))
+      return true;
+  }
+
+  return false;
+}
+
+bool SAGenTestChecker::parseCondOnIVar(const Expr *Cond, const VarDecl *IVar, uint64_t &Const, GuardKind &Kind, ASTContext &ACtx) {
+  Kind = GuardKind::None;
+  if (!Cond) return false;
+
+  // Try a simple direct parse first.
+  const Expr *C = Cond->IgnoreParenImpCasts();
+  if (const auto *BO = dyn_cast<BinaryOperator>(C)) {
+    if (matchRelationalOnIVar(BO, IVar, Const, Kind, ACtx))
+      return true;
+  }
+
+  // Robust path: search anywhere within the condition subtree (handles macros like WARN_ON, likely/unlikely, StmtExpr).
+  // Since Expr is a Stmt, reuse the Stmt DFS.
+  return findRelationalOnIVarInStmt(Cond, IVar, Const, Kind, ACtx);
+}
+
 bool SAGenTestChecker::condHasIVarAgainstConst(const Expr *CondE, const VarDecl *IVar, uint64_t ConstVal, ASTContext &ACtx) {
-  if (!CondE || !IVar) return false;
-
-  CondE = CondE->IgnoreParenImpCasts();
-  if (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {
-    // i >= ConstVal OR i == ConstVal
-    if (isVarRefTo(BO->getLHS(), IVar)) {
-      uint64_t Val;
-      if (evalToUInt64(BO->getRHS(), ACtx, Val) && Val == ConstVal) {
-        if (BO->getOpcode() == BO_GE || BO->getOpcode() == BO_EQ)
-          return true;
-      }
-    }
-    // ConstVal <= i (commuted form of i >= ConstVal)
-    if (isVarRefTo(BO->getRHS(), IVar)) {
-      uint64_t Val;
-      if (evalToUInt64(BO->getLHS(), ACtx, Val) && Val == ConstVal) {
-        if (BO->getOpcode() == BO_LE || BO->getOpcode() == BO_EQ)
-          return true;
-      }
-    }
-  }
+  uint64_t C = 0;
+  GuardKind K = GuardKind::None;
+  if (!parseCondOnIVar(CondE, IVar, C, K, ACtx))
+    return false;
+
+  // We only accept guards that conclusively guard i >= SmallSize or i == SmallSize.
+  if ((K == GuardKind::Ge && C == ConstVal) ||
+      (K == GuardKind::Eq && C == ConstVal))
+    return true;
+
+  // Also accept commuted forms already normalized by parseCondOnIVar.
   return false;
 }

@@ -252,7 +412,6 @@     if (const auto *IS = dyn_cast<IfStmt>(Child)) {
       const Expr *Cond = IS->getCond();
       if (condHasIVarAgainstConst(Cond, IVar, SmallSize, ACtx)) {
-        // Check then-branch for break or return
         const Stmt *Then = IS->getThen();
         if (!Then) continue;
         if (findSpecificTypeInChildren<BreakStmt>(Then) ||
@@ -260,16 +419,494 @@           return true;
         }
       }
-      // Also check nested statements within If
       if (hasGuardForBound(IS->getThen(), IVar, SmallSize, ACtx))
         return true;
       if (hasGuardForBound(IS->getElse(), IVar, SmallSize, ACtx))
         return true;
     } else {
-      // Recurse
       if (hasGuardForBound(Child, IVar, SmallSize, ACtx))
         return true;
     }
+  }
+
+  return false;
+}
+
+bool SAGenTestChecker::containsStmt(const Stmt *Parent, const Stmt *Target) {
+  if (!Parent || !Target) return false;
+  if (Parent == Target) return true;
+  for (const Stmt *Child : Parent->children()) {
+    if (!Child) continue;
+    if (containsStmt(Child, Target))
+      return true;
+  }
+  return false;
+}
+
+bool SAGenTestChecker::branchImpliesIndexInRange(GuardKind Kind, uint64_t Const, bool BranchWhenCondTrue,
+                                                 uint64_t SmallSize, uint64_t UB) {
+  if (Kind == GuardKind::None) return false;
+
+  auto hasSmallMinus1 = [](uint64_t S, uint64_t &Out) -> bool {
+    if (S == 0) return false;
+    Out = S - 1;
+    return true;
+  };
+
+  uint64_t S1 = 0;
+  switch (Kind) {
+    case GuardKind::Lt:
+      // i < Const ; true-branch safe if Const == SmallSize.
+      if (BranchWhenCondTrue && Const == SmallSize)
+        return true;
+      break;
+    case GuardKind::Le:
+      // i <= Const ; true-branch safe if Const == SmallSize - 1
+      if (BranchWhenCondTrue && hasSmallMinus1(SmallSize, S1) && Const == S1)
+        return true;
+      break;
+    case GuardKind::Ge:
+      // i >= Const ; false-branch safe if Const == SmallSize
+      if (!BranchWhenCondTrue && Const == SmallSize)
+        return true;
+      break;
+    case GuardKind::Gt:
+      // i > Const ; false-branch safe if Const == SmallSize - 1
+      if (!BranchWhenCondTrue && hasSmallMinus1(SmallSize, S1) && Const == S1)
+        return true;
+      break;
+    case GuardKind::Eq:
+      // i == Const ; false-branch safe if Const == SmallSize and UB == SmallSize + 1
+      if (!BranchWhenCondTrue && Const == SmallSize && UB == SmallSize + 1)
+        return true;
+      break;
+    case GuardKind::Ne:
+      // i != Const ; true-branch safe if Const == SmallSize and UB == SmallSize + 1
+      if (BranchWhenCondTrue && Const == SmallSize && UB == SmallSize + 1)
+        return true;
+      break;
+    default:
+      break;
+  }
+  return false;
+}
+
+// Robust ancestor BFS to find an enclosing If/?: that guards i.
+bool SAGenTestChecker::isIndexUseGuardedByBranch(const ArraySubscriptExpr *ASE, const VarDecl *IVar,
+                                                 uint64_t SmallSize, uint64_t UB, ASTContext &ACtx) {
+  if (!ASE) return false;
+
+  // BFS over ancestors to find closest IfStmt or ConditionalOperator that contains the use.
+  llvm::SmallVector<const Stmt*, 16> WL;
+  llvm::SmallPtrSet<const Stmt*, 32> Visited;
+  WL.push_back(ASE);
+  Visited.insert(ASE);
+
+  unsigned Steps = 0, MaxSteps = 256;
+
+  while (!WL.empty() && Steps++ < MaxSteps) {
+    const Stmt *Node = WL.pop_back_val();
+
+    auto Parents = ACtx.getParents(*Node);
+    for (const DynTypedNode &DN : Parents) {
+      if (const auto *CO = DN.get<ConditionalOperator>()) {
+        uint64_t C = 0;
+        GuardKind GK = GuardKind::None;
+        if (parseCondOnIVar(CO->getCond(), IVar, C, GK, ACtx)) {
+          bool InTrue = containsStmt(CO->getTrueExpr(), ASE);
+          bool InFalse = containsStmt(CO->getFalseExpr(), ASE);
+          if (InTrue || InFalse) {
+            bool BranchWhenCondTrue = InTrue;
+            if (branchImpliesIndexInRange(GK, C, BranchWhenCondTrue, SmallSize, UB))
+              return true;
+          }
+        }
+        if (!Visited.count(CO)) { Visited.insert(CO); WL.push_back(CO); }
+        continue;
+      }
+
+      if (const auto *IS = DN.get<IfStmt>()) {
+        uint64_t C = 0;
+        GuardKind GK = GuardKind::None;
+        if (parseCondOnIVar(IS->getCond(), IVar, C, GK, ACtx)) {
+          const Stmt *ThenS = IS->getThen();
+          const Stmt *ElseS = IS->getElse();
+          bool InThen = ThenS && containsStmt(ThenS, ASE);
+          bool InElse = ElseS && containsStmt(ElseS, ASE);
+          if (InThen || InElse) {
+            bool BranchWhenCondTrue = InThen;
+            if (branchImpliesIndexInRange(GK, C, BranchWhenCondTrue, SmallSize, UB))
+              return true;
+          }
+        }
+        if (!Visited.count(IS)) { Visited.insert(IS); WL.push_back(IS); }
+        continue;
+      }
+
+      if (const auto *PStmt = DN.get<Stmt>()) {
+        if (!Visited.count(PStmt)) { Visited.insert(PStmt); WL.push_back(PStmt); }
+        continue;
+      }
+    }
+  }
+
+  return false;
+}
+
+// Find nearest enclosing IfStmt that contains S and output the branch (then/else) subtree containing S.
+// Robust with multi-parent BFS; returns the closest by ancestor distance.
+const IfStmt *SAGenTestChecker::findEnclosingIfWithBranch(const Stmt *S, const Stmt *&OutBranch, ASTContext &ACtx) {
+  OutBranch = nullptr;
+  if (!S) return nullptr;
+
+  llvm::SmallVector<const Stmt*, 16> WL;
+  llvm::SmallPtrSet<const Stmt*, 32> Visited;
+  WL.push_back(S);
+  Visited.insert(S);
+
+  unsigned Steps = 0, MaxSteps = 256;
+
+  while (!WL.empty() && Steps++ < MaxSteps) {
+    const Stmt *Node = WL.pop_back_val();
+
+    auto Parents = ACtx.getParents(*Node);
+    for (const DynTypedNode &DN : Parents) {
+      if (const auto *IS = DN.get<IfStmt>()) {
+        const Stmt *ThenS = IS->getThen();
+        const Stmt *ElseS = IS->getElse();
+        if (ThenS && containsStmt(ThenS, S)) {
+          OutBranch = ThenS;
+          return IS;
+        }
+        if (ElseS && containsStmt(ElseS, S)) {
+          OutBranch = ElseS;
+          return IS;
+        }
+        if (!Visited.count(IS)) { Visited.insert(IS); WL.push_back(IS); }
+        continue;
+      }
+      if (const auto *P = DN.get<Stmt>()) {
+        if (!Visited.count(P)) { Visited.insert(P); WL.push_back(P); }
+      }
+    }
+  }
+  return nullptr;
+}
+
+bool SAGenTestChecker::parseMappingGuard(const Expr *Cond, const VarDecl *&InstVar, bool &ValidWhenTrue, ASTContext &ACtx) {
+  InstVar = nullptr;
+  ValidWhenTrue = false;
+  if (!Cond) return false;
+  Cond = Cond->IgnoreParenImpCasts();
+  const auto *BO = dyn_cast<BinaryOperator>(Cond);
+  if (!BO) return false;
+
+  const Expr *L = BO->getLHS()->IgnoreParenImpCasts();
+  const Expr *R = BO->getRHS()->IgnoreParenImpCasts();
+
+  auto asVar = [](const Expr *E) -> const VarDecl* {
+    if (!E) return nullptr;
+    if (const auto *DRE = dyn_cast<DeclRefExpr>(E))
+      return dyn_cast<VarDecl>(DRE->getDecl());
+    return nullptr;
+  };
+
+  auto asConst = [&](const Expr *E, int64_t &C) -> bool {
+    return evalToInt64(E, ACtx, C);
+  };
+
+  if (const VarDecl *VD = asVar(L)) {
+    int64_t Cst;
+    if (!asConst(R, Cst))
+      return false;
+    switch (BO->getOpcode()) {
+      case BO_GE: if (Cst == 0) { InstVar = VD; ValidWhenTrue = true; return true; } break;
+      case BO_GT: if (Cst == -1){ InstVar = VD; ValidWhenTrue = true; return true; } break;
+      case BO_NE: if (Cst == -1){ InstVar = VD; ValidWhenTrue = true; return true; } break;
+      case BO_EQ: if (Cst == -1){ InstVar = VD; ValidWhenTrue = false; return true; } break;
+      case BO_LT: if (Cst == 0) { InstVar = VD; ValidWhenTrue = false; return true; } break;
+      case BO_LE: if (Cst == -1){ InstVar = VD; ValidWhenTrue = false; return true; } break;
+      default: break;
+    }
+    return false;
+  }
+
+  if (const VarDecl *VD = asVar(R)) {
+    int64_t Cst;
+    if (!asConst(L, Cst))
+      return false;
+    switch (BO->getOpcode()) {
+      case BO_LE: if (Cst == 0) { InstVar = VD; ValidWhenTrue = true; return true; } break;
+      case BO_LT: if (Cst == -1){ InstVar = VD; ValidWhenTrue = true; return true; } break;
+      case BO_NE: if (Cst == -1){ InstVar = VD; ValidWhenTrue = true; return true; } break;
+      case BO_EQ: if (Cst == -1){ InstVar = VD; ValidWhenTrue = false; return true; } break;
+      case BO_GT: if (Cst == 0) { InstVar = VD; ValidWhenTrue = false; return true; } break;
+      case BO_GE: if (Cst == -1){ InstVar = VD; ValidWhenTrue = false; return true; } break;
+      default: break;
+    }
+    return false;
+  }
+
+  return false;
+}
+
+const CompoundStmt *SAGenTestChecker::findDirectCompoundParent(const Stmt *S, ASTContext &ACtx) {
+  if (!S) return nullptr;
+
+  llvm::SmallVector<const Stmt*, 16> WL;
+  llvm::SmallPtrSet<const Stmt*, 32> Visited;
+  WL.push_back(S);
+  Visited.insert(S);
+
+  unsigned Steps = 0, MaxSteps = 256;
+
+  while (!WL.empty() && Steps++ < MaxSteps) {
+    const Stmt *Node = WL.pop_back_val();
+
+    auto Parents = ACtx.getParents(*Node);
+    for (const DynTypedNode &DN : Parents) {
+      if (const auto *CS = DN.get<CompoundStmt>()) {
+        // Ensure Node is a direct child of CS.
+        for (const Stmt *Ch : CS->body()) {
+          if (Ch == Node)
+            return CS;
+        }
+        if (!Visited.count(CS)) { Visited.insert(CS); WL.push_back(CS); }
+        continue;
+      }
+      if (const auto *P = DN.get<Stmt>()) {
+        if (!Visited.count(P)) { Visited.insert(P); WL.push_back(P); }
+      }
+    }
+  }
+  return nullptr;
+}
+
+bool SAGenTestChecker::hasPriorAssignFromIVar(const CompoundStmt *CS, const IfStmt *IS, const VarDecl *InstVar, const VarDecl *IVar) {
+  if (!CS || !IS || !InstVar || !IVar) return false;
+
+  for (const Stmt *Ch : CS->body()) {
+    if (Ch == IS)
+      break;
+
+    if (const auto *DS = dyn_cast<DeclStmt>(Ch)) {
+      for (const Decl *Di : DS->decls()) {
+        if (const auto *VD = dyn_cast<VarDecl>(Di)) {
+          if (VD == InstVar) {
+            const Expr *Init = VD->getInit();
+            if (Init && exprContainsVarRef(Init, IVar))
+              return true;
+          }
+        }
+      }
+    }
+
+    if (const auto *BO = dyn_cast<BinaryOperator>(Ch)) {
+      if (BO->getOpcode() == BO_Assign) {
+        const Expr *L = BO->getLHS()->IgnoreParenImpCasts();
+        if (const auto *LDR = dyn_cast<DeclRefExpr>(L)) {
+          if (LDR->getDecl() == InstVar) {
+            const Expr *RHS = BO->getRHS();
+            if (RHS && exprContainsVarRef(RHS, IVar))
+              return true;
+          }
+        }
+      }
+    }
+  }
+  return false;
+}
+
+bool SAGenTestChecker::branchContainsArrayIndexWithVar(const Stmt *Branch, const VarDecl *IdxVar) {
+  if (!Branch || !IdxVar) return false;
+  for (const Stmt *Ch : Branch->children()) {
+    if (!Ch) continue;
+    if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(Ch)) {
+      const Expr *Idx = ASE->getIdx()->IgnoreParenImpCasts();
+      if (const auto *DRE = dyn_cast<DeclRefExpr>(Idx)) {
+        if (DRE->getDecl() == IdxVar)
+          return true;
+      }
+    }
+    if (branchContainsArrayIndexWithVar(Ch, IdxVar))
+      return true;
+  }
+  return false;
+}
+
+bool SAGenTestChecker::isGuardedByIndexMapping(const ArraySubscriptExpr *ASE, const VarDecl *IVar, ASTContext &ACtx) {
+  if (!ASE || !IVar) return false;
+
+  const Stmt *Branch = nullptr;
+  const IfStmt *IS = findEnclosingIfWithBranch(ASE, Branch, ACtx);
+  if (!IS || !Branch)
+    return false;
+
+  const VarDecl *InstVar = nullptr;
+  bool ValidWhenTrue = false;
+  if (!parseMappingGuard(IS->getCond(), InstVar, ValidWhenTrue, ACtx) || !InstVar)
+    return false;
+
+  bool InThen = containsStmt(IS->getThen(), ASE);
+  bool InElse = IS->getElse() && containsStmt(IS->getElse(), ASE);
+  if (!( (ValidWhenTrue && InThen) || (!ValidWhenTrue && InElse) ))
+    return false;
+
+  const CompoundStmt *CS = findDirectCompoundParent(IS, ACtx);
+  if (!hasPriorAssignFromIVar(CS, IS, InstVar, IVar))
+    return false;
+
+  if (!branchContainsArrayIndexWithVar(Branch, InstVar))
+    return false;
+
+  return true;
+}
+
+SAGenTestChecker::ExitKind SAGenTestChecker::getSimpleEarlyExit(const Stmt *S) {
+  if (!S) return ExitKind::None;
+
+  if (isa<ContinueStmt>(S))
+    return ExitKind::Continue;
+  if (isa<BreakStmt>(S))
+    return ExitKind::Break;
+  if (isa<ReturnStmt>(S))
+    return ExitKind::Return;
+
+  if (const auto *CS = dyn_cast<CompoundStmt>(S)) {
+    // Accept only a single-statement compound of the exit.
+    const Stmt *Only = nullptr;
+    for (const Stmt *Ch : CS->body()) {
+      if (!Ch) continue;
+      if (Only) {
+        Only = nullptr; // multiple statements -> not simple
+        break;
+      }
+      Only = Ch;
+    }
+    if (Only)
+      return getSimpleEarlyExit(Only);
+  }
+
+  return ExitKind::None;
+}
+
+bool SAGenTestChecker::branchImpliesIndexOutOfRange(GuardKind Kind, uint64_t Const, bool BranchWhenCondTrue,
+                                                    uint64_t SmallSize, ExitKind EK) {
+  if (Kind == GuardKind::None || EK == ExitKind::None) return false;
+
+  auto hasSmallMinus1 = [](uint64_t S, uint64_t &Out) -> bool {
+    if (S == 0) return false;
+    Out = S - 1;
+    return true;
+  };
+
+  bool IsContinue = (EK == ExitKind::Continue);
+  bool IsBreakOrReturn = (EK == ExitKind::Break || EK == ExitKind::Return);
+
+  uint64_t S1 = 0;
+  bool HasS1 = hasSmallMinus1(SmallSize, S1);
+
+  if (BranchWhenCondTrue) {
+    // Then-branch exits.
+    switch (Kind) {
+      case GuardKind::Ge:
+        if (Const == SmallSize) return true; // i >= S
+        break;
+      case GuardKind::Gt:
+        if (HasS1 && Const == S1) return true; // i > S-1
+        break;
+      case GuardKind::Eq:
+        if (IsBreakOrReturn && Const == SmallSize) return true; // i == S, terminate loop
+        break;
+      default:
+        break;
+    }
+  } else {
+    // Else-branch exits.
+    switch (Kind) {
+      case GuardKind::Lt:
+        if (Const == SmallSize) return true; // !(i < S) => i >= S
+        break;
+      case GuardKind::Le:
+        if (HasS1 && Const == S1) return true; // !(i <= S-1) => i >= S
+        break;
+      case GuardKind::Ne:
+        if (IsBreakOrReturn && Const == SmallSize) return true; // !(i != S) => i == S
+        break;
+      default:
+        break;
+    }
+  }
+
+  // For continue, disallow equality-based one-off guards (they don't protect the whole tail).
+  if (IsContinue) {
+    // Already enforced above by only allowing Ge/Gt and Lt/Le exact thresholds.
+  }
+
+  return false;
+}
+
+bool SAGenTestChecker::hasEarlyExitGuardBeforeUse(const ArraySubscriptExpr *Use, const VarDecl *IVar,
+                                                  uint64_t SmallSize, ASTContext &ACtx) {
+  if (!Use || !IVar) return false;
+
+  const Stmt *Node = Use;
+
+  // Climb ancestors; at each direct compound parent, scan earlier siblings for a guarding if.
+  for (unsigned Depth = 0; Depth < 64 && Node; ++Depth) {
+    const CompoundStmt *CS = nullptr;
+
+    // Find the immediate compound that directly contains Node as a child subtree.
+    CS = findDirectCompoundParent(Node, ACtx);
+    if (!CS)
+      break;
+
+    // Identify which child contains Node, and scan earlier siblings for guarding If.
+    unsigned IndexOfChild = 0;
+    bool FoundChild = false;
+    for (const Stmt *Ch : CS->body()) {
+      if (!Ch) { ++IndexOfChild; continue; }
+      if (containsStmt(Ch, Node)) {
+        FoundChild = true;
+        break;
+      }
+      ++IndexOfChild;
+    }
+
+    if (FoundChild) {
+      unsigned CurIdx = 0;
+      for (const Stmt *Ch : CS->body()) {
+        if (!Ch) { ++CurIdx; continue; }
+        if (CurIdx >= IndexOfChild)
+          break;
+
+        if (const auto *IS = dyn_cast<IfStmt>(Ch)) {
+          uint64_t C = 0;
+          GuardKind GK = GuardKind::None;
+          if (!parseCondOnIVar(IS->getCond(), IVar, C, GK, ACtx)) {
+            ++CurIdx;
+            continue;
+          }
+
+          ExitKind ThenEK = getSimpleEarlyExit(IS->getThen());
+          ExitKind ElseEK = getSimpleEarlyExit(IS->getElse());
+
+          if (ThenEK != ExitKind::None) {
+            if (branchImpliesIndexOutOfRange(GK, C, /*BranchWhenCondTrue=*/true, SmallSize, ThenEK))
+              return true;
+          }
+          if (ElseEK != ExitKind::None) {
+            if (branchImpliesIndexOutOfRange(GK, C, /*BranchWhenCondTrue=*/false, SmallSize, ElseEK))
+              return true;
+          }
+        }
+
+        ++CurIdx;
+      }
+    }
+
+    // Move Node up to this compound to continue climbing.
+    Node = CS;
   }

   return false;
@@ -278,7 +915,6 @@ void SAGenTestChecker::processForStmt(const ForStmt *FS, ASTContext &ACtx, BugReporter &BR) const {
   if (!FS) return;

-  // Extract loop condition: expect i < UB or i <= UB
   const Expr *Cond = FS->getCond();
   if (!Cond) return;

@@ -298,25 +934,20 @@   if (!evalToUInt64(BO->getRHS(), ACtx, UB))
     return;

-  // Adjust for <= bound: effective iteration count
   if (Op == BO_LE)
     UB = UB + 1;

-  // Check increment is a simple increasing increment
   if (!isSimpleIncreasingIncrement(FS->getInc(), IVar, ACtx))
     return;

-  // Check initializer sets i = 0
   if (!isZeroInitOfVar(FS->getInit(), IVar, ACtx))
     return;

-  // Collect array uses indexed by i
   llvm::DenseMap<const ValueDecl*, ArrayUseInfo> Uses;
   collectArrayUsesIndexedBy(FS->getBody(), IVar, ACtx, Uses);
   if (Uses.size() < 2)
-    return; // Need at least two arrays A[i], B[i]
-
-  // Find any array with size == UB
+    return;
+
   bool HasBoundArray = false;
   for (const auto &It : Uses) {
     if (It.second.Size == UB) {
@@ -327,7 +958,6 @@   if (!HasBoundArray)
     return;

-  // Find a smaller array with size < UB
   const ArrayUseInfo *Small = nullptr;
   for (const auto &It : Uses) {
     if (It.second.Size < UB) {
@@ -338,11 +968,25 @@   if (!Small)
     return;

-  // Suppress if there is a guard like: if (i >= SmallSize) break/return;
+  // Suppress classic loop-tail early exit guards, including macro-wrapped conditions (e.g., WARN_ON).
   if (hasGuardForBound(FS->getBody(), IVar, Small->Size, ACtx))
     return;

-  // Report bug at the smaller array access site (if available), otherwise at the for condition
+  // Suppress if this specific use is inside a branch that implies i is in range.
+  if (Small->ExampleUse &&
+      isIndexUseGuardedByBranch(Small->ExampleUse, IVar, Small->Size, UB, ACtx))
+    return;
+
+  // Suppress for mapping guards that effectively tie another index to i.
+  if (Small->ExampleUse &&
+      isGuardedByIndexMapping(Small->ExampleUse, IVar, ACtx))
+    return;
+
+  // Suppress when earlier sibling statements perform an early-exit once i is out of range.
+  if (Small->ExampleUse &&
+      hasEarlyExitGuardBeforeUse(Small->ExampleUse, IVar, Small->Size, ACtx))
+    return;
+
   SourceLocation Loc;
   if (Small->ExampleUse)
     Loc = Small->ExampleUse->getExprLoc();
@@ -376,7 +1020,6 @@
   ASTContext &ACtx = Mgr.getASTContext();

-  // Simple recursive traversal to find ForStmt
   llvm::SmallVector<const Stmt*, 16> Stack;
   Stack.push_back(Body);
   while (!Stack.empty()) {
