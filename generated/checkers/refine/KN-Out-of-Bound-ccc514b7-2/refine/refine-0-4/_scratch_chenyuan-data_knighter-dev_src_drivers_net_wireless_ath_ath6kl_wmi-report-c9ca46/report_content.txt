### Report Summary

File:| drivers/net/wireless/ath/ath6kl/wmi.c
---|---
Warning:| line 2046, column 16
Loop bound uses size of one array but also indexes a smaller array with the
same index; possible out-of-bounds (bound=6, array 'supp_rates' size=2)

### Annotated Source Code


1996  | 			     u32 home_dwell_time, u32 force_scan_interval,
1997  | 			     s8 num_chan, u16 *ch_list, u32 no_cck, u32 *rates)
1998  | {
1999  |  struct ieee80211_supported_band *sband;
2000  |  struct sk_buff *skb;
2001  |  struct wmi_begin_scan_cmd *sc;
2002  | 	s8 *supp_rates;
2003  |  int i, band, ret;
2004  |  struct ath6kl *ar = wmi->parent_dev;
2005  |  int num_rates;
2006  | 	u32 ratemask;
2007  |
2008  |  if (!test_bit(ATH6KL_FW_CAPABILITY_STA_P2PDEV_DUPLEX,
2009  |  ar->fw_capabilities)) {
2010  |  return ath6kl_wmi_startscan_cmd(wmi, if_idx,
2011  | 						scan_type, force_fgscan,
2012  | 						is_legacy, home_dwell_time,
2013  | 						force_scan_interval,
2014  | 						num_chan, ch_list);
2015  | 	}
2016  |
2017  |  if ((scan_type != WMI_LONG_SCAN) && (scan_type != WMI_SHORT_SCAN))
2018  |  return -EINVAL;
2019  |
2020  |  if (num_chan > WMI_MAX_CHANNELS)
2021  |  return -EINVAL;
2022  |
2023  | 	skb = ath6kl_wmi_get_new_buf(struct_size(sc, ch_list, num_chan));
2024  |  if (!skb)
2025  |  return -ENOMEM;
2026  |
2027  | 	sc = (struct wmi_begin_scan_cmd *) skb->data;
2028  | 	sc->scan_type = scan_type;
2029  | 	sc->force_fg_scan = cpu_to_le32(force_fgscan);
2030  | 	sc->is_legacy = cpu_to_le32(is_legacy);
2031  | 	sc->home_dwell_time = cpu_to_le32(home_dwell_time);
2032  | 	sc->force_scan_intvl = cpu_to_le32(force_scan_interval);
2033  | 	sc->no_cck = cpu_to_le32(no_cck);
2034  | 	sc->num_ch = num_chan;
2035  |
2036  |  for (band = 0; band < NUM_NL80211_BANDS; band++) {
2037  | 		sband = ar->wiphy->bands[band];
2038  |
2039  |  if (!sband)
2040  |  continue;
2041  |
2042  |  if (WARN_ON(band >= ATH6KL_NUM_BANDS))
2043  |  break;
2044  |
2045  | 		ratemask = rates[band];
2046  | 		supp_rates = sc->supp_rates[band].rates;
    Loop bound uses size of one array but also indexes a smaller array with the same index; possible out-of-bounds (bound=6, array 'supp_rates' size=2)
2047  | 		num_rates = 0;
2048  |
2049  |  for (i = 0; i < sband->n_bitrates; i++) {
2050  |  if ((BIT(i) & ratemask) == 0)
2051  |  continue; /* skip rate */
2052  | 			supp_rates[num_rates++] =
2053  | 			    (u8) (sband->bitrates[i].bitrate / 5);
2054  | 		}
2055  | 		sc->supp_rates[band].nrates = num_rates;
2056  | 	}
2057  |
2058  |  for (i = 0; i < num_chan; i++)
2059  | 		sc->ch_list[i] = cpu_to_le16(ch_list[i]);
2060  |
2061  | 	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_BEGIN_SCAN_CMDID,
2062  | 				  NO_SYNC_WMIFLAG);
2063  |
2064  |  return ret;
2065  | }
2066  |
2067  | int ath6kl_wmi_enable_sched_scan_cmd(struct wmi *wmi, u8 if_idx, bool enable)
2068  | {
2069  |  struct sk_buff *skb;
2070  |  struct wmi_enable_sched_scan_cmd *sc;
2071  |  int ret;
2072  |
2073  | 	skb = ath6kl_wmi_get_new_buf(sizeof(*sc));
2074  |  if (!skb)
2075  |  return -ENOMEM;
2076  |
