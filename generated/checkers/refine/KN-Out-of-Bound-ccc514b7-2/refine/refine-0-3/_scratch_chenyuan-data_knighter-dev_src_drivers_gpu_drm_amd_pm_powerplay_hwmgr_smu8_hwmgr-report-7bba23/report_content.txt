### Report Summary

File:| drivers/gpu/drm/amd/amdgpu/../pm/powerplay/hwmgr/smu8_hwmgr.c
---|---
Warning:| line 365, column 4
Loop bound uses size of one array but also indexes a smaller array with the
same index; possible out-of-bounds (bound=4, array 'nbp_memory_clock' size=2)

### Annotated Source Code


315   | 	uint8_t frev, crev;
316   | 	uint16_t size;
317   |
318   | 	info = (ATOM_INTEGRATED_SYSTEM_INFO_V1_9 *)smu_atom_get_data_table(hwmgr->adev,
319   |  GetIndexIntoMasterTable(DATA, IntegratedSystemInfo),
320   | 			&size, &frev, &crev);
321   |
322   |  if (info == NULL) {
323   |  pr_err("Could not retrieve the Integrated System Info Table!\n");
324   |  return -EINVAL;
325   | 	}
326   |
327   |  if (crev != 9) {
328   |  pr_err("Unsupported IGP table: %d %d\n", frev, crev);
329   |  return -EINVAL;
330   | 	}
331   |
332   | 	data->sys_info.bootup_uma_clock =
333   |  le32_to_cpu(info->ulBootUpUMAClock);
334   |
335   | 	data->sys_info.bootup_engine_clock =
336   |  le32_to_cpu(info->ulBootUpEngineClock);
337   |
338   | 	data->sys_info.dentist_vco_freq =
339   |  le32_to_cpu(info->ulDentistVCOFreq);
340   |
341   | 	data->sys_info.system_config =
342   |  le32_to_cpu(info->ulSystemConfig);
343   |
344   | 	data->sys_info.bootup_nb_voltage_index =
345   |  le16_to_cpu(info->usBootUpNBVoltage);
346   |
347   | 	data->sys_info.htc_hyst_lmt =
348   | 			(info->ucHtcHystLmt == 0) ? 5 : info->ucHtcHystLmt;
349   |
350   | 	data->sys_info.htc_tmp_lmt =
351   | 			(info->ucHtcTmpLmt == 0) ? 203 : info->ucHtcTmpLmt;
352   |
353   |  if (data->sys_info.htc_tmp_lmt <=
354   | 			data->sys_info.htc_hyst_lmt) {
355   |  pr_err("The htcTmpLmt should be larger than htcHystLmt.\n");
356   |  return -EINVAL;
357   | 	}
358   |
359   | 	data->sys_info.nb_dpm_enable =
360   | 				data->enable_nb_ps_policy &&
361   | 				(le32_to_cpu(info->ulSystemConfig) >> 3 & 0x1);
362   |
363   |  for (i = 0; i < SMU8_NUM_NBPSTATES; i++) {
364   |  if (i < SMU8_NUM_NBPMEMORYCLOCK) {
365   |  data->sys_info.nbp_memory_clock[i] =
    Loop bound uses size of one array but also indexes a smaller array with the same index; possible out-of-bounds (bound=4, array 'nbp_memory_clock' size=2)
366   |  le32_to_cpu(info->ulNbpStateMemclkFreq[i]);
367   | 		}
368   | 		data->sys_info.nbp_n_clock[i] =
369   |  le32_to_cpu(info->ulNbpStateNClkFreq[i]);
370   | 	}
371   |
372   |  for (i = 0; i < MAX_DISPLAY_CLOCK_LEVEL; i++) {
373   | 		data->sys_info.display_clock[i] =
374   |  le32_to_cpu(info->sDispClkVoltageMapping[i].ulMaximumSupportedCLK);
375   | 	}
376   |
377   |  /* Here use 4 levels, make sure not exceed */
378   |  for (i = 0; i < SMU8_NUM_NBPSTATES; i++) {
379   | 		data->sys_info.nbp_voltage_index[i] =
380   |  le16_to_cpu(info->usNBPStateVoltage[i]);
381   | 	}
382   |
383   |  if (!data->sys_info.nb_dpm_enable) {
384   |  for (i = 1; i < SMU8_NUM_NBPSTATES; i++) {
385   |  if (i < SMU8_NUM_NBPMEMORYCLOCK) {
386   | 				data->sys_info.nbp_memory_clock[i] =
387   | 				    data->sys_info.nbp_memory_clock[0];
388   | 			}
389   | 			data->sys_info.nbp_n_clock[i] =
390   | 				    data->sys_info.nbp_n_clock[0];
391   | 			data->sys_info.nbp_voltage_index[i] =
392   | 				    data->sys_info.nbp_voltage_index[0];
393   | 		}
394   | 	}
395   |
