--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -447,93 +447,104 @@   return false;
 }

+// Robust ancestor BFS to find an enclosing If/?: that guards i.
 bool SAGenTestChecker::isIndexUseGuardedByBranch(const ArraySubscriptExpr *ASE, const VarDecl *IVar,
                                                  uint64_t SmallSize, uint64_t UB, ASTContext &ACtx) {
   if (!ASE) return false;

-  const Stmt *Node = ASE;
-  for (unsigned Depth = 0; Depth < 64 && Node; ++Depth) {
+  // BFS over ancestors to find closest IfStmt or ConditionalOperator that contains the use.
+  llvm::SmallVector<const Stmt*, 16> WL;
+  llvm::SmallPtrSet<const Stmt*, 32> Visited;
+  WL.push_back(ASE);
+  Visited.insert(ASE);
+
+  unsigned Steps = 0, MaxSteps = 256;
+
+  while (!WL.empty() && Steps++ < MaxSteps) {
+    const Stmt *Node = WL.pop_back_val();
+
     auto Parents = ACtx.getParents(*Node);
-    if (Parents.empty())
-      break;
-
-    const DynTypedNode &DN = Parents[0];
-    if (const auto *CO = DN.get<ConditionalOperator>()) {
-      uint64_t C = 0;
-      GuardKind GK = GuardKind::None;
-      if (!parseCondOnIVar(CO->getCond(), IVar, C, GK, ACtx)) {
-        Node = CO;
+    for (const DynTypedNode &DN : Parents) {
+      if (const auto *CO = DN.get<ConditionalOperator>()) {
+        uint64_t C = 0;
+        GuardKind GK = GuardKind::None;
+        if (parseCondOnIVar(CO->getCond(), IVar, C, GK, ACtx)) {
+          bool InTrue = containsStmt(CO->getTrueExpr(), ASE);
+          bool InFalse = containsStmt(CO->getFalseExpr(), ASE);
+          if (InTrue || InFalse) {
+            bool BranchWhenCondTrue = InTrue;
+            if (branchImpliesIndexInRange(GK, C, BranchWhenCondTrue, SmallSize, UB))
+              return true;
+          }
+        }
+        if (!Visited.count(CO)) { Visited.insert(CO); WL.push_back(CO); }
         continue;
       }
-      bool InTrue = containsStmt(CO->getTrueExpr(), ASE);
-      bool InFalse = containsStmt(CO->getFalseExpr(), ASE);
-      if (InTrue || InFalse) {
-        bool BranchWhenCondTrue = InTrue;
-        if (branchImpliesIndexInRange(GK, C, BranchWhenCondTrue, SmallSize, UB))
-          return true;
-      }
-      Node = CO;
-      continue;
-    }
-
-    if (const auto *IS = DN.get<IfStmt>()) {
-      uint64_t C = 0;
-      GuardKind GK = GuardKind::None;
-      if (!parseCondOnIVar(IS->getCond(), IVar, C, GK, ACtx)) {
-        Node = IS;
+
+      if (const auto *IS = DN.get<IfStmt>()) {
+        uint64_t C = 0;
+        GuardKind GK = GuardKind::None;
+        if (parseCondOnIVar(IS->getCond(), IVar, C, GK, ACtx)) {
+          const Stmt *ThenS = IS->getThen();
+          const Stmt *ElseS = IS->getElse();
+          bool InThen = ThenS && containsStmt(ThenS, ASE);
+          bool InElse = ElseS && containsStmt(ElseS, ASE);
+          if (InThen || InElse) {
+            bool BranchWhenCondTrue = InThen;
+            if (branchImpliesIndexInRange(GK, C, BranchWhenCondTrue, SmallSize, UB))
+              return true;
+          }
+        }
+        if (!Visited.count(IS)) { Visited.insert(IS); WL.push_back(IS); }
         continue;
       }
-      const Stmt *ThenS = IS->getThen();
-      const Stmt *ElseS = IS->getElse();
-      bool InThen = ThenS && containsStmt(ThenS, ASE);
-      bool InElse = ElseS && containsStmt(ElseS, ASE);
-      if (InThen || InElse) {
-        bool BranchWhenCondTrue = InThen;
-        if (branchImpliesIndexInRange(GK, C, BranchWhenCondTrue, SmallSize, UB))
-          return true;
-      }
-      Node = IS;
-      continue;
-    }
-
-    if (const auto *ParentStmt = DN.get<Stmt>()) {
-      Node = ParentStmt;
-      continue;
-    } else {
-      break;
-    }
-  }
-
-  return false;
-}
-
+
+      if (const auto *PStmt = DN.get<Stmt>()) {
+        if (!Visited.count(PStmt)) { Visited.insert(PStmt); WL.push_back(PStmt); }
+        continue;
+      }
+    }
+  }
+
+  return false;
+}
+
+// Find nearest enclosing IfStmt that contains S and output the branch (then/else) subtree containing S.
+// Robust with multi-parent BFS; returns the closest by ancestor distance.
 const IfStmt *SAGenTestChecker::findEnclosingIfWithBranch(const Stmt *S, const Stmt *&OutBranch, ASTContext &ACtx) {
   OutBranch = nullptr;
-  const Stmt *Node = S;
-  for (unsigned Depth = 0; Depth < 64 && Node; ++Depth) {
+  if (!S) return nullptr;
+
+  llvm::SmallVector<const Stmt*, 16> WL;
+  llvm::SmallPtrSet<const Stmt*, 32> Visited;
+  WL.push_back(S);
+  Visited.insert(S);
+
+  unsigned Steps = 0, MaxSteps = 256;
+
+  while (!WL.empty() && Steps++ < MaxSteps) {
+    const Stmt *Node = WL.pop_back_val();
+
     auto Parents = ACtx.getParents(*Node);
-    if (Parents.empty())
-      break;
-    const DynTypedNode &DN = Parents[0];
-    if (const auto *IS = DN.get<IfStmt>()) {
-      const Stmt *ThenS = IS->getThen();
-      const Stmt *ElseS = IS->getElse();
-      if (ThenS && containsStmt(ThenS, S)) {
-        OutBranch = ThenS;
-        return IS;
-      }
-      if (ElseS && containsStmt(ElseS, S)) {
-        OutBranch = ElseS;
-        return IS;
-      }
-      Node = IS;
-      continue;
-    }
-    if (const auto *P = DN.get<Stmt>()) {
-      Node = P;
-      continue;
-    }
-    break;
+    for (const DynTypedNode &DN : Parents) {
+      if (const auto *IS = DN.get<IfStmt>()) {
+        const Stmt *ThenS = IS->getThen();
+        const Stmt *ElseS = IS->getElse();
+        if (ThenS && containsStmt(ThenS, S)) {
+          OutBranch = ThenS;
+          return IS;
+        }
+        if (ElseS && containsStmt(ElseS, S)) {
+          OutBranch = ElseS;
+          return IS;
+        }
+        if (!Visited.count(IS)) { Visited.insert(IS); WL.push_back(IS); }
+        continue;
+      }
+      if (const auto *P = DN.get<Stmt>()) {
+        if (!Visited.count(P)) { Visited.insert(P); WL.push_back(P); }
+      }
+    }
   }
   return nullptr;
 }
@@ -596,25 +607,33 @@ }

 const CompoundStmt *SAGenTestChecker::findDirectCompoundParent(const Stmt *S, ASTContext &ACtx) {
-  const Stmt *Node = S;
-  for (unsigned Depth = 0; Depth < 64 && Node; ++Depth) {
+  if (!S) return nullptr;
+
+  llvm::SmallVector<const Stmt*, 16> WL;
+  llvm::SmallPtrSet<const Stmt*, 32> Visited;
+  WL.push_back(S);
+  Visited.insert(S);
+
+  unsigned Steps = 0, MaxSteps = 256;
+
+  while (!WL.empty() && Steps++ < MaxSteps) {
+    const Stmt *Node = WL.pop_back_val();
+
     auto Parents = ACtx.getParents(*Node);
-    if (Parents.empty())
-      break;
-    const DynTypedNode &DN = Parents[0];
-    if (const auto *CS = DN.get<CompoundStmt>()) {
-      for (const Stmt *Ch : CS->body()) {
-        if (Ch == S)
-          return CS;
-      }
-      Node = CS;
-      continue;
-    }
-    if (const auto *P = DN.get<Stmt>()) {
-      Node = P;
-      continue;
-    }
-    break;
+    for (const DynTypedNode &DN : Parents) {
+      if (const auto *CS = DN.get<CompoundStmt>()) {
+        // Ensure Node is a direct child of CS.
+        for (const Stmt *Ch : CS->body()) {
+          if (Ch == Node)
+            return CS;
+        }
+        if (!Visited.count(CS)) { Visited.insert(CS); WL.push_back(CS); }
+        continue;
+      }
+      if (const auto *P = DN.get<Stmt>()) {
+        if (!Visited.count(P)) { Visited.insert(P); WL.push_back(P); }
+      }
+    }
   }
   return nullptr;
 }
@@ -777,8 +796,7 @@
   // For continue, disallow equality-based one-off guards (they don't protect the whole tail).
   if (IsContinue) {
-    // We already only allowed Ge/Gt and Lt/Le exact thresholds; Eq/Ne were excluded above.
-    // Nothing additional needed here.
+    // Already enforced above by only allowing Ge/Gt and Lt/Le exact thresholds.
   }

   return false;
@@ -795,36 +813,8 @@     const CompoundStmt *CS = nullptr;

     // Find the immediate compound that directly contains Node as a child subtree.
-    const Stmt *Cur = Node;
-    for (unsigned D2 = 0; D2 < 64 && Cur; ++D2) {
-      auto Parents = ACtx.getParents(*Cur);
-      if (Parents.empty())
-        break;
-      const DynTypedNode &DN = Parents[0];
-      if (const auto *PCS = DN.get<CompoundStmt>()) {
-        // Ensure Cur is a direct child of PCS.
-        bool IsDirectChild = false;
-        for (const Stmt *Ch : PCS->body()) {
-          if (Ch == Cur) {
-            IsDirectChild = true;
-            break;
-          }
-        }
-        if (IsDirectChild) {
-          CS = PCS;
-          break;
-        } else {
-          Cur = PCS;
-          continue;
-        }
-      }
-      if (const auto *PStmt = DN.get<Stmt>()) {
-        Cur = PStmt;
-        continue;
-      }
-      break;
-    }
-
+    // Use robust multi-parent BFS to locate direct compound parent.
+    CS = findDirectCompoundParent(Node, ACtx);
     if (!CS)
       break;

@@ -935,18 +925,21 @@   if (!Small)
     return;

+  // Suppress classic loop-tail early exit guards.
   if (hasGuardForBound(FS->getBody(), IVar, Small->Size, ACtx))
     return;

+  // Suppress if this specific use is inside a branch that implies i is in range.
   if (Small->ExampleUse &&
       isIndexUseGuardedByBranch(Small->ExampleUse, IVar, Small->Size, UB, ACtx))
     return;

+  // Suppress for mapping guards that effectively tie another index to i.
   if (Small->ExampleUse &&
       isGuardedByIndexMapping(Small->ExampleUse, IVar, ACtx))
     return;

-  // New suppression: early-exit guard before the use (e.g. if (i > S-1) continue;)
+  // Suppress when earlier sibling statements perform an early-exit once i is out of range.
   if (Small->ExampleUse &&
       hasEarlyExitGuardBeforeUse(Small->ExampleUse, IVar, Small->Size, ACtx))
     return;
