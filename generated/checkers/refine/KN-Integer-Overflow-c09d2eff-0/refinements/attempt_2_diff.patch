--- attempt_2_original.cpp+++ attempt_2.cpp@@ -20,6 +20,7 @@ #include "clang/AST/Stmt.h"
 #include "clang/Basic/SourceManager.h"
 #include "clang/Lex/Lexer.h"
+#include <optional>

 using namespace clang;
 using namespace ento;
@@ -39,11 +40,17 @@                           llvm::SmallVectorImpl<unsigned> &DerefParams);
 bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C);

-// No custom program state needed.
+// Program state: Map constant-valued integer locals to their known values.
+REGISTER_MAP_WITH_PROGRAMSTATE(ConstIntVarMap, const VarDecl *, llvm::APSInt)

 namespace {

-class SAGenTestChecker : public Checker<check::PostStmt<BinaryOperator>> {
+class SAGenTestChecker
+    : public Checker<
+          check::PostStmt<BinaryOperator>,
+          check::PostStmt<DeclStmt>,
+          check::Bind,
+          check::RegionChanges> {
    mutable std::unique_ptr<BugType> BT;

 public:
@@ -52,6 +59,14 @@                        "Integer Overflow")) {}

   void checkPostStmt(const BinaryOperator *B, CheckerContext &C) const;
+  void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;
+  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;
+  ProgramStateRef checkRegionChanges(ProgramStateRef State,
+                                     const InvalidatedSymbols *Invalidated,
+                                     ArrayRef<const MemRegion *> ExplicitRegions,
+                                     ArrayRef<const MemRegion *> Regions,
+                                     const LocationContext *LCtx,
+                                     const CallEvent *Call) const;

 private:
   static unsigned getIntWidth(QualType T, CheckerContext &C) {
@@ -67,8 +82,59 @@     return E->getType()->isIntegerType();
   }

+  static const Expr *ignoreNoOps(const Expr *E) {
+    return E ? E->IgnoreParenImpCasts() : nullptr;
+  }
+
   static bool isNoOpWrapper(const Stmt *S) {
     return isa<ParenExpr>(S) || isa<ImplicitCastExpr>(S);
+  }
+
+  static bool isSizeT(QualType T, CheckerContext &C) {
+    ASTContext &AC = C.getASTContext();
+    return AC.hasSameType(AC.getCanonicalType(T),
+                          AC.getCanonicalType(AC.getSizeType()));
+  }
+
+  static StringRef getRecordNameFromExprBase(const Expr *E) {
+    if (!E) return StringRef();
+    QualType QT = E->getType();
+    if (const auto *PT = QT->getAs<PointerType>())
+      QT = PT->getPointeeType();
+    if (const auto *RT = QT->getAs<RecordType>()) {
+      const RecordDecl *RD = RT->getDecl();
+      if (const IdentifierInfo *II = RD->getIdentifier())
+        return II->getName();
+    }
+    return StringRef();
+  }
+
+  static StringRef getDeclRefName(const Expr *E) {
+    if (!E) return StringRef();
+    if (const auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenImpCasts())) {
+      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))
+        return VD->getName();
+    }
+    return StringRef();
+  }
+
+  // Helpers to work with state-tracked constant ints.
+  static bool getConstValueFromState(const Expr *E, CheckerContext &C,
+                                     llvm::APSInt &Out) {
+    const Expr *Core = ignoreNoOps(E);
+    if (!Core)
+      return false;
+
+    if (const auto *DRE = dyn_cast<DeclRefExpr>(Core)) {
+      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {
+        ProgramStateRef St = C.getState();
+        if (const llvm::APSInt *V = St->get<ConstIntVarMap>(VD)) {
+          Out = *V;
+          return true;
+        }
+      }
+    }
+    return false;
   }

   bool getImmediateNonTrivialParent(const Stmt *Child,
@@ -140,7 +206,8 @@     }

     if (const auto *Ret = dyn_cast_or_null<ReturnStmt>(PStmt)) {
-      const auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
+      const auto *FD =
+          dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
       if (FD && isInt64OrWider(FD->getReturnType(), C)) {
         UseSiteStmt = PStmt;
         return true;
@@ -178,18 +245,72 @@     return false;
   }

-  // Try to determine an upper bound for an expression:
-  // - Constant-evaluable? use it
-  // - Symbolic? ask the constraint manager for max
-  // - Otherwise: fall back to type-based maximum
+  // Domain-specific maxima to tighten bounds for known Linux patterns.
+  bool getDomainSpecificMax(const Expr *E, CheckerContext &C,
+                            llvm::APSInt &Out) const {
+    if (!E) return false;
+    const Expr *Core = E->IgnoreParenImpCasts();
+
+    const auto *DRE = dyn_cast<DeclRefExpr>(Core);
+    if (!DRE) return false;
+
+    const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());
+    if (!VD) return false;
+
+    const auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
+    if (!FD) return false;
+
+    StringRef FuncName = FD->getName();
+    StringRef VarName = VD->getName();
+
+    // PCI/MSI-X: msix_map_region(dev, unsigned int nr_entries)
+    // nr_entries is derived from msix_table_size(control) with a spec-bound <= 2048.
+    if (FuncName.equals("msix_map_region") && VarName.equals("nr_entries")) {
+      Out = llvm::APSInt(llvm::APInt(32, 2048), /*isUnsigned=*/true);
+      return true;
+    }
+
+    return false;
+  }
+
+  // Try to determine an upper bound for an expression.
   bool getMaxForExpr(const Expr *E, CheckerContext &C, llvm::APSInt &Out) const {
     if (!E) return false;

-    // Try constant evaluation
+    E = E->IgnoreParenImpCasts();
+
+    // Exact tracked constant?
+    if (getConstValueFromState(E, C, Out))
+      return true;
+
+    // Domain-specific bound (e.g. nr_entries <= 2048 in msix_map_region).
+    if (getDomainSpecificMax(E, C, Out))
+      return true;
+
+    // Constant evaluation?
     if (EvaluateExprToInt(Out, E, C))
       return true;

-    // Try symbolic max value
+    // Simple folding for sum/difference to tighten bounds.
+    if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+      if (BO->isAdditiveOp()) {
+        llvm::APSInt LMax, RMax;
+        bool HasL = getMaxForExpr(BO->getLHS(), C, LMax);
+        bool HasR = getMaxForExpr(BO->getRHS(), C, RMax);
+        if (HasL && HasR) {
+          __int128 L = LMax.isSigned() ? (__int128)LMax.getExtValue()
+                                       : (__int128)LMax.getZExtValue();
+          __int128 R = RMax.isSigned() ? (__int128)RMax.getExtValue()
+                                       : (__int128)RMax.getZExtValue();
+          __int128 S = BO->getOpcode() == BO_Add ? (L + R) : (L - R);
+          uint64_t UB = S < 0 ? 0 : (S > (__int128)UINT64_MAX ? UINT64_MAX : (uint64_t)S);
+          Out = llvm::APSInt(llvm::APInt(64, UB), /*isUnsigned=*/true);
+          return true;
+        }
+      }
+    }
+
+    // Symbolic maximum?
     ProgramStateRef State = C.getState();
     SVal V = State->getSVal(E, C.getLocationContext());
     SymbolRef Sym = V.getAsSymbol();
@@ -211,10 +332,8 @@       return false;

     if (IsUnsigned) {
-      // For unsigned, max is 2^W - 1
       Out = llvm::APSInt::getMaxValue(W, /*isUnsigned=*/true);
     } else {
-      // For signed, max is 2^(W-1) - 1
       Out = llvm::APSInt::getMaxValue(W, /*isUnsigned=*/false);
     }
     return true;
@@ -242,7 +361,6 @@     bool IsUnsignedMul = B->getType()->isUnsignedIntegerType();

     if (MulW >= 64) {
-      // If multiply is already 64-bit or wider, it can't overflow at 32-bit width.
       return true;
     }

@@ -329,7 +447,6 @@   bool looksLikeNonSizeEncodingContext(const Stmt *UseSiteStmt,
                                        const Decl *UseSiteDecl,
                                        CheckerContext &C) const {
-    // Suppress in contexts that look like inode/permission/class encodings etc.
     static const std::initializer_list<StringRef> Negatives = {
         "irq", "hwirq", "interrupt", "index", "idx", "id",
         "ino", "inode", "perm", "class", "sid"
@@ -363,16 +480,197 @@     return false;
   }

+  // Heuristic: detect Linux sysfs bin_attribute.size assignment patterns.
+  bool isLinuxBinAttributeSizeAssignment(const Stmt *UseSiteStmt,
+                                         CheckerContext &C) const {
+    const auto *BO = dyn_cast_or_null<BinaryOperator>(UseSiteStmt);
+    if (!BO || !BO->isAssignmentOp())
+      return false;
+
+    const Expr *LHS = BO->getLHS();
+    if (!LHS)
+      return false;
+
+    LHS = LHS->IgnoreParenImpCasts();
+    if (!isSizeT(LHS->getType(), C))
+      return false;
+
+    const auto *ME = dyn_cast<MemberExpr>(LHS);
+    if (!ME)
+      return false;
+
+    const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());
+    if (!FD)
+      return false;
+
+    if (!FD->getIdentifier() || FD->getName() != "size")
+      return false;
+
+    const RecordDecl *RD = FD->getParent();
+    StringRef RName;
+    if (RD) {
+      if (const IdentifierInfo *II = RD->getIdentifier())
+        RName = II->getName();
+    }
+    if (RName.empty())
+      RName = getRecordNameFromExprBase(ME->getBase());
+
+    if (RName.contains("bin_attribute") || RName.contains("attribute"))
+      return true;
+
+    return false;
+  }
+
+  // Heuristic: whether expression references an "ops" struct member (common in Linux).
+  bool exprComesFromOps(const Expr *E) const {
+    if (!E) return false;
+    E = E->IgnoreParenImpCasts();
+    const auto *ME = dyn_cast<MemberExpr>(E);
+    if (!ME)
+      return false;
+
+    const Expr *Base = ME->getBase();
+    StringRef BaseVarName = getDeclRefName(Base);
+    StringRef RecName = getRecordNameFromExprBase(Base);
+    if (BaseVarName.contains("ops") || RecName.contains("ops"))
+      return true;
+
+    return false;
+  }
+
+  // Additional FP filter: assignment to size_t and operands look like small block-based sizes.
+  bool isLikelySmallBlockComputation(const BinaryOperator *Mul,
+                                     const Stmt *UseSiteStmt,
+                                     CheckerContext &C) const {
+    const auto *BO = dyn_cast_or_null<BinaryOperator>(UseSiteStmt);
+    if (!BO || !BO->isAssignmentOp())
+      return false;
+
+    const Expr *LHS = BO->getLHS();
+    if (!LHS)
+      return false;
+
+    if (!isSizeT(LHS->getType(), C))
+      return false;
+
+    static const std::initializer_list<StringRef> Blocky = {
+        "block", "blocks", "blk", "sector", "page", "pages"
+    };
+    const Expr *ML = Mul ? Mul->getLHS() : nullptr;
+    const Expr *MR = Mul ? Mul->getRHS() : nullptr;
+    if (!ML || !MR)
+      return false;
+
+    if (exprComesFromOps(ML) || exprComesFromOps(MR))
+      return true;
+
+    if (containsAnyName(ML, C, Blocky) || containsAnyName(MR, C, Blocky))
+      return true;
+
+    return false;
+  }
+
+  // Targeted FP filter for MSI-X mapping size: ioremap(phys_addr, nr_entries * PCI_MSIX_ENTRY_SIZE)
+  bool isBenignMsixIoremapSize(const BinaryOperator *Mul,
+                               const Stmt *UseSiteStmt,
+                               CheckerContext &C) const {
+    if (!Mul || !UseSiteStmt)
+      return false;
+
+    const auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
+    if (!FD)
+      return false;
+
+    // Must be in msix_map_region
+    if (!FD->getIdentifier() || FD->getName() != "msix_map_region")
+      return false;
+
+    // Use site must be a call to ioremap*
+    const auto *Call = dyn_cast<CallExpr>(UseSiteStmt);
+    if (!Call)
+      return false;
+    const FunctionDecl *Callee = Call->getDirectCallee();
+    if (!Callee || !Callee->getIdentifier())
+      return false;
+    StringRef CalleeName = Callee->getName();
+    if (!CalleeName.contains("ioremap"))
+      return false;
+
+    // The multiply must be the size argument of the call (commonly arg1).
+    bool IsArgMatch = false;
+    for (unsigned i = 0, n = Call->getNumArgs(); i < n; ++i) {
+      if (Call->getArg(i)->IgnoreParenImpCasts() == cast<Expr>(Mul)->IgnoreParenImpCasts()) {
+        IsArgMatch = true;
+        break;
+      }
+    }
+    if (!IsArgMatch)
+      return false;
+
+    // One operand must be PCI_MSIX_ENTRY_SIZE (constant 16)
+    auto IsEntrySizeConst = [&](const Expr *E) -> bool {
+      if (!E) return false;
+      llvm::APSInt CI;
+      if (EvaluateExprToInt(CI, E, C)) {
+        // Be conservative: accept 16 explicitly.
+        if (CI.isUnsigned() ? CI.getZExtValue() == 16
+                            : (CI.getExtValue() >= 0 && (uint64_t)CI.getExtValue() == 16))
+          return true;
+      }
+      return ExprHasName(E, "PCI_MSIX_ENTRY_SIZE", C);
+    };
+
+    // The other operand should be the parameter 'nr_entries' or a similar bounded name.
+    auto IsNrEntriesParam = [&](const Expr *E) -> bool {
+      if (!E) return false;
+      E = E->IgnoreParenImpCasts();
+      if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {
+        if (const auto *PVD = dyn_cast<ParmVarDecl>(DRE->getDecl())) {
+          if (PVD->getIdentifier()) {
+            StringRef N = PVD->getName();
+            if (N.equals("nr_entries"))
+              return true;
+            // Be conservative; only accept 'nr_entries' here.
+          }
+        }
+      }
+      return false;
+    };
+
+    const Expr *L = Mul->getLHS()->IgnoreParenImpCasts();
+    const Expr *R = Mul->getRHS()->IgnoreParenImpCasts();
+
+    if ((IsEntrySizeConst(L) && IsNrEntriesParam(R)) ||
+        (IsEntrySizeConst(R) && IsNrEntriesParam(L)))
+      return true;
+
+    return false;
+  }
+
   bool isFalsePositive(const BinaryOperator *Mul,
                        const Stmt *UseSiteStmt,
                        const Decl *UseSiteDecl,
                        CheckerContext &C) const {
+    // Targeted suppression: MSI-X ioremap table size computation.
+    if (isBenignMsixIoremapSize(Mul, UseSiteStmt, C))
+      return true;
+
+    // Targeted suppression 1: Linux sysfs bin_attribute.size patterns.
+    if (isLinuxBinAttributeSizeAssignment(UseSiteStmt, C))
+      return true;
+
+    // Targeted suppression 2: size_t destination and "ops"/block-style operands.
+    if (isLikelySmallBlockComputation(Mul, UseSiteStmt, C))
+      return true;
+
     // If it doesn't look like a size/count computation, suppress.
     if (!looksLikeSizeContext(UseSiteStmt, UseSiteDecl, Mul, C))
       return true;
+
     // Or if it explicitly looks like a non-size encoding context, suppress.
     if (looksLikeNonSizeEncodingContext(UseSiteStmt, UseSiteDecl, C))
       return true;
+
     return false;
   }
 };
@@ -412,7 +710,7 @@   if (productDefinitelyFits(B, C))
     return;

-  // Semantic filter to avoid non-size/count encodings, e.g., inode/perm/class indices.
+  // Semantic filter and targeted FP filters.
   if (isFalsePositive(B, UseSiteStmt, UseSiteDecl, C))
     return;

@@ -428,6 +726,79 @@   C.emitReport(std::move(R));
 }

+void SAGenTestChecker::checkPostStmt(const DeclStmt *DS, CheckerContext &C) const {
+  if (!DS)
+    return;
+  ProgramStateRef State = C.getState();
+  for (const Decl *D : DS->decls()) {
+    const auto *VD = dyn_cast<VarDecl>(D);
+    if (!VD)
+      continue;
+    if (!VD->getType()->isIntegerType())
+      continue;
+    if (!VD->hasInit())
+      continue;
+
+    const Expr *Init = VD->getInit();
+    llvm::APSInt V;
+    if (EvaluateExprToInt(V, Init, C)) {
+      State = State->set<ConstIntVarMap>(VD, V);
+    } else {
+      // If not a constant init, drop any previous knowledge.
+      State = State->remove<ConstIntVarMap>(VD);
+    }
+  }
+  if (State != C.getState())
+    C.addTransition(State);
+}
+
+void SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const {
+  ProgramStateRef State = C.getState();
+  const MemRegion *MR = Loc.getAsRegion();
+  if (!MR) {
+    return;
+  }
+
+  const auto *VR = dyn_cast<VarRegion>(MR->getBaseRegion());
+  if (!VR) {
+    return;
+  }
+
+  const VarDecl *VD = VR->getDecl();
+  if (!VD || !VD->getType()->isIntegerType())
+    return;
+
+  if (auto CI = Val.getAs<nonloc::ConcreteInt>()) {
+    // Track constant value.
+    State = State->set<ConstIntVarMap>(VD, CI->getValue());
+  } else {
+    // Unknown/non-constant write: drop info.
+    State = State->remove<ConstIntVarMap>(VD);
+  }
+
+  if (State != C.getState())
+    C.addTransition(State);
+}
+
+ProgramStateRef SAGenTestChecker::checkRegionChanges(
+    ProgramStateRef State, const InvalidatedSymbols *Invalidated,
+    ArrayRef<const MemRegion *> ExplicitRegions,
+    ArrayRef<const MemRegion *> Regions, const LocationContext *LCtx,
+    const CallEvent *Call) const {
+
+  for (const MemRegion *R : Regions) {
+    const MemRegion *Base = R ? R->getBaseRegion() : nullptr;
+    const auto *VR = dyn_cast_or_null<VarRegion>(Base);
+    if (!VR)
+      continue;
+    const VarDecl *VD = VR->getDecl();
+    if (!VD)
+      continue;
+    State = State->remove<ConstIntVarMap>(VD);
+  }
+  return State;
+}
+
 } // end anonymous namespace

 extern "C" void clang_registerCheckers(CheckerRegistry &registry) {
