--- attempt_1_original.cpp+++ attempt_1.cpp@@ -25,6 +25,20 @@ using namespace ento;
 using namespace taint;

+// Utility functions provided in the prompt (assumed available):
+template <typename T>
+const T* findSpecificTypeInParents(const Stmt *S, CheckerContext &C);
+template <typename T>
+const T* findSpecificTypeInChildren(const Stmt *S);
+bool EvaluateExprToInt(llvm::APSInt &EvalRes, const Expr *expr, CheckerContext &C);
+const llvm::APSInt *inferSymbolMaxVal(SymbolRef Sym, CheckerContext &C);
+bool getArraySizeFromExpr(llvm::APInt &ArraySize, const Expr *E);
+bool getStringSize(llvm::APInt &StringSize, const Expr *E);
+const MemRegion* getMemRegionFromExpr(const Expr* E, CheckerContext &C);
+bool functionKnownToDeref(const CallEvent &Call,
+                          llvm::SmallVectorImpl<unsigned> &DerefParams);
+bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C);
+
 // No custom program state needed.

 namespace {
@@ -40,7 +54,6 @@   void checkPostStmt(const BinaryOperator *B, CheckerContext &C) const;

 private:
-  // Helpers
   static unsigned getIntWidth(QualType T, CheckerContext &C) {
     return C.getASTContext().getIntWidth(T);
   }
@@ -54,66 +67,121 @@     return E->getType()->isIntegerType();
   }

-  // Determine if the expression result is used in a 64-bit integer context.
-  bool isWidenedUseTo64(const Expr *E, CheckerContext &C) const {
-    if (!E) return false;
-
-    // 1) Look for an implicit cast to 64-bit integer.
-    if (const auto *ICE = findSpecificTypeInParents<ImplicitCastExpr>(E, C)) {
-      QualType DestTy = ICE->getType();
-      if (isInt64OrWider(DestTy, C))
-        return true;
-    }
-
-    // 2) Look for a C-style cast to 64-bit
-    if (const auto *CS = findSpecificTypeInParents<CStyleCastExpr>(E, C)) {
+  static bool isNoOpWrapper(const Stmt *S) {
+    return isa<ParenExpr>(S) || isa<ImplicitCastExpr>(S);
+  }
+
+  bool getImmediateNonTrivialParent(const Stmt *Child,
+                                    CheckerContext &C,
+                                    const Stmt *&OutParentStmt,
+                                    const Decl *&OutParentDecl) const {
+    OutParentStmt = nullptr;
+    OutParentDecl = nullptr;
+    if (!Child)
+      return false;
+
+    const Stmt *Cur = Child;
+    while (true) {
+      auto Parents = C.getASTContext().getParents(*Cur);
+      if (Parents.empty())
+        return false;
+
+      const Stmt *PS = Parents[0].get<Stmt>();
+      const Decl *PD = Parents[0].get<Decl>();
+
+      if (PS) {
+        if (isNoOpWrapper(PS)) {
+          Cur = PS;
+          continue;
+        }
+        OutParentStmt = PS;
+        return true;
+      } else if (PD) {
+        OutParentDecl = PD;
+        return true;
+      } else {
+        return false;
+      }
+    }
+  }
+
+  bool isDirectWidenedUseTo64(const Expr *Mul,
+                              CheckerContext &C,
+                              const Stmt *&UseSiteStmt,
+                              const Decl *&UseSiteDecl) const {
+    UseSiteStmt = nullptr;
+    UseSiteDecl = nullptr;
+    if (!Mul)
+      return false;
+
+    const Stmt *PStmt = nullptr;
+    const Decl *PDecl = nullptr;
+    if (!getImmediateNonTrivialParent(Mul, C, PStmt, PDecl))
+      return false;
+
+    if (const auto *BO = dyn_cast_or_null<BinaryOperator>(PStmt)) {
+      if (!BO->isAssignmentOp())
+        return false;
+      const Expr *LHS = BO->getLHS();
+      if (LHS && isInt64OrWider(LHS->getType(), C)) {
+        UseSiteStmt = PStmt;
+        return true;
+      }
+      return false;
+    }
+
+    if (const auto *CS = dyn_cast_or_null<CStyleCastExpr>(PStmt)) {
       QualType DestTy = CS->getTypeAsWritten();
-      if (isInt64OrWider(DestTy, C))
-        return true;
-    }
-
-    // 3) Look for assignment where LHS is 64-bit
-    if (const auto *PAssn = findSpecificTypeInParents<BinaryOperator>(E, C)) {
-      if (PAssn->isAssignmentOp()) {
-        const Expr *LHS = PAssn->getLHS();
-        if (LHS && isInt64OrWider(LHS->getType(), C))
-          return true;
-      }
-    }
-
-    // 4) Look for return statement where function returns 64-bit
-    if (findSpecificTypeInParents<ReturnStmt>(E, C)) {
-      const auto *D = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
-      if (D) {
-        QualType RetTy = D->getReturnType();
-        if (isInt64OrWider(RetTy, C))
-          return true;
-      }
-    }
-
-    // 5) Look for function call argument where the parameter is 64-bit
-    if (const auto *Call = findSpecificTypeInParents<CallExpr>(E, C)) {
+      if (isInt64OrWider(DestTy, C)) {
+        UseSiteStmt = PStmt;
+        return true;
+      }
+      return false;
+    }
+
+    if (const auto *Ret = dyn_cast_or_null<ReturnStmt>(PStmt)) {
+      const auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
+      if (FD && isInt64OrWider(FD->getReturnType(), C)) {
+        UseSiteStmt = PStmt;
+        return true;
+      }
+      return false;
+    }
+
+    if (const auto *Call = dyn_cast_or_null<CallExpr>(PStmt)) {
       const FunctionDecl *FD = Call->getDirectCallee();
       if (!FD)
         return false;
+
       for (unsigned i = 0, n = Call->getNumArgs(); i < n && i < FD->getNumParams(); ++i) {
-        const Expr *Arg = Call->getArg(i);
-        if (!Arg)
-          continue;
-        const Expr *ArgCore = Arg->IgnoreParenImpCasts();
-        const Expr *ECore = E->IgnoreParenImpCasts();
-        if (ArgCore == ECore) {
+        const Expr *Arg = Call->getArg(i)->IgnoreParenImpCasts();
+        const Expr *MulCore = Mul->IgnoreParenImpCasts();
+        if (Arg == MulCore) {
           QualType ParamTy = FD->getParamDecl(i)->getType();
-          if (isInt64OrWider(ParamTy, C))
+          if (isInt64OrWider(ParamTy, C)) {
+            UseSiteStmt = PStmt;
             return true;
+          }
         }
       }
-    }
-
-    return false;
-  }
-
-  // Try to get the maximum possible value of an expression.
+      return false;
+    }
+
+    if (const auto *VD = dyn_cast_or_null<VarDecl>(PDecl)) {
+      if (isInt64OrWider(VD->getType(), C)) {
+        UseSiteDecl = PDecl;
+        return true;
+      }
+      return false;
+    }
+
+    return false;
+  }
+
+  // Try to determine an upper bound for an expression:
+  // - Constant-evaluable? use it
+  // - Symbolic? ask the constraint manager for max
+  // - Otherwise: fall back to type-based maximum
   bool getMaxForExpr(const Expr *E, CheckerContext &C, llvm::APSInt &Out) const {
     if (!E) return false;

@@ -125,17 +193,34 @@     ProgramStateRef State = C.getState();
     SVal V = State->getSVal(E, C.getLocationContext());
     SymbolRef Sym = V.getAsSymbol();
-    if (!Sym)
-      return false;
-
-    if (const llvm::APSInt *MaxV = inferSymbolMaxVal(Sym, C)) {
-      Out = *MaxV;
-      return true;
-    }
-    return false;
-  }
-
-  // Check if we can prove the product fits into the narrow type; if yes, suppress.
+    if (Sym) {
+      if (const llvm::APSInt *MaxV = inferSymbolMaxVal(Sym, C)) {
+        Out = *MaxV;
+        return true;
+      }
+    }
+
+    // Fallback: type-based maximum
+    QualType QT = E->getType();
+    if (!QT->isIntegerType())
+      return false;
+
+    unsigned W = getIntWidth(QT, C);
+    bool IsUnsigned = QT->isUnsignedIntegerType();
+    if (W == 0)
+      return false;
+
+    if (IsUnsigned) {
+      // For unsigned, max is 2^W - 1
+      Out = llvm::APSInt::getMaxValue(W, /*isUnsigned=*/true);
+    } else {
+      // For signed, max is 2^(W-1) - 1
+      Out = llvm::APSInt::getMaxValue(W, /*isUnsigned=*/false);
+    }
+    return true;
+  }
+
+  // Check if we can prove the product fits into the narrower arithmetic width.
   bool productDefinitelyFits(const BinaryOperator *B, CheckerContext &C) const {
     if (!B) return false;
     const Expr *LHS = B->getLHS();
@@ -147,34 +232,149 @@     if (!getMaxForExpr(LHS, C, MaxL) || !getMaxForExpr(RHS, C, MaxR))
       return false; // Can't prove, so not definitely safe.

-    // Compute product with 128-bit headroom using unsigned math.
-    uint64_t ML = MaxL.getZExtValue();
-    uint64_t MR = MaxR.getZExtValue();
-    __uint128_t Prod = ( (__uint128_t)ML ) * ( (__uint128_t)MR );
-
-    // Determine limit for the narrow type (result type of the multiply).
+    // Compute conservatively using 128-bit.
+    uint64_t ML = MaxL.isSigned() ? (uint64_t)MaxL.getExtValue() : MaxL.getZExtValue();
+    uint64_t MR = MaxR.isSigned() ? (uint64_t)MaxR.getExtValue() : MaxR.getZExtValue();
+    __uint128_t Prod = ((__uint128_t)ML) * ((__uint128_t)MR);
+
+    // Determine limit for the arithmetic type of the multiply.
     unsigned MulW = getIntWidth(B->getType(), C);
-    bool IsUnsigned = B->getType()->isUnsignedIntegerType();
+    bool IsUnsignedMul = B->getType()->isUnsignedIntegerType();
+
+    if (MulW >= 64) {
+      // If multiply is already 64-bit or wider, it can't overflow at 32-bit width.
+      return true;
+    }
+
     __uint128_t Limit;
-    if (IsUnsigned) {
-      if (MulW >= 64) {
-        // If multiply is already 64-bit or more (should not be here), treat as safe.
-        return true;
-      }
+    if (IsUnsignedMul) {
       Limit = (((__uint128_t)1) << MulW) - 1;
     } else {
-      if (MulW == 0)
-        return false;
-      if (MulW >= 64) {
-        // As above, treat as safe (won't reach in typical flow).
-        return true;
-      }
       // Signed max: 2^(W-1) - 1
       Limit = (((__uint128_t)1) << (MulW - 1)) - 1;
     }

     return Prod <= Limit;
   }
+
+  bool containsAnyName(const Expr *E, CheckerContext &C,
+                       std::initializer_list<StringRef> Needles) const {
+    if (!E) return false;
+    for (StringRef N : Needles) {
+      if (ExprHasName(E, N, C))
+        return true;
+    }
+    return false;
+  }
+
+  bool containsAnyNameInString(StringRef S,
+                               std::initializer_list<StringRef> Needles) const {
+    for (StringRef N : Needles) {
+      if (S.contains(N))
+        return true;
+    }
+    return false;
+  }
+
+  bool looksLikeSizeContext(const Stmt *UseSiteStmt,
+                            const Decl *UseSiteDecl,
+                            const BinaryOperator *Mul,
+                            CheckerContext &C) const {
+    static const std::initializer_list<StringRef> Positives = {
+        "size", "len", "length", "count", "num", "bytes", "capacity", "total", "sz"
+    };
+    if (const auto *BO = dyn_cast_or_null<BinaryOperator>(UseSiteStmt)) {
+      if (BO->isAssignmentOp()) {
+        const Expr *LHS = BO->getLHS();
+        if (LHS && containsAnyName(LHS, C, Positives))
+          return true;
+      }
+    }
+    if (const auto *VD = dyn_cast_or_null<VarDecl>(UseSiteDecl)) {
+      if (containsAnyNameInString(VD->getName(), Positives))
+        return true;
+    }
+    if (const auto *Ret = dyn_cast_or_null<ReturnStmt>(UseSiteStmt)) {
+      if (const auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl())) {
+        if (containsAnyNameInString(FD->getName(), Positives))
+          return true;
+      }
+      if (Mul) {
+        if (containsAnyName(Mul->getLHS(), C, Positives) ||
+            containsAnyName(Mul->getRHS(), C, Positives))
+          return true;
+      }
+    }
+    if (const auto *Call = dyn_cast_or_null<CallExpr>(UseSiteStmt)) {
+      if (const FunctionDecl *FD = Call->getDirectCallee()) {
+        for (unsigned i = 0, n = Call->getNumArgs(); i < n && i < FD->getNumParams(); ++i) {
+          const Expr *Arg = Call->getArg(i)->IgnoreParenImpCasts();
+          const Expr *MulCore = Mul ? Mul->IgnoreParenImpCasts() : nullptr;
+          if (Arg == MulCore) {
+            StringRef PName = FD->getParamDecl(i)->getName();
+            if (containsAnyNameInString(PName, Positives))
+              return true;
+          }
+        }
+      }
+    }
+    if (Mul) {
+      if (containsAnyName(Mul->getLHS(), C, Positives) ||
+          containsAnyName(Mul->getRHS(), C, Positives))
+        return true;
+    }
+    return false;
+  }
+
+  bool looksLikeNonSizeEncodingContext(const Stmt *UseSiteStmt,
+                                       const Decl *UseSiteDecl,
+                                       CheckerContext &C) const {
+    // Suppress in contexts that look like inode/permission/class encodings etc.
+    static const std::initializer_list<StringRef> Negatives = {
+        "irq", "hwirq", "interrupt", "index", "idx", "id",
+        "ino", "inode", "perm", "class", "sid"
+    };
+    if (const auto *BO = dyn_cast_or_null<BinaryOperator>(UseSiteStmt)) {
+      if (BO->isAssignmentOp() && BO->getLHS()) {
+        if (containsAnyName(BO->getLHS(), C, Negatives))
+          return true;
+      }
+    }
+    if (const auto *VD = dyn_cast_or_null<VarDecl>(UseSiteDecl)) {
+      if (containsAnyNameInString(VD->getName(), Negatives))
+        return true;
+    }
+    if (const auto *Ret = dyn_cast_or_null<ReturnStmt>(UseSiteStmt)) {
+      if (const auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl())) {
+        if (containsAnyNameInString(FD->getName(), Negatives))
+          return true;
+      }
+    }
+    if (const auto *Call = dyn_cast_or_null<CallExpr>(UseSiteStmt)) {
+      if (const FunctionDecl *FD = Call->getDirectCallee()) {
+        if (containsAnyNameInString(FD->getName(), Negatives))
+          return true;
+        for (const ParmVarDecl *P : FD->parameters()) {
+          if (containsAnyNameInString(P->getName(), Negatives))
+            return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  bool isFalsePositive(const BinaryOperator *Mul,
+                       const Stmt *UseSiteStmt,
+                       const Decl *UseSiteDecl,
+                       CheckerContext &C) const {
+    // If it doesn't look like a size/count computation, suppress.
+    if (!looksLikeSizeContext(UseSiteStmt, UseSiteDecl, Mul, C))
+      return true;
+    // Or if it explicitly looks like a non-size encoding context, suppress.
+    if (looksLikeNonSizeEncodingContext(UseSiteStmt, UseSiteDecl, C))
+      return true;
+    return false;
+  }
 };

 void SAGenTestChecker::checkPostStmt(const BinaryOperator *B, CheckerContext &C) const {
@@ -187,6 +387,10 @@   if (!B->getType()->isIntegerType())
     return;

+  // Require both operands to be integer-typed.
+  if (!isIntegerType(B->getLHS()) || !isIntegerType(B->getRHS()))
+    return;
+
   // The multiply's arithmetic width (after integer promotions).
   unsigned MulWidth = getIntWidth(B->getType(), C);

@@ -194,23 +398,24 @@   if (MulWidth >= 64)
     return;

-  // Ensure operands are integer-typed as well.
-  if (!isIntegerType(B->getLHS()) || !isIntegerType(B->getRHS()))
-    return;
-
-  // Is the result used in 64-bit integer context?
+  // Is the multiply directly used in a 64-bit integer context?
   const Expr *E = dyn_cast<Expr>(B);
   if (!E)
     return;

-  if (!isWidenedUseTo64(E, C))
-    return;
-
-  // Optional reduction: if we can prove product fits in the narrow type, don't warn.
+  const Stmt *UseSiteStmt = nullptr;
+  const Decl *UseSiteDecl = nullptr;
+  if (!isDirectWidenedUseTo64(E, C, UseSiteStmt, UseSiteDecl))
+    return;
+
+  // If we can prove the product fits in the narrow arithmetic width, suppress.
   if (productDefinitelyFits(B, C))
     return;

-  // Report: multiplication in 32-bit (or narrower) that is widened to 64-bit.
+  // Semantic filter to avoid non-size/count encodings, e.g., inode/perm/class indices.
+  if (isFalsePositive(B, UseSiteStmt, UseSiteDecl, C))
+    return;
+
   ExplodedNode *N = C.generateNonFatalErrorNode();
   if (!N)
     return;
