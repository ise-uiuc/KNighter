### Report Summary

File:| /scratch/chenyuan-data/linux-debug/sound/usb/line6/driver.c
---|---
Warning:| line 608, column 37
32-bit multiply widens to 64-bit after overflow; cast an operand to 64-bit
before the multiply

### Annotated Source Code


550   | {
551   |  struct usb_line6 *line6 = hw->private_data;
552   |
553   | 	line6->messages.active = 0;
554   |
555   |  return 0;
556   | }
557   |
558   | /* Read from circular buffer, return to user */
559   | static long
560   | line6_hwdep_read(struct snd_hwdep *hwdep, char __user *buf, long count,
561   | 					loff_t *offset)
562   | {
563   |  struct usb_line6 *line6 = hwdep->private_data;
564   |  long rv = 0;
565   |  unsigned int out_count;
566   |
567   |  if (mutex_lock_interruptible(&line6->messages.read_lock))
568   |  return -ERESTARTSYS;
569   |
570   |  while (kfifo_len(&line6->messages.fifo) == 0) {
571   | 		mutex_unlock(&line6->messages.read_lock);
572   |
573   |  if (line6->messages.nonblock)
574   |  return -EAGAIN;
575   |
576   | 		rv = wait_event_interruptible(
577   |  line6->messages.wait_queue,
578   |  kfifo_len(&line6->messages.fifo) != 0);
579   |  if (rv < 0)
580   |  return rv;
581   |
582   |  if (mutex_lock_interruptible(&line6->messages.read_lock))
583   |  return -ERESTARTSYS;
584   | 	}
585   |
586   |  if (kfifo_peek_len(&line6->messages.fifo) > count) {
587   |  /* Buffer too small; allow re-read of the current item... */
588   | 		rv = -EINVAL;
589   | 	} else {
590   | 		rv = kfifo_to_user(&line6->messages.fifo, buf, count, &out_count);
591   |  if (rv == 0)
592   | 			rv = out_count;
593   | 	}
594   |
595   | 	mutex_unlock(&line6->messages.read_lock);
596   |  return rv;
597   | }
598   |
599   | /* Write directly (no buffering) to device by user*/
600   | static long
601   | line6_hwdep_write(struct snd_hwdep *hwdep, const char __user *data, long count,
602   | 					loff_t *offset)
603   | {
604   |  struct usb_line6 *line6 = hwdep->private_data;
605   |  int rv;
606   |  char *data_copy;
607   |
608   |  if (count > line6->max_packet_size * LINE6_RAW_MESSAGES_MAXCOUNT) {
    32-bit multiply widens to 64-bit after overflow; cast an operand to 64-bit before the multiply
609   |  /* This is an arbitrary limit - still better than nothing... */
610   |  return -EINVAL;
611   | 	}
612   |
613   | 	data_copy = memdup_user(data, count);
614   |  if (IS_ERR(data_copy))
615   |  return PTR_ERR(data_copy);
616   |
617   | 	rv = line6_send_raw_message(line6, data_copy, count);
618   |
619   | 	kfree(data_copy);
620   |  return rv;
621   | }
622   |
623   | static __poll_t
624   | line6_hwdep_poll(struct snd_hwdep *hwdep, struct file *file, poll_table *wait)
625   | {
626   | 	__poll_t rv;
627   |  struct usb_line6 *line6 = hwdep->private_data;
628   |
629   | 	poll_wait(file, &line6->messages.wait_queue, wait);
630   |
631   |  mutex_lock(&line6->messages.read_lock);
632   | 	rv = kfifo_len(&line6->messages.fifo) == 0 ? 0 : EPOLLIN | EPOLLRDNORM;
633   | 	mutex_unlock(&line6->messages.read_lock);
634   |
635   |  return rv;
636   | }
637   |
638   | static const struct snd_hwdep_ops hwdep_ops = {
