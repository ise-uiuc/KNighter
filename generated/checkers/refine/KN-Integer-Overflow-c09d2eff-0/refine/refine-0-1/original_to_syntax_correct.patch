--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -25,7 +25,16 @@ using namespace ento;
 using namespace taint;

-// No custom program state needed.
+// Utility functions from the prompt are assumed to be available in the TU:
+// - findSpecificTypeInParents<T>
+// - findSpecificTypeInChildren<T>
+// - EvaluateExprToInt
+// - inferSymbolMaxVal
+// - getArraySizeFromExpr
+// - getStringSize
+// - getMemRegionFromExpr
+// - functionKnownToDeref
+// - ExprHasName

 namespace {

@@ -54,6 +63,36 @@     return E->getType()->isIntegerType();
   }

+  static QualType getPrePromotionType(const Expr *E) {
+    // We want the declared type prior to integral promotions/implicit casts.
+    // IgnoreParenImpCasts peels off implicit promotions and yields the
+    // underlying expression, whose type is the pre-promotion type.
+    const Expr *Core = E ? E->IgnoreParenImpCasts() : nullptr;
+    return Core ? Core->getType() : QualType();
+  }
+
+  static bool getMaxFromIntegerType(QualType T, CheckerContext &C,
+                                    llvm::APSInt &Out) {
+    if (T.isNull() || !T->isIntegerType())
+      return false;
+
+    unsigned W = getIntWidth(T, C);
+    if (W == 0)
+      return false;
+
+    bool IsUnsigned = T->isUnsignedIntegerType();
+    // Construct APSInt with appropriate bit width and sign.
+    llvm::APInt MaxAP;
+    if (IsUnsigned) {
+      MaxAP = llvm::APInt::getMaxValue(W); // (2^W - 1)
+    } else {
+      // Signed max:  2^(W-1) - 1
+      MaxAP = llvm::APInt::getSignedMaxValue(W);
+    }
+    Out = llvm::APSInt(MaxAP, IsUnsigned);
+    return true;
+  }
+
   // Determine if the expression result is used in a 64-bit integer context.
   bool isWidenedUseTo64(const Expr *E, CheckerContext &C) const {
     if (!E) return false;
@@ -65,14 +104,14 @@         return true;
     }

-    // 2) Look for a C-style cast to 64-bit
+    // 2) Look for a C-style cast to 64-bit.
     if (const auto *CS = findSpecificTypeInParents<CStyleCastExpr>(E, C)) {
       QualType DestTy = CS->getTypeAsWritten();
       if (isInt64OrWider(DestTy, C))
         return true;
     }

-    // 3) Look for assignment where LHS is 64-bit
+    // 3) Look for assignment where LHS is 64-bit.
     if (const auto *PAssn = findSpecificTypeInParents<BinaryOperator>(E, C)) {
       if (PAssn->isAssignmentOp()) {
         const Expr *LHS = PAssn->getLHS();
@@ -81,9 +120,10 @@       }
     }

-    // 4) Look for return statement where function returns 64-bit
+    // 4) Look for return statement where function returns 64-bit.
     if (findSpecificTypeInParents<ReturnStmt>(E, C)) {
-      const auto *D = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
+      const auto *D =
+          dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
       if (D) {
         QualType RetTy = D->getReturnType();
         if (isInt64OrWider(RetTy, C))
@@ -91,7 +131,7 @@       }
     }

-    // 5) Look for function call argument where the parameter is 64-bit
+    // 5) Look for function call argument where the parameter is 64-bit.
     if (const auto *Call = findSpecificTypeInParents<CallExpr>(E, C)) {
       const FunctionDecl *FD = Call->getDirectCallee();
       if (!FD)
@@ -114,6 +154,11 @@   }

   // Try to get the maximum possible value of an expression.
+  // Strategy:
+  // 1) Constant evaluate.
+  // 2) Ask constraint manager for symbolic max bound (if any).
+  // 3) FALLBACK: derive a conservative bound from the expression's declared
+  //    integer type prior to promotions (eliminates FPs when e.g. a u16 field).
   bool getMaxForExpr(const Expr *E, CheckerContext &C, llvm::APSInt &Out) const {
     if (!E) return false;

@@ -125,13 +170,20 @@     ProgramStateRef State = C.getState();
     SVal V = State->getSVal(E, C.getLocationContext());
     SymbolRef Sym = V.getAsSymbol();
-    if (!Sym)
-      return false;
-
-    if (const llvm::APSInt *MaxV = inferSymbolMaxVal(Sym, C)) {
-      Out = *MaxV;
-      return true;
-    }
+    if (Sym) {
+      if (const llvm::APSInt *MaxV = inferSymbolMaxVal(Sym, C)) {
+        Out = *MaxV;
+        return true;
+      }
+    }
+
+    // Fallback: derive from the pre-promotion declared type.
+    QualType DeclTy = getPrePromotionType(E);
+    if (!DeclTy.isNull() && DeclTy->isIntegerType()) {
+      if (getMaxFromIntegerType(DeclTy, C, Out))
+        return true;
+    }
+
     return false;
   }

@@ -155,25 +207,32 @@     // Determine limit for the narrow type (result type of the multiply).
     unsigned MulW = getIntWidth(B->getType(), C);
     bool IsUnsigned = B->getType()->isUnsignedIntegerType();
+
+    // If arithmetic is already >= 64-bit, it's safe for this checker.
+    if (MulW >= 64)
+      return true;
+
     __uint128_t Limit;
     if (IsUnsigned) {
-      if (MulW >= 64) {
-        // If multiply is already 64-bit or more (should not be here), treat as safe.
-        return true;
-      }
+      if (MulW == 0) return false;
       Limit = (((__uint128_t)1) << MulW) - 1;
     } else {
-      if (MulW == 0)
+      if (MulW <= 1) {
+        // 1-bit signed integer can't represent positive products meaningfully,
+        // conservatively say it doesn't fit.
         return false;
-      if (MulW >= 64) {
-        // As above, treat as safe (won't reach in typical flow).
-        return true;
       }
       // Signed max: 2^(W-1) - 1
       Limit = (((__uint128_t)1) << (MulW - 1)) - 1;
     }

     return Prod <= Limit;
+  }
+
+  // Additional gate to avoid warning in benign contexts where we can prove no overflow.
+  bool isFalsePositive(const BinaryOperator *B, CheckerContext &C) const {
+    // Currently, simply defer to productDefinitelyFits().
+    return productDefinitelyFits(B, C);
   }
 };

@@ -206,8 +265,8 @@   if (!isWidenedUseTo64(E, C))
     return;

-  // Optional reduction: if we can prove product fits in the narrow type, don't warn.
-  if (productDefinitelyFits(B, C))
+  // Suppress if we can prove the product fits in the narrow type (e.g., due to u16 operand).
+  if (isFalsePositive(B, C))
     return;

   // Report: multiplication in 32-bit (or narrower) that is widened to 64-bit.
