### Report Summary

File:| /scratch/chenyuan-data/linux-debug/drivers/misc/sgi-xp/xpc_uv.c
---|---
Warning:| line 1045, column 21
32-bit multiply widens to 64-bit after overflow; cast an operand to 64-bit
before the multiply

### Annotated Source Code


984   |
985   | static u64
986   | xpc_get_chctl_all_flags_uv(struct xpc_partition *part)
987   | {
988   |  unsigned long irq_flags;
989   |  union xpc_channel_ctl_flags chctl;
990   |
991   |  spin_lock_irqsave(&part->chctl_lock, irq_flags);
992   | 	chctl = part->chctl;
993   |  if (chctl.all_flags != 0)
994   | 		part->chctl.all_flags = 0;
995   |
996   | 	spin_unlock_irqrestore(&part->chctl_lock, irq_flags);
997   |  return chctl.all_flags;
998   | }
999   |
1000  | static enum xp_retval
1001  | xpc_allocate_send_msg_slot_uv(struct xpc_channel *ch)
1002  | {
1003  |  struct xpc_channel_uv *ch_uv = &ch->sn.uv;
1004  |  struct xpc_send_msg_slot_uv *msg_slot;
1005  |  unsigned long irq_flags;
1006  |  int nentries;
1007  |  int entry;
1008  | 	size_t nbytes;
1009  |
1010  |  for (nentries = ch->local_nentries; nentries > 0; nentries--) {
1011  | 		nbytes = nentries * sizeof(struct xpc_send_msg_slot_uv);
1012  | 		ch_uv->send_msg_slots = kzalloc(nbytes, GFP_KERNEL);
1013  |  if (ch_uv->send_msg_slots == NULL)
1014  |  continue;
1015  |
1016  |  for (entry = 0; entry < nentries; entry++) {
1017  | 			msg_slot = &ch_uv->send_msg_slots[entry];
1018  |
1019  | 			msg_slot->msg_slot_number = entry;
1020  | 			xpc_put_fifo_entry_uv(&ch_uv->msg_slot_free_list,
1021  | 					      &msg_slot->next);
1022  | 		}
1023  |
1024  |  spin_lock_irqsave(&ch->lock, irq_flags);
1025  |  if (nentries < ch->local_nentries)
1026  | 			ch->local_nentries = nentries;
1027  | 		spin_unlock_irqrestore(&ch->lock, irq_flags);
1028  |  return xpSuccess;
1029  | 	}
1030  |
1031  |  return xpNoMemory;
1032  | }
1033  |
1034  | static enum xp_retval
1035  | xpc_allocate_recv_msg_slot_uv(struct xpc_channel *ch)
1036  | {
1037  |  struct xpc_channel_uv *ch_uv = &ch->sn.uv;
1038  |  struct xpc_notify_mq_msg_uv *msg_slot;
1039  |  unsigned long irq_flags;
1040  |  int nentries;
1041  |  int entry;
1042  | 	size_t nbytes;
1043  |
1044  |  for (nentries = ch->remote_nentries; nentries > 0; nentries--) {
    6←Assuming 'nentries' is > 0→
    7←Loop condition is true.  Entering loop body→
1045  |  nbytes = nentries * ch->entry_size;
    8←32-bit multiply widens to 64-bit after overflow; cast an operand to 64-bit before the multiply
1046  | 		ch_uv->recv_msg_slots = kzalloc(nbytes, GFP_KERNEL);
1047  |  if (ch_uv->recv_msg_slots == NULL)
1048  |  continue;
1049  |
1050  |  for (entry = 0; entry < nentries; entry++) {
1051  | 			msg_slot = ch_uv->recv_msg_slots +
1052  | 			    entry * ch->entry_size;
1053  |
1054  | 			msg_slot->hdr.msg_slot_number = entry;
1055  | 		}
1056  |
1057  |  spin_lock_irqsave(&ch->lock, irq_flags);
1058  |  if (nentries < ch->remote_nentries)
1059  | 			ch->remote_nentries = nentries;
1060  | 		spin_unlock_irqrestore(&ch->lock, irq_flags);
1061  |  return xpSuccess;
1062  | 	}
1063  |
1064  |  return xpNoMemory;
1065  | }
1066  |
1067  | /*
1068  |  * Allocate msg_slots associated with the channel.
1069  |  */
1070  | static enum xp_retval
1071  | xpc_setup_msg_structures_uv(struct xpc_channel *ch)
1072  | {
1073  |  static enum xp_retval ret;
1074  |  struct xpc_channel_uv *ch_uv = &ch->sn.uv;
1075  |
1076  | 	DBUG_ON(ch->flags & XPC_C_SETUP);
1077  |
1078  | 	ch_uv->cached_notify_gru_mq_desc = kmalloc(sizeof(struct
1079  | 						   gru_message_queue_desc),
1080  |  GFP_KERNEL);
1081  |  if (ch_uv->cached_notify_gru_mq_desc == NULL)
    1Assuming field 'cached_notify_gru_mq_desc' is not equal to NULL→
    2←Taking false branch→
1082  |  return xpNoMemory;
1083  |
1084  |  ret = xpc_allocate_send_msg_slot_uv(ch);
1085  |  if (ret == xpSuccess) {
    3←Assuming 'ret' is equal to xpSuccess→
    4←Taking true branch→
1086  |
1087  |  ret = xpc_allocate_recv_msg_slot_uv(ch);
    5←Calling 'xpc_allocate_recv_msg_slot_uv'→
1088  |  if (ret != xpSuccess) {
1089  | 			kfree(ch_uv->send_msg_slots);
1090  | 			xpc_init_fifo_uv(&ch_uv->msg_slot_free_list);
1091  | 		}
1092  | 	}
1093  |  return ret;
1094  | }
1095  |
1096  | /*
1097  |  * Free up msg_slots and clear other stuff that were setup for the specified
1098  |  * channel.
1099  |  */
1100  | static void
1101  | xpc_teardown_msg_structures_uv(struct xpc_channel *ch)
1102  | {
1103  |  struct xpc_channel_uv *ch_uv = &ch->sn.uv;
1104  |
1105  |  lockdep_assert_held(&ch->lock);
1106  |
1107  | 	kfree(ch_uv->cached_notify_gru_mq_desc);
1108  | 	ch_uv->cached_notify_gru_mq_desc = NULL;
1109  |
1110  |  if (ch->flags & XPC_C_SETUP) {
1111  | 		xpc_init_fifo_uv(&ch_uv->msg_slot_free_list);
1112  | 		kfree(ch_uv->send_msg_slots);
1113  | 		xpc_init_fifo_uv(&ch_uv->recv_msg_list);
1114  | 		kfree(ch_uv->recv_msg_slots);
1115  | 	}
1116  | }
1117  |
