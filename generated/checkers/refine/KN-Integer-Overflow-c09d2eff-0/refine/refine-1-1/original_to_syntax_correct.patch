--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -39,8 +39,6 @@                           llvm::SmallVectorImpl<unsigned> &DerefParams);
 bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C);

-// No custom program state needed.
-
 namespace {

 class SAGenTestChecker : public Checker<check::PostStmt<BinaryOperator>> {
@@ -180,27 +178,32 @@
   // Try to determine an upper bound for an expression:
   // - Constant-evaluable? use it
+  // - Concrete store value? use it
   // - Symbolic? ask the constraint manager for max
   // - Otherwise: fall back to type-based maximum
   bool getMaxForExpr(const Expr *E, CheckerContext &C, llvm::APSInt &Out) const {
     if (!E) return false;

-    // Try constant evaluation
+    // Try constant evaluation (AST-level constant).
     if (EvaluateExprToInt(Out, E, C))
       return true;

-    // Try symbolic max value
-    ProgramStateRef State = C.getState();
-    SVal V = State->getSVal(E, C.getLocationContext());
-    SymbolRef Sym = V.getAsSymbol();
-    if (Sym) {
+    // Try to read a concrete value from the current program state.
+    SVal V = C.getSVal(E);
+    if (auto CI = V.getAs<nonloc::ConcreteInt>()) {
+      Out = CI->getValue();
+      return true;
+    }
+
+    // Try symbolic max value.
+    if (SymbolRef Sym = V.getAsSymbol()) {
       if (const llvm::APSInt *MaxV = inferSymbolMaxVal(Sym, C)) {
         Out = *MaxV;
         return true;
       }
     }

-    // Fallback: type-based maximum
+    // Fallback: type-based maximum.
     QualType QT = E->getType();
     if (!QT->isIntegerType())
       return false;
@@ -211,10 +214,8 @@       return false;

     if (IsUnsigned) {
-      // For unsigned, max is 2^W - 1
       Out = llvm::APSInt::getMaxValue(W, /*isUnsigned=*/true);
     } else {
-      // For signed, max is 2^(W-1) - 1
       Out = llvm::APSInt::getMaxValue(W, /*isUnsigned=*/false);
     }
     return true;
@@ -233,8 +234,10 @@       return false; // Can't prove, so not definitely safe.

     // Compute conservatively using 128-bit.
-    uint64_t ML = MaxL.isSigned() ? (uint64_t)MaxL.getExtValue() : MaxL.getZExtValue();
-    uint64_t MR = MaxR.isSigned() ? (uint64_t)MaxR.getExtValue() : MaxR.getZExtValue();
+    uint64_t ML = MaxL.isUnsigned() ? MaxL.getZExtValue()
+                                    : static_cast<uint64_t>(MaxL.getExtValue());
+    uint64_t MR = MaxR.isUnsigned() ? MaxR.getZExtValue()
+                                    : static_cast<uint64_t>(MaxR.getExtValue());
     __uint128_t Prod = ((__uint128_t)ML) * ((__uint128_t)MR);

     // Determine limit for the arithmetic type of the multiply.
