--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -25,6 +25,20 @@ using namespace ento;
 using namespace taint;

+// Utility functions provided in the prompt (assumed available):
+template <typename T>
+const T* findSpecificTypeInParents(const Stmt *S, CheckerContext &C);
+template <typename T>
+const T* findSpecificTypeInChildren(const Stmt *S);
+bool EvaluateExprToInt(llvm::APSInt &EvalRes, const Expr *expr, CheckerContext &C);
+const llvm::APSInt *inferSymbolMaxVal(SymbolRef Sym, CheckerContext &C);
+bool getArraySizeFromExpr(llvm::APInt &ArraySize, const Expr *E);
+bool getStringSize(llvm::APInt &StringSize, const Expr *E);
+const MemRegion* getMemRegionFromExpr(const Expr* E, CheckerContext &C);
+bool functionKnownToDeref(const CallEvent &Call,
+                          llvm::SmallVectorImpl<unsigned> &DerefParams);
+bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C);
+
 // No custom program state needed.

 namespace {
@@ -54,60 +68,122 @@     return E->getType()->isIntegerType();
   }

-  // Determine if the expression result is used in a 64-bit integer context.
-  bool isWidenedUseTo64(const Expr *E, CheckerContext &C) const {
-    if (!E) return false;
-
-    // 1) Look for an implicit cast to 64-bit integer.
-    if (const auto *ICE = findSpecificTypeInParents<ImplicitCastExpr>(E, C)) {
-      QualType DestTy = ICE->getType();
-      if (isInt64OrWider(DestTy, C))
-        return true;
-    }
-
-    // 2) Look for a C-style cast to 64-bit
-    if (const auto *CS = findSpecificTypeInParents<CStyleCastExpr>(E, C)) {
+  // Returns true if S is a no-op wrapper we can ignore when looking up the parent.
+  static bool isNoOpWrapper(const Stmt *S) {
+    return isa<ParenExpr>(S) || isa<ImplicitCastExpr>(S);
+  }
+
+  // Extract the immediate non-trivial parent of a statement, skipping parens/implicit casts.
+  // Returns true and sets OutParentStmt or OutParentDecl if found, otherwise false.
+  bool getImmediateNonTrivialParent(const Stmt *Child,
+                                    CheckerContext &C,
+                                    const Stmt *&OutParentStmt,
+                                    const Decl *&OutParentDecl) const {
+    OutParentStmt = nullptr;
+    OutParentDecl = nullptr;
+    if (!Child)
+      return false;
+
+    const Stmt *Cur = Child;
+    while (true) {
+      auto Parents = C.getASTContext().getParents(*Cur);
+      if (Parents.empty())
+        return false;
+
+      // Pick the first parent (the AST should provide a single structural parent here).
+      const Stmt *PS = Parents[0].get<Stmt>();
+      const Decl *PD = Parents[0].get<Decl>();
+
+      if (PS) {
+        if (isNoOpWrapper(PS)) {
+          Cur = PS;
+          continue; // keep skipping trivial wrappers
+        }
+        OutParentStmt = PS;
+        return true;
+      } else if (PD) {
+        OutParentDecl = PD;
+        return true;
+      } else {
+        return false;
+      }
+    }
+  }
+
+  // Check if the multiply is used directly (without intervening non-trivial ops)
+  // in a 64-bit integer context. If yes, return true and optionally expose the
+  // use site node/decl.
+  bool isDirectWidenedUseTo64(const Expr *Mul,
+                              CheckerContext &C,
+                              const Stmt *&UseSiteStmt,
+                              const Decl *&UseSiteDecl) const {
+    UseSiteStmt = nullptr;
+    UseSiteDecl = nullptr;
+    if (!Mul)
+      return false;
+
+    const Stmt *PStmt = nullptr;
+    const Decl *PDecl = nullptr;
+    if (!getImmediateNonTrivialParent(Mul, C, PStmt, PDecl))
+      return false;
+
+    if (const auto *BO = dyn_cast_or_null<BinaryOperator>(PStmt)) {
+      if (!BO->isAssignmentOp())
+        return false;
+      const Expr *LHS = BO->getLHS();
+      if (LHS && isInt64OrWider(LHS->getType(), C)) {
+        UseSiteStmt = PStmt;
+        return true;
+      }
+      return false;
+    }
+
+    if (const auto *CS = dyn_cast_or_null<CStyleCastExpr>(PStmt)) {
       QualType DestTy = CS->getTypeAsWritten();
-      if (isInt64OrWider(DestTy, C))
-        return true;
-    }
-
-    // 3) Look for assignment where LHS is 64-bit
-    if (const auto *PAssn = findSpecificTypeInParents<BinaryOperator>(E, C)) {
-      if (PAssn->isAssignmentOp()) {
-        const Expr *LHS = PAssn->getLHS();
-        if (LHS && isInt64OrWider(LHS->getType(), C))
-          return true;
-      }
-    }
-
-    // 4) Look for return statement where function returns 64-bit
-    if (findSpecificTypeInParents<ReturnStmt>(E, C)) {
-      const auto *D = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
-      if (D) {
-        QualType RetTy = D->getReturnType();
-        if (isInt64OrWider(RetTy, C))
-          return true;
-      }
-    }
-
-    // 5) Look for function call argument where the parameter is 64-bit
-    if (const auto *Call = findSpecificTypeInParents<CallExpr>(E, C)) {
+      if (isInt64OrWider(DestTy, C)) {
+        UseSiteStmt = PStmt;
+        return true;
+      }
+      return false;
+    }
+
+    if (const auto *Ret = dyn_cast_or_null<ReturnStmt>(PStmt)) {
+      const auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
+      if (FD && isInt64OrWider(FD->getReturnType(), C)) {
+        UseSiteStmt = PStmt;
+        return true;
+      }
+      return false;
+    }
+
+    if (const auto *Call = dyn_cast_or_null<CallExpr>(PStmt)) {
       const FunctionDecl *FD = Call->getDirectCallee();
       if (!FD)
         return false;
+
+      // The immediate non-trivial parent is the call.
+      // Ensure the multiply is directly used as the argument (not nested in further ops).
       for (unsigned i = 0, n = Call->getNumArgs(); i < n && i < FD->getNumParams(); ++i) {
-        const Expr *Arg = Call->getArg(i);
-        if (!Arg)
-          continue;
-        const Expr *ArgCore = Arg->IgnoreParenImpCasts();
-        const Expr *ECore = E->IgnoreParenImpCasts();
-        if (ArgCore == ECore) {
+        const Expr *Arg = Call->getArg(i)->IgnoreParenImpCasts();
+        const Expr *MulCore = Mul->IgnoreParenImpCasts();
+        if (Arg == MulCore) {
           QualType ParamTy = FD->getParamDecl(i)->getType();
-          if (isInt64OrWider(ParamTy, C))
+          if (isInt64OrWider(ParamTy, C)) {
+            UseSiteStmt = PStmt;
             return true;
+          }
         }
       }
+      return false;
+    }
+
+    if (const auto *VD = dyn_cast_or_null<VarDecl>(PDecl)) {
+      // Directly initializing a variable?
+      if (isInt64OrWider(VD->getType(), C)) {
+        UseSiteDecl = PDecl;
+        return true;
+      }
+      return false;
     }

     return false;
@@ -175,6 +251,129 @@
     return Prod <= Limit;
   }
+
+  // Heuristics to identify "size-like" and "irq-like" names.
+  bool containsAnyName(const Expr *E, CheckerContext &C,
+                       std::initializer_list<StringRef> Needles) const {
+    if (!E) return false;
+    for (StringRef N : Needles) {
+      if (ExprHasName(E, N, C))
+        return true;
+    }
+    return false;
+  }
+
+  bool containsAnyNameInString(StringRef S,
+                               std::initializer_list<StringRef> Needles) const {
+    for (StringRef N : Needles) {
+      if (S.contains(N))
+        return true;
+    }
+    return false;
+  }
+
+  bool looksLikeSizeContext(const Stmt *UseSiteStmt,
+                            const Decl *UseSiteDecl,
+                            const BinaryOperator *Mul,
+                            CheckerContext &C) const {
+    static const std::initializer_list<StringRef> Positives = {
+        "size", "len", "length", "count", "num", "bytes", "capacity", "total", "sz"
+    };
+    // Prefer strong evidence on the destination side.
+    if (const auto *BO = dyn_cast_or_null<BinaryOperator>(UseSiteStmt)) {
+      if (BO->isAssignmentOp()) {
+        const Expr *LHS = BO->getLHS();
+        if (LHS && containsAnyName(LHS, C, Positives))
+          return true;
+      }
+    }
+    if (const auto *VD = dyn_cast_or_null<VarDecl>(UseSiteDecl)) {
+      if (containsAnyNameInString(VD->getName(), Positives))
+        return true;
+    }
+    if (const auto *Ret = dyn_cast_or_null<ReturnStmt>(UseSiteStmt)) {
+      // If returning, check function name or operands for size hints.
+      if (const auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl())) {
+        if (containsAnyNameInString(FD->getName(), Positives))
+          return true;
+      }
+      // Otherwise check operands themselves for size/count semantics.
+      if (Mul) {
+        if (containsAnyName(Mul->getLHS(), C, Positives) ||
+            containsAnyName(Mul->getRHS(), C, Positives))
+          return true;
+      }
+    }
+    if (const auto *Call = dyn_cast_or_null<CallExpr>(UseSiteStmt)) {
+      if (const FunctionDecl *FD = Call->getDirectCallee()) {
+        // Find whether the multiply is used as a direct 64-bit param whose name suggests size/count.
+        for (unsigned i = 0, n = Call->getNumArgs(); i < n && i < FD->getNumParams(); ++i) {
+          const Expr *Arg = Call->getArg(i)->IgnoreParenImpCasts();
+          const Expr *MulCore = Mul ? Mul->IgnoreParenImpCasts() : nullptr;
+          if (Arg == MulCore) {
+            StringRef PName = FD->getParamDecl(i)->getName();
+            if (containsAnyNameInString(PName, Positives))
+              return true;
+          }
+        }
+      }
+    }
+    // Fallback: if either operand looks size-like, accept.
+    if (Mul) {
+      if (containsAnyName(Mul->getLHS(), C, Positives) ||
+          containsAnyName(Mul->getRHS(), C, Positives))
+        return true;
+    }
+    return false;
+  }
+
+  bool looksLikeIrqContext(const Stmt *UseSiteStmt,
+                           const Decl *UseSiteDecl,
+                           CheckerContext &C) const {
+    static const std::initializer_list<StringRef> Negatives = {
+        "irq", "hwirq", "interrupt", "index", "idx", "id"
+    };
+    if (const auto *BO = dyn_cast_or_null<BinaryOperator>(UseSiteStmt)) {
+      if (BO->isAssignmentOp() && BO->getLHS()) {
+        if (containsAnyName(BO->getLHS(), C, Negatives))
+          return true;
+      }
+    }
+    if (const auto *VD = dyn_cast_or_null<VarDecl>(UseSiteDecl)) {
+      if (containsAnyNameInString(VD->getName(), Negatives))
+        return true;
+    }
+    if (const auto *Ret = dyn_cast_or_null<ReturnStmt>(UseSiteStmt)) {
+      if (const auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl())) {
+        if (containsAnyNameInString(FD->getName(), Negatives))
+          return true;
+      }
+    }
+    if (const auto *Call = dyn_cast_or_null<CallExpr>(UseSiteStmt)) {
+      if (const FunctionDecl *FD = Call->getDirectCallee()) {
+        if (containsAnyNameInString(FD->getName(), Negatives))
+          return true;
+        for (const ParmVarDecl *P : FD->parameters()) {
+          if (containsAnyNameInString(P->getName(), Negatives))
+            return true;
+        }
+      }
+    }
+    return false;
+  }
+
+  // Decide if this is a false positive based on context heuristics.
+  bool isFalsePositive(const BinaryOperator *Mul,
+                       const Stmt *UseSiteStmt,
+                       const Decl *UseSiteDecl,
+                       CheckerContext &C) const {
+    // Suppress if not a size-like context or looks explicitly IRQ-like.
+    if (!looksLikeSizeContext(UseSiteStmt, UseSiteDecl, Mul, C))
+      return true;
+    if (looksLikeIrqContext(UseSiteStmt, UseSiteDecl, C))
+      return true;
+    return false;
+  }
 };

 void SAGenTestChecker::checkPostStmt(const BinaryOperator *B, CheckerContext &C) const {
@@ -187,6 +386,10 @@   if (!B->getType()->isIntegerType())
     return;

+  // Require both operands to be integer-typed.
+  if (!isIntegerType(B->getLHS()) || !isIntegerType(B->getRHS()))
+    return;
+
   // The multiply's arithmetic width (after integer promotions).
   unsigned MulWidth = getIntWidth(B->getType(), C);

@@ -194,20 +397,22 @@   if (MulWidth >= 64)
     return;

-  // Ensure operands are integer-typed as well.
-  if (!isIntegerType(B->getLHS()) || !isIntegerType(B->getRHS()))
-    return;
-
-  // Is the result used in 64-bit integer context?
+  // Is the multiply directly used in a 64-bit integer context?
   const Expr *E = dyn_cast<Expr>(B);
   if (!E)
     return;

-  if (!isWidenedUseTo64(E, C))
+  const Stmt *UseSiteStmt = nullptr;
+  const Decl *UseSiteDecl = nullptr;
+  if (!isDirectWidenedUseTo64(E, C, UseSiteStmt, UseSiteDecl))
     return;

   // Optional reduction: if we can prove product fits in the narrow type, don't warn.
   if (productDefinitelyFits(B, C))
+    return;
+
+  // Semantic filter to avoid non-size/count like usages (e.g., IRQ computation).
+  if (isFalsePositive(B, UseSiteStmt, UseSiteDecl, C))
     return;

   // Report: multiplication in 32-bit (or narrower) that is widened to 64-bit.
