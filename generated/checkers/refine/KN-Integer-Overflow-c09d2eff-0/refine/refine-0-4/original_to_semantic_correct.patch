--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -54,7 +54,6 @@   void checkPostStmt(const BinaryOperator *B, CheckerContext &C) const;

 private:
-  // Helpers
   static unsigned getIntWidth(QualType T, CheckerContext &C) {
     return C.getASTContext().getIntWidth(T);
   }
@@ -68,13 +67,10 @@     return E->getType()->isIntegerType();
   }

-  // Returns true if S is a no-op wrapper we can ignore when looking up the parent.
   static bool isNoOpWrapper(const Stmt *S) {
     return isa<ParenExpr>(S) || isa<ImplicitCastExpr>(S);
   }

-  // Extract the immediate non-trivial parent of a statement, skipping parens/implicit casts.
-  // Returns true and sets OutParentStmt or OutParentDecl if found, otherwise false.
   bool getImmediateNonTrivialParent(const Stmt *Child,
                                     CheckerContext &C,
                                     const Stmt *&OutParentStmt,
@@ -90,14 +86,13 @@       if (Parents.empty())
         return false;

-      // Pick the first parent (the AST should provide a single structural parent here).
       const Stmt *PS = Parents[0].get<Stmt>();
       const Decl *PD = Parents[0].get<Decl>();

       if (PS) {
         if (isNoOpWrapper(PS)) {
           Cur = PS;
-          continue; // keep skipping trivial wrappers
+          continue;
         }
         OutParentStmt = PS;
         return true;
@@ -110,9 +105,6 @@     }
   }

-  // Check if the multiply is used directly (without intervening non-trivial ops)
-  // in a 64-bit integer context. If yes, return true and optionally expose the
-  // use site node/decl.
   bool isDirectWidenedUseTo64(const Expr *Mul,
                               CheckerContext &C,
                               const Stmt *&UseSiteStmt,
@@ -161,8 +153,6 @@       if (!FD)
         return false;

-      // The immediate non-trivial parent is the call.
-      // Ensure the multiply is directly used as the argument (not nested in further ops).
       for (unsigned i = 0, n = Call->getNumArgs(); i < n && i < FD->getNumParams(); ++i) {
         const Expr *Arg = Call->getArg(i)->IgnoreParenImpCasts();
         const Expr *MulCore = Mul->IgnoreParenImpCasts();
@@ -178,7 +168,6 @@     }

     if (const auto *VD = dyn_cast_or_null<VarDecl>(PDecl)) {
-      // Directly initializing a variable?
       if (isInt64OrWider(VD->getType(), C)) {
         UseSiteDecl = PDecl;
         return true;
@@ -189,7 +178,10 @@     return false;
   }

-  // Try to get the maximum possible value of an expression.
+  // Try to determine an upper bound for an expression:
+  // - Constant-evaluable? use it
+  // - Symbolic? ask the constraint manager for max
+  // - Otherwise: fall back to type-based maximum
   bool getMaxForExpr(const Expr *E, CheckerContext &C, llvm::APSInt &Out) const {
     if (!E) return false;

@@ -201,17 +193,34 @@     ProgramStateRef State = C.getState();
     SVal V = State->getSVal(E, C.getLocationContext());
     SymbolRef Sym = V.getAsSymbol();
-    if (!Sym)
-      return false;
-
-    if (const llvm::APSInt *MaxV = inferSymbolMaxVal(Sym, C)) {
-      Out = *MaxV;
-      return true;
-    }
-    return false;
-  }
-
-  // Check if we can prove the product fits into the narrow type; if yes, suppress.
+    if (Sym) {
+      if (const llvm::APSInt *MaxV = inferSymbolMaxVal(Sym, C)) {
+        Out = *MaxV;
+        return true;
+      }
+    }
+
+    // Fallback: type-based maximum
+    QualType QT = E->getType();
+    if (!QT->isIntegerType())
+      return false;
+
+    unsigned W = getIntWidth(QT, C);
+    bool IsUnsigned = QT->isUnsignedIntegerType();
+    if (W == 0)
+      return false;
+
+    if (IsUnsigned) {
+      // For unsigned, max is 2^W - 1
+      Out = llvm::APSInt::getMaxValue(W, /*isUnsigned=*/true);
+    } else {
+      // For signed, max is 2^(W-1) - 1
+      Out = llvm::APSInt::getMaxValue(W, /*isUnsigned=*/false);
+    }
+    return true;
+  }
+
+  // Check if we can prove the product fits into the narrower arithmetic width.
   bool productDefinitelyFits(const BinaryOperator *B, CheckerContext &C) const {
     if (!B) return false;
     const Expr *LHS = B->getLHS();
@@ -223,28 +232,24 @@     if (!getMaxForExpr(LHS, C, MaxL) || !getMaxForExpr(RHS, C, MaxR))
       return false; // Can't prove, so not definitely safe.

-    // Compute product with 128-bit headroom using unsigned math.
-    uint64_t ML = MaxL.getZExtValue();
-    uint64_t MR = MaxR.getZExtValue();
-    __uint128_t Prod = ( (__uint128_t)ML ) * ( (__uint128_t)MR );
-
-    // Determine limit for the narrow type (result type of the multiply).
+    // Compute conservatively using 128-bit.
+    uint64_t ML = MaxL.isSigned() ? (uint64_t)MaxL.getExtValue() : MaxL.getZExtValue();
+    uint64_t MR = MaxR.isSigned() ? (uint64_t)MaxR.getExtValue() : MaxR.getZExtValue();
+    __uint128_t Prod = ((__uint128_t)ML) * ((__uint128_t)MR);
+
+    // Determine limit for the arithmetic type of the multiply.
     unsigned MulW = getIntWidth(B->getType(), C);
-    bool IsUnsigned = B->getType()->isUnsignedIntegerType();
+    bool IsUnsignedMul = B->getType()->isUnsignedIntegerType();
+
+    if (MulW >= 64) {
+      // If multiply is already 64-bit or wider, it can't overflow at 32-bit width.
+      return true;
+    }
+
     __uint128_t Limit;
-    if (IsUnsigned) {
-      if (MulW >= 64) {
-        // If multiply is already 64-bit or more (should not be here), treat as safe.
-        return true;
-      }
+    if (IsUnsignedMul) {
       Limit = (((__uint128_t)1) << MulW) - 1;
     } else {
-      if (MulW == 0)
-        return false;
-      if (MulW >= 64) {
-        // As above, treat as safe (won't reach in typical flow).
-        return true;
-      }
       // Signed max: 2^(W-1) - 1
       Limit = (((__uint128_t)1) << (MulW - 1)) - 1;
     }
@@ -252,7 +257,6 @@     return Prod <= Limit;
   }

-  // Heuristics to identify "size-like" and "irq-like" names.
   bool containsAnyName(const Expr *E, CheckerContext &C,
                        std::initializer_list<StringRef> Needles) const {
     if (!E) return false;
@@ -279,7 +283,6 @@     static const std::initializer_list<StringRef> Positives = {
         "size", "len", "length", "count", "num", "bytes", "capacity", "total", "sz"
     };
-    // Prefer strong evidence on the destination side.
     if (const auto *BO = dyn_cast_or_null<BinaryOperator>(UseSiteStmt)) {
       if (BO->isAssignmentOp()) {
         const Expr *LHS = BO->getLHS();
@@ -292,12 +295,10 @@         return true;
     }
     if (const auto *Ret = dyn_cast_or_null<ReturnStmt>(UseSiteStmt)) {
-      // If returning, check function name or operands for size hints.
       if (const auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl())) {
         if (containsAnyNameInString(FD->getName(), Positives))
           return true;
       }
-      // Otherwise check operands themselves for size/count semantics.
       if (Mul) {
         if (containsAnyName(Mul->getLHS(), C, Positives) ||
             containsAnyName(Mul->getRHS(), C, Positives))
@@ -306,7 +307,6 @@     }
     if (const auto *Call = dyn_cast_or_null<CallExpr>(UseSiteStmt)) {
       if (const FunctionDecl *FD = Call->getDirectCallee()) {
-        // Find whether the multiply is used as a direct 64-bit param whose name suggests size/count.
         for (unsigned i = 0, n = Call->getNumArgs(); i < n && i < FD->getNumParams(); ++i) {
           const Expr *Arg = Call->getArg(i)->IgnoreParenImpCasts();
           const Expr *MulCore = Mul ? Mul->IgnoreParenImpCasts() : nullptr;
@@ -318,7 +318,6 @@         }
       }
     }
-    // Fallback: if either operand looks size-like, accept.
     if (Mul) {
       if (containsAnyName(Mul->getLHS(), C, Positives) ||
           containsAnyName(Mul->getRHS(), C, Positives))
@@ -327,11 +326,13 @@     return false;
   }

-  bool looksLikeIrqContext(const Stmt *UseSiteStmt,
-                           const Decl *UseSiteDecl,
-                           CheckerContext &C) const {
+  bool looksLikeNonSizeEncodingContext(const Stmt *UseSiteStmt,
+                                       const Decl *UseSiteDecl,
+                                       CheckerContext &C) const {
+    // Suppress in contexts that look like inode/permission/class encodings etc.
     static const std::initializer_list<StringRef> Negatives = {
-        "irq", "hwirq", "interrupt", "index", "idx", "id"
+        "irq", "hwirq", "interrupt", "index", "idx", "id",
+        "ino", "inode", "perm", "class", "sid"
     };
     if (const auto *BO = dyn_cast_or_null<BinaryOperator>(UseSiteStmt)) {
       if (BO->isAssignmentOp() && BO->getLHS()) {
@@ -362,15 +363,15 @@     return false;
   }

-  // Decide if this is a false positive based on context heuristics.
   bool isFalsePositive(const BinaryOperator *Mul,
                        const Stmt *UseSiteStmt,
                        const Decl *UseSiteDecl,
                        CheckerContext &C) const {
-    // Suppress if not a size-like context or looks explicitly IRQ-like.
+    // If it doesn't look like a size/count computation, suppress.
     if (!looksLikeSizeContext(UseSiteStmt, UseSiteDecl, Mul, C))
       return true;
-    if (looksLikeIrqContext(UseSiteStmt, UseSiteDecl, C))
+    // Or if it explicitly looks like a non-size encoding context, suppress.
+    if (looksLikeNonSizeEncodingContext(UseSiteStmt, UseSiteDecl, C))
       return true;
     return false;
   }
@@ -407,15 +408,14 @@   if (!isDirectWidenedUseTo64(E, C, UseSiteStmt, UseSiteDecl))
     return;

-  // Optional reduction: if we can prove product fits in the narrow type, don't warn.
+  // If we can prove the product fits in the narrow arithmetic width, suppress.
   if (productDefinitelyFits(B, C))
     return;

-  // Semantic filter to avoid non-size/count like usages (e.g., IRQ computation).
+  // Semantic filter to avoid non-size/count encodings, e.g., inode/perm/class indices.
   if (isFalsePositive(B, UseSiteStmt, UseSiteDecl, C))
     return;

-  // Report: multiplication in 32-bit (or narrower) that is widened to 64-bit.
   ExplodedNode *N = C.generateNonFatalErrorNode();
   if (!N)
     return;
