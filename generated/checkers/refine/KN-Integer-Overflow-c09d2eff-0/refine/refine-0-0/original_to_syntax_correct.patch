--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -25,7 +25,18 @@ using namespace ento;
 using namespace taint;

-// No custom program state needed.
+// Utility functions provided by the user context.
+template <typename T>
+const T* findSpecificTypeInParents(const Stmt *S, CheckerContext &C);
+
+template <typename T>
+const T* findSpecificTypeInChildren(const Stmt *S);
+
+bool EvaluateExprToInt(llvm::APSInt &EvalRes, const Expr *expr, CheckerContext &C);
+const llvm::APSInt *inferSymbolMaxVal(SymbolRef Sym, CheckerContext &C);
+bool getArraySizeFromExpr(llvm::APInt &ArraySize, const Expr *E);
+bool getStringSize(llvm::APInt &StringSize, const Expr *E);
+const MemRegion* getMemRegionFromExpr(const Expr* E, CheckerContext &C);

 namespace {

@@ -54,63 +65,107 @@     return E->getType()->isIntegerType();
   }

-  // Determine if the expression result is used in a 64-bit integer context.
-  bool isWidenedUseTo64(const Expr *E, CheckerContext &C) const {
-    if (!E) return false;
-
-    // 1) Look for an implicit cast to 64-bit integer.
-    if (const auto *ICE = findSpecificTypeInParents<ImplicitCastExpr>(E, C)) {
-      QualType DestTy = ICE->getType();
-      if (isInt64OrWider(DestTy, C))
+  static const Expr *ignorePII(const Expr *E) {
+    return E ? E->IgnoreParenImpCasts() : nullptr;
+  }
+
+  // Determine if E is immediately used as the RHS of an assignment to a 64-bit int.
+  bool isImmediateRHSOfAssignTo64(const Expr *E, CheckerContext &C) const {
+    const auto *ParentBO = findSpecificTypeInParents<BinaryOperator>(E, C);
+    if (!ParentBO || !ParentBO->isAssignmentOp())
+      return false;
+
+    const Expr *RHS = ParentBO->getRHS();
+    if (!RHS)
+      return false;
+
+    // Ensure E is exactly the RHS (ignoring parens/implicit casts).
+    if (ignorePII(RHS) != ignorePII(E))
+      return false;
+
+    const Expr *LHS = ParentBO->getLHS();
+    return LHS && isInt64OrWider(LHS->getType(), C);
+  }
+
+  // Determine if E is the initializer of a 64-bit variable.
+  bool isInitializerOf64Var(const Expr *E, CheckerContext &C) const {
+    const auto *DS = findSpecificTypeInParents<DeclStmt>(E, C);
+    if (!DS)
+      return false;
+
+    const Expr *ECore = ignorePII(E);
+
+    for (const Decl *D : DS->decls()) {
+      const auto *VD = dyn_cast<VarDecl>(D);
+      if (!VD || !VD->hasInit())
+        continue;
+      if (!isInt64OrWider(VD->getType(), C))
+        continue;
+      const Expr *Init = VD->getInit();
+      if (ignorePII(Init) == ECore)
         return true;
     }
-
-    // 2) Look for a C-style cast to 64-bit
-    if (const auto *CS = findSpecificTypeInParents<CStyleCastExpr>(E, C)) {
-      QualType DestTy = CS->getTypeAsWritten();
-      if (isInt64OrWider(DestTy, C))
-        return true;
-    }
-
-    // 3) Look for assignment where LHS is 64-bit
-    if (const auto *PAssn = findSpecificTypeInParents<BinaryOperator>(E, C)) {
-      if (PAssn->isAssignmentOp()) {
-        const Expr *LHS = PAssn->getLHS();
-        if (LHS && isInt64OrWider(LHS->getType(), C))
+    return false;
+  }
+
+  // Determine if E is the returned expression of a function returning 64-bit.
+  bool isImmediateReturnOf64(const Expr *E, CheckerContext &C) const {
+    const auto *RS = findSpecificTypeInParents<ReturnStmt>(E, C);
+    if (!RS)
+      return false;
+    const Expr *Ret = RS->getRetValue();
+    if (!Ret || ignorePII(Ret) != ignorePII(E))
+      return false;
+
+    const auto *D = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
+    if (!D)
+      return false;
+    return isInt64OrWider(D->getReturnType(), C);
+  }
+
+  // Determine if E is passed as an argument to a 64-bit parameter.
+  bool isPassedTo64Param(const Expr *E, CheckerContext &C) const {
+    const auto *Call = findSpecificTypeInParents<CallExpr>(E, C);
+    if (!Call)
+      return false;
+
+    const FunctionDecl *FD = Call->getDirectCallee();
+    if (!FD)
+      return false;
+
+    const Expr *ECore = ignorePII(E);
+    for (unsigned i = 0, n = Call->getNumArgs(); i < n && i < FD->getNumParams(); ++i) {
+      const Expr *Arg = Call->getArg(i);
+      if (!Arg)
+        continue;
+      if (ignorePII(Arg) == ECore) {
+        QualType ParamTy = FD->getParamDecl(i)->getType();
+        if (isInt64OrWider(ParamTy, C))
           return true;
       }
     }
-
-    // 4) Look for return statement where function returns 64-bit
-    if (findSpecificTypeInParents<ReturnStmt>(E, C)) {
-      const auto *D = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
-      if (D) {
-        QualType RetTy = D->getReturnType();
-        if (isInt64OrWider(RetTy, C))
-          return true;
-      }
-    }
-
-    // 5) Look for function call argument where the parameter is 64-bit
-    if (const auto *Call = findSpecificTypeInParents<CallExpr>(E, C)) {
-      const FunctionDecl *FD = Call->getDirectCallee();
-      if (!FD)
-        return false;
-      for (unsigned i = 0, n = Call->getNumArgs(); i < n && i < FD->getNumParams(); ++i) {
-        const Expr *Arg = Call->getArg(i);
-        if (!Arg)
-          continue;
-        const Expr *ArgCore = Arg->IgnoreParenImpCasts();
-        const Expr *ECore = E->IgnoreParenImpCasts();
-        if (ArgCore == ECore) {
-          QualType ParamTy = FD->getParamDecl(i)->getType();
-          if (isInt64OrWider(ParamTy, C))
-            return true;
-        }
-      }
-    }
-
     return false;
+  }
+
+  // Determine if E is explicitly cast to 64-bit using a C-style cast.
+  bool isExplicitlyCastTo64(const Expr *E, CheckerContext &C) const {
+    const auto *CS = findSpecificTypeInParents<CStyleCastExpr>(E, C);
+    if (!CS)
+      return false;
+    if (ignorePII(CS->getSubExpr()) != ignorePII(E))
+      return false;
+
+    QualType DestTy = CS->getTypeAsWritten();
+    return isInt64OrWider(DestTy, C);
+  }
+
+  // The only contexts we want to consider as "widened to 64" to avoid FPs:
+  bool isRelevantWidenedUseTo64(const Expr *E, CheckerContext &C) const {
+    return isImmediateRHSOfAssignTo64(E, C) ||
+           isInitializerOf64Var(E, C) ||
+           isImmediateReturnOf64(E, C) ||
+           isPassedTo64Param(E, C) ||
+           isExplicitlyCastTo64(E, C);
   }

   // Try to get the maximum possible value of an expression.
@@ -158,7 +213,7 @@     __uint128_t Limit;
     if (IsUnsigned) {
       if (MulW >= 64) {
-        // If multiply is already 64-bit or more (should not be here), treat as safe.
+        // If multiply is already 64-bit or more, treat as safe.
         return true;
       }
       Limit = (((__uint128_t)1) << MulW) - 1;
@@ -198,19 +253,23 @@   if (!isIntegerType(B->getLHS()) || !isIntegerType(B->getRHS()))
     return;

-  // Is the result used in 64-bit integer context?
   const Expr *E = dyn_cast<Expr>(B);
   if (!E)
     return;

-  if (!isWidenedUseTo64(E, C))
+  // Only warn when the 32-bit multiply result is materialized in a 64-bit context
+  // that matches the bug pattern: assignment/initialization, return, param passing,
+  // or explicit cast. Do NOT warn for promotions due to other arithmetic ops
+  // (e.g., division with a 64-bit numerator), which caused the FP.
+  if (!isRelevantWidenedUseTo64(E, C))
     return;

   // Optional reduction: if we can prove product fits in the narrow type, don't warn.
   if (productDefinitelyFits(B, C))
     return;

-  // Report: multiplication in 32-bit (or narrower) that is widened to 64-bit.
+  // Report: multiplication in 32-bit (or narrower) that is widened to 64-bit
+  // only at the use site, risking overflow before the widening.
   ExplodedNode *N = C.generateNonFatalErrorNode();
   if (!N)
     return;
