--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -647,10 +647,82 @@     return false;
   }

+  // Targeted FP filter for Linux SLUB: calculate_order() -> get_order(size * MAX_OBJS_PER_PAGE)
+  bool isKernelSlubCalcOrderSafe(const BinaryOperator *Mul,
+                                 const Stmt *UseSiteStmt,
+                                 CheckerContext &C) const {
+    if (!Mul || !UseSiteStmt)
+      return false;
+
+    // We must be inside calculate_order().
+    const auto *CurFD =
+        dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
+    if (!CurFD || !CurFD->getIdentifier() || CurFD->getName() != "calculate_order")
+      return false;
+
+    // Use site must be a direct call to get_order(...).
+    const auto *Call = dyn_cast<CallExpr>(UseSiteStmt);
+    if (!Call)
+      return false;
+    const FunctionDecl *Callee = Call->getDirectCallee();
+    if (!Callee || !Callee->getIdentifier() || Callee->getName() != "get_order")
+      return false;
+
+    // The multiply must be an argument of the call.
+    bool IsArgMatch = false;
+    for (unsigned i = 0, n = Call->getNumArgs(); i < n; ++i) {
+      if (Call->getArg(i)->IgnoreParenImpCasts() == cast<Expr>(Mul)->IgnoreParenImpCasts()) {
+        IsArgMatch = true;
+        break;
+      }
+    }
+    if (!IsArgMatch)
+      return false;
+
+    // One operand should be the parameter named 'size'.
+    auto IsSizeParam = [&](const Expr *E) -> bool {
+      E = E ? E->IgnoreParenImpCasts() : nullptr;
+      const auto *DRE = dyn_cast_or_null<DeclRefExpr>(E);
+      if (!DRE) return false;
+      const auto *VD = dyn_cast_or_null<VarDecl>(DRE->getDecl());
+      if (!VD || !VD->getIdentifier()) return false;
+      // Accept exact name 'size' (matches the function parameter).
+      return VD->getName() == "size";
+    };
+
+    // The other operand should be MAX_OBJS_PER_PAGE or a small literal consistent with it.
+    auto IsMaxObjsPerPage = [&](const Expr *E) -> bool {
+      if (!E) return false;
+      if (ExprHasName(E, "MAX_OBJS_PER_PAGE", C))
+        return true;
+      llvm::APSInt Val;
+      if (EvaluateExprToInt(Val, E, C)) {
+        // Linux defines MAX_OBJS_PER_PAGE as 32767. Be conservative and suppress
+        // if the literal is reasonably small (<= 65535) to avoid overfitting.
+        uint64_t V = Val.isSigned() ? (uint64_t)Val.getExtValue() : Val.getZExtValue();
+        return V <= 65535ULL;
+      }
+      return false;
+    };
+
+    const Expr *L = Mul->getLHS();
+    const Expr *R = Mul->getRHS();
+
+    if ((IsSizeParam(L) && IsMaxObjsPerPage(R)) ||
+        (IsSizeParam(R) && IsMaxObjsPerPage(L)))
+      return true;
+
+    return false;
+  }
+
   bool isFalsePositive(const BinaryOperator *Mul,
                        const Stmt *UseSiteStmt,
                        const Decl *UseSiteDecl,
                        CheckerContext &C) const {
+    // Targeted suppression: safe SLUB calculate_order() pattern.
+    if (isKernelSlubCalcOrderSafe(Mul, UseSiteStmt, C))
+      return true;
+
     // Targeted suppression: MSI-X ioremap table size computation.
     if (isBenignMsixIoremapSize(Mul, UseSiteStmt, C))
       return true;
