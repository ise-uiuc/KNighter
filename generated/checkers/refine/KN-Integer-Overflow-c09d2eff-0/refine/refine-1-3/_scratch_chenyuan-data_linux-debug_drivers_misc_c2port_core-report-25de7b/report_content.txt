### Report Summary

File:| /scratch/chenyuan-data/linux-debug/drivers/misc/c2port/core.c
---|---
Warning:| line 916, column 45
32-bit multiply widens to 64-bit after overflow; cast an operand to 64-bit
before the multiply

### Annotated Source Code


841   |
842   |  mutex_lock(&c2dev->mutex);
843   | 	ret = __c2port_write_flash_data(c2dev, buffer, offset, count);
844   | 	mutex_unlock(&c2dev->mutex);
845   |
846   |  if (ret < 0)
847   |  dev_err(c2dev->dev, "cannot write %s flash\n", c2dev->name);
848   |
849   |  return ret;
850   | }
851   | /* size is computed at run-time */
852   | static BIN_ATTR(flash_data, 0644, c2port_read_flash_data,
853   |  c2port_write_flash_data, 0);
854   |
855   | /*
856   |  * Class attributes
857   |  */
858   | static struct attribute *c2port_attrs[] = {
859   | 	&dev_attr_name.attr,
860   | 	&dev_attr_flash_blocks_num.attr,
861   | 	&dev_attr_flash_block_size.attr,
862   | 	&dev_attr_flash_size.attr,
863   | 	&dev_attr_access.attr,
864   | 	&dev_attr_reset.attr,
865   | 	&dev_attr_dev_id.attr,
866   | 	&dev_attr_rev_id.attr,
867   | 	&dev_attr_flash_access.attr,
868   | 	&dev_attr_flash_erase.attr,
869   |  NULL,
870   | };
871   |
872   | static struct bin_attribute *c2port_bin_attrs[] = {
873   | 	&bin_attr_flash_data,
874   |  NULL,
875   | };
876   |
877   | static const struct attribute_group c2port_group = {
878   | 	.attrs = c2port_attrs,
879   | 	.bin_attrs = c2port_bin_attrs,
880   | };
881   |
882   | static const struct attribute_group *c2port_groups[] = {
883   | 	&c2port_group,
884   |  NULL,
885   | };
886   |
887   | /*
888   |  * Exported functions
889   |  */
890   |
891   | struct c2port_device *c2port_device_register(char *name,
892   |  struct c2port_ops *ops, void *devdata)
893   | {
894   |  struct c2port_device *c2dev;
895   |  int ret;
896   |
897   |  if (unlikely(!ops) || unlikely(!ops->access) || \
    1Assuming 'ops' is non-null→
    2←Assuming field 'access' is non-null→
    7←Taking false branch→
898   |  unlikely(!ops->c2d_dir) || unlikely(!ops->c2ck_set) || \
    3←Assuming field 'c2d_dir' is non-null→
    4←Assuming field 'c2ck_set' is non-null→
899   |  unlikely(!ops->c2d_get) || unlikely(!ops->c2d_set))
    5←Assuming field 'c2d_get' is non-null→
    6←Assuming field 'c2d_set' is non-null→
900   |  return ERR_PTR(-EINVAL);
901   |
902   |  c2dev = kzalloc(sizeof(struct c2port_device), GFP_KERNEL);
903   |  if (unlikely(!c2dev))
    8←Assuming 'c2dev' is non-null→
    9←Taking false branch→
904   |  return ERR_PTR(-ENOMEM);
905   |
906   |  idr_preload(GFP_KERNEL);
907   | 	spin_lock_irq(&c2port_idr_lock);
908   | 	ret = idr_alloc(&c2port_idr, c2dev, 0, 0, GFP_NOWAIT);
909   | 	spin_unlock_irq(&c2port_idr_lock);
910   | 	idr_preload_end();
911   |
912   |  if (ret < 0)
    10←Assuming 'ret' is >= 0→
    11←Taking false branch→
913   |  goto error_idr_alloc;
914   |  c2dev->id = ret;
915   |
916   | 	bin_attr_flash_data.size = ops->blocks_num * ops->block_size;
    12←32-bit multiply widens to 64-bit after overflow; cast an operand to 64-bit before the multiply
917   |
918   | 	c2dev->dev = device_create(c2port_class, NULL, 0, c2dev,
919   |  "c2port%d", c2dev->id);
920   |  if (IS_ERR(c2dev->dev)) {
921   | 		ret = PTR_ERR(c2dev->dev);
922   |  goto error_device_create;
923   | 	}
924   | 	dev_set_drvdata(c2dev->dev, c2dev);
925   |
926   |  strscpy(c2dev->name, name, sizeof(c2dev->name));
927   | 	c2dev->ops = ops;
928   |  mutex_init(&c2dev->mutex);
929   |
930   |  /* By default C2 port access is off */
931   | 	c2dev->access = c2dev->flash_access = 0;
932   | 	ops->access(c2dev, 0);
933   |
934   |  dev_info(c2dev->dev, "C2 port %s added\n", name);
935   |  dev_info(c2dev->dev, "%s flash has %d blocks x %d bytes "
936   |  "(%d bytes total)\n",
937   |  name, ops->blocks_num, ops->block_size,
938   |  ops->blocks_num * ops->block_size);
939   |
940   |  return c2dev;
941   |
942   | error_device_create:
943   | 	spin_lock_irq(&c2port_idr_lock);
944   | 	idr_remove(&c2port_idr, c2dev->id);
945   | 	spin_unlock_irq(&c2port_idr_lock);
946   |
