--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -54,44 +54,79 @@     return E->getType()->isIntegerType();
   }

-  // Determine if the expression result is used in a 64-bit integer context.
+  static const Expr *ignoreNoOps(const Expr *E) {
+    return E ? E->IgnoreParenImpCasts() : nullptr;
+  }
+
+  // Suppression for well-formed shift-count usage: E is RHS of a shift.
+  bool isUsedAsShiftCount(const Expr *E, CheckerContext &C) const {
+    const auto *ParentBin = findSpecificTypeInParents<BinaryOperator>(E, C);
+    if (!ParentBin)
+      return false;
+    if (!(ParentBin->getOpcode() == BO_Shl || ParentBin->getOpcode() == BO_Shr))
+      return false;
+    const Expr *RHS = ignoreNoOps(ParentBin->getRHS());
+    const Expr *Core = ignoreNoOps(E);
+    return RHS == Core;
+  }
+
+  // Determine if the expression result is used in a 64-bit integer context,
+  // and that 64-bit context applies directly to this multiply's value.
   bool isWidenedUseTo64(const Expr *E, CheckerContext &C) const {
     if (!E) return false;

-    // 1) Look for an implicit cast to 64-bit integer.
-    if (const auto *ICE = findSpecificTypeInParents<ImplicitCastExpr>(E, C)) {
-      QualType DestTy = ICE->getType();
-      if (isInt64OrWider(DestTy, C))
-        return true;
-    }
-
-    // 2) Look for a C-style cast to 64-bit
-    if (const auto *CS = findSpecificTypeInParents<CStyleCastExpr>(E, C)) {
-      QualType DestTy = CS->getTypeAsWritten();
-      if (isInt64OrWider(DestTy, C))
-        return true;
-    }
-
-    // 3) Look for assignment where LHS is 64-bit
+    // Suppress when multiply is used only as a shift count.
+    if (isUsedAsShiftCount(E, C))
+      return false;
+
+    const Expr *Core = ignoreNoOps(E);
+
+    // 1) Direct assignment where RHS is exactly this multiply and LHS is 64-bit.
     if (const auto *PAssn = findSpecificTypeInParents<BinaryOperator>(E, C)) {
       if (PAssn->isAssignmentOp()) {
-        const Expr *LHS = PAssn->getLHS();
-        if (LHS && isInt64OrWider(LHS->getType(), C))
+        const Expr *RHS = ignoreNoOps(PAssn->getRHS());
+        if (RHS == Core) {
+          const Expr *LHS = PAssn->getLHS();
+          if (LHS && isInt64OrWider(LHS->getType(), C))
+            return true;
+        }
+      }
+    }
+
+    // 2) Explicit C-style cast directly applied to the multiply to 64-bit.
+    if (const auto *CS = findSpecificTypeInParents<CStyleCastExpr>(E, C)) {
+      const Expr *Sub = ignoreNoOps(CS->getSubExpr());
+      if (Sub == Core) {
+        QualType DestTy = CS->getTypeAsWritten();
+        if (isInt64OrWider(DestTy, C))
           return true;
       }
     }

-    // 4) Look for return statement where function returns 64-bit
-    if (findSpecificTypeInParents<ReturnStmt>(E, C)) {
-      const auto *D = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
-      if (D) {
-        QualType RetTy = D->getReturnType();
-        if (isInt64OrWider(RetTy, C))
+    // 3) Immediate implicit cast to 64-bit directly applied to the multiply.
+    if (const auto *ICE = findSpecificTypeInParents<ImplicitCastExpr>(E, C)) {
+      const Expr *Sub = ignoreNoOps(ICE->getSubExpr());
+      if (Sub == Core) {
+        QualType DestTy = ICE->getType();
+        if (isInt64OrWider(DestTy, C))
           return true;
       }
     }

-    // 5) Look for function call argument where the parameter is 64-bit
+    // 4) Direct return where function returns 64-bit and this multiply is the returned expr.
+    if (const auto *RS = findSpecificTypeInParents<ReturnStmt>(E, C)) {
+      const Expr *RV = RS->getRetValue();
+      if (ignoreNoOps(RV) == Core) {
+        const auto *D = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());
+        if (D) {
+          QualType RetTy = D->getReturnType();
+          if (isInt64OrWider(RetTy, C))
+            return true;
+        }
+      }
+    }
+
+    // 5) Direct function call argument where the parameter is 64-bit and the argument is exactly this multiply.
     if (const auto *Call = findSpecificTypeInParents<CallExpr>(E, C)) {
       const FunctionDecl *FD = Call->getDirectCallee();
       if (!FD)
@@ -100,9 +135,7 @@         const Expr *Arg = Call->getArg(i);
         if (!Arg)
           continue;
-        const Expr *ArgCore = Arg->IgnoreParenImpCasts();
-        const Expr *ECore = E->IgnoreParenImpCasts();
-        if (ArgCore == ECore) {
+        if (ignoreNoOps(Arg) == Core) {
           QualType ParamTy = FD->getParamDecl(i)->getType();
           if (isInt64OrWider(ParamTy, C))
             return true;
@@ -198,7 +231,7 @@   if (!isIntegerType(B->getLHS()) || !isIntegerType(B->getRHS()))
     return;

-  // Is the result used in 64-bit integer context?
+  // Is the result used directly in a 64-bit integer context?
   const Expr *E = dyn_cast<Expr>(B);
   if (!E)
     return;
