--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -37,9 +37,10 @@   // Check if expression (ignoring parens/imp-casts) is a sizeof(...) expr.
   static bool isSizeofExpr(const Expr *E);

-  // Return true if 'E' syntactically contains a multiplication with sizeof on
-  // one side. Do not traverse into sizeof(...) operands to avoid false hits.
-  static const BinaryOperator *findMulWithSizeof(const Expr *E);
+  // Return true if E (ignoring parens/imp-casts) is exactly a multiply
+  // with exactly one side being a sizeof(...). If so, returns that BO via Out.
+  static bool isTopLevelMulWithExactlyOneSizeof(const Expr *E,
+                                                const BinaryOperator *&Out);

   // Filter out benign cases (e.g., plain sizeof(...) without multiplication).
   static bool isFalsePositive(const Expr *SizeArg);
@@ -57,74 +58,34 @@   return false;
 }

-// Helper: recursively search for a BinaryOperator '*' with one side a sizeof.
-// - Ignore parens/implicit casts.
-// - Do NOT traverse into sizeof(...) operands to avoid flagging patterns
-//   like sizeof(a*b).
-static const BinaryOperator *findMulWithSizeofRec(const Expr *E) {
+bool SAGenTestChecker::isTopLevelMulWithExactlyOneSizeof(
+    const Expr *E, const BinaryOperator *&Out) {
+  Out = nullptr;
   if (!E)
-    return nullptr;
+    return false;

   E = E->IgnoreParenImpCasts();

-  // If we reached a sizeof(...) expression, do not look inside.
-  if (isa<UnaryExprOrTypeTraitExpr>(E))
-    return nullptr;
+  const auto *BO = dyn_cast<BinaryOperator>(E);
+  if (!BO || BO->getOpcode() != BO_Mul)
+    return false;

-  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
-    if (BO->getOpcode() == BO_Mul) {
-      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();
-      const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();
-      if (isa<UnaryExprOrTypeTraitExpr>(LHS) ||
-          isa<UnaryExprOrTypeTraitExpr>(RHS)) {
-        const auto *UL = dyn_cast<UnaryExprOrTypeTraitExpr>(LHS);
-        const auto *UR = dyn_cast<UnaryExprOrTypeTraitExpr>(RHS);
-        if ((UL && UL->getKind() == UETT_SizeOf) ||
-            (UR && UR->getKind() == UETT_SizeOf)) {
-          return BO;
-        }
-      }
-    }
-    // Recurse into children (still respecting the "don't go inside sizeof" rule)
-    if (const BinaryOperator *Found = findMulWithSizeofRec(BO->getLHS()))
-      return Found;
-    if (const BinaryOperator *Found = findMulWithSizeofRec(BO->getRHS()))
-      return Found;
-    return nullptr;
-  }
+  const Expr *LHS = BO->getLHS();
+  const Expr *RHS = BO->getRHS();
+  bool LIsSizeof = isSizeofExpr(LHS);
+  bool RIsSizeof = isSizeofExpr(RHS);

-  // Ternary operator
-  if (const auto *CO = dyn_cast<ConditionalOperator>(E)) {
-    if (const BinaryOperator *Found = findMulWithSizeofRec(CO->getTrueExpr()))
-      return Found;
-    if (const BinaryOperator *Found = findMulWithSizeofRec(CO->getFalseExpr()))
-      return Found;
-    return nullptr;
-  }
+  // We only want the "count * sizeof(elem)" shape, i.e., exactly one sizeof.
+  if (LIsSizeof == RIsSizeof)
+    return false;

-  // Casts (already ignoring implicit; handle explicit as well)
-  if (const auto *CE = dyn_cast<CastExpr>(E)) {
-    return findMulWithSizeofRec(CE->getSubExpr());
-  }
-
-  // Generic traversal over children for any other Expr subclasses.
-  for (const Stmt *Child : E->children()) {
-    const auto *ChildE = dyn_cast_or_null<Expr>(Child);
-    if (!ChildE)
-      continue;
-    if (const auto *Found = findMulWithSizeofRec(ChildE))
-      return Found;
-  }
-  return nullptr;
-}
-
-const BinaryOperator *SAGenTestChecker::findMulWithSizeof(const Expr *E) {
-  return findMulWithSizeofRec(E);
+  Out = BO;
+  return true;
 }

 bool SAGenTestChecker::isFalsePositive(const Expr *SizeArg) {
   // Suppress when the entire size arg is a plain sizeof(...) of anything.
-  // This covers the reported FP: memdup_user(arg, sizeof(*ldpc))
+  // This covers the reported FP: memdup_user(arg, sizeof(*desc))
   return isSizeofExpr(SizeArg);
 }

@@ -151,10 +112,10 @@   if (isFalsePositive(SizeArg))
     return;

-  // Find a multiplication with sizeof(...) anywhere in the size argument,
-  // but never inside a sizeof operand.
-  const BinaryOperator *Mul = findMulWithSizeof(SizeArg);
-  if (!Mul)
+  // Only warn when the top-level expression (ignoring parens/casts) is exactly
+  // a multiplication with exactly one side being sizeof(...).
+  const BinaryOperator *TopMul = nullptr;
+  if (!isTopLevelMulWithExactlyOneSizeof(SizeArg, TopMul))
     return;

   ExplodedNode *N = C.generateNonFatalErrorNode();
@@ -166,8 +127,8 @@       "Use memdup_array_user(ptr, count, elem_size) instead of memdup_user(ptr, "
       "count * elem_size); multiplication may overflow.",
       N);
-  // Highlight just the multiplication subexpression for precision.
-  R->addRange(Mul->getSourceRange());
+  // Highlight just the multiplication subexpression (the whole size arg).
+  R->addRange(TopMul->getSourceRange());
   C.emitReport(std::move(R));
 }
