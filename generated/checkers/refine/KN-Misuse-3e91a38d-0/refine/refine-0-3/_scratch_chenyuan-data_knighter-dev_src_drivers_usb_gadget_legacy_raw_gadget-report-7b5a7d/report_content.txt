### Report Summary

File:| drivers/usb/gadget/legacy/raw_gadget.c
---|---
Warning:| line 847, column 9
Use memdup_array_user(ptr, count, elem_size) instead of memdup_user(ptr, count
* elem_size); multiplication may overflow

### Annotated Source Code


789   | 		ret = length;
790   | free:
791   | 	kfree(data);
792   |  return ret;
793   | }
794   |
795   | static int raw_ioctl_ep0_stall(struct raw_dev *dev, unsigned long value)
796   | {
797   |  int ret = 0;
798   |  unsigned long flags;
799   |
800   |  if (value)
801   |  return -EINVAL;
802   |  spin_lock_irqsave(&dev->lock, flags);
803   |  if (dev->state != STATE_DEV_RUNNING) {
804   |  dev_dbg(dev->dev, "fail, device is not running\n");
805   | 		ret = -EINVAL;
806   |  goto out_unlock;
807   | 	}
808   |  if (!dev->gadget) {
809   |  dev_dbg(dev->dev, "fail, gadget is not bound\n");
810   | 		ret = -EBUSY;
811   |  goto out_unlock;
812   | 	}
813   |  if (dev->ep0_urb_queued) {
814   |  dev_dbg(&dev->gadget->dev, "fail, urb already queued\n");
815   | 		ret = -EBUSY;
816   |  goto out_unlock;
817   | 	}
818   |  if (!dev->ep0_in_pending && !dev->ep0_out_pending) {
819   |  dev_dbg(&dev->gadget->dev, "fail, no request pending\n");
820   | 		ret = -EBUSY;
821   |  goto out_unlock;
822   | 	}
823   |
824   | 	ret = usb_ep_set_halt(dev->gadget->ep0);
825   |  if (ret < 0)
826   |  dev_err(&dev->gadget->dev,
827   |  "fail, usb_ep_set_halt returned %d\n", ret);
828   |
829   |  if (dev->ep0_in_pending)
830   | 		dev->ep0_in_pending = false;
831   |  else
832   | 		dev->ep0_out_pending = false;
833   |
834   | out_unlock:
835   | 	spin_unlock_irqrestore(&dev->lock, flags);
836   |  return ret;
837   | }
838   |
839   | static int raw_ioctl_ep_enable(struct raw_dev *dev, unsigned long value)
840   | {
841   |  int ret = 0, i;
842   |  unsigned long flags;
843   |  struct usb_endpoint_descriptor *desc;
844   |  struct raw_ep *ep;
845   | 	bool ep_props_matched = false;
846   |
847   |  desc = memdup_user((void __user *)value, sizeof(*desc));
    Use memdup_array_user(ptr, count, elem_size) instead of memdup_user(ptr, count * elem_size); multiplication may overflow
848   |  if (IS_ERR(desc))
849   |  return PTR_ERR(desc);
850   |
851   |  /*
852   |  * Endpoints with a maxpacket length of 0 can cause crashes in UDC
853   |  * drivers.
854   |  */
855   |  if (usb_endpoint_maxp(desc) == 0) {
856   |  dev_dbg(dev->dev, "fail, bad endpoint maxpacket\n");
857   | 		kfree(desc);
858   |  return -EINVAL;
859   | 	}
860   |
861   |  spin_lock_irqsave(&dev->lock, flags);
862   |  if (dev->state != STATE_DEV_RUNNING) {
863   |  dev_dbg(dev->dev, "fail, device is not running\n");
864   | 		ret = -EINVAL;
865   |  goto out_free;
866   | 	}
867   |  if (!dev->gadget) {
868   |  dev_dbg(dev->dev, "fail, gadget is not bound\n");
869   | 		ret = -EBUSY;
870   |  goto out_free;
871   | 	}
872   |
873   |  for (i = 0; i < dev->eps_num; i++) {
874   | 		ep = &dev->eps[i];
875   |  if (ep->addr != usb_endpoint_num(desc) &&
876   | 				ep->addr != USB_RAW_EP_ADDR_ANY)
877   |  continue;
