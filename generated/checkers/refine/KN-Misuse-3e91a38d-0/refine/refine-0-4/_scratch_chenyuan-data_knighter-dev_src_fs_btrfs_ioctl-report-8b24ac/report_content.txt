### Report Summary

File:| fs/btrfs/ioctl.c
---|---
Warning:| line 2708, column 13
Use memdup_array_user(ptr, count, elem_size) instead of memdup_user(ptr, count
* elem_size); multiplication may overflow

### Annotated Source Code


358   |
359   | 		binode_flags |= BTRFS_INODE_COMPRESS;
360   | 		binode_flags &= ~BTRFS_INODE_NOCOMPRESS;
361   |
362   | 		comp = btrfs_compress_type2str(fs_info->compress_type);
363   |  if (!comp || comp[0] == 0)
364   | 			comp = btrfs_compress_type2str(BTRFS_COMPRESS_ZLIB);
365   | 	} else {
366   | 		binode_flags &= ~(BTRFS_INODE_COMPRESS | BTRFS_INODE_NOCOMPRESS);
367   | 	}
368   |
369   |  /*
370   |  * 1 for inode item
371   |  * 2 for properties
372   |  */
373   | 	trans = btrfs_start_transaction(root, 3);
374   |  if (IS_ERR(trans))
375   |  return PTR_ERR(trans);
376   |
377   |  if (comp) {
378   | 		ret = btrfs_set_prop(trans, inode, "btrfs.compression", comp,
379   |  strlen(comp), 0);
380   |  if (ret) {
381   |  btrfs_abort_transaction(trans, ret);
382   |  goto out_end_trans;
383   | 		}
384   | 	} else {
385   | 		ret = btrfs_set_prop(trans, inode, "btrfs.compression", NULL,
386   | 				     0, 0);
387   |  if (ret && ret != -ENODATA) {
388   |  btrfs_abort_transaction(trans, ret);
389   |  goto out_end_trans;
390   | 		}
391   | 	}
392   |
393   | update_flags:
394   | 	binode->flags = binode_flags;
395   | 	btrfs_sync_inode_flags_to_i_flags(inode);
396   | 	inode_inc_iversion(inode);
397   | 	inode_set_ctime_current(inode);
398   | 	ret = btrfs_update_inode(trans, BTRFS_I(inode));
399   |
400   |  out_end_trans:
401   | 	btrfs_end_transaction(trans);
402   |  return ret;
403   | }
404   |
405   | /*
406   |  * Start exclusive operation @type, return true on success
407   |  */
408   | bool btrfs_exclop_start(struct btrfs_fs_info *fs_info,
409   |  enum btrfs_exclusive_operation type)
410   | {
411   | 	bool ret = false;
412   |
413   | 	spin_lock(&fs_info->super_lock);
414   |  if (fs_info->exclusive_operation == BTRFS_EXCLOP_NONE) {
415   | 		fs_info->exclusive_operation = type;
416   | 		ret = true;
417   | 	}
418   | 	spin_unlock(&fs_info->super_lock);
419   |
420   |  return ret;
421   | }
422   |
423   | /*
424   |  * Conditionally allow to enter the exclusive operation in case it's compatible
425   |  * with the running one.  This must be paired with btrfs_exclop_start_unlock and
426   |  * btrfs_exclop_finish.
427   |  *
428   |  * Compatibility:
429   |  * - the same type is already running
430   |  * - when trying to add a device and balance has been paused
431   |  * - not BTRFS_EXCLOP_NONE - this is intentionally incompatible and the caller
432   |  *   must check the condition first that would allow none -> @type
433   |  */
434   | bool btrfs_exclop_start_try_lock(struct btrfs_fs_info *fs_info,
435   |  enum btrfs_exclusive_operation type)
436   | {
437   | 	spin_lock(&fs_info->super_lock);
438   |  if (fs_info->exclusive_operation == type ||
439   | 	    (fs_info->exclusive_operation == BTRFS_EXCLOP_BALANCE_PAUSED &&
440   | 	     type == BTRFS_EXCLOP_DEV_ADD))
441   |  return true;
442   |
443   | 	spin_unlock(&fs_info->super_lock);
444   |  return false;
445   | }
446   |
447   | void btrfs_exclop_start_unlock(struct btrfs_fs_info *fs_info)
448   | {
449   | 	spin_unlock(&fs_info->super_lock);
450   | }
2624  |  case S_IFDIR:
2625  |  if (!capable(CAP_SYS_ADMIN)) {
2626  | 			ret = -EPERM;
2627  |  goto out;
2628  | 		}
2629  | 		ret = btrfs_defrag_root(root);
2630  |  break;
2631  |  case S_IFREG:
2632  |  /*
2633  |  * Note that this does not check the file descriptor for write
2634  |  * access. This prevents defragmenting executables that are
2635  |  * running and allows defrag on files open in read-only mode.
2636  |  */
2637  |  if (!capable(CAP_SYS_ADMIN) &&
2638  | 		    inode_permission(&nop_mnt_idmap, inode, MAY_WRITE)) {
2639  | 			ret = -EPERM;
2640  |  goto out;
2641  | 		}
2642  |
2643  |  if (argp) {
2644  |  if (copy_from_user(&range, argp, sizeof(range))) {
2645  | 				ret = -EFAULT;
2646  |  goto out;
2647  | 			}
2648  |  if (range.flags & ~BTRFS_DEFRAG_RANGE_FLAGS_SUPP) {
2649  | 				ret = -EOPNOTSUPP;
2650  |  goto out;
2651  | 			}
2652  |  /* compression requires us to start the IO */
2653  |  if ((range.flags & BTRFS_DEFRAG_RANGE_COMPRESS)) {
2654  | 				range.flags |= BTRFS_DEFRAG_RANGE_START_IO;
2655  | 				range.extent_thresh = (u32)-1;
2656  | 			}
2657  | 		} else {
2658  |  /* the rest are all set to zero by kzalloc */
2659  | 			range.len = (u64)-1;
2660  | 		}
2661  | 		ret = btrfs_defrag_file(file_inode(file), &file->f_ra,
2662  | 					&range, BTRFS_OLDEST_GENERATION, 0);
2663  |  if (ret > 0)
2664  | 			ret = 0;
2665  |  break;
2666  |  default:
2667  | 		ret = -EINVAL;
2668  | 	}
2669  | out:
2670  | 	mnt_drop_write_file(file);
2671  |  return ret;
2672  | }
2673  |
2674  | static long btrfs_ioctl_add_dev(struct btrfs_fs_info *fs_info, void __user *arg)
2675  | {
2676  |  struct btrfs_ioctl_vol_args *vol_args;
2677  | 	bool restore_op = false;
2678  |  int ret;
2679  |
2680  |  if (!capable(CAP_SYS_ADMIN))
    5←Assuming the condition is false→
    6←Taking false branch→
2681  |  return -EPERM;
2682  |
2683  |  if (btrfs_fs_incompat(fs_info, EXTENT_TREE_V2)) {
    7←Assuming the condition is true→
    8←Taking false branch→
2684  |  btrfs_err(fs_info, "device add not supported on extent tree v2 yet");
2685  |  return -EINVAL;
2686  | 	}
2687  |
2688  |  if (fs_info->fs_devices->temp_fsid) {
    9←Assuming field 'temp_fsid' is false→
    10←Taking false branch→
2689  |  btrfs_err(fs_info,
2690  |  "device add not supported on cloned temp-fsid mount");
2691  |  return -EINVAL;
2692  | 	}
2693  |
2694  |  if (!btrfs_exclop_start(fs_info, BTRFS_EXCLOP_DEV_ADD)) {
    11←Taking false branch→
2695  |  if (!btrfs_exclop_start_try_lock(fs_info, BTRFS_EXCLOP_DEV_ADD))
2696  |  return BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;
2697  |
2698  |  /*
2699  |  * We can do the device add because we have a paused balanced,
2700  |  * change the exclusive op type and remember we should bring
2701  |  * back the paused balance
2702  |  */
2703  | 		fs_info->exclusive_operation = BTRFS_EXCLOP_DEV_ADD;
2704  | 		btrfs_exclop_start_unlock(fs_info);
2705  | 		restore_op = true;
2706  | 	}
2707  |
2708  |  vol_args = memdup_user(arg, sizeof(*vol_args));
    12←Use memdup_array_user(ptr, count, elem_size) instead of memdup_user(ptr, count * elem_size); multiplication may overflow
2709  |  if (IS_ERR(vol_args)) {
2710  | 		ret = PTR_ERR(vol_args);
2711  |  goto out;
2712  | 	}
2713  |
2714  | 	ret = btrfs_check_ioctl_vol_args_path(vol_args);
2715  |  if (ret < 0)
2716  |  goto out_free;
2717  |
2718  | 	ret = btrfs_init_new_device(fs_info, vol_args->name);
2719  |
2720  |  if (!ret)
2721  |  btrfs_info(fs_info, "disk added %s", vol_args->name);
2722  |
2723  | out_free:
2724  | 	kfree(vol_args);
2725  | out:
2726  |  if (restore_op)
2727  | 		btrfs_exclop_balance(fs_info, BTRFS_EXCLOP_BALANCE_PAUSED);
2728  |  else
2729  | 		btrfs_exclop_finish(fs_info);
2730  |  return ret;
2731  | }
2732  |
2733  | static long btrfs_ioctl_rm_dev_v2(struct file *file, void __user *arg)
2734  | {
2735  |  BTRFS_DEV_LOOKUP_ARGS(args);
2736  |  struct inode *inode = file_inode(file);
2737  |  struct btrfs_fs_info *fs_info = inode_to_fs_info(inode);
2738  |  struct btrfs_ioctl_vol_args_v2 *vol_args;
4601  |  goto out_acct;
4602  |  if (memchr_inv(args.reserved, 0, sizeof(args.reserved)))
4603  |  goto out_acct;
4604  |  if (args.compression == BTRFS_ENCODED_IO_COMPRESSION_NONE &&
4605  | 	    args.encryption == BTRFS_ENCODED_IO_ENCRYPTION_NONE)
4606  |  goto out_acct;
4607  |  if (args.compression >= BTRFS_ENCODED_IO_COMPRESSION_TYPES ||
4608  | 	    args.encryption >= BTRFS_ENCODED_IO_ENCRYPTION_TYPES)
4609  |  goto out_acct;
4610  |  if (args.unencoded_offset > args.unencoded_len)
4611  |  goto out_acct;
4612  |  if (args.len > args.unencoded_len - args.unencoded_offset)
4613  |  goto out_acct;
4614  |
4615  | 	ret = import_iovec(ITER_SOURCE, args.iov, args.iovcnt, ARRAY_SIZE(iovstack),
4616  | 			   &iov, &iter);
4617  |  if (ret < 0)
4618  |  goto out_acct;
4619  |
4620  |  if (iov_iter_count(&iter) == 0) {
4621  | 		ret = 0;
4622  |  goto out_iov;
4623  | 	}
4624  | 	pos = args.offset;
4625  | 	ret = rw_verify_area(WRITE, file, &pos, args.len);
4626  |  if (ret < 0)
4627  |  goto out_iov;
4628  |
4629  | 	init_sync_kiocb(&kiocb, file);
4630  | 	ret = kiocb_set_rw_flags(&kiocb, 0);
4631  |  if (ret)
4632  |  goto out_iov;
4633  | 	kiocb.ki_pos = pos;
4634  |
4635  | 	file_start_write(file);
4636  |
4637  | 	ret = btrfs_do_write_iter(&kiocb, &iter, &args);
4638  |  if (ret > 0)
4639  | 		fsnotify_modify(file);
4640  |
4641  | 	file_end_write(file);
4642  | out_iov:
4643  | 	kfree(iov);
4644  | out_acct:
4645  |  if (ret > 0)
4646  | 		add_wchar(current, ret);
4647  | 	inc_syscw(current);
4648  |  return ret;
4649  | }
4650  |
4651  | long btrfs_ioctl(struct file *file, unsigned int
4652  | 		cmd, unsigned long arg)
4653  | {
4654  |  struct inode *inode = file_inode(file);
4655  |  struct btrfs_fs_info *fs_info = inode_to_fs_info(inode);
4656  |  struct btrfs_root *root = BTRFS_I(inode)->root;
4657  |  void __user *argp = (void __user *)arg;
4658  |
4659  |  switch (cmd) {
    3←Control jumps to 'case 1342215178:'  at line 4692→
4660  |  case FS_IOC_GETVERSION:
4661  |  return btrfs_ioctl_getversion(inode, argp);
4662  |  case FS_IOC_GETFSLABEL:
4663  |  return btrfs_ioctl_get_fslabel(fs_info, argp);
4664  |  case FS_IOC_SETFSLABEL:
4665  |  return btrfs_ioctl_set_fslabel(file, argp);
4666  |  case FITRIM:
4667  |  return btrfs_ioctl_fitrim(fs_info, argp);
4668  |  case BTRFS_IOC_SNAP_CREATE:
4669  |  return btrfs_ioctl_snap_create(file, argp, 0);
4670  |  case BTRFS_IOC_SNAP_CREATE_V2:
4671  |  return btrfs_ioctl_snap_create_v2(file, argp, 0);
4672  |  case BTRFS_IOC_SUBVOL_CREATE:
4673  |  return btrfs_ioctl_snap_create(file, argp, 1);
4674  |  case BTRFS_IOC_SUBVOL_CREATE_V2:
4675  |  return btrfs_ioctl_snap_create_v2(file, argp, 1);
4676  |  case BTRFS_IOC_SNAP_DESTROY:
4677  |  return btrfs_ioctl_snap_destroy(file, argp, false);
4678  |  case BTRFS_IOC_SNAP_DESTROY_V2:
4679  |  return btrfs_ioctl_snap_destroy(file, argp, true);
4680  |  case BTRFS_IOC_SUBVOL_GETFLAGS:
4681  |  return btrfs_ioctl_subvol_getflags(inode, argp);
4682  |  case BTRFS_IOC_SUBVOL_SETFLAGS:
4683  |  return btrfs_ioctl_subvol_setflags(file, argp);
4684  |  case BTRFS_IOC_DEFAULT_SUBVOL:
4685  |  return btrfs_ioctl_default_subvol(file, argp);
4686  |  case BTRFS_IOC_DEFRAG:
4687  |  return btrfs_ioctl_defrag(file, NULL);
4688  |  case BTRFS_IOC_DEFRAG_RANGE:
4689  |  return btrfs_ioctl_defrag(file, argp);
4690  |  case BTRFS_IOC_RESIZE:
4691  |  return btrfs_ioctl_resize(file, argp);
4692  |  case BTRFS_IOC_ADD_DEV:
4693  |  return btrfs_ioctl_add_dev(fs_info, argp);
    4←Calling 'btrfs_ioctl_add_dev'→
4694  |  case BTRFS_IOC_RM_DEV:
4695  |  return btrfs_ioctl_rm_dev(file, argp);
4696  |  case BTRFS_IOC_RM_DEV_V2:
4697  |  return btrfs_ioctl_rm_dev_v2(file, argp);
4698  |  case BTRFS_IOC_FS_INFO:
4699  |  return btrfs_ioctl_fs_info(fs_info, argp);
4700  |  case BTRFS_IOC_DEV_INFO:
4701  |  return btrfs_ioctl_dev_info(fs_info, argp);
4702  |  case BTRFS_IOC_TREE_SEARCH:
4703  |  return btrfs_ioctl_tree_search(inode, argp);
4704  |  case BTRFS_IOC_TREE_SEARCH_V2:
4705  |  return btrfs_ioctl_tree_search_v2(inode, argp);
4706  |  case BTRFS_IOC_INO_LOOKUP:
4707  |  return btrfs_ioctl_ino_lookup(root, argp);
4708  |  case BTRFS_IOC_INO_PATHS:
4709  |  return btrfs_ioctl_ino_to_path(root, argp);
4710  |  case BTRFS_IOC_LOGICAL_INO:
4711  |  return btrfs_ioctl_logical_to_ino(fs_info, argp, 1);
4712  |  case BTRFS_IOC_LOGICAL_INO_V2:
4713  |  return btrfs_ioctl_logical_to_ino(fs_info, argp, 2);
4714  |  case BTRFS_IOC_SPACE_INFO:
4715  |  return btrfs_ioctl_space_info(fs_info, argp);
4716  |  case BTRFS_IOC_SYNC: {
4717  |  int ret;
4718  |
4719  | 		ret = btrfs_start_delalloc_roots(fs_info, LONG_MAX, false);
4720  |  if (ret)
4721  |  return ret;
4722  | 		ret = btrfs_sync_fs(inode->i_sb, 1);
4723  |  /*
4759  |  case BTRFS_IOC_GET_DEV_STATS:
4760  |  return btrfs_ioctl_get_dev_stats(fs_info, argp);
4761  |  case BTRFS_IOC_QUOTA_CTL:
4762  |  return btrfs_ioctl_quota_ctl(file, argp);
4763  |  case BTRFS_IOC_QGROUP_ASSIGN:
4764  |  return btrfs_ioctl_qgroup_assign(file, argp);
4765  |  case BTRFS_IOC_QGROUP_CREATE:
4766  |  return btrfs_ioctl_qgroup_create(file, argp);
4767  |  case BTRFS_IOC_QGROUP_LIMIT:
4768  |  return btrfs_ioctl_qgroup_limit(file, argp);
4769  |  case BTRFS_IOC_QUOTA_RESCAN:
4770  |  return btrfs_ioctl_quota_rescan(file, argp);
4771  |  case BTRFS_IOC_QUOTA_RESCAN_STATUS:
4772  |  return btrfs_ioctl_quota_rescan_status(fs_info, argp);
4773  |  case BTRFS_IOC_QUOTA_RESCAN_WAIT:
4774  |  return btrfs_ioctl_quota_rescan_wait(fs_info, argp);
4775  |  case BTRFS_IOC_DEV_REPLACE:
4776  |  return btrfs_ioctl_dev_replace(fs_info, argp);
4777  |  case BTRFS_IOC_GET_SUPPORTED_FEATURES:
4778  |  return btrfs_ioctl_get_supported_features(argp);
4779  |  case BTRFS_IOC_GET_FEATURES:
4780  |  return btrfs_ioctl_get_features(fs_info, argp);
4781  |  case BTRFS_IOC_SET_FEATURES:
4782  |  return btrfs_ioctl_set_features(file, argp);
4783  |  case BTRFS_IOC_GET_SUBVOL_INFO:
4784  |  return btrfs_ioctl_get_subvol_info(inode, argp);
4785  |  case BTRFS_IOC_GET_SUBVOL_ROOTREF:
4786  |  return btrfs_ioctl_get_subvol_rootref(root, argp);
4787  |  case BTRFS_IOC_INO_LOOKUP_USER:
4788  |  return btrfs_ioctl_ino_lookup_user(file, argp);
4789  |  case FS_IOC_ENABLE_VERITY:
4790  |  return fsverity_ioctl_enable(file, (const void __user *)argp);
4791  |  case FS_IOC_MEASURE_VERITY:
4792  |  return fsverity_ioctl_measure(file, argp);
4793  |  case BTRFS_IOC_ENCODED_READ:
4794  |  return btrfs_ioctl_encoded_read(file, argp, false);
4795  |  case BTRFS_IOC_ENCODED_WRITE:
4796  |  return btrfs_ioctl_encoded_write(file, argp, false);
4797  | #if defined(CONFIG_64BIT) && defined(CONFIG_COMPAT)
4798  |  case BTRFS_IOC_ENCODED_READ_32:
4799  |  return btrfs_ioctl_encoded_read(file, argp, true);
4800  |  case BTRFS_IOC_ENCODED_WRITE_32:
4801  |  return btrfs_ioctl_encoded_write(file, argp, true);
4802  | #endif
4803  | 	}
4804  |
4805  |  return -ENOTTY;
4806  | }
4807  |
4808  | #ifdef CONFIG_COMPAT
4809  | long btrfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
4810  | {
4811  |  /*
4812  |  * These all access 32-bit values anyway so no further
4813  |  * handling is necessary.
4814  |  */
4815  |  switch (cmd) {
4816  |  case FS_IOC32_GETVERSION:
4817  | 		cmd = FS_IOC_GETVERSION;
4818  |  break;
4819  | 	}
4820  |
4821  |  return btrfs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));
    1'Default' branch taken. Execution continues on line 4821→
    2←Calling 'btrfs_ioctl'→
4822  | }
4823  | #endif
