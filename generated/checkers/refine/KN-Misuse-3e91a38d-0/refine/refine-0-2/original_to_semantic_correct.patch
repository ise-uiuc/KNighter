--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -34,12 +34,17 @@   void checkPreCall(const CallEvent &Call, CheckerContext &C) const;

 private:
+  // Check if expression (ignoring parens/imp-casts) is a sizeof(...) expr.
   static bool isSizeofExpr(const Expr *E);
-  static const BinaryOperator *getMulWithSizeof(const Expr *E);

-  // Filter out known benign cases to avoid false positives.
+  // Return true if 'E' syntactically contains a multiplication with sizeof on
+  // one side. Do not traverse into sizeof(...) operands to avoid false hits.
+  static const BinaryOperator *findMulWithSizeof(const Expr *E);
+
+  // Filter out benign cases (e.g., plain sizeof(...) without multiplication).
   static bool isFalsePositive(const Expr *SizeArg);

+  // Recognize memdup_user (not memdup_user_nul etc.).
   static bool isMemdupUser(const CallEvent &Call);
 };

@@ -52,29 +57,74 @@   return false;
 }

-const BinaryOperator *SAGenTestChecker::getMulWithSizeof(const Expr *E) {
+// Helper: recursively search for a BinaryOperator '*' with one side a sizeof.
+// - Ignore parens/implicit casts.
+// - Do NOT traverse into sizeof(...) operands to avoid flagging patterns
+//   like sizeof(a*b).
+static const BinaryOperator *findMulWithSizeofRec(const Expr *E) {
   if (!E)
     return nullptr;
+
   E = E->IgnoreParenImpCasts();
-  const auto *BO = dyn_cast<BinaryOperator>(E);
-  if (!BO)
-    return nullptr;
-  if (BO->getOpcode() != BO_Mul)
+
+  // If we reached a sizeof(...) expression, do not look inside.
+  if (isa<UnaryExprOrTypeTraitExpr>(E))
     return nullptr;

-  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();
-  const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();
+  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+    if (BO->getOpcode() == BO_Mul) {
+      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();
+      const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();
+      if (isa<UnaryExprOrTypeTraitExpr>(LHS) ||
+          isa<UnaryExprOrTypeTraitExpr>(RHS)) {
+        const auto *UL = dyn_cast<UnaryExprOrTypeTraitExpr>(LHS);
+        const auto *UR = dyn_cast<UnaryExprOrTypeTraitExpr>(RHS);
+        if ((UL && UL->getKind() == UETT_SizeOf) ||
+            (UR && UR->getKind() == UETT_SizeOf)) {
+          return BO;
+        }
+      }
+    }
+    // Recurse into children (still respecting the "don't go inside sizeof" rule)
+    if (const BinaryOperator *Found = findMulWithSizeofRec(BO->getLHS()))
+      return Found;
+    if (const BinaryOperator *Found = findMulWithSizeofRec(BO->getRHS()))
+      return Found;
+    return nullptr;
+  }

-  if (isSizeofExpr(LHS) || isSizeofExpr(RHS))
-    return BO;
+  // Ternary operator
+  if (const auto *CO = dyn_cast<ConditionalOperator>(E)) {
+    if (const BinaryOperator *Found = findMulWithSizeofRec(CO->getTrueExpr()))
+      return Found;
+    if (const BinaryOperator *Found = findMulWithSizeofRec(CO->getFalseExpr()))
+      return Found;
+    return nullptr;
+  }

+  // Casts (already ignoring implicit; handle explicit as well)
+  if (const auto *CE = dyn_cast<CastExpr>(E)) {
+    return findMulWithSizeofRec(CE->getSubExpr());
+  }
+
+  // Generic traversal over children for any other Expr subclasses.
+  for (const Stmt *Child : E->children()) {
+    const auto *ChildE = dyn_cast_or_null<Expr>(Child);
+    if (!ChildE)
+      continue;
+    if (const auto *Found = findMulWithSizeofRec(ChildE))
+      return Found;
+  }
   return nullptr;
 }

+const BinaryOperator *SAGenTestChecker::findMulWithSizeof(const Expr *E) {
+  return findMulWithSizeofRec(E);
+}
+
 bool SAGenTestChecker::isFalsePositive(const Expr *SizeArg) {
-  // The primary false positive we observed: sizeof(*ptr) (no multiplication).
-  // If the size argument is a plain sizeof expression, it's not an array copy
-  // and memdup_user is the correct API.
+  // Suppress when the entire size arg is a plain sizeof(...) of anything.
+  // This covers the reported FP: memdup_user(arg, sizeof(*ldpc))
   return isSizeofExpr(SizeArg);
 }

@@ -86,7 +136,7 @@
 void SAGenTestChecker::checkPreCall(const CallEvent &Call,
                                     CheckerContext &C) const {
-  // Only interested in direct calls to memdup_user (not memdup_user_nul, etc.).
+  // Only interested in direct calls to memdup_user.
   if (!isMemdupUser(Call))
     return;

@@ -97,12 +147,13 @@   if (!SizeArg)
     return;

-  // Suppress plain sizeof(...) calls.
+  // Suppress plain sizeof(...) calls (dup of a single struct/object).
   if (isFalsePositive(SizeArg))
     return;

-  // Detect size expressions of the form count * sizeof(...).
-  const BinaryOperator *Mul = getMulWithSizeof(SizeArg);
+  // Find a multiplication with sizeof(...) anywhere in the size argument,
+  // but never inside a sizeof operand.
+  const BinaryOperator *Mul = findMulWithSizeof(SizeArg);
   if (!Mul)
     return;

@@ -115,7 +166,8 @@       "Use memdup_array_user(ptr, count, elem_size) instead of memdup_user(ptr, "
       "count * elem_size); multiplication may overflow.",
       N);
-  R->addRange(SizeArg->getSourceRange());
+  // Highlight just the multiplication subexpression for precision.
+  R->addRange(Mul->getSourceRange());
   C.emitReport(std::move(R));
 }
