--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -23,13 +23,22 @@ // Program state: track pointer-like storage regions that may come from "optional" getters.
 REGISTER_MAP_WITH_PROGRAMSTATE(OptionalPtrMap, const MemRegion*, unsigned)
 // Map the return symbol of optional getter calls; used to transfer tag on bind.
-REGISTER_MAP_WITH_PROGRAMSTATE(OptRetSymMap, SymbolRef, char)
+// Value encodes the OptionalOriginKind.
+REGISTER_MAP_WITH_PROGRAMSTATE(OptRetSymMap, SymbolRef, unsigned)
+// Track the origin kind for each tracked destination region (to validate type).
+REGISTER_MAP_WITH_PROGRAMSTATE(OptOriginKindMap, const MemRegion*, unsigned)

 namespace {

 static constexpr unsigned FromOptionalGetter = 1u;   // bit0
 static constexpr unsigned NullCheckedObserved = 2u;  // bit1
 static constexpr unsigned ErrCheckedObserved  = 4u;  // bit2
+
+enum OptionalOriginKind : unsigned {
+  OK_None = 0,
+  OK_GPIOD_ARRAY = 1, // e.g., devm_gpiod_get_array_optional
+  OK_GPIOD_DESC  = 2  // e.g., devm_gpiod_get_optional
+};

 class SAGenTestChecker : public Checker<
   check::PostCall,
@@ -50,7 +59,7 @@    private:

       // Helper predicates and state updaters
-      static bool isOptionalGetterExpr(const Expr *E, CheckerContext &C);
+      static OptionalOriginKind optionalGetterKindForCall(const CallEvent &Call);

       static bool isIS_ERR_Name(const Expr *E, CheckerContext &C);
       static bool isIS_ERR_OR_NULL_Name(const Expr *E, CheckerContext &C);
@@ -66,6 +75,14 @@
       // Only track genuine storage locations that can hold the optional pointer.
       static bool isTrackableStorageRegion(const MemRegion *R);
+      static bool isPointerLikeStorage(const MemRegion *R, CheckerContext &C);
+
+      // Validate and suppress spurious reports.
+      static bool isGPIODescLikeType(QualType QT);
+      static bool isConsistentWithOriginKind(OptionalOriginKind K, QualType PtrQT);
+      static const Expr *getPointerBaseExprFromDerefSite(const Stmt *DerefSite);
+
+      bool isFalsePositive(const MemRegion *Reg, const Stmt *DerefSite, CheckerContext &C) const;

       void reportDerefWithoutNullCheck(const Stmt *S, unsigned Flags, CheckerContext &C) const;
 };
@@ -83,12 +100,27 @@   return ExprText.contains(Name);
 }

-bool SAGenTestChecker::isOptionalGetterExpr(const Expr *E, CheckerContext &C) {
-  if (!E) return false;
-  return ExprHasName(E, "devm_gpiod_get_array_optional", C) ||
-         ExprHasName(E, "gpiod_get_array_optional", C)      ||
-         ExprHasName(E, "devm_gpiod_get_optional", C)       ||
-         ExprHasName(E, "gpiod_get_optional", C);
+static StringRef getCalleeName(const CallEvent &Call) {
+  if (const IdentifierInfo *ID = Call.getCalleeIdentifier())
+    return ID->getName();
+  return StringRef();
+}
+
+OptionalOriginKind SAGenTestChecker::optionalGetterKindForCall(const CallEvent &Call) {
+  StringRef Name = getCalleeName(Call);
+  if (Name.empty())
+    return OK_None;
+
+  // Precisely match well-known optional GPIO getters.
+  if (Name.equals("devm_gpiod_get_array_optional") ||
+      Name.equals("gpiod_get_array_optional"))
+    return OK_GPIOD_ARRAY;
+
+  if (Name.equals("devm_gpiod_get_optional") ||
+      Name.equals("gpiod_get_optional"))
+    return OK_GPIOD_DESC;
+
+  return OK_None;
 }

 bool SAGenTestChecker::isIS_ERR_Name(const Expr *E, CheckerContext &C) {
@@ -172,21 +204,110 @@   return isa<FieldRegion>(R) || isa<VarRegion>(R);
 }

+bool SAGenTestChecker::isPointerLikeStorage(const MemRegion *R, CheckerContext &C) {
+  if (!R) return false;
+  QualType T;
+  if (const auto *FR = dyn_cast<FieldRegion>(R))
+    T = FR->getDecl()->getType();
+  else if (const auto *VR = dyn_cast<VarRegion>(R))
+    T = VR->getValueType();
+  else
+    return false;
+
+  return !T.isNull() && T->isPointerType();
+}
+
+bool SAGenTestChecker::isGPIODescLikeType(QualType QT) {
+  if (QT.isNull())
+    return false;
+  if (!QT->isPointerType())
+    return false;
+
+  QualType Pointee = QT->getPointeeType();
+  if (const RecordType *RT = Pointee->getAs<RecordType>()) {
+    if (const RecordDecl *RD = RT->getDecl()) {
+      StringRef Name = RD->getName();
+      // Typical Linux types: 'gpio_desc' (single) and 'gpio_descs' (array).
+      return Name.contains_insensitive("gpio_desc");
+    }
+  }
+
+  // Fallback: textual check, safer than nothing
+  std::string S = Pointee.getAsString();
+  return StringRef(S).contains_insensitive("gpio_desc");
+}
+
+bool SAGenTestChecker::isConsistentWithOriginKind(OptionalOriginKind K, QualType PtrQT) {
+  if (K == OK_None)
+    return false; // must have known origin
+
+  if (!PtrQT->isPointerType())
+    return false;
+
+  // For now both GPIOD kinds point to gpio_desc or gpio_descs.
+  // If more origins are added, refine here.
+  return isGPIODescLikeType(PtrQT);
+}
+
+const Expr *SAGenTestChecker::getPointerBaseExprFromDerefSite(const Stmt *DerefSite) {
+  if (!DerefSite) return nullptr;
+
+  if (const auto *ME = dyn_cast<MemberExpr>(DerefSite)) {
+    if (ME->isArrow())
+      return ME->getBase()->IgnoreParenCasts();
+  }
+  if (const auto *UO = dyn_cast<UnaryOperator>(DerefSite)) {
+    if (UO->getOpcode() == UO_Deref)
+      return UO->getSubExpr()->IgnoreParenCasts();
+  }
+  if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(DerefSite)) {
+    return ASE->getBase()->IgnoreParenCasts();
+  }
+  return nullptr;
+}
+
+bool SAGenTestChecker::isFalsePositive(const MemRegion *Reg, const Stmt *DerefSite, CheckerContext &C) const {
+  if (!Reg || !DerefSite)
+    return true;
+
+  ProgramStateRef State = C.getState();
+  const unsigned *Flags = State->get<OptionalPtrMap>(Reg);
+  if (!Flags || !(*Flags & FromOptionalGetter))
+    return true;
+
+  const unsigned *KPtr = State->get<OptOriginKindMap>(Reg);
+  OptionalOriginKind K = KPtr ? static_cast<OptionalOriginKind>(*KPtr) : OK_None;
+  if (K == OK_None)
+    return true;
+
+  // Validate that the dereferenced expression is of a type consistent with origin.
+  const Expr *BaseE = getPointerBaseExprFromDerefSite(DerefSite);
+  if (!BaseE)
+    return true; // Not a dereference site we can reason about
+
+  QualType QT = BaseE->getType();
+  if (QT.isNull())
+    return true;
+
+  if (!isConsistentWithOriginKind(K, QT))
+    return true;
+
+  return false;
+}
+
 // -------- Callbacks --------

 void SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const {
-  const Expr *OriginExpr = Call.getOriginExpr();
-  if (!OriginExpr)
+  // Identify calls to known optional getters.
+  OptionalOriginKind K = optionalGetterKindForCall(Call);
+  if (K == OK_None)
     return;

-  // Identify calls to known optional getters.
-  if (isOptionalGetterExpr(OriginExpr, C)) {
-    SVal Ret = Call.getReturnValue();
-    if (SymbolRef Sym = Ret.getAsSymbol()) {
-      ProgramStateRef State = C.getState();
-      State = State->set<OptRetSymMap>(Sym, 1);
-      C.addTransition(State);
-    }
+  SVal Ret = Call.getReturnValue();
+  if (SymbolRef Sym = Ret.getAsSymbol()) {
+    ProgramStateRef State = C.getState();
+    State = State->set<OptRetSymMap>(Sym, static_cast<unsigned>(K));
+    C.addTransition(State);
   }
 }

@@ -200,33 +321,36 @@
   // Case A: Binding the return of an optional getter (tagged by symbol) into storage.
   if (SymbolRef Sym = Val.getAsSymbol()) {
-    if (State->get<OptRetSymMap>(Sym)) {
-      State = overwriteFlags(State, Dst, FromOptionalGetter);
+    if (const unsigned *KPtr = State->get<OptRetSymMap>(Sym)) {
+      OptionalOriginKind K = static_cast<OptionalOriginKind>(*KPtr);
+      // Only track pointer-typed storage.
+      if (isPointerLikeStorage(Dst, C)) {
+        State = overwriteFlags(State, Dst, FromOptionalGetter);
+        State = State->set<OptOriginKindMap>(Dst, static_cast<unsigned>(K));
+        Changed = true;
+      }
       State = State->remove<OptRetSymMap>(Sym);
-      Changed = true;
-    }
-  }
-
-  // Case B: Binding from another tracked storage region -> copy flags.
+    }
+  }
+
+  // Case B: Binding from another tracked storage region -> copy flags and origin kind.
   if (!Changed) {
     if (const MemRegion *Src = Val.getAsRegion()) {
       if (State->get<OptionalPtrMap>(Src)) {
         const unsigned *SrcFlags = State->get<OptionalPtrMap>(Src);
         State = overwriteFlags(State, Dst, *SrcFlags);
+        if (const unsigned *SrcK = State->get<OptOriginKindMap>(Src))
+          State = State->set<OptOriginKindMap>(Dst, *SrcK);
         Changed = true;
       }
     }
   }

-  // Note: Previously there was a broad "fallback" that marked any Dst when S
-  // contained an optional getter call. That caused false positives by tagging
-  // unrelated regions (e.g. function parameters used in the same statement).
-  // We intentionally do NOT do that here.
-
   // Any other assignment wipes prior tracking for Dst (fresh value not from optional getter).
   if (!Changed) {
-    if (State->get<OptionalPtrMap>(Dst)) {
+    if (State->get<OptionalPtrMap>(Dst) || State->get<OptOriginKindMap>(Dst)) {
       State = State->remove<OptionalPtrMap>(Dst);
+      State = State->remove<OptOriginKindMap>(Dst);
       Changed = true;
     }
   }
@@ -322,6 +446,10 @@   const Stmt *DerefSite = findDerefUseSiteForLoad(S, C);
   if (!DerefSite) return;

+  // Suppress if provenance/type validation fails.
+  if (isFalsePositive(LocReg, DerefSite, C))
+    return;
+
   if ((*Flags & FromOptionalGetter) && !(*Flags & NullCheckedObserved)) {
     reportDerefWithoutNullCheck(DerefSite, *Flags, C);
   }
