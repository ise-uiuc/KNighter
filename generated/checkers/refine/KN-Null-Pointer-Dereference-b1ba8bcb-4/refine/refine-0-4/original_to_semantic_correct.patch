--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -15,6 +15,7 @@ #include "clang/StaticAnalyzer/Checkers/utility.h"
 #include "clang/AST/Expr.h"
 #include "clang/AST/Stmt.h"
+#include "clang/Lex/Lexer.h"

 using namespace clang;
 using namespace ento;
@@ -67,7 +68,9 @@       static ProgramStateRef overwriteFlags(ProgramStateRef State, const MemRegion *Reg, unsigned Flags);
       static ProgramStateRef orFlags(ProgramStateRef State, const MemRegion *Reg, unsigned Mask);

-      const MemRegion *getTrackedRegionFromExpr(const Expr *E, CheckerContext &C, ProgramStateRef State) const;
+      // Get the tracked storage region (VarRegion/FieldRegion) for expression E, if any.
+      const MemRegion *getTrackedRegionFromExpr(const Expr *E, CheckerContext &C,
+                                                ProgramStateRef State) const;

       // AST helpers to determine dereference contexts.
       static bool nodeContains(const Stmt *Root, const Stmt *Query);
@@ -85,6 +88,9 @@       bool isFalsePositive(const MemRegion *Reg, const Stmt *DerefSite, CheckerContext &C) const;

       void reportDerefWithoutNullCheck(const Stmt *S, unsigned Flags, CheckerContext &C) const;
+
+      // New: Compute storage region for lvalue-like exprs (MemberExpr/DeclRefExpr).
+      const MemRegion *computeStorageRegionForExpr(const Expr *E, CheckerContext &C) const;
 };

 // -------- Helpers --------
@@ -145,12 +151,35 @@   return State->set<OptionalPtrMap>(Reg, NewFlags);
 }

+// Compute the storage region (VarRegion/FieldRegion) for an expression E,
+// when applicable. This is crucial to consistently match the same region
+// we track in checkBind (the lvalue storage), rather than the pointee region
+// or the rvalue symbol.
+const MemRegion *SAGenTestChecker::computeStorageRegionForExpr(const Expr *E, CheckerContext &C) const {
+  if (!E) return nullptr;
+  E = E->IgnoreParenCasts();
+
+  ProgramStateRef State = C.getState();
+
+  if (const auto *ME = dyn_cast<MemberExpr>(E)) {
+    SVal LV = State->getSVal(ME, C.getLocationContext());
+    return LV.getAsRegion();
+  }
+
+  if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {
+    SVal LV = State->getSVal(DRE, C.getLocationContext());
+    return LV.getAsRegion();
+  }
+
+  // Fall back to what the expression evaluates to.
+  return State->getSVal(E, C.getLocationContext()).getAsRegion();
+}
+
 const MemRegion *SAGenTestChecker::getTrackedRegionFromExpr(const Expr *E, CheckerContext &C, ProgramStateRef State) const {
   if (!E) return nullptr;
-  if (const MemRegion *MR = C.getState()->getSVal(E, C.getLocationContext()).getAsRegion()) {
-    if (State->get<OptionalPtrMap>(MR))
-      return MR;
-  }
+  const MemRegion *MR = computeStorageRegionForExpr(E, C);
+  if (MR && State->get<OptionalPtrMap>(MR))
+    return MR;
   return nullptr;
 }

@@ -342,6 +371,14 @@         if (const unsigned *SrcK = State->get<OptOriginKindMap>(Src))
           State = State->set<OptOriginKindMap>(Dst, *SrcK);
         Changed = true;
+      } else {
+        // If destination was previously tracked but now overwritten with an unrelated value,
+        // clear tracking to avoid stale flags.
+        if (State->get<OptionalPtrMap>(Dst) || State->get<OptOriginKindMap>(Dst)) {
+          State = State->remove<OptionalPtrMap>(Dst);
+          State = State->remove<OptOriginKindMap>(Dst);
+          Changed = true;
+        }
       }
     }
   }
