### Report Summary

File:| /scratch/chenyuan-data/linux-debug/drivers/pinctrl/pinctrl-mcp23s08.c
---|---
Warning:| line 140, column 21
Dereference of optional resource without NULL-check

### Annotated Source Code


88    | 	.max_register = MCP_OLAT,
89    | };
90    | EXPORT_SYMBOL_GPL(mcp23x08_regmap);
91    |
92    | static const struct reg_default mcp23x17_defaults[] = {
93    | 	{.reg = MCP_IODIR << 1,		.def = 0xffff},
94    | 	{.reg = MCP_IPOL << 1,		.def = 0x0000},
95    | 	{.reg = MCP_GPINTEN << 1,	.def = 0x0000},
96    | 	{.reg = MCP_DEFVAL << 1,	.def = 0x0000},
97    | 	{.reg = MCP_INTCON << 1,	.def = 0x0000},
98    | 	{.reg = MCP_IOCON << 1,		.def = 0x0000},
99    | 	{.reg = MCP_GPPU << 1,		.def = 0x0000},
100   | 	{.reg = MCP_OLAT << 1,		.def = 0x0000},
101   | };
102   |
103   | static const struct regmap_range mcp23x17_volatile_range = {
104   | 	.range_min = MCP_INTF << 1,
105   | 	.range_max = MCP_GPIO << 1,
106   | };
107   |
108   | static const struct regmap_access_table mcp23x17_volatile_table = {
109   | 	.yes_ranges = &mcp23x17_volatile_range,
110   | 	.n_yes_ranges = 1,
111   | };
112   |
113   | static const struct regmap_range mcp23x17_precious_range = {
114   | 	.range_min = MCP_INTCAP << 1,
115   | 	.range_max = MCP_GPIO << 1,
116   | };
117   |
118   | static const struct regmap_access_table mcp23x17_precious_table = {
119   | 	.yes_ranges = &mcp23x17_precious_range,
120   | 	.n_yes_ranges = 1,
121   | };
122   |
123   | const struct regmap_config mcp23x17_regmap = {
124   | 	.reg_bits = 8,
125   | 	.val_bits = 16,
126   |
127   | 	.reg_stride = 2,
128   | 	.max_register = MCP_OLAT << 1,
129   | 	.volatile_table = &mcp23x17_volatile_table,
130   | 	.precious_table = &mcp23x17_precious_table,
131   | 	.reg_defaults = mcp23x17_defaults,
132   | 	.num_reg_defaults = ARRAY_SIZE(mcp23x17_defaults),
133   | 	.cache_type = REGCACHE_FLAT,
134   | 	.val_format_endian = REGMAP_ENDIAN_LITTLE,
135   | };
136   | EXPORT_SYMBOL_GPL(mcp23x17_regmap);
137   |
138   | static int mcp_read(struct mcp23s08 *mcp, unsigned int reg, unsigned int *val)
139   | {
140   |  return regmap_read(mcp->regmap, reg << mcp->reg_shift, val);
    3←Dereference of optional resource without NULL-check
141   | }
142   |
143   | static int mcp_write(struct mcp23s08 *mcp, unsigned int reg, unsigned int val)
144   | {
145   |  return regmap_write(mcp->regmap, reg << mcp->reg_shift, val);
146   | }
147   |
148   | static int mcp_update_bits(struct mcp23s08 *mcp, unsigned int reg,
149   |  unsigned int mask, unsigned int val)
150   | {
151   |  return regmap_update_bits(mcp->regmap, reg << mcp->reg_shift,
152   | 				  mask, val);
153   | }
154   |
155   | static int mcp_set_bit(struct mcp23s08 *mcp, unsigned int reg,
156   |  unsigned int pin, bool enabled)
157   | {
158   | 	u16 mask = BIT(pin);
159   |  return mcp_update_bits(mcp, reg, mask, enabled ? mask : 0);
160   | }
161   |
162   | static const struct pinctrl_pin_desc mcp23x08_pins[] = {
163   |  PINCTRL_PIN(0, "gpio0"),
164   |  PINCTRL_PIN(1, "gpio1"),
165   |  PINCTRL_PIN(2, "gpio2"),
166   |  PINCTRL_PIN(3, "gpio3"),
167   |  PINCTRL_PIN(4, "gpio4"),
168   |  PINCTRL_PIN(5, "gpio5"),
169   |  PINCTRL_PIN(6, "gpio6"),
170   |  PINCTRL_PIN(7, "gpio7"),
538   | 	regcache_cache_only(mcp->regmap, false);
539   | 	regcache_sync(mcp->regmap);
540   |
541   | 	mutex_unlock(&mcp->lock);
542   | }
543   |
544   | static int mcp23s08_irq_setup(struct mcp23s08 *mcp)
545   | {
546   |  struct gpio_chip *chip = &mcp->chip;
547   |  int err;
548   |  unsigned long irqflags = IRQF_ONESHOT | IRQF_SHARED;
549   |
550   |  if (mcp->irq_active_high)
551   | 		irqflags |= IRQF_TRIGGER_HIGH;
552   |  else
553   | 		irqflags |= IRQF_TRIGGER_LOW;
554   |
555   | 	err = devm_request_threaded_irq(chip->parent, mcp->irq, NULL,
556   | 					mcp23s08_irq,
557   | 					irqflags, dev_name(chip->parent), mcp);
558   |  if (err != 0) {
559   |  dev_err(chip->parent, "unable to request IRQ#%d: %d\n",
560   |  mcp->irq, err);
561   |  return err;
562   | 	}
563   |
564   |  return 0;
565   | }
566   |
567   | static void mcp23s08_irq_print_chip(struct irq_data *d, struct seq_file *p)
568   | {
569   |  struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
570   |  struct mcp23s08 *mcp = gpiochip_get_data(gc);
571   |
572   | 	seq_printf(p, dev_name(mcp->dev));
573   | }
574   |
575   | static const struct irq_chip mcp23s08_irq_chip = {
576   | 	.irq_mask = mcp23s08_irq_mask,
577   | 	.irq_unmask = mcp23s08_irq_unmask,
578   | 	.irq_set_type = mcp23s08_irq_set_type,
579   | 	.irq_bus_lock = mcp23s08_irq_bus_lock,
580   | 	.irq_bus_sync_unlock = mcp23s08_irq_bus_unlock,
581   | 	.irq_print_chip = mcp23s08_irq_print_chip,
582   | 	.flags = IRQCHIP_IMMUTABLE,
583   |  GPIOCHIP_IRQ_RESOURCE_HELPERS,
584   | };
585   |
586   | /*----------------------------------------------------------------------*/
587   |
588   | int mcp23s08_probe_one(struct mcp23s08 *mcp, struct device *dev,
589   |  unsigned int addr, unsigned int type, unsigned int base)
590   | {
591   |  int status, ret;
592   | 	bool mirror = false;
593   |  bool open_drain = false;
594   |
595   |  mutex_init(&mcp->lock);
    1Loop condition is false.  Exiting loop→
596   |
597   |  mcp->dev = dev;
598   | 	mcp->addr = addr;
599   |
600   | 	mcp->irq_active_high = false;
601   |
602   | 	mcp->chip.direction_input = mcp23s08_direction_input;
603   | 	mcp->chip.get = mcp23s08_get;
604   | 	mcp->chip.get_multiple = mcp23s08_get_multiple;
605   | 	mcp->chip.direction_output = mcp23s08_direction_output;
606   | 	mcp->chip.set = mcp23s08_set;
607   | 	mcp->chip.set_multiple = mcp23s08_set_multiple;
608   |
609   | 	mcp->chip.base = base;
610   | 	mcp->chip.can_sleep = true;
611   | 	mcp->chip.parent = dev;
612   | 	mcp->chip.owner = THIS_MODULE;
613   |
614   | 	mcp->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
615   |
616   |  /* verify MCP_IOCON.SEQOP = 0, so sequential reads work,
617   |  * and MCP_IOCON.HAEN = 1, so we work with all chips.
618   |  */
619   |
620   |  ret = mcp_read(mcp, MCP_IOCON, &status);
    2←Calling 'mcp_read'→
621   |  if (ret < 0)
622   |  return dev_err_probe(dev, ret, "can't identify chip %d\n", addr);
623   |
624   | 	mcp->irq_controller =
625   | 		device_property_read_bool(dev, "interrupt-controller");
626   |  if (mcp->irq && mcp->irq_controller) {
627   | 		mcp->irq_active_high =
628   | 			device_property_read_bool(dev,
629   |  "microchip,irq-active-high");
630   |
631   | 		mirror = device_property_read_bool(dev, "microchip,irq-mirror");
632   | 		open_drain = device_property_read_bool(dev, "drive-open-drain");
633   | 	}
634   |
635   |  if ((status & IOCON_SEQOP) || !(status & IOCON_HAEN) || mirror ||
636   | 	     mcp->irq_active_high || open_drain) {
637   |  /* mcp23s17 has IOCON twice, make sure they are in sync */
638   | 		status &= ~(IOCON_SEQOP | (IOCON_SEQOP << 8));
639   | 		status |= IOCON_HAEN | (IOCON_HAEN << 8);
640   |  if (mcp->irq_active_high)
641   | 			status |= IOCON_INTPOL | (IOCON_INTPOL << 8);
642   |  else
643   | 			status &= ~(IOCON_INTPOL | (IOCON_INTPOL << 8));
644   |
645   |  if (mirror)
646   | 			status |= IOCON_MIRROR | (IOCON_MIRROR << 8);
647   |
648   |  if (open_drain)
649   | 			status |= IOCON_ODR | (IOCON_ODR << 8);
650   |
