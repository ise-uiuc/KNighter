--- original_code.cpp+++ semantic_correct_refine_code.cpp@@ -50,7 +50,6 @@    private:

       // Helper predicates and state updaters
-      static bool isOptionalGetterName(StringRef N);
       static bool isOptionalGetterExpr(const Expr *E, CheckerContext &C);

       static bool isIS_ERR_Name(const Expr *E, CheckerContext &C);
@@ -65,16 +64,23 @@       static bool nodeContains(const Stmt *Root, const Stmt *Query);
       const Stmt *findDerefUseSiteForLoad(const Stmt *S, CheckerContext &C) const;

+      // Only track genuine storage locations that can hold the optional pointer.
+      static bool isTrackableStorageRegion(const MemRegion *R);
+
       void reportDerefWithoutNullCheck(const Stmt *S, unsigned Flags, CheckerContext &C) const;
 };

 // -------- Helpers --------

-bool SAGenTestChecker::isOptionalGetterName(StringRef N) {
-  return N.equals("devm_gpiod_get_array_optional") ||
-         N.equals("gpiod_get_array_optional")      ||
-         N.equals("devm_gpiod_get_optional")       ||
-         N.equals("gpiod_get_optional");
+static bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C) {
+  if (!E)
+    return false;
+
+  const SourceManager &SM = C.getSourceManager();
+  const LangOptions &LangOpts = C.getLangOpts();
+  CharSourceRange Range = CharSourceRange::getTokenRange(E->getSourceRange());
+  StringRef ExprText = Lexer::getSourceText(Range, SM, LangOpts);
+  return ExprText.contains(Name);
 }

 bool SAGenTestChecker::isOptionalGetterExpr(const Expr *E, CheckerContext &C) {
@@ -109,11 +115,10 @@
 const MemRegion *SAGenTestChecker::getTrackedRegionFromExpr(const Expr *E, CheckerContext &C, ProgramStateRef State) const {
   if (!E) return nullptr;
-  const MemRegion *MR = getMemRegionFromExpr(E, C);
-  if (!MR) return nullptr;
-  // Important: do NOT collapse to base region. We want the exact storage (e.g., FieldRegion for lcd->im_pins).
-  if (State->get<OptionalPtrMap>(MR))
-    return MR;
+  if (const MemRegion *MR = C.getState()->getSVal(E, C.getLocationContext()).getAsRegion()) {
+    if (State->get<OptionalPtrMap>(MR))
+      return MR;
+  }
   return nullptr;
 }

@@ -160,6 +165,11 @@   }

   return nullptr;
+}
+
+bool SAGenTestChecker::isTrackableStorageRegion(const MemRegion *R) {
+  // Only track storage locations that represent real lvalues: fields or local/global vars.
+  return isa<FieldRegion>(R) || isa<VarRegion>(R);
 }

 // -------- Callbacks --------
@@ -183,6 +193,7 @@ void SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const {
   const MemRegion *Dst = Loc.getAsRegion();
   if (!Dst) return;
+  if (!isTrackableStorageRegion(Dst)) return;

   ProgramStateRef State = C.getState();
   bool Changed = false;
@@ -199,22 +210,18 @@   // Case B: Binding from another tracked storage region -> copy flags.
   if (!Changed) {
     if (const MemRegion *Src = Val.getAsRegion()) {
-      if (const unsigned *SrcFlags = State->get<OptionalPtrMap>(Src)) {
+      if (State->get<OptionalPtrMap>(Src)) {
+        const unsigned *SrcFlags = State->get<OptionalPtrMap>(Src);
         State = overwriteFlags(State, Dst, *SrcFlags);
         Changed = true;
       }
     }
   }

-  // Case C: Fallback - detect inline optional getter call on RHS syntactically.
-  if (!Changed && S) {
-    if (const auto *CE = findSpecificTypeInChildren<CallExpr>(S)) {
-      if (isOptionalGetterExpr(CE, C)) {
-        State = overwriteFlags(State, Dst, FromOptionalGetter);
-        Changed = true;
-      }
-    }
-  }
+  // Note: Previously there was a broad "fallback" that marked any Dst when S
+  // contained an optional getter call. That caused false positives by tagging
+  // unrelated regions (e.g. function parameters used in the same statement).
+  // We intentionally do NOT do that here.

   // Any other assignment wipes prior tracking for Dst (fresh value not from optional getter).
   if (!Changed) {
@@ -289,7 +296,6 @@
     // Truthiness: if (ptr)
     if (const MemRegion *MR = getTrackedRegionFromExpr(CondE, C, State)) {
-      // Heuristically treat as a NULL-check observation.
       State = orFlags(State, MR, NullCheckedObserved);
       Updated = true;
     }
@@ -307,6 +313,7 @@   ProgramStateRef State = C.getState();
   const MemRegion *LocReg = Loc.getAsRegion();
   if (!LocReg) return;
+  if (!isTrackableStorageRegion(LocReg)) return;

   const unsigned *Flags = State->get<OptionalPtrMap>(LocReg);
   if (!Flags) return;
