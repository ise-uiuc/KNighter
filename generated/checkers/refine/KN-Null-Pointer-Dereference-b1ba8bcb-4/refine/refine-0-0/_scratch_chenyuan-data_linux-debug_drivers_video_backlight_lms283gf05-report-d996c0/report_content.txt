### Report Summary

File:| /scratch/chenyuan-data/linux-debug/drivers/video/backlight/lms283gf05.c
---|---
Warning:| line 158, column 13
Dereference of optional resource without NULL-check

### Annotated Source Code


97    | 	gpiod_set_value(gpiod, 1); /* Asserted */
98    |  mdelay(20);
99    | 	gpiod_set_value(gpiod, 0); /* De-asserted */
100   |  mdelay(20);
101   | }
102   |
103   | static void lms283gf05_toggle(struct spi_device *spi,
104   |  const struct lms283gf05_seq *seq, int sz)
105   | {
106   |  char buf[3];
107   |  int i;
108   |
109   |  for (i = 0; i < sz; i++) {
110   | 		buf[0] = 0x74;
111   | 		buf[1] = 0x00;
112   | 		buf[2] = seq[i].reg;
113   | 		spi_write(spi, buf, 3);
114   |
115   | 		buf[0] = 0x76;
116   | 		buf[1] = seq[i].value >> 8;
117   | 		buf[2] = seq[i].value & 0xff;
118   | 		spi_write(spi, buf, 3);
119   |
120   |  mdelay(seq[i].delay);
121   | 	}
122   | }
123   |
124   | static int lms283gf05_power_set(struct lcd_device *ld, int power)
125   | {
126   |  struct lms283gf05_state *st = lcd_get_data(ld);
127   |  struct spi_device *spi = st->spi;
128   |
129   |  if (power <= FB_BLANK_NORMAL) {
130   |  if (st->reset)
131   | 			lms283gf05_reset(st->reset);
132   | 		lms283gf05_toggle(spi, disp_initseq, ARRAY_SIZE(disp_initseq));
133   | 	} else {
134   | 		lms283gf05_toggle(spi, disp_pdwnseq, ARRAY_SIZE(disp_pdwnseq));
135   |  if (st->reset)
136   | 			gpiod_set_value(st->reset, 1); /* Asserted */
137   | 	}
138   |
139   |  return 0;
140   | }
141   |
142   | static struct lcd_ops lms_ops = {
143   | 	.set_power	= lms283gf05_power_set,
144   | 	.get_power	= NULL,
145   | };
146   |
147   | static int lms283gf05_probe(struct spi_device *spi)
148   | {
149   |  struct lms283gf05_state *st;
150   |  struct lcd_device *ld;
151   |
152   | 	st = devm_kzalloc(&spi->dev, sizeof(struct lms283gf05_state),
153   |  GFP_KERNEL);
154   |  if (st == NULL)
    1Assuming 'st' is not equal to NULL→
    2←Taking false branch→
155   |  return -ENOMEM;
156   |
157   |  st->reset = gpiod_get_optional(&spi->dev, "reset", GPIOD_OUT_LOW);
158   |  if (IS_ERR(st->reset))
    3←Dereference of optional resource without NULL-check
159   |  return PTR_ERR(st->reset);
160   | 	gpiod_set_consumer_name(st->reset, "LMS283GF05 RESET");
161   |
162   | 	ld = devm_lcd_device_register(&spi->dev, "lms283gf05", &spi->dev, st,
163   | 					&lms_ops);
164   |  if (IS_ERR(ld))
165   |  return PTR_ERR(ld);
166   |
167   | 	st->spi = spi;
168   | 	st->ld = ld;
169   |
170   | 	spi_set_drvdata(spi, st);
171   |
172   |  /* kick in the LCD */
173   |  if (st->reset)
174   | 		lms283gf05_reset(st->reset);
175   | 	lms283gf05_toggle(spi, disp_initseq, ARRAY_SIZE(disp_initseq));
176   |
177   |  return 0;
178   | }
179   |
180   | static struct spi_driver lms283gf05_driver = {
181   | 	.driver = {
182   | 		.name	= "lms283gf05",
183   | 	},
184   | 	.probe		= lms283gf05_probe,
185   | };
186   |
187   | module_spi_driver(lms283gf05_driver);
188   |
