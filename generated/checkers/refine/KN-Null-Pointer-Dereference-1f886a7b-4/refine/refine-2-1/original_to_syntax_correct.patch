--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -17,10 +17,43 @@ #include "clang/AST/Expr.h"
 #include "clang/AST/Stmt.h"
 #include "clang/Lex/Lexer.h"
+#include "clang/Basic/Builtins.h"

 using namespace clang;
 using namespace ento;
 using namespace taint;
+
+// Utilities provided:
+/*
+// Going upward in an AST tree, and find the Stmt of a specific type
+template <typename T>
+const T* findSpecificTypeInParents(const Stmt *S, CheckerContext &C);
+
+// Going downward in an AST tree, and find the Stmt of a secific type
+// Only return one of the statements if there are many
+template <typename T>
+const T* findSpecificTypeInChildren(const Stmt *S);
+
+bool EvaluateExprToInt(llvm::APSInt &EvalRes, const Expr *expr, CheckerContext &C);
+
+const llvm::APSInt *inferSymbolMaxVal(SymbolRef Sym, CheckerContext &C);
+
+// The expression should be the DeclRefExpr of the array
+bool getArraySizeFromExpr(llvm::APInt &ArraySize, const Expr *E);
+
+bool getStringSize(llvm::APInt &StringSize, const Expr *E);
+
+const MemRegion* getMemRegionFromExpr(const Expr* E, CheckerContext &C);
+
+struct KnownDerefFunction {
+  const char *Name;
+  llvm::SmallVector<unsigned, 4> Params;
+};
+
+bool functionKnownToDeref(const CallEvent &Call, llvm::SmallVectorImpl<unsigned> &DerefParams);
+
+bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C);
+*/

 // Track unchecked symbols returned by devm_kzalloc.
 REGISTER_SET_WITH_PROGRAMSTATE(UncheckedDevmPtrSyms, SymbolRef)
@@ -45,6 +78,18 @@ private:
   // Extract the base pointer symbol that is being dereferenced by statement S.
   SymbolRef getDereferencedBaseSymbol(const Stmt *S, SVal Loc, CheckerContext &C) const;
+
+  // Unwrap common boolean wrappers (e.g., __builtin_expect from likely/unlikely).
+  const Expr *unwrapBooleanWrappers(const Expr *E) const;
+
+  // Try to extract a pointer symbol that is being null-checked in the given condition.
+  SymbolRef getSymbolFromNullCheckCond(const Expr *CondE, CheckerContext &C) const;
+
+  // Check whether the symbol is known to be non-null on the current path.
+  bool isProvenNonNull(SymbolRef Sym, CheckerContext &C) const;
+
+  // Best-effort additional guard to avoid reporting obvious false positives.
+  bool isFalsePositive(SymbolRef Sym, CheckerContext &C, const Stmt *S) const;

   void reportBug(CheckerContext &C, const Stmt *S) const;
 };
@@ -98,6 +143,135 @@   return nullptr;
 }

+const Expr *SAGenTestChecker::unwrapBooleanWrappers(const Expr *E) const {
+  if (!E)
+    return nullptr;
+
+  const Expr *Cur = E->IgnoreParenImpCasts();
+
+  // Unwrap __builtin_expect (commonly used by likely/unlikely macros).
+  while (const auto *CE = dyn_cast<CallExpr>(Cur)) {
+    Cur = Cur->IgnoreParenImpCasts();
+
+    const FunctionDecl *FD = CE->getDirectCallee();
+    if (!FD)
+      break;
+
+    if (FD->getBuiltinID() == Builtin::BI__builtin_expect) {
+      if (CE->getNumArgs() >= 1) {
+        Cur = CE->getArg(0)->IgnoreParenImpCasts();
+        continue; // Keep unwrapping, nested wrappers possible.
+      }
+    }
+    // Unknown call wrapper: stop unwrapping.
+    break;
+  }
+
+  return Cur->IgnoreParenImpCasts();
+}
+
+SymbolRef SAGenTestChecker::getSymbolFromNullCheckCond(const Expr *CondE, CheckerContext &C) const {
+  if (!CondE)
+    return nullptr;
+
+  const Expr *E = unwrapBooleanWrappers(CondE);
+  if (!E)
+    return nullptr;
+
+  ProgramStateRef State = C.getState();
+  const LocationContext *LCtx = C.getLocationContext();
+
+  // Handle: if (!ptr)
+  if (const auto *UO = dyn_cast<UnaryOperator>(E)) {
+    if (UO->getOpcode() == UO_LNot) {
+      const Expr *SubE = UO->getSubExpr();
+      if (SubE) {
+        SVal SV = State->getSVal(SubE, LCtx);
+        if (SymbolRef Sym = SV.getAsSymbol())
+          return Sym;
+        if (const MemRegion *MR = SV.getAsRegion()) {
+          MR = MR->getBaseRegion();
+          if (const auto *SR = dyn_cast<SymbolicRegion>(MR))
+            return SR->getSymbol();
+        }
+      }
+      return nullptr;
+    }
+  }
+
+  // Handle: if (ptr == NULL) or if (ptr != NULL)
+  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+    BinaryOperator::Opcode Op = BO->getOpcode();
+    if (Op == BO_EQ || Op == BO_NE) {
+      const Expr *LHS = BO->getLHS();
+      const Expr *RHS = BO->getRHS();
+      if (LHS && RHS) {
+        bool LHSIsNull = LHS->IgnoreParenImpCasts()->isNullPointerConstant(
+            C.getASTContext(), Expr::NPC_ValueDependentIsNull);
+        bool RHSIsNull = RHS->IgnoreParenImpCasts()->isNullPointerConstant(
+            C.getASTContext(), Expr::NPC_ValueDependentIsNull);
+        const Expr *PtrExpr = nullptr;
+        if (LHSIsNull && !RHSIsNull)
+          PtrExpr = RHS;
+        else if (RHSIsNull && !LHSIsNull)
+          PtrExpr = LHS;
+
+        if (PtrExpr) {
+          SVal SV = State->getSVal(PtrExpr, LCtx);
+          if (SymbolRef Sym = SV.getAsSymbol())
+            return Sym;
+          if (const MemRegion *MR = SV.getAsRegion()) {
+            MR = MR->getBaseRegion();
+            if (const auto *SR = dyn_cast<SymbolicRegion>(MR))
+              return SR->getSymbol();
+          }
+          return nullptr;
+        }
+      }
+    }
+  }
+
+  // Handle: if (ptr)
+  {
+    SVal SV = State->getSVal(E, LCtx);
+    if (SymbolRef Sym = SV.getAsSymbol())
+      return Sym;
+    if (const MemRegion *MR = SV.getAsRegion()) {
+      MR = MR->getBaseRegion();
+      if (const auto *SR = dyn_cast<SymbolicRegion>(MR))
+        return SR->getSymbol();
+    }
+  }
+
+  return nullptr;
+}
+
+bool SAGenTestChecker::isProvenNonNull(SymbolRef Sym, CheckerContext &C) const {
+  if (!Sym)
+    return false;
+
+  ProgramStateRef State = C.getState();
+  SValBuilder &SVB = C.getSValBuilder();
+
+  SVal SymSV = SVB.makeSymbolVal(Sym);
+  if (!SymSV.getAs<Loc>())
+    return false;
+
+  Loc NullLoc = SVB.makeZeroVal(C.getASTContext().VoidPtrTy).castAs<Loc>();
+  DefinedOrUnknownSVal EqNull = SVB.evalEQ(State, SymSV.castAs<Loc>(), NullLoc);
+  // If we cannot assume equal-to-null to be true, then null is impossible => proven non-null.
+  ProgramStateRef StateIfNull = State->assume(EqNull, true);
+  if (!StateIfNull)
+    return true;
+
+  return false;
+}
+
+bool SAGenTestChecker::isFalsePositive(SymbolRef Sym, CheckerContext &C, const Stmt * /*S*/) const {
+  // Currently, consider a dereference FP if the symbol is proven non-null on the path.
+  return isProvenNonNull(Sym, C);
+}
+
 void SAGenTestChecker::reportBug(CheckerContext &C, const Stmt *S) const {
   ExplodedNode *N = C.generateNonFatalErrorNode();
   if (!N)
@@ -115,7 +289,7 @@   if (!OriginExpr)
     return;

-  // Only track devm_kzalloc results.
+  // Only track devm_kzalloc results (heuristic textual check as provided).
   if (!ExprHasName(OriginExpr, "devm_kzalloc", C))
     return;

@@ -129,55 +303,16 @@
 void SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext &C) const {
   const Expr *CondE = dyn_cast_or_null<Expr>(Condition);
-  if (!CondE) {
-    return;
-  }
-
-  ProgramStateRef State = C.getState();
-  const LocationContext *LCtx = C.getLocationContext();
-  SymbolRef TargetSym = nullptr;
-
-  // Handle: if (!ptr)
-  if (const auto *UO = dyn_cast<UnaryOperator>(CondE)) {
-    if (UO->getOpcode() == UO_LNot) {
-      const Expr *SubE = UO->getSubExpr();
-      if (SubE) {
-        SVal SV = State->getSVal(SubE, LCtx);
-        TargetSym = SV.getAsSymbol();
-      }
-    }
-  }
-  // Handle: if (ptr == NULL) or if (ptr != NULL)
-  else if (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {
-    BinaryOperator::Opcode Op = BO->getOpcode();
-    if (Op == BO_EQ || Op == BO_NE) {
-      const Expr *LHS = BO->getLHS();
-      const Expr *RHS = BO->getRHS();
-      if (LHS && RHS) {
-        bool LHSIsNull = LHS->IgnoreParenImpCasts()->isNullPointerConstant(C.getASTContext(),
-                                         Expr::NPC_ValueDependentIsNull);
-        bool RHSIsNull = RHS->IgnoreParenImpCasts()->isNullPointerConstant(C.getASTContext(),
-                                         Expr::NPC_ValueDependentIsNull);
-        const Expr *PtrExpr = nullptr;
-        if (LHSIsNull && !RHSIsNull)
-          PtrExpr = RHS;
-        else if (RHSIsNull && !LHSIsNull)
-          PtrExpr = LHS;
-
-        if (PtrExpr) {
-          SVal SV = State->getSVal(PtrExpr, LCtx);
-          TargetSym = SV.getAsSymbol();
-        }
-      }
-    }
-  }
-  // Handle: if (ptr)
-  else {
-    SVal SV = State->getSVal(CondE, LCtx);
-    TargetSym = SV.getAsSymbol();
-  }
-
-  if (TargetSym && State->contains<UncheckedDevmPtrSyms>(TargetSym)) {
+  if (!CondE)
+    return;
+
+  SymbolRef TargetSym = getSymbolFromNullCheckCond(CondE, C);
+  if (!TargetSym)
+    return;
+
+  ProgramStateRef State = C.getState();
+  if (State->contains<UncheckedDevmPtrSyms>(TargetSym)) {
+    // Mark this devm_kzalloc result as checked once a null check appears.
     State = State->remove<UncheckedDevmPtrSyms>(TargetSym);
     C.addTransition(State);
   }
@@ -189,9 +324,14 @@     return;

   ProgramStateRef State = C.getState();
-  if (State->contains<UncheckedDevmPtrSyms>(BaseSym)) {
-    reportBug(C, S);
-  }
+  if (!State->contains<UncheckedDevmPtrSyms>(BaseSym))
+    return;
+
+  // Do not report if path constraints already prove non-null.
+  if (isFalsePositive(BaseSym, C, S))
+    return;
+
+  reportBug(C, S);
 }

 } // end anonymous namespace
