--- original_code.cpp+++ syntax_correct_refine_code.cpp@@ -46,8 +46,106 @@   // Extract the base pointer symbol that is being dereferenced by statement S.
   SymbolRef getDereferencedBaseSymbol(const Stmt *S, SVal Loc, CheckerContext &C) const;

+  // Helpers for finding null-checks embedded in conditions (including inside wrapper calls).
+  enum class CheckContext { ConditionTop, InsideCall };
+
+  SymbolRef getSymbolForExpr(const Expr *E, CheckerContext &C) const;
+
+  bool isNullPointerConstantExpr(const Expr *E, CheckerContext &C) const;
+
+  bool collectNullCheckSymbols(const Expr *E, CheckerContext &C,
+                               llvm::SmallVectorImpl<SymbolRef> &OutSyms,
+                               CheckContext Ctx) const;
+
   void reportBug(CheckerContext &C, const Stmt *S) const;
 };
+
+SymbolRef SAGenTestChecker::getSymbolForExpr(const Expr *E, CheckerContext &C) const {
+  if (!E)
+    return nullptr;
+  ProgramStateRef State = C.getState();
+  const LocationContext *LCtx = C.getLocationContext();
+  SVal SV = State->getSVal(E, LCtx);
+  if (SymbolRef Sym = SV.getAsSymbol())
+    return Sym;
+  if (const MemRegion *MR = SV.getAsRegion()) {
+    MR = MR->getBaseRegion();
+    if (const auto *SR = dyn_cast<SymbolicRegion>(MR))
+      return SR->getSymbol();
+  }
+  return nullptr;
+}
+
+bool SAGenTestChecker::isNullPointerConstantExpr(const Expr *E, CheckerContext &C) const {
+  if (!E) return false;
+  return E->IgnoreParenImpCasts()->isNullPointerConstant(
+      C.getASTContext(), Expr::NPC_ValueDependentIsNull);
+}
+
+bool SAGenTestChecker::collectNullCheckSymbols(const Expr *E, CheckerContext &C,
+                                               llvm::SmallVectorImpl<SymbolRef> &OutSyms,
+                                               CheckContext Ctx) const {
+  if (!E) return false;
+
+  E = E->IgnoreParenImpCasts();
+
+  // Pattern: !ptr or !(ptr == NULL) etc.
+  if (const auto *UO = dyn_cast<UnaryOperator>(E)) {
+    if (UO->getOpcode() == UO_LNot) {
+      // Recurse into the sub-expression; allow both direct pointer and comparisons.
+      return collectNullCheckSymbols(UO->getSubExpr(), C, OutSyms, Ctx);
+    }
+    // Other unary ops are not considered a null-check.
+    return false;
+  }
+
+  // Pattern: ptr == NULL or ptr != NULL
+  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {
+    BinaryOperator::Opcode Op = BO->getOpcode();
+    if (Op == BO_EQ || Op == BO_NE) {
+      const Expr *LHS = BO->getLHS();
+      const Expr *RHS = BO->getRHS();
+      if (LHS && RHS) {
+        bool LNull = isNullPointerConstantExpr(LHS, C);
+        bool RNull = isNullPointerConstantExpr(RHS, C);
+        const Expr *PtrExpr = nullptr;
+        if (LNull && !RNull) PtrExpr = RHS;
+        else if (RNull && !LNull) PtrExpr = LHS;
+
+        if (PtrExpr) {
+          if (SymbolRef Sym = getSymbolForExpr(PtrExpr, C)) {
+            OutSyms.push_back(Sym);
+            return true;
+          }
+        }
+      }
+    }
+    return false;
+  }
+
+  // Pattern: direct pointer used as condition (top-level only, e.g. if (ptr))
+  if (Ctx == CheckContext::ConditionTop) {
+    // Using a pointer in a boolean context counts as a check.
+    if (SymbolRef Sym = getSymbolForExpr(E, C)) {
+      OutSyms.push_back(Sym);
+      return true;
+    }
+  }
+
+  // Pattern: wrapper call in a condition, e.g. if (WARN_ON(!ptr)) or if (unlikely(!ptr))
+  if (const auto *CE = dyn_cast<CallExpr>(E)) {
+    bool Any = false;
+    // Only consider explicit null-check patterns in arguments.
+    for (const Expr *Arg : CE->arguments()) {
+      // Inside a call: be strict. Accept only explicit null-check shapes (!ptr, ptr == NULL).
+      Any |= collectNullCheckSymbols(Arg, C, OutSyms, CheckContext::InsideCall);
+    }
+    return Any;
+  }
+
+  // Not a recognized null-check pattern.
+  return false;
+}

 SymbolRef SAGenTestChecker::getDereferencedBaseSymbol(const Stmt *S, SVal Loc,
                                                       CheckerContext &C) const {
@@ -88,7 +186,7 @@     }
   }

-  // Fallback: derive from location region.
+  // Fallback: derive from location region (e.g., array/pointer indexing).
   if (const MemRegion *MR = Loc.getAsRegion()) {
     MR = MR->getBaseRegion();
     if (const auto *SR = dyn_cast<SymbolicRegion>(MR))
@@ -115,9 +213,13 @@   if (!OriginExpr)
     return;

-  // Only track devm_kzalloc results.
-  if (!ExprHasName(OriginExpr, "devm_kzalloc", C))
-    return;
+  // Only track devm_kzalloc results using callee identifier, not by source text.
+  if (const IdentifierInfo *ID = Call.getCalleeIdentifier()) {
+    if (ID->getName() != "devm_kzalloc")
+      return;
+  } else {
+    return;
+  }

   ProgramStateRef State = C.getState();
   SVal Ret = Call.getReturnValue();
@@ -129,58 +231,24 @@
 void SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext &C) const {
   const Expr *CondE = dyn_cast_or_null<Expr>(Condition);
-  if (!CondE) {
-    return;
-  }
-
-  ProgramStateRef State = C.getState();
-  const LocationContext *LCtx = C.getLocationContext();
-  SymbolRef TargetSym = nullptr;
-
-  // Handle: if (!ptr)
-  if (const auto *UO = dyn_cast<UnaryOperator>(CondE)) {
-    if (UO->getOpcode() == UO_LNot) {
-      const Expr *SubE = UO->getSubExpr();
-      if (SubE) {
-        SVal SV = State->getSVal(SubE, LCtx);
-        TargetSym = SV.getAsSymbol();
-      }
-    }
-  }
-  // Handle: if (ptr == NULL) or if (ptr != NULL)
-  else if (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {
-    BinaryOperator::Opcode Op = BO->getOpcode();
-    if (Op == BO_EQ || Op == BO_NE) {
-      const Expr *LHS = BO->getLHS();
-      const Expr *RHS = BO->getRHS();
-      if (LHS && RHS) {
-        bool LHSIsNull = LHS->IgnoreParenImpCasts()->isNullPointerConstant(C.getASTContext(),
-                                         Expr::NPC_ValueDependentIsNull);
-        bool RHSIsNull = RHS->IgnoreParenImpCasts()->isNullPointerConstant(C.getASTContext(),
-                                         Expr::NPC_ValueDependentIsNull);
-        const Expr *PtrExpr = nullptr;
-        if (LHSIsNull && !RHSIsNull)
-          PtrExpr = RHS;
-        else if (RHSIsNull && !LHSIsNull)
-          PtrExpr = LHS;
-
-        if (PtrExpr) {
-          SVal SV = State->getSVal(PtrExpr, LCtx);
-          TargetSym = SV.getAsSymbol();
-        }
-      }
-    }
-  }
-  // Handle: if (ptr)
-  else {
-    SVal SV = State->getSVal(CondE, LCtx);
-    TargetSym = SV.getAsSymbol();
-  }
-
-  if (TargetSym && State->contains<UncheckedDevmPtrSyms>(TargetSym)) {
-    State = State->remove<UncheckedDevmPtrSyms>(TargetSym);
+  if (!CondE)
+    return;
+
+  llvm::SmallVector<SymbolRef, 4> CheckedSyms;
+  // Collect any symbols that are being checked for null in the condition.
+  if (!collectNullCheckSymbols(CondE, C, CheckedSyms, CheckContext::ConditionTop))
+    return;
+
+  ProgramStateRef State = C.getState();
+  bool Changed = false;
+  for (SymbolRef S : CheckedSyms) {
+    if (S && State->contains<UncheckedDevmPtrSyms>(S)) {
+      State = State->remove<UncheckedDevmPtrSyms>(S);
+      Changed = true;
+    }
+  }
+  if (Changed)
     C.addTransition(State);
-  }
 }

 void SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const {
