### Report Summary

File:| drivers/clk/clk-loongson2.c
---|---
Warning:| line 282, column 26
devm_kzalloc() result may be NULL and is dereferenced without check

### Annotated Source Code


1     | // SPDX-License-Identifier: GPL-2.0+
2     | /*
3     |  * Author: Yinbo Zhu <zhuyinbo@loongson.cn>
4     |  * Copyright (C) 2022-2023 Loongson Technology Corporation Limited
5     |  */
6     |
7     | #include <linux/err.h>
8     | #include <linux/init.h>
9     | #include <linux/clk-provider.h>
10    | #include <linux/slab.h>
11    | #include <linux/module.h>
12    | #include <linux/platform_device.h>
13    | #include <linux/io-64-nonatomic-lo-hi.h>
14    | #include <dt-bindings/clock/loongson,ls2k-clk.h>
15    |
16    | #define LOONGSON2_PLL_MULT_SHIFT		32
17    | #define LOONGSON2_PLL_MULT_WIDTH		10
18    | #define LOONGSON2_PLL_DIV_SHIFT			26
19    | #define LOONGSON2_PLL_DIV_WIDTH			6
20    | #define LOONGSON2_APB_FREQSCALE_SHIFT		20
21    | #define LOONGSON2_APB_FREQSCALE_WIDTH		3
22    | #define LOONGSON2_USB_FREQSCALE_SHIFT		16
23    | #define LOONGSON2_USB_FREQSCALE_WIDTH		3
24    | #define LOONGSON2_SATA_FREQSCALE_SHIFT		12
25    | #define LOONGSON2_SATA_FREQSCALE_WIDTH		3
26    | #define LOONGSON2_BOOT_FREQSCALE_SHIFT		8
27    | #define LOONGSON2_BOOT_FREQSCALE_WIDTH		3
28    |
29    | static void __iomem *loongson2_pll_base;
30    |
31    | static const struct clk_parent_data pdata[] = {
32    | 	{ .fw_name = "ref_100m",},
33    | };
34    |
35    | static struct clk_hw *loongson2_clk_register(struct device *dev,
36    |  const char *name,
37    |  const char *parent_name,
38    |  const struct clk_ops *ops,
39    |  unsigned long flags)
40    | {
41    |  int ret;
42    |  struct clk_hw *hw;
43    |  struct clk_init_data init = { };
44    |
45    | 	hw = devm_kzalloc(dev, sizeof(*hw), GFP_KERNEL);
46    |  if (!hw)
47    |  return ERR_PTR(-ENOMEM);
48    |
49    | 	init.name = name;
50    | 	init.ops = ops;
51    | 	init.flags = flags;
52    | 	init.num_parents = 1;
53    |
54    |  if (!parent_name)
55    | 		init.parent_data = pdata;
56    |  else
57    | 		init.parent_names = &parent_name;
58    |
59    | 	hw->init = &init;
60    |
61    | 	ret = devm_clk_hw_register(dev, hw);
62    |  if (ret)
63    | 		hw = ERR_PTR(ret);
64    |
65    |  return hw;
66    | }
67    |
68    | static unsigned long loongson2_calc_pll_rate(int offset, unsigned long rate)
69    | {
70    | 	u64 val;
71    | 	u32 mult, div;
72    |
73    | 	val = readq(loongson2_pll_base + offset);
74    |
75    | 	mult = (val >> LOONGSON2_PLL_MULT_SHIFT) &
76    |  clk_div_mask(LOONGSON2_PLL_MULT_WIDTH);
77    | 	div = (val >> LOONGSON2_PLL_DIV_SHIFT) &
158   | static unsigned long loongson2_apb_recalc_rate(struct clk_hw *hw,
159   |  unsigned long parent_rate)
160   | {
161   |  return loongson2_calc_rate(parent_rate,
162   |  LOONGSON2_APB_FREQSCALE_SHIFT,
163   |  LOONGSON2_APB_FREQSCALE_WIDTH);
164   | }
165   |
166   | static const struct clk_ops loongson2_apb_clk_ops = {
167   | 	.recalc_rate = loongson2_apb_recalc_rate,
168   | };
169   |
170   | static unsigned long loongson2_usb_recalc_rate(struct clk_hw *hw,
171   |  unsigned long parent_rate)
172   | {
173   |  return loongson2_calc_rate(parent_rate,
174   |  LOONGSON2_USB_FREQSCALE_SHIFT,
175   |  LOONGSON2_USB_FREQSCALE_WIDTH);
176   | }
177   |
178   | static const struct clk_ops loongson2_usb_clk_ops = {
179   | 	.recalc_rate = loongson2_usb_recalc_rate,
180   | };
181   |
182   | static unsigned long loongson2_sata_recalc_rate(struct clk_hw *hw,
183   |  unsigned long parent_rate)
184   | {
185   |  return loongson2_calc_rate(parent_rate,
186   |  LOONGSON2_SATA_FREQSCALE_SHIFT,
187   |  LOONGSON2_SATA_FREQSCALE_WIDTH);
188   | }
189   |
190   | static const struct clk_ops loongson2_sata_clk_ops = {
191   | 	.recalc_rate = loongson2_sata_recalc_rate,
192   | };
193   |
194   | static inline int loongson2_check_clk_hws(struct clk_hw *clks[], unsigned int count)
195   | {
196   |  unsigned int i;
197   |
198   |  for (i = 0; i < count; i++)
199   |  if (IS_ERR(clks[i])) {
200   |  pr_err("Loongson2 clk %u: register failed with %ld\n",
201   |  i, PTR_ERR(clks[i]));
202   |  return PTR_ERR(clks[i]);
203   | 		}
204   |
205   |  return 0;
206   | }
207   |
208   | static int loongson2_clk_probe(struct platform_device *pdev)
209   | {
210   |  int ret;
211   |  struct clk_hw **hws;
212   |  struct clk_hw_onecell_data *clk_hw_data;
213   | 	spinlock_t loongson2_clk_lock;
214   |  struct device *dev = &pdev->dev;
215   |
216   | 	loongson2_pll_base = devm_platform_ioremap_resource(pdev, 0);
217   |  if (IS_ERR(loongson2_pll_base))
    1Taking false branch→
218   |  return PTR_ERR(loongson2_pll_base);
219   |
220   |  clk_hw_data = devm_kzalloc(dev, struct_size(clk_hw_data, hws, LOONGSON2_CLK_END),
221   |  GFP_KERNEL);
222   |  if (WARN_ON(!clk_hw_data))
    2←Assuming 'clk_hw_data' is non-null→
    3←Taking false branch→
    4←Taking false branch→
223   |  return -ENOMEM;
224   |
225   |  clk_hw_data->num = LOONGSON2_CLK_END;
226   | 	hws = clk_hw_data->hws;
227   |
228   | 	hws[LOONGSON2_NODE_PLL] = loongson2_clk_register(dev, "node_pll",
229   |  NULL,
230   | 						&loongson2_node_clk_ops, 0);
231   |
232   | 	hws[LOONGSON2_DDR_PLL] = loongson2_clk_register(dev, "ddr_pll",
233   |  NULL,
234   | 						&loongson2_ddr_clk_ops, 0);
235   |
236   | 	hws[LOONGSON2_DC_PLL] = loongson2_clk_register(dev, "dc_pll",
237   |  NULL,
238   | 						&loongson2_dc_clk_ops, 0);
239   |
240   | 	hws[LOONGSON2_PIX0_PLL] = loongson2_clk_register(dev, "pix0_pll",
241   |  NULL,
242   | 						&loongson2_pix0_clk_ops, 0);
243   |
244   | 	hws[LOONGSON2_PIX1_PLL] = loongson2_clk_register(dev, "pix1_pll",
245   |  NULL,
246   | 						&loongson2_pix1_clk_ops, 0);
247   |
248   | 	hws[LOONGSON2_BOOT_CLK] = loongson2_clk_register(dev, "boot",
249   |  NULL,
250   | 						&loongson2_boot_clk_ops, 0);
251   |
252   | 	hws[LOONGSON2_NODE_CLK] = devm_clk_hw_register_divider(dev, "node",
253   |  "node_pll", 0,
254   |  loongson2_pll_base + 0x8, 0,
255   |  6, CLK_DIVIDER_ONE_BASED,
256   |  &loongson2_clk_lock);
257   |
258   |  /*
259   |  * The hda clk divisor in the upper 32bits and the clk-prodiver
260   |  * layer code doesn't support 64bit io operation thus a conversion
261   |  * is required that subtract shift by 32 and add 4byte to the hda
262   |  * address
263   |  */
264   | 	hws[LOONGSON2_HDA_CLK] = devm_clk_hw_register_divider(dev, "hda",
265   |  "ddr_pll", 0,
266   |  loongson2_pll_base + 0x22, 12,
267   |  7, CLK_DIVIDER_ONE_BASED,
268   |  &loongson2_clk_lock);
269   |
270   | 	hws[LOONGSON2_GPU_CLK] = devm_clk_hw_register_divider(dev, "gpu",
271   |  "ddr_pll", 0,
272   |  loongson2_pll_base + 0x18, 22,
273   |  6, CLK_DIVIDER_ONE_BASED,
274   |  &loongson2_clk_lock);
275   |
276   | 	hws[LOONGSON2_DDR_CLK] = devm_clk_hw_register_divider(dev, "ddr",
277   |  "ddr_pll", 0,
278   |  loongson2_pll_base + 0x18, 0,
279   |  6, CLK_DIVIDER_ONE_BASED,
280   |  &loongson2_clk_lock);
281   |
282   |  hws[LOONGSON2_GMAC_CLK] = devm_clk_hw_register_divider(dev, "gmac",
    5←devm_kzalloc() result may be NULL and is dereferenced without check
283   |  "dc_pll", 0,
284   |  loongson2_pll_base + 0x28, 22,
285   |  6, CLK_DIVIDER_ONE_BASED,
286   |  &loongson2_clk_lock);
287   |
288   | 	hws[LOONGSON2_DC_CLK] = devm_clk_hw_register_divider(dev, "dc",
289   |  "dc_pll", 0,
290   |  loongson2_pll_base + 0x28, 0,
291   |  6, CLK_DIVIDER_ONE_BASED,
292   |  &loongson2_clk_lock);
293   |
294   | 	hws[LOONGSON2_APB_CLK] = loongson2_clk_register(dev, "apb",
295   |  "gmac",
296   | 						&loongson2_apb_clk_ops, 0);
297   |
298   | 	hws[LOONGSON2_USB_CLK] = loongson2_clk_register(dev, "usb",
299   |  "gmac",
300   | 						&loongson2_usb_clk_ops, 0);
301   |
302   | 	hws[LOONGSON2_SATA_CLK] = loongson2_clk_register(dev, "sata",
303   |  "gmac",
304   | 						&loongson2_sata_clk_ops, 0);
305   |
306   | 	hws[LOONGSON2_PIX0_CLK] = clk_hw_register_divider(NULL, "pix0",
307   |  "pix0_pll", 0,
308   |  loongson2_pll_base + 0x38, 0, 6,
309   |  CLK_DIVIDER_ONE_BASED,
310   |  &loongson2_clk_lock);
311   |
312   | 	hws[LOONGSON2_PIX1_CLK] = clk_hw_register_divider(NULL, "pix1",
