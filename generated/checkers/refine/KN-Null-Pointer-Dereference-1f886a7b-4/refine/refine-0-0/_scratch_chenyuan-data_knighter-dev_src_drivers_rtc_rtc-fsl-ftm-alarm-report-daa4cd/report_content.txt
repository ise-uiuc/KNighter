### Report Summary

File:| drivers/rtc/rtc-fsl-ftm-alarm.c
---|---
Warning:| line 259, column 13
devm_kzalloc() result may be NULL and is dereferenced without check

### Annotated Source Code


194   | /*
195   |  * 1. Select fixed frequency clock (32KHz) as clock source;
196   |  * 2. Select 128 (2^7) as divider factor;
197   |  * So clock is 250 Hz (32KHz/128).
198   |  *
199   |  * 3. FlexTimer's CNT register is a 32bit register,
200   |  * but the register's 16 bit as counter value,it's other 16 bit
201   |  * is reserved.So minimum counter value is 0x0,maximum counter
202   |  * value is 0xffff.
203   |  * So max alarm value is 262 (65536 / 250) seconds
204   |  */
205   | static int ftm_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
206   | {
207   | 	time64_t alm_time;
208   |  unsigned long long cycle;
209   |  struct ftm_rtc *rtc = dev_get_drvdata(dev);
210   |
211   | 	alm_time = rtc_tm_to_time64(&alm->time);
212   |
213   | 	ftm_clean_alarm(rtc);
214   | 	cycle = (alm_time - ktime_get_real_seconds()) * rtc->alarm_freq;
215   |  if (cycle > MAX_COUNT_VAL) {
216   |  pr_err("Out of alarm range {0~262} seconds.\n");
217   |  return -ERANGE;
218   | 	}
219   |
220   | 	ftm_irq_disable(rtc);
221   |
222   |  /*
223   |  * The counter increments until the value of MOD is reached,
224   |  * at which point the counter is reloaded with the value of CNTIN.
225   |  * The TOF (the overflow flag) bit is set when the FTM counter
226   |  * changes from MOD to CNTIN. So we should using the cycle - 1.
227   |  */
228   | 	rtc_writel(rtc, FTM_MOD, cycle - 1);
229   |
230   | 	ftm_counter_enable(rtc);
231   | 	ftm_irq_enable(rtc);
232   |
233   |  return 0;
234   |
235   | }
236   |
237   | static const struct rtc_class_ops ftm_rtc_ops = {
238   | 	.read_time		= ftm_rtc_read_time,
239   | 	.read_alarm		= ftm_rtc_read_alarm,
240   | 	.set_alarm		= ftm_rtc_set_alarm,
241   | 	.alarm_irq_enable	= ftm_rtc_alarm_irq_enable,
242   | };
243   |
244   | static int ftm_rtc_probe(struct platform_device *pdev)
245   | {
246   |  int irq;
247   |  int ret;
248   |  struct ftm_rtc *rtc;
249   |
250   | 	rtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);
251   |  if (unlikely(!rtc)) {
    1Assuming 'rtc' is non-null→
    2←Taking false branch→
252   |  dev_err(&pdev->dev, "cannot alloc memory for rtc\n");
253   |  return -ENOMEM;
254   | 	}
255   |
256   |  platform_set_drvdata(pdev, rtc);
257   |
258   | 	rtc->rtc_dev = devm_rtc_allocate_device(&pdev->dev);
259   |  if (IS_ERR(rtc->rtc_dev))
    3←devm_kzalloc() result may be NULL and is dereferenced without check
260   |  return PTR_ERR(rtc->rtc_dev);
261   |
262   | 	rtc->base = devm_platform_ioremap_resource(pdev, 0);
263   |  if (IS_ERR(rtc->base)) {
264   |  dev_err(&pdev->dev, "cannot ioremap resource for rtc\n");
265   |  return PTR_ERR(rtc->base);
266   | 	}
267   |
268   | 	irq = platform_get_irq(pdev, 0);
269   |  if (irq < 0)
270   |  return irq;
271   |
272   | 	ret = devm_request_irq(&pdev->dev, irq, ftm_rtc_alarm_interrupt,
273   | 			       0, dev_name(&pdev->dev), rtc);
274   |  if (ret < 0) {
275   |  dev_err(&pdev->dev, "failed to request irq\n");
276   |  return ret;
277   | 	}
278   |
279   | 	rtc->big_endian =
280   | 		device_property_read_bool(&pdev->dev, "big-endian");
281   |
282   | 	rtc->alarm_freq = (u32)FIXED_FREQ_CLK / (u32)MAX_FREQ_DIV;
283   | 	rtc->rtc_dev->ops = &ftm_rtc_ops;
284   |
285   | 	device_init_wakeup(&pdev->dev, true);
286   | 	ret = dev_pm_set_wake_irq(&pdev->dev, irq);
287   |  if (ret)
288   |  dev_err(&pdev->dev, "failed to enable irq wake\n");
289   |
