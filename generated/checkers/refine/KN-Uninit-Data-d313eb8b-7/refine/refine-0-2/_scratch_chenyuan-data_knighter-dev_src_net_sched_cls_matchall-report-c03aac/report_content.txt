### Report Summary

File:| net/sched/cls_matchall.c
---|---
Warning:| line 359, column 6
Copying partially initialized struct with padding to user; zero-initialize
before export

### Annotated Source Code


276   |  struct cls_mall_head *head = rtnl_dereference(tp->root);
277   |  struct tc_cls_matchall_offload cls_mall = {};
278   |  struct tcf_block *block = tp->chain->block;
279   |  int err;
280   |
281   |  if (tc_skip_hw(head->flags))
282   |  return 0;
283   |
284   | 	cls_mall.rule =	flow_rule_alloc(tcf_exts_num_actions(&head->exts));
285   |  if (!cls_mall.rule)
286   |  return -ENOMEM;
287   |
288   | 	tc_cls_common_offload_init(&cls_mall.common, tp, head->flags, extack);
289   | 	cls_mall.command = add ?
290   | 		TC_CLSMATCHALL_REPLACE : TC_CLSMATCHALL_DESTROY;
291   | 	cls_mall.cookie = (unsigned long)head;
292   |
293   | 	err = tc_setup_offload_action(&cls_mall.rule->action, &head->exts,
294   | 				      cls_mall.common.extack);
295   |  if (err) {
296   | 		kfree(cls_mall.rule);
297   |
298   |  return add && tc_skip_sw(head->flags) ? err : 0;
299   | 	}
300   |
301   | 	err = tc_setup_cb_reoffload(block, tp, add, cb, TC_SETUP_CLSMATCHALL,
302   | 				    &cls_mall, cb_priv, &head->flags,
303   | 				    &head->in_hw_count);
304   | 	tc_cleanup_offload_action(&cls_mall.rule->action);
305   | 	kfree(cls_mall.rule);
306   |
307   |  return err;
308   | }
309   |
310   | static void mall_stats_hw_filter(struct tcf_proto *tp,
311   |  struct cls_mall_head *head,
312   |  unsigned long cookie)
313   | {
314   |  struct tc_cls_matchall_offload cls_mall = {};
315   |  struct tcf_block *block = tp->chain->block;
316   |
317   | 	tc_cls_common_offload_init(&cls_mall.common, tp, head->flags, NULL);
318   | 	cls_mall.command = TC_CLSMATCHALL_STATS;
319   | 	cls_mall.cookie = cookie;
320   |
321   | 	tc_setup_cb_call(block, TC_SETUP_CLSMATCHALL, &cls_mall, false, true);
322   |
323   | 	tcf_exts_hw_stats_update(&head->exts, &cls_mall.stats, cls_mall.use_act_stats);
324   | }
325   |
326   | static int mall_dump(struct net *net, struct tcf_proto *tp, void *fh,
327   |  struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)
328   | {
329   |  struct tc_matchall_pcnt gpf = {};
330   |  struct cls_mall_head *head = fh;
331   |  struct nlattr *nest;
332   |  int cpu;
333   |
334   |  if (!head)
    1Assuming 'head' is non-null→
    2←Taking false branch→
335   |  return skb->len;
336   |
337   |  if (!tc_skip_hw(head->flags))
    3←Taking false branch→
338   | 		mall_stats_hw_filter(tp, head, (unsigned long)head);
339   |
340   |  t->tcm_handle = head->handle;
341   |
342   | 	nest = nla_nest_start_noflag(skb, TCA_OPTIONS);
343   |  if (!nest)
    4←Assuming 'nest' is non-null→
344   |  goto nla_put_failure;
345   |
346   |  if (head->res.classid &&
    5←Assuming field 'classid' is 0→
347   | 	    nla_put_u32(skb, TCA_MATCHALL_CLASSID, head->res.classid))
348   |  goto nla_put_failure;
349   |
350   |  if (head->flags && nla_put_u32(skb, TCA_MATCHALL_FLAGS, head->flags))
    6←Assuming field 'flags' is not equal to 0→
    7←Assuming the condition is false→
    8←Taking false branch→
351   |  goto nla_put_failure;
352   |
353   |  for_each_possible_cpu(cpu) {
    9←Assuming 'cpu' is >= 'nr_cpu_ids'→
    10←Loop condition is false. Execution continues on line 359→
354   |  struct tc_matchall_pcnt *pf = per_cpu_ptr(head->pf, cpu);
355   |
356   | 		gpf.rhit += pf->rhit;
357   | 	}
358   |
359   |  if (nla_put_64bit(skb, TCA_MATCHALL_PCNT,
    11←Copying partially initialized struct with padding to user; zero-initialize before export
360   |  sizeof(struct tc_matchall_pcnt),
361   |  &gpf, TCA_MATCHALL_PAD))
362   |  goto nla_put_failure;
363   |
364   |  if (tcf_exts_dump(skb, &head->exts))
365   |  goto nla_put_failure;
366   |
367   | 	nla_nest_end(skb, nest);
368   |
369   |  if (tcf_exts_dump_stats(skb, &head->exts) < 0)
370   |  goto nla_put_failure;
371   |
372   |  return skb->len;
373   |
374   | nla_put_failure:
375   | 	nla_nest_cancel(skb, nest);
376   |  return -1;
377   | }
378   |
379   | static void mall_bind_class(void *fh, u32 classid, unsigned long cl, void *q,
380   |  unsigned long base)
381   | {
382   |  struct cls_mall_head *head = fh;
383   |
384   | 	tc_cls_bind_class(classid, cl, q, &head->res, base);
385   | }
386   |
387   | static struct tcf_proto_ops cls_mall_ops __read_mostly = {
388   | 	.kind		= "matchall",
389   | 	.classify	= mall_classify,
390   | 	.init		= mall_init,
391   | 	.destroy	= mall_destroy,
