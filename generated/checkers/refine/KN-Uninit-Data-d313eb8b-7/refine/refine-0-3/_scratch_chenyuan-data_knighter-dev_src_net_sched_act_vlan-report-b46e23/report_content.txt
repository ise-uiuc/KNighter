### Report Summary

File:| net/sched/act_vlan.c
---|---
Warning:| line 303, column 6
Copying partially initialized struct with padding to user; zero-initialize
before export

### Annotated Source Code


236   | 	v = to_vlan(*a);
237   |
238   | 	p = kzalloc(sizeof(*p), GFP_KERNEL);
239   |  if (!p) {
240   | 		err = -ENOMEM;
241   |  goto put_chain;
242   | 	}
243   |
244   | 	p->tcfv_action = action;
245   | 	p->tcfv_push_vid = push_vid;
246   | 	p->tcfv_push_prio = push_prio;
247   | 	p->tcfv_push_prio_exists = push_prio_exists || action == TCA_VLAN_ACT_PUSH;
248   | 	p->tcfv_push_proto = push_proto;
249   |
250   |  if (action == TCA_VLAN_ACT_PUSH_ETH) {
251   | 		nla_memcpy(&p->tcfv_push_dst, tb[TCA_VLAN_PUSH_ETH_DST],
252   |  ETH_ALEN);
253   | 		nla_memcpy(&p->tcfv_push_src, tb[TCA_VLAN_PUSH_ETH_SRC],
254   |  ETH_ALEN);
255   | 	}
256   |
257   | 	spin_lock_bh(&v->tcf_lock);
258   | 	goto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);
259   | 	p = rcu_replace_pointer(v->vlan_p, p, lockdep_is_held(&v->tcf_lock));
260   | 	spin_unlock_bh(&v->tcf_lock);
261   |
262   |  if (goto_ch)
263   | 		tcf_chain_put_by_act(goto_ch);
264   |  if (p)
265   |  kfree_rcu(p, rcu);
266   |
267   |  return ret;
268   | put_chain:
269   |  if (goto_ch)
270   | 		tcf_chain_put_by_act(goto_ch);
271   | release_idr:
272   | 	tcf_idr_release(*a, bind);
273   |  return err;
274   | }
275   |
276   | static void tcf_vlan_cleanup(struct tc_action *a)
277   | {
278   |  struct tcf_vlan *v = to_vlan(a);
279   |  struct tcf_vlan_params *p;
280   |
281   | 	p = rcu_dereference_protected(v->vlan_p, 1);
282   |  if (p)
283   |  kfree_rcu(p, rcu);
284   | }
285   |
286   | static int tcf_vlan_dump(struct sk_buff *skb, struct tc_action *a,
287   |  int bind, int ref)
288   | {
289   |  unsigned char *b = skb_tail_pointer(skb);
290   |  struct tcf_vlan *v = to_vlan(a);
291   |  struct tcf_vlan_params *p;
292   |  struct tc_vlan opt = {
293   | 		.index    = v->tcf_index,
294   | 		.refcnt   = refcount_read(&v->tcf_refcnt) - ref,
295   | 		.bindcnt  = atomic_read(&v->tcf_bindcnt) - bind,
296   | 	};
297   |  struct tcf_t t;
298   |
299   | 	spin_lock_bh(&v->tcf_lock);
300   |  opt.action = v->tcf_action;
301   |  p = rcu_dereference_protected(v->vlan_p, lockdep_is_held(&v->tcf_lock));
    1Assuming the condition is false→
    2←Loop condition is false.  Exiting loop→
302   | 	opt.v_action = p->tcfv_action;
303   |  if (nla_put(skb, TCA_VLAN_PARMS, sizeof(opt), &opt))
    3←Copying partially initialized struct with padding to user; zero-initialize before export
304   |  goto nla_put_failure;
305   |
306   |  if ((p->tcfv_action == TCA_VLAN_ACT_PUSH ||
307   | 	     p->tcfv_action == TCA_VLAN_ACT_MODIFY) &&
308   | 	    (nla_put_u16(skb, TCA_VLAN_PUSH_VLAN_ID, p->tcfv_push_vid) ||
309   | 	     nla_put_be16(skb, TCA_VLAN_PUSH_VLAN_PROTOCOL,
310   | 			  p->tcfv_push_proto) ||
311   | 	     (p->tcfv_push_prio_exists &&
312   | 	      nla_put_u8(skb, TCA_VLAN_PUSH_VLAN_PRIORITY, p->tcfv_push_prio))))
313   |  goto nla_put_failure;
314   |
315   |  if (p->tcfv_action == TCA_VLAN_ACT_PUSH_ETH) {
316   |  if (nla_put(skb, TCA_VLAN_PUSH_ETH_DST, ETH_ALEN,
317   | 			    p->tcfv_push_dst))
318   |  goto nla_put_failure;
319   |  if (nla_put(skb, TCA_VLAN_PUSH_ETH_SRC, ETH_ALEN,
320   | 			    p->tcfv_push_src))
321   |  goto nla_put_failure;
322   | 	}
323   |
324   | 	tcf_tm_dump(&t, &v->tcf_tm);
325   |  if (nla_put_64bit(skb, TCA_VLAN_TM, sizeof(t), &t, TCA_VLAN_PAD))
326   |  goto nla_put_failure;
327   | 	spin_unlock_bh(&v->tcf_lock);
328   |
329   |  return skb->len;
330   |
331   | nla_put_failure:
332   | 	spin_unlock_bh(&v->tcf_lock);
333   | 	nlmsg_trim(skb, b);
