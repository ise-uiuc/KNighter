--- attempt_1_original.cpp+++ attempt_1.cpp@@ -17,6 +17,7 @@ #include "clang/AST/Decl.h"
 #include "clang/AST/Expr.h"
 #include "clang/AST/Type.h"
+#include "clang/AST/RecordLayout.h"
 #include "clang/Lex/Lexer.h"
 #include <memory>

@@ -27,6 +28,24 @@ // Program states
 REGISTER_MAP_WITH_PROGRAMSTATE(PartiallyInitAgg, const VarDecl*, char)
 REGISTER_SET_WITH_PROGRAMSTATE(ZeroCleared, const VarDecl*)
+
+// Utility functions provided by the prompt
+template <typename T>
+const T* findSpecificTypeInParents(const Stmt *S, CheckerContext &C);
+template <typename T>
+const T* findSpecificTypeInChildren(const Stmt *S);
+bool EvaluateExprToInt(llvm::APSInt &EvalRes, const Expr *expr, CheckerContext &C);
+const llvm::APSInt *inferSymbolMaxVal(SymbolRef Sym, CheckerContext &C);
+bool getArraySizeFromExpr(llvm::APInt &ArraySize, const Expr *E);
+bool getStringSize(llvm::APInt &StringSize, const Expr *E);
+const MemRegion* getMemRegionFromExpr(const Expr* E, CheckerContext &C);
+struct KnownDerefFunction {
+  const char *Name;
+  llvm::SmallVector<unsigned, 4> Params;
+};
+bool functionKnownToDeref(const CallEvent &Call,
+                          llvm::SmallVectorImpl<unsigned> &DerefParams);
+bool ExprHasName(const Expr *E, StringRef Name, CheckerContext &C);

 namespace {

@@ -55,8 +74,18 @@       enum ZeroKind { ZK_None = 0, ZK_Memset, ZK_MemzeroExplicit, ZK_Bzero };
       static ZeroKind getZeroingKind(const CallEvent &Call, unsigned &PtrIdx, unsigned &LenIdx, CheckerContext &C);

+      // Padding detection
+      static QualType unwrapArrayElementBaseType(QualType T);
+      static bool hasImplicitPadding(QualType QT, ASTContext &Ctx);
+
       void markZeroCleared(ProgramStateRef &State, const VarDecl *VD) const;
       void markPartiallyInit(ProgramStateRef &State, const VarDecl *VD) const;
+
+      // Additional helpers to eliminate false positives and strengthen matching
+      static bool calleeNameIs(const CallEvent &Call, StringRef Name);
+      static bool isBraceZeroInitializedVar(const VarDecl *VD);
+      static bool isExplicitZeroInitExpr(const Expr *E);
+      static bool isFalsePositive(const VarDecl *VD, CheckerContext &C);

       void reportLeak(const CallEvent &Call, CheckerContext &C) const;
 };
@@ -131,17 +160,22 @@     return LenVal >= VarSize;
   }

-  // Fallback: textual containment of variable name (captures sizeof(var) pattern)
-  return ExprHasName(LenExpr, VD->getName(), C);
+  // Fallback: textual containment of sizeof(var) pattern
+  if (ExprHasName(LenExpr, "sizeof", C) && ExprHasName(LenExpr, VD->getName(), C))
+    return true;
+
+  return false;
+}
+
+bool SAGenTestChecker::calleeNameIs(const CallEvent &Call, StringRef Name) {
+  if (const IdentifierInfo *ID = Call.getCalleeIdentifier())
+    return ID->getName() == Name;
+  return false;
 }

 bool SAGenTestChecker::isNetlinkExportCall(const CallEvent &Call, unsigned &LenIdx, unsigned &DataIdx, CheckerContext &C) {
-  const Expr *OriginExpr = Call.getOriginExpr();
-  if (!OriginExpr)
-    return false;
-
-  // Explicitly match known netlink export helpers we care about
-  if (ExprHasName(OriginExpr, "nla_put_64bit", C)) {
+  // Prefer identifier-based matching; fall back to source text as a last resort.
+  if (calleeNameIs(Call, "nla_put_64bit") || ExprHasName(Call.getOriginExpr(), "nla_put_64bit", C)) {
     // nla_put_64bit(skb, attrtype, len, data, padtype)
     if (Call.getNumArgs() >= 4) {
       LenIdx = 2;
@@ -150,7 +184,7 @@     }
     return false;
   }
-  if (ExprHasName(OriginExpr, "nla_put", C)) {
+  if (calleeNameIs(Call, "nla_put") || ExprHasName(Call.getOriginExpr(), "nla_put", C)) {
     // nla_put(skb, attrtype, len, data)
     if (Call.getNumArgs() >= 4) {
       LenIdx = 2;
@@ -164,12 +198,8 @@ }

 SAGenTestChecker::ZeroKind SAGenTestChecker::getZeroingKind(const CallEvent &Call, unsigned &PtrIdx, unsigned &LenIdx, CheckerContext &C) {
-  const Expr *OriginExpr = Call.getOriginExpr();
-  if (!OriginExpr)
-    return ZK_None;
-
   // memset(ptr, 0, len)
-  if (ExprHasName(OriginExpr, "memset", C)) {
+  if (calleeNameIs(Call, "memset") || ExprHasName(Call.getOriginExpr(), "memset", C)) {
     if (Call.getNumArgs() >= 3) {
       PtrIdx = 0;
       LenIdx = 2;
@@ -179,7 +209,7 @@   }

   // memzero_explicit(ptr, len)
-  if (ExprHasName(OriginExpr, "memzero_explicit", C)) {
+  if (calleeNameIs(Call, "memzero_explicit") || ExprHasName(Call.getOriginExpr(), "memzero_explicit", C)) {
     if (Call.getNumArgs() >= 2) {
       PtrIdx = 0;
       LenIdx = 1;
@@ -189,7 +219,7 @@   }

   // bzero(ptr, len)
-  if (ExprHasName(OriginExpr, "bzero", C)) {
+  if (calleeNameIs(Call, "bzero") || ExprHasName(Call.getOriginExpr(), "bzero", C)) {
     if (Call.getNumArgs() >= 2) {
       PtrIdx = 0;
       LenIdx = 1;
@@ -201,6 +231,100 @@   return ZK_None;
 }

+static QualType getElementTypeIfArray(QualType T) {
+  if (const auto *AT = dyn_cast<ArrayType>(T.getTypePtr()))
+    return AT->getElementType();
+  return QualType();
+}
+
+// Follow element types down to the base, so arrays of records delegate to the record.
+QualType SAGenTestChecker::unwrapArrayElementBaseType(QualType T) {
+  const Type *Ty = T.getTypePtr();
+  while (const auto *AT = dyn_cast<ArrayType>(Ty)) {
+    T = cast<ArrayType>(Ty)->getElementType();
+    Ty = T.getTypePtr();
+  }
+  return T;
+}
+
+// Precise padding detection using ASTRecordLayout and bit-level coverage:
+// - Computes gaps between the end of one field and the start of the next,
+//   using bitfield widths where applicable.
+// - Detects tail padding if total size in bits exceeds the end of the last field.
+// - Recurses into nested records and arrays of records.
+bool SAGenTestChecker::hasImplicitPadding(QualType QT, ASTContext &Ctx) {
+  QT = QT.getCanonicalType().getUnqualifiedType();
+
+  // If it's an array, check the base element type.
+  if (const auto *AT = dyn_cast<ArrayType>(QT.getTypePtr())) {
+    QualType ElemT = unwrapArrayElementBaseType(QT);
+    if (ElemT->isRecordType())
+      return hasImplicitPadding(ElemT, Ctx);
+    return false;
+  }
+
+  const RecordType *RT = QT->getAs<RecordType>();
+  if (!RT)
+    return false;
+
+  const RecordDecl *RD = RT->getDecl();
+  if (!RD)
+    return false;
+
+  RD = RD->getDefinition();
+  if (!RD)
+    return false;
+
+  if (RD->isUnion()) {
+    // Exporting an entire union object may copy bytes from inactive members.
+    return true;
+  }
+
+  const ASTRecordLayout &Layout = Ctx.getASTRecordLayout(RD);
+
+  uint64_t BitsCovered = 0;
+  unsigned Index = 0;
+
+  for (const FieldDecl *FD : RD->fields()) {
+    // Recurse into nested records/array-of-records
+    {
+      QualType Base = unwrapArrayElementBaseType(FD->getType());
+      if (Base->isRecordType() && hasImplicitPadding(Base, Ctx))
+        return true;
+    }
+
+    uint64_t Begin = Layout.getFieldOffset(Index);
+    // Compute the number of bits this field actually occupies in the layout.
+    uint64_t WidthBits = 0;
+    if (FD->isBitField()) {
+      const Expr *BW = FD->getBitWidth();
+      if (!BW)
+        return true; // conservative
+      if (BW->isValueDependent())
+        return true; // conservative
+      WidthBits = FD->getBitWidthValue(Ctx);
+    } else {
+      WidthBits = Ctx.getTypeSize(FD->getType());
+    }
+
+    if (Begin > BitsCovered)
+      return true; // gap (inter-field padding) detected
+
+    uint64_t End = Begin + WidthBits;
+    if (End > BitsCovered)
+      BitsCovered = End;
+
+    ++Index;
+  }
+
+  // Tail padding: total allocated size vs bits covered by fields.
+  uint64_t TotalSizeBits = Layout.getSize().getQuantity() * 8ULL;
+  if (TotalSizeBits > BitsCovered)
+    return true;
+
+  return false;
+}
+
 void SAGenTestChecker::markZeroCleared(ProgramStateRef &State, const VarDecl *VD) const {
   if (!VD) return;
   State = State->add<ZeroCleared>(VD);
@@ -212,6 +336,42 @@   State = State->set<PartiallyInitAgg>(VD, 1);
 }

+bool SAGenTestChecker::isExplicitZeroInitExpr(const Expr *E) {
+  if (!E) return false;
+  E = E->IgnoreParenImpCasts();
+  if (const auto *ILE = dyn_cast<InitListExpr>(E))
+    return isZeroBraceInit(ILE);
+  if (const auto *IL = dyn_cast<IntegerLiteral>(E))
+    return IL->getValue().isZero();
+  return false;
+}
+
+bool SAGenTestChecker::isBraceZeroInitializedVar(const VarDecl *VD) {
+  if (!VD) return false;
+  if (!VD->hasInit()) return false;
+  const Expr *Init = VD->getInit();
+  if (!Init) return false;
+  const Expr *I = Init->IgnoreImplicit();
+  if (const auto *ILE = dyn_cast<InitListExpr>(I))
+    return isZeroBraceInit(ILE);
+  // Very defensive: accept a single explicit 0 initializer
+  return isExplicitZeroInitExpr(I);
+}
+
+bool SAGenTestChecker::isFalsePositive(const VarDecl *VD, CheckerContext &C) {
+  // If the var was brace-zero-initialized ("{}" or "{0}"), it's fully zeroed,
+  // including padding. Exporting it is safe.
+  if (isBraceZeroInitializedVar(VD))
+    return true;
+
+  // Path-sensitive knowledge: if we've already marked it zero-cleared (via memset, etc.), it's safe.
+  ProgramStateRef State = C.getState();
+  if (State->contains<ZeroCleared>(VD))
+    return true;
+
+  return false;
+}
+
 /************ Checker Callbacks ************/

 void SAGenTestChecker::checkPostStmt(const DeclStmt *DS, CheckerContext &C) const {
@@ -239,18 +399,29 @@
     const Expr *I = Init->IgnoreImplicit();
     const auto *ILE = dyn_cast<InitListExpr>(I);
-    if (!ILE)
-      continue;
-
-    if (isNonZeroingInitList(ILE)) {
-      ProgramStateRef NewState = State->set<PartiallyInitAgg>(VD, 1);
+    if (!ILE) {
+      // If not an init-list, still record if it's equivalent to zero-init.
+      if (isExplicitZeroInitExpr(I)) {
+        ProgramStateRef NewState = State->add<ZeroCleared>(VD);
+        if (NewState != State) { State = NewState; Changed = true; }
+      }
+      continue;
+    }
+
+    // If zero-brace init, mark cleared regardless of padding.
+    if (isZeroBraceInit(ILE)) {
+      ProgramStateRef NewState = State->add<ZeroCleared>(VD);
       if (NewState != State) {
         State = NewState;
         Changed = true;
       }
-    } else {
-      // Zero brace init like {} or {0} considered cleared
-      ProgramStateRef NewState = State->add<ZeroCleared>(VD);
+      continue;
+    }
+
+    // Only interesting if the type actually has implicit padding.
+    if (isNonZeroingInitList(ILE) &&
+        hasImplicitPadding(VD->getType(), C.getASTContext())) {
+      ProgramStateRef NewState = State->set<PartiallyInitAgg>(VD, 1);
       if (NewState != State) {
         State = NewState;
         Changed = true;
@@ -309,13 +480,19 @@   if (!sizeofCoversVar(VD, LenE, C))
     return;

+  // If the record type has no implicit padding/holes, exporting it cannot leak
+  // uninitialized padding bytes. Do not warn.
+  if (!hasImplicitPadding(VD->getType(), C.getASTContext()))
+    return;
+
+  // Eliminate false positives where the aggregate is brace-zero-initialized
+  // (or otherwise known zeroed).
+  if (isFalsePositive(VD, C))
+    return;
+
   ProgramStateRef State = C.getState();

-  // If explicitly zero-cleared, it's safe
-  if (State->contains<ZeroCleared>(VD))
-    return;
-
-  // Warn only if we have evidence of risky partial init via init-list
+  // Warn only if we have evidence of risky partial init via init-list.
   if (!State->get<PartiallyInitAgg>(VD))
     return;
