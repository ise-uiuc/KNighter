_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 61c43780e9444123410cd48c2483e01d2b8f75e8
commit_type: Misuse
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Decl.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states are needed.\n\nnamespace {\n\
  \nclass SAGenTestChecker : public Checker<check::PostCall> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Wrong devlink\
  \ cmd in dump\",\n                       \"Linux Kernel API Misuse\")) {}\n\n  void\
  \ checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\nprivate:\n \
  \ static bool isDumpContext(const FunctionDecl *FD);\n};\n\nbool SAGenTestChecker::isDumpContext(const\
  \ FunctionDecl *FD) {\n  if (!FD)\n    return false;\n  StringRef Name = FD->getName();\n\
  \  // Heuristic: dump handlers in the kernel typically contain \"dump\" in the name\n\
  \  // (e.g., devlink_nl_port_get_dump_one, dumpit). This confines our check.\n \
  \ return Name.contains(\"dump\");\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call,\n                                     CheckerContext &C) const\
  \ {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return;\n\
  \n  // We only care about calls to devlink_nl_port_fill\n  if (!ExprHasName(Origin,\
  \ \"devlink_nl_port_fill\", C))\n    return;\n\n  // Ensure we are inside a dump-like\
  \ handler to avoid false positives\n  const auto *FD =\n      dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());\n\
  \  if (!isDumpContext(FD))\n    return;\n\n  // The 'cmd' argument is the 3rd arg\
  \ (index 2)\n  if (Call.getNumArgs() <= 2)\n    return;\n\n  const Expr *CmdArg\
  \ = Call.getArgExpr(2);\n  if (!CmdArg)\n    return;\n\n  // Detect misuse: DEVLINK_CMD_NEW\
  \ used instead of DEVLINK_CMD_PORT_NEW.\n  // Note: ExprHasName performs a substring\
  \ match, so we must ensure we do not\n  // match DEVLINK_CMD_PORT_NEW inadvertently.\n\
  \  bool UsesWrongCmd =\n      ExprHasName(CmdArg, \"DEVLINK_CMD_NEW\", C) &&\n \
  \     !ExprHasName(CmdArg, \"DEVLINK_CMD_PORT_NEW\", C);\n\n  if (!UsesWrongCmd)\n\
  \    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Wrong devlink cmd in dump: use DEVLINK_CMD_PORT_NEW\", N);\n  R->addRange(CmdArg->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects devlink port dump using DEVLINK_CMD_NEW\
  \ instead of DEVLINK_CMD_PORT_NEW\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndevlink: fix port dump cmd type\n\nUnlike other commands,\
  \ due to a c&p error, port dump fills-up cmd with\nwrong value, different from port-get\
  \ request cmd, port-get doit reply\nand port notification.\n\nFix it by filling\
  \ cmd with value DEVLINK_CMD_PORT_NEW.\n\nSkimmed through devlink userspace implementations,\
  \ none of them cares\nabout this cmd value. Only ynl, for which, this is actually\
  \ a fix, as it\nexpects doit and dumpit ops rsp_value to be the same.\n\nOmit the\
  \ fixes tag, even thought this is fix, better to target this for\nnext release.\n\
  \nFixes: bfcd3a466172 (\"Introduce devlink infrastructure\")\nSigned-off-by: Jiri\
  \ Pirko <jiri@nvidia.com>\nReviewed-by: Simon Horman <horms@kernel.org>\nReviewed-by:\
  \ Jakub Kicinski <kuba@kernel.org>\nLink: https://lore.kernel.org/r/20240220075245.75416-1-jiri@resnulli.us\n\
  Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ devlink_nl_port_get_dump_one in net/devlink/port.c\nstatic int\ndevlink_nl_port_get_dump_one(struct\
  \ sk_buff *msg, struct devlink *devlink,\n\t\t\t     struct netlink_callback *cb,\
  \ int flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\
  \tstruct devlink_port *devlink_port;\n\tunsigned long port_index;\n\tint err = 0;\n\
  \n\txa_for_each_start(&devlink->ports, port_index, devlink_port, state->idx) {\n\
  \t\terr = devlink_nl_port_fill(msg, devlink_port,\n\t\t\t\t\t   DEVLINK_CMD_NEW,\n\
  \t\t\t\t\t   NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, flags,\n\
  \t\t\t\t\t   cb->extack);\n\t\tif (err) {\n\t\t\tstate->idx = port_index;\n\t\t\t\
  break;\n\t\t}\n\t}\n\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff\
  \ --git a/net/devlink/port.c b/net/devlink/port.c\nindex 78592912f657..4b2d46ccfe48\
  \ 100644\n--- a/net/devlink/port.c\n+++ b/net/devlink/port.c\n@@ -583,7 +583,7 @@\
  \ devlink_nl_port_get_dump_one(struct sk_buff *msg, struct devlink *devlink,\n \n\
  \ \txa_for_each_start(&devlink->ports, port_index, devlink_port, state->idx) {\n\
  \ \t\terr = devlink_nl_port_fill(msg, devlink_port,\n-\t\t\t\t\t   DEVLINK_CMD_NEW,\n\
  +\t\t\t\t\t   DEVLINK_CMD_PORT_NEW,\n \t\t\t\t\t   NETLINK_CB(cb->skb).portid,\n\
  \ \t\t\t\t\t   cb->nlh->nlmsg_seq, flags,\n \t\t\t\t\t   cb->extack);\n```\n"
pattern: "## Bug Pattern\n\nPassing the wrong Netlink command identifier to a message-fill\
  \ function: using a generic DEVLINK_CMD_NEW instead of the object-specific DEVLINK_CMD_PORT_NEW\
  \ in dump responses, causing the dump reply\u2019s cmd to be inconsistent with the\
  \ corresponding get/doit replies and notifications. This copy\u2011paste mismatch\
  \ of cmd enums breaks userspace expectations that dump and doit use the same rsp_value."
plan: "1) Program state customization\n- No custom program state is needed. The pattern\
  \ is a local, syntactic misuse of the enum argument passed to a well-known fill\
  \ function inside a dump handler. We can detect it directly from the call site context.\n\
  \n2) Callback functions and detailed implementation\n\n- checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const\n  - Goal: Detect calls to devlink_nl_port_fill\
  \ inside dump handlers that pass the wrong cmd enum (DEVLINK_CMD_NEW instead of\
  \ DEVLINK_CMD_PORT_NEW).\n  - Steps:\n    1. Identify the target function:\n   \
  \    - Retrieve the callee identifier: if (const IdentifierInfo *II = Call.getCalleeIdentifier()).\n\
  \       - Check name equals \"devlink_nl_port_fill\". If not, return.\n    2. Ensure\
  \ we are inside a dump handler:\n       - Obtain the enclosing function: const auto\
  \ *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl()).\n   \
  \    - If no FD, return.\n       - Get function name: std::string FName = FD->getNameAsString().\n\
  \       - If FName does not contain substring \"dump\" (e.g., \u201Cdump\u201D,\
  \ \u201Cdumpit\u201D, \u201Cget_dump\u201D), return. This confines the checker to\
  \ dump contexts and avoids false positives in doit or notification paths.\n    3.\
  \ Inspect the cmd argument:\n       - The cmd argument is the 3rd argument of devlink_nl_port_fill,\
  \ i.e., index 2.\n       - Get the expression: const Expr *CmdArg = Call.getArgExpr(2).\n\
  \       - Determine if it is the wrong enum:\n         - Prefer robust name checks\
  \ using the provided utility: if (ExprHasName(CmdArg, \"DEVLINK_CMD_NEW\", C)).\n\
  \         - Optionally, for additional strictness, you may check that it is not\
  \ already the correct one: if (!ExprHasName(CmdArg, \"DEVLINK_CMD_PORT_NEW\", C))\
  \ \u2014 but the primary trigger is when it equals DEVLINK_CMD_NEW.\n    4. (Optional,\
  \ extra guard) Confirm dump-style arguments to the fill call:\n       - Check if\
  \ other arguments include typical dump constructs to further reduce false positives:\n\
  \         - Arg[3] or Arg[4] often contain NETLINK_CB(cb->skb).portid and cb->nlh->nlmsg_seq.\
  \ You can use ExprHasName on args[3] for \"NETLINK_CB\" or \"cb->\".\n       - If\
  \ these checks fail, you can still proceed if the function name filter matched \"\
  dump\".\n    5. Report the bug:\n       - Create a non-fatal error node: if (ExplodedNode\
  \ *N = C.generateNonFatalErrorNode()).\n       - Keep a static BugType instance,\
  \ e.g., static std::unique_ptr<BugType> BT = std::make_unique<BugType>(this, \"\
  Wrong devlink cmd in dump\", \"Linux Kernel API Misuse\");\n       - Create and\
  \ emit the report with a short message, attaching the range of CmdArg:\n       \
  \  - auto R = std::make_unique<PathSensitiveBugReport>(*BT, \"Wrong devlink cmd\
  \ in dump: use DEVLINK_CMD_PORT_NEW\", N);\n         - R->addRange(CmdArg->getSourceRange());\n\
  \         - C.emitReport(std::move(R)).\n\nNotes and rationale\n- We rely on function\
  \ name containment \u201Cdump\u201D to recognize dump handlers (e.g., devlink_nl_port_get_dump_one).\
  \ This mirrors the kernel naming convention and keeps the checker simple with minimal\
  \ false positives.\n- We match the exact misuse from the patch: passing DEVLINK_CMD_NEW\
  \ to devlink_nl_port_fill in a dump context. Userspace expects dump and doit rsp_value\
  \ to match; for ports this should be DEVLINK_CMD_PORT_NEW.\n- Using ExprHasName\
  \ is robust for matching enum constants like DEVLINK_CMD_NEW even under macro/enum\
  \ contexts, as suggested.\n- No alias or taint tracking is needed; the bug is localized\
  \ to a single call site."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Decl.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states are needed.\n\nnamespace {\n\
  \nclass SAGenTestChecker : public Checker<check::PostCall> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Wrong devlink\
  \ cmd in dump\",\n                       \"Linux Kernel API Misuse\")) {}\n\n  void\
  \ checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\nprivate:\n \
  \ static bool isDumpContext(const FunctionDecl *FD);\n};\n\nbool SAGenTestChecker::isDumpContext(const\
  \ FunctionDecl *FD) {\n  if (!FD)\n    return false;\n  StringRef Name = FD->getName();\n\
  \  // Heuristic: dump handlers in the kernel typically contain \"dump\" in the name\n\
  \  // (e.g., devlink_nl_port_get_dump_one, dumpit). This confines our check.\n \
  \ return Name.contains(\"dump\");\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call,\n                                     CheckerContext &C) const\
  \ {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return;\n\
  \n  // We only care about calls to devlink_nl_port_fill\n  if (!ExprHasName(Origin,\
  \ \"devlink_nl_port_fill\", C))\n    return;\n\n  // Ensure we are inside a dump-like\
  \ handler to avoid false positives\n  const auto *FD =\n      dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());\n\
  \  if (!isDumpContext(FD))\n    return;\n\n  // The 'cmd' argument is the 3rd arg\
  \ (index 2)\n  if (Call.getNumArgs() <= 2)\n    return;\n\n  const Expr *CmdArg\
  \ = Call.getArgExpr(2);\n  if (!CmdArg)\n    return;\n\n  // Detect misuse: DEVLINK_CMD_NEW\
  \ used instead of DEVLINK_CMD_PORT_NEW.\n  // Note: ExprHasName performs a substring\
  \ match, so we must ensure we do not\n  // match DEVLINK_CMD_PORT_NEW inadvertently.\n\
  \  bool UsesWrongCmd =\n      ExprHasName(CmdArg, \"DEVLINK_CMD_NEW\", C) &&\n \
  \     !ExprHasName(CmdArg, \"DEVLINK_CMD_PORT_NEW\", C);\n\n  if (!UsesWrongCmd)\n\
  \    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Wrong devlink cmd in dump: use DEVLINK_CMD_PORT_NEW\", N);\n  R->addRange(CmdArg->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects devlink port dump using DEVLINK_CMD_NEW\
  \ instead of DEVLINK_CMD_PORT_NEW\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
