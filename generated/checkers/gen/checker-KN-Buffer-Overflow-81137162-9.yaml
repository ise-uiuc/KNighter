_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 81137162bfaa7278785b24c1fd2e9e74f082e8e4
commit_type: Buffer-Overflow
index: 9
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states needed for this checker.\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n\
  \  SAGenTestChecker()\n      : BT(new BugType(this, \"Unbounded string copy into\
  \ fixed-size buffer\",\n                       \"Buffer Overflow\")) {}\n\n  void\
  \ checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\nprivate:\n  //\
  \ Helpers\n  bool isStrcpy(const CallEvent &Call, CheckerContext &C) const;\n  bool\
  \ getFixedArraySizeFromExpr(const Expr *E, uint64_t &Size,\n                   \
  \              CheckerContext &C) const;\n  bool getConstStringLen(const Expr *E,\
  \ uint64_t &Len) const;\n  void reportUnbounded(const CallEvent &Call, const Expr\
  \ *Dest,\n                       CheckerContext &C) const;\n  void reportPossibleOverflow(const\
  \ CallEvent &Call, const Expr *Dest,\n                              uint64_t DestCap,\
  \ uint64_t SrcLen,\n                              CheckerContext &C) const;\n};\n\
  \nbool SAGenTestChecker::isStrcpy(const CallEvent &Call,\n                     \
  \           CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n  return ExprHasName(OriginExpr, \"strcpy\"\
  , C);\n}\n\nbool SAGenTestChecker::getConstStringLen(const Expr *E, uint64_t &Len)\
  \ const {\n  if (!E)\n    return false;\n  llvm::APInt StrSize;\n  if (getStringSize(StrSize,\
  \ E)) {\n    Len = StrSize.getZExtValue();\n    return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::getFixedArraySizeFromExpr(const Expr *E,\n         \
  \                                        uint64_t &Size,\n                     \
  \                            CheckerContext &C) const {\n  if (!E)\n    return false;\n\
  \n  const Expr *EE = E->IgnoreParenImpCasts();\n\n  // Case 1: DeclRefExpr to a\
  \ constant array variable\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(EE)) {\n\
  \    llvm::APInt ArrSz;\n    if (getArraySizeFromExpr(ArrSz, DRE)) {\n      Size\
  \ = ArrSz.getZExtValue();\n      return true;\n    }\n    // Fallback: inspect the\
  \ variable type directly\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n      if (const auto *CAT =\n              C.getASTContext().getAsConstantArrayType(VD->getType()))\
  \ {\n        Size = CAT->getSize().getZExtValue();\n        return true;\n     \
  \ }\n    }\n  }\n\n  // Case 2: MemberExpr to a constant array field (e.g., di.name)\n\
  \  if (const auto *ME = dyn_cast<MemberExpr>(EE)) {\n    QualType QT = ME->getType();\n\
  \    if (const auto *CAT = C.getASTContext().getAsConstantArrayType(QT)) {\n   \
  \   Size = CAT->getSize().getZExtValue();\n      return true;\n    }\n    // Sometimes\
  \ the member type may be retrieved from the FieldDecl\n    if (const auto *FD =\
  \ dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n      if (const auto *CAT =\n   \
  \           C.getASTContext().getAsConstantArrayType(FD->getType())) {\n       \
  \ Size = CAT->getSize().getZExtValue();\n        return true;\n      }\n    }\n\
  \  }\n\n  // Case 3: ArraySubscriptExpr base\n  if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(EE))\
  \ {\n    const Expr *Base = ASE->getBase()->IgnoreParenImpCasts();\n    return getFixedArraySizeFromExpr(Base,\
  \ Size, C);\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::reportUnbounded(const\
  \ CallEvent &Call, const Expr *Dest,\n                                       CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Unbounded string copy into fixed-size buffer\", N);\n  if (const Expr *E = Call.getOriginExpr())\n\
  \    R->addRange(E->getSourceRange());\n  if (Dest)\n    R->addRange(Dest->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::reportPossibleOverflow(const\
  \ CallEvent &Call,\n                                              const Expr *Dest,\
  \ uint64_t DestCap,\n                                              uint64_t SrcLen,\n\
  \                                              CheckerContext &C) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto Msg = Twine(\"\
  strcpy may overflow fixed-size buffer (dest=\")\n                 .concat(Twine(DestCap))\n\
  \                 .concat(\", src_len=\")\n                 .concat(Twine(SrcLen))\n\
  \                 .concat(\")\")\n                 .str();\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  if (const Expr *E = Call.getOriginExpr())\n    R->addRange(E->getSourceRange());\n\
  \  if (Dest)\n    R->addRange(Dest->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call,\n              \
  \                      CheckerContext &C) const {\n  if (!isStrcpy(Call, C))\n \
  \   return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n  const Expr *DestE\
  \ = Call.getArgExpr(0);\n  const Expr *SrcE = Call.getArgExpr(1);\n  if (!DestE\
  \ || !SrcE)\n    return;\n\n  uint64_t DestCap = 0;\n  if (!getFixedArraySizeFromExpr(DestE,\
  \ DestCap, C)) {\n    // Only warn when destination is a known fixed-size array.\n\
  \    return;\n  }\n\n  uint64_t SrcLen = 0;\n  bool HasConstLen = getConstStringLen(SrcE,\
  \ SrcLen);\n\n  if (HasConstLen) {\n    // Definite overflow if source length >=\
  \ dest capacity (due to NUL).\n    if (SrcLen >= DestCap) {\n      reportPossibleOverflow(Call,\
  \ DestE, DestCap, SrcLen, C);\n    }\n    // Else safe; do nothing.\n  } else {\n\
  \    // Unbounded copy into a fixed-size array; warn.\n    reportUnbounded(Call,\
  \ DestE, C);\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects strcpy into fixed-size buffers; suggest bounded copy like strscpy\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: hci_core: Fix possible buffer overflow\n\
  \nstruct hci_dev_info has a fixed size name[8] field so in the event that\nhdev->name\
  \ is bigger than that strcpy would attempt to write past its\nsize, so this fixes\
  \ this problem by switching to use strscpy.\n\nFixes: dcda165706b9 (\"Bluetooth:\
  \ hci_core: Fix build warnings\")\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\n\
  \n## Buggy Code\n\n```c\n// Function: hci_get_dev_info in net/bluetooth/hci_core.c\n\
  int hci_get_dev_info(void __user *arg)\n{\n\tstruct hci_dev *hdev;\n\tstruct hci_dev_info\
  \ di;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (copy_from_user(&di, arg,\
  \ sizeof(di)))\n\t\treturn -EFAULT;\n\n\thdev = hci_dev_get(di.dev_id);\n\tif (!hdev)\n\
  \t\treturn -ENODEV;\n\n\t/* When the auto-off is configured it means the transport\n\
  \t * is running, but in that case still indicate that the\n\t * device is actually\
  \ down.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_AUTO_OFF))\n\t\tflags = hdev->flags\
  \ & ~BIT(HCI_UP);\n\telse\n\t\tflags = hdev->flags;\n\n\tstrcpy(di.name, hdev->name);\n\
  \tdi.bdaddr   = hdev->bdaddr;\n\tdi.type     = (hdev->bus & 0x0f) | ((hdev->dev_type\
  \ & 0x03) << 4);\n\tdi.flags    = flags;\n\tdi.pkt_type = hdev->pkt_type;\n\tif\
  \ (lmp_bredr_capable(hdev)) {\n\t\tdi.acl_mtu  = hdev->acl_mtu;\n\t\tdi.acl_pkts\
  \ = hdev->acl_pkts;\n\t\tdi.sco_mtu  = hdev->sco_mtu;\n\t\tdi.sco_pkts = hdev->sco_pkts;\n\
  \t} else {\n\t\tdi.acl_mtu  = hdev->le_mtu;\n\t\tdi.acl_pkts = hdev->le_pkts;\n\t\
  \tdi.sco_mtu  = 0;\n\t\tdi.sco_pkts = 0;\n\t}\n\tdi.link_policy = hdev->link_policy;\n\
  \tdi.link_mode   = hdev->link_mode;\n\n\tmemcpy(&di.stat, &hdev->stat, sizeof(di.stat));\n\
  \tmemcpy(&di.features, &hdev->features, sizeof(di.features));\n\n\tif (copy_to_user(arg,\
  \ &di, sizeof(di)))\n\t\terr = -EFAULT;\n\n\thci_dev_put(hdev);\n\n\treturn err;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c\n\
  index 6ca4c0df9f9c..230d2bbb933b 100644\n--- a/net/bluetooth/hci_core.c\n+++ b/net/bluetooth/hci_core.c\n\
  @@ -908,7 +908,7 @@ int hci_get_dev_info(void __user *arg)\n \telse\n \t\tflags\
  \ = hdev->flags;\n \n-\tstrcpy(di.name, hdev->name);\n+\tstrscpy(di.name, hdev->name,\
  \ sizeof(di.name));\n \tdi.bdaddr   = hdev->bdaddr;\n \tdi.type     = (hdev->bus\
  \ & 0x0f) | ((hdev->dev_type & 0x03) << 4);\n \tdi.flags    = flags;\n```\n"
pattern: "## Bug Pattern\n\nUnbounded string copy into a fixed-size buffer:\n- Copying\
  \ a potentially long runtime string into a struct field with a small, fixed-length\
  \ char array using strcpy (or other unbounded APIs), e.g.:\n  strcpy(dest_fixed[N],\
  \ src_variable);\n- This causes buffer overflow when src length >= N. The correct\
  \ pattern is to use a bounded copy (e.g., strscpy(dest, src, sizeof(dest))) or validate\
  \ length before copying."
plan: "Plan: Detect unbounded string copy into fixed-size buffers (strcpy into fixed-size\
  \ arrays)\n\n1) Program state customization\n- Not necessary for the core pattern.\
  \ We can detect the issue locally at the call site without path reasoning or alias\
  \ tracking.\n- Optional enhancement (last step) shows how to add a simple alias\
  \ map if you want to catch cases like char *p = di.name; strcpy(p, src); but keep\
  \ it out of the core minimal version.\n\n2) Callbacks to use\n- checkPreCall: Inspect\
  \ strcpy calls before they are evaluated, extract destination/source expressions,\
  \ compute destination capacity if it is a fixed-size array, and decide whether to\
  \ report.\n- No other callbacks are required for the basic checker.\n\n3) Helpers\
  \ to implement\n- bool isStrcpy(const CallEvent &Call)\n  - Return true when Call.getCalleeIdentifier()->getName()\
  \ == \"strcpy\".\n- bool getFixedArraySizeFromExpr(const Expr *E, uint64_t &Size,\
  \ CheckerContext &C)\n  - Goal: obtain a compile-time constant capacity of the destination\
  \ if it is a fixed-size array.\n  - Steps:\n    - E = E->IgnoreImpCasts()\n    -\
  \ If E is a DeclRefExpr that refers to a VarDecl of ConstantArrayType:\n      -\
  \ Use provided getArraySizeFromExpr(ArraySize, E). If true, Size = ArraySize.getZExtValue();\
  \ return true.\n    - If E is a MemberExpr (e.g., di.name):\n      - Fetch the FieldDecl\
  \ via ME->getMemberDecl(), get its QualType.\n      - If the type is ConstantArrayType,\
  \ read its size (getSize().getZExtValue()) into Size; return true.\n    - If E is\
  \ an ArraySubscriptExpr, inspect the base expression similarly (DeclRefExpr or MemberExpr)\
  \ to see if it is a ConstantArrayType and obtain the array\u2019s size.\n    - Otherwise,\
  \ return false (no known fixed bound).\n- bool getConstStringLen(const Expr *E,\
  \ uint64_t &Len)\n  - Use provided getStringSize(StringSize, E). If true, Len =\
  \ StringSize.getZExtValue(); return true. Otherwise return false.\n\n4) checkPreCall\
  \ implementation\n- Trigger conditions:\n  - If not isStrcpy(Call), return.\n  -\
  \ Let Dest = Call.getArgExpr(0), Src = Call.getArgExpr(1).\n- Determine destination\
  \ capacity:\n  - uint64_t DestCap; if !getFixedArraySizeFromExpr(Dest, DestCap,\
  \ C), return (we only warn when the destination is a known fixed-size array).\n\
  - Determine source length (if constant):\n  - uint64_t SrcLen; bool HasConstLen\
  \ = getConstStringLen(Src, SrcLen).\n- Decide if/what to report:\n  - Case A: HasConstLen\
  \ && SrcLen >= DestCap\n    - This is a definite overflow (strcpy copies SrcLen\
  \ bytes plus a NUL; if SrcLen >= DestCap, the NUL write overflows).\n    - Emit\
  \ a bug report:\n      - Message: \"strcpy may overflow fixed-size buffer\"\n  \
  \    - Add note/details in the message: \"dest capacity is DestCap; source length\
  \ is SrcLen\"\n  - Case B: !HasConstLen\n    - This is an unbounded copy into a\
  \ fixed-size buffer.\n    - Emit a bug report:\n      - Message: \"Unbounded string\
  \ copy into fixed-size buffer\"\n      - Optional note: \"Use strscpy(dest, src,\
  \ sizeof(dest)) or validate length\"\n  - Case C: HasConstLen && SrcLen < DestCap\n\
  \    - Safe; do nothing.\n- Reporting details:\n  - Use generateNonFatalErrorNode\
  \ to get the node N, and if N is non-null, create a PathSensitiveBugReport with\
  \ a short message as above.\n  - Attach the range of the call expression and highlight\
  \ the destination argument.\n  - Keep the message short and clear per the instruction.\n\
  \n5) Optional enhancement: alias tracking (only if you want to catch pointer aliases)\n\
  - Program state maps:\n  - REGISTER_MAP_WITH_PROGRAMSTATE(ArrayPtrSizeMap, const\
  \ MemRegion*, uint64_t)\n    - Maps a pointer variable\u2019s region to the fixed\
  \ capacity of the array it currently aliases.\n- checkBind:\n  - When a pointer\
  \ variable (LHS region) is bound to a value coming from a known fixed-size array\
  \ (RHS expression is DeclRefExpr/MemberExpr/ArraySubscriptExpr with ConstantArrayType),\
  \ record ArrayPtrSizeMap[LHSRegion] = Size.\n  - If LHS is reassigned to a non-array\
  \ or unknown source, remove LHSRegion from the map.\n  - To get the regions:\n \
  \   - LHS region: Loc.getAsRegion()\n    - RHS size: try to recover the RHS expression\
  \ from S if possible (BinaryOperator or VarDecl init), or when not available, attempt\
  \ to derive from Val.getAsRegion() (e.g., a FieldRegion) and inspect its type for\
  \ ConstantArrayType.\n- checkPreCall (extended):\n  - If getFixedArraySizeFromExpr(Dest,\
  \ ...) fails:\n    - Fetch the MemRegion of Dest via getMemRegionFromExpr(Dest,\
  \ C). If found and exists in ArrayPtrSizeMap, treat that as DestCap and proceed\
  \ with the same logic as above.\n\n6) Notes and constraints\n- Prefer minimal false\
  \ positives:\n  - Only warn when the destination is a proven fixed-size array.\n\
  \  - Do not warn when the source is a constant string literal that is strictly shorter\
  \ than the destination capacity.\n- Keep messages short and actionable:\n  - Primary:\
  \ \"Unbounded string copy into fixed-size buffer\"\n  - For definite overflow: \"\
  strcpy may overflow fixed-size buffer\"\n- This checker directly covers the target\
  \ patch pattern: strcpy(di.name, hdev->name) where di.name is a fixed-size array\
  \ (e.g., char name[8]). The fix suggested by the kernel patch aligns with our note\
  \ recommending strscpy with sizeof(dest)."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states needed for this checker.\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n\
  \  SAGenTestChecker()\n      : BT(new BugType(this, \"Unbounded string copy into\
  \ fixed-size buffer\",\n                       \"Buffer Overflow\")) {}\n\n  void\
  \ checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\nprivate:\n  //\
  \ Helpers\n  bool isStrcpy(const CallEvent &Call, CheckerContext &C) const;\n  bool\
  \ getFixedArraySizeFromExpr(const Expr *E, uint64_t &Size,\n                   \
  \              CheckerContext &C) const;\n  bool getConstStringLen(const Expr *E,\
  \ uint64_t &Len) const;\n  void reportUnbounded(const CallEvent &Call, const Expr\
  \ *Dest,\n                       CheckerContext &C) const;\n  void reportPossibleOverflow(const\
  \ CallEvent &Call, const Expr *Dest,\n                              uint64_t DestCap,\
  \ uint64_t SrcLen,\n                              CheckerContext &C) const;\n};\n\
  \nbool SAGenTestChecker::isStrcpy(const CallEvent &Call,\n                     \
  \           CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n  return ExprHasName(OriginExpr, \"strcpy\"\
  , C);\n}\n\nbool SAGenTestChecker::getConstStringLen(const Expr *E, uint64_t &Len)\
  \ const {\n  if (!E)\n    return false;\n  llvm::APInt StrSize;\n  if (getStringSize(StrSize,\
  \ E)) {\n    Len = StrSize.getZExtValue();\n    return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::getFixedArraySizeFromExpr(const Expr *E,\n         \
  \                                        uint64_t &Size,\n                     \
  \                            CheckerContext &C) const {\n  if (!E)\n    return false;\n\
  \n  const Expr *EE = E->IgnoreParenImpCasts();\n\n  // Case 1: DeclRefExpr to a\
  \ constant array variable\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(EE)) {\n\
  \    llvm::APInt ArrSz;\n    if (getArraySizeFromExpr(ArrSz, DRE)) {\n      Size\
  \ = ArrSz.getZExtValue();\n      return true;\n    }\n    // Fallback: inspect the\
  \ variable type directly\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n      if (const auto *CAT =\n              C.getASTContext().getAsConstantArrayType(VD->getType()))\
  \ {\n        Size = CAT->getSize().getZExtValue();\n        return true;\n     \
  \ }\n    }\n  }\n\n  // Case 2: MemberExpr to a constant array field (e.g., di.name)\n\
  \  if (const auto *ME = dyn_cast<MemberExpr>(EE)) {\n    QualType QT = ME->getType();\n\
  \    if (const auto *CAT = C.getASTContext().getAsConstantArrayType(QT)) {\n   \
  \   Size = CAT->getSize().getZExtValue();\n      return true;\n    }\n    // Sometimes\
  \ the member type may be retrieved from the FieldDecl\n    if (const auto *FD =\
  \ dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n      if (const auto *CAT =\n   \
  \           C.getASTContext().getAsConstantArrayType(FD->getType())) {\n       \
  \ Size = CAT->getSize().getZExtValue();\n        return true;\n      }\n    }\n\
  \  }\n\n  // Case 3: ArraySubscriptExpr base\n  if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(EE))\
  \ {\n    const Expr *Base = ASE->getBase()->IgnoreParenImpCasts();\n    return getFixedArraySizeFromExpr(Base,\
  \ Size, C);\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::reportUnbounded(const\
  \ CallEvent &Call, const Expr *Dest,\n                                       CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Unbounded string copy into fixed-size buffer\", N);\n  if (const Expr *E = Call.getOriginExpr())\n\
  \    R->addRange(E->getSourceRange());\n  if (Dest)\n    R->addRange(Dest->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::reportPossibleOverflow(const\
  \ CallEvent &Call,\n                                              const Expr *Dest,\
  \ uint64_t DestCap,\n                                              uint64_t SrcLen,\n\
  \                                              CheckerContext &C) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto Msg = Twine(\"\
  strcpy may overflow fixed-size buffer (dest=\")\n                 .concat(Twine(DestCap))\n\
  \                 .concat(\", src_len=\")\n                 .concat(Twine(SrcLen))\n\
  \                 .concat(\")\")\n                 .str();\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  if (const Expr *E = Call.getOriginExpr())\n    R->addRange(E->getSourceRange());\n\
  \  if (Dest)\n    R->addRange(Dest->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call,\n              \
  \                      CheckerContext &C) const {\n  if (!isStrcpy(Call, C))\n \
  \   return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n  const Expr *DestE\
  \ = Call.getArgExpr(0);\n  const Expr *SrcE = Call.getArgExpr(1);\n  if (!DestE\
  \ || !SrcE)\n    return;\n\n  uint64_t DestCap = 0;\n  if (!getFixedArraySizeFromExpr(DestE,\
  \ DestCap, C)) {\n    // Only warn when destination is a known fixed-size array.\n\
  \    return;\n  }\n\n  uint64_t SrcLen = 0;\n  bool HasConstLen = getConstStringLen(SrcE,\
  \ SrcLen);\n\n  if (HasConstLen) {\n    // Definite overflow if source length >=\
  \ dest capacity (due to NUL).\n    if (SrcLen >= DestCap) {\n      reportPossibleOverflow(Call,\
  \ DestE, DestCap, SrcLen, C);\n    }\n    // Else safe; do nothing.\n  } else {\n\
  \    // Unbounded copy into a fixed-size array; warn.\n    reportUnbounded(Call,\
  \ DestE, C);\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects strcpy into fixed-size buffers; suggest bounded copy like strscpy\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
