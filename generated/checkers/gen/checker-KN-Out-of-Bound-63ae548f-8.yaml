_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 63ae548f1054a0b71678d0349c7dc9628ddd42ca
commit_type: Out-of-Bound
index: 8
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"\
  clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No custom program states are necessary.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::Location> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Possible out-of-bounds\
  \ access to tf_pts\", \"Array Bounds\")) {}\n\n      void checkLocation(SVal Loc,\
  \ bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\n   private:\n\n     \
  \ // no self-defined helpers needed\n};\n\nvoid SAGenTestChecker::checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const {\n  if (!IsLoad ||\
  \ !S)\n    return;\n\n  // We are interested in array subscript reads only.\n  const\
  \ ArraySubscriptExpr *ASE = dyn_cast<ArraySubscriptExpr>(S);\n  if (!ASE)\n    ASE\
  \ = findSpecificTypeInChildren<ArraySubscriptExpr>(S);\n  if (!ASE)\n    return;\n\
  \n  const Expr *BaseE = ASE->getBase();\n  if (!BaseE)\n    return;\n\n  // Focus\
  \ only on tf_pts.{red,green,blue}\n  bool IsRed   = ExprHasName(BaseE, \"tf_pts.red\"\
  , C);\n  bool IsGreen = ExprHasName(BaseE, \"tf_pts.green\", C);\n  bool IsBlue\
  \  = ExprHasName(BaseE, \"tf_pts.blue\", C);\n  if (!IsRed && !IsGreen && !IsBlue)\n\
  \    return;\n\n  // Simple de-duplication: only report once for .red access.\n\
  \  if (!IsRed)\n    return;\n\n  // Determine the compile-time bound from the member's\
  \ declared type.\n  const Expr *BaseNoCasts = BaseE->IgnoreImpCasts();\n  const\
  \ MemberExpr *ME = dyn_cast<MemberExpr>(BaseNoCasts);\n  if (!ME)\n    return;\n\
  \n  const ValueDecl *VD = ME->getMemberDecl();\n  if (!VD)\n    return;\n\n  QualType\
  \ MT = VD->getType();\n  const ConstantArrayType *CAT = dyn_cast<ConstantArrayType>(MT.getTypePtr());\n\
  \  if (!CAT)\n    return; // can't get a fixed bound; avoid false positives\n\n\
  \  llvm::APInt BoundAP = CAT->getSize();\n  uint64_t Bound = BoundAP.getZExtValue();\n\
  \  if (Bound == 0)\n    return; // degenerate, ignore\n\n  const Expr *IdxE = ASE->getIdx();\n\
  \  if (!IdxE)\n    return;\n  IdxE = IdxE->IgnoreImpCasts();\n\n  // Try to evaluate\
  \ the index to a constant integer.\n  llvm::APSInt EvalRes;\n  if (EvaluateExprToInt(EvalRes,\
  \ IdxE, C)) {\n    // Constant index case.\n    if (EvalRes.isSigned() && EvalRes.isNegative())\
  \ {\n      // Definitely out-of-bounds (negative).\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \      if (!N)\n        return;\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"Index may exceed TRANSFER_FUNC_POINTS when accessing tf_pts.\"\
  , N);\n      R->addRange(ASE->getSourceRange());\n      C.emitReport(std::move(R));\n\
  \      return;\n    }\n    // Compare against bound.\n    uint64_t IdxVal = EvalRes.isSigned()\
  \ ? (uint64_t)EvalRes.getSExtValue()\n                                         :\
  \ EvalRes.getZExtValue();\n    if (IdxVal >= Bound) {\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \      if (!N)\n        return;\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"Index may exceed TRANSFER_FUNC_POINTS when accessing tf_pts.\"\
  , N);\n      R->addRange(ASE->getSourceRange());\n      C.emitReport(std::move(R));\n\
  \    }\n    return; // constant and safe otherwise\n  }\n\n  // Non-constant index:\
  \ see if we can prove safety from constraints.\n  SVal IdxSV = C.getSVal(IdxE, C.getLocationContext());\n\
  \  SymbolRef Sym = IdxSV.getAsSymbol();\n  if (Sym) {\n    if (const llvm::APSInt\
  \ *MaxVal = inferSymbolMaxVal(Sym, C)) {\n      // If max value is proven <= Bound-1,\
  \ it's safe.\n      llvm::APSInt BoundMinusOne(*MaxVal);\n      BoundMinusOne =\
  \ llvm::APSInt(*MaxVal);\n      // Prepare a compatible APSInt with the same bit\
  \ width/sign as MaxVal for comparison.\n      llvm::APSInt BoundAPS(MaxVal->getBitWidth(),\
  \ MaxVal->isUnsigned());\n      BoundAPS = Bound - 1;\n      if (*MaxVal <= BoundAPS)\
  \ {\n        return; // Proven safe\n      }\n      // If the max is >= bound, it's\
  \ potentially unsafe -> report.\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \      if (!N)\n        return;\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"Index may exceed TRANSFER_FUNC_POINTS when accessing tf_pts.\"\
  , N);\n      R->addRange(ASE->getSourceRange());\n      C.emitReport(std::move(R));\n\
  \      return;\n    }\n\n    // Unknown max -> cannot prove safe; report.\n    ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n    if (!N)\n      return;\n    auto R =\
  \ std::make_unique<PathSensitiveBugReport>(\n        *BT, \"Index may exceed TRANSFER_FUNC_POINTS\
  \ when accessing tf_pts.\", N);\n    R->addRange(ASE->getSourceRange());\n    C.emitReport(std::move(R));\n\
  \    return;\n  }\n\n  // If we can't extract a symbol, we can't reason about the\
  \ index; report conservatively.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Index may exceed TRANSFER_FUNC_POINTS when accessing tf_pts.\", N);\n\
  \  R->addRange(ASE->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n} //\
  \ end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects possible out-of-bounds indexing of output_tf->tf_pts.{red,green,blue}\
  \ without validating against TRANSFER_FUNC_POINTS\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Fix potential index out of bounds\
  \ in color transformation function\n\nFixes index out of bounds issue in the color\
  \ transformation function.\nThe issue could occur when the index 'i' exceeds the\
  \ number of transfer\nfunction points (TRANSFER_FUNC_POINTS).\n\nThe fix adds a\
  \ check to ensure 'i' is within bounds before accessing the\ntransfer function points.\
  \ If 'i' is out of bounds, an error message is\nlogged and the function returns\
  \ false to indicate an error.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:405\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.red'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:406\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.green'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:407\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.blue'\
  \ 1025 <= s32max\n\nFixes: b629596072e5 (\"drm/amd/display: Build unity lut for\
  \ shaper\")\nCc: Vitaly Prosyak <vitaly.prosyak@amd.com>\nCc: Charlene Liu <Charlene.Liu@amd.com>\n\
  Cc: Harry Wentland <harry.wentland@amd.com>\nCc: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>\n\
  Cc: Roman Li <roman.li@amd.com>\nCc: Aurabindo Pillai <aurabindo.pillai@amd.com>\n\
  Cc: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Srinivasan Shanmugam <srinivasan.shanmugam@amd.com>\n\
  Reviewed-by: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Alex Deucher <alexander.deucher@amd.com>\n\
  \n## Buggy Code\n\n```c\n// Function: cm_helper_translate_curve_to_hw_format in\
  \ drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nbool cm_helper_translate_curve_to_hw_format(struct\
  \ dc_context *ctx,\n\t\t\t\tconst struct dc_transfer_func *output_tf,\n\t\t\t\t\
  struct pwl_params *lut_params, bool fixpoint)\n{\n\tstruct curve_points3 *corner_points;\n\
  \tstruct pwl_result_data *rgb_resulted;\n\tstruct pwl_result_data *rgb;\n\tstruct\
  \ pwl_result_data *rgb_plus_1;\n\tstruct pwl_result_data *rgb_minus_1;\n\n\tint32_t\
  \ region_start, region_end;\n\tint32_t i;\n\tuint32_t j, k, seg_distr[MAX_REGIONS_NUMBER],\
  \ increment, start_index, hw_points;\n\n\tif (output_tf == NULL || lut_params ==\
  \ NULL || output_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\tcorner_points\
  \ = lut_params->corner_points;\n\trgb_resulted = lut_params->rgb_resulted;\n\thw_points\
  \ = 0;\n\n\tmemset(lut_params, 0, sizeof(struct pwl_params));\n\tmemset(seg_distr,\
  \ 0, sizeof(seg_distr));\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ || output_tf->tf\
  \ == TRANSFER_FUNCTION_GAMMA22) {\n\t\t/* 32 segments\n\t\t * segments are from\
  \ 2^-25 to 2^7\n\t\t */\n\t\tfor (i = 0; i < NUMBER_REGIONS ; i++)\n\t\t\tseg_distr[i]\
  \ = 3;\n\n\t\tregion_start = -MAX_LOW_POINT;\n\t\tregion_end   = NUMBER_REGIONS\
  \ - MAX_LOW_POINT;\n\t} else {\n\t\t/* 11 segments\n\t\t * segment is from 2^-10\
  \ to 2^1\n\t\t * There are less than 256 points, for optimization\n\t\t */\n\t\t\
  seg_distr[0] = 3;\n\t\tseg_distr[1] = 4;\n\t\tseg_distr[2] = 4;\n\t\tseg_distr[3]\
  \ = 4;\n\t\tseg_distr[4] = 4;\n\t\tseg_distr[5] = 4;\n\t\tseg_distr[6] = 4;\n\t\t\
  seg_distr[7] = 4;\n\t\tseg_distr[8] = 4;\n\t\tseg_distr[9] = 4;\n\t\tseg_distr[10]\
  \ = 1;\n\n\t\tregion_start = -10;\n\t\tregion_end = 1;\n\t}\n\n\tfor (i = region_end\
  \ - region_start; i < MAX_REGIONS_NUMBER ; i++)\n\t\tseg_distr[i] = -1;\n\n\tfor\
  \ (k = 0; k < MAX_REGIONS_NUMBER; k++) {\n\t\tif (seg_distr[k] != -1)\n\t\t\thw_points\
  \ += (1 << seg_distr[k]);\n\t}\n\n\tj = 0;\n\tfor (k = 0; k < (region_end - region_start);\
  \ k++) {\n\t\tincrement = NUMBER_SW_SEGMENTS / (1 << seg_distr[k]);\n\t\tstart_index\
  \ = (region_start + k + MAX_LOW_POINT) *\n\t\t\t\tNUMBER_SW_SEGMENTS;\n\t\tfor (i\
  \ = start_index; i < start_index + NUMBER_SW_SEGMENTS;\n\t\t\t\ti += increment)\
  \ {\n\t\t\tif (j == hw_points - 1)\n\t\t\t\tbreak;\n\t\t\trgb_resulted[j].red =\
  \ output_tf->tf_pts.red[i];\n\t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n\
  \t\t\trgb_resulted[j].blue = output_tf->tf_pts.blue[i];\n\t\t\tj++;\n\t\t}\n\t}\n\
  \n\t/* last point */\n\tstart_index = (region_end + MAX_LOW_POINT) * NUMBER_SW_SEGMENTS;\n\
  \trgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];\n\trgb_resulted[hw_points\
  \ - 1].green = output_tf->tf_pts.green[start_index];\n\trgb_resulted[hw_points -\
  \ 1].blue = output_tf->tf_pts.blue[start_index];\n\n\trgb_resulted[hw_points].red\
  \ = rgb_resulted[hw_points - 1].red;\n\trgb_resulted[hw_points].green = rgb_resulted[hw_points\
  \ - 1].green;\n\trgb_resulted[hw_points].blue = rgb_resulted[hw_points - 1].blue;\n\
  \n\t// All 3 color channels have same x\n\tcorner_points[0].red.x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\
  \t\t\t\t\t     dc_fixpt_from_int(region_start));\n\tcorner_points[0].green.x = corner_points[0].red.x;\n\
  \tcorner_points[0].blue.x = corner_points[0].red.x;\n\n\tcorner_points[1].red.x\
  \ = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_end));\n\
  \tcorner_points[1].green.x = corner_points[1].red.x;\n\tcorner_points[1].blue.x\
  \ = corner_points[1].red.x;\n\n\tcorner_points[0].red.y = rgb_resulted[0].red;\n\
  \tcorner_points[0].green.y = rgb_resulted[0].green;\n\tcorner_points[0].blue.y =\
  \ rgb_resulted[0].blue;\n\n\tcorner_points[0].red.slope = dc_fixpt_div(corner_points[0].red.y,\n\
  \t\t\tcorner_points[0].red.x);\n\tcorner_points[0].green.slope = dc_fixpt_div(corner_points[0].green.y,\n\
  \t\t\tcorner_points[0].green.x);\n\tcorner_points[0].blue.slope = dc_fixpt_div(corner_points[0].blue.y,\n\
  \t\t\tcorner_points[0].blue.x);\n\n\t/* see comment above, m_arrPoints[1].y should\
  \ be the Y value for the\n\t * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints\
  \ - 1)\n\t */\n\tcorner_points[1].red.y = rgb_resulted[hw_points - 1].red;\n\tcorner_points[1].green.y\
  \ = rgb_resulted[hw_points - 1].green;\n\tcorner_points[1].blue.y = rgb_resulted[hw_points\
  \ - 1].blue;\n\tcorner_points[1].red.slope = dc_fixpt_zero;\n\tcorner_points[1].green.slope\
  \ = dc_fixpt_zero;\n\tcorner_points[1].blue.slope = dc_fixpt_zero;\n\n\tif (output_tf->tf\
  \ == TRANSFER_FUNCTION_PQ) {\n\t\t/* for PQ, we want to have a straight line from\
  \ last HW X point,\n\t\t * and the slope to be such that we hit 1.0 at 10000 nits.\n\
  \t\t */\n\t\tconst struct fixed31_32 end_value =\n\t\t\t\tdc_fixpt_from_int(125);\n\
  \n\t\tcorner_points[1].red.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].red.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].red.x));\n\
  \t\tcorner_points[1].green.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].green.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].green.x));\n\
  \t\tcorner_points[1].blue.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].blue.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].blue.x));\n\
  \t}\n\n\tlut_params->hw_points_num = hw_points;\n\n\tk = 0;\n\tfor (i = 1; i < MAX_REGIONS_NUMBER;\
  \ i++) {\n\t\tif (seg_distr[k] != -1) {\n\t\t\tlut_params->arr_curve_points[k].segments_num\
  \ =\n\t\t\t\t\tseg_distr[k];\n\t\t\tlut_params->arr_curve_points[i].offset =\n\t\
  \t\t\t\tlut_params->arr_curve_points[k].offset + (1 << seg_distr[k]);\n\t\t}\n\t\
  \tk++;\n\t}\n\n\tif (seg_distr[k] != -1)\n\t\tlut_params->arr_curve_points[k].segments_num\
  \ = seg_distr[k];\n\n\trgb = rgb_resulted;\n\trgb_plus_1 = rgb_resulted + 1;\n\t\
  rgb_minus_1 = rgb;\n\n\ti = 1;\n\twhile (i != hw_points + 1) {\n\n\t\tif (i >= hw_points\
  \ - 1) {\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->red, rgb->red))\n\t\t\t\trgb_plus_1->red\
  \ = dc_fixpt_add(rgb->red, rgb_minus_1->delta_red);\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->green,\
  \ rgb->green))\n\t\t\t\trgb_plus_1->green = dc_fixpt_add(rgb->green, rgb_minus_1->delta_green);\n\
  \t\t\tif (dc_fixpt_lt(rgb_plus_1->blue, rgb->blue))\n\t\t\t\trgb_plus_1->blue =\
  \ dc_fixpt_add(rgb->blue, rgb_minus_1->delta_blue);\n\t\t}\n\n\t\trgb->delta_red\
  \   = dc_fixpt_sub(rgb_plus_1->red,   rgb->red);\n\t\trgb->delta_green = dc_fixpt_sub(rgb_plus_1->green,\
  \ rgb->green);\n\t\trgb->delta_blue  = dc_fixpt_sub(rgb_plus_1->blue,  rgb->blue);\n\
  \n\n\t\tif (fixpoint == true) {\n\t\t\tuint32_t red_clamp = dc_fixpt_clamp_u0d14(rgb->delta_red);\n\
  \t\t\tuint32_t green_clamp = dc_fixpt_clamp_u0d14(rgb->delta_green);\n\t\t\tuint32_t\
  \ blue_clamp = dc_fixpt_clamp_u0d14(rgb->delta_blue);\n\n\t\t\tif (red_clamp >>\
  \ 10 || green_clamp >> 10 || blue_clamp >> 10)\n\t\t\t\tDC_LOG_WARNING(\"Losing\
  \ delta precision while programming shaper LUT.\");\n\n\t\t\trgb->delta_red_reg\
  \   = red_clamp & 0x3ff;\n\t\t\trgb->delta_green_reg = green_clamp & 0x3ff;\n\t\t\
  \trgb->delta_blue_reg  = blue_clamp & 0x3ff;\n\t\t\trgb->red_reg         = dc_fixpt_clamp_u0d14(rgb->red);\n\
  \t\t\trgb->green_reg       = dc_fixpt_clamp_u0d14(rgb->green);\n\t\t\trgb->blue_reg\
  \        = dc_fixpt_clamp_u0d14(rgb->blue);\n\t\t}\n\n\t\t++rgb_plus_1;\n\t\trgb_minus_1\
  \ = rgb;\n\t\t++rgb;\n\t\t++i;\n\t}\n\tcm_helper_convert_to_custom_float(rgb_resulted,\n\
  \t\t\t\t\t\tlut_params->corner_points,\n\t\t\t\t\t\thw_points, fixpoint);\n\n\t\
  return true;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\
  \ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nindex b7e57aa27361..b0d192c6e63e\
  \ 100644\n--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n\
  @@ -402,6 +402,11 @@ bool cm_helper_translate_curve_to_hw_format(struct dc_context\
  \ *ctx,\n \t\t\t\ti += increment) {\n \t\t\tif (j == hw_points - 1)\n \t\t\t\tbreak;\n\
  +\t\t\tif (i >= TRANSFER_FUNC_POINTS) {\n+\t\t\t\tDC_LOG_ERROR(\"Index out of bounds:\
  \ i=%d, TRANSFER_FUNC_POINTS=%d\\n\",\n+\t\t\t\t\t     i, TRANSFER_FUNC_POINTS);\n\
  +\t\t\t\treturn false;\n+\t\t\t}\n \t\t\trgb_resulted[j].red = output_tf->tf_pts.red[i];\n\
  \ \t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n \t\t\trgb_resulted[j].blue\
  \ = output_tf->tf_pts.blue[i];\n```\n"
pattern: "## Bug Pattern\n\nIndexing a fixed-size lookup table (transfer function\
  \ points) with a computed loop index without validating the index against the table\u2019\
  s size constant. Specifically, using i (derived from region-based start_index and\
  \ increment) to access output_tf->tf_pts.{red,green,blue}[i] without checking i\
  \ < TRANSFER_FUNC_POINTS, leading to potential out-of-bounds array access."
plan: "Plan: Detect unguarded indexing into output_tf->tf_pts.{red,green,blue}[i]\
  \ without proving i < TRANSFER_FUNC_POINTS\n\n1) Program state\n- No custom program\
  \ state traits or maps are necessary. We will rely on the analyzer\u2019s built-in\
  \ constraint manager to reason about index ranges (via inferSymbolMaxVal) and only\
  \ report when safety cannot be proven.\n\n2) Callbacks and their roles\n- checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const\n  - Purpose: Trigger\
  \ on array element loads of the tf_pts channels. The buggy pattern is a read from\
  \ fixed-size lookup tables with a computed index i that is not validated against\
  \ the array size (TRANSFER_FUNC_POINTS).\n  - Steps to implement:\n    1. Early\
  \ filter: Only act on loads (IsLoad == true).\n    2. Identify the array access:\n\
  \       - dyn_cast the Stmt S to ArraySubscriptExpr (ASE). If not, return.\n   \
  \    - Extract the base expression of ASE: Base = ASE->getBase()->IgnoreImpCasts().\n\
  \       - We only care about the three channels of the transfer function:\n    \
  \     - Use the provided ExprHasName utility to check for any of the following on\
  \ Base:\n           - \"tf_pts.red\"\n           - \"tf_pts.green\"\n          \
  \ - \"tf_pts.blue\"\n         - To avoid duplicate reports for the three channels\
  \ in the same block, optionally only emit a report when Base contains \"tf_pts.red\"\
  \ (this is a simple de-dup heuristic). Otherwise, allow reports for all channels.\n\
  \       - If none match, return.\n    3. Retrieve the bound (TRANSFER_FUNC_POINTS)\
  \ from the array type:\n       - For reliable array size extraction, look at the\
  \ member declaration type:\n         - If Base is a MemberExpr ME, get the field\u2019\
  s declared type: QualType MT = ME->getMemberDecl()->getType().\n         - dyn_cast<ConstantArrayType>(MT.getTypePtr()).\
  \ If null, we cannot get a compile-time bound; return to avoid false positives.\n\
  \         - Extract the size into an llvm::APInt BoundAP = ArrayType->getSize();\
  \ Convert to uint64_t Bound.\n    4. Analyze the index expression:\n       - Let\
  \ IdxE = ASE->getIdx()->IgnoreImpCasts().\n       - Try to compute a constant value\
  \ using EvaluateExprToInt(EvalRes, IdxE, C). If success:\n         - If EvalRes.isSigned()\
  \ and EvalRes.isNegative() or EvalRes >= Bound: definitely out-of-bounds \u2192\
  \ Report.\n         - Else: safe \u2192 return.\n       - Otherwise, retrieve a\
  \ symbolic bound for the index:\n         - SVal IdxSVal = C.getSVal(IdxE);\n  \
  \       - SymbolRef Sym = IdxSVal.getAsSymbol();\n         - If Sym is null, we\
  \ cannot reason, report conservatively (but see step 5 for suppression).\n     \
  \    - Else use inferSymbolMaxVal(Sym, C) to get maxVal:\n           - If maxVal\
  \ exists and maxVal.ule(Bound - 1): proven safe \u2192 return.\n           - If\
  \ maxVal is absent or maxVal.uge(Bound): not proven safe or proven unsafe \u2192\
  \ proceed to report.\n       - Note: This leverages the analyzer\u2019s path constraints.\
  \ If there is a guarding condition like if (i >= TRANSFER_FUNC_POINTS) return; or\
  \ if (i < TRANSFER_FUNC_POINTS) ..., the constraint manager will refine the max\
  \ value, and we will not report.\n    5. Suppress obvious duplicates:\n       -\
  \ If you chose not to de-dup via the \".red\" heuristic, you may keep it simple\
  \ and accept multiple reports (one per channel). Prefer the simple de-dup heuristic:\
  \ only report when ExprHasName(Base, \"tf_pts.red\", C) is true.\n    6. Emit the\
  \ bug report:\n       - Create a non-fatal error node: if (!N) N = C.generateNonFatalErrorNode();\n\
  \       - Message: \u201CIndex may exceed TRANSFER_FUNC_POINTS when accessing tf_pts.\u201D\
  \n       - Use PathSensitiveBugReport with a short, clear description. Optionally\
  \ add a note pointing to the index expression.\n       - C.emitReport(...).\n\n\
  - No other callbacks are required.\n  - We do not need checkBranchCondition: the\
  \ analyzer\u2019s constraint system will update symbol ranges after branches; inferSymbolMaxVal\
  \ will reflect that.\n  - We do not need checkBind or maps for aliases: the index\
  \ is an integer expression; aliasing is not relevant here.\n  - We do not need checkPreCall/checkPostCall:\
  \ the bug is not about function effects.\n\n3) Heuristics/Details\n- Base identification\
  \ is done via ExprHasName on the base of ArraySubscriptExpr to focus on the specific\
  \ pattern tf_pts.{red,green,blue}.\n- Array bound extraction:\n  - Prefer to use\
  \ MemberExpr\u2019s FieldDecl type (ConstantArrayType) to get the compile-time bound\
  \ that originates from TRANSFER_FUNC_POINTS. This avoids relying on macro name strings.\n\
  - Soundness vs noise:\n  - If you cannot find a ConstantArrayType bound, skip reporting\
  \ to avoid false positives.\n  - If the analyzer proves Idx < Bound via constraints\
  \ (inferSymbolMaxVal), do not report.\n  - Constant index outside range is a definite\
  \ bug: always report.\n\n4) Summary of detection logic in checkLocation\n- S is\
  \ ArraySubscriptExpr and Base contains \u201Ctf_pts.red|green|blue\u201D.\n- Array\
  \ bound (Bound) is available from the member\u2019s ConstantArrayType.\n- Index\
  \ i:\n  - If constant and i >= Bound: report.\n  - Else if symbol:\n    - If maxVal\
  \ \u2264 Bound-1: safe, return.\n    - If maxVal \u2265 Bound or unknown: report.\n\
  - Use a simple de-dup heuristic: only report for \u201Ctf_pts.red\u201D to avoid\
  \ three identical diagnostics per site.\n\n5) Report message\n- Title: \u201CPossible\
  \ out-of-bounds access to tf_pts\u201D\n- Description: \u201CIndex may exceed TRANSFER_FUNC_POINTS\
  \ when accessing tf_pts.\u201D\n- Keep it short and clear as requested."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"\
  clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No custom program states are necessary.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::Location> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Possible out-of-bounds\
  \ access to tf_pts\", \"Array Bounds\")) {}\n\n      void checkLocation(SVal Loc,\
  \ bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\n   private:\n\n     \
  \ // no self-defined helpers needed\n};\n\nvoid SAGenTestChecker::checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const {\n  if (!IsLoad ||\
  \ !S)\n    return;\n\n  // We are interested in array subscript reads only.\n  const\
  \ ArraySubscriptExpr *ASE = dyn_cast<ArraySubscriptExpr>(S);\n  if (!ASE)\n    ASE\
  \ = findSpecificTypeInChildren<ArraySubscriptExpr>(S);\n  if (!ASE)\n    return;\n\
  \n  const Expr *BaseE = ASE->getBase();\n  if (!BaseE)\n    return;\n\n  // Focus\
  \ only on tf_pts.{red,green,blue}\n  bool IsRed   = ExprHasName(BaseE, \"tf_pts.red\"\
  , C);\n  bool IsGreen = ExprHasName(BaseE, \"tf_pts.green\", C);\n  bool IsBlue\
  \  = ExprHasName(BaseE, \"tf_pts.blue\", C);\n  if (!IsRed && !IsGreen && !IsBlue)\n\
  \    return;\n\n  // Simple de-duplication: only report once for .red access.\n\
  \  if (!IsRed)\n    return;\n\n  // Determine the compile-time bound from the member's\
  \ declared type.\n  const Expr *BaseNoCasts = BaseE->IgnoreImpCasts();\n  const\
  \ MemberExpr *ME = dyn_cast<MemberExpr>(BaseNoCasts);\n  if (!ME)\n    return;\n\
  \n  const ValueDecl *VD = ME->getMemberDecl();\n  if (!VD)\n    return;\n\n  QualType\
  \ MT = VD->getType();\n  const ConstantArrayType *CAT = dyn_cast<ConstantArrayType>(MT.getTypePtr());\n\
  \  if (!CAT)\n    return; // can't get a fixed bound; avoid false positives\n\n\
  \  llvm::APInt BoundAP = CAT->getSize();\n  uint64_t Bound = BoundAP.getZExtValue();\n\
  \  if (Bound == 0)\n    return; // degenerate, ignore\n\n  const Expr *IdxE = ASE->getIdx();\n\
  \  if (!IdxE)\n    return;\n  IdxE = IdxE->IgnoreImpCasts();\n\n  // Try to evaluate\
  \ the index to a constant integer.\n  llvm::APSInt EvalRes;\n  if (EvaluateExprToInt(EvalRes,\
  \ IdxE, C)) {\n    // Constant index case.\n    if (EvalRes.isSigned() && EvalRes.isNegative())\
  \ {\n      // Definitely out-of-bounds (negative).\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \      if (!N)\n        return;\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"Index may exceed TRANSFER_FUNC_POINTS when accessing tf_pts.\"\
  , N);\n      R->addRange(ASE->getSourceRange());\n      C.emitReport(std::move(R));\n\
  \      return;\n    }\n    // Compare against bound.\n    uint64_t IdxVal = EvalRes.isSigned()\
  \ ? (uint64_t)EvalRes.getSExtValue()\n                                         :\
  \ EvalRes.getZExtValue();\n    if (IdxVal >= Bound) {\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \      if (!N)\n        return;\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"Index may exceed TRANSFER_FUNC_POINTS when accessing tf_pts.\"\
  , N);\n      R->addRange(ASE->getSourceRange());\n      C.emitReport(std::move(R));\n\
  \    }\n    return; // constant and safe otherwise\n  }\n\n  // Non-constant index:\
  \ see if we can prove safety from constraints.\n  SVal IdxSV = C.getSVal(IdxE);\n\
  \  SymbolRef Sym = IdxSV.getAsSymbol();\n  if (Sym) {\n    if (const llvm::APSInt\
  \ *MaxVal = inferSymbolMaxVal(Sym, C)) {\n      // If max value is proven <= Bound-1,\
  \ it's safe.\n      llvm::APSInt BoundMinusOne(*MaxVal);\n      BoundMinusOne =\
  \ llvm::APSInt(*MaxVal);\n      // Prepare a compatible APSInt with the same bit\
  \ width/sign as MaxVal for comparison.\n      llvm::APSInt BoundAPS(MaxVal->getBitWidth(),\
  \ MaxVal->isUnsigned());\n      BoundAPS = Bound - 1;\n      if (*MaxVal <= BoundAPS)\
  \ {\n        return; // Proven safe\n      }\n      // If the max is >= bound, it's\
  \ potentially unsafe -> report.\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \      if (!N)\n        return;\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"Index may exceed TRANSFER_FUNC_POINTS when accessing tf_pts.\"\
  , N);\n      R->addRange(ASE->getSourceRange());\n      C.emitReport(std::move(R));\n\
  \      return;\n    }\n\n    // Unknown max -> cannot prove safe; report.\n    ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n    if (!N)\n      return;\n    auto R =\
  \ std::make_unique<PathSensitiveBugReport>(\n        *BT, \"Index may exceed TRANSFER_FUNC_POINTS\
  \ when accessing tf_pts.\", N);\n    R->addRange(ASE->getSourceRange());\n    C.emitReport(std::move(R));\n\
  \    return;\n  }\n\n  // If we can't extract a symbol, we can't reason about the\
  \ index; report conservatively.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Index may exceed TRANSFER_FUNC_POINTS when accessing tf_pts.\", N);\n\
  \  R->addRange(ASE->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n} //\
  \ end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects possible out-of-bounds indexing of output_tf->tf_pts.{red,green,blue}\
  \ without validating against TRANSFER_FUNC_POINTS\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
