_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 51df947678360faf1967fe0bd1a40c681f634104
commit_type: Memory-Leak
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include\
  \ \"clang/AST/ParentMapContext.h\"\n#include <vector>\n#include <utility>\n\nusing\
  \ namespace clang;\nusing namespace ento;\nusing namespace taint;\n\nnamespace {\n\
  /* The checker callbacks are to be decided. */\nclass SAGenTestChecker : public\
  \ Checker<check::ASTCodeBody> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n\
  \      SAGenTestChecker() : BT(new BugType(this, \"Leak on early exit before register_netdev\"\
  , \"Memory Management\")) {}\n\n      void checkASTCodeBody(const Decl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const;\n\n   private:\n\n      // Helpers\n      static\
  \ bool isCalleeNamed(const CallExpr *CE, std::initializer_list<const char*> Names);\n\
  \      static bool isNetdevAllocCall(const CallExpr *CE);\n      static bool isRegisterNetdevForVar(const\
  \ CallExpr *CE, const VarDecl *VD);\n      static bool isFreeNetdevForVar(const\
  \ CallExpr *CE, const VarDecl *VD);\n\n      static const VarDecl* getAssignedVarFromCall(const\
  \ CallExpr *CE, ASTContext &Ctx);\n      static bool stmtContains(const Stmt *Parent,\
  \ const Stmt *Child);\n      static void collectCallsAndExits(const Stmt *S,\n \
  \                                      std::vector<const CallExpr*> &Calls,\n  \
  \                                     std::vector<const Stmt*> &Exits);\n\n    \
  \  static bool isBetween(const SourceManager &SM,\n                            SourceLocation\
  \ StartAfter,\n                            const Stmt *Mid,\n                  \
  \          SourceLocation EndBefore);\n\n      static const Stmt* findNearestParentOfKind(const\
  \ Stmt *S, ASTContext &Ctx, std::function<bool(const Stmt*)> Pred);\n      static\
  \ const CompoundStmt* findNearestEnclosingCompound(const Stmt *S, ASTContext &Ctx);\n\
  \n      static bool isNullTestOfVar(const Expr *Cond, const VarDecl *VD, ASTContext\
  \ &Ctx);\n      static bool isExitGuardedByNullOfVar(const Stmt *Exit, const VarDecl\
  \ *VD, ASTContext &Ctx);\n\n      static bool containsFreeNetdevForVarAfterStart(const\
  \ Stmt *S, const VarDecl *VD,\n                                                \
  \     const SourceManager &SM, SourceLocation StartAfter);\n\n      void analyzeLoopBody(const\
  \ Stmt *LoopBody, const Decl *D, AnalysisManager &Mgr, BugReporter &BR) const;\n\
  };\n\nstatic SourceLocation getBeginTokenLoc(const Stmt *S, const SourceManager\
  \ &SM) {\n  return SM.getExpansionLoc(S->getBeginLoc());\n}\nstatic SourceLocation\
  \ getEndTokenLoc(const Stmt *S, const SourceManager &SM) {\n  return SM.getExpansionLoc(S->getEndLoc());\n\
  }\n\nbool SAGenTestChecker::isCalleeNamed(const CallExpr *CE, std::initializer_list<const\
  \ char*> Names) {\n  if (!CE) return false;\n  const FunctionDecl *FD = CE->getDirectCallee();\n\
  \  if (!FD) return false;\n  StringRef Name = FD->getName();\n  for (const char\
  \ *N : Names) {\n    if (Name.equals(N))\n      return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isNetdevAllocCall(const CallExpr *CE) {\n  return isCalleeNamed(CE,\
  \ {\"alloc_etherdev\", \"alloc_netdev\", \"alloc_netdev_mqs\"});\n}\n\nstatic const\
  \ DeclRefExpr* getAsDeclRef(const Expr *E) {\n  if (!E) return nullptr;\n  E = E->IgnoreParenImpCasts();\n\
  \  return dyn_cast<DeclRefExpr>(E);\n}\n\nbool SAGenTestChecker::isRegisterNetdevForVar(const\
  \ CallExpr *CE, const VarDecl *VD) {\n  if (!CE || !VD) return false;\n  if (!isCalleeNamed(CE,\
  \ {\"register_netdev\"})) return false;\n  if (CE->getNumArgs() != 1) return false;\n\
  \  const Expr *Arg = CE->getArg(0);\n  if (const DeclRefExpr *DRE = getAsDeclRef(Arg))\
  \ {\n    if (const VarDecl *A = dyn_cast<VarDecl>(DRE->getDecl()))\n      return\
  \ A == VD;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isFreeNetdevForVar(const\
  \ CallExpr *CE, const VarDecl *VD) {\n  if (!CE || !VD) return false;\n  if (!isCalleeNamed(CE,\
  \ {\"free_netdev\"})) return false;\n  if (CE->getNumArgs() != 1) return false;\n\
  \  const Expr *Arg = CE->getArg(0);\n  if (const DeclRefExpr *DRE = getAsDeclRef(Arg))\
  \ {\n    if (const VarDecl *A = dyn_cast<VarDecl>(DRE->getDecl()))\n      return\
  \ A == VD;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::stmtContains(const\
  \ Stmt *Parent, const Stmt *Child) {\n  if (!Parent || !Child) return false;\n \
  \ if (Parent == Child) return true;\n  for (const Stmt *Sub : Parent->children())\
  \ {\n    if (Sub && stmtContains(Sub, Child))\n      return true;\n  }\n  return\
  \ false;\n}\n\nconst VarDecl* SAGenTestChecker::getAssignedVarFromCall(const CallExpr\
  \ *CE, ASTContext &Ctx) {\n  if (!CE) return nullptr;\n\n  DynTypedNode Node = DynTypedNode::create(*CE);\n\
  \n  // Climb up through wrappers to find either a BinaryOperator (=) or a DeclStmt.\n\
  \  for (int depth = 0; depth < 16; ++depth) {\n    auto Parents = Ctx.getParents(Node);\n\
  \    if (Parents.empty())\n      break;\n\n    // Try to find a BinaryOperator parent\
  \ (assignment) first.\n    const BinaryOperator *FoundBO = nullptr;\n    const DeclStmt\
  \ *FoundDS = nullptr;\n    const Expr *FoundExpr = nullptr;\n\n    for (const auto\
  \ &P : Parents) {\n      if (!FoundBO) FoundBO = P.get<BinaryOperator>();\n    \
  \  if (!FoundDS) FoundDS = P.get<DeclStmt>();\n      if (!FoundExpr) FoundExpr =\
  \ P.get<Expr>();\n    }\n\n    if (FoundBO) {\n      const BinaryOperator *BO =\
  \ FoundBO;\n      if (BO->isAssignmentOp() && BO->getOpcode() == BO_Assign) {\n\
  \        if (stmtContains(BO->getRHS(), CE)) {\n          const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \          if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(LHS)) {\n        \
  \    if (const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n              return\
  \ VD;\n          }\n        }\n      }\n      // If it's some other binop or not\
  \ containing CE, continue climbing.\n      Node = DynTypedNode::create(*BO);\n \
  \     continue;\n    }\n\n    if (FoundDS) {\n      const DeclStmt *DS = FoundDS;\n\
  \      if (DS->isSingleDecl()) {\n        if (const VarDecl *VD = dyn_cast<VarDecl>(DS->getSingleDecl()))\
  \ {\n          if (const Expr *Init = VD->getInit()) {\n            if (stmtContains(Init,\
  \ CE))\n              return VD;\n          }\n        }\n      }\n      Node =\
  \ DynTypedNode::create(*DS);\n      continue;\n    }\n\n    if (FoundExpr) {\n \
  \     Node = DynTypedNode::create(*FoundExpr);\n      continue;\n    }\n\n    break;\n\
  \  }\n\n  return nullptr;\n}\n\nvoid SAGenTestChecker::collectCallsAndExits(const\
  \ Stmt *S,\n                                            std::vector<const CallExpr*>\
  \ &Calls,\n                                            std::vector<const Stmt*>\
  \ &Exits) {\n  if (!S) return;\n\n  if (const auto *CE = dyn_cast<CallExpr>(S))\
  \ {\n    Calls.push_back(CE);\n  } else if (isa<GotoStmt>(S) || isa<ReturnStmt>(S))\
  \ {\n    Exits.push_back(S);\n  }\n\n  for (const Stmt *Child : S->children()) {\n\
  \    if (Child)\n      collectCallsAndExits(Child, Calls, Exits);\n  }\n}\n\nbool\
  \ SAGenTestChecker::isBetween(const SourceManager &SM,\n                       \
  \          SourceLocation StartAfter,\n                                 const Stmt\
  \ *Mid,\n                                 SourceLocation EndBefore) {\n  if (!Mid.isNotNull())\
  \ return false;\n  SourceLocation MidBegin = getBeginTokenLoc(Mid, SM);\n  SourceLocation\
  \ MidEnd   = getEndTokenLoc(Mid, SM);\n\n  bool AfterStart = SM.isBeforeInTranslationUnit(StartAfter,\
  \ MidBegin);\n  bool BeforeEnd  = SM.isBeforeInTranslationUnit(MidEnd, EndBefore);\n\
  \  return AfterStart && BeforeEnd;\n}\n\nconst Stmt* SAGenTestChecker::findNearestParentOfKind(const\
  \ Stmt *S, ASTContext &Ctx, std::function<bool(const Stmt*)> Pred) {\n  if (!S)\
  \ return nullptr;\n  DynTypedNode Node = DynTypedNode::create(*S);\n  for (int depth\
  \ = 0; depth < 32; ++depth) {\n    auto Parents = Ctx.getParents(Node);\n    if\
  \ (Parents.empty())\n      break;\n    const Stmt *Found = nullptr;\n    const Stmt\
  \ *AnyParent = nullptr;\n    for (const auto &P : Parents) {\n      if (const Stmt\
  \ *PS = P.get<Stmt>()) {\n        AnyParent = PS;\n        if (Pred(PS)) {\n   \
  \       Found = PS;\n          break;\n        }\n      }\n    }\n    if (Found)\n\
  \      return Found;\n    if (!AnyParent)\n      break;\n    Node = DynTypedNode::create(*AnyParent);\n\
  \  }\n  return nullptr;\n}\n\nconst CompoundStmt* SAGenTestChecker::findNearestEnclosingCompound(const\
  \ Stmt *S, ASTContext &Ctx) {\n  return dyn_cast_or_null<CompoundStmt>(findNearestParentOfKind(\n\
  \      S, Ctx, [](const Stmt *X) { return isa<CompoundStmt>(X); }));\n}\n\nstatic\
  \ bool isZeroOrNullPtr(const Expr *E, ASTContext &Ctx) {\n  if (!E) return false;\n\
  \  return E->isNullPointerConstant(Ctx, Expr::NPC_ValueDependentIsNull);\n}\n\n\
  bool SAGenTestChecker::isNullTestOfVar(const Expr *Cond, const VarDecl *VD, ASTContext\
  \ &Ctx) {\n  if (!Cond || !VD) return false;\n  const Expr *C = Cond->IgnoreParenImpCasts();\n\
  \n  // if (!vd)\n  if (const auto *UO = dyn_cast<UnaryOperator>(C)) {\n    if (UO->getOpcode()\
  \ == UO_LNot) {\n      if (const DeclRefExpr *DRE = getAsDeclRef(UO->getSubExpr()))\
  \ {\n        if (const VarDecl *V = dyn_cast<VarDecl>(DRE->getDecl()))\n       \
  \   return V == VD;\n      }\n    }\n  }\n\n  // if (vd == NULL) or if (vd != NULL)\n\
  \  if (const auto *BO = dyn_cast<BinaryOperator>(C)) {\n    if (BO->getOpcode()\
  \ == BO_EQ || BO->getOpcode() == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n      const DeclRefExpr\
  \ *LDRE = dyn_cast<DeclRefExpr>(LHS);\n      const DeclRefExpr *RDRE = dyn_cast<DeclRefExpr>(RHS);\n\
  \n      if (LDRE && dyn_cast<VarDecl>(LDRE->getDecl()) == VD && isZeroOrNullPtr(RHS,\
  \ Ctx))\n        return true;\n      if (RDRE && dyn_cast<VarDecl>(RDRE->getDecl())\
  \ == VD && isZeroOrNullPtr(LHS, Ctx))\n        return true;\n    }\n  }\n\n  //\
  \ if (vd) -- positive test\n  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(C))\
  \ {\n    if (const VarDecl *V = dyn_cast<VarDecl>(DRE->getDecl()))\n      return\
  \ V == VD;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isExitGuardedByNullOfVar(const\
  \ Stmt *Exit, const VarDecl *VD, ASTContext &Ctx) {\n  if (!Exit || !VD) return\
  \ false;\n  const IfStmt *IS = dyn_cast_or_null<IfStmt>(findNearestParentOfKind(\n\
  \      Exit, Ctx, [](const Stmt *X) { return isa<IfStmt>(X); }));\n  if (!IS) return\
  \ false;\n\n  const Expr *Cond = IS->getCond();\n  if (!Cond) return false;\n\n\
  \  // We conservatively assume that if the nearest enclosing if-statement's\n  //\
  \ condition is a null/non-null test of VD, then the exit is guarded by a\n  // null-check\
  \ of the var, and thus no leak occurs when VD is NULL.\n  return isNullTestOfVar(Cond,\
  \ VD, Ctx);\n}\n\nbool SAGenTestChecker::containsFreeNetdevForVarAfterStart(const\
  \ Stmt *S, const VarDecl *VD,\n                                                \
  \          const SourceManager &SM, SourceLocation StartAfter) {\n  if (!S || !VD)\
  \ return false;\n\n  if (const auto *CE = dyn_cast<CallExpr>(S)) {\n    if (isFreeNetdevForVar(CE,\
  \ VD)) {\n      if (SM.isBeforeInTranslationUnit(StartAfter, getBeginTokenLoc(CE,\
  \ SM)))\n        return true;\n    }\n  }\n\n  for (const Stmt *Child : S->children())\
  \ {\n    if (Child && containsFreeNetdevForVarAfterStart(Child, VD, SM, StartAfter))\n\
  \      return true;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::analyzeLoopBody(const\
  \ Stmt *LoopBody, const Decl *D, AnalysisManager &Mgr, BugReporter &BR) const {\n\
  \  if (!LoopBody) return;\n\n  ASTContext &Ctx = Mgr.getASTContext();\n  const SourceManager\
  \ &SM = BR.getSourceManager();\n  AnalysisDeclContext *AC = Mgr.getAnalysisDeclContext(D);\n\
  \n  // Collect all calls and exits within the loop body.\n  std::vector<const CallExpr*>\
  \ Calls;\n  std::vector<const Stmt*> Exits;\n  collectCallsAndExits(LoopBody, Calls,\
  \ Exits);\n\n  // For each allocation inside the loop, analyze early exits before\
  \ register_netdev.\n  for (const CallExpr *AllocCE : Calls) {\n    if (!isNetdevAllocCall(AllocCE))\n\
  \      continue;\n\n    const VarDecl *VD = getAssignedVarFromCall(AllocCE, Ctx);\n\
  \    if (!VD)\n      continue; // Only handle obvious assignment targets.\n\n  \
  \  // Find the first register_netdev(VD) after the allocation.\n    const CallExpr\
  \ *FirstReg = nullptr;\n    SourceLocation AllocEnd = getEndTokenLoc(AllocCE, SM);\n\
  \    SourceLocation BodyEnd = getEndTokenLoc(LoopBody, SM);\n    SourceLocation\
  \ EndBoundLoc = BodyEnd;\n\n    for (const CallExpr *C : Calls) {\n      if (isRegisterNetdevForVar(C,\
  \ VD)) {\n        if (SM.isBeforeInTranslationUnit(AllocEnd, getBeginTokenLoc(C,\
  \ SM))) {\n          if (!FirstReg ||\n              SM.isBeforeInTranslationUnit(getBeginTokenLoc(C,\
  \ SM),\n                                           getBeginTokenLoc(FirstReg, SM)))\
  \ {\n            FirstReg = C;\n          }\n        }\n      }\n    }\n    if (FirstReg)\n\
  \      EndBoundLoc = getBeginTokenLoc(FirstReg, SM);\n\n    // Look for exits between\
  \ allocation and registration.\n    for (const Stmt *ExitS : Exits) {\n      if\
  \ (!isBetween(SM, AllocEnd, ExitS, EndBoundLoc))\n        continue;\n\n      //\
  \ Skip exits that are guarded by a null-check on VD (allocation failed path).\n\
  \      if (isExitGuardedByNullOfVar(ExitS, VD, Ctx))\n        continue;\n\n    \
  \  // Ensure there is a free_netdev(VD) before this exit in the same enclosing compound.\n\
  \      const CompoundStmt *CS = findNearestEnclosingCompound(ExitS, Ctx);\n    \
  \  bool HasLocalFree = false;\n      if (CS) {\n        for (const Stmt *Child :\
  \ CS->body()) {\n          if (Child == ExitS)\n            break;\n          //\
  \ Consider only those after the allocation point.\n          if (SM.isBeforeInTranslationUnit(AllocEnd,\
  \ getBeginTokenLoc(Child, SM))) {\n            if (containsFreeNetdevForVarAfterStart(Child,\
  \ VD, SM, AllocEnd)) {\n              HasLocalFree = true;\n              break;\n\
  \            }\n          }\n        }\n      }\n\n      if (!HasLocalFree) {\n\
  \        // Report: missing free_netdev before early exit.\n        PathDiagnosticLocation\
  \ ELoc =\n            PathDiagnosticLocation::createBegin(ExitS, SM, AC);\n    \
  \    auto R = std::make_unique<BasicBugReport>(\n            *BT,\n            \"\
  net_device allocated in loop may leak on early exit; \"\n            \"missing free_netdev\
  \ before goto/return\",\n            ELoc);\n        R->addRange(ExitS->getSourceRange());\n\
  \        BR.emitReport(std::move(R));\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkASTCodeBody(const\
  \ Decl *D, AnalysisManager &Mgr, BugReporter &BR) const {\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!FD || !FD->hasBody())\n    return;\n\n  const Stmt *Body = FD->getBody();\n\
  \  if (!Body)\n    return;\n\n  // Recursively scan for loops and analyze each.\n\
  \  std::vector<const Stmt*> Worklist;\n  Worklist.push_back(Body);\n\n  while (!Worklist.empty())\
  \ {\n    const Stmt *S = Worklist.back();\n    Worklist.pop_back();\n\n    if (!S)\
  \ continue;\n\n    if (const auto *FS = dyn_cast<ForStmt>(S)) {\n      analyzeLoopBody(FS->getBody(),\
  \ D, Mgr, BR);\n    } else if (const auto *WS = dyn_cast<WhileStmt>(S)) {\n    \
  \  analyzeLoopBody(WS->getBody(), D, Mgr, BR);\n    } else if (const auto *DS =\
  \ dyn_cast<DoStmt>(S)) {\n      analyzeLoopBody(DS->getBody(), D, Mgr, BR);\n  \
  \  }\n\n    for (const Stmt *Child : S->children()) {\n      if (Child)\n      \
  \  Worklist.push_back(Child);\n    }\n  }\n}\n\n} // end anonymous namespace\n\n\
  extern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects net_device leak on early goto/return\
  \ between alloc_etherdev and register_netdev in loops\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nocteontx2-pf: fix netdev memory leak in rvu_rep_create()\n\
  \nWhen rvu_rep_devlink_port_register() fails, free_netdev(ndev) for this\nincomplete\
  \ iteration before going to \"exit:\" label.\n\nFixes: 9ed0343f561e (\"octeontx2-pf:\
  \ Add devlink port support\")\nReviewed-by: Przemek Kitszel <przemyslaw.kitszel@intel.com>\n\
  Signed-off-by: Harshit Mogalapalli <harshit.m.mogalapalli@oracle.com>\nLink: https://patch.msgid.link/20241217052326.1086191-1-harshit.m.mogalapalli@oracle.com\n\
  Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ rvu_rep_create in drivers/net/ethernet/marvell/octeontx2/nic/rep.c\nint rvu_rep_create(struct\
  \ otx2_nic *priv, struct netlink_ext_ack *extack)\n{\n\tint rep_cnt = priv->rep_cnt;\n\
  \tstruct net_device *ndev;\n\tstruct rep_dev *rep;\n\tint rep_id, err;\n\tu16 pcifunc;\n\
  \n\terr = rvu_rep_rsrc_init(priv);\n\tif (err)\n\t\treturn -ENOMEM;\n\n\tpriv->reps\
  \ = kcalloc(rep_cnt, sizeof(struct rep_dev *), GFP_KERNEL);\n\tif (!priv->reps)\n\
  \t\treturn -ENOMEM;\n\n\tfor (rep_id = 0; rep_id < rep_cnt; rep_id++) {\n\t\tndev\
  \ = alloc_etherdev(sizeof(*rep));\n\t\tif (!ndev) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\
  \t\t\t\t\t       \"PFVF representor:%d creation failed\",\n\t\t\t\t\t       rep_id);\n\
  \t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\trep = netdev_priv(ndev);\n\t\
  \tpriv->reps[rep_id] = rep;\n\t\trep->mdev = priv;\n\t\trep->netdev = ndev;\n\t\t\
  rep->rep_id = rep_id;\n\n\t\tndev->min_mtu = OTX2_MIN_MTU;\n\t\tndev->max_mtu =\
  \ priv->hw.max_mtu;\n\t\tndev->netdev_ops = &rvu_rep_netdev_ops;\n\t\tpcifunc =\
  \ priv->rep_pf_map[rep_id];\n\t\trep->pcifunc = pcifunc;\n\n\t\tsnprintf(ndev->name,\
  \ sizeof(ndev->name), \"Rpf%dvf%d\",\n\t\t\t rvu_get_pf(pcifunc), (pcifunc & RVU_PFVF_FUNC_MASK));\n\
  \n\t\tndev->hw_features = (NETIF_F_RXCSUM | NETIF_F_IP_CSUM |\n\t\t\t       NETIF_F_IPV6_CSUM\
  \ | NETIF_F_RXHASH |\n\t\t\t       NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6);\n\n\
  \t\tndev->hw_features |= NETIF_F_HW_TC;\n\t\tndev->features |= ndev->hw_features;\n\
  \t\teth_hw_addr_random(ndev);\n\t\terr = rvu_rep_devlink_port_register(rep);\n\t\
  \tif (err)\n\t\t\tgoto exit;\n\n\t\tSET_NETDEV_DEVLINK_PORT(ndev, &rep->dl_port);\n\
  \t\terr = register_netdev(ndev);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\
  \t\t\t\t\t   \"PFVF representor registration failed\");\n\t\t\tfree_netdev(ndev);\n\
  \t\t\tgoto exit;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&rep->stats_wrk, rvu_rep_get_stats);\n\
  \t}\n\terr = rvu_rep_napi_init(priv, extack);\n\tif (err)\n\t\tgoto exit;\n\n\t\
  rvu_eswitch_config(priv, true);\n\treturn 0;\nexit:\n\twhile (--rep_id >= 0) {\n\
  \t\trep = priv->reps[rep_id];\n\t\tunregister_netdev(rep->netdev);\n\t\trvu_rep_devlink_port_unregister(rep);\n\
  \t\tfree_netdev(rep->netdev);\n\t}\n\tkfree(priv->reps);\n\trvu_rep_rsrc_free(priv);\n\
  \treturn err;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/net/ethernet/marvell/octeontx2/nic/rep.c\
  \ b/drivers/net/ethernet/marvell/octeontx2/nic/rep.c\nindex 232b10740c13..9e3fcbae5dee\
  \ 100644\n--- a/drivers/net/ethernet/marvell/octeontx2/nic/rep.c\n+++ b/drivers/net/ethernet/marvell/octeontx2/nic/rep.c\n\
  @@ -680,8 +680,10 @@ int rvu_rep_create(struct otx2_nic *priv, struct netlink_ext_ack\
  \ *extack)\n \t\tndev->features |= ndev->hw_features;\n \t\teth_hw_addr_random(ndev);\n\
  \ \t\terr = rvu_rep_devlink_port_register(rep);\n-\t\tif (err)\n+\t\tif (err) {\n\
  +\t\t\tfree_netdev(ndev);\n \t\t\tgoto exit;\n+\t\t}\n \n \t\tSET_NETDEV_DEVLINK_PORT(ndev,\
  \ &rep->dl_port);\n \t\terr = register_netdev(ndev);\n```\n"
pattern: "## Bug Pattern\n\nExiting early from an iterative resource-creation loop\
  \ after allocating a net_device but before registering it, while the shared cleanup\
  \ block only frees resources from previous iterations (using a pre-decrement index),\
  \ leaving the current iteration\u2019s allocation unfreed.\n\nIn code form:\n\n\
  for (i = 0; i < cnt; i++) {\n    ndev = alloc_etherdev(...);     // allocation\n\
  \    if (!ndev) goto exit;\n\n    if (rvu_rep_devlink_port_register(...))  // fails\
  \ before register_netdev()\n        goto exit;                             // missing\
  \ free_netdev(ndev) here\n    register_netdev(ndev);\n}\nexit:\nwhile (--i >= 0)\
  \ {      // cleans only iterations [0..i-1]\n    unregister_netdev(rep[i]->netdev);\n\
  \    free_netdev(rep[i]->netdev);\n}\n\nRoot cause: Not freeing the per-iteration\
  \ resource on the failure path between alloc_etherdev() and register_netdev(), combined\
  \ with a cleanup loop that intentionally skips the current (partially initialized)\
  \ iteration."
plan: "1) Program state\n- No custom program state is required. The bug is a structural/lexical\
  \ pattern within a single function body.\n\n2) Chosen callbacks\n- Implement the\
  \ checker in checkASTCodeBody. Perform an AST, source-order-aware structural scan\
  \ of each function body to detect:\n  - Per-iteration allocation of a net_device\
  \ in a loop.\n  - Possible early-exit statements before the first register_netdev()\
  \ call for the allocated net_device.\n  - Absence of free_netdev(ndev) on those\
  \ early-exit paths.\n\n3) Detailed steps in checkASTCodeBody\n- High-level scanning\
  \ plan:\n  - For each FunctionDecl with a body, traverse its Stmt subtree.\n  -\
  \ Locate loops (ForStmt, WhileStmt, DoStmt). For each loop, analyze its CompoundStmt\
  \ body against the target pattern.\n\n- Helper utilities to implement:\n  - isCalleeNamed(const\
  \ CallExpr *CE, ArrayRef<StringRef> Names):\n    - Extract the callee identifier\
  \ and check against a small set of names.\n  - getAssignedVarFromCall(const CallExpr\
  \ *CE):\n    - Identify the LHS variable receiving CE\u2019s return:\n      - Case\
  \ A: DeclStmt with a single VarDecl whose init is CE.\n      - Case B: BinaryOperator\
  \ \u2018=\u2019 whose RHS is CE and whose LHS is a DeclRefExpr.\n    - Use findSpecificTypeInParents<DeclStmt>\
  \ and findSpecificTypeInParents<BinaryOperator> to detect each case.\n    - Return\
  \ the VarDecl* of the assigned variable (or nullptr if not found).\n  - isArgumentVar(const\
  \ Expr *Arg, const VarDecl *VD, CheckerContext &C):\n    - Return true if Arg source\
  \ text contains VD->getName() using ExprHasName.\n  - isNetdevAllocCall(const CallExpr\
  \ *CE):\n    - Return true for alloc_etherdev, alloc_netdev, alloc_netdev_mqs (extendable).\n\
  \  - isRegisterNetdevForVar(const CallExpr *CE, const VarDecl *VD, CheckerContext\
  \ &C):\n    - Return true if CE callee is register_netdev and CE->getNumArgs() ==\
  \ 1 and isArgumentVar(CE->getArg(0), VD).\n  - isFreeNetdevForVar(const CallExpr\
  \ *CE, const VarDecl *VD, CheckerContext &C):\n    - Return true if CE callee is\
  \ free_netdev and CE->getNumArgs() == 1 and isArgumentVar(CE->getArg(0), VD).\n\
  \  - stmtIsBetween(SourceManager &SM, const Stmt *A, const Stmt *Mid, const Stmt\
  \ *B):\n    - Return true if A ends before Mid begins and Mid ends before B begins\
  \ (TU order).\n\n- Loop analysis workflow:\n  1) For each loop L (ForStmt/WhileStmt/DoStmt),\
  \ let Body be the loop\u2019s CompoundStmt (or the single Stmt treated as a body).\n\
  \  2) Collect all CallExpr nodes within Body (findSpecificTypeInChildren<CallExpr>\
  \ will give only one; instead traverse children manually or do a small recursive\
  \ walk of Body to gather all CallExpr, GotoStmt, ReturnStmt, IfStmt under L).\n\
  \  3) For each CallExpr CE in Body where isNetdevAllocCall(CE) is true:\n     -\
  \ Determine the assigned LHS variable V via getAssignedVarFromCall(CE). If V is\
  \ null, skip (we only support obvious assignment/decl patterns).\n     - Identify\
  \ the first register_netdev call for V after CE:\n       - Among all CallExpr nodes\
  \ in Body, find those where isRegisterNetdevForVar(CE2, V) is true and stmtIsBetween(SM,\
  \ CE, CE2, LoopEndSentinel) holds; choose the CE2 with the smallest begin location\
  \ greater than CE end location. If none is found, set RegBound = nullptr (we still\
  \ check early-exits up to loop end, but the absence of register_netdev likely increases\
  \ risk).\n     - Compute the \u201Cat-risk segment\u201D:\n       - Start = CE (the\
  \ allocation).\n       - End = RegBound if found, otherwise the end of Body (we\
  \ can approximate with Body end location).\n  4) Within that segment, detect early\
  \ exits:\n     - Gather all GotoStmt and ReturnStmt that satisfy stmtIsBetween(SM,\
  \ Start, ExitStmt, End).\n     - Exclusion: skip exits that are guarding allocation-failure\
  \ of V itself:\n       - If the nearest enclosing IfStmt for ExitStmt has a condition\
  \ that references V by name (ExprHasName(Cond, V->getName(), C)) and the condition\
  \ is a \u201Cnull test\u201D pattern such as:\n         - UnaryOperator kind UO_LNot\
  \ on V, or\n         - BinaryOperator (==/!=) where one side references V and the\
  \ other references NULL/0,\n         then ignore this ExitStmt (no need to free\
  \ when V is NULL).\n       - To get nearest enclosing IfStmt, use findSpecificTypeInParents<IfStmt>(ExitStmt,\
  \ C).\n     - For each remaining ExitStmt (Goto/Return) in that segment, check for\
  \ a local free:\n       - Find the immediate enclosing CompoundStmt Block that contains\
  \ ExitStmt using findSpecificTypeInParents<CompoundStmt>(ExitStmt, C).\n       -\
  \ Inspect the statements within Block in source order from after Start up to just\
  \ before ExitStmt for a call isFreeNetdevForVar(Call, V). You can do this by scanning\
  \ the CompoundStmt\u2019s children and checking their source positions relative\
  \ to Start and ExitStmt.\n       - If no such free_netdev(V) call exists prior to\
  \ the ExitStmt in the same Block, this is a violation candidate.\n  5) Optional\
  \ confidence boost (heuristic, skip if it complicates the implementation):\n   \
  \  - If ExitStmt is a GotoStmt, retrieve its label name. If it is a common cleanup\
  \ label like \u201Cexit\u201D, and the labeled statement later in TU contains a\
  \ while/for loop freeing only \u201Colder\u201D iterations (e.g., a WhileStmt with\
  \ a PreDec \u2018--i\u2019 in the condition), and contains free_netdev on something\
  \ other than V (e.g., array element), then we can note higher confidence. This step\
  \ can be omitted to keep the checker simple.\n\n- Reporting:\n  - For each violation\
  \ candidate, create a BasicBugReport:\n    - Bug type: \u201CLeak on early exit\
  \ before register_netdev\u201D\n    - Message: \u201Cnet_device allocated in loop\
  \ may leak on early exit; missing free_netdev(ndev) before goto/return.\u201D\n\
  \    - Anchor the report at the GotoStmt or ReturnStmt range. Optionally add a note/range\
  \ at the allocation CE.\n  - Use generateNonFatalErrorNode if needed to get a node\
  \ for the report. Otherwise, BasicBugReport is sufficient for AST checkers.\n\n\
  4) Matching details and heuristics\n- Allocation functions:\n  - Recognize: alloc_etherdev,\
  \ alloc_netdev, alloc_netdev_mqs (extendable via a small list).\n- Registration\
  \ function:\n  - Recognize: register_netdev (single argument).\n- Free function:\n\
  \  - Recognize: free_netdev (single argument).\n- Loop identification:\n  - ForStmt,\
  \ WhileStmt, DoStmt, ensuring we\u2019re operating on a per-iteration allocation\
  \ pattern.\n- Early exits:\n  - GotoStmt (most common for cleanup paths).\n  - ReturnStmt\
  \ (early returns also applicable).\n- Avoid false positives on allocation failure:\n\
  \  - Skip exits whose enclosing IfStmt condition tests V for NULL as described above.\n\
  \n5) Use of provided utilities\n- findSpecificTypeInParents<T>:\n  - To find enclosing\
  \ DeclStmt/BinaryOperator for LHS resolution, and enclosing IfStmt/CompoundStmt\
  \ for exit checks.\n- findSpecificTypeInChildren<T>:\n  - To collect CallExpr nodes\
  \ for allocation/registration/free checks under loop bodies or blocks.\n- ExprHasName:\n\
  \  - To match that register_netdev or free_netdev argument refers to the same variable\
  \ (e.g., \u201Cndev\u201D).\n- EvaluateExprToInt / inferSymbolMaxVal / getArraySizeFromExpr\
  \ / getStringSize / getMemRegionFromExpr / functionKnownToDeref:\n  - Not required\
  \ for this checker.\n\n6) Minimal data flow\n- No alias or symbolic reasoning is\
  \ needed. Work only with obvious local variables (\u201Cndev\u201D) in the same\
  \ block/loop. This keeps the checker simple and robust.\n\n7) Success criterion\
  \ (what triggers a report)\n- Inside a loop, a net_device pointer variable V is\
  \ assigned the result of alloc_etherdev/alloc_netdev*.\n- There exists a goto/return\
  \ between that allocation and the first register_netdev(V).\n- The goto/return is\
  \ not guarded by a \u201CV is NULL\u201D condition.\n- There is no free_netdev(V)\
  \ lexically before the goto/return within the same block.\n- Emit one report per\
  \ offending early-exit site."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include\
  \ \"clang/AST/ParentMapContext.h\"\n#include <vector>\n#include <utility>\n#include\
  \ <functional>\n#include <memory>\n#include <initializer_list>\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\nnamespace {\n/* The checker\
  \ callbacks are to be decided. */\nclass SAGenTestChecker : public Checker<check::ASTCodeBody>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Leak on early exit before register_netdev\", \"Memory\
  \ Management\")) {}\n\n      void checkASTCodeBody(const Decl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const;\n\n   private:\n\n      // Helpers\n      static\
  \ bool isCalleeNamed(const CallExpr *CE, std::initializer_list<const char*> Names);\n\
  \      static bool isNetdevAllocCall(const CallExpr *CE);\n      static bool isRegisterNetdevForVar(const\
  \ CallExpr *CE, const VarDecl *VD);\n      static bool isFreeNetdevForVar(const\
  \ CallExpr *CE, const VarDecl *VD);\n\n      static const VarDecl* getAssignedVarFromCall(const\
  \ CallExpr *CE, ASTContext &Ctx);\n      static bool stmtContains(const Stmt *Parent,\
  \ const Stmt *Child);\n      static void collectCallsAndExits(const Stmt *S,\n \
  \                                      std::vector<const CallExpr*> &Calls,\n  \
  \                                     std::vector<const Stmt*> &Exits);\n\n    \
  \  static bool isBetween(const SourceManager &SM,\n                            SourceLocation\
  \ StartAfter,\n                            const Stmt *Mid,\n                  \
  \          SourceLocation EndBefore);\n\n      static const Stmt* findNearestParentOfKind(const\
  \ Stmt *S, ASTContext &Ctx, std::function<bool(const Stmt*)> Pred);\n      static\
  \ const CompoundStmt* findNearestEnclosingCompound(const Stmt *S, ASTContext &Ctx);\n\
  \n      static bool isNullTestOfVar(const Expr *Cond, const VarDecl *VD, ASTContext\
  \ &Ctx);\n      static bool isExitGuardedByNullOfVar(const Stmt *Exit, const VarDecl\
  \ *VD, ASTContext &Ctx);\n\n      static bool containsFreeNetdevForVarAfterStart(const\
  \ Stmt *S, const VarDecl *VD,\n                                                \
  \     const SourceManager &SM, SourceLocation StartAfter);\n\n      void analyzeLoopBody(const\
  \ Stmt *LoopBody, const Decl *D, AnalysisManager &Mgr, BugReporter &BR) const;\n\
  };\n\nstatic SourceLocation getBeginTokenLoc(const Stmt *S, const SourceManager\
  \ &SM) {\n  return SM.getExpansionLoc(S->getBeginLoc());\n}\nstatic SourceLocation\
  \ getEndTokenLoc(const Stmt *S, const SourceManager &SM) {\n  return SM.getExpansionLoc(S->getEndLoc());\n\
  }\n\nbool SAGenTestChecker::isCalleeNamed(const CallExpr *CE, std::initializer_list<const\
  \ char*> Names) {\n  if (!CE) return false;\n  const FunctionDecl *FD = CE->getDirectCallee();\n\
  \  if (!FD) return false;\n  StringRef Name = FD->getName();\n  for (const char\
  \ *N : Names) {\n    if (Name.equals(N))\n      return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isNetdevAllocCall(const CallExpr *CE) {\n  return isCalleeNamed(CE,\
  \ {\"alloc_etherdev\", \"alloc_netdev\", \"alloc_netdev_mqs\"});\n}\n\nstatic const\
  \ DeclRefExpr* getAsDeclRef(const Expr *E) {\n  if (!E) return nullptr;\n  E = E->IgnoreParenImpCasts();\n\
  \  return dyn_cast<DeclRefExpr>(E);\n}\n\nbool SAGenTestChecker::isRegisterNetdevForVar(const\
  \ CallExpr *CE, const VarDecl *VD) {\n  if (!CE || !VD) return false;\n  if (!isCalleeNamed(CE,\
  \ {\"register_netdev\"})) return false;\n  if (CE->getNumArgs() != 1) return false;\n\
  \  const Expr *Arg = CE->getArg(0);\n  if (const DeclRefExpr *DRE = getAsDeclRef(Arg))\
  \ {\n    if (const VarDecl *A = dyn_cast<VarDecl>(DRE->getDecl()))\n      return\
  \ A == VD;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isFreeNetdevForVar(const\
  \ CallExpr *CE, const VarDecl *VD) {\n  if (!CE || !VD) return false;\n  if (!isCalleeNamed(CE,\
  \ {\"free_netdev\"})) return false;\n  if (CE->getNumArgs() != 1) return false;\n\
  \  const Expr *Arg = CE->getArg(0);\n  if (const DeclRefExpr *DRE = getAsDeclRef(Arg))\
  \ {\n    if (const VarDecl *A = dyn_cast<VarDecl>(DRE->getDecl()))\n      return\
  \ A == VD;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::stmtContains(const\
  \ Stmt *Parent, const Stmt *Child) {\n  if (!Parent || !Child) return false;\n \
  \ if (Parent == Child) return true;\n  for (const Stmt *Sub : Parent->children())\
  \ {\n    if (Sub && stmtContains(Sub, Child))\n      return true;\n  }\n  return\
  \ false;\n}\n\nconst VarDecl* SAGenTestChecker::getAssignedVarFromCall(const CallExpr\
  \ *CE, ASTContext &Ctx) {\n  if (!CE) return nullptr;\n\n  DynTypedNode Node = DynTypedNode::create(*CE);\n\
  \n  // Climb up through wrappers to find either a BinaryOperator (=) or a DeclStmt.\n\
  \  for (int depth = 0; depth < 16; ++depth) {\n    auto Parents = Ctx.getParents(Node);\n\
  \    if (Parents.empty())\n      break;\n\n    // Try to find a BinaryOperator parent\
  \ (assignment) first.\n    const BinaryOperator *FoundBO = nullptr;\n    const DeclStmt\
  \ *FoundDS = nullptr;\n    const Expr *FoundExpr = nullptr;\n\n    for (const auto\
  \ &P : Parents) {\n      if (!FoundBO) FoundBO = P.get<BinaryOperator>();\n    \
  \  if (!FoundDS) FoundDS = P.get<DeclStmt>();\n      if (!FoundExpr) FoundExpr =\
  \ P.get<Expr>();\n    }\n\n    if (FoundBO) {\n      const BinaryOperator *BO =\
  \ FoundBO;\n      if (BO->isAssignmentOp() && BO->getOpcode() == BO_Assign) {\n\
  \        if (stmtContains(BO->getRHS(), CE)) {\n          const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \          if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(LHS)) {\n        \
  \    if (const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n              return\
  \ VD;\n          }\n        }\n      }\n      // If it's some other binop or not\
  \ containing CE, continue climbing.\n      Node = DynTypedNode::create(*BO);\n \
  \     continue;\n    }\n\n    if (FoundDS) {\n      const DeclStmt *DS = FoundDS;\n\
  \      if (DS->isSingleDecl()) {\n        if (const VarDecl *VD = dyn_cast<VarDecl>(DS->getSingleDecl()))\
  \ {\n          if (const Expr *Init = VD->getInit()) {\n            if (stmtContains(Init,\
  \ CE))\n              return VD;\n          }\n        }\n      }\n      Node =\
  \ DynTypedNode::create(*DS);\n      continue;\n    }\n\n    if (FoundExpr) {\n \
  \     Node = DynTypedNode::create(*FoundExpr);\n      continue;\n    }\n\n    break;\n\
  \  }\n\n  return nullptr;\n}\n\nvoid SAGenTestChecker::collectCallsAndExits(const\
  \ Stmt *S,\n                                            std::vector<const CallExpr*>\
  \ &Calls,\n                                            std::vector<const Stmt*>\
  \ &Exits) {\n  if (!S) return;\n\n  if (const auto *CE = dyn_cast<CallExpr>(S))\
  \ {\n    Calls.push_back(CE);\n  } else if (isa<GotoStmt>(S) || isa<ReturnStmt>(S))\
  \ {\n    Exits.push_back(S);\n  }\n\n  for (const Stmt *Child : S->children()) {\n\
  \    if (Child)\n      collectCallsAndExits(Child, Calls, Exits);\n  }\n}\n\nbool\
  \ SAGenTestChecker::isBetween(const SourceManager &SM,\n                       \
  \          SourceLocation StartAfter,\n                                 const Stmt\
  \ *Mid,\n                                 SourceLocation EndBefore) {\n  if (!Mid)\
  \ return false;\n  SourceLocation MidBegin = getBeginTokenLoc(Mid, SM);\n  SourceLocation\
  \ MidEnd   = getEndTokenLoc(Mid, SM);\n\n  bool AfterStart = SM.isBeforeInTranslationUnit(StartAfter,\
  \ MidBegin);\n  bool BeforeEnd  = SM.isBeforeInTranslationUnit(MidEnd, EndBefore);\n\
  \  return AfterStart && BeforeEnd;\n}\n\nconst Stmt* SAGenTestChecker::findNearestParentOfKind(const\
  \ Stmt *S, ASTContext &Ctx, std::function<bool(const Stmt*)> Pred) {\n  if (!S)\
  \ return nullptr;\n  DynTypedNode Node = DynTypedNode::create(*S);\n  for (int depth\
  \ = 0; depth < 32; ++depth) {\n    auto Parents = Ctx.getParents(Node);\n    if\
  \ (Parents.empty())\n      break;\n    const Stmt *Found = nullptr;\n    const Stmt\
  \ *AnyParent = nullptr;\n    for (const auto &P : Parents) {\n      if (const Stmt\
  \ *PS = P.get<Stmt>()) {\n        AnyParent = PS;\n        if (Pred(PS)) {\n   \
  \       Found = PS;\n          break;\n        }\n      }\n    }\n    if (Found)\n\
  \      return Found;\n    if (!AnyParent)\n      break;\n    Node = DynTypedNode::create(*AnyParent);\n\
  \  }\n  return nullptr;\n}\n\nconst CompoundStmt* SAGenTestChecker::findNearestEnclosingCompound(const\
  \ Stmt *S, ASTContext &Ctx) {\n  return dyn_cast_or_null<CompoundStmt>(findNearestParentOfKind(\n\
  \      S, Ctx, [](const Stmt *X) { return isa<CompoundStmt>(X); }));\n}\n\nstatic\
  \ bool isZeroOrNullPtr(const Expr *E, ASTContext &Ctx) {\n  if (!E) return false;\n\
  \  return E->isNullPointerConstant(Ctx, Expr::NPC_ValueDependentIsNull);\n}\n\n\
  bool SAGenTestChecker::isNullTestOfVar(const Expr *Cond, const VarDecl *VD, ASTContext\
  \ &Ctx) {\n  if (!Cond || !VD) return false;\n  const Expr *C = Cond->IgnoreParenImpCasts();\n\
  \n  // if (!vd)\n  if (const auto *UO = dyn_cast<UnaryOperator>(C)) {\n    if (UO->getOpcode()\
  \ == UO_LNot) {\n      if (const DeclRefExpr *DRE = getAsDeclRef(UO->getSubExpr()))\
  \ {\n        if (const VarDecl *V = dyn_cast<VarDecl>(DRE->getDecl()))\n       \
  \   return V == VD;\n      }\n    }\n  }\n\n  // if (vd == NULL) or if (vd != NULL)\n\
  \  if (const auto *BO = dyn_cast<BinaryOperator>(C)) {\n    if (BO->getOpcode()\
  \ == BO_EQ || BO->getOpcode() == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n      const DeclRefExpr\
  \ *LDRE = dyn_cast<DeclRefExpr>(LHS);\n      const DeclRefExpr *RDRE = dyn_cast<DeclRefExpr>(RHS);\n\
  \n      if (LDRE && dyn_cast<VarDecl>(LDRE->getDecl()) == VD && isZeroOrNullPtr(RHS,\
  \ Ctx))\n        return true;\n      if (RDRE && dyn_cast<VarDecl>(RDRE->getDecl())\
  \ == VD && isZeroOrNullPtr(LHS, Ctx))\n        return true;\n    }\n  }\n\n  //\
  \ if (vd) -- positive test\n  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(C))\
  \ {\n    if (const VarDecl *V = dyn_cast<VarDecl>(DRE->getDecl()))\n      return\
  \ V == VD;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isExitGuardedByNullOfVar(const\
  \ Stmt *Exit, const VarDecl *VD, ASTContext &Ctx) {\n  if (!Exit || !VD) return\
  \ false;\n  const IfStmt *IS = dyn_cast_or_null<IfStmt>(findNearestParentOfKind(\n\
  \      Exit, Ctx, [](const Stmt *X) { return isa<IfStmt>(X); }));\n  if (!IS) return\
  \ false;\n\n  const Expr *Cond = IS->getCond();\n  if (!Cond) return false;\n\n\
  \  // We conservatively assume that if the nearest enclosing if-statement's\n  //\
  \ condition is a null/non-null test of VD, then the exit is guarded by a\n  // null-check\
  \ of the var, and thus no leak occurs when VD is NULL.\n  return isNullTestOfVar(Cond,\
  \ VD, Ctx);\n}\n\nbool SAGenTestChecker::containsFreeNetdevForVarAfterStart(const\
  \ Stmt *S, const VarDecl *VD,\n                                                \
  \          const SourceManager &SM, SourceLocation StartAfter) {\n  if (!S || !VD)\
  \ return false;\n\n  if (const auto *CE = dyn_cast<CallExpr>(S)) {\n    if (isFreeNetdevForVar(CE,\
  \ VD)) {\n      if (SM.isBeforeInTranslationUnit(StartAfter, getBeginTokenLoc(CE,\
  \ SM)))\n        return true;\n    }\n  }\n\n  for (const Stmt *Child : S->children())\
  \ {\n    if (Child && containsFreeNetdevForVarAfterStart(Child, VD, SM, StartAfter))\n\
  \      return true;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::analyzeLoopBody(const\
  \ Stmt *LoopBody, const Decl *D, AnalysisManager &Mgr, BugReporter &BR) const {\n\
  \  if (!LoopBody) return;\n\n  ASTContext &Ctx = Mgr.getASTContext();\n  const SourceManager\
  \ &SM = BR.getSourceManager();\n  AnalysisDeclContext *AC = Mgr.getAnalysisDeclContext(D);\n\
  \n  // Collect all calls and exits within the loop body.\n  std::vector<const CallExpr*>\
  \ Calls;\n  std::vector<const Stmt*> Exits;\n  collectCallsAndExits(LoopBody, Calls,\
  \ Exits);\n\n  // For each allocation inside the loop, analyze early exits before\
  \ register_netdev.\n  for (const CallExpr *AllocCE : Calls) {\n    if (!isNetdevAllocCall(AllocCE))\n\
  \      continue;\n\n    const VarDecl *VD = getAssignedVarFromCall(AllocCE, Ctx);\n\
  \    if (!VD)\n      continue; // Only handle obvious assignment targets.\n\n  \
  \  // Find the first register_netdev(VD) after the allocation.\n    const CallExpr\
  \ *FirstReg = nullptr;\n    SourceLocation AllocEnd = getEndTokenLoc(AllocCE, SM);\n\
  \    SourceLocation BodyEnd = getEndTokenLoc(LoopBody, SM);\n    SourceLocation\
  \ EndBoundLoc = BodyEnd;\n\n    for (const CallExpr *C : Calls) {\n      if (isRegisterNetdevForVar(C,\
  \ VD)) {\n        if (SM.isBeforeInTranslationUnit(AllocEnd, getBeginTokenLoc(C,\
  \ SM))) {\n          if (!FirstReg ||\n              SM.isBeforeInTranslationUnit(getBeginTokenLoc(C,\
  \ SM),\n                                           getBeginTokenLoc(FirstReg, SM)))\
  \ {\n            FirstReg = C;\n          }\n        }\n      }\n    }\n    if (FirstReg)\n\
  \      EndBoundLoc = getBeginTokenLoc(FirstReg, SM);\n\n    // Look for exits between\
  \ allocation and registration.\n    for (const Stmt *ExitS : Exits) {\n      if\
  \ (!isBetween(SM, AllocEnd, ExitS, EndBoundLoc))\n        continue;\n\n      //\
  \ Skip exits that are guarded by a null-check on VD (allocation failed path).\n\
  \      if (isExitGuardedByNullOfVar(ExitS, VD, Ctx))\n        continue;\n\n    \
  \  // Ensure there is a free_netdev(VD) before this exit in the same enclosing compound.\n\
  \      const CompoundStmt *CS = findNearestEnclosingCompound(ExitS, Ctx);\n    \
  \  bool HasLocalFree = false;\n      if (CS) {\n        for (const Stmt *Child :\
  \ CS->body()) {\n          if (Child == ExitS)\n            break;\n          //\
  \ Consider only those after the allocation point.\n          if (SM.isBeforeInTranslationUnit(AllocEnd,\
  \ getBeginTokenLoc(Child, SM))) {\n            if (containsFreeNetdevForVarAfterStart(Child,\
  \ VD, SM, AllocEnd)) {\n              HasLocalFree = true;\n              break;\n\
  \            }\n          }\n        }\n      }\n\n      if (!HasLocalFree) {\n\
  \        // Report: missing free_netdev before early exit.\n        PathDiagnosticLocation\
  \ ELoc =\n            PathDiagnosticLocation::createBegin(ExitS, SM, AC);\n    \
  \    auto R = std::make_unique<BasicBugReport>(\n            *BT,\n            \"\
  net_device allocated in loop may leak on early exit; \"\n            \"missing free_netdev\
  \ before goto/return\",\n            ELoc);\n        R->addRange(ExitS->getSourceRange());\n\
  \        BR.emitReport(std::move(R));\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkASTCodeBody(const\
  \ Decl *D, AnalysisManager &Mgr, BugReporter &BR) const {\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!FD || !FD->hasBody())\n    return;\n\n  const Stmt *Body = FD->getBody();\n\
  \  if (!Body)\n    return;\n\n  // Recursively scan for loops and analyze each.\n\
  \  std::vector<const Stmt*> Worklist;\n  Worklist.push_back(Body);\n\n  while (!Worklist.empty())\
  \ {\n    const Stmt *S = Worklist.back();\n    Worklist.pop_back();\n\n    if (!S)\
  \ continue;\n\n    if (const auto *FS = dyn_cast<ForStmt>(S)) {\n      analyzeLoopBody(FS->getBody(),\
  \ D, Mgr, BR);\n    } else if (const auto *WS = dyn_cast<WhileStmt>(S)) {\n    \
  \  analyzeLoopBody(WS->getBody(), D, Mgr, BR);\n    } else if (const auto *DS =\
  \ dyn_cast<DoStmt>(S)) {\n      analyzeLoopBody(DS->getBody(), D, Mgr, BR);\n  \
  \  }\n\n    for (const Stmt *Child : S->children()) {\n      if (Child)\n      \
  \  Worklist.push_back(Child);\n    }\n  }\n}\n\n} // end anonymous namespace\n\n\
  extern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects net_device leak on early goto/return\
  \ between alloc_etherdev and register_netdev in loops\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
