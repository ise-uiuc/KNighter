_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 19ebc1e6cab334a8193398d4152deb76019b5d34
commit_type: Double-Free
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include\
  \ <algorithm>\n#include <utility>\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n // If necessary\n\nnamespace {\n/* The checker callbacks\
  \ are to be decided. */\nclass SAGenTestChecker : public Checker<check::ASTCodeBody>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Double free on retry\", \"Memory Management\")) {}\n\n\
  \      void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter &BR)\
  \ const;\n\n   private:\n\n      // Helper data structures\n      enum class WriteKind\
  \ { NullInit, AllocWrite, OtherWrite };\n\n      struct LabelInfo {\n        const\
  \ LabelDecl *LD = nullptr;\n        std::string Name;\n        SourceLocation Loc;\n\
  \      };\n\n      struct GotoInfo {\n        const LabelDecl *Target = nullptr;\n\
  \        SourceLocation Loc;\n      };\n\n      struct FreeEvent {\n        const\
  \ VarDecl *Var = nullptr;\n        std::string Callee;\n        SourceLocation Loc;\n\
  \      };\n\n      struct WriteEvent {\n        const VarDecl *Var = nullptr;\n\
  \        WriteKind Kind = WriteKind::OtherWrite;\n        SourceLocation Loc;\n\
  \      };\n\n      // Visitor to collect events\n      class BodyVisitor : public\
  \ RecursiveASTVisitor<BodyVisitor> {\n      public:\n        BodyVisitor(ASTContext\
  \ &Ctx,\n                    std::vector<LabelInfo> &Labels,\n                 \
  \   std::vector<GotoInfo> &Gotos,\n                    std::vector<FreeEvent> &Frees,\n\
  \                    std::vector<WriteEvent> &Writes)\n            : Ctx(Ctx), Labels(Labels),\
  \ Gotos(Gotos), Frees(Frees), Writes(Writes) {}\n\n        bool VisitLabelStmt(LabelStmt\
  \ *S) {\n          LabelInfo LI;\n          LI.LD = S->getDecl();\n          if\
  \ (LI.LD)\n            LI.Name = LI.LD->getName().str();\n          LI.Loc = S->getBeginLoc();\n\
  \          Labels.push_back(LI);\n          return true;\n        }\n\n        bool\
  \ VisitGotoStmt(GotoStmt *S) {\n          GotoInfo GI;\n          GI.Target = S->getLabel();\n\
  \          GI.Loc = S->getGotoLoc();\n          Gotos.push_back(GI);\n         \
  \ return true;\n        }\n\n        bool VisitCallExpr(CallExpr *E) {\n       \
  \   const FunctionDecl *FD = E->getDirectCallee();\n          if (!FD) return true;\n\
  \n          StringRef Name = FD->getName();\n          if (isFreeLike(Name)) {\n\
  \            if (E->getNumArgs() >= 1) {\n              const Expr *Arg0 = E->getArg(0);\n\
  \              Arg0 = Arg0 ? Arg0->IgnoreParenImpCasts() : nullptr;\n          \
  \    if (const auto *DRE = dyn_cast_or_null<DeclRefExpr>(Arg0)) {\n            \
  \    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n               \
  \   if (VD->getType()->isPointerType()) {\n                    FreeEvent FE;\n \
  \                   FE.Var = VD;\n                    FE.Callee = Name.str();\n\
  \                    FE.Loc = E->getExprLoc();\n                    Frees.push_back(FE);\n\
  \                  }\n                }\n              }\n            }\n      \
  \    }\n          return true;\n        }\n\n        bool VisitBinaryOperator(BinaryOperator\
  \ *BO) {\n          if (!BO->isAssignmentOp())\n            return true;\n\n   \
  \       const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n          const Expr\
  \ *RHS = BO->getRHS();\n\n          const auto *LHS_DRE = dyn_cast<DeclRefExpr>(LHS);\n\
  \          if (!LHS_DRE) return true;\n\n          const auto *VD = dyn_cast<VarDecl>(LHS_DRE->getDecl());\n\
  \          if (!VD) return true;\n          if (!VD->getType()->isPointerType())\
  \ return true;\n\n          WriteEvent WE;\n          WE.Var = VD;\n          WE.Loc\
  \ = BO->getOperatorLoc();\n          WE.Kind = classifyWrite(RHS);\n          Writes.push_back(WE);\n\
  \          return true;\n        }\n\n        bool VisitDeclStmt(DeclStmt *DS) {\n\
  \          if (!DS->isSingleDecl())\n            return true;\n\n          const\
  \ Decl *D = DS->getSingleDecl();\n          const auto *VD = dyn_cast<VarDecl>(D);\n\
  \          if (!VD) return true;\n          if (!VD->getType()->isPointerType())\
  \ return true;\n\n          if (const Expr *Init = VD->getInit()) {\n          \
  \  WriteEvent WE;\n            WE.Var = VD;\n            WE.Loc = Init->getExprLoc();\n\
  \            WE.Kind = classifyWrite(Init);\n            Writes.push_back(WE);\n\
  \          }\n          return true;\n        }\n\n      private:\n        ASTContext\
  \ &Ctx;\n        std::vector<LabelInfo> &Labels;\n        std::vector<GotoInfo>\
  \ &Gotos;\n        std::vector<FreeEvent> &Frees;\n        std::vector<WriteEvent>\
  \ &Writes;\n\n        static bool isFreeLike(StringRef Name) {\n          return\
  \ Name == \"kfree\" || Name == \"kvfree\" || Name == \"vfree\" ||\n            \
  \     Name == \"kfree_sensitive\";\n        }\n\n        static bool isAllocLike(StringRef\
  \ Name) {\n          return Name == \"kmalloc\" || Name == \"kzalloc\" || Name ==\
  \ \"kcalloc\" ||\n                 Name == \"kvzalloc\" || Name == \"vzalloc\" ||\
  \ Name == \"kmalloc_array\" ||\n                 Name == \"kstrdup\" || Name ==\
  \ \"krealloc\";\n        }\n\n        WriteKind classifyWrite(const Expr *RHS) {\n\
  \          if (!RHS) return WriteKind::OtherWrite;\n\n          // Null detection\n\
  \          if (RHS->isNullPointerConstant(Ctx, Expr::NPC_ValueDependentIsNull))\n\
  \            return WriteKind::NullInit;\n\n          // Zero literal (covers cases\
  \ where null macro didn't fold)\n          if (const auto *IL = dyn_cast<IntegerLiteral>(RHS->IgnoreParenCasts()))\
  \ {\n            if (IL->getValue() == 0)\n              return WriteKind::NullInit;\n\
  \          }\n\n          // Alloc-like calls\n          if (const auto *CE = dyn_cast<CallExpr>(RHS->IgnoreParenCasts()))\
  \ {\n            const FunctionDecl *FD = CE->getDirectCallee();\n            if\
  \ (FD) {\n              StringRef Name = FD->getName();\n              if (isAllocLike(Name))\n\
  \                return WriteKind::AllocWrite;\n            }\n          }\n\n \
  \         return WriteKind::OtherWrite;\n        }\n      }; // end BodyVisitor\n\
  \n      // Helper utilities\n      static SourceLocation expLoc(const SourceManager\
  \ &SM, SourceLocation L) {\n        return SM.getExpansionLoc(L);\n      }\n\n \
  \     static bool before(const SourceManager &SM, SourceLocation A, SourceLocation\
  \ B) {\n        A = expLoc(SM, A);\n        B = expLoc(SM, B);\n        return SM.isBeforeInTranslationUnit(A,\
  \ B);\n      }\n\n      static bool equalLoc(const SourceManager &SM, SourceLocation\
  \ A, SourceLocation B) {\n        A = expLoc(SM, A);\n        B = expLoc(SM, B);\n\
  \        return A == B;\n      }\n\n      static bool lessOrEqual(const SourceManager\
  \ &SM, SourceLocation A, SourceLocation B) {\n        return before(SM, A, B) ||\
  \ equalLoc(SM, A, B);\n      }\n\n      static const LabelDecl *nearestCleanupBefore(const\
  \ SourceManager &SM,\n                                                   const std::vector<LabelInfo>\
  \ &Labels,\n                                                   const std::set<const\
  \ LabelDecl*> &CleanupLabels,\n                                                \
  \   SourceLocation Loc) {\n        const LabelDecl *Best = nullptr;\n        SourceLocation\
  \ BestLoc;\n        for (const auto &L : Labels) {\n          if (!CleanupLabels.count(L.LD))\n\
  \            continue;\n          if (lessOrEqual(SM, L.Loc, Loc)) {\n         \
  \   if (!Best || before(SM, BestLoc, L.Loc)) {\n              Best = L.LD;\n   \
  \           BestLoc = L.Loc;\n            }\n          }\n        }\n        return\
  \ Best;\n      }\n\n      static bool hasAllocBefore(const SourceManager &SM,\n\
  \                                 const std::vector<WriteEvent> &Writes,\n     \
  \                            const VarDecl *V,\n                               \
  \  SourceLocation Loc) {\n        for (const auto &W : Writes) {\n          if (W.Var\
  \ == V && W.Kind == WriteKind::AllocWrite && before(SM, W.Loc, Loc))\n         \
  \   return true;\n        }\n        return false;\n      }\n\n      static SourceLocation\
  \ getLabelLoc(const std::vector<LabelInfo> &Labels,\n                          \
  \              const LabelDecl *LD) {\n        for (const auto &L : Labels)\n  \
  \        if (L.LD == LD) return L.Loc;\n        return SourceLocation();\n     \
  \ }\n\n      static bool isNullInitBetween(const SourceManager &SM,\n          \
  \                          const std::vector<WriteEvent> &Writes,\n            \
  \                        const VarDecl *V,\n                                   \
  \ SourceLocation StartExclusive,\n                                    SourceLocation\
  \ EndExclusive) {\n        for (const auto &W : Writes) {\n          if (W.Var !=\
  \ V) continue;\n          if (W.Kind != WriteKind::NullInit) continue;\n       \
  \   if (before(SM, StartExclusive, W.Loc) && before(SM, W.Loc, EndExclusive))\n\
  \            return true;\n        }\n        return false;\n      }\n\n      static\
  \ bool writeAfter(const SourceManager &SM,\n                             const WriteEvent\
  \ &A,\n                             const WriteEvent &B) {\n        return before(SM,\
  \ B.Loc, A.Loc);\n      }\n\n      static SourceLocation firstWriteAfter(const SourceManager\
  \ &SM,\n                                            const std::vector<WriteEvent>\
  \ &Writes,\n                                            const VarDecl *V,\n    \
  \                                        SourceLocation LocR,\n                \
  \                            bool &Found) {\n        Found = false;\n        SourceLocation\
  \ Best;\n        for (const auto &W : Writes) {\n          if (W.Var != V) continue;\n\
  \          if (before(SM, LocR, W.Loc)) {\n            if (!Found || before(SM,\
  \ W.Loc, Best)) {\n              Best = W.Loc;\n              Found = true;\n  \
  \          }\n          }\n        }\n        return Best;\n      }\n\n}; // end\
  \ class\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const {\n  const auto *FD = dyn_cast<FunctionDecl>(D);\n\
  \  if (!FD) return;\n  const Stmt *Body = FD->getBody();\n  if (!Body) return;\n\
  \n  ASTContext &ACtx = Mgr.getASTContext();\n  const SourceManager &SM = Mgr.getSourceManager();\n\
  \n  std::vector<LabelInfo> Labels;\n  std::vector<GotoInfo> Gotos;\n  std::vector<FreeEvent>\
  \ Frees;\n  std::vector<WriteEvent> Writes;\n\n  BodyVisitor V(ACtx, Labels, Gotos,\
  \ Frees, Writes);\n  V.TraverseStmt(const_cast<Stmt *>(Body));\n\n  // Classify\
  \ labels as cleanup or retry via goto directions\n  std::set<const LabelDecl*> CleanupLabels;\n\
  \  std::set<const LabelDecl*> RetryLabels;\n  std::map<const LabelDecl*, std::vector<SourceLocation>>\
  \ GotoLocsByLabel;\n\n  for (const auto &G : Gotos) {\n    if (!G.Target) continue;\n\
  \    SourceLocation LLoc = getLabelLoc(Labels, G.Target);\n    if (LLoc.isInvalid())\
  \ continue;\n\n    GotoLocsByLabel[G.Target].push_back(G.Loc);\n\n    if (before(SM,\
  \ G.Loc, LLoc)) {\n      CleanupLabels.insert(G.Target); // forward goto to label\
  \ => cleanup\n    } else if (before(SM, LLoc, G.Loc)) {\n      RetryLabels.insert(G.Target);\
  \   // backward goto => retry\n    }\n  }\n\n  // Map each free to the nearest preceding\
  \ cleanup label if any and require prior alloc\n  struct FreedInCleanup {\n    const\
  \ VarDecl *Var = nullptr;\n    const LabelDecl *Cleanup = nullptr;\n    SourceLocation\
  \ FreeLoc;\n  };\n  std::vector<FreedInCleanup> FreedList;\n  for (const auto &F\
  \ : Frees) {\n    if (!F.Var) continue;\n    const LabelDecl *C = nearestCleanupBefore(SM,\
  \ Labels, CleanupLabels, F.Loc);\n    if (!C) continue;\n    if (!hasAllocBefore(SM,\
  \ Writes, F.Var, F.Loc))\n      continue;\n    FreedList.push_back({F.Var, C, F.Loc});\n\
  \  }\n\n  // For each freed var in cleanup, and each retry label reachable after\
  \ free, check missing NULL reinit\n  std::set<std::pair<const VarDecl*, const LabelDecl*>>\
  \ Reported; // (Var, RetryLabel)\n  for (const auto &FI : FreedList) {\n    // Consider\
  \ retry labels R such that there is a goto to R after FI.FreeLoc\n    for (const\
  \ LabelDecl *R : RetryLabels) {\n      auto It = GotoLocsByLabel.find(R);\n    \
  \  if (It == GotoLocsByLabel.end()) continue;\n\n      // Any goto to R after free?\n\
  \      bool HasBackwardGotoAfterFree = false;\n      for (const auto &GLoc : It->second)\
  \ {\n        if (before(SM, FI.FreeLoc, GLoc)) {\n          HasBackwardGotoAfterFree\
  \ = true;\n          break;\n        }\n      }\n      if (!HasBackwardGotoAfterFree)\
  \ continue;\n\n      // Now ensure there's a goto to cleanup C between R and first\
  \ write of Var after R\n      SourceLocation RLoc = getLabelLoc(Labels, R);\n  \
  \    if (RLoc.isInvalid()) continue;\n\n      bool FoundFirstWrite = false;\n  \
  \    SourceLocation FirstWLoc = firstWriteAfter(SM, Writes, FI.Var, RLoc, FoundFirstWrite);\n\
  \n      // Iterate gotos to the cleanup label C, and check those between RLoc and\
  \ FirstWLoc (or any after R if no write)\n      auto ItC = GotoLocsByLabel.find(FI.Cleanup);\n\
  \      if (ItC == GotoLocsByLabel.end()) continue;\n\n      // Find the first offending\
  \ goto (no NULL init between R and Goto)\n      SourceLocation OffendingGoto;\n\
  \      for (const auto &GLoc : ItC->second) {\n        if (!before(SM, RLoc, GLoc))\n\
  \          continue; // must be after retry label\n        if (FoundFirstWrite &&\
  \ !before(SM, GLoc, FirstWLoc))\n          continue; // must be before the first\
  \ write after R\n\n        // Is there a NullInit write for Var between RLoc and\
  \ GLoc?\n        if (!isNullInitBetween(SM, Writes, FI.Var, RLoc, GLoc)) {\n   \
  \       OffendingGoto = GLoc;\n          break;\n        }\n      }\n\n      if\
  \ (OffendingGoto.isInvalid())\n        continue;\n\n      // Deduplicate (Var, RetryLabel)\n\
  \      auto Key = std::make_pair(FI.Var, R);\n      if (Reported.count(Key))\n \
  \       continue;\n      Reported.insert(Key);\n\n      // Report\n      PathDiagnosticLocation\
  \ ELoc(OffendingGoto, BR.getSourceManager(), FD);\n      auto Rpt = std::make_unique<BasicBugReport>(\n\
  \          *BT, \"Pointer freed in cleanup is not reset to NULL on retry\", ELoc);\n\
  \      // Provide context\n      std::string Msg = \"Possible double free: '\";\n\
  \      Msg += FI.Var->getName().str();\n      Msg += \"' is freed in cleanup and\
  \ not set to NULL before goto to cleanup on retry.\";\n      Rpt->setDeclWithIssue(FD);\n\
  \      Rpt->addNote(Msg, ELoc);\n\n      // Add note for free site\n      PathDiagnosticLocation\
  \ FreeLoc(FI.FreeLoc, BR.getSourceManager(), FD);\n      Rpt->addNote(\"Freed here\
  \ in cleanup\", FreeLoc);\n\n      BR.emitReport(std::move(Rpt));\n    }\n  }\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects missing pointer NULL reinitialization at retry labels leading\
  \ to double free in cleanup\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nsmb: client: fix possible double free in smb2_set_ea()\n\
  \nClang static checker(scan-build) warning\uFF1A\nfs/smb/client/smb2ops.c:1304:2:\
  \ Attempt to free released memory.\n 1304 |         kfree(ea);\n      |        \
  \ ^~~~~~~~~\n\nThere is a double free in such case:\n'ea is initialized to NULL'\
  \ -> 'first successful memory allocation for\nea' -> 'something failed, goto sea_exit'\
  \ -> 'first memory release for ea'\n-> 'goto replay_again' -> 'second goto sea_exit\
  \ before allocate memory\nfor ea' -> 'second memory release for ea resulted in double\
  \ free'.\n\nRe-initialie 'ea' to NULL near to the replay_again label, it can fix\
  \ this\ndouble free problem.\n\nFixes: 4f1fffa23769 (\"cifs: commands that are retried\
  \ should have replay flag set\")\nReviewed-by: Dan Carpenter <dan.carpenter@linaro.org>\n\
  Signed-off-by: Su Hui <suhui@nfschina.com>\nSigned-off-by: Steve French <stfrench@microsoft.com>\n\
  \n## Buggy Code\n\n```c\n// Function: smb2_set_ea in fs/smb/client/smb2ops.c\nstatic\
  \ int\nsmb2_set_ea(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const\
  \ char *path, const char *ea_name, const void *ea_value,\n\t    const __u16 ea_value_len,\
  \ const struct nls_table *nls_codepage,\n\t    struct cifs_sb_info *cifs_sb)\n{\n\
  \tstruct smb2_compound_vars *vars;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct\
  \ TCP_Server_Info *server;\n\tstruct smb_rqst *rqst;\n\tstruct kvec *rsp_iov;\n\t\
  __le16 *utf16_path = NULL;\n\tint ea_name_len = strlen(ea_name);\n\tint flags =\
  \ CIFS_CP_CREATE_CLOSE_OP;\n\tint len;\n\tint resp_buftype[3];\n\tstruct cifs_open_parms\
  \ oparms;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_fid fid;\n\tunsigned\
  \ int size[1];\n\tvoid *data[1];\n\tstruct smb2_file_full_ea_info *ea = NULL;\n\t\
  struct smb2_query_info_rsp *rsp;\n\tint rc, used_len = 0;\n\tint retries = 0, cur_sleep\
  \ = 1;\n\nreplay_again:\n\t/* reinitialize for possible replay */\n\tflags = CIFS_CP_CREATE_CLOSE_OP;\n\
  \toplock = SMB2_OPLOCK_LEVEL_NONE;\n\tserver = cifs_pick_channel(ses);\n\n\tif (smb3_encryption_required(tcon))\n\
  \t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tif (ea_name_len > 255)\n\t\treturn -EINVAL;\n\
  \n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path)\n\
  \t\treturn -ENOMEM;\n\n\tresp_buftype[0] = resp_buftype[1] = resp_buftype[2] = CIFS_NO_BUFFER;\n\
  \tvars = kzalloc(sizeof(*vars), GFP_KERNEL);\n\tif (!vars) {\n\t\trc = -ENOMEM;\n\
  \t\tgoto out_free_path;\n\t}\n\trqst = vars->rqst;\n\trsp_iov = vars->rsp_iov;\n\
  \n\tif (ses->server->ops->query_all_EAs) {\n\t\tif (!ea_value) {\n\t\t\trc = ses->server->ops->query_all_EAs(xid,\
  \ tcon, path,\n\t\t\t\t\t\t\t     ea_name, NULL, 0,\n\t\t\t\t\t\t\t     cifs_sb);\n\
  \t\t\tif (rc == -ENODATA)\n\t\t\t\tgoto sea_exit;\n\t\t} else {\n\t\t\t/* If we\
  \ are adding a attribute we should first check\n\t\t\t * if there will be enough\
  \ space available to store\n\t\t\t * the new EA. If not we should not add it since\
  \ we\n\t\t\t * would not be able to even read the EAs back.\n\t\t\t */\n\t\t\trc\
  \ = smb2_query_info_compound(xid, tcon, path,\n\t\t\t\t      FILE_READ_EA,\n\t\t\
  \t\t      FILE_FULL_EA_INFORMATION,\n\t\t\t\t      SMB2_O_INFO_FILE,\n\t\t\t\t \
  \     CIFSMaxBufSize -\n\t\t\t\t      MAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\t\t\t\
  \      MAX_SMB2_CLOSE_RESPONSE_SIZE,\n\t\t\t\t      &rsp_iov[1], &resp_buftype[1],\
  \ cifs_sb);\n\t\t\tif (rc == 0) {\n\t\t\t\trsp = (struct smb2_query_info_rsp *)rsp_iov[1].iov_base;\n\
  \t\t\t\tused_len = le32_to_cpu(rsp->OutputBufferLength);\n\t\t\t}\n\t\t\tfree_rsp_buf(resp_buftype[1],\
  \ rsp_iov[1].iov_base);\n\t\t\tresp_buftype[1] = CIFS_NO_BUFFER;\n\t\t\tmemset(&rsp_iov[1],\
  \ 0, sizeof(rsp_iov[1]));\n\t\t\trc = 0;\n\n\t\t\t/* Use a fudge factor of 256 bytes\
  \ in case we collide\n\t\t\t * with a different set_EAs command.\n\t\t\t */\n\t\t\
  \tif (CIFSMaxBufSize - MAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\t\t   MAX_SMB2_CLOSE_RESPONSE_SIZE\
  \ - 256 <\n\t\t\t   used_len + ea_name_len + ea_value_len + 1) {\n\t\t\t\trc = -ENOSPC;\n\
  \t\t\t\tgoto sea_exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Open */\n\trqst[0].rq_iov =\
  \ vars->open_iov;\n\trqst[0].rq_nvec = SMB2_CREATE_IOV_SIZE;\n\n\toparms = (struct\
  \ cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = path,\n\t\t.desired_access\
  \ = FILE_WRITE_EA,\n\t\t.disposition = FILE_OPEN,\n\t\t.create_options = cifs_create_options(cifs_sb,\
  \ 0),\n\t\t.fid = &fid,\n\t\t.replay = !!(retries),\n\t};\n\n\trc = SMB2_open_init(tcon,\
  \ server,\n\t\t\t    &rqst[0], &oplock, &oparms, utf16_path);\n\tif (rc)\n\t\tgoto\
  \ sea_exit;\n\tsmb2_set_next_command(tcon, &rqst[0]);\n\n\n\t/* Set Info */\n\t\
  rqst[1].rq_iov = vars->si_iov;\n\trqst[1].rq_nvec = 1;\n\n\tlen = sizeof(*ea) +\
  \ ea_name_len + ea_value_len + 1;\n\tea = kzalloc(len, GFP_KERNEL);\n\tif (ea ==\
  \ NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto sea_exit;\n\t}\n\n\tea->ea_name_length =\
  \ ea_name_len;\n\tea->ea_value_length = cpu_to_le16(ea_value_len);\n\tmemcpy(ea->ea_data,\
  \ ea_name, ea_name_len + 1);\n\tmemcpy(ea->ea_data + ea_name_len + 1, ea_value,\
  \ ea_value_len);\n\n\tsize[0] = len;\n\tdata[0] = ea;\n\n\trc = SMB2_set_info_init(tcon,\
  \ server,\n\t\t\t\t&rqst[1], COMPOUND_FID,\n\t\t\t\tCOMPOUND_FID, current->tgid,\n\
  \t\t\t\tFILE_FULL_EA_INFORMATION,\n\t\t\t\tSMB2_O_INFO_FILE, 0, data, size);\n\t\
  if (rc)\n\t\tgoto sea_exit;\n\tsmb2_set_next_command(tcon, &rqst[1]);\n\tsmb2_set_related(&rqst[1]);\n\
  \n\t/* Close */\n\trqst[2].rq_iov = &vars->close_iov;\n\trqst[2].rq_nvec = 1;\n\t\
  rc = SMB2_close_init(tcon, server,\n\t\t\t     &rqst[2], COMPOUND_FID, COMPOUND_FID,\
  \ false);\n\tif (rc)\n\t\tgoto sea_exit;\n\tsmb2_set_related(&rqst[2]);\n\n\tif\
  \ (retries) {\n\t\tsmb2_set_replay(server, &rqst[0]);\n\t\tsmb2_set_replay(server,\
  \ &rqst[1]);\n\t\tsmb2_set_replay(server, &rqst[2]);\n\t}\n\n\trc = compound_send_recv(xid,\
  \ ses, server,\n\t\t\t\tflags, 3, rqst,\n\t\t\t\tresp_buftype, rsp_iov);\n\t/* no\
  \ need to bump num_remote_opens because handle immediately closed */\n\n sea_exit:\n\
  \tkfree(ea);\n\tSMB2_open_free(&rqst[0]);\n\tSMB2_set_info_free(&rqst[1]);\n\tSMB2_close_free(&rqst[2]);\n\
  \tfree_rsp_buf(resp_buftype[0], rsp_iov[0].iov_base);\n\tfree_rsp_buf(resp_buftype[1],\
  \ rsp_iov[1].iov_base);\n\tfree_rsp_buf(resp_buftype[2], rsp_iov[2].iov_base);\n\
  \tkfree(vars);\nout_free_path:\n\tkfree(utf16_path);\n\n\tif (is_replayable_error(rc)\
  \ &&\n\t    smb2_should_replay(tcon, &retries, &cur_sleep))\n\t\tgoto replay_again;\n\
  \n\treturn rc;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/fs/smb/client/smb2ops.c\
  \ b/fs/smb/client/smb2ops.c\nindex 6b385fce3f2a..24a2aa04a108 100644\n--- a/fs/smb/client/smb2ops.c\n\
  +++ b/fs/smb/client/smb2ops.c\n@@ -1158,7 +1158,7 @@ smb2_set_ea(const unsigned\
  \ int xid, struct cifs_tcon *tcon,\n \tstruct cifs_fid fid;\n \tunsigned int size[1];\n\
  \ \tvoid *data[1];\n-\tstruct smb2_file_full_ea_info *ea = NULL;\n+\tstruct smb2_file_full_ea_info\
  \ *ea;\n \tstruct smb2_query_info_rsp *rsp;\n \tint rc, used_len = 0;\n \tint retries\
  \ = 0, cur_sleep = 1;\n@@ -1179,6 +1179,7 @@ smb2_set_ea(const unsigned int xid,\
  \ struct cifs_tcon *tcon,\n \tif (!utf16_path)\n \t\treturn -ENOMEM;\n \n+\tea =\
  \ NULL;\n \tresp_buftype[0] = resp_buftype[1] = resp_buftype[2] = CIFS_NO_BUFFER;\n\
  \ \tvars = kzalloc(sizeof(*vars), GFP_KERNEL);\n \tif (!vars) {\n```\n"
pattern: "## Bug Pattern\n\nA retry loop using a goto back to a label shares a common\
  \ cleanup path that frees resources, but pointer variables freed in the cleanup\
  \ are not reset to NULL at the start of each retry iteration. If an error occurs\
  \ before the pointer is reallocated on a subsequent iteration, the cleanup path\
  \ is taken again and kfree() is called on the stale (already freed) pointer, causing\
  \ a double free.\n\nTypical shape:\nreplay_again:\n    /* state not reinitialized\
  \ */\n    if (error_before_alloc)\n        goto out;     /* cleanup */\n\n    ptr\
  \ = kmalloc(...);\n    ...\nout:\n    kfree(ptr);       /* frees ptr from prior\
  \ try too */\n    if (should_retry)\n        goto replay_again;\n\nFix: set ptr\
  \ = NULL at the start of each retry iteration (near the label) before any path can\
  \ jump to the cleanup."
plan: "1) Program state\n- No custom program state is needed. This checker can be\
  \ implemented as a single AST-body analysis pass that reasons over labels, gotos,\
  \ frees, and assignments using source locations.\n\n2) Chosen callbacks\n- Use only\
  \ checkASTCodeBody. We will traverse the function body once, collect a few \u201C\
  events\u201D (labels, gotos, frees, writes), and then run a lightweight dataflow\
  \ over source-order to spot the pattern.\n\n3) Detailed plan for checkASTCodeBody\n\
  A. Collect basic facts from the function body\n- Walk the entire body (recursive\
  \ AST visit) and build these structures:\n  - LabelInfos: for each LabelStmt, record:\n\
  \    - LabelDecl*, Name (LabelStmt->getDecl()->getName()), and SourceLocation (start\
  \ of label).\n  - GotoInfos: for each GotoStmt, record:\n    - Target LabelDecl*,\
  \ and SourceLocation (the goto\u2019s location).\n  - FreeEvents: for each CallExpr\
  \ to a free-like function, record:\n    - Callee name in {\"kfree\", \"kvfree\"\
  , \"vfree\", \"kfree_sensitive\"}.\n    - The VarDecl* of the freed pointer, if\
  \ the first argument is a DeclRefExpr (ignore non-DeclRefExpr to reduce FPs).\n\
  \    - SourceLocation of the call.\n  - WriteEvents: for each assignment (BinaryOperator\
  \ with isAssignmentOp()):\n    - If LHS is a DeclRefExpr resolving to VarDecl* V,\
  \ record V and SourceLocation.\n    - Classify the RHS kind:\n      - NullInit if\
  \ RHS is 0, nullptr, GNUNullExpr, or contains \"NULL\" via ExprHasName(RHS, \"NULL\"\
  , Ctx).\n      - AllocWrite if RHS is a CallExpr whose callee is one of {\"kmalloc\"\
  , \"kzalloc\", \"kcalloc\", \"kvzalloc\", \"vzalloc\", \"kmalloc_array\", \"kcalloc\"\
  , \"kstrdup\", \"krealloc\"}.\n      - OtherWrite otherwise.\n- Implementation details:\n\
  \  - Use dyn_cast<BinaryOperator> to find assignments, then inspect LHS and RHS.\n\
  \  - Use Identifier names for callee detection. For \u201CNULL\u201D macro, use\
  \ ExprHasName utility.\n  - Record only pointer-typed variables (V->getType()->isPointerType())\
  \ in FreeEvents and WriteEvents.\n\nB. Identify \u201Ccleanup\u201D and \u201Cretry\u201D\
  \ labels from gotos\n- For each label L:\n  - Cleanup labels: mark L as a cleanup\
  \ label if it is the target of any forward goto (there exists a GotoStmt G where\
  \ G.Loc is before L.Loc).\n  - Retry labels: mark L as a retry label if it is the\
  \ target of any backward goto (there exists a GotoStmt G where G.Loc is after L.Loc).\n\
  - Keep maps:\n  - IsCleanupLabel[LabelDecl*] = true/false.\n  - IsRetryLabel[LabelDecl*]\
  \ = true/false.\n\nC. Associate freed variables to a cleanup label\n- For each FreeEvent\
  \ F(V, LocF):\n  - Find a cleanup label C such that:\n    - IsCleanupLabel[C] is\
  \ true, and\n    - C.Loc <= LocF, and among such labels choose the nearest (max\
  \ C.Loc).\n  - If none, skip this free (we only want frees that live in a common\
  \ cleanup tail).\n  - To reduce false positives: require that V was allocated at\
  \ least once before this free:\n    - There exists a WriteEvent for V with kind\
  \ == AllocWrite and WriteLoc < LocF.\n  - Create/record a pair (V, CleanupLabel\
  \ C, FreeLoc LocF). There can be multiple frees; keep each.\n\nD. Confirm the existence\
  \ of a retry loop after the cleanup\n- For each retry label R (IsRetryLabel[R] true):\n\
  \  - Check that there exists at least one backward goto to R whose GotoLoc is after\
  \ LocF for some pair in step C (i.e., the code can execute cleanup then jump back\
  \ to R). If not, the retry loop may not interact with that free; skip that R for\
  \ that (V,C).\n\nE. Detect the missing NULL reinitialize near the retry label\n\
  - For each (V, C, LocF) from step C and each retry label R that passes D:\n  - Compute\
  \ FirstWriteAfterR(V):\n    - Among all WriteEvents for V with WriteLoc > R.Loc,\
  \ take the minimum WriteLoc; if none exists, treat as +infinity.\n  - Find any Goto-to-cleanup\
  \ between R and FirstWriteAfterR(V):\n    - Collect all GotoInfos targeting C where\
  \ R.Loc < GotoLoc < FirstWriteAfterR(V).\n    - If none exist, this (R,V) pair is\
  \ safe; continue.\n  - For each such GotoLoc in that range, check if V is re-initialized\
  \ to NULL before that goto:\n    - Look for a NullInit WriteEvent for V with R.Loc\
  \ < WriteLoc < GotoLoc.\n    - If found, this particular path is safe; continue\
  \ checking other gotos if any.\n    - If no NullInit exists before that GotoLoc,\
  \ report a bug.\n\nF. Reporting\n- Create a BasicBugReport with a short message\
  \ at the retry label or at the first offending goto:\n  - Title: \u201CPointer freed\
  \ in cleanup is not reset to NULL on retry\u201D\n  - Message: \u201CPossible double\
  \ free: \u2018<VName>\u2019 is freed in cleanup and not set to NULL before a goto\
  \ to cleanup on retry.\u201D\n- Point the primary location either at:\n  - The retry\
  \ label R (actionable to set V = NULL near the label), or\n  - The first offending\
  \ goto to C between R and FirstWriteAfterR(V).\n- Optionally, add a note at the\
  \ free site (LocF) to show where the free happens.\n- Only one report per (function,\
  \ V) to avoid duplicates. Track emitted pairs (V, R) in a local set within checkASTCodeBody.\n\
  \n4) Heuristics and helpers\n- Free-like functions: {\"kfree\", \"kvfree\", \"vfree\"\
  , \"kfree_sensitive\"}.\n- Alloc-like functions: {\"kmalloc\", \"kzalloc\", \"kcalloc\"\
  , \"kvzalloc\", \"vzalloc\", \"kmalloc_array\", \"kcalloc\", \"kstrdup\", \"krealloc\"\
  }.\n- Null detection:\n  - IntegerLiteral zero.\n  - CXXNullPtrLiteralExpr, GNUNullExpr.\n\
  \  - ExprHasName(RHS, \"NULL\", Ctx) returns true.\n- Source ordering:\n  - Use\
  \ SourceManager to compare SourceLocations (ensure both are in the same file; skip\
  \ cross-file/macro-expansion anomalies if needed by checking isValid() and FileID\
  \ equality).\n- Var extraction:\n  - For FreeEvents: arg 0 must be a DeclRefExpr\
  \ to VarDecl.\n  - For WriteEvents: LHS must be a DeclRefExpr to VarDecl.\n\n5)\
  \ Why this works for the target pattern\n- It captures the shape: a backward goto\
  \ (retry), a forward-goto cleanup with kfree(ptr), and a path from the retry label\
  \ to cleanup before any write to ptr, without ptr being reset to NULL. That is exactly\
  \ the cause of double free on retries when an error path jumps to cleanup before\
  \ re-allocation.\n- The heuristic requiring a prior allocation of V before the free\
  \ reduces false positives where kfree(NULL) is harmless."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include\
  \ <algorithm>\n#include <utility>\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n // If necessary\n\nnamespace {\n/* The checker callbacks\
  \ are to be decided. */\nclass SAGenTestChecker : public Checker<check::ASTCodeBody>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Double free on retry\", \"Memory Management\")) {}\n\n\
  \      void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter &BR)\
  \ const;\n\n   private:\n\n      // Helper data structures\n      enum class WriteKind\
  \ { NullInit, AllocWrite, OtherWrite };\n\n      struct LabelInfo {\n        const\
  \ LabelDecl *LD = nullptr;\n        std::string Name;\n        SourceLocation Loc;\n\
  \      };\n\n      struct GotoInfo {\n        const LabelDecl *Target = nullptr;\n\
  \        SourceLocation Loc;\n      };\n\n      struct FreeEvent {\n        const\
  \ VarDecl *Var = nullptr;\n        std::string Callee;\n        SourceLocation Loc;\n\
  \      };\n\n      struct WriteEvent {\n        const VarDecl *Var = nullptr;\n\
  \        WriteKind Kind = WriteKind::OtherWrite;\n        SourceLocation Loc;\n\
  \      };\n\n      // Visitor to collect events\n      class BodyVisitor : public\
  \ RecursiveASTVisitor<BodyVisitor> {\n      public:\n        BodyVisitor(ASTContext\
  \ &Ctx,\n                    std::vector<LabelInfo> &Labels,\n                 \
  \   std::vector<GotoInfo> &Gotos,\n                    std::vector<FreeEvent> &Frees,\n\
  \                    std::vector<WriteEvent> &Writes)\n            : Ctx(Ctx), Labels(Labels),\
  \ Gotos(Gotos), Frees(Frees), Writes(Writes) {}\n\n        bool VisitLabelStmt(LabelStmt\
  \ *S) {\n          LabelInfo LI;\n          LI.LD = S->getDecl();\n          if\
  \ (LI.LD)\n            LI.Name = LI.LD->getName().str();\n          LI.Loc = S->getBeginLoc();\n\
  \          Labels.push_back(LI);\n          return true;\n        }\n\n        bool\
  \ VisitGotoStmt(GotoStmt *S) {\n          GotoInfo GI;\n          GI.Target = S->getLabel();\n\
  \          GI.Loc = S->getGotoLoc();\n          Gotos.push_back(GI);\n         \
  \ return true;\n        }\n\n        bool VisitCallExpr(CallExpr *E) {\n       \
  \   const FunctionDecl *FD = E->getDirectCallee();\n          if (!FD) return true;\n\
  \n          StringRef Name = FD->getName();\n          if (isFreeLike(Name)) {\n\
  \            if (E->getNumArgs() >= 1) {\n              const Expr *Arg0 = E->getArg(0);\n\
  \              Arg0 = Arg0 ? Arg0->IgnoreParenImpCasts() : nullptr;\n          \
  \    if (const auto *DRE = dyn_cast_or_null<DeclRefExpr>(Arg0)) {\n            \
  \    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n               \
  \   if (VD->getType()->isPointerType()) {\n                    FreeEvent FE;\n \
  \                   FE.Var = VD;\n                    FE.Callee = Name.str();\n\
  \                    FE.Loc = E->getExprLoc();\n                    Frees.push_back(FE);\n\
  \                  }\n                }\n              }\n            }\n      \
  \    }\n          return true;\n        }\n\n        bool VisitBinaryOperator(BinaryOperator\
  \ *BO) {\n          if (!BO->isAssignmentOp())\n            return true;\n\n   \
  \       const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n          const Expr\
  \ *RHS = BO->getRHS();\n\n          const auto *LHS_DRE = dyn_cast<DeclRefExpr>(LHS);\n\
  \          if (!LHS_DRE) return true;\n\n          const auto *VD = dyn_cast<VarDecl>(LHS_DRE->getDecl());\n\
  \          if (!VD) return true;\n          if (!VD->getType()->isPointerType())\
  \ return true;\n\n          WriteEvent WE;\n          WE.Var = VD;\n          WE.Loc\
  \ = BO->getOperatorLoc();\n          WE.Kind = classifyWrite(RHS);\n          Writes.push_back(WE);\n\
  \          return true;\n        }\n\n        bool VisitDeclStmt(DeclStmt *DS) {\n\
  \          if (!DS->isSingleDecl())\n            return true;\n\n          const\
  \ Decl *D = DS->getSingleDecl();\n          const auto *VD = dyn_cast<VarDecl>(D);\n\
  \          if (!VD) return true;\n          if (!VD->getType()->isPointerType())\
  \ return true;\n\n          if (const Expr *Init = VD->getInit()) {\n          \
  \  WriteEvent WE;\n            WE.Var = VD;\n            WE.Loc = Init->getExprLoc();\n\
  \            WE.Kind = classifyWrite(Init);\n            Writes.push_back(WE);\n\
  \          }\n          return true;\n        }\n\n      private:\n        ASTContext\
  \ &Ctx;\n        std::vector<LabelInfo> &Labels;\n        std::vector<GotoInfo>\
  \ &Gotos;\n        std::vector<FreeEvent> &Frees;\n        std::vector<WriteEvent>\
  \ &Writes;\n\n        static bool isFreeLike(StringRef Name) {\n          return\
  \ Name == \"kfree\" || Name == \"kvfree\" || Name == \"vfree\" ||\n            \
  \     Name == \"kfree_sensitive\";\n        }\n\n        static bool isAllocLike(StringRef\
  \ Name) {\n          return Name == \"kmalloc\" || Name == \"kzalloc\" || Name ==\
  \ \"kcalloc\" ||\n                 Name == \"kvzalloc\" || Name == \"vzalloc\" ||\
  \ Name == \"kmalloc_array\" ||\n                 Name == \"kstrdup\" || Name ==\
  \ \"krealloc\";\n        }\n\n        WriteKind classifyWrite(const Expr *RHS) {\n\
  \          if (!RHS) return WriteKind::OtherWrite;\n\n          // Null detection\n\
  \          if (RHS->isNullPointerConstant(Ctx, Expr::NPC_ValueDependentIsNull))\n\
  \            return WriteKind::NullInit;\n\n          // Zero literal (covers cases\
  \ where null macro didn't fold)\n          if (const auto *IL = dyn_cast<IntegerLiteral>(RHS->IgnoreParenCasts()))\
  \ {\n            if (IL->getValue() == 0)\n              return WriteKind::NullInit;\n\
  \          }\n\n          // Alloc-like calls\n          if (const auto *CE = dyn_cast<CallExpr>(RHS->IgnoreParenCasts()))\
  \ {\n            const FunctionDecl *FD = CE->getDirectCallee();\n            if\
  \ (FD) {\n              StringRef Name = FD->getName();\n              if (isAllocLike(Name))\n\
  \                return WriteKind::AllocWrite;\n            }\n          }\n\n \
  \         return WriteKind::OtherWrite;\n        }\n      }; // end BodyVisitor\n\
  \n      // Helper utilities\n      static SourceLocation expLoc(const SourceManager\
  \ &SM, SourceLocation L) {\n        return SM.getExpansionLoc(L);\n      }\n\n \
  \     static bool before(const SourceManager &SM, SourceLocation A, SourceLocation\
  \ B) {\n        A = expLoc(SM, A);\n        B = expLoc(SM, B);\n        return SM.isBeforeInTranslationUnit(A,\
  \ B);\n      }\n\n      static bool equalLoc(const SourceManager &SM, SourceLocation\
  \ A, SourceLocation B) {\n        A = expLoc(SM, A);\n        B = expLoc(SM, B);\n\
  \        return A == B;\n      }\n\n      static bool lessOrEqual(const SourceManager\
  \ &SM, SourceLocation A, SourceLocation B) {\n        return before(SM, A, B) ||\
  \ equalLoc(SM, A, B);\n      }\n\n      static const LabelDecl *nearestCleanupBefore(const\
  \ SourceManager &SM,\n                                                   const std::vector<LabelInfo>\
  \ &Labels,\n                                                   const std::set<const\
  \ LabelDecl*> &CleanupLabels,\n                                                \
  \   SourceLocation Loc) {\n        const LabelDecl *Best = nullptr;\n        SourceLocation\
  \ BestLoc;\n        for (const auto &L : Labels) {\n          if (!CleanupLabels.count(L.LD))\n\
  \            continue;\n          if (lessOrEqual(SM, L.Loc, Loc)) {\n         \
  \   if (!Best || before(SM, BestLoc, L.Loc)) {\n              Best = L.LD;\n   \
  \           BestLoc = L.Loc;\n            }\n          }\n        }\n        return\
  \ Best;\n      }\n\n      static bool hasAllocBefore(const SourceManager &SM,\n\
  \                                 const std::vector<WriteEvent> &Writes,\n     \
  \                            const VarDecl *V,\n                               \
  \  SourceLocation Loc) {\n        for (const auto &W : Writes) {\n          if (W.Var\
  \ == V && W.Kind == WriteKind::AllocWrite && before(SM, W.Loc, Loc))\n         \
  \   return true;\n        }\n        return false;\n      }\n\n      static SourceLocation\
  \ getLabelLoc(const std::vector<LabelInfo> &Labels,\n                          \
  \              const LabelDecl *LD) {\n        for (const auto &L : Labels)\n  \
  \        if (L.LD == LD) return L.Loc;\n        return SourceLocation();\n     \
  \ }\n\n      static bool isNullInitBetween(const SourceManager &SM,\n          \
  \                          const std::vector<WriteEvent> &Writes,\n            \
  \                        const VarDecl *V,\n                                   \
  \ SourceLocation StartExclusive,\n                                    SourceLocation\
  \ EndExclusive) {\n        for (const auto &W : Writes) {\n          if (W.Var !=\
  \ V) continue;\n          if (W.Kind != WriteKind::NullInit) continue;\n       \
  \   if (before(SM, StartExclusive, W.Loc) && before(SM, W.Loc, EndExclusive))\n\
  \            return true;\n        }\n        return false;\n      }\n\n      static\
  \ bool writeAfter(const SourceManager &SM,\n                             const WriteEvent\
  \ &A,\n                             const WriteEvent &B) {\n        return before(SM,\
  \ B.Loc, A.Loc);\n      }\n\n      static SourceLocation firstWriteAfter(const SourceManager\
  \ &SM,\n                                            const std::vector<WriteEvent>\
  \ &Writes,\n                                            const VarDecl *V,\n    \
  \                                        SourceLocation LocR,\n                \
  \                            bool &Found) {\n        Found = false;\n        SourceLocation\
  \ Best;\n        for (const auto &W : Writes) {\n          if (W.Var != V) continue;\n\
  \          if (before(SM, LocR, W.Loc)) {\n            if (!Found || before(SM,\
  \ W.Loc, Best)) {\n              Best = W.Loc;\n              Found = true;\n  \
  \          }\n          }\n        }\n        return Best;\n      }\n\n}; // end\
  \ class\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const {\n  const auto *FD = dyn_cast<FunctionDecl>(D);\n\
  \  if (!FD) return;\n  const Stmt *Body = FD->getBody();\n  if (!Body) return;\n\
  \n  ASTContext &ACtx = Mgr.getASTContext();\n  const SourceManager &SM = Mgr.getSourceManager();\n\
  \n  std::vector<LabelInfo> Labels;\n  std::vector<GotoInfo> Gotos;\n  std::vector<FreeEvent>\
  \ Frees;\n  std::vector<WriteEvent> Writes;\n\n  BodyVisitor V(ACtx, Labels, Gotos,\
  \ Frees, Writes);\n  V.TraverseStmt(const_cast<Stmt *>(Body));\n\n  // Classify\
  \ labels as cleanup or retry via goto directions\n  std::set<const LabelDecl*> CleanupLabels;\n\
  \  std::set<const LabelDecl*> RetryLabels;\n  std::map<const LabelDecl*, std::vector<SourceLocation>>\
  \ GotoLocsByLabel;\n\n  for (const auto &G : Gotos) {\n    if (!G.Target) continue;\n\
  \    SourceLocation LLoc = getLabelLoc(Labels, G.Target);\n    if (LLoc.isInvalid())\
  \ continue;\n\n    GotoLocsByLabel[G.Target].push_back(G.Loc);\n\n    if (before(SM,\
  \ G.Loc, LLoc)) {\n      CleanupLabels.insert(G.Target); // forward goto to label\
  \ => cleanup\n    } else if (before(SM, LLoc, G.Loc)) {\n      RetryLabels.insert(G.Target);\
  \   // backward goto => retry\n    }\n  }\n\n  // Map each free to the nearest preceding\
  \ cleanup label if any and require prior alloc\n  struct FreedInCleanup {\n    const\
  \ VarDecl *Var = nullptr;\n    const LabelDecl *Cleanup = nullptr;\n    SourceLocation\
  \ FreeLoc;\n  };\n  std::vector<FreedInCleanup> FreedList;\n  for (const auto &F\
  \ : Frees) {\n    if (!F.Var) continue;\n    const LabelDecl *C = nearestCleanupBefore(SM,\
  \ Labels, CleanupLabels, F.Loc);\n    if (!C) continue;\n    if (!hasAllocBefore(SM,\
  \ Writes, F.Var, F.Loc))\n      continue;\n    FreedList.push_back({F.Var, C, F.Loc});\n\
  \  }\n\n  // For each freed var in cleanup, and each retry label reachable after\
  \ free, check missing NULL reinit\n  std::set<std::pair<const VarDecl*, const LabelDecl*>>\
  \ Reported; // (Var, RetryLabel)\n  for (const auto &FI : FreedList) {\n    // Consider\
  \ retry labels R such that there is a goto to R after FI.FreeLoc\n    for (const\
  \ LabelDecl *R : RetryLabels) {\n      auto It = GotoLocsByLabel.find(R);\n    \
  \  if (It == GotoLocsByLabel.end()) continue;\n\n      // Any goto to R after free?\n\
  \      bool HasBackwardGotoAfterFree = false;\n      for (const auto &GLoc : It->second)\
  \ {\n        if (before(SM, FI.FreeLoc, GLoc)) {\n          HasBackwardGotoAfterFree\
  \ = true;\n          break;\n        }\n      }\n      if (!HasBackwardGotoAfterFree)\
  \ continue;\n\n      // Now ensure there's a goto to cleanup C between R and first\
  \ write of Var after R\n      SourceLocation RLoc = getLabelLoc(Labels, R);\n  \
  \    if (RLoc.isInvalid()) continue;\n\n      bool FoundFirstWrite = false;\n  \
  \    SourceLocation FirstWLoc = firstWriteAfter(SM, Writes, FI.Var, RLoc, FoundFirstWrite);\n\
  \n      // Iterate gotos to the cleanup label C, and check those between RLoc and\
  \ FirstWLoc (or any after R if no write)\n      auto ItC = GotoLocsByLabel.find(FI.Cleanup);\n\
  \      if (ItC == GotoLocsByLabel.end()) continue;\n\n      // Find the first offending\
  \ goto (no NULL init between R and Goto)\n      SourceLocation OffendingGoto;\n\
  \      for (const auto &GLoc : ItC->second) {\n        if (!before(SM, RLoc, GLoc))\n\
  \          continue; // must be after retry label\n        if (FoundFirstWrite &&\
  \ !before(SM, GLoc, FirstWLoc))\n          continue; // must be before the first\
  \ write after R\n\n        // Is there a NullInit write for Var between RLoc and\
  \ GLoc?\n        if (!isNullInitBetween(SM, Writes, FI.Var, RLoc, GLoc)) {\n   \
  \       OffendingGoto = GLoc;\n          break;\n        }\n      }\n\n      if\
  \ (OffendingGoto.isInvalid())\n        continue;\n\n      // Deduplicate (Var, RetryLabel)\n\
  \      auto Key = std::make_pair(FI.Var, R);\n      if (Reported.count(Key))\n \
  \       continue;\n      Reported.insert(Key);\n\n      // Report\n      PathDiagnosticLocation\
  \ ELoc(OffendingGoto, BR.getSourceManager());\n      auto Rpt = std::make_unique<BasicBugReport>(\n\
  \          *BT, \"Pointer freed in cleanup is not reset to NULL on retry\", ELoc);\n\
  \      // Provide context\n      std::string Msg = \"Possible double free: '\";\n\
  \      Msg += FI.Var->getName().str();\n      Msg += \"' is freed in cleanup and\
  \ not set to NULL before goto to cleanup on retry.\";\n      Rpt->setDeclWithIssue(FD);\n\
  \      Rpt->addNote(Msg, ELoc);\n\n      // Add note for free site\n      PathDiagnosticLocation\
  \ FreeLoc(FI.FreeLoc, BR.getSourceManager());\n      Rpt->addNote(\"Freed here in\
  \ cleanup\", FreeLoc);\n\n      BR.emitReport(std::move(Rpt));\n    }\n  }\n}\n\n\
  } // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects missing pointer NULL reinitialization at retry labels leading\
  \ to double free in cleanup\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
