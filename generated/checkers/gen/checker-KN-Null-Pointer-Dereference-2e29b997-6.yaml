_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 2e29b9971ac54dec88baa58856a230ec2f2a2dff
commit_type: Null-Pointer-Dereference
index: 6
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Program state traits / maps\nREGISTER_TRAIT_WITH_PROGRAMSTATE(LastAllocRegion,\
  \ const MemRegion*)\nREGISTER_TRAIT_WITH_PROGRAMSTATE(LastAllocCall, const Stmt*)\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*, const MemRegion*)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n\
  \        check::Bind,\n        check::BranchCondition,\n        check::BeginFunction>\
  \ {\n\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\
  \ : BT(new BugType(this, \"Wrong NULL check after allocation\", \"API Misuse\"))\
  \ {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \  void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \  void checkBeginFunction(CheckerContext &C) const;\n\nprivate:\n  // Helpers\n\
  \  bool isKernelAllocator(const CallEvent &Call, CheckerContext &C) const;\n  const\
  \ MemRegion *getAssignedLHSRegionForCall(const CallEvent &Call, CheckerContext &C)\
  \ const;\n  const MemRegion *resolveAliasRegion(const MemRegion *R, ProgramStateRef\
  \ State) const;\n\n  struct NullCheckInfo {\n    const Expr *PtrExpr = nullptr;\
  \   // The expression being checked against NULL.\n    bool IsNullOnThen = false;\
  \       // True if the 'then' branch is the NULL path.\n  };\n  bool extractNullCheckInfo(const\
  \ Expr *CondE, CheckerContext &C, NullCheckInfo &Out) const;\n\n  void clearPendingAlloc(ProgramStateRef\
  \ &State) const;\n};\n\n// Helper: identify allocator calls we care about using\
  \ origin expr text match as suggested.\nbool SAGenTestChecker::isKernelAllocator(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Check common kernel allocators\n  return\
  \ ExprHasName(Origin, \"kzalloc\", C) ||\n         ExprHasName(Origin, \"kmalloc\"\
  , C) ||\n         ExprHasName(Origin, \"kcalloc\", C) ||\n         ExprHasName(Origin,\
  \ \"kmalloc_array\", C) ||\n         ExprHasName(Origin, \"kvzalloc\", C) ||\n \
  \        ExprHasName(Origin, \"vzalloc\", C) ||\n         ExprHasName(Origin, \"\
  devm_kzalloc\", C) ||\n         ExprHasName(Origin, \"devm_kcalloc\", C);\n}\n\n\
  // Helper: From a call expression on the RHS, find the parent assignment and return\
  \ the LHS region.\nconst MemRegion *SAGenTestChecker::getAssignedLHSRegionForCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return nullptr;\n\n  // Find the parent BinaryOperator which\
  \ should be an assignment.\n  const BinaryOperator *BO = findSpecificTypeInParents<BinaryOperator>(Origin,\
  \ C);\n  if (!BO || !BO->isAssignmentOp())\n    return nullptr;\n\n  const Expr\
  \ *LHS = BO->getLHS();\n  if (!LHS)\n    return nullptr;\n\n  const MemRegion *MR\
  \ = getMemRegionFromExpr(LHS, C);\n  if (!MR)\n    return nullptr;\n\n  MR = MR->getBaseRegion();\n\
  \  return MR;\n}\n\nconst MemRegion *SAGenTestChecker::resolveAliasRegion(const\
  \ MemRegion *R, ProgramStateRef State) const {\n  if (!R)\n    return nullptr;\n\
  \  const MemRegion *Cur = R->getBaseRegion();\n  llvm::SmallPtrSet<const MemRegion*,\
  \ 8> Visited;\n  while (Cur) {\n    if (!Visited.insert(Cur).second)\n      break;\n\
  \    const MemRegion *Next = State->get<PtrAliasMap>(Cur);\n    if (!Next)\n   \
  \   break;\n    Cur = Next->getBaseRegion();\n  }\n  return Cur;\n}\n\nstatic bool\
  \ isNullExpr(const Expr *E, CheckerContext &C) {\n  if (!E)\n    return false;\n\
  \  if (E->isNullPointerConstant(C.getASTContext(), Expr::NPC_ValueDependentIsNull))\n\
  \    return true;\n  return ExprHasName(E, \"NULL\", C);\n}\n\nbool SAGenTestChecker::extractNullCheckInfo(const\
  \ Expr *CondE, CheckerContext &C, NullCheckInfo &Out) const {\n  if (!CondE)\n \
  \   return false;\n\n  CondE = CondE->IgnoreParenImpCasts();\n\n  if (const auto\
  \ *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if (UO->getOpcode() == UO_LNot) {\n\
  \      Out.PtrExpr = UO->getSubExpr();\n      Out.IsNullOnThen = true; // !ptr ==>\
  \ then-branch is NULL path\n      return Out.PtrExpr != nullptr;\n    }\n  } else\
  \ if (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr\
  \ *LHS = BO->getLHS()->IgnoreParenImpCasts();\n      const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \      bool LHSIsNull = isNullExpr(LHS, C);\n      bool RHSIsNull = isNullExpr(RHS,\
  \ C);\n\n      if (LHSIsNull && !RHSIsNull) {\n        Out.PtrExpr = RHS;\n    \
  \    Out.IsNullOnThen = (Op == BO_EQ); // ptr == NULL => then is null\n        return\
  \ true;\n      } else if (RHSIsNull && !LHSIsNull) {\n        Out.PtrExpr = LHS;\n\
  \        Out.IsNullOnThen = (Op == BO_EQ);\n        return true;\n      }\n    }\n\
  \  }\n\n  // We intentionally do not treat \"if (ptr)\" as a NULL-check here to\
  \ keep FP low.\n  return false;\n}\n\nvoid SAGenTestChecker::clearPendingAlloc(ProgramStateRef\
  \ &State) const {\n  State = State->remove<LastAllocRegion>();\n  State = State->remove<LastAllocCall>();\n\
  }\n\n// Record the LHS region that received the allocation result.\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isKernelAllocator(Call, C))\n\
  \    return;\n\n  const MemRegion *LHSReg = getAssignedLHSRegionForCall(Call, C);\n\
  \  if (!LHSReg)\n    return;\n\n  ProgramStateRef State = C.getState();\n  State\
  \ = State->set<LastAllocRegion>(LHSReg->getBaseRegion());\n  State = State->set<LastAllocCall>(Call.getOriginExpr());\n\
  \  C.addTransition(State);\n}\n\n// Track simple pointer aliases: LHS-reg -> RHS-reg\n\
  void SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  const MemRegion *Dst = Loc.getAsRegion();\n  const MemRegion *Src\
  \ = Val.getAsRegion();\n  if (!Dst || !Src)\n    return;\n\n  Dst = Dst->getBaseRegion();\n\
  \  Src = Src->getBaseRegion();\n  if (!Dst || !Src)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  State = State->set<PtrAliasMap>(Dst, Src);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  // If we don't have\
  \ a pending allocation, nothing to do.\n  const MemRegion *Pending = State->get<LastAllocRegion>();\n\
  \  if (!Pending)\n    return;\n\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE) {\n    // Not an expression condition; clear pending to only look\
  \ at immediate next branch.\n    clearPendingAlloc(State);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  NullCheckInfo Info;\n  bool IsNullCheck = extractNullCheckInfo(CondE,\
  \ C, Info);\n  if (!IsNullCheck) {\n    // First branch after allocation is unrelated;\
  \ clear pending.\n    clearPendingAlloc(State);\n    C.addTransition(State);\n \
  \   return;\n  }\n\n  // Find the surrounding IfStmt to examine the null-path body\
  \ for an immediate return.\n  const IfStmt *IS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IS) {\n    clearPendingAlloc(State);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  const Stmt *NullBranch = Info.IsNullOnThen ? IS->getThen()\
  \ : IS->getElse();\n  if (!NullBranch) {\n    clearPendingAlloc(State);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  const ReturnStmt *RS = findSpecificTypeInChildren<ReturnStmt>(NullBranch);\n\
  \  if (!RS) {\n    // We only warn when the null path immediately returns (typical\
  \ error handling).\n    clearPendingAlloc(State);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // Determine which region is actually being checked in the\
  \ condition.\n  const MemRegion *CheckedReg = nullptr;\n  if (Info.PtrExpr) {\n\
  \    CheckedReg = getMemRegionFromExpr(Info.PtrExpr, C);\n    if (CheckedReg)\n\
  \      CheckedReg = CheckedReg->getBaseRegion();\n  }\n\n  const MemRegion *CanonPending\
  \ = resolveAliasRegion(Pending, State);\n  const MemRegion *CanonChecked = resolveAliasRegion(CheckedReg,\
  \ State);\n\n  // If we cannot resolve regions confidently, do not warn.\n  if (!CanonPending\
  \ || !CanonChecked) {\n    clearPendingAlloc(State);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  if (CanonPending == CanonChecked) {\n    // Correct: the\
  \ null check is on the allocated pointer.\n    clearPendingAlloc(State);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // Wrong pointer is being NULL-checked after allocation;\
  \ report a bug.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N) {\n\
  \    clearPendingAlloc(State);\n    C.addTransition(State);\n    return;\n  }\n\n\
  \  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"NULL check on\
  \ wrong pointer after allocation\", N);\n  R->addRange(Condition->getSourceRange());\n\
  \  if (const Stmt *AllocS = State->get<LastAllocCall>()) {\n    SourceRange SR =\
  \ AllocS->getSourceRange();\n    if (SR.isValid())\n      R->addRange(SR);\n  }\n\
  \  C.emitReport(std::move(R));\n\n  // Clear pending expectation after reporting.\n\
  \  clearPendingAlloc(State);\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  clearPendingAlloc(State);\n\
  \  C.addTransition(State);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects NULL checks on the wrong pointer\
  \ immediately after allocation\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\narm64/sme: Fix NULL check after kzalloc\n\nFix following\
  \ coccicheck error:\n./arch/arm64/kernel/process.c:322:2-23: alloc with no test,\
  \ possible model on line 326\n\nHere should be dst->thread.sve_state.\n\nFixes:\
  \ 8bd7f91c03d8 (\"arm64/sme: Implement traps and syscall handling for SME\")\nSigned-off-by:\
  \ Wan Jiabing <wanjiabing@vivo.com>\nReviwed-by: Mark Brown <broonie@kernel.org>\n\
  Link: https://lore.kernel.org/r/20220426113054.630983-1-wanjiabing@vivo.com\nSigned-off-by:\
  \ Catalin Marinas <catalin.marinas@arm.com>\n\n## Buggy Code\n\n```c\n// Function:\
  \ arch_dup_task_struct in arch/arm64/kernel/process.c\nint arch_dup_task_struct(struct\
  \ task_struct *dst, struct task_struct *src)\n{\n\tif (current->mm)\n\t\tfpsimd_preserve_current_state();\n\
  \t*dst = *src;\n\n\t/* We rely on the above assignment to initialize dst's thread_flags:\
  \ */\n\tBUILD_BUG_ON(!IS_ENABLED(CONFIG_THREAD_INFO_IN_TASK));\n\n\t/*\n\t * Detach\
  \ src's sve_state (if any) from dst so that it does not\n\t * get erroneously used\
  \ or freed prematurely.  dst's copies\n\t * will be allocated on demand later on\
  \ if dst uses SVE.\n\t * For consistency, also clear TIF_SVE here: this could be\
  \ done\n\t * later in copy_process(), but to avoid tripping up future\n\t * maintainers\
  \ it is best not to leave TIF flags and buffers in\n\t * an inconsistent state,\
  \ even temporarily.\n\t */\n\tdst->thread.sve_state = NULL;\n\tclear_tsk_thread_flag(dst,\
  \ TIF_SVE);\n\n\t/*\n\t * In the unlikely event that we create a new thread with\
  \ ZA\n\t * enabled we should retain the ZA state so duplicate it here.\n\t * This\
  \ may be shortly freed if we exec() or if CLONE_SETTLS\n\t * but it's simpler to\
  \ do it here. To avoid confusing the rest\n\t * of the code ensure that we have\
  \ a sve_state allocated\n\t * whenever za_state is allocated.\n\t */\n\tif (thread_za_enabled(&src->thread))\
  \ {\n\t\tdst->thread.sve_state = kzalloc(sve_state_size(src),\n\t\t\t\t\t\tGFP_KERNEL);\n\
  \t\tif (!dst->thread.za_state)\n\t\t\treturn -ENOMEM;\n\t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n\t\t\t\t\t       za_state_size(src),\n\t\t\t\t\
  \t       GFP_KERNEL);\n\t\tif (!dst->thread.za_state) {\n\t\t\tkfree(dst->thread.sve_state);\n\
  \t\t\tdst->thread.sve_state = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\
  \tdst->thread.za_state = NULL;\n\t\tclear_tsk_thread_flag(dst, TIF_SME);\n\t}\n\n\
  \t/* clear any pending asynchronous tag fault raised by the parent */\n\tclear_tsk_thread_flag(dst,\
  \ TIF_MTE_ASYNC_FAULT);\n\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c\nindex 99c293513817..9734c9fb1a32\
  \ 100644\n--- a/arch/arm64/kernel/process.c\n+++ b/arch/arm64/kernel/process.c\n\
  @@ -321,7 +321,7 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct\
  \ *src)\n \tif (thread_za_enabled(&src->thread)) {\n \t\tdst->thread.sve_state =\
  \ kzalloc(sve_state_size(src),\n \t\t\t\t\t\tGFP_KERNEL);\n-\t\tif (!dst->thread.za_state)\n\
  +\t\tif (!dst->thread.sve_state)\n \t\t\treturn -ENOMEM;\n \t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n \t\t\t\t\t       za_state_size(src),\n```\n"
pattern: "## Bug Pattern\n\nPost-allocation NULL check on the wrong pointer.\n\nExample\
  \ pattern:\nptr_alloc = kzalloc(size, GFP_KERNEL);\nif (!ptr_other)\n    return\
  \ -ENOMEM;\n\nHere, memory is allocated into ptr_alloc but the error check tests\
  \ ptr_other instead of ptr_alloc, so allocation failures for ptr_alloc go undetected\
  \ and can lead to later NULL dereference or invariant violations."
plan: "1) Program state\n\n- REGISTER_TRAIT_WITH_PROGRAMSTATE(LastAllocRegion, const\
  \ MemRegion*)\n  - Stores the region that just received the result of a memory allocator\
  \ (the one that must be NULL-checked next).\n\n- REGISTER_TRAIT_WITH_PROGRAMSTATE(LastAllocCall,\
  \ const Stmt*)\n  - Stores the allocator call expression for diagnostics (optional,\
  \ can be nullptr).\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*,\
  \ const MemRegion*)\n  - Tracks simple pointer aliases so that if an alias of the\
  \ allocated region is checked, we can consider the check valid.\n  - Map direction:\
  \ alias -> canonical (original) region.\n\n\n2) Callback selection and behavior\n\
  \nA) checkPostCall (the allocator sink and state setup)\n- Goal: Record the LHS\
  \ region that receives the result of a known allocator so we know what should be\
  \ NULL-checked immediately after.\n- Steps:\n  1) Identify allocator calls:\n  \
  \   - If the callee identifier matches one of: \"kzalloc\", \"kmalloc\", \"kcalloc\"\
  \ (you can extend with \"kvzalloc\", \"vzalloc\", \"devm_kzalloc\" if desired),\
  \ proceed. Otherwise, return.\n  2) Find the LHS region:\n     - Get the CallExpr\
  \ via Call.getOriginExpr().\n     - Use findSpecificTypeInParents<BinaryOperator>(CallExpr,\
  \ C) and check it is an assignment operator.\n     - If so, get BO->getLHS(), then\
  \ get the region via getMemRegionFromExpr(LHS, C). If this returns nullptr, bail\
  \ out.\n     - Optionally handle variable initialization:\n       - Use findSpecificTypeInParents<DeclStmt>(CallExpr,\
  \ C). For each VarDecl with Init that contains this CallExpr, use the region of\
  \ that VarDecl (you can fetch it with State->getLValue(VD, ...) or simply skip this\
  \ case if you want to keep the checker simpler).\n  3) Update state:\n     - Set\
  \ LastAllocRegion to the LHS region found above.\n     - Set LastAllocCall to the\
  \ CallExpr (Call.getOriginExpr()) for diagnostics.\n     - Note: We only track the\
  \ \u201Cmost recent\u201D allocation. This keeps the checker simple; we will only\
  \ look at the next branch condition.\n\nB) checkBind (alias tracking)\n- Goal: Track\
  \ pointer aliases so that checking an alias of the allocated pointer is considered\
  \ valid.\n- Steps:\n  1) If Loc is a location (lvalue) and Val is a pointer SVal\
  \ that refers to a region:\n     - Let Rdst = Loc.getAsRegion() and Rsrc = Val.getAsRegion().\n\
  \     - If both non-null, record alias: State = State->set<PtrAliasMap>(Rdst, Rsrc).\n\
  \  2) Provide a small helper resolveAliasRegion(R):\n     - Follow PtrAliasMap repeatedly\
  \ to find the canonical region (stop on first missing mapping or cycle).\n     -\
  \ Use this resolver whenever comparing regions.\n\nC) checkBranchCondition (detect\
  \ the wrong NULL check)\n- Goal: On the very next branch after an allocation, verify\
  \ that the condition NULL-checks the newly allocated pointer (or its alias). If\
  \ it NULL-checks a different pointer and the branch exits (e.g., return -ENOMEM),\
  \ report.\n- Steps:\n  1) If LastAllocRegion is null, do nothing and return.\n \
  \ 2) Parse the condition into a possible NULL-check:\n     - Extract an Expr* Cond\
  \ from the Stmt* argument.\n     - Normalize by ignoring parens/implicit casts.\n\
  \     - Handle forms:\n       - UnaryOperator UO_LNot: \"!E\" (interpreted as \u201C\
  E == NULL\u201D on the true branch).\n       - BinaryOperator BO_EQ or BO_NE where\
  \ one side is NULL (0 or \"NULL\"):\n         - One side is the pointer expression\
  \ Ep, the other side is a null literal. Recognize NULL by:\n           - IntegerLiteral\
  \ with value 0, or\n           - ExprHasName(..., \"NULL\", C).\n     - If not a\
  \ NULL-check, clear LastAllocRegion and return (we only consider the first branch\
  \ after allocation).\n  3) Determine the checked region:\n     - For the pointer\
  \ expression Ep, get region Rchecked via getMemRegionFromExpr(Ep, C).\n     - Canonicalize\
  \ with resolveAliasRegion(Rchecked).\n     - Canonicalize LastAllocRegion with resolveAliasRegion(LastAllocRegion).\n\
  \  4) Check control-flow intent and minimize false positives:\n     - Find the surrounding\
  \ IfStmt via findSpecificTypeInParents<IfStmt>(Condition, C).\n     - Determine\
  \ if the branch that is taken when \u201Cpointer is NULL\u201D contains an immediate\
  \ ReturnStmt:\n       - If condition is \"!Ep\" or \"Ep == NULL\", the \u201Cthen\u201D\
  \ branch is the NULL path. Look for a ReturnStmt inside Then using findSpecificTypeInChildren<ReturnStmt>(Then).\n\
  \       - If not found, clear LastAllocRegion and return (we only warn for immediate\
  \ failure returns like return -ENOMEM).\n  5) Decide and act:\n     - If Rchecked\
  \ == LastAllocRegion (after alias resolution):\n       - This is a correct NULL\
  \ check. Clear LastAllocRegion and return (no report).\n     - Else:\n       - This\
  \ is a NULL check on a different pointer immediately after an allocation and leading\
  \ to an immediate return. Report a bug.\n       - After reporting, clear LastAllocRegion\
  \ to avoid duplicate reports.\n  6) Always clear LastAllocRegion after processing\
  \ this branch (matched or not) so only the immediate next branch is considered.\n\
  \nD) Optional: checkBeginFunction / checkEndFunction\n- Clear LastAllocRegion and\
  \ LastAllocCall on function entry/exit to keep state local and avoid stale carryover\
  \ (defensive measure).\n\n\n3) Helper utilities to implement\n\n- bool isKernelAllocator(const\
  \ CallEvent &Call):\n  - Return true if callee is one of: \"kzalloc\", \"kmalloc\"\
  , \"kcalloc\" (extendable).\n\n- const MemRegion* getAssignedLHSRegionForCall(const\
  \ CallEvent &Call, CheckerContext &C):\n  - Use parent BinaryOperator as described\
  \ above; return region of LHS or nullptr.\n\n- struct NullCheckInfo { const MemRegion\
  \ *Checked; bool IsNullOnThen; };\n  - extractNullCheckedRegion(const Expr *Cond,\
  \ CheckerContext &C, NullCheckInfo &Out):\n    - Parse condition into:\n      -\
  \ Checked = region of the pointer expression if it\u2019s a NULL-check.\n      -\
  \ IsNullOnThen = true if the null case is on the \u201Cthen\u201D branch (e.g.,\
  \ \"!ptr\" or \"ptr == NULL\").\n    - Return true if recognized, false otherwise.\n\
  \n- const MemRegion* resolveAliasRegion(const MemRegion *R, ProgramStateRef State):\n\
  \  - Follow PtrAliasMap to canonical region.\n\n- Clear helpers:\n  - State = State->remove<PtrAliasMap>(...)\
  \ when regions go out of scope if desired. Not strictly necessary for this checker.\n\
  \n\n4) Bug reporting\n\n- Create a BugType once: std::unique_ptr<BugType> BT(\"\
  Wrong NULL check after allocation\", \"API Misuse\");\n- When detecting the bug\
  \ in checkBranchCondition:\n  - Create a non-fatal error node using generateNonFatalErrorNode().\n\
  \  - Use PathSensitiveBugReport with message: \"NULL check on wrong pointer after\
  \ allocation\".\n  - Attach the condition\u2019s source range as the primary range.\n\
  \  - Optionally add a note at the allocator site using LastAllocCall->getSourceRange()\
  \ if available: \"Allocation is assigned here; this allocation result should be\
  \ checked for NULL\".\n  - Emit report via C.emitReport(...).\n\n\n5) Simplifications\
  \ and scope limits (intentional to keep checker precise and simple)\n\n- Only the\
  \ immediate next branch after the allocator-assignment is examined. Any unrelated\
  \ branching clears the pending expectation to prevent false positives.\n- We only\
  \ warn when the null-check branch returns immediately (e.g., return -ENOMEM), which\
  \ closely matches the kernel pattern.\n- We primarily support assignment form (ptr\
  \ = kzalloc(...);). Variable-initializer form can be added later if needed.\n- Alias\
  \ tracking is direct and simple (R2 = R1). Deep/complex aliasing or pointer arithmetic\
  \ is not modeled."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Program state traits / maps\nREGISTER_TRAIT_WITH_PROGRAMSTATE(LastAllocRegion,\
  \ const MemRegion*)\nREGISTER_TRAIT_WITH_PROGRAMSTATE(LastAllocCall, const Stmt*)\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*, const MemRegion*)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n\
  \        check::Bind,\n        check::BranchCondition,\n        check::BeginFunction>\
  \ {\n\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\
  \ : BT(new BugType(this, \"Wrong NULL check after allocation\", \"API Misuse\"))\
  \ {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \  void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \  void checkBeginFunction(CheckerContext &C) const;\n\nprivate:\n  // Helpers\n\
  \  bool isKernelAllocator(const CallEvent &Call, CheckerContext &C) const;\n  const\
  \ MemRegion *getAssignedLHSRegionForCall(const CallEvent &Call, CheckerContext &C)\
  \ const;\n  const MemRegion *resolveAliasRegion(const MemRegion *R, ProgramStateRef\
  \ State) const;\n\n  struct NullCheckInfo {\n    const Expr *PtrExpr = nullptr;\
  \   // The expression being checked against NULL.\n    bool IsNullOnThen = false;\
  \       // True if the 'then' branch is the NULL path.\n  };\n  bool extractNullCheckInfo(const\
  \ Expr *CondE, CheckerContext &C, NullCheckInfo &Out) const;\n\n  void clearPendingAlloc(ProgramStateRef\
  \ &State) const;\n};\n\n// Helper: identify allocator calls we care about using\
  \ origin expr text match as suggested.\nbool SAGenTestChecker::isKernelAllocator(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Check common kernel allocators\n  return\
  \ ExprHasName(Origin, \"kzalloc\", C) ||\n         ExprHasName(Origin, \"kmalloc\"\
  , C) ||\n         ExprHasName(Origin, \"kcalloc\", C) ||\n         ExprHasName(Origin,\
  \ \"kmalloc_array\", C) ||\n         ExprHasName(Origin, \"kvzalloc\", C) ||\n \
  \        ExprHasName(Origin, \"vzalloc\", C) ||\n         ExprHasName(Origin, \"\
  devm_kzalloc\", C) ||\n         ExprHasName(Origin, \"devm_kcalloc\", C);\n}\n\n\
  // Helper: From a call expression on the RHS, find the parent assignment and return\
  \ the LHS region.\nconst MemRegion *SAGenTestChecker::getAssignedLHSRegionForCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return nullptr;\n\n  // Find the parent BinaryOperator which\
  \ should be an assignment.\n  const BinaryOperator *BO = findSpecificTypeInParents<BinaryOperator>(Origin,\
  \ C);\n  if (!BO || !BO->isAssignmentOp())\n    return nullptr;\n\n  const Expr\
  \ *LHS = BO->getLHS();\n  if (!LHS)\n    return nullptr;\n\n  const MemRegion *MR\
  \ = getMemRegionFromExpr(LHS, C);\n  if (!MR)\n    return nullptr;\n\n  MR = MR->getBaseRegion();\n\
  \  return MR;\n}\n\nconst MemRegion *SAGenTestChecker::resolveAliasRegion(const\
  \ MemRegion *R, ProgramStateRef State) const {\n  if (!R)\n    return nullptr;\n\
  \  const MemRegion *Cur = R->getBaseRegion();\n  llvm::SmallPtrSet<const MemRegion*,\
  \ 8> Visited;\n  while (Cur) {\n    if (!Visited.insert(Cur).second)\n      break;\n\
  \    const MemRegion * const *NextPtr = State->get<PtrAliasMap>(Cur);\n    if (!NextPtr)\n\
  \      break;\n    const MemRegion *Next = *NextPtr;\n    if (!Next)\n      break;\n\
  \    Cur = Next->getBaseRegion();\n  }\n  return Cur;\n}\n\nstatic bool isNullExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E)\n    return false;\n  if (E->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull))\n    return true;\n  return ExprHasName(E, \"\
  NULL\", C);\n}\n\nbool SAGenTestChecker::extractNullCheckInfo(const Expr *CondE,\
  \ CheckerContext &C, NullCheckInfo &Out) const {\n  if (!CondE)\n    return false;\n\
  \n  CondE = CondE->IgnoreParenImpCasts();\n\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      Out.PtrExpr = UO->getSubExpr();\n\
  \      Out.IsNullOnThen = true; // !ptr ==> then-branch is NULL path\n      return\
  \ Out.PtrExpr != nullptr;\n    }\n  } else if (const auto *BO = dyn_cast<BinaryOperator>(CondE))\
  \ {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n    if (Op == BO_EQ || Op\
  \ == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  \
  \    const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n      bool LHSIsNull\
  \ = isNullExpr(LHS, C);\n      bool RHSIsNull = isNullExpr(RHS, C);\n\n      if\
  \ (LHSIsNull && !RHSIsNull) {\n        Out.PtrExpr = RHS;\n        Out.IsNullOnThen\
  \ = (Op == BO_EQ); // ptr == NULL => then is null\n        return true;\n      }\
  \ else if (RHSIsNull && !LHSIsNull) {\n        Out.PtrExpr = LHS;\n        Out.IsNullOnThen\
  \ = (Op == BO_EQ);\n        return true;\n      }\n    }\n  }\n\n  // We intentionally\
  \ do not treat \"if (ptr)\" as a NULL-check here to keep FP low.\n  return false;\n\
  }\n\nvoid SAGenTestChecker::clearPendingAlloc(ProgramStateRef &State) const {\n\
  \  State = State->remove<LastAllocRegion>();\n  State = State->remove<LastAllocCall>();\n\
  }\n\n// Record the LHS region that received the allocation result.\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isKernelAllocator(Call, C))\n\
  \    return;\n\n  const MemRegion *LHSReg = getAssignedLHSRegionForCall(Call, C);\n\
  \  if (!LHSReg)\n    return;\n\n  ProgramStateRef State = C.getState();\n  State\
  \ = State->set<LastAllocRegion>(LHSReg->getBaseRegion());\n  State = State->set<LastAllocCall>(Call.getOriginExpr());\n\
  \  C.addTransition(State);\n}\n\n// Track simple pointer aliases: LHS-reg -> RHS-reg\n\
  void SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  const MemRegion *Dst = Loc.getAsRegion();\n  const MemRegion *Src\
  \ = Val.getAsRegion();\n  if (!Dst || !Src)\n    return;\n\n  Dst = Dst->getBaseRegion();\n\
  \  Src = Src->getBaseRegion();\n  if (!Dst || !Src)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  State = State->set<PtrAliasMap>(Dst, Src);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  // If we don't have\
  \ a pending allocation, nothing to do.\n  const MemRegion *Pending = State->get<LastAllocRegion>();\n\
  \  if (!Pending)\n    return;\n\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE) {\n    // Not an expression condition; clear pending to only look\
  \ at immediate next branch.\n    clearPendingAlloc(State);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  NullCheckInfo Info;\n  bool IsNullCheck = extractNullCheckInfo(CondE,\
  \ C, Info);\n  if (!IsNullCheck) {\n    // First branch after allocation is unrelated;\
  \ clear pending.\n    clearPendingAlloc(State);\n    C.addTransition(State);\n \
  \   return;\n  }\n\n  // Find the surrounding IfStmt to examine the null-path body\
  \ for an immediate return.\n  const IfStmt *IS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IS) {\n    clearPendingAlloc(State);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  const Stmt *NullBranch = Info.IsNullOnThen ? IS->getThen()\
  \ : IS->getElse();\n  if (!NullBranch) {\n    clearPendingAlloc(State);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  const ReturnStmt *RS = findSpecificTypeInChildren<ReturnStmt>(NullBranch);\n\
  \  if (!RS) {\n    // We only warn when the null path immediately returns (typical\
  \ error handling).\n    clearPendingAlloc(State);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // Determine which region is actually being checked in the\
  \ condition.\n  const MemRegion *CheckedReg = nullptr;\n  if (Info.PtrExpr) {\n\
  \    CheckedReg = getMemRegionFromExpr(Info.PtrExpr, C);\n    if (CheckedReg)\n\
  \      CheckedReg = CheckedReg->getBaseRegion();\n  }\n\n  const MemRegion *CanonPending\
  \ = resolveAliasRegion(Pending, State);\n  const MemRegion *CanonChecked = resolveAliasRegion(CheckedReg,\
  \ State);\n\n  // If we cannot resolve regions confidently, do not warn.\n  if (!CanonPending\
  \ || !CanonChecked) {\n    clearPendingAlloc(State);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  if (CanonPending == CanonChecked) {\n    // Correct: the\
  \ null check is on the allocated pointer.\n    clearPendingAlloc(State);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // Wrong pointer is being NULL-checked after allocation;\
  \ report a bug.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N) {\n\
  \    clearPendingAlloc(State);\n    C.addTransition(State);\n    return;\n  }\n\n\
  \  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"NULL check on\
  \ wrong pointer after allocation\", N);\n  R->addRange(Condition->getSourceRange());\n\
  \  if (const Stmt *AllocS = State->get<LastAllocCall>()) {\n    SourceRange SR =\
  \ AllocS->getSourceRange();\n    if (SR.isValid())\n      R->addRange(SR);\n  }\n\
  \  C.emitReport(std::move(R));\n\n  // Clear pending expectation after reporting.\n\
  \  clearPendingAlloc(State);\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  clearPendingAlloc(State);\n\
  \  C.addTransition(State);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects NULL checks on the wrong pointer\
  \ immediately after allocation\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
