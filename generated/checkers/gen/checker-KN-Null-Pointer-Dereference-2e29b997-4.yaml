_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 2e29b9971ac54dec88baa58856a230ec2f2a2dff
commit_type: Null-Pointer-Dereference
index: 4
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No custom program states are needed.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"Wrong pointer checked\
  \ after allocation\", \"API Misuse\")) {}\n\n  void checkBranchCondition(const Stmt\
  \ *Condition, CheckerContext &C) const;\n\nprivate:\n  // Extract the expression\
  \ being negatively null-checked from a condition if possible.\n  // Returns the\
  \ raw expression to use for region extraction, or nullptr if not a negative null-check.\n\
  \  const Expr *getNegNullCheckedExprRaw(const Stmt *Condition, CheckerContext &C)\
  \ const;\n\n  // Find the statement immediately preceding IfS inside its containing\
  \ CompoundStmt.\n  const Stmt *getPrevSiblingStmt(const IfStmt *IfS, CheckerContext\
  \ &C) const;\n\n  // Determine if the statement is an allocation assignment/decl,\
  \ and if so,\n  // return the LHS expression (the allocated target) and true. Otherwise\
  \ return false.\n  bool getAllocatedTargetFromPrevStmt(const Stmt *PrevS, const\
  \ Expr *&AllocatedTargetExpr,\n                                      CheckerContext\
  \ &C) const;\n\n  // Check if a given CallExpr represents a known allocator which\
  \ can return NULL.\n  bool isKnownAllocatorCall(const CallExpr *CE, CheckerContext\
  \ &C) const;\n\n  // Determine if the Then-branch of the IfStmt looks like an allocation\
  \ failure path.\n  bool thenBranchIsAllocError(const IfStmt *IfS, CheckerContext\
  \ &C) const;\n\n  // Utility: is expression a null constant (0 or NULL)?\n  bool\
  \ isNullConstant(const Expr *E, CheckerContext &C) const;\n};\n\nconst Expr *SAGenTestChecker::getNegNullCheckedExprRaw(const\
  \ Stmt *Condition,\n                                                       CheckerContext\
  \ &C) const {\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n\
  \    return nullptr;\n\n  // Peel likely()/unlikely() wrappers if present.\n  const\
  \ Expr *Tmp = CondE->IgnoreParenImpCasts();\n  if (const auto *Call = dyn_cast<CallExpr>(Tmp))\
  \ {\n    const Expr *CalleeE = Call->getCallee();\n    if (CalleeE && (ExprHasName(CalleeE,\
  \ \"likely\", C) || ExprHasName(CalleeE, \"unlikely\", C))) {\n      if (Call->getNumArgs()\
  \ >= 1) {\n        CondE = Call->getArg(0);\n      }\n    }\n  }\n\n  // Recompute\
  \ after possible peeling\n  CondE = dyn_cast<Expr>(CondE);\n  if (!CondE)\n    return\
  \ nullptr;\n\n  // Pattern 1: if (!X)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE->IgnoreParens()))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *XRaw = UO->getSubExpr();\n\
  \      if (!XRaw)\n        return nullptr;\n      QualType QT = XRaw->getType();\n\
  \      if (QT->isPointerType())\n        return XRaw; // raw expr, do not strip\
  \ casts for region extraction\n      return nullptr;\n    }\n  }\n\n  // Pattern\
  \ 2: if (X == NULL/0)\n  if (const auto *BO = dyn_cast<BinaryOperator>(CondE->IgnoreParens()))\
  \ {\n    if (BO->getOpcode() == BO_EQ) {\n      const Expr *LHSRaw = BO->getLHS();\n\
  \      const Expr *RHSRaw = BO->getRHS();\n      if (!LHSRaw || !RHSRaw)\n     \
  \   return nullptr;\n\n      bool LHSNull = isNullConstant(LHSRaw, C);\n      bool\
  \ RHSNull = isNullConstant(RHSRaw, C);\n\n      const Expr *PtrRaw = nullptr;\n\
  \      if (LHSNull && !RHSNull)\n        PtrRaw = RHSRaw;\n      else if (RHSNull\
  \ && !LHSNull)\n        PtrRaw = LHSRaw;\n\n      if (PtrRaw) {\n        if (PtrRaw->getType()->isPointerType())\n\
  \          return PtrRaw;\n      }\n    }\n  }\n\n  return nullptr;\n}\n\nbool SAGenTestChecker::isNullConstant(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n  // Quick\
  \ textual check for NULL macro in the expression source.\n  if (ExprHasName(E, \"\
  NULL\", C))\n    return true;\n\n  // Semantic checks.\n  if (E->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull))\n    return true;\n\n  llvm::APSInt Res;\n  if\
  \ (EvaluateExprToInt(Res, E, C)) {\n    if (Res == 0)\n      return true;\n  }\n\
  \  return false;\n}\n\nconst Stmt *SAGenTestChecker::getPrevSiblingStmt(const IfStmt\
  \ *IfS, CheckerContext &C) const {\n  if (!IfS)\n    return nullptr;\n\n  const\
  \ CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(IfS, C);\n  if (!CS)\n\
  \    return nullptr;\n\n  const Stmt *Prev = nullptr;\n  for (const Stmt *S : CS->body())\
  \ {\n    if (S == IfS) {\n      return Prev;\n    }\n    Prev = S;\n  }\n  return\
  \ nullptr;\n}\n\nbool SAGenTestChecker::isKnownAllocatorCall(const CallExpr *CE,\
  \ CheckerContext &C) const {\n  if (!CE)\n    return false;\n  const Expr *CalleeE\
  \ = CE->getCallee();\n  if (!CalleeE)\n    return false;\n\n  // Known allocators\
  \ that can return NULL\n  static const char *AllocNames[] = {\n      \"kzalloc\"\
  , \"kmalloc\", \"kcalloc\", \"kmalloc_array\",\n      \"kzalloc_array\", \"krealloc\"\
  , \"kmemdup\"\n  };\n\n  for (const char *Name : AllocNames) {\n    if (ExprHasName(CalleeE,\
  \ Name, C))\n      return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getAllocatedTargetFromPrevStmt(const\
  \ Stmt *PrevS,\n                                                      const Expr\
  \ *&AllocatedTargetExpr,\n                                                     \
  \ CheckerContext &C) const {\n  if (!PrevS)\n    return false;\n\n  // Case 1: assignment:\
  \ LHS = allocator(...)\n  if (const auto *BO = dyn_cast<BinaryOperator>(PrevS))\
  \ {\n    if (BO->getOpcode() == BO_Assign) {\n      const Expr *LHSRaw = BO->getLHS();\n\
  \      const Expr *RHS = BO->getRHS();\n      if (!LHSRaw || !RHS)\n        return\
  \ false;\n\n      const CallExpr *CallInRHS = findSpecificTypeInChildren<CallExpr>(RHS);\n\
  \      if (!CallInRHS)\n        return false;\n\n      if (!isKnownAllocatorCall(CallInRHS,\
  \ C))\n        return false;\n\n      // LHS must be a pointer-typed target.\n \
  \     if (!LHSRaw->getType()->isAnyPointerType() && !LHSRaw->getType()->isPointerType())\n\
  \        return false;\n\n      AllocatedTargetExpr = LHSRaw; // raw expr for region\
  \ extraction\n      return true;\n    }\n  }\n\n  // Case 2: declaration with initializer:\
  \ T *p = allocator(...);\n  if (const auto *DS = dyn_cast<DeclStmt>(PrevS)) {\n\
  \    if (!DS->isSingleDecl())\n      return false;\n    const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());\n\
  \    if (!VD)\n      return false;\n    const Expr *Init = VD->getInit();\n    if\
  \ (!Init)\n      return false;\n\n    const CallExpr *CallInInit = findSpecificTypeInChildren<CallExpr>(Init);\n\
  \    if (!CallInInit)\n      return false;\n    if (!isKnownAllocatorCall(CallInInit,\
  \ C))\n      return false;\n\n    if (!VD->getType()->isPointerType())\n      return\
  \ false;\n\n    // We will get region from VarDecl via lvalue, so we don't need\
  \ an Expr.\n    // For uniformity with rest of code, fabricate a DeclRefExpr is\
  \ complex; instead,\n    // we handle VarDecl specially later if needed. Here, return\
  \ false to keep\n    // the checker conservative unless we really need this case.\n\
  \    // However, to support this path, we can still return false and rely on the\n\
  \    // assignment case which covers the provided buggy code.\n    return false;\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::thenBranchIsAllocError(const\
  \ IfStmt *IfS, CheckerContext &C) const {\n  if (!IfS)\n    return false;\n\n  const\
  \ Stmt *ThenS = IfS->getThen();\n  if (!ThenS)\n    return false;\n\n  // Search\
  \ for a ReturnStmt in the then-branch.\n  const ReturnStmt *RS = findSpecificTypeInChildren<ReturnStmt>(ThenS);\n\
  \  if (!RS)\n    return false;\n\n  const Expr *RetE = RS->getRetValue();\n  if\
  \ (!RetE)\n    return false;\n\n  // Heuristic: Return mentions ENOMEM (e.g., return\
  \ -ENOMEM;)\n  if (ExprHasName(RetE, \"ENOMEM\", C))\n    return true;\n\n  return\
  \ false;\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const {\n  // 1) Extract the negatively null-checked expression\
  \ from the condition.\n  const Expr *CheckedExprRaw = getNegNullCheckedExprRaw(Condition,\
  \ C);\n  if (!CheckedExprRaw)\n    return;\n\n  // The checked expression must be\
  \ a pointer type.\n  if (!CheckedExprRaw->getType()->isPointerType())\n    return;\n\
  \n  // 2) Find the enclosing IfStmt for this condition.\n  const IfStmt *IfS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IfS)\n    return;\n\n  // 3) Find the previous sibling statement.\n\
  \  const Stmt *PrevS = getPrevSiblingStmt(IfS, C);\n  if (!PrevS)\n    return;\n\
  \n  // 4) Determine if previous statement is an allocation assignment and get the\
  \ LHS (allocated target).\n  const Expr *AllocatedTargetExpr = nullptr;\n  if (!getAllocatedTargetFromPrevStmt(PrevS,\
  \ AllocatedTargetExpr, C))\n    return;\n\n  // 5) Check that then-branch looks\
  \ like an allocation error path (e.g. return -ENOMEM).\n  if (!thenBranchIsAllocError(IfS,\
  \ C))\n    return;\n\n  // 6) Compare memory regions of the allocated target and\
  \ the checked pointer.\n  const MemRegion *AllocReg = getMemRegionFromExpr(AllocatedTargetExpr,\
  \ C);\n  if (!AllocReg)\n    return;\n  AllocReg = AllocReg->getBaseRegion();\n\
  \  if (!AllocReg)\n    return;\n\n  const MemRegion *CheckedReg = getMemRegionFromExpr(CheckedExprRaw,\
  \ C);\n  if (!CheckedReg)\n    return;\n  CheckedReg = CheckedReg->getBaseRegion();\n\
  \  if (!CheckedReg)\n    return;\n\n  // If they are different, we likely checked\
  \ the wrong pointer.\n  if (AllocReg != CheckedReg) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Wrong pointer checked after allocation\", N);\n    R->addRange(IfS->getCond()->getSourceRange());\n\
  \    C.emitReport(std::move(R));\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects checking a different pointer\
  \ than the one just allocated (wrong NULL-check after allocation)\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\narm64/sme: Fix NULL check after kzalloc\n\nFix following\
  \ coccicheck error:\n./arch/arm64/kernel/process.c:322:2-23: alloc with no test,\
  \ possible model on line 326\n\nHere should be dst->thread.sve_state.\n\nFixes:\
  \ 8bd7f91c03d8 (\"arm64/sme: Implement traps and syscall handling for SME\")\nSigned-off-by:\
  \ Wan Jiabing <wanjiabing@vivo.com>\nReviwed-by: Mark Brown <broonie@kernel.org>\n\
  Link: https://lore.kernel.org/r/20220426113054.630983-1-wanjiabing@vivo.com\nSigned-off-by:\
  \ Catalin Marinas <catalin.marinas@arm.com>\n\n## Buggy Code\n\n```c\n// Function:\
  \ arch_dup_task_struct in arch/arm64/kernel/process.c\nint arch_dup_task_struct(struct\
  \ task_struct *dst, struct task_struct *src)\n{\n\tif (current->mm)\n\t\tfpsimd_preserve_current_state();\n\
  \t*dst = *src;\n\n\t/* We rely on the above assignment to initialize dst's thread_flags:\
  \ */\n\tBUILD_BUG_ON(!IS_ENABLED(CONFIG_THREAD_INFO_IN_TASK));\n\n\t/*\n\t * Detach\
  \ src's sve_state (if any) from dst so that it does not\n\t * get erroneously used\
  \ or freed prematurely.  dst's copies\n\t * will be allocated on demand later on\
  \ if dst uses SVE.\n\t * For consistency, also clear TIF_SVE here: this could be\
  \ done\n\t * later in copy_process(), but to avoid tripping up future\n\t * maintainers\
  \ it is best not to leave TIF flags and buffers in\n\t * an inconsistent state,\
  \ even temporarily.\n\t */\n\tdst->thread.sve_state = NULL;\n\tclear_tsk_thread_flag(dst,\
  \ TIF_SVE);\n\n\t/*\n\t * In the unlikely event that we create a new thread with\
  \ ZA\n\t * enabled we should retain the ZA state so duplicate it here.\n\t * This\
  \ may be shortly freed if we exec() or if CLONE_SETTLS\n\t * but it's simpler to\
  \ do it here. To avoid confusing the rest\n\t * of the code ensure that we have\
  \ a sve_state allocated\n\t * whenever za_state is allocated.\n\t */\n\tif (thread_za_enabled(&src->thread))\
  \ {\n\t\tdst->thread.sve_state = kzalloc(sve_state_size(src),\n\t\t\t\t\t\tGFP_KERNEL);\n\
  \t\tif (!dst->thread.za_state)\n\t\t\treturn -ENOMEM;\n\t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n\t\t\t\t\t       za_state_size(src),\n\t\t\t\t\
  \t       GFP_KERNEL);\n\t\tif (!dst->thread.za_state) {\n\t\t\tkfree(dst->thread.sve_state);\n\
  \t\t\tdst->thread.sve_state = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\
  \tdst->thread.za_state = NULL;\n\t\tclear_tsk_thread_flag(dst, TIF_SME);\n\t}\n\n\
  \t/* clear any pending asynchronous tag fault raised by the parent */\n\tclear_tsk_thread_flag(dst,\
  \ TIF_MTE_ASYNC_FAULT);\n\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c\nindex 99c293513817..9734c9fb1a32\
  \ 100644\n--- a/arch/arm64/kernel/process.c\n+++ b/arch/arm64/kernel/process.c\n\
  @@ -321,7 +321,7 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct\
  \ *src)\n \tif (thread_za_enabled(&src->thread)) {\n \t\tdst->thread.sve_state =\
  \ kzalloc(sve_state_size(src),\n \t\t\t\t\t\tGFP_KERNEL);\n-\t\tif (!dst->thread.za_state)\n\
  +\t\tif (!dst->thread.sve_state)\n \t\t\treturn -ENOMEM;\n \t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n \t\t\t\t\t       za_state_size(src),\n```\n"
pattern: "## Bug Pattern\n\nIncorrect NULL-check after allocation: the code allocates\
  \ one pointer but checks a different pointer for NULL.\n\nExample pattern:\nptrA\
  \ = kzalloc(size, GFP_KERNEL);\nif (!ptrB)  // wrong pointer checked\n    return\
  \ -ENOMEM;\n\nIn the patch, after allocating dst->thread.sve_state, the code mistakenly\
  \ checks dst->thread.za_state instead of dst->thread.sve_state, causing allocation\
  \ failures for sve_state to be missed."
plan: "1) Program state\n- No custom program state is needed. We can detect this purely\
  \ from the AST around the if-condition using the provided utilities.\n\n2) Callbacks\
  \ to use\n- checkBranchCondition: Single, central callback to:\n  - Recognize NULL-check\
  \ conditions.\n  - Find the immediately previous statement.\n  - Verify if that\
  \ previous statement is an allocation assignment.\n  - Compare the checked pointer\
  \ with the just-allocated pointer.\n  - Report if they differ.\n\n3) Detailed implementation\n\
  \nA. Detect and normalize NULL-check conditions (in checkBranchCondition)\n- Input:\
  \ const Stmt *Condition.\n- Normalize the condition expression by peeling wrappers:\n\
  \  - Strip ParenExpr and implicit casts: E = E->IgnoreParenImpCasts().\n  - Handle\
  \ likely/unlikely macro wrappers:\n    - If E is a CallExpr with callee named \"\
  likely\" or \"unlikely\", set E to its first argument and then strip parens/impcasts\
  \ again.\n- Identify a \u201Cnegative NULL-check\u201D that typically follows an\
  \ allocation failure check:\n  - Pattern 1: UnaryOperator with opcode UO_LNot: if\
  \ (!X) ...\n    - Extract X as the checked pointer expression (CheckedExpr = X->IgnoreParenImpCasts()).\n\
  \  - Pattern 2: BinaryOperator with opcode BO_EQ: if (X == 0) or if (X == NULL)\n\
  \    - One side must be a null constant:\n      - Use EvaluateExprToInt or string-based\
  \ check: ExprHasName(RHS, \"NULL\", C) or EvaluateExprToInt == 0.\n    - Extract\
  \ the non-constant side as CheckedExpr.\n  - Do not match if (X) or (X != NULL/0).\
  \ Keep the checker conservative and focused on failure checks.\n- Ensure CheckedExpr\u2019\
  s type is pointer: CheckedExpr->getType()->isPointerType().\n- Save CheckedExpr\
  \ for comparison.\n\nB. Find the IfStmt and its previous sibling statement\n- From\
  \ Condition, find the enclosing IfStmt:\n  - const IfStmt *IfS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C).\n  - If not found, return.\n- Find the enclosing CompoundStmt (block) that\
  \ contains IfS:\n  - const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(IfS,\
  \ C).\n  - If not found, return (cannot locate sibling).\n- Locate IfS in CS\u2019\
  s body sequence and fetch the immediately previous statement PrevS:\n  - Iterate\
  \ CS->body() to find IfS; if it\u2019s the first element, return (no previous statement).\n\
  \  - PrevS = the statement immediately before IfS.\n\nC. Determine if PrevS is an\
  \ allocation assignment to a pointer target\n- Case 1: PrevS is a BinaryOperator\
  \ with opcode BO_Assign (LHS = RHS):\n  - Extract RHS:\n    - Find a CallExpr in\
  \ RHS with findSpecificTypeInChildren<CallExpr>(RHS).\n    - If none, return (not\
  \ an allocation).\n  - Check if the callee is a known possibly-NULL allocator:\n\
  \    - Accept names: \"kzalloc\", \"kmalloc\", \"kcalloc\", \"kmalloc_array\", \"\
  kzalloc_array\", \"krealloc\", \"kmemdup\".\n    - Get callee name via callee\u2019\
  s FunctionDecl->getNameAsString() and compare to the above set.\n    - If not in\
  \ the set, return.\n  - Extract the allocation target (AllocatedExpr) = LHS of the\
  \ assignment (MemberExpr, DeclRefExpr, etc.).\n- Case 2: PrevS is a DeclStmt with\
  \ a single VarDecl that has an initializer:\n  - For the VarDecl\u2019s init, look\
  \ for a CallExpr as above.\n  - If callee is a known allocator, then AllocatedExpr\
  \ is the DeclRefExpr of the declared variable.\n- If neither case matches, return\
  \ (no immediate prior allocation).\n\nD. Compare the checked pointer and the allocation\
  \ target\n- Obtain regions via the provided utility:\n  - const MemRegion *AllocReg\
  \ = getMemRegionFromExpr(AllocatedExpr, C).\n  - const MemRegion *CheckedReg = getMemRegionFromExpr(CheckedExpr,\
  \ C).\n- If either region is null, return (cannot compare).\n- If CheckedReg ==\
  \ AllocReg, this is correct and we do nothing.\n- If CheckedReg != AllocReg, this\
  \ is suspicious: \u201Cwrong pointer checked after allocation\u201D.\n\nE. Reduce\
  \ false positives by ensuring it\u2019s an error path typical for allocation failure\n\
  - Inspect the Then branch of the IfStmt:\n  - const Stmt *ThenS = IfS->getThen().\n\
  \  - Try to find a ReturnStmt in ThenS using findSpecificTypeInChildren<ReturnStmt>(ThenS).\n\
  \  - If found, check the return expression:\n    - Prefer detecting ENOMEM: if ExprHasName(ReturnExpr,\
  \ \"ENOMEM\", C) return true.\n    - Optionally also accept EvaluateExprToInt to\
  \ any negative integer if it succeeds (common error returns), but ENOMEM check is\
  \ sufficient and robust for kernel code.\n- If no ReturnStmt found or no ENOMEM\
  \ hint, skip reporting to remain conservative.\n\nF. Report the bug\n- Create an\
  \ error node with generateNonFatalErrorNode().\n- Emit a short and clear message;\
  \ for example:\n  - \"Wrong pointer checked after allocation\"\n- Point the report\
  \ to the condition expression or the checked expression.\n- Use std::make_unique<PathSensitiveBugReport>.\n\
  \n4) Utilities to use\n- findSpecificTypeInParents to get IfStmt and CompoundStmt.\n\
  - findSpecificTypeInChildren to locate CallExpr and ReturnStmt within statements.\n\
  - getMemRegionFromExpr to obtain comparable memory regions from expressions.\n-\
  \ EvaluateExprToInt for detecting literal zero in equality.\n- ExprHasName to detect\
  \ \"NULL\", \"ENOMEM\", and handle macro-based returns and wrappers like unlikely().\n\
  \n5) Notes and scope control\n- The checker only triggers when:\n  - An IfStmt immediately\
  \ follows an allocation assignment.\n  - The If condition is a negative NULL-check.\n\
  \  - The Then branch indicates an error path likely due to allocation failure (contains\
  \ a return mentioning ENOMEM).\n  - The checked pointer is different from the just-allocated\
  \ pointer.\n- This keeps the checker simple and precise for the intended kernel\
  \ pattern (e.g., allocating dst->thread.sve_state but checking dst->thread.za_state)."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No custom program states are needed.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"Wrong pointer checked\
  \ after allocation\", \"API Misuse\")) {}\n\n  void checkBranchCondition(const Stmt\
  \ *Condition, CheckerContext &C) const;\n\nprivate:\n  // Extract the expression\
  \ being negatively null-checked from a condition if possible.\n  // Returns the\
  \ raw expression to use for region extraction, or nullptr if not a negative null-check.\n\
  \  const Expr *getNegNullCheckedExprRaw(const Stmt *Condition, CheckerContext &C)\
  \ const;\n\n  // Find the statement immediately preceding IfS inside its containing\
  \ CompoundStmt.\n  const Stmt *getPrevSiblingStmt(const IfStmt *IfS, CheckerContext\
  \ &C) const;\n\n  // Determine if the statement is an allocation assignment/decl,\
  \ and if so,\n  // return the LHS expression (the allocated target) and true. Otherwise\
  \ return false.\n  bool getAllocatedTargetFromPrevStmt(const Stmt *PrevS, const\
  \ Expr *&AllocatedTargetExpr,\n                                      CheckerContext\
  \ &C) const;\n\n  // Check if a given CallExpr represents a known allocator which\
  \ can return NULL.\n  bool isKnownAllocatorCall(const CallExpr *CE, CheckerContext\
  \ &C) const;\n\n  // Determine if the Then-branch of the IfStmt looks like an allocation\
  \ failure path.\n  bool thenBranchIsAllocError(const IfStmt *IfS, CheckerContext\
  \ &C) const;\n\n  // Utility: is expression a null constant (0 or NULL)?\n  bool\
  \ isNullConstant(const Expr *E, CheckerContext &C) const;\n};\n\nconst Expr *SAGenTestChecker::getNegNullCheckedExprRaw(const\
  \ Stmt *Condition,\n                                                       CheckerContext\
  \ &C) const {\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n\
  \    return nullptr;\n\n  // Peel likely()/unlikely() wrappers if present.\n  const\
  \ Expr *Tmp = CondE->IgnoreParenImpCasts();\n  if (const auto *Call = dyn_cast<CallExpr>(Tmp))\
  \ {\n    const Expr *CalleeE = Call->getCallee();\n    if (CalleeE && (ExprHasName(CalleeE,\
  \ \"likely\", C) || ExprHasName(CalleeE, \"unlikely\", C))) {\n      if (Call->getNumArgs()\
  \ >= 1) {\n        CondE = Call->getArg(0);\n      }\n    }\n  }\n\n  // Recompute\
  \ after possible peeling\n  CondE = dyn_cast<Expr>(CondE);\n  if (!CondE)\n    return\
  \ nullptr;\n\n  // Pattern 1: if (!X)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE->IgnoreParens()))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *XRaw = UO->getSubExpr();\n\
  \      if (!XRaw)\n        return nullptr;\n      QualType QT = XRaw->getType();\n\
  \      if (QT->isPointerType())\n        return XRaw; // raw expr, do not strip\
  \ casts for region extraction\n      return nullptr;\n    }\n  }\n\n  // Pattern\
  \ 2: if (X == NULL/0)\n  if (const auto *BO = dyn_cast<BinaryOperator>(CondE->IgnoreParens()))\
  \ {\n    if (BO->getOpcode() == BO_EQ) {\n      const Expr *LHSRaw = BO->getLHS();\n\
  \      const Expr *RHSRaw = BO->getRHS();\n      if (!LHSRaw || !RHSRaw)\n     \
  \   return nullptr;\n\n      bool LHSNull = isNullConstant(LHSRaw, C);\n      bool\
  \ RHSNull = isNullConstant(RHSRaw, C);\n\n      const Expr *PtrRaw = nullptr;\n\
  \      if (LHSNull && !RHSNull)\n        PtrRaw = RHSRaw;\n      else if (RHSNull\
  \ && !LHSNull)\n        PtrRaw = LHSRaw;\n\n      if (PtrRaw) {\n        if (PtrRaw->getType()->isPointerType())\n\
  \          return PtrRaw;\n      }\n    }\n  }\n\n  return nullptr;\n}\n\nbool SAGenTestChecker::isNullConstant(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n  // Quick\
  \ textual check for NULL macro in the expression source.\n  if (ExprHasName(E, \"\
  NULL\", C))\n    return true;\n\n  // Semantic checks.\n  if (E->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull))\n    return true;\n\n  llvm::APSInt Res;\n  if\
  \ (EvaluateExprToInt(Res, E, C)) {\n    if (Res == 0)\n      return true;\n  }\n\
  \  return false;\n}\n\nconst Stmt *SAGenTestChecker::getPrevSiblingStmt(const IfStmt\
  \ *IfS, CheckerContext &C) const {\n  if (!IfS)\n    return nullptr;\n\n  const\
  \ CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(IfS, C);\n  if (!CS)\n\
  \    return nullptr;\n\n  const Stmt *Prev = nullptr;\n  for (const Stmt *S : CS->body())\
  \ {\n    if (S == IfS) {\n      return Prev;\n    }\n    Prev = S;\n  }\n  return\
  \ nullptr;\n}\n\nbool SAGenTestChecker::isKnownAllocatorCall(const CallExpr *CE,\
  \ CheckerContext &C) const {\n  if (!CE)\n    return false;\n  const Expr *CalleeE\
  \ = CE->getCallee();\n  if (!CalleeE)\n    return false;\n\n  // Known allocators\
  \ that can return NULL\n  static const char *AllocNames[] = {\n      \"kzalloc\"\
  , \"kmalloc\", \"kcalloc\", \"kmalloc_array\",\n      \"kzalloc_array\", \"krealloc\"\
  , \"kmemdup\"\n  };\n\n  for (const char *Name : AllocNames) {\n    if (ExprHasName(CalleeE,\
  \ Name, C))\n      return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getAllocatedTargetFromPrevStmt(const\
  \ Stmt *PrevS,\n                                                      const Expr\
  \ *&AllocatedTargetExpr,\n                                                     \
  \ CheckerContext &C) const {\n  if (!PrevS)\n    return false;\n\n  // Case 1: assignment:\
  \ LHS = allocator(...)\n  if (const auto *BO = dyn_cast<BinaryOperator>(PrevS))\
  \ {\n    if (BO->getOpcode() == BO_Assign) {\n      const Expr *LHSRaw = BO->getLHS();\n\
  \      const Expr *RHS = BO->getRHS();\n      if (!LHSRaw || !RHS)\n        return\
  \ false;\n\n      const CallExpr *CallInRHS = findSpecificTypeInChildren<CallExpr>(RHS);\n\
  \      if (!CallInRHS)\n        return false;\n\n      if (!isKnownAllocatorCall(CallInRHS,\
  \ C))\n        return false;\n\n      // LHS must be a pointer-typed target.\n \
  \     if (!LHSRaw->getType()->isAnyPointerType() && !LHSRaw->getType()->isPointerType())\n\
  \        return false;\n\n      AllocatedTargetExpr = LHSRaw; // raw expr for region\
  \ extraction\n      return true;\n    }\n  }\n\n  // Case 2: declaration with initializer:\
  \ T *p = allocator(...);\n  if (const auto *DS = dyn_cast<DeclStmt>(PrevS)) {\n\
  \    if (!DS->isSingleDecl())\n      return false;\n    const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());\n\
  \    if (!VD)\n      return false;\n    const Expr *Init = VD->getInit();\n    if\
  \ (!Init)\n      return false;\n\n    const CallExpr *CallInInit = findSpecificTypeInChildren<CallExpr>(Init);\n\
  \    if (!CallInInit)\n      return false;\n    if (!isKnownAllocatorCall(CallInInit,\
  \ C))\n      return false;\n\n    if (!VD->getType()->isPointerType())\n      return\
  \ false;\n\n    // We will get region from VarDecl via lvalue, so we don't need\
  \ an Expr.\n    // For uniformity with rest of code, fabricate a DeclRefExpr is\
  \ complex; instead,\n    // we handle VarDecl specially later if needed. Here, return\
  \ false to keep\n    // the checker conservative unless we really need this case.\n\
  \    // However, to support this path, we can still return false and rely on the\n\
  \    // assignment case which covers the provided buggy code.\n    return false;\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::thenBranchIsAllocError(const\
  \ IfStmt *IfS, CheckerContext &C) const {\n  if (!IfS)\n    return false;\n\n  const\
  \ Stmt *ThenS = IfS->getThen();\n  if (!ThenS)\n    return false;\n\n  // Search\
  \ for a ReturnStmt in the then-branch.\n  const ReturnStmt *RS = findSpecificTypeInChildren<ReturnStmt>(ThenS);\n\
  \  if (!RS)\n    return false;\n\n  const Expr *RetE = RS->getRetValue();\n  if\
  \ (!RetE)\n    return false;\n\n  // Heuristic: Return mentions ENOMEM (e.g., return\
  \ -ENOMEM;)\n  if (ExprHasName(RetE, \"ENOMEM\", C))\n    return true;\n\n  return\
  \ false;\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const {\n  // 1) Extract the negatively null-checked expression\
  \ from the condition.\n  const Expr *CheckedExprRaw = getNegNullCheckedExprRaw(Condition,\
  \ C);\n  if (!CheckedExprRaw)\n    return;\n\n  // The checked expression must be\
  \ a pointer type.\n  if (!CheckedExprRaw->getType()->isPointerType())\n    return;\n\
  \n  // 2) Find the enclosing IfStmt for this condition.\n  const IfStmt *IfS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IfS)\n    return;\n\n  // 3) Find the previous sibling statement.\n\
  \  const Stmt *PrevS = getPrevSiblingStmt(IfS, C);\n  if (!PrevS)\n    return;\n\
  \n  // 4) Determine if previous statement is an allocation assignment and get the\
  \ LHS (allocated target).\n  const Expr *AllocatedTargetExpr = nullptr;\n  if (!getAllocatedTargetFromPrevStmt(PrevS,\
  \ AllocatedTargetExpr, C))\n    return;\n\n  // 5) Check that then-branch looks\
  \ like an allocation error path (e.g. return -ENOMEM).\n  if (!thenBranchIsAllocError(IfS,\
  \ C))\n    return;\n\n  // 6) Compare memory regions of the allocated target and\
  \ the checked pointer.\n  const MemRegion *AllocReg = getMemRegionFromExpr(AllocatedTargetExpr,\
  \ C);\n  if (!AllocReg)\n    return;\n  AllocReg = AllocReg->getBaseRegion();\n\
  \  if (!AllocReg)\n    return;\n\n  const MemRegion *CheckedReg = getMemRegionFromExpr(CheckedExprRaw,\
  \ C);\n  if (!CheckedReg)\n    return;\n  CheckedReg = CheckedReg->getBaseRegion();\n\
  \  if (!CheckedReg)\n    return;\n\n  // If they are different, we likely checked\
  \ the wrong pointer.\n  if (AllocReg != CheckedReg) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Wrong pointer checked after allocation\", N);\n    R->addRange(IfS->getCond()->getSourceRange());\n\
  \    C.emitReport(std::move(R));\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects checking a different pointer\
  \ than the one just allocated (wrong NULL-check after allocation)\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
