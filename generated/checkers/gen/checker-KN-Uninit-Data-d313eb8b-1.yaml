_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: d313eb8b77557a6d5855f42d2234bd592c7b50dd
commit_type: Uninit-Data
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include\
  \ \"clang/AST/ParentMap.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(StructInitRiskMap,\
  \ const VarDecl *, bool)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::PostStmt<DeclStmt>,\n        check::PreCall,\n        check::PostCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n\
  \      : BT(new BugType(this, \"Kernel infoleak: partial struct init\",\n      \
  \                 \"Memory Management\")) {}\n\n  void checkPostStmt(const DeclStmt\
  \ *DS, CheckerContext &C) const;\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \nprivate:\n  // Helpers\n  static bool isLocalRecordVar(const VarDecl *VD);\n \
  \ static const VarDecl *getVarDeclFromArg(const Expr *E, CheckerContext &C,\n  \
  \                                        const MemRegion **OutMR = nullptr);\n \
  \ static bool isZeroInt(const Expr *E, CheckerContext &C);\n  static bool isSizeofVar(const\
  \ Expr *LenExpr, const VarDecl *VD, CheckerContext &C);\n  static bool isMemsetCall(const\
  \ CallEvent &Call, CheckerContext &C);\n  static bool isMemsetZeroWholeVar(const\
  \ CallEvent &Call, const VarDecl *&OutVD,\n                                   CheckerContext\
  \ &C);\n  static bool getExportToUserLayout(const CallEvent &Call, unsigned &LenIdx,\n\
  \                                    unsigned &DataIdx, CheckerContext &C);\n\n\
  \  void reportLeak(const Expr *DataE, const Expr *LenE, CheckerContext &C) const;\n\
  };\n\n// ----------------- Helper Implementations -----------------\n\nbool SAGenTestChecker::isLocalRecordVar(const\
  \ VarDecl *VD) {\n  if (!VD)\n    return false;\n  if (!VD->isLocalVarDecl() ||\
  \ !VD->hasLocalStorage())\n    return false;\n  if (VD->isStaticLocal())\n    return\
  \ false;\n  QualType T = VD->getType();\n  return T->isRecordType();\n}\n\nconst\
  \ VarDecl *SAGenTestChecker::getVarDeclFromArg(const Expr *E, CheckerContext &C,\n\
  \                                                   const MemRegion **OutMR) {\n\
  \  if (!E)\n    return nullptr;\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR)\n    return nullptr;\n  const MemRegion *Base = MR->getBaseRegion();\n\
  \  if (!Base)\n    return nullptr;\n\n  // We only accept taking the address of\
  \ the whole object, not subfields/elements.\n  if (!isa<VarRegion>(MR))\n    return\
  \ nullptr;\n\n  const auto *VR = dyn_cast<VarRegion>(Base);\n  if (!VR)\n    return\
  \ nullptr;\n  const auto *VD = dyn_cast<VarDecl>(VR->getDecl());\n  if (OutMR)\n\
  \    *OutMR = MR;\n  return VD;\n}\n\nbool SAGenTestChecker::isZeroInt(const Expr\
  \ *E, CheckerContext &C) {\n  if (!E)\n    return false;\n  llvm::APSInt Res;\n\
  \  if (EvaluateExprToInt(Res, E, C)) {\n    return Res == 0;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isSizeofVar(const Expr *LenExpr, const VarDecl *VD,\
  \ CheckerContext &C) {\n  if (!LenExpr || !VD)\n    return false;\n\n  const auto\
  \ *UETT = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(LenExpr);\n  if (!UETT)\n\
  \    return false;\n\n  if (UETT->getKind() != UETT_SizeOf)\n    return false;\n\
  \n  if (UETT->isArgumentType()) {\n    QualType Ty = UETT->getArgumentType();\n\
  \    return C.getASTContext().hasSameUnqualifiedType(Ty, VD->getType());\n  } else\
  \ {\n    const Expr *Arg = UETT->getArgumentExpr();\n    if (!Arg)\n      return\
  \ false;\n    Arg = Arg->IgnoreParenCasts();\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(Arg))\
  \ {\n      if (const auto *RefVD = dyn_cast<VarDecl>(DRE->getDecl())) {\n      \
  \  return RefVD == VD;\n      }\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isMemsetCall(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  if (ExprHasName(Origin, \"memset\", C))\n\
  \    return true;\n  if (ExprHasName(Origin, \"__builtin_memset\", C))\n    return\
  \ true;\n  return false;\n}\n\nbool SAGenTestChecker::isMemsetZeroWholeVar(const\
  \ CallEvent &Call, const VarDecl *&OutVD,\n                                    \
  \        CheckerContext &C) {\n  OutVD = nullptr;\n  if (!isMemsetCall(Call, C))\n\
  \    return false;\n\n  if (Call.getNumArgs() < 3)\n    return false;\n\n  // Arg0:\
  \ destination buffer\n  const Expr *BufE = Call.getArgExpr(0);\n  const VarDecl\
  \ *VD = getVarDeclFromArg(BufE, C);\n  if (!isLocalRecordVar(VD))\n    return false;\n\
  \n  // Arg1: value should be zero\n  const Expr *ValE = Call.getArgExpr(1);\n  if\
  \ (!isZeroInt(ValE, C))\n    return false;\n\n  // Arg2: size should be sizeof(VD)\
  \ or sizeof(type-of-VD)\n  const Expr *SizeE = Call.getArgExpr(2);\n  if (!isSizeofVar(SizeE,\
  \ VD, C))\n    return false;\n\n  OutVD = VD;\n  return true;\n}\n\nbool SAGenTestChecker::getExportToUserLayout(const\
  \ CallEvent &Call, unsigned &LenIdx,\n                                         \
  \    unsigned &DataIdx, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // nla_put(skb, type, len, data)\n  if (ExprHasName(Origin,\
  \ \"nla_put\", C)) {\n    if (Call.getNumArgs() >= 4) {\n      LenIdx = 2;\n   \
  \   DataIdx = 3;\n      return true;\n    }\n  }\n\n  // nla_put_64bit(skb, type,\
  \ len, data, padattr)\n  if (ExprHasName(Origin, \"nla_put_64bit\", C)) {\n    if\
  \ (Call.getNumArgs() >= 5) {\n      LenIdx = 2;\n      DataIdx = 3;\n      return\
  \ true;\n    }\n  }\n\n  // nla_put_nohdr(skb, len, data)\n  if (ExprHasName(Origin,\
  \ \"nla_put_nohdr\", C)) {\n    if (Call.getNumArgs() >= 3) {\n      LenIdx = 0;\n\
  \      DataIdx = 1;\n      return true;\n    }\n  }\n\n  // copy_to_user(to, from,\
  \ n)\n  if (ExprHasName(Origin, \"copy_to_user\", C)) {\n    if (Call.getNumArgs()\
  \ >= 3) {\n      LenIdx = 2;\n      DataIdx = 1;\n      return true;\n    }\n  }\n\
  \n  // copy_to_user_iter(to, from, bytes)\n  if (ExprHasName(Origin, \"copy_to_user_iter\"\
  , C)) {\n    if (Call.getNumArgs() >= 3) {\n      LenIdx = 2;\n      DataIdx = 1;\n\
  \      return true;\n    }\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::reportLeak(const\
  \ Expr *DataE, const Expr *LenE, CheckerContext &C) const {\n  ExplodedNode *N =\
  \ C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Partially initialized stack struct copied to user; zero it with memset.\"\
  , N);\n  if (DataE)\n    R->addRange(DataE->getSourceRange());\n  if (LenE)\n  \
  \  R->addRange(LenE->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n//\
  \ ----------------- Checker Callbacks -----------------\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  bool Changed = false;\n\n  for (const Decl *D : DS->decls()) {\n    const auto\
  \ *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      continue;\n\n    if (!isLocalRecordVar(VD))\n\
  \      continue;\n\n    bool Risky = true; // default risky unless proven safe\n\
  \n    if (!VD->hasInit()) {\n      // No initializer: risky.\n      Risky = true;\n\
  \    } else {\n      const Expr *Init = VD->getInit();\n      if (const auto *ILE\
  \ = dyn_cast<InitListExpr>(Init->IgnoreImplicit())) {\n        // {} -> safe; any\
  \ other partial init -> risky\n        if (ILE->getNumInits() == 0)\n          Risky\
  \ = false;\n        else\n          Risky = true;\n      } else {\n        // Other\
  \ forms: conservatively mark risky\n        Risky = true;\n      }\n    }\n\n  \
  \  const bool *Old = State->get<StructInitRiskMap>(VD);\n    if (!Old || *Old !=\
  \ Risky) {\n      State = State->set<StructInitRiskMap>(VD, Risky);\n      Changed\
  \ = true;\n    }\n  }\n\n  if (Changed)\n    C.addTransition(State);\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  ProgramStateRef State = C.getState();\n\n  // Detect memset(&var, 0, sizeof(var\
  \ or type))\n  const VarDecl *VD = nullptr;\n  if (isMemsetZeroWholeVar(Call, VD,\
  \ C) && VD) {\n    // Mark as safe\n    State = State->set<StructInitRiskMap>(VD,\
  \ false);\n    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  unsigned LenIdx = 0, DataIdx = 0;\n  if (!getExportToUserLayout(Call, LenIdx,\
  \ DataIdx, C))\n    return;\n\n  if (Call.getNumArgs() <= std::max(LenIdx, DataIdx))\n\
  \    return;\n\n  const Expr *DataE = Call.getArgExpr(DataIdx);\n  const MemRegion\
  \ *MR = nullptr;\n  const VarDecl *VD = getVarDeclFromArg(DataE, C, &MR);\n  if\
  \ (!VD || !isLocalRecordVar(VD))\n    return;\n\n  // Ensure the data pointer is\
  \ the address of the whole object, not a field/element.\n  if (!MR || !isa<VarRegion>(MR))\n\
  \    return;\n\n  const Expr *LenE = Call.getArgExpr(LenIdx);\n  if (!isSizeofVar(LenE,\
  \ VD, C))\n    return;\n\n  const bool *Risky = State->get<StructInitRiskMap>(VD);\n\
  \  if (Risky && *Risky) {\n    reportLeak(DataE, LenE, C);\n  }\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects copying partially initialized stack structs (with padding) to\
  \ user space\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/sched: act_skbmod: prevent kernel-infoleak\n\n\
  syzbot found that tcf_skbmod_dump() was copying four bytes\nfrom kernel stack to\
  \ user space [1].\n\nThe issue here is that 'struct tc_skbmod' has a four bytes\
  \ hole.\n\nWe need to clear the structure before filling fields.\n\n[1]\nBUG: KMSAN:\
  \ kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in copy_to_user_iter lib/iov_iter.c:24 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_and_advance2 include/linux/iov_iter.h:245\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in iterate_and_advance include/linux/iov_iter.h:271\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n  copy_to_user_iter\
  \ lib/iov_iter.c:24 [inline]\n  iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \  iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\n  iterate_and_advance\
  \ include/linux/iov_iter.h:271 [inline]\n  _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  copy_to_iter include/linux/uio.h:196 [inline]\n  simple_copy_to_iter net/core/datagram.c:532\
  \ [inline]\n  __skb_datagram_iter+0x185/0x1000 net/core/datagram.c:420\n  skb_copy_datagram_iter+0x5c/0x200\
  \ net/core/datagram.c:546\n  skb_copy_datagram_msg include/linux/skbuff.h:4050 [inline]\n\
  \  netlink_recvmsg+0x432/0x1610 net/netlink/af_netlink.c:1962\n  sock_recvmsg_nosec\
  \ net/socket.c:1046 [inline]\n  sock_recvmsg+0x2c4/0x340 net/socket.c:1068\n  __sys_recvfrom+0x35a/0x5f0\
  \ net/socket.c:2242\n  __do_sys_recvfrom net/socket.c:2260 [inline]\n  __se_sys_recvfrom\
  \ net/socket.c:2256 [inline]\n  __x64_sys_recvfrom+0x126/0x1d0 net/socket.c:2256\n\
  \ do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nUninit\
  \ was stored to memory at:\n  pskb_expand_head+0x30f/0x19d0 net/core/skbuff.c:2253\n\
  \  netlink_trim+0x2c2/0x330 net/netlink/af_netlink.c:1317\n  netlink_unicast+0x9f/0x1260\
  \ net/netlink/af_netlink.c:1351\n  nlmsg_unicast include/net/netlink.h:1144 [inline]\n\
  \  nlmsg_notify+0x21d/0x2f0 net/netlink/af_netlink.c:2610\n  rtnetlink_send+0x73/0x90\
  \ net/core/rtnetlink.c:741\n  rtnetlink_maybe_send include/linux/rtnetlink.h:17\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2048 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x146e/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nUninit was stored to memory at:\n  __nla_put lib/nlattr.c:1041 [inline]\n  nla_put+0x1c6/0x230\
  \ lib/nlattr.c:1099\n  tcf_skbmod_dump+0x23f/0xc20 net/sched/act_skbmod.c:256\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n  tcf_action_dump+0x1fd/0x460 net/sched/act_api.c:1251\n\
  \  tca_get_fill+0x519/0x7a0 net/sched/act_api.c:1628\n  tcf_add_notify_msg net/sched/act_api.c:2023\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2042 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x1365/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nLocal variable opt created at:\n  tcf_skbmod_dump+0x9d/0xc20 net/sched/act_skbmod.c:244\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n\nBytes 188-191 of 248 are uninitialized\nMemory access\
  \ of size 248 starts at ffff888117697680\nData copied to user address 00007ffe56d855f0\n\
  \nFixes: 86da71b57383 (\"net_sched: Introduce skbmod action\")\nSigned-off-by: Eric\
  \ Dumazet <edumazet@google.com>\nAcked-by: Jamal Hadi Salim <jhs@mojatatu.com>\n\
  Link: https://lore.kernel.org/r/20240403130908.93421-1-edumazet@google.com\nSigned-off-by:\
  \ Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: tcf_skbmod_dump\
  \ in net/sched/act_skbmod.c\nstatic int tcf_skbmod_dump(struct sk_buff *skb, struct\
  \ tc_action *a,\n\t\t\t   int bind, int ref)\n{\n\tstruct tcf_skbmod *d = to_skbmod(a);\n\
  \tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_skbmod_params  *p;\n\t\
  struct tc_skbmod opt = {\n\t\t.index   = d->tcf_index,\n\t\t.refcnt  = refcount_read(&d->tcf_refcnt)\
  \ - ref,\n\t\t.bindcnt = atomic_read(&d->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t\
  \ t;\n\n\tspin_lock_bh(&d->tcf_lock);\n\topt.action = d->tcf_action;\n\tp = rcu_dereference_protected(d->skbmod_p,\n\
  \t\t\t\t      lockdep_is_held(&d->tcf_lock));\n\topt.flags  = p->flags;\n\tif (nla_put(skb,\
  \ TCA_SKBMOD_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_DMAC) &&\n\t    nla_put(skb, TCA_SKBMOD_DMAC, ETH_ALEN, p->eth_dst))\n\
  \t\tgoto nla_put_failure;\n\tif ((p->flags & SKBMOD_F_SMAC) &&\n\t    nla_put(skb,\
  \ TCA_SKBMOD_SMAC, ETH_ALEN, p->eth_src))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_ETYPE) &&\n\t    nla_put_u16(skb, TCA_SKBMOD_ETYPE, ntohs(p->eth_type)))\n\
  \t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &d->tcf_tm);\n\tif (nla_put_64bit(skb,\
  \ TCA_SKBMOD_TM, sizeof(t), &t, TCA_SKBMOD_PAD))\n\t\tgoto nla_put_failure;\n\n\t\
  spin_unlock_bh(&d->tcf_lock);\n\treturn skb->len;\nnla_put_failure:\n\tspin_unlock_bh(&d->tcf_lock);\n\
  \tnlmsg_trim(skb, b);\n\treturn -1;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff\
  \ --git a/net/sched/act_skbmod.c b/net/sched/act_skbmod.c\nindex 39945b139c48..cd0accaf844a\
  \ 100644\n--- a/net/sched/act_skbmod.c\n+++ b/net/sched/act_skbmod.c\n@@ -241,13\
  \ +241,13 @@ static int tcf_skbmod_dump(struct sk_buff *skb, struct tc_action *a,\n\
  \ \tstruct tcf_skbmod *d = to_skbmod(a);\n \tunsigned char *b = skb_tail_pointer(skb);\n\
  \ \tstruct tcf_skbmod_params  *p;\n-\tstruct tc_skbmod opt = {\n-\t\t.index   =\
  \ d->tcf_index,\n-\t\t.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n-\t\t.bindcnt\
  \ = atomic_read(&d->tcf_bindcnt) - bind,\n-\t};\n+\tstruct tc_skbmod opt;\n \tstruct\
  \ tcf_t t;\n \n+\tmemset(&opt, 0, sizeof(opt));\n+\topt.index   = d->tcf_index;\n\
  +\topt.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n+\topt.bindcnt = atomic_read(&d->tcf_bindcnt)\
  \ - bind;\n \tspin_lock_bh(&d->tcf_lock);\n \topt.action = d->tcf_action;\n \tp\
  \ = rcu_dereference_protected(d->skbmod_p,\n```\n"
pattern: '## Bug Pattern


  Stack-allocated struct with padding/holes is only partially initialized, then the
  entire struct (sizeof(struct)) is copied to user space (e.g., via nla_put/copy_to_user).
  The uninitialized padding bytes get leaked.


  Pattern example:

  - struct S has implicit padding

  - Code initializes only some members

  - Calls nla_put(..., sizeof(S), &s) (or equivalent) without zeroing s first


  Root cause: not zero-initializing a struct with padding before exporting it, leading
  to kernel-infoleak through uninitialized padding bytes.'
plan: "Plan\n\n1. Program state\n- REGISTER_MAP_WITH_PROGRAMSTATE(StructInitRiskMap,\
  \ const VarDecl *, bool)\n  - Key: the VarDecl of a stack-allocated struct.\n  -\
  \ Value: true = may contain uninitialized bytes (risky); false = known zeroed (safe).\n\
  - Rationale: We only need to know \u201Crisky vs. safe\u201D per local struct. We\
  \ match later via VarDecl extracted from the MemRegion of \u201C&var\u201D.\n\n\
  2. Helpers\n- isLocalRecordVar(const VarDecl *VD):\n  - return VD && VD->isLocalVarDecl()\
  \ && VD->hasLocalStorage() && VD->getType()->isRecordType() && !VD->isStaticLocal();\n\
  - getVarDeclFromArg(const Expr *E, CheckerContext &C):\n  - Use getMemRegionFromExpr(E,\
  \ C).\n  - If region exists, take R->getBaseRegion(), dyn_cast<VarRegion>, then\
  \ return cast<VarDecl>(VR->getDecl()).\n- isSizeofVar(const Expr *LenExpr, const\
  \ VarDecl *VD):\n  - Using findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(LenExpr)\
  \ find a UETT_SizeOf.\n  - If the sizeof refers to an expression: check if it\u2019\
  s a DeclRefExpr of the same VD.\n  - If the sizeof refers to a type: compare it\
  \ with VD->getType() (ignoring qualifiers). If they are the same record type, return\
  \ true.\n- isZeroInt(const Expr *E, CheckerContext &C):\n  - Use EvaluateExprToInt;\
  \ if true and value == 0, return true.\n- isMemsetZeroWholeVar(const CallEvent &Call,\
  \ const VarDecl *VD, CheckerContext &C):\n  - Callee name must be \u201Cmemset\u201D\
  \ or \u201C__builtin_memset\u201D.\n  - Arg0: buffer, Arg1: value, Arg2: size.\n\
  \  - Arg1 must be zero via isZeroInt.\n  - Arg0 must be &VD (use getVarDeclFromArg\
  \ on Arg0 and compare to VD).\n  - Arg2 must be sizeof(VD) via isSizeofVar(Arg2,\
  \ VD).\n- getExportToUserLayout(const CallEvent &Call, unsigned &LenIdx, unsigned\
  \ &DataIdx):\n  - For the following names, set indices and return true:\n    - \u201C\
  nla_put\u201D: LenIdx=2, DataIdx=3\n    - \u201Cnla_put_64bit\u201D: LenIdx=2, DataIdx=3\n\
  \    - \u201Cnla_put_nohdr\u201D: LenIdx=0, DataIdx=1\n    - \u201Ccopy_to_user\u201D\
  : LenIdx=2, DataIdx=1\n    - \u201Ccopy_to_user_iter\u201D: LenIdx=2, DataIdx=1\n\
  \  - Otherwise return false.\n\n3. checkPostStmt(const DeclStmt *DS)\n- For each\
  \ decl in DS:\n  - If VarDecl* VD and isLocalRecordVar(VD):\n    - If no initializer:\
  \ mark risky: State = State->set<StructInitRiskMap>(VD, true).\n    - If has initializer:\n\
  \      - If it is an InitListExpr:\n        - If getNumInits() == 0 (i.e., \u201C\
  {}\u201D): consider safe: State->set(VD, false).\n        - Otherwise, consider\
  \ risky: State->set(VD, true).\n      - Else: conservatively mark risky (true).\n\
  \    - Note: We intentionally do not attempt field-level tracking; this keeps the\
  \ checker simple and aligns with the kernel\u2019s guidance to use memset for padding.\n\
  \n4. checkPostCall(const CallEvent &Call, CheckerContext &C)\n- Detect memset zeroing\
  \ that clears the entire struct:\n  - For each entry (VD -> bool) in StructInitRiskMap\
  \ where value is true:\n    - If isMemsetZeroWholeVar(Call, VD, C) is true:\n  \
  \    - Set VD to safe: State->set<StructInitRiskMap>(VD, false).\n- No other modeling\
  \ needed.\n\n5. checkPreCall(const CallEvent &Call, CheckerContext &C)\n- Identify\
  \ export-to-user functions:\n  - unsigned LenIdx, DataIdx; if !getExportToUserLayout(Call,\
  \ LenIdx, DataIdx) return.\n- Extract the data VarDecl:\n  - const Expr *DataE =\
  \ Call.getArgExpr(DataIdx);\n  - const VarDecl *VD = getVarDeclFromArg(DataE, C).\n\
  \  - Require VD != nullptr and isLocalRecordVar(VD).\n  - Additionally, ensure the\
  \ data expression is the address of the whole object (not a field):\n    - If the\
  \ MemRegion from DataE base is a VarRegion (not FieldRegion/ElementRegion), accept;\
  \ otherwise skip (we only warn on copying the whole struct object).\n- Ensure the\
  \ length matches sizeof(var):\n  - const Expr *LenE = Call.getArgExpr(LenIdx);\n\
  \  - If !isSizeofVar(LenE, VD), return (only warn on whole-struct copies).\n- Consult\
  \ map:\n  - bool Risky; if State->lookup<StructInitRiskMap>(VD, Risky) && Risky\
  \ == true:\n    - Report a bug.\n\n6. Bug reporting\n- Use generateNonFatalErrorNode()\
  \ and std::make_unique<PathSensitiveBugReport>.\n- BugType: \u201CKernel infoleak:\
  \ partial struct init\u201D.\n- Message: \u201CPartially initialized stack struct\
  \ copied to user; zero it with memset.\u201D\n- Add ranges:\n  - Highlight DataE\
  \ and LenE ranges if available.\n\n7. Notes and simplifications\n- We only clear\
  \ risk via an explicit memset(&var, 0, sizeof(var)). Other patterns (e.g., s = (struct\
  \ S){0};) are not considered; this avoids complex modeling and matches kernel guidance.\n\
  - We only warn when:\n  - The data pointer is the address of a stack struct object\
  \ (not a field),\n  - The length is sizeof(the struct object or its type),\n  -\
  \ The variable is marked risky at that point.\n- This is intentionally conservative\
  \ and simple; it will catch the target pattern demonstrated in the provided patch\
  \ (designated/partial initializer + nla_put with sizeof(var))."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include\
  \ \"clang/AST/ParentMap.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(StructInitRiskMap,\
  \ const VarDecl *, bool)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::PostStmt<DeclStmt>,\n        check::PreCall,\n        check::PostCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n\
  \      : BT(new BugType(this, \"Kernel infoleak: partial struct init\",\n      \
  \                 \"Memory Management\")) {}\n\n  void checkPostStmt(const DeclStmt\
  \ *DS, CheckerContext &C) const;\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \nprivate:\n  // Helpers\n  static bool isLocalRecordVar(const VarDecl *VD);\n \
  \ static const VarDecl *getVarDeclFromArg(const Expr *E, CheckerContext &C,\n  \
  \                                        const MemRegion **OutMR = nullptr);\n \
  \ static bool isZeroInt(const Expr *E, CheckerContext &C);\n  static bool isSizeofVar(const\
  \ Expr *LenExpr, const VarDecl *VD, CheckerContext &C);\n  static bool isMemsetCall(const\
  \ CallEvent &Call, CheckerContext &C);\n  static bool isMemsetZeroWholeVar(const\
  \ CallEvent &Call, const VarDecl *&OutVD,\n                                   CheckerContext\
  \ &C);\n  static bool getExportToUserLayout(const CallEvent &Call, unsigned &LenIdx,\n\
  \                                    unsigned &DataIdx, CheckerContext &C);\n\n\
  \  void reportLeak(const Expr *DataE, const Expr *LenE, CheckerContext &C) const;\n\
  };\n\n// ----------------- Helper Implementations -----------------\n\nbool SAGenTestChecker::isLocalRecordVar(const\
  \ VarDecl *VD) {\n  if (!VD)\n    return false;\n  if (!VD->isLocalVarDecl() ||\
  \ !VD->hasLocalStorage())\n    return false;\n  if (VD->isStaticLocal())\n    return\
  \ false;\n  QualType T = VD->getType();\n  return T->isRecordType();\n}\n\nconst\
  \ VarDecl *SAGenTestChecker::getVarDeclFromArg(const Expr *E, CheckerContext &C,\n\
  \                                                   const MemRegion **OutMR) {\n\
  \  if (!E)\n    return nullptr;\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR)\n    return nullptr;\n  const MemRegion *Base = MR->getBaseRegion();\n\
  \  if (!Base)\n    return nullptr;\n\n  // We only accept taking the address of\
  \ the whole object, not subfields/elements.\n  if (!isa<VarRegion>(MR))\n    return\
  \ nullptr;\n\n  const auto *VR = dyn_cast<VarRegion>(Base);\n  if (!VR)\n    return\
  \ nullptr;\n  const auto *VD = dyn_cast<VarDecl>(VR->getDecl());\n  if (OutMR)\n\
  \    *OutMR = MR;\n  return VD;\n}\n\nbool SAGenTestChecker::isZeroInt(const Expr\
  \ *E, CheckerContext &C) {\n  if (!E)\n    return false;\n  llvm::APSInt Res;\n\
  \  if (EvaluateExprToInt(Res, E, C)) {\n    return Res == 0;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isSizeofVar(const Expr *LenExpr, const VarDecl *VD,\
  \ CheckerContext &C) {\n  if (!LenExpr || !VD)\n    return false;\n\n  const auto\
  \ *UETT = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(LenExpr);\n  if (!UETT)\n\
  \    return false;\n\n  if (UETT->getKind() != UETT_SizeOf)\n    return false;\n\
  \n  if (UETT->isArgumentType()) {\n    QualType Ty = UETT->getArgumentType();\n\
  \    return C.getASTContext().hasSameUnqualifiedType(Ty, VD->getType());\n  } else\
  \ {\n    const Expr *Arg = UETT->getArgumentExpr();\n    if (!Arg)\n      return\
  \ false;\n    Arg = Arg->IgnoreParenCasts();\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(Arg))\
  \ {\n      if (const auto *RefVD = dyn_cast<VarDecl>(DRE->getDecl())) {\n      \
  \  return RefVD == VD;\n      }\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isMemsetCall(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  if (ExprHasName(Origin, \"memset\", C))\n\
  \    return true;\n  if (ExprHasName(Origin, \"__builtin_memset\", C))\n    return\
  \ true;\n  return false;\n}\n\nbool SAGenTestChecker::isMemsetZeroWholeVar(const\
  \ CallEvent &Call, const VarDecl *&OutVD,\n                                    \
  \        CheckerContext &C) {\n  OutVD = nullptr;\n  if (!isMemsetCall(Call, C))\n\
  \    return false;\n\n  if (Call.getNumArgs() < 3)\n    return false;\n\n  // Arg0:\
  \ destination buffer\n  const Expr *BufE = Call.getArgExpr(0);\n  const VarDecl\
  \ *VD = getVarDeclFromArg(BufE, C);\n  if (!isLocalRecordVar(VD))\n    return false;\n\
  \n  // Arg1: value should be zero\n  const Expr *ValE = Call.getArgExpr(1);\n  if\
  \ (!isZeroInt(ValE, C))\n    return false;\n\n  // Arg2: size should be sizeof(VD)\
  \ or sizeof(type-of-VD)\n  const Expr *SizeE = Call.getArgExpr(2);\n  if (!isSizeofVar(SizeE,\
  \ VD, C))\n    return false;\n\n  OutVD = VD;\n  return true;\n}\n\nbool SAGenTestChecker::getExportToUserLayout(const\
  \ CallEvent &Call, unsigned &LenIdx,\n                                         \
  \    unsigned &DataIdx, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // nla_put(skb, type, len, data)\n  if (ExprHasName(Origin,\
  \ \"nla_put\", C)) {\n    if (Call.getNumArgs() >= 4) {\n      LenIdx = 2;\n   \
  \   DataIdx = 3;\n      return true;\n    }\n  }\n\n  // nla_put_64bit(skb, type,\
  \ len, data, padattr)\n  if (ExprHasName(Origin, \"nla_put_64bit\", C)) {\n    if\
  \ (Call.getNumArgs() >= 5) {\n      LenIdx = 2;\n      DataIdx = 3;\n      return\
  \ true;\n    }\n  }\n\n  // nla_put_nohdr(skb, len, data)\n  if (ExprHasName(Origin,\
  \ \"nla_put_nohdr\", C)) {\n    if (Call.getNumArgs() >= 3) {\n      LenIdx = 0;\n\
  \      DataIdx = 1;\n      return true;\n    }\n  }\n\n  // copy_to_user(to, from,\
  \ n)\n  if (ExprHasName(Origin, \"copy_to_user\", C)) {\n    if (Call.getNumArgs()\
  \ >= 3) {\n      LenIdx = 2;\n      DataIdx = 1;\n      return true;\n    }\n  }\n\
  \n  // copy_to_user_iter(to, from, bytes)\n  if (ExprHasName(Origin, \"copy_to_user_iter\"\
  , C)) {\n    if (Call.getNumArgs() >= 3) {\n      LenIdx = 2;\n      DataIdx = 1;\n\
  \      return true;\n    }\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::reportLeak(const\
  \ Expr *DataE, const Expr *LenE, CheckerContext &C) const {\n  ExplodedNode *N =\
  \ C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Partially initialized stack struct copied to user; zero it with memset.\"\
  , N);\n  if (DataE)\n    R->addRange(DataE->getSourceRange());\n  if (LenE)\n  \
  \  R->addRange(LenE->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n//\
  \ ----------------- Checker Callbacks -----------------\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  bool Changed = false;\n\n  for (const Decl *D : DS->decls()) {\n    const auto\
  \ *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      continue;\n\n    if (!isLocalRecordVar(VD))\n\
  \      continue;\n\n    bool Risky = true; // default risky unless proven safe\n\
  \n    if (!VD->hasInit()) {\n      // No initializer: risky.\n      Risky = true;\n\
  \    } else {\n      const Expr *Init = VD->getInit();\n      if (const auto *ILE\
  \ = dyn_cast<InitListExpr>(Init->IgnoreImplicit())) {\n        // {} -> safe; any\
  \ other partial init -> risky\n        if (ILE->getNumInits() == 0)\n          Risky\
  \ = false;\n        else\n          Risky = true;\n      } else {\n        // Other\
  \ forms: conservatively mark risky\n        Risky = true;\n      }\n    }\n\n  \
  \  const bool *Old = State->get<StructInitRiskMap>(VD);\n    if (!Old || *Old !=\
  \ Risky) {\n      State = State->set<StructInitRiskMap>(VD, Risky);\n      Changed\
  \ = true;\n    }\n  }\n\n  if (Changed)\n    C.addTransition(State);\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  ProgramStateRef State = C.getState();\n\n  // Detect memset(&var, 0, sizeof(var\
  \ or type))\n  const VarDecl *VD = nullptr;\n  if (isMemsetZeroWholeVar(Call, VD,\
  \ C) && VD) {\n    // Mark as safe\n    State = State->set<StructInitRiskMap>(VD,\
  \ false);\n    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  unsigned LenIdx = 0, DataIdx = 0;\n  if (!getExportToUserLayout(Call, LenIdx,\
  \ DataIdx, C))\n    return;\n\n  if (Call.getNumArgs() <= std::max(LenIdx, DataIdx))\n\
  \    return;\n\n  const Expr *DataE = Call.getArgExpr(DataIdx);\n  const MemRegion\
  \ *MR = nullptr;\n  const VarDecl *VD = getVarDeclFromArg(DataE, C, &MR);\n  if\
  \ (!VD || !isLocalRecordVar(VD))\n    return;\n\n  // Ensure the data pointer is\
  \ the address of the whole object, not a field/element.\n  if (!MR || !isa<VarRegion>(MR))\n\
  \    return;\n\n  const Expr *LenE = Call.getArgExpr(LenIdx);\n  if (!isSizeofVar(LenE,\
  \ VD, C))\n    return;\n\n  const bool *Risky = State->get<StructInitRiskMap>(VD);\n\
  \  if (Risky && *Risky) {\n    reportLeak(DataE, LenE, C);\n  }\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects copying partially initialized stack structs (with padding) to\
  \ user space\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
