_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: d8c561741ef83980114b3f7f95ffac54600f3f16
commit_type: Double-Free
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program states:\n// - SQPendingRdyMap: sq region -> mdev region, indicates set_sq_rdy\
  \ was just invoked for this SQ.\n// - RetSymToSQMap: return SymbolRef of set_sq_rdy\
  \ -> sq region.\n// - ErrVarToSQMap: region of variable storing the return of set_sq_rdy\
  \ (e.g., 'err') -> sq region.\nREGISTER_MAP_WITH_PROGRAMSTATE(SQPendingRdyMap, const\
  \ MemRegion*, const MemRegion*)\nREGISTER_MAP_WITH_PROGRAMSTATE(RetSymToSQMap, SymbolRef,\
  \ const MemRegion*)\nREGISTER_MAP_WITH_PROGRAMSTATE(ErrVarToSQMap, const MemRegion*,\
  \ const MemRegion*)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::PostCall,\n        check::PreCall,\n        check::Bind> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this,\
  \ \"Wrong cleanup in error path\", \"Memory Management\")) {}\n\n  void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  void checkBind(SVal Loc, SVal Val, const Stmt\
  \ *S, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  static bool isCallNamed(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C);\n\n  const MemRegion *getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) const;\n\n  // Extract the SQ region from the 2nd\
  \ argument of hws_send_ring_set_sq_rdy(..., sq->sqn)\n  const MemRegion *extractSQRegionFromSetRdyArg(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n  void reportWrongCleanup(const\
  \ CallEvent &Call, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isCallNamed(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) {\n  const Expr *Origin =\
  \ Call.getOriginExpr();\n  if (!Origin)\n    return false;\n  return ExprHasName(Origin,\
  \ Name, C);\n}\n\nconst MemRegion *SAGenTestChecker::getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return nullptr;\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C);\n  if (!MR)\n    return nullptr;\n  return MR->getBaseRegion();\n\
  }\n\nconst MemRegion *SAGenTestChecker::extractSQRegionFromSetRdyArg(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  if (Call.getNumArgs() < 2)\n    return nullptr;\n\
  \n  const Expr *Arg1 = Call.getArgExpr(1);\n  if (!Arg1)\n    return nullptr;\n\n\
  \  // We expect something like sq->sqn; find MemberExpr named \"sqn\", then get\
  \ its base (the 'sq')\n  const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(Arg1);\n\
  \  if (!ME)\n    return nullptr;\n\n  const ValueDecl *MD = ME->getMemberDecl();\n\
  \  if (!MD)\n    return nullptr;\n\n  if (MD->getName() != \"sqn\")\n    return\
  \ nullptr;\n\n  const Expr *Base = ME->getBase();\n  if (!Base)\n    return nullptr;\n\
  \n  return getBaseRegionFromExpr(Base, C);\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Track hws_send_ring_set_sq_rdy(mdev, sq->sqn)\n  if (isCallNamed(Call, \"\
  hws_send_ring_set_sq_rdy\", C)) {\n    // mdev region from arg[0]\n    const Expr\
  \ *Arg0 = Call.getArgExpr(0);\n    const MemRegion *MdevReg = getBaseRegionFromExpr(Arg0,\
  \ C);\n    if (!MdevReg)\n      return;\n\n    // sq region derived from arg[1]\n\
  \    const MemRegion *SQReg = extractSQRegionFromSetRdyArg(Call, C);\n    if (!SQReg)\n\
  \      return;\n\n    // Record that this SQ is pending ready, paired with its mdev\n\
  \    State = State->set<SQPendingRdyMap>(SQReg, MdevReg);\n\n    // Map the return\
  \ symbol to the SQ\n    SVal Ret = Call.getReturnValue();\n    if (SymbolRef Sym\
  \ = Ret.getAsSymbol()) {\n      State = State->set<RetSymToSQMap>(Sym, SQReg);\n\
  \    }\n\n    C.addTransition(State);\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\n\
  \    return;\n  LHSReg = LHSReg->getBaseRegion();\n  if (!LHSReg)\n    return;\n\
  \n  if (SymbolRef Sym = Val.getAsSymbol()) {\n    const MemRegion *SQReg = State->get<RetSymToSQMap>(Sym);\n\
  \    if (SQReg) {\n      // Bind err-like variable region to the SQ region\n   \
  \   State = State->set<ErrVarToSQMap>(LHSReg, SQReg);\n      // Consume the return\
  \ symbol mapping\n      State = State->remove<RetSymToSQMap>(Sym);\n      C.addTransition(State);\n\
  \    }\n  }\n}\n\nvoid SAGenTestChecker::reportWrongCleanup(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Use destroy for partially initialized SQ; 'close' here may double\
  \ free.\", N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n\n  // Correct cleanup: hws_send_ring_destroy_sq(mdev,\
  \ sq)\n  if (isCallNamed(Call, \"hws_send_ring_destroy_sq\", C)) {\n    if (Call.getNumArgs()\
  \ >= 2) {\n      const Expr *Arg1 = Call.getArgExpr(1);\n      if (const MemRegion\
  \ *SQReg = getBaseRegionFromExpr(Arg1, C)) {\n        // Cleanup: no need to warn,\
  \ remove pending state if exists.\n        if (State->get<SQPendingRdyMap>(SQReg))\
  \ {\n          State = State->remove<SQPendingRdyMap>(SQReg);\n          C.addTransition(State);\n\
  \        }\n      }\n    }\n    return;\n  }\n\n  // Misuse we want to catch: hws_send_ring_close_sq(sq)\
  \ inside error branch after set_sq_rdy\n  if (isCallNamed(Call, \"hws_send_ring_close_sq\"\
  , C)) {\n    if (Call.getNumArgs() < 1)\n      return;\n\n    // Extract SQ region\
  \ from arg[0]\n    const Expr *Arg0 = Call.getArgExpr(0);\n    const MemRegion *SQReg\
  \ = getBaseRegionFromExpr(Arg0, C);\n    if (!SQReg)\n      return;\n\n    // Only\
  \ consider SQs that are in \"pending ready\" state\n    const MemRegion *MdevReg\
  \ = State->get<SQPendingRdyMap>(SQReg);\n    if (!MdevReg)\n      return;\n\n  \
  \  // Find nearest IfStmt containing this call: ensure it's in an error branch\n\
  \    const Expr *Origin = Call.getOriginExpr();\n    if (!Origin)\n      return;\n\
  \n    const IfStmt *IfP = findSpecificTypeInParents<IfStmt>(Origin, C);\n    if\
  \ (!IfP)\n      return;\n\n    // Heuristic: find a DeclRefExpr in condition (e.g.,\
  \ 'err')\n    const Expr *CondE = IfP->getCond();\n    if (!CondE)\n      return;\n\
  \n    const DeclRefExpr *DRE = findSpecificTypeInChildren<DeclRefExpr>(CondE);\n\
  \    if (!DRE)\n      return;\n\n    const Expr *CondVarE = DRE;\n    const MemRegion\
  \ *CondVarReg = getBaseRegionFromExpr(CondVarE, C);\n    if (!CondVarReg)\n    \
  \  return;\n\n    // Check if this condition var is mapped to the same SQ (from\
  \ set_sq_rdy result)\n    const MemRegion *MappedSQ = State->get<ErrVarToSQMap>(CondVarReg);\n\
  \    if (!MappedSQ)\n      return;\n\n    if (MappedSQ == SQReg) {\n      // This\
  \ is exactly the misuse we target.\n      reportWrongCleanup(Call, C);\n      //\
  \ Avoid duplicate reports along this path\n      State = State->remove<SQPendingRdyMap>(SQReg);\n\
  \      C.addTransition(State);\n    }\n  }\n}\n\n} // end anonymous namespace\n\n\
  extern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects using close() instead of destroy()\
  \ in the error path after set_sq_rdy, which may double free\",\n      \"\");\n}\n\
  \nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/mlx5: HWS, fixed double-free in error flow of\
  \ creating SQ\n\nWhen SQ creation fails, call the appropriate mlx5_core destroy\
  \ function.\n\nThis fixes the following smatch warnings:\n  divers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c:739\n\
  \    hws_send_ring_open_sq() warn: 'sq->dep_wqe' double freed\n    hws_send_ring_open_sq()\
  \ warn: 'sq->wq_ctrl.buf.frags' double freed\n    hws_send_ring_open_sq() warn:\
  \ 'sq->wr_priv' double freed\n\nFixes: 2ca62599aa0b (\"net/mlx5: HWS, added send\
  \ engine and context handling\")\nReported-by: Dan Carpenter <dan.carpenter@linaro.org>\n\
  Closes: https://lore.kernel.org/all/e4ebc227-4b25-49bf-9e4c-14b7ea5c6a07@stanley.mountain/\n\
  Signed-off-by: Yevgeny Kliteynik <kliteyn@nvidia.com>\nSigned-off-by: Saeed Mahameed\
  \ <saeedm@nvidia.com>\n\n## Buggy Code\n\n```c\n// Function: hws_send_ring_create_sq\
  \ in drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\nstatic\
  \ int hws_send_ring_create_sq(struct mlx5_core_dev *mdev, u32 pdn,\n\t\t\t\t   void\
  \ *sqc_data,\n\t\t\t\t   struct mlx5hws_send_engine *queue,\n\t\t\t\t   struct mlx5hws_send_ring_sq\
  \ *sq,\n\t\t\t\t   struct mlx5hws_send_ring_cq *cq)\n{\n\tvoid *in, *sqc, *wq;\n\
  \tint inlen, err;\n\tu8 ts_format;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_sq_in) +\n\
  \t\tsizeof(u64) * sq->wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\
  \tif (!in)\n\t\treturn -ENOMEM;\n\n\tsqc = MLX5_ADDR_OF(create_sq_in, in, ctx);\n\
  \twq = MLX5_ADDR_OF(sqc, sqc, wq);\n\n\tmemcpy(sqc, sqc_data, MLX5_ST_SZ_BYTES(sqc));\n\
  \tMLX5_SET(sqc, sqc, cqn, cq->mcq.cqn);\n\n\tMLX5_SET(sqc, sqc, state, MLX5_SQC_STATE_RST);\n\
  \tMLX5_SET(sqc, sqc, flush_in_error_en, 1);\n\n\tts_format = mlx5_is_real_time_sq(mdev)\
  \ ? MLX5_TIMESTAMP_FORMAT_REAL_TIME :\n\t\t\t\t\t\t MLX5_TIMESTAMP_FORMAT_FREE_RUNNING;\n\
  \tMLX5_SET(sqc, sqc, ts_format, ts_format);\n\n\tMLX5_SET(wq, wq, wq_type, MLX5_WQ_TYPE_CYCLIC);\n\
  \tMLX5_SET(wq, wq, uar_page, mdev->mlx5e_res.hw_objs.bfreg.index);\n\tMLX5_SET(wq,\
  \ wq, log_wq_pg_sz, sq->wq_ctrl.buf.page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(wq,\
  \ wq, dbr_addr, sq->wq_ctrl.db.dma);\n\n\tmlx5_fill_page_frag_array(&sq->wq_ctrl.buf,\n\
  \t\t\t\t  (__be64 *)MLX5_ADDR_OF(wq, wq, pas));\n\n\terr = mlx5_core_create_sq(mdev,\
  \ in, inlen, &sq->sqn);\n\n\tkvfree(in);\n\n\treturn err;\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\
  \ b/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\nindex a1adbb48735c..0c7989184c30\
  \ 100644\n--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\n\
  +++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\n@@ -653,6\
  \ +653,12 @@ static int hws_send_ring_create_sq(struct mlx5_core_dev *mdev, u32\
  \ pdn,\n \treturn err;\n }\n \n+static void hws_send_ring_destroy_sq(struct mlx5_core_dev\
  \ *mdev,\n+\t\t\t\t     struct mlx5hws_send_ring_sq *sq)\n+{\n+\tmlx5_core_destroy_sq(mdev,\
  \ sq->sqn);\n+}\n+\n static int hws_send_ring_set_sq_rdy(struct mlx5_core_dev *mdev,\
  \ u32 sqn)\n {\n \tvoid *in, *sqc;\n@@ -696,7 +702,7 @@ static int hws_send_ring_create_sq_rdy(struct\
  \ mlx5_core_dev *mdev, u32 pdn,\n \n \terr = hws_send_ring_set_sq_rdy(mdev, sq->sqn);\n\
  \ \tif (err)\n-\t\thws_send_ring_close_sq(sq);\n+\t\thws_send_ring_destroy_sq(mdev,\
  \ sq);\n \n \treturn err;\n }\n```\n"
pattern: '## Bug Pattern


  Using a full teardown/close routine in a mid-initialization error path, instead
  of rolling back only the step that just succeeded. Specifically, after creating
  a hardware SQ but failing to transition it to ready, the code called a "close" helper
  that frees software resources (e.g., WQ buffers, private structs) that are also
  freed later by the higher-level error cleanup, causing double free. The correct
  pattern is to call the matching hardware destroy function (mlx5_core_destroy_sq)
  for that partial state, not the full close routine.'
plan: "Plan\n\n1) Program state\n- REGISTER_MAP_WITH_PROGRAMSTATE(SQPendingRdyMap,\
  \ const MemRegion*, const MemRegion*)\n  - Key: sq region (struct mlx5hws_send_ring_sq\
  \ *).\n  - Value: mdev region (struct mlx5_core_dev *).\n  - Meaning: set_sq_rdy\
  \ was just invoked for this SQ; on failure the proper rollback is destroy, not close.\n\
  - REGISTER_MAP_WITH_PROGRAMSTATE(RetSymToSQMap, SymbolRef, const MemRegion*)\n \
  \ - Map the symbolic return value of hws_send_ring_set_sq_rdy to the corresponding\
  \ SQ region.\n  - Used to connect \u201Cerr\u201D-like variables to the specific\
  \ SQ.\n- REGISTER_MAP_WITH_PROGRAMSTATE(ErrVarToSQMap, const MemRegion*, const MemRegion*)\n\
  \  - Key: region of the variable that stores the return of set_sq_rdy (e.g., \u2018\
  err\u2019).\n  - Value: the SQ region connected to that return.\n\n2) Targeted functions\
  \ and how to recognize arguments\n- Set-ready function: \u201Chws_send_ring_set_sq_rdy(mdev,\
  \ sqn)\u201D\n  - From CallEvent, check callee name equals \"hws_send_ring_set_sq_rdy\"\
  .\n  - Extract mdev region from arg[0] using getMemRegionFromExpr.\n  - Extract\
  \ SQ region from arg[1] by finding a MemberExpr for \u201Csqn\u201D and retrieving\
  \ its base (the \u2018sq\u2019 expression). Use:\n    - const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(Call.getArgExpr(1));\n\
  \    - Ensure ME->getMemberDecl()->getNameAsString() == \"sqn\".\n    - Let Base\
  \ = ME->getBase()->IgnoreImpCasts(); get sq region via getMemRegionFromExpr(Base,\
  \ C).\n- \u201Cclose\u201D function: \u201Chws_send_ring_close_sq(sq)\u201D\n  -\
  \ Callee name equals \"hws_send_ring_close_sq\".\n  - SQ region is arg[0] via getMemRegionFromExpr.\n\
  - \u201Cdestroy\u201D functions (to avoid false positives/for cleanup if desired):\n\
  \  - \"hws_send_ring_destroy_sq(mdev, sq)\" (preferred and present in the fix)\n\
  \    - SQ region is arg[1].\n    - mdev region is arg[0].\n  - \u201Cmlx5_core_destroy_sq(mdev,\
  \ sqn)\u201D exists but uses sqn, not sq pointer; we do not rely on it in this checker.\n\
  \n3) Callback selection and implementation details\n\nA) checkPostCall\n- Purpose:\
  \ When we call hws_send_ring_set_sq_rdy, record which SQ is being transitioned,\
  \ and map its returned error symbol to the SQ.\n- Steps:\n  1) If callee is \"hws_send_ring_set_sq_rdy\"\
  :\n     - Extract mdev region from arg[0].\n     - Extract sq region from arg[1]\
  \ by locating MemberExpr \u201Csqn\u201D and taking its base.\n     - Insert SQPendingRdyMap[sqRegion]\
  \ = mdevRegion.\n     - Obtain the symbolic return value: SVal Ret = Call.getReturnValue();\
  \ if SymbolRef Sym = Ret.getAsSymbol():\n       - Insert RetSymToSQMap[Sym] = sqRegion.\n\
  \nB) checkBind\n- Purpose: Connect the \u201Cerr\u201D-like LHS variable to the\
  \ SQ for which set_sq_rdy just returned.\n- Steps:\n  1) If Val is a nonconcrete\
  \ SVal with SymbolRef Sym, and RetSymToSQMap contains Sym:\n     - Let LHSRegion\
  \ = Loc.getAsRegion(); if null, skip.\n     - Let SQRegion = RetSymToSQMap[Sym].\n\
  \     - Insert ErrVarToSQMap[LHSRegion] = SQRegion.\n     - Erase RetSymToSQMap[Sym]\
  \ (consumed).\n\nC) checkPreCall\n- Purpose: Detect the misuse: calling the full\
  \ close routine in the immediate error path of set_sq_rdy.\n- Steps:\n  1) If callee\
  \ is \"hws_send_ring_close_sq\":\n     - Extract sq region from arg[0]; if null,\
  \ return.\n     - Check that SQPendingRdyMap contains sq region; if not present,\
  \ return (not the mid-initialization case).\n     - Find the nearest IfStmt parent\
  \ of this call: const IfStmt *IfP = findSpecificTypeInParents<IfStmt>(CallExpr or\
  \ S, C). If null, return (we only warn inside an error branch).\n     - From IfP->getCond(),\
  \ find DeclRefExpr representing the condition variable (the typical \u2018err\u2019\
  ). Use findSpecificTypeInChildren<DeclRefExpr>(IfP->getCond()) to get a DeclRefExpr;\
  \ if none, return.\n     - Get the MemRegion of that DeclRefExpr via getMemRegionFromExpr;\
  \ call it CondVarRegion; if null, return.\n     - If ErrVarToSQMap[CondVarRegion]\
  \ == sq region, we are in the error branch tied to the result of set_sq_rdy on this\
  \ SQ. This is the buggy pattern.\n       - Report a bug:\n         - Message: \"\
  Use destroy for partially initialized SQ; 'close' here may double free.\"\n    \
  \     - Create error node: auto N = C.generateNonFatalErrorNode(); then emit std::make_unique<PathSensitiveBugReport>(...).\n\
  \       - Optionally, remove SQPendingRdyMap[sq] to avoid duplicate warnings along\
  \ this path.\n  2) If callee is \"hws_send_ring_destroy_sq\":\n     - It\u2019s\
  \ the correct cleanup. Optionally clear SQPendingRdyMap for arg[1] SQ region to\
  \ keep state tidy.\n\nD) checkBranchCondition (optional refinement, keep simple)\n\
  - Not strictly required if we detect the IfStmt parent in checkPreCall. We can omit\
  \ this to keep the checker simple.\n\nE) checkEndFunction\n- Clean up all program\
  \ state maps (CSA will discard with the context; no explicit action required).\n\
  \n4) Heuristics to reduce false positives\n- Only warn if:\n  - A corresponding\
  \ hws_send_ring_set_sq_rdy happened (SQPendingRdyMap contains the SQ region).\n\
  \  - The close call is inside an IfStmt branch whose condition variable is mapped\
  \ in ErrVarToSQMap to the same SQ (ensures it\u2019s an immediate error path for\
  \ that specific call).\n- Do not warn on destroy calls.\n- Do not attempt to match\
  \ mlx5_core_destroy_sq since it takes sqn; the checker\u2019s goal is to catch the\
  \ \u201Cclose in error path\u201D misuse.\n\n5) Utility usage\n- findSpecificTypeInChildren<MemberExpr>\
  \ and MemberDecl::getNameAsString() to detect the \u201Csqn\u201D access and recover\
  \ the base \u2018sq\u2019.\n- getMemRegionFromExpr to convert expressions (mdev,\
  \ sq, error variable) to MemRegion keys.\n- findSpecificTypeInParents<IfStmt> to\
  \ locate the enclosing if of the cleanup call.\n- ExprHasName is not necessary if\
  \ you extract DeclRefExpr and MemRegions directly.\n\n6) Reporting\n- Use a concise\
  \ message:\n  - Title: \"Wrong cleanup in error path\"\n  - Description: \"Use destroy\
  \ for partially initialized SQ; 'close' here may double free.\"\n- Emit via PathSensitiveBugReport\
  \ with generateNonFatalErrorNode."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include <memory>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// Program states:\n// - SQPendingRdyMap: sq region -> mdev region,\
  \ indicates set_sq_rdy was just invoked for this SQ.\n// - RetSymToSQMap: return\
  \ SymbolRef of set_sq_rdy -> sq region.\n// - ErrVarToSQMap: region of variable\
  \ storing the return of set_sq_rdy (e.g., 'err') -> sq region.\nREGISTER_MAP_WITH_PROGRAMSTATE(SQPendingRdyMap,\
  \ const MemRegion*, const MemRegion*)\nREGISTER_MAP_WITH_PROGRAMSTATE(RetSymToSQMap,\
  \ SymbolRef, const MemRegion*)\nREGISTER_MAP_WITH_PROGRAMSTATE(ErrVarToSQMap, const\
  \ MemRegion*, const MemRegion*)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public\
  \ Checker<\n        check::PostCall,\n        check::PreCall,\n        check::Bind>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker() :\
  \ BT(new BugType(this, \"Wrong cleanup in error path\", \"Memory Management\"))\
  \ {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n  void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n\
  \  static bool isCallNamed(const CallEvent &Call, StringRef Name, CheckerContext\
  \ &C);\n\n  const MemRegion *getBaseRegionFromExpr(const Expr *E, CheckerContext\
  \ &C) const;\n\n  // Extract the SQ region from the 2nd argument of hws_send_ring_set_sq_rdy(...,\
  \ sq->sqn)\n  const MemRegion *extractSQRegionFromSetRdyArg(const CallEvent &Call,\
  \ CheckerContext &C) const;\n\n  void reportWrongCleanup(const CallEvent &Call,\
  \ CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isCallNamed(const CallEvent\
  \ &Call, StringRef Name, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  return ExprHasName(Origin, Name, C);\n}\n\n\
  const MemRegion *SAGenTestChecker::getBaseRegionFromExpr(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E)\n    return nullptr;\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR)\n    return nullptr;\n  return MR->getBaseRegion();\n}\n\nconst\
  \ MemRegion *SAGenTestChecker::extractSQRegionFromSetRdyArg(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  if (Call.getNumArgs() < 2)\n    return nullptr;\n\
  \n  const Expr *Arg1 = Call.getArgExpr(1);\n  if (!Arg1)\n    return nullptr;\n\n\
  \  // We expect something like sq->sqn; find MemberExpr named \"sqn\", then get\
  \ its base (the 'sq')\n  const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(Arg1);\n\
  \  if (!ME)\n    return nullptr;\n\n  const ValueDecl *MD = ME->getMemberDecl();\n\
  \  if (!MD)\n    return nullptr;\n\n  if (MD->getName() != \"sqn\")\n    return\
  \ nullptr;\n\n  const Expr *Base = ME->getBase();\n  if (!Base)\n    return nullptr;\n\
  \n  return getBaseRegionFromExpr(Base, C);\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Track hws_send_ring_set_sq_rdy(mdev, sq->sqn)\n  if (isCallNamed(Call, \"\
  hws_send_ring_set_sq_rdy\", C)) {\n    // mdev region from arg[0]\n    const Expr\
  \ *Arg0 = Call.getArgExpr(0);\n    const MemRegion *MdevReg = getBaseRegionFromExpr(Arg0,\
  \ C);\n    if (!MdevReg)\n      return;\n\n    // sq region derived from arg[1]\n\
  \    const MemRegion *SQReg = extractSQRegionFromSetRdyArg(Call, C);\n    if (!SQReg)\n\
  \      return;\n\n    // Record that this SQ is pending ready, paired with its mdev\n\
  \    State = State->set<SQPendingRdyMap>(SQReg, MdevReg);\n\n    // Map the return\
  \ symbol to the SQ\n    SVal Ret = Call.getReturnValue();\n    if (SymbolRef Sym\
  \ = Ret.getAsSymbol()) {\n      State = State->set<RetSymToSQMap>(Sym, SQReg);\n\
  \    }\n\n    C.addTransition(State);\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\n\
  \    return;\n  LHSReg = LHSReg->getBaseRegion();\n  if (!LHSReg)\n    return;\n\
  \n  if (SymbolRef Sym = Val.getAsSymbol()) {\n    if (const MemRegion *const *SQRegPtr\
  \ = State->get<RetSymToSQMap>(Sym)) {\n      const MemRegion *SQReg = *SQRegPtr;\n\
  \      // Bind err-like variable region to the SQ region\n      State = State->set<ErrVarToSQMap>(LHSReg,\
  \ SQReg);\n      // Consume the return symbol mapping\n      State = State->remove<RetSymToSQMap>(Sym);\n\
  \      C.addTransition(State);\n    }\n  }\n}\n\nvoid SAGenTestChecker::reportWrongCleanup(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Use destroy for partially initialized SQ; 'close' here may double\
  \ free.\", N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n\n  // Correct cleanup: hws_send_ring_destroy_sq(mdev,\
  \ sq)\n  if (isCallNamed(Call, \"hws_send_ring_destroy_sq\", C)) {\n    if (Call.getNumArgs()\
  \ >= 2) {\n      const Expr *Arg1 = Call.getArgExpr(1);\n      if (const MemRegion\
  \ *SQReg = getBaseRegionFromExpr(Arg1, C)) {\n        // Cleanup: no need to warn,\
  \ remove pending state if exists.\n        if (State->get<SQPendingRdyMap>(SQReg))\
  \ {\n          State = State->remove<SQPendingRdyMap>(SQReg);\n          C.addTransition(State);\n\
  \        }\n      }\n    }\n    return;\n  }\n\n  // Misuse we want to catch: hws_send_ring_close_sq(sq)\
  \ inside error branch after set_sq_rdy\n  if (isCallNamed(Call, \"hws_send_ring_close_sq\"\
  , C)) {\n    if (Call.getNumArgs() < 1)\n      return;\n\n    // Extract SQ region\
  \ from arg[0]\n    const Expr *Arg0 = Call.getArgExpr(0);\n    const MemRegion *SQReg\
  \ = getBaseRegionFromExpr(Arg0, C);\n    if (!SQReg)\n      return;\n\n    // Only\
  \ consider SQs that are in \"pending ready\" state\n    const MemRegion *const *MdevRegPtr\
  \ = State->get<SQPendingRdyMap>(SQReg);\n    if (!MdevRegPtr)\n      return;\n \
  \   const MemRegion *MdevReg = *MdevRegPtr;\n    (void)MdevReg; // MdevReg is not\
  \ used further, keep semantics explicit.\n\n    // Find nearest IfStmt containing\
  \ this call: ensure it's in an error branch\n    const Expr *Origin = Call.getOriginExpr();\n\
  \    if (!Origin)\n      return;\n\n    const IfStmt *IfP = findSpecificTypeInParents<IfStmt>(Origin,\
  \ C);\n    if (!IfP)\n      return;\n\n    // Heuristic: find a DeclRefExpr in condition\
  \ (e.g., 'err')\n    const Expr *CondE = IfP->getCond();\n    if (!CondE)\n    \
  \  return;\n\n    const DeclRefExpr *DRE = findSpecificTypeInChildren<DeclRefExpr>(CondE);\n\
  \    if (!DRE)\n      return;\n\n    const Expr *CondVarE = DRE;\n    const MemRegion\
  \ *CondVarReg = getBaseRegionFromExpr(CondVarE, C);\n    if (!CondVarReg)\n    \
  \  return;\n\n    // Check if this condition var is mapped to the same SQ (from\
  \ set_sq_rdy result)\n    const MemRegion *const *MappedSQPtr = State->get<ErrVarToSQMap>(CondVarReg);\n\
  \    if (!MappedSQPtr)\n      return;\n    const MemRegion *MappedSQ = *MappedSQPtr;\n\
  \n    if (MappedSQ == SQReg) {\n      // This is exactly the misuse we target.\n\
  \      reportWrongCleanup(Call, C);\n      // Avoid duplicate reports along this\
  \ path\n      State = State->remove<SQPendingRdyMap>(SQReg);\n      C.addTransition(State);\n\
  \    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects using close() instead of destroy() in the error path after set_sq_rdy,\
  \ which may double free\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
