_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: d313eb8b77557a6d5855f42d2234bd592c7b50dd
commit_type: Uninit-Data
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/APInt.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\nREGISTER_SET_WITH_PROGRAMSTATE(ZeroedStructSet,\
  \ const MemRegion *)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PostCall,\
  \ check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n   \
  \   SAGenTestChecker() : BT(new BugType(this, \"Kernel information leak\", \"Security\"\
  )) {}\n\n      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n  \
  \ private:\n\n      // Helpers\n      bool isFuncNamed(const CallEvent &Call, CheckerContext\
  \ &C, StringRef Name) const;\n      bool extractAddrOfLocalRecordVar(const Expr\
  \ *E, const VarDecl *&VD) const;\n      bool sizeMatchesWholeObject(const Expr *SizeE,\
  \ const VarDecl *VD, CheckerContext &C) const;\n      bool isZeroValueExpr(const\
  \ Expr *E, CheckerContext &C) const;\n      void recordWholeObjectZeroing(const\
  \ CallEvent &Call, CheckerContext &C,\n                                    unsigned\
  \ DstIdx, unsigned SizeIdx) const;\n      bool matchSink(const CallEvent &Call,\
  \ CheckerContext &C,\n                     unsigned &LenIdx, unsigned &DataIdx)\
  \ const;\n      void reportLeak(const CallEvent &Call, CheckerContext &C) const;\n\
  };\n\n// Check function name using source text of the origin expression.\nbool SAGenTestChecker::isFuncNamed(const\
  \ CallEvent &Call, CheckerContext &C, StringRef Name) const {\n  const Expr *OriginExpr\
  \ = Call.getOriginExpr();\n  if (!OriginExpr)\n    return false;\n  return ExprHasName(OriginExpr,\
  \ Name, C);\n}\n\nbool SAGenTestChecker::extractAddrOfLocalRecordVar(const Expr\
  \ *E, const VarDecl *&VD) const {\n  if (!E)\n    return false;\n  E = E->IgnoreParenCasts();\n\
  \  const auto *UO = dyn_cast<UnaryOperator>(E);\n  if (!UO || UO->getOpcode() !=\
  \ UO_AddrOf)\n    return false;\n\n  const Expr *Sub = UO->getSubExpr();\n  if (!Sub)\n\
  \    return false;\n  Sub = Sub->IgnoreParenCasts();\n\n  const auto *DRE = dyn_cast<DeclRefExpr>(Sub);\n\
  \  if (!DRE)\n    return false;\n\n  VD = dyn_cast<VarDecl>(DRE->getDecl());\n \
  \ if (!VD)\n    return false;\n\n  QualType T = VD->getType();\n  if (T.isNull()\
  \ || !T->isRecordType())\n    return false;\n\n  if (!VD->hasLocalStorage() || VD->hasGlobalStorage())\n\
  \    return false;\n\n  return true;\n}\n\nbool SAGenTestChecker::isZeroValueExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n  llvm::APSInt\
  \ Val;\n  if (EvaluateExprToInt(Val, E, C)) {\n    return Val.isZero();\n  }\n \
  \ return false;\n}\n\nbool SAGenTestChecker::sizeMatchesWholeObject(const Expr *SizeE,\
  \ const VarDecl *VD,\n                                              CheckerContext\
  \ &C) const {\n  if (!SizeE || !VD)\n    return false;\n\n  // Prefer sizeof-based\
  \ check.\n  if (const auto *UETT = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(SizeE))\
  \ {\n    if (UETT->getKind() == UETT_SizeOf) {\n      if (UETT->isArgumentType())\
  \ {\n        QualType ArgTy = UETT->getArgumentType();\n        if (!ArgTy.isNull())\
  \ {\n          if (C.getASTContext().hasSameType(ArgTy.getUnqualifiedType(),\n \
  \                                           VD->getType().getUnqualifiedType()))\n\
  \            return true;\n        }\n      } else {\n        const Expr *Arg =\
  \ UETT->getArgumentExpr();\n        if (Arg) {\n          Arg = Arg->IgnoreParenCasts();\n\
  \          if (const auto *DRE = dyn_cast<DeclRefExpr>(Arg)) {\n            if (DRE->getDecl()\
  \ == VD)\n              return true;\n          }\n        }\n      }\n    }\n \
  \ }\n\n  // Fallback: constant value equals sizeof(VD->getType())\n  llvm::APSInt\
  \ Val;\n  if (EvaluateExprToInt(Val, SizeE, C)) {\n    uint64_t ObjSizeBytes =\n\
  \        C.getASTContext().getTypeSizeInChars(VD->getType()).getQuantity();\n  \
  \  return Val.isNonNegative() && Val.getZExtValue() == ObjSizeBytes;\n  }\n\n  return\
  \ false;\n}\n\nvoid SAGenTestChecker::recordWholeObjectZeroing(const CallEvent &Call,\
  \ CheckerContext &C,\n                                                unsigned DstIdx,\
  \ unsigned SizeIdx) const {\n  if (Call.getNumArgs() <= std::max(DstIdx, SizeIdx))\n\
  \    return;\n\n  const Expr *DstExpr = Call.getArgExpr(DstIdx);\n  const Expr *SizeExpr\
  \ = Call.getArgExpr(SizeIdx);\n  if (!DstExpr || !SizeExpr)\n    return;\n\n  //\
  \ Ensure the destination is &Var where Var is a local record.\n  const VarDecl *VD\
  \ = nullptr;\n  if (!extractAddrOfLocalRecordVar(DstExpr, VD))\n    return;\n\n\
  \  // Ensure size equals the whole object size.\n  if (!sizeMatchesWholeObject(SizeExpr,\
  \ VD, C))\n    return;\n\n  // Get the region from the original expression (without\
  \ stripping) and add base region to the set.\n  const MemRegion *MR = getMemRegionFromExpr(DstExpr,\
  \ C);\n  if (!MR)\n    return;\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n  State = State->add<ZeroedStructSet>(MR);\n\
  \  C.addTransition(State);\n}\n\nbool SAGenTestChecker::matchSink(const CallEvent\
  \ &Call, CheckerContext &C,\n                                 unsigned &LenIdx,\
  \ unsigned &DataIdx) const {\n  struct SinkInfo {\n    StringRef Name;\n    unsigned\
  \ LenIndex;\n    unsigned DataIndex;\n  };\n  static const SinkInfo Sinks[] = {\n\
  \      {\"nla_put\", 2u, 3u},\n      {\"nla_put_64bit\", 2u, 3u},\n  };\n\n  for\
  \ (const auto &S : Sinks) {\n    if (isFuncNamed(Call, C, S.Name)) {\n      LenIdx\
  \ = S.LenIndex;\n      DataIdx = S.DataIndex;\n      return true;\n    }\n  }\n\
  \  return false;\n}\n\nvoid SAGenTestChecker::reportLeak(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"stack struct not fully zeroed before user copy (padding leak)\", N);\n\
  \  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  // Detect whole-object zeroing calls.\n  // memset(dst, 0, size)\n  if (isFuncNamed(Call,\
  \ C, \"memset\") || isFuncNamed(Call, C, \"__builtin_memset\")) {\n    if (Call.getNumArgs()\
  \ >= 3) {\n      const Expr *ValExpr = Call.getArgExpr(1);\n      if (isZeroValueExpr(ValExpr,\
  \ C)) {\n        recordWholeObjectZeroing(Call, C, /*DstIdx=*/0, /*SizeIdx=*/2);\n\
  \      }\n    }\n    return;\n  }\n\n  // memzero_explicit(dst, size) or bpf_memzero(dst,\
  \ size)\n  if (isFuncNamed(Call, C, \"memzero_explicit\") || isFuncNamed(Call, C,\
  \ \"bpf_memzero\")) {\n    if (Call.getNumArgs() >= 2) {\n      recordWholeObjectZeroing(Call,\
  \ C, /*DstIdx=*/0, /*SizeIdx=*/1);\n    }\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // Detect sinks that export raw\
  \ bytes to user space, e.g., nla_put*\n  unsigned LenIdx = 0, DataIdx = 0;\n  if\
  \ (!matchSink(Call, C, LenIdx, DataIdx))\n    return;\n\n  if (Call.getNumArgs()\
  \ <= std::max(LenIdx, DataIdx))\n    return;\n\n  const Expr *DataExpr = Call.getArgExpr(DataIdx);\n\
  \  const Expr *LenExpr = Call.getArgExpr(LenIdx);\n  if (!DataExpr || !LenExpr)\n\
  \    return;\n\n  // Ensure data is &Var where Var is a local record.\n  const VarDecl\
  \ *VD = nullptr;\n  if (!extractAddrOfLocalRecordVar(DataExpr, VD))\n    return;\n\
  \n  // Ensure length equals sizeof(Var) to match the risky pattern.\n  if (!sizeMatchesWholeObject(LenExpr,\
  \ VD, C))\n    return;\n\n  // Get the MemRegion for the data argument and check\
  \ if it was fully zeroed.\n  const MemRegion *MR = getMemRegionFromExpr(DataExpr,\
  \ C);\n  if (!MR)\n    return;\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n  if (!State->contains<ZeroedStructSet>(MR))\
  \ {\n    reportLeak(Call, C);\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects copying partially initialized\
  \ stack structs with sizeof(struct) to user (padding leak)\",\n      \"\");\n}\n\
  \nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/sched: act_skbmod: prevent kernel-infoleak\n\n\
  syzbot found that tcf_skbmod_dump() was copying four bytes\nfrom kernel stack to\
  \ user space [1].\n\nThe issue here is that 'struct tc_skbmod' has a four bytes\
  \ hole.\n\nWe need to clear the structure before filling fields.\n\n[1]\nBUG: KMSAN:\
  \ kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in copy_to_user_iter lib/iov_iter.c:24 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_and_advance2 include/linux/iov_iter.h:245\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in iterate_and_advance include/linux/iov_iter.h:271\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n  copy_to_user_iter\
  \ lib/iov_iter.c:24 [inline]\n  iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \  iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\n  iterate_and_advance\
  \ include/linux/iov_iter.h:271 [inline]\n  _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  copy_to_iter include/linux/uio.h:196 [inline]\n  simple_copy_to_iter net/core/datagram.c:532\
  \ [inline]\n  __skb_datagram_iter+0x185/0x1000 net/core/datagram.c:420\n  skb_copy_datagram_iter+0x5c/0x200\
  \ net/core/datagram.c:546\n  skb_copy_datagram_msg include/linux/skbuff.h:4050 [inline]\n\
  \  netlink_recvmsg+0x432/0x1610 net/netlink/af_netlink.c:1962\n  sock_recvmsg_nosec\
  \ net/socket.c:1046 [inline]\n  sock_recvmsg+0x2c4/0x340 net/socket.c:1068\n  __sys_recvfrom+0x35a/0x5f0\
  \ net/socket.c:2242\n  __do_sys_recvfrom net/socket.c:2260 [inline]\n  __se_sys_recvfrom\
  \ net/socket.c:2256 [inline]\n  __x64_sys_recvfrom+0x126/0x1d0 net/socket.c:2256\n\
  \ do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nUninit\
  \ was stored to memory at:\n  pskb_expand_head+0x30f/0x19d0 net/core/skbuff.c:2253\n\
  \  netlink_trim+0x2c2/0x330 net/netlink/af_netlink.c:1317\n  netlink_unicast+0x9f/0x1260\
  \ net/netlink/af_netlink.c:1351\n  nlmsg_unicast include/net/netlink.h:1144 [inline]\n\
  \  nlmsg_notify+0x21d/0x2f0 net/netlink/af_netlink.c:2610\n  rtnetlink_send+0x73/0x90\
  \ net/core/rtnetlink.c:741\n  rtnetlink_maybe_send include/linux/rtnetlink.h:17\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2048 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x146e/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nUninit was stored to memory at:\n  __nla_put lib/nlattr.c:1041 [inline]\n  nla_put+0x1c6/0x230\
  \ lib/nlattr.c:1099\n  tcf_skbmod_dump+0x23f/0xc20 net/sched/act_skbmod.c:256\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n  tcf_action_dump+0x1fd/0x460 net/sched/act_api.c:1251\n\
  \  tca_get_fill+0x519/0x7a0 net/sched/act_api.c:1628\n  tcf_add_notify_msg net/sched/act_api.c:2023\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2042 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x1365/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nLocal variable opt created at:\n  tcf_skbmod_dump+0x9d/0xc20 net/sched/act_skbmod.c:244\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n\nBytes 188-191 of 248 are uninitialized\nMemory access\
  \ of size 248 starts at ffff888117697680\nData copied to user address 00007ffe56d855f0\n\
  \nFixes: 86da71b57383 (\"net_sched: Introduce skbmod action\")\nSigned-off-by: Eric\
  \ Dumazet <edumazet@google.com>\nAcked-by: Jamal Hadi Salim <jhs@mojatatu.com>\n\
  Link: https://lore.kernel.org/r/20240403130908.93421-1-edumazet@google.com\nSigned-off-by:\
  \ Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: tcf_skbmod_dump\
  \ in net/sched/act_skbmod.c\nstatic int tcf_skbmod_dump(struct sk_buff *skb, struct\
  \ tc_action *a,\n\t\t\t   int bind, int ref)\n{\n\tstruct tcf_skbmod *d = to_skbmod(a);\n\
  \tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_skbmod_params  *p;\n\t\
  struct tc_skbmod opt = {\n\t\t.index   = d->tcf_index,\n\t\t.refcnt  = refcount_read(&d->tcf_refcnt)\
  \ - ref,\n\t\t.bindcnt = atomic_read(&d->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t\
  \ t;\n\n\tspin_lock_bh(&d->tcf_lock);\n\topt.action = d->tcf_action;\n\tp = rcu_dereference_protected(d->skbmod_p,\n\
  \t\t\t\t      lockdep_is_held(&d->tcf_lock));\n\topt.flags  = p->flags;\n\tif (nla_put(skb,\
  \ TCA_SKBMOD_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_DMAC) &&\n\t    nla_put(skb, TCA_SKBMOD_DMAC, ETH_ALEN, p->eth_dst))\n\
  \t\tgoto nla_put_failure;\n\tif ((p->flags & SKBMOD_F_SMAC) &&\n\t    nla_put(skb,\
  \ TCA_SKBMOD_SMAC, ETH_ALEN, p->eth_src))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_ETYPE) &&\n\t    nla_put_u16(skb, TCA_SKBMOD_ETYPE, ntohs(p->eth_type)))\n\
  \t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &d->tcf_tm);\n\tif (nla_put_64bit(skb,\
  \ TCA_SKBMOD_TM, sizeof(t), &t, TCA_SKBMOD_PAD))\n\t\tgoto nla_put_failure;\n\n\t\
  spin_unlock_bh(&d->tcf_lock);\n\treturn skb->len;\nnla_put_failure:\n\tspin_unlock_bh(&d->tcf_lock);\n\
  \tnlmsg_trim(skb, b);\n\treturn -1;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff\
  \ --git a/net/sched/act_skbmod.c b/net/sched/act_skbmod.c\nindex 39945b139c48..cd0accaf844a\
  \ 100644\n--- a/net/sched/act_skbmod.c\n+++ b/net/sched/act_skbmod.c\n@@ -241,13\
  \ +241,13 @@ static int tcf_skbmod_dump(struct sk_buff *skb, struct tc_action *a,\n\
  \ \tstruct tcf_skbmod *d = to_skbmod(a);\n \tunsigned char *b = skb_tail_pointer(skb);\n\
  \ \tstruct tcf_skbmod_params  *p;\n-\tstruct tc_skbmod opt = {\n-\t\t.index   =\
  \ d->tcf_index,\n-\t\t.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n-\t\t.bindcnt\
  \ = atomic_read(&d->tcf_bindcnt) - bind,\n-\t};\n+\tstruct tc_skbmod opt;\n \tstruct\
  \ tcf_t t;\n \n+\tmemset(&opt, 0, sizeof(opt));\n+\topt.index   = d->tcf_index;\n\
  +\topt.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n+\topt.bindcnt = atomic_read(&d->tcf_bindcnt)\
  \ - bind;\n \tspin_lock_bh(&d->tcf_lock);\n \topt.action = d->tcf_action;\n \tp\
  \ = rcu_dereference_protected(d->skbmod_p,\n```\n"
pattern: '## Bug Pattern


  Partially initialized stack struct (via designated initializers or field-by-field
  assignments) is copied to user space using sizeof(struct), leaking uninitialized
  padding bytes.


  Example pattern:

  struct S { u32 index; u32 refcnt; u32 bindcnt; /* padding/hole exists */ };

  struct S s = { .index = idx, .refcnt = r, .bindcnt = b };  // only members set;
  padding uninitialized

  nla_put(skb, ATTR, sizeof(s), &s);  // copies padding to user (info leak)


  Root cause: struct contains padding and the code does not fully zero the object
  before exporting it; copying sizeof(struct) includes those uninitialized padding
  bytes.'
plan: "1) Program state\n\n- REGISTER_SET_WITH_PROGRAMSTATE(ZeroedStructSet, const\
  \ MemRegion *)\n  - Tracks stack struct objects that have been fully zeroed (i.e.,\
  \ the entire object storage is cleared) before being copied out.\n  - We only add\
  \ a region to this set when we see an explicit whole-object zeroing like memset(&s,\
  \ 0, sizeof(s)) or memzero_explicit(&s, sizeof(s)).\n\nRationale: The bug is \u201C\
  padding bytes not initialized.\u201D The simplest and robust criterion is: before\
  \ copying sizeof(struct) bytes to user-visible buffers, the whole struct must be\
  \ zeroed via a memset-like call. We do not attempt to prove member-by-member full\
  \ initialization.\n\n2) Callback functions and implementation steps\n\nA) checkPostCall\
  \ \u2014 record whole-object zeroing\n\nGoal: Mark a stack variable\u2019s region\
  \ as fully zeroed when we detect memset-like patterns that clear the entire object\
  \ storage.\n\n- Detect zeroing functions (callee name match):\n  - \"memset\", \"\
  __builtin_memset\" \u2014 expect 3 params: dst, value, size.\n    - Ensure the second\
  \ param (value) is integer constant 0 using EvaluateExprToInt.\n  - \"memzero_explicit\"\
  , \"bpf_memzero\" \u2014 expect 2 params: dst, size.\n\n- Extract the destination\
  \ object:\n  - From the first argument (dst), strip casts. If it\u2019s UnaryOperator\
  \ \u2018&\u2019 of a DeclRefExpr to a VarDecl of RecordType, accept it.\n  - Confirm\
  \ the VarDecl has automatic local storage (VD->hasLocalStorage() && !VD->hasGlobalStorage())\
  \ to restrict to stack structs.\n  - Retrieve its MemRegion with getMemRegionFromExpr(Call.getArgExpr(0),\
  \ C).\n\n- Check the size argument covers the entire object:\n  - Prefer AST-based:\
  \ findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(sizeExpr) and see if it is\
  \ a sizeof whose argument refers to:\n    - the same variable (sizeof(var)), or\n\
  \    - the exact type of that variable (sizeof(struct S)) matching VD->getType().\n\
  \  - If not found, fallback to numeric check:\n    - EvaluateExprToInt(sizeExpr,\
  \ ...) and compare to the object size in bytes:\n      C.getASTContext().getTypeSizeInChars(VD->getType()).getQuantity()\n\
  \n- If all checks pass, add the object\u2019s region to ZeroedStructSet.\n\nNotes:\n\
  - Ignore cases where dst is not \u201C&VarDecl\u201D of a RecordType (e.g., heap\
  \ or field addresses). This keeps the checker simple and focused.\n- Ignore partial\
  \ sizes or non-zero memset values.\n\nB) checkPreCall \u2014 detect copy-to-user/netlink\
  \ sinks that export the struct\n\nGoal: Warn when a stack struct\u2019s address\
  \ is passed to a sink together with a size equal to sizeof(the struct), but the\
  \ struct\u2019s region is not in ZeroedStructSet.\n\n- Define a small table of known\
  \ sinks that copy raw bytes out of kernel (netlink helpers):\n  - KnownSink { \"\
  nla_put\", LenIndex=2, DataIndex=3 }\n  - KnownSink { \"nla_put_64bit\", LenIndex=2,\
  \ DataIndex=3 }\n  (You can easily add more if needed, e.g. other nla_put variants.\
  \ Start minimal to avoid false positives.)\n\n- For a matching sink:\n  - Extract\
  \ the data argument (DataIndex). Expect \"&var\" where var is a local VarDecl of\
  \ RecordType.\n    - Strip casts; check UnaryOperator \u2018&\u2019 -> DeclRefExpr\
  \ -> VarDecl.\n    - Confirm local storage as above.\n    - Obtain its MemRegion.\n\
  \  - Extract the length argument (LenIndex) and ensure it equals sizeof(var):\n\
  \    - Prefer AST-based: if len has a sizeof on the same variable expression (sizeof(var))\
  \ or on the same record type.\n    - Else, EvaluateExprToInt and compare to the\
  \ size of var\u2019s type in bytes.\n\n- If the region is not present in ZeroedStructSet:\n\
  \  - Report a bug at the call site:\n    - Message: \"stack struct not fully zeroed\
  \ before user copy (padding leak)\"\n    - Create a PathSensitiveBugReport from\
  \ a non-fatal error node.\n\nNotes:\n- This mirrors the buggy pattern: struct on\
  \ stack, only some fields set, then nla_put(..., sizeof(struct), &struct). Without\
  \ prior full memset-like zeroing, padding may leak.\n\nC) Optional: checkPostStmt\
  \ (DeclStmt) \u2014 no state needed\n\n- No special handling is required here. We\
  \ don\u2019t try to infer full initialization from initializer lists or field stores.\
  \ The checker remains robust and simple by requiring an explicit full zeroing call\
  \ before the sink.\n\nD) Other callbacks\n\n- Not needed:\n  - checkBind: we don\u2019\
  t track aliases for stack struct addresses (the sink pattern uses &var directly).\n\
  \  - checkLocation / checkBranchCondition / evalAssume / checkRegionChanges: not\
  \ necessary for this pattern.\n  - checkBeginFunction / checkEndFunction: no special\
  \ logic; regions will naturally go out of scope.\n\n3) Helper logic details to keep\
  \ implementation straightforward\n\n- Extracting the VarDecl from an expression\
  \ expected to be \u201C&var\u201D:\n  - E = E->IgnoreImpCasts()\n  - if UnaryOperator\
  \ UO with opcode UO_AddrOf:\n    - Inner = UO->getSubExpr()->IgnoreImpCasts()\n\
  \    - if DeclRefExpr DRE -> VarDecl VD\n- Matching sizeof(var) or sizeof(type):\n\
  \  - Use findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(LenExpr)\n  - If found\
  \ and it is a sizeof:\n    - If it\u2019s sizeof(Expr): check if that Expr is DeclRefExpr\
  \ to the same VarDecl\n    - If it\u2019s sizeof(Type): compare Type with VD->getType()\
  \ (canonical types)\n- Numeric size fallback:\n  - EvaluateExprToInt(LenExpr, ...)\
  \ and compare to sizeof(type) from ASTContext.\n\n4) Reporting\n\n- On unsafe sink\
  \ call, generate a non-fatal error node and emit:\n  - Short message: \"stack struct\
  \ not fully zeroed before user copy (padding leak)\"\n  - Location: the sink call\
  \ expression.\n- No need for custom notes beyond the main message to keep it concise.\n\
  \n5) Summary of the minimal end-to-end flow\n\n- When seeing memset/memzero_explicit\
  \ that fully zeroes &var with the correct size, mark var\u2019s region as zeroed\
  \ in ZeroedStructSet.\n- When encountering nla_put/nla_put_64bit, if length equals\
  \ sizeof(var) and data is &var of a stack RecordType, check ZeroedStructSet:\n \
  \ - If not zeroed, report the leak.\n  - If zeroed, do nothing.\n\nThis plan directly\
  \ targets the kernel-infoleak pattern shown in the patch with minimal state and\
  \ callbacks, using the provided utilities for AST/expr handling and value evaluation."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/APInt.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\nREGISTER_SET_WITH_PROGRAMSTATE(ZeroedStructSet,\
  \ const MemRegion *)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PostCall,\
  \ check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n   \
  \   SAGenTestChecker() : BT(new BugType(this, \"Kernel information leak\", \"Security\"\
  )) {}\n\n      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n  \
  \ private:\n\n      // Helpers\n      bool isFuncNamed(const CallEvent &Call, CheckerContext\
  \ &C, StringRef Name) const;\n      bool extractAddrOfLocalRecordVar(const Expr\
  \ *E, const VarDecl *&VD) const;\n      bool sizeMatchesWholeObject(const Expr *SizeE,\
  \ const VarDecl *VD, CheckerContext &C) const;\n      bool isZeroValueExpr(const\
  \ Expr *E, CheckerContext &C) const;\n      void recordWholeObjectZeroing(const\
  \ CallEvent &Call, CheckerContext &C,\n                                    unsigned\
  \ DstIdx, unsigned SizeIdx) const;\n      bool matchSink(const CallEvent &Call,\
  \ CheckerContext &C,\n                     unsigned &LenIdx, unsigned &DataIdx)\
  \ const;\n      void reportLeak(const CallEvent &Call, CheckerContext &C) const;\n\
  };\n\n// Check function name using source text of the origin expression.\nbool SAGenTestChecker::isFuncNamed(const\
  \ CallEvent &Call, CheckerContext &C, StringRef Name) const {\n  const Expr *OriginExpr\
  \ = Call.getOriginExpr();\n  if (!OriginExpr)\n    return false;\n  return ExprHasName(OriginExpr,\
  \ Name, C);\n}\n\nbool SAGenTestChecker::extractAddrOfLocalRecordVar(const Expr\
  \ *E, const VarDecl *&VD) const {\n  if (!E)\n    return false;\n  E = E->IgnoreParenCasts();\n\
  \  const auto *UO = dyn_cast<UnaryOperator>(E);\n  if (!UO || UO->getOpcode() !=\
  \ UO_AddrOf)\n    return false;\n\n  const Expr *Sub = UO->getSubExpr();\n  if (!Sub)\n\
  \    return false;\n  Sub = Sub->IgnoreParenCasts();\n\n  const auto *DRE = dyn_cast<DeclRefExpr>(Sub);\n\
  \  if (!DRE)\n    return false;\n\n  VD = dyn_cast<VarDecl>(DRE->getDecl());\n \
  \ if (!VD)\n    return false;\n\n  QualType T = VD->getType();\n  if (T.isNull()\
  \ || !T->isRecordType())\n    return false;\n\n  if (!VD->hasLocalStorage() || VD->hasGlobalStorage())\n\
  \    return false;\n\n  return true;\n}\n\nbool SAGenTestChecker::isZeroValueExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n  llvm::APSInt\
  \ Val;\n  if (EvaluateExprToInt(Val, E, C)) {\n    return Val.isZero();\n  }\n \
  \ return false;\n}\n\nbool SAGenTestChecker::sizeMatchesWholeObject(const Expr *SizeE,\
  \ const VarDecl *VD,\n                                              CheckerContext\
  \ &C) const {\n  if (!SizeE || !VD)\n    return false;\n\n  // Prefer sizeof-based\
  \ check.\n  if (const auto *UETT = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(SizeE))\
  \ {\n    if (UETT->getKind() == UETT_SizeOf) {\n      if (UETT->isArgumentType())\
  \ {\n        QualType ArgTy = UETT->getArgumentType();\n        if (!ArgTy.isNull())\
  \ {\n          if (C.getASTContext().hasSameType(ArgTy.getUnqualifiedType(),\n \
  \                                           VD->getType().getUnqualifiedType()))\n\
  \            return true;\n        }\n      } else {\n        const Expr *Arg =\
  \ UETT->getArgumentExpr();\n        if (Arg) {\n          Arg = Arg->IgnoreParenCasts();\n\
  \          if (const auto *DRE = dyn_cast<DeclRefExpr>(Arg)) {\n            if (DRE->getDecl()\
  \ == VD)\n              return true;\n          }\n        }\n      }\n    }\n \
  \ }\n\n  // Fallback: constant value equals sizeof(VD->getType())\n  llvm::APSInt\
  \ Val;\n  if (EvaluateExprToInt(Val, SizeE, C)) {\n    uint64_t ObjSizeBytes =\n\
  \        C.getASTContext().getTypeSizeInChars(VD->getType()).getQuantity();\n  \
  \  return Val.isNonNegative() && Val.getZExtValue() == ObjSizeBytes;\n  }\n\n  return\
  \ false;\n}\n\nvoid SAGenTestChecker::recordWholeObjectZeroing(const CallEvent &Call,\
  \ CheckerContext &C,\n                                                unsigned DstIdx,\
  \ unsigned SizeIdx) const {\n  if (Call.getNumArgs() <= std::max(DstIdx, SizeIdx))\n\
  \    return;\n\n  const Expr *DstExpr = Call.getArgExpr(DstIdx);\n  const Expr *SizeExpr\
  \ = Call.getArgExpr(SizeIdx);\n  if (!DstExpr || !SizeExpr)\n    return;\n\n  //\
  \ Ensure the destination is &Var where Var is a local record.\n  const VarDecl *VD\
  \ = nullptr;\n  if (!extractAddrOfLocalRecordVar(DstExpr, VD))\n    return;\n\n\
  \  // Ensure size equals the whole object size.\n  if (!sizeMatchesWholeObject(SizeExpr,\
  \ VD, C))\n    return;\n\n  // Get the region from the original expression (without\
  \ stripping) and add base region to the set.\n  const MemRegion *MR = getMemRegionFromExpr(DstExpr,\
  \ C);\n  if (!MR)\n    return;\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n  State = State->add<ZeroedStructSet>(MR);\n\
  \  C.addTransition(State);\n}\n\nbool SAGenTestChecker::matchSink(const CallEvent\
  \ &Call, CheckerContext &C,\n                                 unsigned &LenIdx,\
  \ unsigned &DataIdx) const {\n  struct SinkInfo {\n    StringRef Name;\n    unsigned\
  \ LenIndex;\n    unsigned DataIndex;\n  };\n  static const SinkInfo Sinks[] = {\n\
  \      {\"nla_put\", 2u, 3u},\n      {\"nla_put_64bit\", 2u, 3u},\n  };\n\n  for\
  \ (const auto &S : Sinks) {\n    if (isFuncNamed(Call, C, S.Name)) {\n      LenIdx\
  \ = S.LenIndex;\n      DataIdx = S.DataIndex;\n      return true;\n    }\n  }\n\
  \  return false;\n}\n\nvoid SAGenTestChecker::reportLeak(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"stack struct not fully zeroed before user copy (padding leak)\", N);\n\
  \  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  // Detect whole-object zeroing calls.\n  // memset(dst, 0, size)\n  if (isFuncNamed(Call,\
  \ C, \"memset\") || isFuncNamed(Call, C, \"__builtin_memset\")) {\n    if (Call.getNumArgs()\
  \ >= 3) {\n      const Expr *ValExpr = Call.getArgExpr(1);\n      if (isZeroValueExpr(ValExpr,\
  \ C)) {\n        recordWholeObjectZeroing(Call, C, /*DstIdx=*/0, /*SizeIdx=*/2);\n\
  \      }\n    }\n    return;\n  }\n\n  // memzero_explicit(dst, size) or bpf_memzero(dst,\
  \ size)\n  if (isFuncNamed(Call, C, \"memzero_explicit\") || isFuncNamed(Call, C,\
  \ \"bpf_memzero\")) {\n    if (Call.getNumArgs() >= 2) {\n      recordWholeObjectZeroing(Call,\
  \ C, /*DstIdx=*/0, /*SizeIdx=*/1);\n    }\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // Detect sinks that export raw\
  \ bytes to user space, e.g., nla_put*\n  unsigned LenIdx = 0, DataIdx = 0;\n  if\
  \ (!matchSink(Call, C, LenIdx, DataIdx))\n    return;\n\n  if (Call.getNumArgs()\
  \ <= std::max(LenIdx, DataIdx))\n    return;\n\n  const Expr *DataExpr = Call.getArgExpr(DataIdx);\n\
  \  const Expr *LenExpr = Call.getArgExpr(LenIdx);\n  if (!DataExpr || !LenExpr)\n\
  \    return;\n\n  // Ensure data is &Var where Var is a local record.\n  const VarDecl\
  \ *VD = nullptr;\n  if (!extractAddrOfLocalRecordVar(DataExpr, VD))\n    return;\n\
  \n  // Ensure length equals sizeof(Var) to match the risky pattern.\n  if (!sizeMatchesWholeObject(LenExpr,\
  \ VD, C))\n    return;\n\n  // Get the MemRegion for the data argument and check\
  \ if it was fully zeroed.\n  const MemRegion *MR = getMemRegionFromExpr(DataExpr,\
  \ C);\n  if (!MR)\n    return;\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n  if (!State->contains<ZeroedStructSet>(MR))\
  \ {\n    reportLeak(Call, C);\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects copying partially initialized\
  \ stack structs with sizeof(struct) to user (padding leak)\",\n      \"\");\n}\n\
  \nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
