_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3b0daecfeac0103aba8b293df07a0cbaf8b43f29
commit_type: Integer-Overflow
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No program state customization needed.\nnamespace {\n/* The checker callbacks\
  \ are to be decided. */\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Allocator integer overflow risk\", \"Memory\")) {}\n\n\
  \      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n  \
  \ private:\n\n      // Helper to check if the call name matches using ExprHasName\
  \ or callee identifier.\n      static bool isCallNamed(const CallEvent &Call, CheckerContext\
  \ &C, StringRef Name);\n      // Is allocator of interest (kmalloc/kzalloc and their\
  \ _node/__ variants), not kcalloc/kvcalloc.\n      static bool isAllocatorOfInterest(const\
  \ CallEvent &Call, CheckerContext &C);\n      // Returns true if expression text\
  \ uses overflow-safe helpers.\n      static bool isUsingOverflowSafeHelper(const\
  \ Expr *E, CheckerContext &C);\n      // Returns true if E is a multiplication that\
  \ directly involves a sizeof.\n      static bool isRawSizeofMultiply(const Expr\
  \ *E);\n};\n\nbool SAGenTestChecker::isCallNamed(const CallEvent &Call, CheckerContext\
  \ &C, StringRef Name) {\n  const Expr *Origin = Call.getOriginExpr();\n  if (Origin\
  \ && ExprHasName(Origin, Name, C))\n    return true;\n  if (const IdentifierInfo\
  \ *II = Call.getCalleeIdentifier())\n    return II->getName() == Name;\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::isAllocatorOfInterest(const CallEvent &Call,\
  \ CheckerContext &C) {\n  // Exclude safe array allocators\n  if (isCallNamed(Call,\
  \ C, \"kcalloc\") || isCallNamed(Call, C, \"kvcalloc\"))\n    return false;\n\n\
  \  // Target allocators that take a size argument as first parameter\n  if (isCallNamed(Call,\
  \ C, \"kmalloc\") ||\n      isCallNamed(Call, C, \"__kmalloc\") ||\n      isCallNamed(Call,\
  \ C, \"kmalloc_node\") ||\n      isCallNamed(Call, C, \"kzalloc\") ||\n      isCallNamed(Call,\
  \ C, \"kzalloc_node\")) {\n    return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isUsingOverflowSafeHelper(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return false;\n  return ExprHasName(E,\
  \ \"array_size\", C) ||\n         ExprHasName(E, \"struct_size\", C) ||\n      \
  \   ExprHasName(E, \"flex_array_size\", C);\n}\n\nbool SAGenTestChecker::isRawSizeofMultiply(const\
  \ Expr *E) {\n  if (!E) return false;\n  E = E->IgnoreParenImpCasts();\n  const\
  \ auto *BO = dyn_cast<BinaryOperator>(E);\n  if (!BO) return false;\n  if (BO->getOpcode()\
  \ != BO_Mul) return false;\n\n  const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \  const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n\n  auto HasSizeof = [](const\
  \ Expr *X) -> bool {\n    if (!X) return false;\n    if (const auto *U = dyn_cast<UnaryExprOrTypeTraitExpr>(X))\
  \ {\n      return U->getKind() == UETT_SizeOf;\n    }\n    return false;\n  };\n\
  \n  return HasSizeof(L) || HasSizeof(R);\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isAllocatorOfInterest(Call,\
  \ C))\n    return;\n\n  if (Call.getNumArgs() < 1)\n    return;\n\n  const Expr\
  \ *SizeArg = Call.getArgExpr(0);\n  if (!SizeArg)\n    return;\n\n  SizeArg = SizeArg->IgnoreParenImpCasts();\n\
  \n  // Suppress when using overflow-safe helpers\n  if (isUsingOverflowSafeHelper(SizeArg,\
  \ C))\n    return;\n\n  // Only warn when the size arg is a raw multiply including\
  \ sizeof(...)\n  if (!isRawSizeofMultiply(SizeArg))\n    return;\n\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Use kcalloc(n, sizeof(T), ...) instead of kmalloc/kzalloc with\
  \ sizeof(T) * n; unchecked multiplication may overflow\",\n      N);\n\n  R->addRange(SizeArg->getSourceRange());\n\
  \  if (const Stmt *S = Call.getOriginExpr())\n    R->addRange(S->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect kmalloc/kzalloc with sizeof(T)\
  \ * n; suggest kcalloc to avoid overflow\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\namdkfd: use calloc instead of kzalloc to avoid integer\
  \ overflow\n\nThis uses calloc instead of doing the multiplication which might\n\
  overflow.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: kfd_ioctl_get_process_apertures_new in drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\t\t\t\tstruct\
  \ kfd_process *p, void *data)\n{\n\tstruct kfd_ioctl_get_process_apertures_new_args\
  \ *args = data;\n\tstruct kfd_process_device_apertures *pa;\n\tint ret;\n\tint i;\n\
  \n\tdev_dbg(kfd_device, \"get apertures for PASID 0x%x\", p->pasid);\n\n\tif (args->num_of_nodes\
  \ == 0) {\n\t\t/* Return number of nodes, so that user space can alloacate\n\t\t\
  \ * sufficient memory\n\t\t */\n\t\tmutex_lock(&p->mutex);\n\t\targs->num_of_nodes\
  \ = p->n_pdds;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Fill in process-aperture information\
  \ for all available\n\t * nodes, but not more than args->num_of_nodes as that is\n\
  \t * the amount of memory allocated by user\n\t */\n\tpa = kzalloc((sizeof(struct\
  \ kfd_process_device_apertures) *\n\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n\t\
  if (!pa)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&p->mutex);\n\n\tif (!p->n_pdds) {\n\
  \t\targs->num_of_nodes = 0;\n\t\tkfree(pa);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Run\
  \ over all pdd of the process */\n\tfor (i = 0; i < min(p->n_pdds, args->num_of_nodes);\
  \ i++) {\n\t\tstruct kfd_process_device *pdd = p->pdds[i];\n\n\t\tpa[i].gpu_id =\
  \ pdd->dev->id;\n\t\tpa[i].lds_base = pdd->lds_base;\n\t\tpa[i].lds_limit = pdd->lds_limit;\n\
  \t\tpa[i].gpuvm_base = pdd->gpuvm_base;\n\t\tpa[i].gpuvm_limit = pdd->gpuvm_limit;\n\
  \t\tpa[i].scratch_base = pdd->scratch_base;\n\t\tpa[i].scratch_limit = pdd->scratch_limit;\n\
  \n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpu id %u\\n\", pdd->dev->id);\n\t\tdev_dbg(kfd_device,\n\
  \t\t\t\"lds_base %llX\\n\", pdd->lds_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"lds_limit\
  \ %llX\\n\", pdd->lds_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_base %llX\\\
  n\", pdd->gpuvm_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_limit %llX\\n\",\
  \ pdd->gpuvm_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_base %llX\\n\", pdd->scratch_base);\n\
  \t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_limit %llX\\n\", pdd->scratch_limit);\n\
  \t}\n\tmutex_unlock(&p->mutex);\n\n\targs->num_of_nodes = i;\n\tret = copy_to_user(\n\
  \t\t\t(void __user *)args->kfd_process_device_apertures_ptr,\n\t\t\tpa,\n\t\t\t\
  (i * sizeof(struct kfd_process_device_apertures)));\n\tkfree(pa);\n\treturn ret\
  \ ? -EFAULT : 0;\n\nout_unlock:\n\tmutex_unlock(&p->mutex);\n\treturn 0;\n}\n```\n\
  \n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\
  \ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\nindex f9631f4b1a02..55aa74cbc532 100644\n\
  --- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  @@ -779,8 +779,8 @@ static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\
  \ \t * nodes, but not more than args->num_of_nodes as that is\n \t * the amount\
  \ of memory allocated by user\n \t */\n-\tpa = kzalloc((sizeof(struct kfd_process_device_apertures)\
  \ *\n-\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n+\tpa = kcalloc(args->num_of_nodes,\
  \ sizeof(struct kfd_process_device_apertures),\n+\t\t     GFP_KERNEL);\n \tif (!pa)\n\
  \ \t\treturn -ENOMEM;\n \n```\n"
pattern: '## Bug Pattern


  Allocating an array with kmalloc/kzalloc using manual size multiplication without
  overflow checking:


  - Pattern: buf = kzalloc(sizeof(struct item) * count, GFP_KERNEL);

  - Problem: If count is large or user-controlled, the multiplication can overflow,
  allocating too small a buffer and leading to memory corruption when writing count
  elements.

  - Fix: Use kcalloc(count, sizeof(struct item), GFP_KERNEL) (or array_size/struct_size
  helpers), which performs overflow-checked size calculations.'
plan: "1) Program state customization\n- Not needed. The pattern can be detected locally\
  \ at the call site, without interprocedural aliasing or path-sensitive state.\n\n\
  2) Callback functions and implementation steps\n\n- checkPreCall\n  - Goal: Detect\
  \ calls to kmalloc/kzalloc where the size argument is computed by a raw multiplication\
  \ that includes a sizeof expression (i.e., sizeof(T) * N), which is prone to integer\
  \ overflow. Suggest using kcalloc(N, sizeof(T), ...) instead.\n  - Steps:\n    1.\
  \ Identify allocator calls:\n       - Retrieve the callee identifier via Call.getCalleeIdentifier().\n\
  \       - If the name matches any of these: \"kmalloc\", \"kzalloc\", \"__kmalloc\"\
  , \"kmalloc_node\", \"kzalloc_node\", continue; otherwise, return.\n       - Exclude\
  \ calls to \"kcalloc\", \"kvcalloc\" (do not warn).\n    2. Extract the size argument:\n\
  \       - For the matched allocators:\n         - kmalloc/__kmalloc/kmalloc_node:\
  \ Arg0 is size, Arg1 is flags.\n         - kzalloc/kzalloc_node: Arg0 is size, Arg1\
  \ is flags.\n       - If there are fewer than 1 argument, return.\n       - Let\
  \ SizeArg = Call.getArgExpr(0)->IgnoreParenImpCasts().\n    3. Suppress if using\
  \ overflow-safe helpers:\n       - If ExprHasName(SizeArg, \"array_size\", C) ||\
  \ ExprHasName(SizeArg, \"struct_size\", C) || ExprHasName(SizeArg, \"flex_array_size\"\
  , C), return (do not warn).\n    4. Check for raw multiplication including sizeof:\n\
  \       - If SizeArg is a BinaryOperator with opcode BO_Mul:\n         - Let L =\
  \ LHS->IgnoreParenImpCasts(), R = RHS->IgnoreParenImpCasts().\n         - Check\
  \ if L or R is a UnaryExprOrTypeTraitExpr with getKind() == UETT_SizeOf.\n     \
  \      - If neither operand is a sizeof, return (do not warn). Only report when\
  \ the multiplication directly involves sizeof.\n       - Otherwise, return (do not\
  \ warn).\n    5. Report:\n       - Create a BugType once (e.g., in checker ctor)\
  \ named \"Allocator integer overflow risk\".\n       - Generate a non-fatal error\
  \ node: if (!C.generateNonFatalErrorNode()) return.\n       - Build a concise message,\
  \ e.g.:\n         - \"Use kcalloc(n, sizeof(T), ...) instead of kmalloc/kzalloc\
  \ with sizeof(T) * n; unchecked multiplication may overflow.\"\n       - Create\
  \ and emit a PathSensitiveBugReport with the call expression as the primary location\
  \ and highlight the first argument (SizeArg) range for context.\n\n- Optional helper\
  \ routines (local to checker, no program state)\n  - bool isAllocatorOfInterest(const\
  \ CallEvent &Call):\n    - Return true if callee name is one of: kmalloc, kzalloc,\
  \ __kmalloc, kmalloc_node, kzalloc_node.\n  - bool isRawSizeofMultiply(const Expr\
  \ *E):\n    - E = E->IgnoreParenImpCasts().\n    - If not a BinaryOperator with\
  \ BO_Mul, return false.\n    - Let L, R be E\u2019s operands after IgnoreParenImpCasts().\n\
  \    - Return true if L or R is a UnaryExprOrTypeTraitExpr with UETT_SizeOf.\n \
  \ - bool isUsingOverflowSafeHelper(const Expr *E, CheckerContext &C):\n    - Return\
  \ ExprHasName(E, \"array_size\", C) || ExprHasName(E, \"struct_size\", C) || ExprHasName(E,\
  \ \"flex_array_size\", C).\n\nNotes\n- The checker intentionally focuses on direct,\
  \ syntactic patterns: allocation calls where the size argument is a multiplication\
  \ involving sizeof. This keeps the implementation simple and precise for the target\
  \ pattern (e.g., kzalloc(sizeof(struct foo) * n, GFP_KERNEL)).\n- We do not require\
  \ path-sensitive overflow-proof detection or guarding condition analysis. Kernel\
  \ guidance is to use kcalloc/array_size helpers; hence warning is appropriate even\
  \ if the code attempts manual checks.\n- We avoid false positives where array_size/struct_size-style\
  \ helpers are used by checking the source text via ExprHasName before reporting."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No program state customization needed.\nnamespace {\n/* The checker callbacks\
  \ are to be decided. */\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Allocator integer overflow risk\", \"Memory\")) {}\n\n\
  \      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n  \
  \ private:\n\n      // Helper to check if the call name matches using ExprHasName\
  \ or callee identifier.\n      static bool isCallNamed(const CallEvent &Call, CheckerContext\
  \ &C, StringRef Name);\n      // Is allocator of interest (kmalloc/kzalloc and their\
  \ _node/__ variants), not kcalloc/kvcalloc.\n      static bool isAllocatorOfInterest(const\
  \ CallEvent &Call, CheckerContext &C);\n      // Returns true if expression text\
  \ uses overflow-safe helpers.\n      static bool isUsingOverflowSafeHelper(const\
  \ Expr *E, CheckerContext &C);\n      // Returns true if E is a multiplication that\
  \ directly involves a sizeof.\n      static bool isRawSizeofMultiply(const Expr\
  \ *E);\n};\n\nbool SAGenTestChecker::isCallNamed(const CallEvent &Call, CheckerContext\
  \ &C, StringRef Name) {\n  const Expr *Origin = Call.getOriginExpr();\n  if (Origin\
  \ && ExprHasName(Origin, Name, C))\n    return true;\n  if (const IdentifierInfo\
  \ *II = Call.getCalleeIdentifier())\n    return II->getName() == Name;\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::isAllocatorOfInterest(const CallEvent &Call,\
  \ CheckerContext &C) {\n  // Exclude safe array allocators\n  if (isCallNamed(Call,\
  \ C, \"kcalloc\") || isCallNamed(Call, C, \"kvcalloc\"))\n    return false;\n\n\
  \  // Target allocators that take a size argument as first parameter\n  if (isCallNamed(Call,\
  \ C, \"kmalloc\") ||\n      isCallNamed(Call, C, \"__kmalloc\") ||\n      isCallNamed(Call,\
  \ C, \"kmalloc_node\") ||\n      isCallNamed(Call, C, \"kzalloc\") ||\n      isCallNamed(Call,\
  \ C, \"kzalloc_node\")) {\n    return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isUsingOverflowSafeHelper(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return false;\n  return ExprHasName(E,\
  \ \"array_size\", C) ||\n         ExprHasName(E, \"struct_size\", C) ||\n      \
  \   ExprHasName(E, \"flex_array_size\", C);\n}\n\nbool SAGenTestChecker::isRawSizeofMultiply(const\
  \ Expr *E) {\n  if (!E) return false;\n  E = E->IgnoreParenImpCasts();\n  const\
  \ auto *BO = dyn_cast<BinaryOperator>(E);\n  if (!BO) return false;\n  if (BO->getOpcode()\
  \ != BO_Mul) return false;\n\n  const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \  const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n\n  auto HasSizeof = [](const\
  \ Expr *X) -> bool {\n    if (!X) return false;\n    if (const auto *U = dyn_cast<UnaryExprOrTypeTraitExpr>(X))\
  \ {\n      return U->getKind() == UETT_SizeOf;\n    }\n    return false;\n  };\n\
  \n  return HasSizeof(L) || HasSizeof(R);\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isAllocatorOfInterest(Call,\
  \ C))\n    return;\n\n  if (Call.getNumArgs() < 1)\n    return;\n\n  const Expr\
  \ *SizeArg = Call.getArgExpr(0);\n  if (!SizeArg)\n    return;\n\n  SizeArg = SizeArg->IgnoreParenImpCasts();\n\
  \n  // Suppress when using overflow-safe helpers\n  if (isUsingOverflowSafeHelper(SizeArg,\
  \ C))\n    return;\n\n  // Only warn when the size arg is a raw multiply including\
  \ sizeof(...)\n  if (!isRawSizeofMultiply(SizeArg))\n    return;\n\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Use kcalloc(n, sizeof(T), ...) instead of kmalloc/kzalloc with\
  \ sizeof(T) * n; unchecked multiplication may overflow\",\n      N);\n\n  R->addRange(SizeArg->getSourceRange());\n\
  \  if (const Stmt *S = Call.getOriginExpr())\n    R->addRange(S->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect kmalloc/kzalloc with sizeof(T)\
  \ * n; suggest kcalloc to avoid overflow\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
