_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 7a4b21250bf79eef26543d35bd390448646c536b
commit_type: Integer-Overflow
index: 4
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion *, const Expr *)\n\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::Bind, check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Misuse of\
  \ roundup_pow_of_two overflow check\", \"API Misuse\")) {}\n\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n\n      const Expr\
  \ *getRHSOfAssignmentOrInit(const Stmt *S) const;\n      bool isZeroExpr(const Expr\
  \ *E, CheckerContext &C) const;\n      bool isRoundupExpr(const Expr *E, CheckerContext\
  \ &C) const;\n      void report(const Stmt *Condition, CheckerContext &C) const;\n\
  };\n\nconst Expr *SAGenTestChecker::getRHSOfAssignmentOrInit(const Stmt *S) const\
  \ {\n  if (!S)\n    return nullptr;\n\n  if (const auto *BO = dyn_cast<BinaryOperator>(S))\
  \ {\n    if (BO->isAssignmentOp())\n      return BO->getRHS();\n  }\n\n  if (const\
  \ auto *DS = dyn_cast<DeclStmt>(S)) {\n    if (DS->isSingleDecl()) {\n      if (const\
  \ auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl())) {\n        if (VD->hasInit())\n\
  \          return VD->getInit();\n      }\n    }\n  }\n\n  return nullptr;\n}\n\n\
  bool SAGenTestChecker::isZeroExpr(const Expr *E, CheckerContext &C) const {\n  if\
  \ (!E)\n    return false;\n  llvm::APSInt Res;\n  if (EvaluateExprToInt(Res, E->IgnoreParenImpCasts(),\
  \ C)) {\n    return Res == 0;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isRoundupExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n  // Use source\
  \ text presence to cover both calls and macro-like expansions.\n  return ExprHasName(E,\
  \ \"roundup_pow_of_two\", C);\n}\n\nvoid SAGenTestChecker::report(const Stmt *Condition,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Do not detect overflow by testing roundup_pow_of_two(x) ==\
  \ 0; on 32-bit, check x <= (1UL << 31) before calling.\",\n      N);\n  if (Condition)\n\
  \    R->addRange(Condition->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *DstR\
  \ = Loc.getAsRegion();\n  if (!DstR)\n    return;\n  DstR = DstR->getBaseRegion();\n\
  \  if (!DstR)\n    return;\n\n  const Expr *RHSRaw = getRHSOfAssignmentOrInit(S);\n\
  \  if (!RHSRaw) {\n    // Not an assignment or init we care about; clear any prior\
  \ tag.\n    if (State->contains<RoundupResMap>(DstR)) {\n      State = State->remove<RoundupResMap>(DstR);\n\
  \      C.addTransition(State);\n    }\n    return;\n  }\n\n  // Case 1: RHS is roundup_pow_of_two(...)\
  \ (or macro-expands to it).\n  if (isRoundupExpr(RHSRaw, C)) {\n    // Try to store\
  \ the argument for better context if it's a real call.\n    const Expr *Stored =\
  \ nullptr;\n    if (const auto *CE = dyn_cast<CallExpr>(RHSRaw->IgnoreParenImpCasts()))\
  \ {\n      if (CE->getNumArgs() > 0)\n        Stored = CE->getArg(0);\n    }\n \
  \   // Fallback to store RHS itself if we didn't find a clean argument.\n    if\
  \ (!Stored)\n      Stored = RHSRaw;\n\n    State = State->set<RoundupResMap>(DstR,\
  \ Stored);\n    C.addTransition(State);\n    return;\n  }\n\n  // Case 2: Propagate\
  \ tag on simple copies: dest = src;\n  if (const MemRegion *SrcR = getMemRegionFromExpr(RHSRaw,\
  \ C)) {\n    SrcR = SrcR->getBaseRegion();\n    if (SrcR) {\n      if (const Expr\
  \ *const *Tagged = State->get<RoundupResMap>(SrcR)) {\n        State = State->set<RoundupResMap>(DstR,\
  \ *Tagged);\n        C.addTransition(State);\n        return;\n      }\n    }\n\
  \  }\n\n  // Default: clear any prior tag for destination.\n  if (State->contains<RoundupResMap>(DstR))\
  \ {\n    State = State->remove<RoundupResMap>(DstR);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  // Only warn on 32-bit unsigned long targets.\n  const ASTContext\
  \ &ACtx = C.getASTContext();\n  unsigned ULWidth = ACtx.getIntWidth(ACtx.UnsignedLongTy);\n\
  \  if (ULWidth != 32)\n    return;\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n\
  \  if (!CondE)\n    return;\n\n  ProgramStateRef State = C.getState();\n  const\
  \ Expr *CondNoCasts = CondE->IgnoreParenImpCasts();\n\n  // Pattern P2 first: direct\
  \ zero-check on roundup expression.\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondNoCasts))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *Sub = UO->getSubExpr();\n\
  \      if (isRoundupExpr(Sub, C)) {\n        report(Condition, C);\n        return;\n\
  \      }\n      // Also handle: if (!n) where n was assigned from roundup_pow_of_two\n\
  \      if (const MemRegion *MR = getMemRegionFromExpr(Sub, C)) {\n        MR = MR->getBaseRegion();\n\
  \        if (MR) {\n          if (State->get<RoundupResMap>(MR)) {\n           \
  \ report(Condition, C);\n            return;\n          }\n        }\n      }\n\
  \    }\n  } else if (const auto *BO = dyn_cast<BinaryOperator>(CondNoCasts)) {\n\
  \    if (BO->getOpcode() == BO_EQ) {\n      const Expr *L = BO->getLHS();\n    \
  \  const Expr *R = BO->getRHS();\n\n      bool LIsZero = isZeroExpr(L, C);\n   \
  \   bool RIsZero = isZeroExpr(R, C);\n\n      // Direct check on roundup expression:\
  \ roundup_pow_of_two(x) == 0\n      if ((isRoundupExpr(L, C) && RIsZero) || (isRoundupExpr(R,\
  \ C) && LIsZero)) {\n        report(Condition, C);\n        return;\n      }\n\n\
  \      // Check variable tagged by prior assignment: n == 0\n      if (RIsZero)\
  \ {\n        if (const MemRegion *MR = getMemRegionFromExpr(L, C)) {\n         \
  \ MR = MR->getBaseRegion();\n          if (MR && State->get<RoundupResMap>(MR))\
  \ {\n            report(Condition, C);\n            return;\n          }\n     \
  \   }\n      } else if (LIsZero) {\n        if (const MemRegion *MR = getMemRegionFromExpr(R,\
  \ C)) {\n          MR = MR->getBaseRegion();\n          if (MR && State->get<RoundupResMap>(MR))\
  \ {\n            report(Condition, C);\n            return;\n          }\n     \
  \   }\n      }\n    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Warn when using roundup_pow_of_two(x)\
  \ == 0 to detect overflow; check x <= (1UL << 31) before calling\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbpf: Fix stackmap overflow check on 32-bit arches\n\
  \nThe stackmap code relies on roundup_pow_of_two() to compute the number\nof hash\
  \ buckets, and contains an overflow check by checking if the\nresulting value is\
  \ 0. However, on 32-bit arches, the roundup code itself\ncan overflow by doing a\
  \ 32-bit left-shift of an unsigned long value,\nwhich is undefined behaviour, so\
  \ it is not guaranteed to truncate\nneatly. This was triggered by syzbot on the\
  \ DEVMAP_HASH type, which\ncontains the same check, copied from the hashtab code.\n\
  \nThe commit in the fixes tag actually attempted to fix this, but the fix\ndid not\
  \ account for the UB, so the fix only works on CPUs where an\noverflow does result\
  \ in a neat truncation to zero, which is not\nguaranteed. Checking the value before\
  \ rounding does not have this\nproblem.\n\nFixes: 6183f4d3a0a2 (\"bpf: Check for\
  \ integer overflow when using roundup_pow_of_two()\")\nSigned-off-by: Toke H\xF8\
  iland-J\xF8rgensen <toke@redhat.com>\nReviewed-by: Bui Quang Minh <minhquangbui99@gmail.com>\n\
  Message-ID: <20240307120340.99577-4-toke@redhat.com>\nSigned-off-by: Alexei Starovoitov\
  \ <ast@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: stack_map_alloc in kernel/bpf/stackmap.c\n\
  static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n{\n\tu32 value_size\
  \ = attr->value_size;\n\tstruct bpf_stack_map *smap;\n\tu64 cost, n_buckets;\n\t\
  int err;\n\n\tif (attr->map_flags & ~STACK_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size\
  \ != 4 ||\n\t    value_size < 8 || value_size % 8)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\tBUILD_BUG_ON(sizeof(struct bpf_stack_build_id) % sizeof(u64));\n\tif (attr->map_flags\
  \ & BPF_F_STACK_BUILD_ID) {\n\t\tif (value_size % sizeof(struct bpf_stack_build_id)\
  \ ||\n\t\t    value_size / sizeof(struct bpf_stack_build_id)\n\t\t    > sysctl_perf_event_max_stack)\n\
  \t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n\
  \t\treturn ERR_PTR(-EINVAL);\n\n\t/* hash table size must be power of 2 */\n\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n\tif (!n_buckets)\n\t\treturn ERR_PTR(-E2BIG);\n\
  \n\tcost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);\n\tsmap\
  \ = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\tif (!smap)\n\t\t\
  return ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&smap->map, attr);\n\tsmap->n_buckets\
  \ = n_buckets;\n\n\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\t\
  if (err)\n\t\tgoto free_smap;\n\n\terr = prealloc_elems_and_freelist(smap);\n\t\
  if (err)\n\t\tgoto put_buffers;\n\n\treturn &smap->map;\n\nput_buffers:\n\tput_callchain_buffers();\n\
  free_smap:\n\tbpf_map_area_free(smap);\n\treturn ERR_PTR(err);\n}\n```\n\n## Bug\
  \ Fix Patch\n\n```diff\ndiff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c\n\
  index dff7ba539701..c99f8e5234ac 100644\n--- a/kernel/bpf/stackmap.c\n+++ b/kernel/bpf/stackmap.c\n\
  @@ -91,11 +91,14 @@ static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n\
  \ \t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n \t\treturn ERR_PTR(-EINVAL);\n\
  \ \n-\t/* hash table size must be power of 2 */\n-\tn_buckets = roundup_pow_of_two(attr->max_entries);\n\
  -\tif (!n_buckets)\n+\t/* hash table size must be power of 2; roundup_pow_of_two()\
  \ can overflow\n+\t * into UB on 32-bit arches, so check that first\n+\t */\n+\t\
  if (attr->max_entries > 1UL << 31)\n \t\treturn ERR_PTR(-E2BIG);\n \n+\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n+\n \tcost = n_buckets * sizeof(struct\
  \ stack_map_bucket *) + sizeof(*smap);\n \tsmap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\
  \ \tif (!smap)\n```\n"
pattern: "## Bug Pattern\n\nDetecting overflow by checking the result of roundup_pow_of_two(x)\
  \ for zero after the call, instead of validating x beforehand. On 32-bit architectures,\
  \ roundup_pow_of_two() may perform a left shift by \u226532 (e.g., when x > 1UL\
  \ << 31), which is undefined behavior, so the function can return a non-zero garbage\
  \ value and the post-call zero check fails. The buggy idiom looks like:\n\nn = roundup_pow_of_two(x);\n\
  if (!n)\n    /* assume overflow */\n\nCorrect pattern: first ensure x <= (1UL <<\
  \ 31), then call roundup_pow_of_two()."
plan: "Plan\n\n1) Program state\n- Register one map to remember variables that just\
  \ received the result of roundup_pow_of_two():\n  - REGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion *, const Expr *)\n  - Key: the destination variable\u2019s MemRegion.\n\
  \  - Value: the (single) argument expression passed to roundup_pow_of_two (to help\
  \ produce a better diagnostic). If you don\u2019t need it in the message, you can\
  \ store a dummy pointer or a bool instead.\n\nRationale: We only need to know whether\
  \ a particular variable was assigned from roundup_pow_of_two(). No complex aliasing\
  \ or lifetime tracking is necessary; we clear/rewrite the tag on subsequent assignments.\n\
  \n2) Callback selection and implementation\n\nA) checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const\nGoal: Tag the LHS variable if it\u2019s assigned\
  \ from roundup_pow_of_two(arg), propagate/clear tags on other assignments.\n\nImplementation\
  \ steps:\n- Extract the destination region:\n  - If Loc is not a loc::MemRegionVal\
  \ or the region is not a VarRegion, return.\n  - const MemRegion *DstR = Loc.castAs<loc::MemRegionVal>().getRegion();\n\
  - Identify the RHS expression of this bind from S:\n  - If S is a BinaryOperator\
  \ with isAssignmentOp(), let RHS = BO->getRHS()->IgnoreParenImpCasts().\n  - Else\
  \ if S is a DeclStmt with a single VarDecl that has an initializer, let RHS = VD->getInit()->IgnoreParenImpCasts().\n\
  \  - Otherwise, best-effort fallback: use findSpecificTypeInChildren<CallExpr>(S)\
  \ if needed (but prefer the two direct cases above).\n- Case 1: RHS is a call to\
  \ roundup_pow_of_two:\n  - Check call by:\n    - If RHS is CallExpr CE and ExprHasName(CE,\
  \ \"roundup_pow_of_two\", C) is true.\n  - If true:\n    - const Expr *Arg0 = CE->getNumArgs()\
  \ > 0 ? CE->getArg(0) : nullptr.\n    - State = State->set<RoundupResMap>(DstR,\
  \ Arg0);\n    - C.addTransition(State).\n  - Return.\n- Case 2: Propagate tag on\
  \ simple copies:\n  - If RHS is a DeclRefExpr DRE:\n    - const MemRegion *SrcR\
  \ = getMemRegionFromExpr(DRE, C).\n    - If SrcR found and State has entry for SrcR\
  \ in RoundupResMap, then:\n      - State = State->set<RoundupResMap>(DstR, State->get<RoundupResMap>(SrcR));\n\
  \      - C.addTransition(State).\n      - Return.\n- Default: Clear any prior tag\
  \ for DstR when this assignment is not from roundup:\n  - If State contains DstR,\
  \ State = State->remove<RoundupResMap>(DstR); C.addTransition(State).\n\nNotes:\n\
  - This keeps the map precise: only the most recent assignment governs the tag.\n\
  - No alias map is needed because we are tracking scalars that are assigned by value.\n\
  \nB) checkBranchCondition(const Stmt *Condition, CheckerContext &C) const\nGoal:\
  \ Detect the buggy overflow check pattern where code tests the result of roundup_pow_of_two\
  \ for zero after the call.\n\nWe emit a warning only on 32-bit unsigned long targets.\n\
  \nImplementation steps:\n- Gate by target type size:\n  - const ASTContext &ACtx\
  \ = C.getASTContext();\n  - unsigned ULWidth = ACtx.getIntWidth(ACtx.UnsignedLongTy);\n\
  \  - If ULWidth != 32, return (do not warn on 64-bit).\n- Prepare small helpers:\n\
  \  - isZeroExpr(const Expr *E):\n    - Use EvaluateExprToInt to constant-fold; return\
  \ true iff value == 0.\n  - isRoundupCall(const Expr *E):\n    - Return true if\
  \ E is a CallExpr and ExprHasName(E, \"roundup_pow_of_two\", C).\n- Analyze the\
  \ condition expression:\n  - const Expr *Cond = dyn_cast<Expr>(Condition); if (!Cond)\
  \ return;\n  - Cond = Cond->IgnoreParenImpCasts().\n- Pattern P1: Direct zero-check\
  \ of a variable that came from roundup_pow_of_two:\n  - If Cond is a UnaryOperator\
  \ UO_LNot:\n    - const Expr *Sub = U->getSubExpr()->IgnoreParenImpCasts();\n  \
  \  - If Sub is a DeclRefExpr:\n      - const MemRegion *R = getMemRegionFromExpr(Sub,\
  \ C);\n      - If R and State has R in RoundupResMap, then report.\n  - Else if\
  \ Cond is a BinaryOperator BO with opcode BO_EQ:\n    - const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \    - const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n    - If (L is DeclRefExpr\
  \ tracked in RoundupResMap and isZeroExpr(RHS)) OR\n         (RHS is DeclRefExpr\
  \ tracked and isZeroExpr(L)):\n      - report.\n- Pattern P2: Direct zero-check\
  \ on the call itself:\n  - If Cond is UnaryOperator UO_LNot:\n    - const Expr *Sub\
  \ = U->getSubExpr()->IgnoreParenImpCasts();\n    - If isRoundupCall(Sub), report.\n\
  \  - Else if Cond is BinaryOperator BO with opcode BO_EQ:\n    - const Expr *L =\
  \ BO->getLHS()->IgnoreParenImpCasts();\n    - const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \    - If (isRoundupCall(L) and isZeroExpr(RHS)) OR\n         (isRoundupCall(RHS)\
  \ and isZeroExpr(L)):\n      - report.\n\nBug reporting:\n- Create a BugType once\
  \ (e.g., in the checker constructor) with a short name like \"Misuse of roundup_pow_of_two\
  \ overflow check\".\n- Create a non-fatal error node and emit a short message:\n\
  \  - \"Do not detect overflow by testing roundup_pow_of_two(x) == 0; on 32-bit,\
  \ check x <= (1UL << 31) before calling.\"\n- Use the condition\u2019s source range\
  \ as the primary location.\n- Optionally, if you stored Arg0 in RoundupResMap, add\
  \ a note to point to the original argument expression to help the user identify\
  \ what should be pre-validated.\n\n3) Optional pattern coverage and pruning\n- The\
  \ above detects the canonical buggy idiom:\n  - n = roundup_pow_of_two(x); if (!n)\
  \ ...\n  - if (!roundup_pow_of_two(x)) ...\n  - if (n == 0) ... with n tagged as\
  \ from roundup.\n- We do not warn on 64-bit targets to avoid false positives.\n\
  - We clear tags on any non-roundup assignment to keep state precise and avoid stale\
  \ reports.\n\n4) Utility functions used\n- ExprHasName to recognize \"roundup_pow_of_two\"\
  \ even if it is a macro.\n- EvaluateExprToInt to test if an expression is 0.\n-\
  \ getMemRegionFromExpr to map DeclRefExprs to regions for state lookup.\n- findSpecificTypeInChildren\
  \ may be used as a fallback in checkBind if needed to locate the RHS call when S\
  \ is complex."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion *, const Expr *)\n\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::Bind, check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Misuse of\
  \ roundup_pow_of_two overflow check\", \"API Misuse\")) {}\n\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n\n      const Expr\
  \ *getRHSOfAssignmentOrInit(const Stmt *S) const;\n      bool isZeroExpr(const Expr\
  \ *E, CheckerContext &C) const;\n      bool isRoundupExpr(const Expr *E, CheckerContext\
  \ &C) const;\n      void report(const Stmt *Condition, CheckerContext &C) const;\n\
  };\n\nconst Expr *SAGenTestChecker::getRHSOfAssignmentOrInit(const Stmt *S) const\
  \ {\n  if (!S)\n    return nullptr;\n\n  if (const auto *BO = dyn_cast<BinaryOperator>(S))\
  \ {\n    if (BO->isAssignmentOp())\n      return BO->getRHS();\n  }\n\n  if (const\
  \ auto *DS = dyn_cast<DeclStmt>(S)) {\n    if (DS->isSingleDecl()) {\n      if (const\
  \ auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl())) {\n        if (VD->hasInit())\n\
  \          return VD->getInit();\n      }\n    }\n  }\n\n  return nullptr;\n}\n\n\
  bool SAGenTestChecker::isZeroExpr(const Expr *E, CheckerContext &C) const {\n  if\
  \ (!E)\n    return false;\n  llvm::APSInt Res;\n  if (EvaluateExprToInt(Res, E->IgnoreParenImpCasts(),\
  \ C)) {\n    return Res == 0;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isRoundupExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n  // Use source\
  \ text presence to cover both calls and macro-like expansions.\n  return ExprHasName(E,\
  \ \"roundup_pow_of_two\", C);\n}\n\nvoid SAGenTestChecker::report(const Stmt *Condition,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Do not detect overflow by testing roundup_pow_of_two(x) ==\
  \ 0; on 32-bit, check x <= (1UL << 31) before calling.\",\n      N);\n  if (Condition)\n\
  \    R->addRange(Condition->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *DstR\
  \ = Loc.getAsRegion();\n  if (!DstR)\n    return;\n  DstR = DstR->getBaseRegion();\n\
  \  if (!DstR)\n    return;\n\n  const Expr *RHSRaw = getRHSOfAssignmentOrInit(S);\n\
  \  if (!RHSRaw) {\n    // Not an assignment or init we care about; clear any prior\
  \ tag.\n    if (State->contains<RoundupResMap>(DstR)) {\n      State = State->remove<RoundupResMap>(DstR);\n\
  \      C.addTransition(State);\n    }\n    return;\n  }\n\n  // Case 1: RHS is roundup_pow_of_two(...)\
  \ (or macro-expands to it).\n  if (isRoundupExpr(RHSRaw, C)) {\n    // Try to store\
  \ the argument for better context if it's a real call.\n    const Expr *Stored =\
  \ nullptr;\n    if (const auto *CE = dyn_cast<CallExpr>(RHSRaw->IgnoreParenImpCasts()))\
  \ {\n      if (CE->getNumArgs() > 0)\n        Stored = CE->getArg(0);\n    }\n \
  \   // Fallback to store RHS itself if we didn't find a clean argument.\n    if\
  \ (!Stored)\n      Stored = RHSRaw;\n\n    State = State->set<RoundupResMap>(DstR,\
  \ Stored);\n    C.addTransition(State);\n    return;\n  }\n\n  // Case 2: Propagate\
  \ tag on simple copies: dest = src;\n  if (const MemRegion *SrcR = getMemRegionFromExpr(RHSRaw,\
  \ C)) {\n    SrcR = SrcR->getBaseRegion();\n    if (SrcR) {\n      if (const Expr\
  \ *const *Tagged = State->get<RoundupResMap>(SrcR)) {\n        State = State->set<RoundupResMap>(DstR,\
  \ *Tagged);\n        C.addTransition(State);\n        return;\n      }\n    }\n\
  \  }\n\n  // Default: clear any prior tag for destination.\n  if (State->contains<RoundupResMap>(DstR))\
  \ {\n    State = State->remove<RoundupResMap>(DstR);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  // Only warn on 32-bit unsigned long targets.\n  const ASTContext\
  \ &ACtx = C.getASTContext();\n  unsigned ULWidth = ACtx.getIntWidth(ACtx.UnsignedLongTy);\n\
  \  if (ULWidth != 32)\n    return;\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n\
  \  if (!CondE)\n    return;\n\n  ProgramStateRef State = C.getState();\n  const\
  \ Expr *CondNoCasts = CondE->IgnoreParenImpCasts();\n\n  // Pattern P2 first: direct\
  \ zero-check on roundup expression.\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondNoCasts))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *Sub = UO->getSubExpr();\n\
  \      if (isRoundupExpr(Sub, C)) {\n        report(Condition, C);\n        return;\n\
  \      }\n      // Also handle: if (!n) where n was assigned from roundup_pow_of_two\n\
  \      if (const MemRegion *MR = getMemRegionFromExpr(Sub, C)) {\n        MR = MR->getBaseRegion();\n\
  \        if (MR) {\n          if (State->get<RoundupResMap>(MR)) {\n           \
  \ report(Condition, C);\n            return;\n          }\n        }\n      }\n\
  \    }\n  } else if (const auto *BO = dyn_cast<BinaryOperator>(CondNoCasts)) {\n\
  \    if (BO->getOpcode() == BO_EQ) {\n      const Expr *L = BO->getLHS();\n    \
  \  const Expr *R = BO->getRHS();\n\n      bool LIsZero = isZeroExpr(L, C);\n   \
  \   bool RIsZero = isZeroExpr(R, C);\n\n      // Direct check on roundup expression:\
  \ roundup_pow_of_two(x) == 0\n      if ((isRoundupExpr(L, C) && RIsZero) || (isRoundupExpr(R,\
  \ C) && LIsZero)) {\n        report(Condition, C);\n        return;\n      }\n\n\
  \      // Check variable tagged by prior assignment: n == 0\n      if (RIsZero)\
  \ {\n        if (const MemRegion *MR = getMemRegionFromExpr(L, C)) {\n         \
  \ MR = MR->getBaseRegion();\n          if (MR && State->get<RoundupResMap>(MR))\
  \ {\n            report(Condition, C);\n            return;\n          }\n     \
  \   }\n      } else if (LIsZero) {\n        if (const MemRegion *MR = getMemRegionFromExpr(R,\
  \ C)) {\n          MR = MR->getBaseRegion();\n          if (MR && State->get<RoundupResMap>(MR))\
  \ {\n            report(Condition, C);\n            return;\n          }\n     \
  \   }\n      }\n    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Warn when using roundup_pow_of_two(x)\
  \ == 0 to detect overflow; check x <= (1UL << 31) before calling\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
