_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: a97de7bff13b1cc825c1b1344eaed8d6c2d3e695
commit_type: Misuse
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include <tuple>\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Track a path-sensitive\
  \ lower bound for the parameter 'optlen' (if present).\nREGISTER_MAP_WITH_PROGRAMSTATE(OptlenLowerBoundMap,\
  \ const MemRegion *, llvm::APSInt)\n\nnamespace {\nclass SAGenTestChecker : public\
  \ Checker<\n                             check::BeginFunction,\n               \
  \              check::BranchCondition,\n                             check::PostCall>\
  \ {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n \
  \     : BT(new BugType(this, \"Setsockopt length validation\", \"API Misuse\"))\
  \ {}\n\n  void checkBeginFunction(CheckerContext &C) const;\n  void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n  void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\nprivate:\n  // Helper determinations\n  static\
  \ bool isSetSockoptHandler(const FunctionDecl *FD);\n  static const ParmVarDecl\
  \ *getParmByName(const FunctionDecl *FD, StringRef Name);\n  static const ParmVarDecl\
  \ *getOptlenParm(const FunctionDecl *FD);\n  static const ParmVarDecl *getOptvalParm(const\
  \ FunctionDecl *FD);\n  static const MemRegion *getParmRegion(const ParmVarDecl\
  \ *PVD, CheckerContext &C);\n\n  static bool isSockptrCopyCall(const CallEvent &Call,\
  \ CheckerContext &C,\n                                unsigned &SizeArgIndex);\n\
  \  static bool isSafeBtSockptrCopy(const CallEvent &Call, CheckerContext &C);\n\
  \  static bool getConstSizeValue(llvm::APSInt &Out, const Expr *E,\n           \
  \                     CheckerContext &C);\n  static bool sizeExprMentionsOptlen(const\
  \ Expr *E, CheckerContext &C);\n\n  static ProgramStateRef updateLowerBound(ProgramStateRef\
  \ St,\n                                          const MemRegion *OptlenMR,\n  \
  \                                        const llvm::APSInt &NewLB);\n\n  static\
  \ BinaryOperator::Opcode invertRelOp(BinaryOperator::Opcode Op);\n};\n\nbool SAGenTestChecker::isSetSockoptHandler(const\
  \ FunctionDecl *FD) {\n  if (!FD)\n    return false;\n  StringRef Name = FD->getName();\n\
  \  if (!Name.contains(\"setsockopt\"))\n    return false;\n\n  // Heuristic: require\
  \ both 'optlen' and 'optval' parameters present.\n  const ParmVarDecl *Optlen =\
  \ getParmByName(FD, \"optlen\");\n  const ParmVarDecl *Optval = getParmByName(FD,\
  \ \"optval\");\n  if (!Optlen || !Optval)\n    return false;\n\n  // 'optlen' should\
  \ be an integer type (typical in kernel handlers).\n  QualType QT = Optlen->getType();\n\
  \  if (!QT->isIntegerType())\n    return false;\n\n  return true;\n}\n\nconst ParmVarDecl\
  \ *SAGenTestChecker::getParmByName(const FunctionDecl *FD,\n                   \
  \                                StringRef Name) {\n  if (!FD)\n    return nullptr;\n\
  \  for (const ParmVarDecl *P : FD->parameters()) {\n    if (!P)\n      continue;\n\
  \    if (P->getName() == Name)\n      return P;\n  }\n  return nullptr;\n}\n\nconst\
  \ ParmVarDecl *SAGenTestChecker::getOptlenParm(const FunctionDecl *FD) {\n  return\
  \ getParmByName(FD, \"optlen\");\n}\n\nconst ParmVarDecl *SAGenTestChecker::getOptvalParm(const\
  \ FunctionDecl *FD) {\n  return getParmByName(FD, \"optval\");\n}\n\nconst MemRegion\
  \ *SAGenTestChecker::getParmRegion(const ParmVarDecl *PVD,\n                   \
  \                              CheckerContext &C) {\n  if (!PVD)\n    return nullptr;\n\
  \  MemRegionManager &MRMgr = C.getSValBuilder().getRegionManager();\n  const VarRegion\
  \ *VR = MRMgr.getVarRegion(PVD, C.getLocationContext());\n  if (!VR)\n    return\
  \ nullptr;\n  const MemRegion *Base = VR->getBaseRegion();\n  return Base;\n}\n\n\
  bool SAGenTestChecker::isSafeBtSockptrCopy(const CallEvent &Call,\n            \
  \                               CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  // Safe helper: bt_copy_from_sockptr(dst,\
  \ dst_size, src, optlen)\n  return ExprHasName(Origin, \"bt_copy_from_sockptr\"\
  , C);\n}\n\nbool SAGenTestChecker::isSockptrCopyCall(const CallEvent &Call,\n  \
  \                                       CheckerContext &C,\n                   \
  \                      unsigned &SizeArgIndex) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  if (ExprHasName(Origin, \"copy_from_sockptr_offset\"\
  , C)) {\n    SizeArgIndex = 3; // (dst, src, offset, size)\n    return true;\n \
  \ }\n  if (ExprHasName(Origin, \"copy_from_sockptr\", C)) {\n    SizeArgIndex =\
  \ 2; // (dst, src, size)\n    return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getConstSizeValue(llvm::APSInt\
  \ &Out, const Expr *E,\n                                         CheckerContext\
  \ &C) {\n  if (!E)\n    return false;\n  return EvaluateExprToInt(Out, E, C);\n\
  }\n\nbool SAGenTestChecker::sizeExprMentionsOptlen(const Expr *E,\n            \
  \                                  CheckerContext &C) {\n  if (!E)\n    return false;\n\
  \  return ExprHasName(E, \"optlen\", C);\n}\n\nProgramStateRef SAGenTestChecker::updateLowerBound(ProgramStateRef\
  \ St,\n                                                   const MemRegion *OptlenMR,\n\
  \                                                   const llvm::APSInt &NewLB) {\n\
  \  if (!St || !OptlenMR)\n    return St;\n\n  const llvm::APSInt *Prev = St->get<OptlenLowerBoundMap>(OptlenMR);\n\
  \  if (!Prev) {\n    // No previous LB, set it now.\n    return St->set<OptlenLowerBoundMap>(OptlenMR,\
  \ NewLB);\n  }\n\n  // Compare after aligning bit widths and signedness.\n  llvm::APSInt\
  \ PrevAdj = *Prev;\n  if (PrevAdj.getBitWidth() != NewLB.getBitWidth())\n    PrevAdj\
  \ = PrevAdj.extOrTrunc(NewLB.getBitWidth());\n  PrevAdj.setIsSigned(NewLB.isSigned());\n\
  \n  if (PrevAdj < NewLB) {\n    return St->set<OptlenLowerBoundMap>(OptlenMR, NewLB);\n\
  \  }\n  return St;\n}\n\nBinaryOperator::Opcode SAGenTestChecker::invertRelOp(BinaryOperator::Opcode\
  \ Op) {\n  switch (Op) {\n  case BO_LT:\n    return BO_GT;\n  case BO_GT:\n    return\
  \ BO_LT;\n  case BO_LE:\n    return BO_GE;\n  case BO_GE:\n    return BO_LE;\n \
  \ case BO_EQ:\n    return BO_EQ;\n  case BO_NE:\n    return BO_NE;\n  default:\n\
  \    return Op;\n  }\n}\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  const LocationContext *LCtx = C.getLocationContext();\n  const\
  \ FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(LCtx->getDecl());\n  if (!FD\
  \ || !isSetSockoptHandler(FD))\n    return;\n\n  const ParmVarDecl *OptlenPVD =\
  \ getOptlenParm(FD);\n  if (!OptlenPVD)\n    return;\n\n  const MemRegion *OptlenMR\
  \ = getParmRegion(OptlenPVD, C);\n  if (!OptlenMR)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  // Clear any previous learning for this param (fresh\
  \ function entry).\n  if (State->contains<OptlenLowerBoundMap>(OptlenMR)) {\n  \
  \  State = State->remove<OptlenLowerBoundMap>(OptlenMR);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\n\
  \                                            CheckerContext &C) const {\n  const\
  \ LocationContext *LCtx = C.getLocationContext();\n  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(LCtx->getDecl());\n\
  \  if (!FD || !isSetSockoptHandler(FD))\n    return;\n\n  const ParmVarDecl *OptlenPVD\
  \ = getOptlenParm(FD);\n  if (!OptlenPVD)\n    return;\n\n  const MemRegion *OptlenMR\
  \ = getParmRegion(OptlenPVD, C);\n  if (!OptlenMR)\n    return;\n\n  const Expr\
  \ *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE)\n    return;\n\n  CondE\
  \ = CondE->IgnoreParenImpCasts();\n  const auto *BO = dyn_cast<BinaryOperator>(CondE);\n\
  \  if (!BO)\n    return;\n\n  BinaryOperator::Opcode Op = BO->getOpcode();\n  //\
  \ Only relational ops are interesting.\n  if (!(Op == BO_LT || Op == BO_LE || Op\
  \ == BO_GT || Op == BO_GE ||\n        Op == BO_EQ || Op == BO_NE))\n    return;\n\
  \n  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS =\
  \ BO->getRHS()->IgnoreParenImpCasts();\n\n  bool LHSHasOptlen = sizeExprMentionsOptlen(LHS,\
  \ C);\n  bool RHSHasOptlen = sizeExprMentionsOptlen(RHS, C);\n\n  if (LHSHasOptlen\
  \ == RHSHasOptlen)\n    return; // Need exactly one side to reference optlen and\
  \ the other side to be a constant.\n\n  const Expr *OptlenSide = LHSHasOptlen ?\
  \ LHS : RHS;\n  const Expr *OtherSide = LHSHasOptlen ? RHS : LHS;\n\n  (void)OptlenSide;\
  \ // Not used beyond presence check.\n\n  llvm::APSInt K;\n  if (!getConstSizeValue(K,\
  \ OtherSide, C))\n    return; // We only handle comparisons against constants/sizeof-expr.\n\
  \n  // Normalize to the form: optlen <OpN> K\n  BinaryOperator::Opcode OpN = LHSHasOptlen\
  \ ? Op : invertRelOp(Op);\n\n  // Now split states based on the condition runtime\
  \ value.\n  ProgramStateRef State = C.getState();\n  DefinedOrUnknownSVal DV =\n\
  \      State->getSVal(CondE, C.getLocationContext()).castAs<DefinedOrUnknownSVal>();\n\
  \n  ProgramStateRef StateTrue, StateFalse;\n  std::tie(StateTrue, StateFalse) =\
  \ C.assume(DV);\n\n  // For each branch, update lower bound if we can conclude it.\n\
  \  // True branch implications:\n  if (StateTrue) {\n    switch (OpN) {\n    case\
  \ BO_GE:\n      StateTrue = updateLowerBound(StateTrue, OptlenMR, K);\n      break;\n\
  \    case BO_GT: {\n      llvm::APSInt Kp1 = K;\n      Kp1 = Kp1 + 1;\n      StateTrue\
  \ = updateLowerBound(StateTrue, OptlenMR, Kp1);\n      break;\n    }\n    case BO_EQ:\n\
  \      StateTrue = updateLowerBound(StateTrue, OptlenMR, K);\n      break;\n   \
  \ default:\n      break; // For <, <=, != true branch does not increase LB.\n  \
  \  }\n    C.addTransition(StateTrue);\n  }\n\n  // False branch implications:\n\
  \  if (StateFalse) {\n    switch (OpN) {\n    case BO_LT:\n      // !(optlen < K)\
  \ => optlen >= K\n      StateFalse = updateLowerBound(StateFalse, OptlenMR, K);\n\
  \      break;\n    case BO_LE: {\n      // !(optlen <= K) => optlen > K => LB =\
  \ K+1\n      llvm::APSInt Kp1 = K;\n      Kp1 = Kp1 + 1;\n      StateFalse = updateLowerBound(StateFalse,\
  \ OptlenMR, Kp1);\n      break;\n    }\n    case BO_NE:\n      // !(optlen != K)\
  \ => optlen == K => LB = K\n      StateFalse = updateLowerBound(StateFalse, OptlenMR,\
  \ K);\n      break;\n    default:\n      break; // For >=, > false branch does not\
  \ increase LB.\n    }\n    C.addTransition(StateFalse);\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call,\n                                     CheckerContext &C) const\
  \ {\n  const LocationContext *LCtx = C.getLocationContext();\n  const FunctionDecl\
  \ *FD = dyn_cast_or_null<FunctionDecl>(LCtx->getDecl());\n  if (!FD || !isSetSockoptHandler(FD))\n\
  \    return;\n\n  // Safe helper: do not warn.\n  if (isSafeBtSockptrCopy(Call,\
  \ C))\n    return;\n\n  unsigned SizeArgIndex = 0;\n  if (!isSockptrCopyCall(Call,\
  \ C, SizeArgIndex))\n    return;\n\n  if (SizeArgIndex >= Call.getNumArgs())\n \
  \   return;\n\n  // Size argument expression\n  const Expr *SizeE = Call.getArgExpr(SizeArgIndex);\n\
  \  if (!SizeE)\n    return;\n\n  // If size expression mentions \"optlen\", it is\
  \ length-aware -> do not warn.\n  if (sizeExprMentionsOptlen(SizeE, C))\n    return;\n\
  \n  llvm::APSInt SizeConst;\n  if (!getConstSizeValue(SizeConst, SizeE, C))\n  \
  \  return; // Only warn for fixed-size copies (sizeof or literal)\n\n  const ParmVarDecl\
  \ *OptlenPVD = getOptlenParm(FD);\n  if (!OptlenPVD)\n    return;\n  const MemRegion\
  \ *OptlenMR = getParmRegion(OptlenPVD, C);\n  if (!OptlenMR)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  const llvm::APSInt *LBPtr = State->get<OptlenLowerBoundMap>(OptlenMR);\n\
  \n  bool Safe = false;\n  if (LBPtr) {\n    llvm::APSInt LB = *LBPtr;\n    // Align\
  \ widths and signedness for comparison\n    if (LB.getBitWidth() != SizeConst.getBitWidth())\n\
  \      LB = LB.extOrTrunc(SizeConst.getBitWidth());\n    LB.setIsSigned(SizeConst.isSigned());\n\
  \    // If LB >= SizeConst, it's safe on this path.\n    Safe = (LB >= SizeConst);\n\
  \  }\n\n  if (!Safe) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n \
  \   if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT,\n        \"copy_from_sockptr uses fixed size without ensuring optlen\
  \ is large enough\",\n        N);\n    if (SizeE)\n      R->addRange(SizeE->getSourceRange());\n\
  \    C.emitReport(std::move(R));\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect fixed-size copy_from_sockptr\
  \ in setsockopt without validating optlen\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: RFCOMM: Fix not validating setsockopt user\
  \ input\n\nsyzbot reported rfcomm_sock_setsockopt_old() is copying data without\n\
  checking user input length.\n\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset\n\
  include/linux/sockptr.h:49 [inline]\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr\n\
  include/linux/sockptr.h:55 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt_old\n\
  net/bluetooth/rfcomm/sock.c:632 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt+0x893/0xa70\n\
  net/bluetooth/rfcomm/sock.c:673\nRead of size 4 at addr ffff8880209a8bc3 by task\
  \ syz-executor632/5064\n\nFixes: 9f2c8a03fbb3 (\"Bluetooth: Replace RFCOMM link\
  \ mode with security level\")\nFixes: bb23c0ab8246 (\"Bluetooth: Add support for\
  \ deferring RFCOMM connection setup\")\nReported-by: syzbot <syzkaller@googlegroups.com>\n\
  Signed-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Luiz Augusto von\
  \ Dentz <luiz.von.dentz@intel.com>\n\n## Buggy Code\n\n```c\n// Function: rfcomm_sock_setsockopt\
  \ in net/bluetooth/rfcomm/sock.c\nstatic int rfcomm_sock_setsockopt(struct socket\
  \ *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\
  \tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint err = 0;\n\tsize_t\
  \ len;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\
  \treturn rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level\
  \ != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname)\
  \ {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\
  \t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned\
  \ int, sizeof(sec), optlen);\n\t\tif (copy_from_sockptr(&sec, optval, len)) {\n\t\
  \t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level > BT_SECURITY_HIGH)\
  \ {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\trfcomm_pi(sk)->sec_level =\
  \ sec.level;\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND\
  \ && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\
  \t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\
  \t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\
  \t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\n\t\tbreak;\n\
  \n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\t\
  return err;\n}\n```\n\n```c\n// Function: rfcomm_sock_setsockopt_old in net/bluetooth/rfcomm/sock.c\n\
  static int rfcomm_sock_setsockopt_old(struct socket *sock, int optname,\n\t\tsockptr_t\
  \ optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\
  \tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname)\
  \ {\n\tcase RFCOMM_LM:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\
  \t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_FIPS) {\n\t\
  \t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_AUTH)\n\t\t\t\
  rfcomm_pi(sk)->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & RFCOMM_LM_ENCRYPT)\n\t\
  \t\trfcomm_pi(sk)->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & RFCOMM_LM_SECURE)\n\
  \t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_HIGH;\n\n\t\trfcomm_pi(sk)->role_switch\
  \ = (opt & RFCOMM_LM_MASTER);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\
  \t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\
  \n```diff\ndiff --git a/net/bluetooth/rfcomm/sock.c b/net/bluetooth/rfcomm/sock.c\n\
  index b54e8a530f55..29aa07e9db9d 100644\n--- a/net/bluetooth/rfcomm/sock.c\n+++\
  \ b/net/bluetooth/rfcomm/sock.c\n@@ -629,7 +629,7 @@ static int rfcomm_sock_setsockopt_old(struct\
  \ socket *sock, int optname,\n \n \tswitch (optname) {\n \tcase RFCOMM_LM:\n-\t\t\
  if (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n+\t\tif (bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen)) {\n \t\t\terr = -EFAULT;\n \t\t\tbreak;\n \t\t}\n\
  @@ -664,7 +664,6 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level,\
  \ int optname,\n \tstruct sock *sk = sock->sk;\n \tstruct bt_security sec;\n \t\
  int err = 0;\n-\tsize_t len;\n \tu32 opt;\n \n \tBT_DBG(\"sk %p\", sk);\n@@ -686,11\
  \ +685,9 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level, int\
  \ optname,\n \n \t\tsec.level = BT_SECURITY_LOW;\n \n-\t\tlen = min_t(unsigned int,\
  \ sizeof(sec), optlen);\n-\t\tif (copy_from_sockptr(&sec, optval, len)) {\n-\t\t\
  \terr = -EFAULT;\n+\t\terr = bt_copy_from_sockptr(&sec, sizeof(sec), optval, optlen);\n\
  +\t\tif (err)\n \t\t\tbreak;\n-\t\t}\n \n \t\tif (sec.level > BT_SECURITY_HIGH)\
  \ {\n \t\t\terr = -EINVAL;\n@@ -706,10 +703,9 @@ static int rfcomm_sock_setsockopt(struct\
  \ socket *sock, int level, int optname,\n \t\t\tbreak;\n \t\t}\n \n-\t\tif (copy_from_sockptr(&opt,\
  \ optval, sizeof(u32))) {\n-\t\t\terr = -EFAULT;\n+\t\terr = bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen);\n+\t\tif (err)\n \t\t\tbreak;\n-\t\t}\n \n \t\t\
  if (opt)\n \t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n```\n"
pattern: "## Bug Pattern\n\nIn a setsockopt handler, copying option data with a fixed-size\
  \ read (e.g., copy_from_sockptr(&dst, optval, sizeof(dst))) without validating that\
  \ the user-supplied optlen is at least that size. This can over-read the caller\u2019\
  s buffer (slab-out-of-bounds) when optlen is smaller. Correct code must check optlen\
  \ >= expected_size or use a helper that enforces this (e.g., bt_copy_from_sockptr(&dst,\
  \ sizeof(dst), optval, optlen))."
plan: "1) Program state\n\n- Keep it minimal, but track path-sensitive bounds learned\
  \ for the specific parameter optlen:\n  - REGISTER_MAP_WITH_PROGRAMSTATE(OptlenLowerBoundMap,\
  \ const MemRegion*, llvm::APSInt)\n    - Key: MemRegion of the ParmVarDecl named\
  \ \"optlen\".\n    - Value: The best-known lower bound (>=) for optlen along the\
  \ current path.\n  - Rationale: This lets us suppress false positives when the code\
  \ already checked optlen >= expected_size in the current branch.\n\n2) Core idea\
  \ and targets\n\n- Target calls that copy from sockptr_t inside setsockopt handlers\
  \ using a fixed size not validated against optlen:\n  - copy_from_sockptr(void *dst,\
  \ sockptr_t src, size_t size) \u2014 size at arg index 2.\n  - copy_from_sockptr_offset(void\
  \ *dst, sockptr_t src, size_t offset, size_t size) \u2014 size at arg index 3.\n\
  - Restrict to functions that:\n  - Have a name containing \"setsockopt\".\n  - Have\
  \ a parameter named \"optlen\".\n  - Also have a parameter named \"optval\" (heuristic\
  \ to ensure we\u2019re matching setsockopt-like handlers).\n- Do not warn if the\
  \ safe helper is used: bt_copy_from_sockptr(&dst, sizeof(dst), optval, optlen).\n\
  - Do not warn if the size expression of copy_from_sockptr refers to optlen (e.g.,\
  \ min(optlen, ...), or directly optlen), since that implies a length-aware read.\n\
  - Warn when a fixed constant size (e.g., sizeof(u32) or integer literal) is passed\
  \ and there is no path constraint ensuring optlen >= that size.\n\n3) Helper utilities\
  \ to implement\n\n- isSetSockoptHandler(const FunctionDecl *FD):\n  - Return true\
  \ if FD->getNameAsString() contains \"setsockopt\".\n  - Additionally, ensure it\
  \ has parameters named \"optlen\" and \"optval\".\n- getOptlenParm(const FunctionDecl\
  \ *FD) -> const ParmVarDecl*:\n  - Return the ParmVarDecl whose name is exactly\
  \ \"optlen\" and is of integer type.\n- isSockptrCopyCall(const CallEvent &Call,\
  \ unsigned &SizeArgIndex):\n  - If callee name is \"copy_from_sockptr\", set SizeArgIndex\
  \ = 2 and return true.\n  - If \"copy_from_sockptr_offset\", set SizeArgIndex =\
  \ 3 and return true.\n  - If \"bt_copy_from_sockptr\", return false (explicitly\
  \ do not warn).\n- getConstSizeValue(const Expr *E, CheckerContext &C, llvm::APSInt\
  \ &Out):\n  - Use EvaluateExprToInt to resolve constants and sizeof-expressions.\n\
  - sizeExprMentionsOptlen(const Expr *E, CheckerContext &C):\n  - Return true if\
  \ ExprHasName(E, \"optlen\", C) is true (the size depends on optlen).\n- getParmRegion(const\
  \ ParmVarDecl *PVD, CheckerContext &C) -> const MemRegion*:\n  - Build a DeclRefExpr\
  \ from PVD or obtain its region via C.getState()->getLValue(PVD, C.getLocationContext()).getAsRegion().\n\
  \  - (It\u2019s acceptable to leverage getMemRegionFromExpr if you construct a DRE;\
  \ otherwise, use the store manager to get the LValue region directly.)\n- updateLowerBound(ProgramStateRef\
  \ St, const MemRegion *OptlenMR, const llvm::APSInt &NewLB) -> ProgramStateRef:\n\
  \  - Read prior LB from OptlenLowerBoundMap; write back max(prior, NewLB).\n\n4)\
  \ Callbacks and their roles\n\n- checkBeginFunction(CheckerContext &C):\n  - If\
  \ current function is not a setsockopt handler (isSetSockoptHandler == false), do\
  \ nothing.\n  - If true, initialize state for this function:\n    - Identify the\
  \ \"optlen\" parameter (getOptlenParm), get its MemRegion, and ensure any old entry\
  \ for it is removed from OptlenLowerBoundMap.\n  - No transitions necessary aside\
  \ from storing the cleared state (if modified).\n\n- checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C):\n  - Only if we are in a setsockopt handler\
  \ and we can find an \"optlen\" parameter region.\n  - Extract the condition expression\
  \ (e.g., BinaryOperator).\n  - Handle comparisons where one side mentions optlen\
  \ and the other side is an integer constant or sizeof-expression (resolved via getConstSizeValue).\
  \ Support:\n    - optlen >= K or K <= optlen -> true branch LB := max(LB, K)\n \
  \   - optlen > K -> true branch LB := max(LB, K+1)\n    - optlen < K -> false branch\
  \ LB := max(LB, K)\n    - optlen <= K -> false branch LB := max(LB, K+1)\n  - Use\
  \ C.getState()->assume(Cond) to split into StTrue/StFalse and add transitions:\n\
  \    - On StTrue, update LB for the true-branch rule above.\n    - On StFalse, update\
  \ LB for the false-branch rule above.\n  - If the condition does not reference optlen\
  \ or we cannot resolve K, do nothing.\n\n- checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C):\n  - If callee is bt_copy_from_sockptr, return (safe path).\n\
  \  - If not a sockptr copy call (isSockptrCopyCall == false), return.\n  - If current\
  \ function context is not a setsockopt handler, return.\n  - Determine size argument\
  \ index (SizeArgIndex).\n  - Obtain the size expression: const Expr *SizeE = Call.getArgExpr(SizeArgIndex).\n\
  \  - If sizeExprMentionsOptlen(SizeE, C) is true, return (length-aware use; don\u2019\
  t warn).\n  - Try getConstSizeValue(SizeE, C, ConstSize). If fails, return (we only\
  \ target fixed-size reads).\n  - Find the \"optlen\" parameter and its MemRegion.\n\
  \  - Check OptlenLowerBoundMap for this region:\n    - If present and LowerBound\
  \ >= ConstSize, return (properly validated on this path).\n    - Else, warn.\n \
  \ - Reporting:\n    - Create a non-fatal error node and emit a PathSensitiveBugReport\
  \ with message like:\n      \"copy_from_sockptr uses fixed size without ensuring\
  \ optlen is large enough\"\n    - Optionally add a note range at the size argument\
  \ to highlight the fixed-size value.\n\n5) Optional minor suppressions (simple heuristics)\n\
  \n- If the nearest enclosing IfStmt (use findSpecificTypeInParents<IfStmt>(CallExpr))\
  \ has a condition that mentions \"optlen\" and contains \">=\" or \">= sizeof\"\
  , and the then-branch contains the call, you may skip the warning. This is optional;\
  \ the path-sensitive LB map should already handle typical cases.\n\n6) Summary of\
  \ detection logic\n\n- Trigger only inside setsockopt handlers (name contains \"\
  setsockopt\" and parameters include \"optval\" and \"optlen\").\n- Target calls\
  \ to copy_from_sockptr(_offset) using a fixed size argument that does not reference\
  \ optlen.\n- Use a simple path-sensitive lower-bound map updated by branch conditions\
  \ to see if the current path guarantees optlen >= that fixed size.\n- If no such\
  \ guarantee, report a bug.\n\n7) Chosen callbacks\n\n- checkBeginFunction: initialize\
  \ optlen tracking for the function.\n- checkBranchCondition: update OptlenLowerBoundMap\
  \ when conditions constrain optlen.\n- checkPostCall: detect unsafe copy_from_sockptr\
  \ usage, consult the lower bound map, and report.\n- No other callbacks are necessary."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include <tuple>\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Track a path-sensitive\
  \ lower bound for the parameter 'optlen' (if present).\nREGISTER_MAP_WITH_PROGRAMSTATE(OptlenLowerBoundMap,\
  \ const MemRegion *, llvm::APSInt)\n\nnamespace {\nclass SAGenTestChecker : public\
  \ Checker<\n                             check::BeginFunction,\n               \
  \              check::BranchCondition,\n                             check::PostCall>\
  \ {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n \
  \     : BT(new BugType(this, \"Setsockopt length validation\", \"API Misuse\"))\
  \ {}\n\n  void checkBeginFunction(CheckerContext &C) const;\n  void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n  void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\nprivate:\n  // Helper determinations\n  static\
  \ bool isSetSockoptHandler(const FunctionDecl *FD);\n  static const ParmVarDecl\
  \ *getParmByName(const FunctionDecl *FD, StringRef Name);\n  static const ParmVarDecl\
  \ *getOptlenParm(const FunctionDecl *FD);\n  static const ParmVarDecl *getOptvalParm(const\
  \ FunctionDecl *FD);\n  static const MemRegion *getParmRegion(const ParmVarDecl\
  \ *PVD, CheckerContext &C);\n\n  static bool isSockptrCopyCall(const CallEvent &Call,\
  \ CheckerContext &C,\n                                unsigned &SizeArgIndex);\n\
  \  static bool isSafeBtSockptrCopy(const CallEvent &Call, CheckerContext &C);\n\
  \  static bool getConstSizeValue(llvm::APSInt &Out, const Expr *E,\n           \
  \                     CheckerContext &C);\n  static bool sizeExprMentionsOptlen(const\
  \ Expr *E, CheckerContext &C);\n\n  static ProgramStateRef updateLowerBound(ProgramStateRef\
  \ St,\n                                          const MemRegion *OptlenMR,\n  \
  \                                        const llvm::APSInt &NewLB);\n\n  static\
  \ BinaryOperator::Opcode invertRelOp(BinaryOperator::Opcode Op);\n};\n\nbool SAGenTestChecker::isSetSockoptHandler(const\
  \ FunctionDecl *FD) {\n  if (!FD)\n    return false;\n  StringRef Name = FD->getName();\n\
  \  if (!Name.contains(\"setsockopt\"))\n    return false;\n\n  // Heuristic: require\
  \ both 'optlen' and 'optval' parameters present.\n  const ParmVarDecl *Optlen =\
  \ getParmByName(FD, \"optlen\");\n  const ParmVarDecl *Optval = getParmByName(FD,\
  \ \"optval\");\n  if (!Optlen || !Optval)\n    return false;\n\n  // 'optlen' should\
  \ be an integer type (typical in kernel handlers).\n  QualType QT = Optlen->getType();\n\
  \  if (!QT->isIntegerType())\n    return false;\n\n  return true;\n}\n\nconst ParmVarDecl\
  \ *SAGenTestChecker::getParmByName(const FunctionDecl *FD,\n                   \
  \                                StringRef Name) {\n  if (!FD)\n    return nullptr;\n\
  \  for (const ParmVarDecl *P : FD->parameters()) {\n    if (!P)\n      continue;\n\
  \    if (P->getName() == Name)\n      return P;\n  }\n  return nullptr;\n}\n\nconst\
  \ ParmVarDecl *SAGenTestChecker::getOptlenParm(const FunctionDecl *FD) {\n  return\
  \ getParmByName(FD, \"optlen\");\n}\n\nconst ParmVarDecl *SAGenTestChecker::getOptvalParm(const\
  \ FunctionDecl *FD) {\n  return getParmByName(FD, \"optval\");\n}\n\nconst MemRegion\
  \ *SAGenTestChecker::getParmRegion(const ParmVarDecl *PVD,\n                   \
  \                              CheckerContext &C) {\n  if (!PVD)\n    return nullptr;\n\
  \  MemRegionManager &MRMgr = C.getSValBuilder().getRegionManager();\n  const VarRegion\
  \ *VR = MRMgr.getVarRegion(PVD, C.getLocationContext());\n  if (!VR)\n    return\
  \ nullptr;\n  const MemRegion *Base = VR->getBaseRegion();\n  return Base;\n}\n\n\
  bool SAGenTestChecker::isSafeBtSockptrCopy(const CallEvent &Call,\n            \
  \                               CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  // Safe helper: bt_copy_from_sockptr(dst,\
  \ dst_size, src, optlen)\n  return ExprHasName(Origin, \"bt_copy_from_sockptr\"\
  , C);\n}\n\nbool SAGenTestChecker::isSockptrCopyCall(const CallEvent &Call,\n  \
  \                                       CheckerContext &C,\n                   \
  \                      unsigned &SizeArgIndex) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  if (ExprHasName(Origin, \"copy_from_sockptr_offset\"\
  , C)) {\n    SizeArgIndex = 3; // (dst, src, offset, size)\n    return true;\n \
  \ }\n  if (ExprHasName(Origin, \"copy_from_sockptr\", C)) {\n    SizeArgIndex =\
  \ 2; // (dst, src, size)\n    return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getConstSizeValue(llvm::APSInt\
  \ &Out, const Expr *E,\n                                         CheckerContext\
  \ &C) {\n  if (!E)\n    return false;\n  return EvaluateExprToInt(Out, E, C);\n\
  }\n\nbool SAGenTestChecker::sizeExprMentionsOptlen(const Expr *E,\n            \
  \                                  CheckerContext &C) {\n  if (!E)\n    return false;\n\
  \  return ExprHasName(E, \"optlen\", C);\n}\n\nProgramStateRef SAGenTestChecker::updateLowerBound(ProgramStateRef\
  \ St,\n                                                   const MemRegion *OptlenMR,\n\
  \                                                   const llvm::APSInt &NewLB) {\n\
  \  if (!St || !OptlenMR)\n    return St;\n\n  const llvm::APSInt *Prev = St->get<OptlenLowerBoundMap>(OptlenMR);\n\
  \  if (!Prev) {\n    // No previous LB, set it now.\n    return St->set<OptlenLowerBoundMap>(OptlenMR,\
  \ NewLB);\n  }\n\n  // Compare after aligning bit widths and signedness.\n  llvm::APSInt\
  \ PrevAdj = *Prev;\n  if (PrevAdj.getBitWidth() != NewLB.getBitWidth())\n    PrevAdj\
  \ = PrevAdj.extOrTrunc(NewLB.getBitWidth());\n  PrevAdj.setIsSigned(NewLB.isSigned());\n\
  \n  if (PrevAdj < NewLB) {\n    return St->set<OptlenLowerBoundMap>(OptlenMR, NewLB);\n\
  \  }\n  return St;\n}\n\nBinaryOperator::Opcode SAGenTestChecker::invertRelOp(BinaryOperator::Opcode\
  \ Op) {\n  switch (Op) {\n  case BO_LT:\n    return BO_GT;\n  case BO_GT:\n    return\
  \ BO_LT;\n  case BO_LE:\n    return BO_GE;\n  case BO_GE:\n    return BO_LE;\n \
  \ case BO_EQ:\n    return BO_EQ;\n  case BO_NE:\n    return BO_NE;\n  default:\n\
  \    return Op;\n  }\n}\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  const LocationContext *LCtx = C.getLocationContext();\n  const\
  \ FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(LCtx->getDecl());\n  if (!FD\
  \ || !isSetSockoptHandler(FD))\n    return;\n\n  const ParmVarDecl *OptlenPVD =\
  \ getOptlenParm(FD);\n  if (!OptlenPVD)\n    return;\n\n  const MemRegion *OptlenMR\
  \ = getParmRegion(OptlenPVD, C);\n  if (!OptlenMR)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  // Clear any previous learning for this param (fresh\
  \ function entry).\n  if (State->contains<OptlenLowerBoundMap>(OptlenMR)) {\n  \
  \  State = State->remove<OptlenLowerBoundMap>(OptlenMR);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\n\
  \                                            CheckerContext &C) const {\n  const\
  \ LocationContext *LCtx = C.getLocationContext();\n  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(LCtx->getDecl());\n\
  \  if (!FD || !isSetSockoptHandler(FD))\n    return;\n\n  const ParmVarDecl *OptlenPVD\
  \ = getOptlenParm(FD);\n  if (!OptlenPVD)\n    return;\n\n  const MemRegion *OptlenMR\
  \ = getParmRegion(OptlenPVD, C);\n  if (!OptlenMR)\n    return;\n\n  const Expr\
  \ *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE)\n    return;\n\n  CondE\
  \ = CondE->IgnoreParenImpCasts();\n  const auto *BO = dyn_cast<BinaryOperator>(CondE);\n\
  \  if (!BO)\n    return;\n\n  BinaryOperator::Opcode Op = BO->getOpcode();\n  //\
  \ Only relational ops are interesting.\n  if (!(Op == BO_LT || Op == BO_LE || Op\
  \ == BO_GT || Op == BO_GE ||\n        Op == BO_EQ || Op == BO_NE))\n    return;\n\
  \n  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS =\
  \ BO->getRHS()->IgnoreParenImpCasts();\n\n  bool LHSHasOptlen = sizeExprMentionsOptlen(LHS,\
  \ C);\n  bool RHSHasOptlen = sizeExprMentionsOptlen(RHS, C);\n\n  if (LHSHasOptlen\
  \ == RHSHasOptlen)\n    return; // Need exactly one side to reference optlen and\
  \ the other side to be a constant.\n\n  const Expr *OptlenSide = LHSHasOptlen ?\
  \ LHS : RHS;\n  const Expr *OtherSide = LHSHasOptlen ? RHS : LHS;\n\n  (void)OptlenSide;\
  \ // Not used beyond presence check.\n\n  llvm::APSInt K;\n  if (!getConstSizeValue(K,\
  \ OtherSide, C))\n    return; // We only handle comparisons against constants/sizeof-expr.\n\
  \n  // Normalize to the form: optlen <OpN> K\n  BinaryOperator::Opcode OpN = LHSHasOptlen\
  \ ? Op : invertRelOp(Op);\n\n  // Now split states based on the condition runtime\
  \ value.\n  ProgramStateRef State = C.getState();\n  DefinedOrUnknownSVal DV =\n\
  \      State->getSVal(CondE, C.getLocationContext()).castAs<DefinedOrUnknownSVal>();\n\
  \n  ProgramStateRef StateTrue, StateFalse;\n  std::tie(StateTrue, StateFalse) =\
  \ State->assume(DV);\n\n  // For each branch, update lower bound if we can conclude\
  \ it.\n  // True branch implications:\n  if (StateTrue) {\n    switch (OpN) {\n\
  \    case BO_GE:\n      StateTrue = updateLowerBound(StateTrue, OptlenMR, K);\n\
  \      break;\n    case BO_GT: {\n      llvm::APSInt Kp1 = K;\n      Kp1 = Kp1 +\
  \ 1;\n      StateTrue = updateLowerBound(StateTrue, OptlenMR, Kp1);\n      break;\n\
  \    }\n    case BO_EQ:\n      StateTrue = updateLowerBound(StateTrue, OptlenMR,\
  \ K);\n      break;\n    default:\n      break; // For <, <=, != true branch does\
  \ not increase LB.\n    }\n    C.addTransition(StateTrue);\n  }\n\n  // False branch\
  \ implications:\n  if (StateFalse) {\n    switch (OpN) {\n    case BO_LT:\n    \
  \  // !(optlen < K) => optlen >= K\n      StateFalse = updateLowerBound(StateFalse,\
  \ OptlenMR, K);\n      break;\n    case BO_LE: {\n      // !(optlen <= K) => optlen\
  \ > K => LB = K+1\n      llvm::APSInt Kp1 = K;\n      Kp1 = Kp1 + 1;\n      StateFalse\
  \ = updateLowerBound(StateFalse, OptlenMR, Kp1);\n      break;\n    }\n    case\
  \ BO_NE:\n      // !(optlen != K) => optlen == K => LB = K\n      StateFalse = updateLowerBound(StateFalse,\
  \ OptlenMR, K);\n      break;\n    default:\n      break; // For >=, > false branch\
  \ does not increase LB.\n    }\n    C.addTransition(StateFalse);\n  }\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call,\n                     \
  \                CheckerContext &C) const {\n  const LocationContext *LCtx = C.getLocationContext();\n\
  \  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(LCtx->getDecl());\n \
  \ if (!FD || !isSetSockoptHandler(FD))\n    return;\n\n  // Safe helper: do not\
  \ warn.\n  if (isSafeBtSockptrCopy(Call, C))\n    return;\n\n  unsigned SizeArgIndex\
  \ = 0;\n  if (!isSockptrCopyCall(Call, C, SizeArgIndex))\n    return;\n\n  if (SizeArgIndex\
  \ >= Call.getNumArgs())\n    return;\n\n  // Size argument expression\n  const Expr\
  \ *SizeE = Call.getArgExpr(SizeArgIndex);\n  if (!SizeE)\n    return;\n\n  // If\
  \ size expression mentions \"optlen\", it is length-aware -> do not warn.\n  if\
  \ (sizeExprMentionsOptlen(SizeE, C))\n    return;\n\n  llvm::APSInt SizeConst;\n\
  \  if (!getConstSizeValue(SizeConst, SizeE, C))\n    return; // Only warn for fixed-size\
  \ copies (sizeof or literal)\n\n  const ParmVarDecl *OptlenPVD = getOptlenParm(FD);\n\
  \  if (!OptlenPVD)\n    return;\n  const MemRegion *OptlenMR = getParmRegion(OptlenPVD,\
  \ C);\n  if (!OptlenMR)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  const llvm::APSInt *LBPtr = State->get<OptlenLowerBoundMap>(OptlenMR);\n\n  bool\
  \ Safe = false;\n  if (LBPtr) {\n    llvm::APSInt LB = *LBPtr;\n    // Align widths\
  \ and signedness for comparison\n    if (LB.getBitWidth() != SizeConst.getBitWidth())\n\
  \      LB = LB.extOrTrunc(SizeConst.getBitWidth());\n    LB.setIsSigned(SizeConst.isSigned());\n\
  \    // If LB >= SizeConst, it's safe on this path.\n    Safe = (LB >= SizeConst);\n\
  \  }\n\n  if (!Safe) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n \
  \   if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT,\n        \"copy_from_sockptr uses fixed size without ensuring optlen\
  \ is large enough\",\n        N);\n    if (SizeE)\n      R->addRange(SizeE->getSourceRange());\n\
  \    C.emitReport(std::move(R));\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect fixed-size copy_from_sockptr\
  \ in setsockopt without validating optlen\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
