_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: c6087b82a9146826564a55c5ca0164cac40348f5
commit_type: Buffer-Overflow
index: 6
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Type.h\"\n#include \"llvm/ADT/APInt.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(SizeBoundMap,\
  \ const MemRegion*, const MemRegion*)\n\nnamespace {\nclass SAGenTestChecker : public\
  \ Checker<check::PreCall, check::Bind> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unbounded user copy\
  \ into fixed-size buffer\", \"Memory Safety\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      bool isCopyFromUser(const CallEvent &Call, CheckerContext &C) const;\n  \
  \    bool getFixedCharArrayInfo(const DeclRefExpr *DRE, CheckerContext &C,\n   \
  \                              llvm::APInt &ArraySize, const MemRegion *&ArrayReg)\
  \ const;\n      bool countExprIsClampedToArray(const Expr *CountE, StringRef BufName,\n\
  \                                     const MemRegion *BufReg, CheckerContext &C)\
  \ const;\n      const Expr *getRHSForBind(const Stmt *S, const MemRegion *LHSReg,\
  \ CheckerContext &C) const;\n};\n\nstatic bool isCharLike(QualType QT) {\n  QT =\
  \ QT.getUnqualifiedType();\n  if (const Type *Ty = QT.getTypePtrOrNull()) {\n  \
  \  if (Ty->isCharType())\n      return true;\n    if (const BuiltinType *BT = dyn_cast<BuiltinType>(Ty))\
  \ {\n      return BT->getKind() == BuiltinType::SChar ||\n             BT->getKind()\
  \ == BuiltinType::UChar;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isCopyFromUser(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n  // Use text-based name check as suggested\
  \ to be robust.\n  return ExprHasName(OriginExpr, \"copy_from_user\", C);\n}\n\n\
  bool SAGenTestChecker::getFixedCharArrayInfo(const DeclRefExpr *DRE, CheckerContext\
  \ &C,\n                                             llvm::APInt &ArraySize,\n  \
  \                                           const MemRegion *&ArrayReg) const {\n\
  \  if (!DRE)\n    return false;\n\n  // Check that the DeclRefExpr refers to a fixed-size\
  \ array and get its size.\n  if (!getArraySizeFromExpr(ArraySize, DRE))\n    return\
  \ false;\n\n  // Verify the element type is char-like (char/signed char/unsigned\
  \ char).\n  const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n\
  \    return false;\n\n  QualType QT = VD->getType();\n  const ConstantArrayType\
  \ *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr());\n  if (!CAT)\n    return\
  \ false;\n\n  if (!isCharLike(CAT->getElementType()))\n    return false;\n\n  //\
  \ Get the MemRegion for the array variable.\n  ArrayReg = getMemRegionFromExpr(DRE,\
  \ C);\n  if (!ArrayReg)\n    return false;\n  ArrayReg = ArrayReg->getBaseRegion();\n\
  \  if (!ArrayReg)\n    return false;\n\n  return true;\n}\n\nbool SAGenTestChecker::countExprIsClampedToArray(const\
  \ Expr *CountE, StringRef BufName,\n                                           \
  \      const MemRegion *BufReg, CheckerContext &C) const {\n  if (!CountE)\n   \
  \ return false;\n\n  // 1) Constant check: if CountE is a constant <= sizeof(buf),\
  \ it's safe.\n  // We cannot compute sizeof(buf) here without array size, so this\
  \ branch\n  // will be handled by the caller when they know the array size.\n  //\
  \ Here we only handle text/state checks.\n\n  // 2) Textual clamp using sizeof and\
  \ optionally min/min_t.\n  bool HasSizeof = ExprHasName(CountE, \"sizeof\", C);\n\
  \  bool MentionsBuf = ExprHasName(CountE, BufName, C);\n  bool HasMin = ExprHasName(CountE,\
  \ \"min\", C) || ExprHasName(CountE, \"min_t\", C);\n\n  if (HasSizeof && MentionsBuf)\n\
  \    return true; // e.g., sizeof(buf) - 1, or sizeof(buf)\n\n  if (HasMin && HasSizeof\
  \ && MentionsBuf)\n    return true; // e.g., min(n, sizeof(buf) - 1)\n\n  // 3)\
  \ State-based clamp: has this CountE been previously bounded to this array?\n  const\
  \ MemRegion *CountReg = getMemRegionFromExpr(CountE, C);\n  if (CountReg) {\n  \
  \  CountReg = CountReg->getBaseRegion();\n    if (CountReg) {\n      ProgramStateRef\
  \ State = C.getState();\n      const MemRegion *BoundTo = State->get<SizeBoundMap>(CountReg);\n\
  \      if (BoundTo && BoundTo->getBaseRegion() == BufReg)\n        return true;\n\
  \    }\n  }\n\n  return false;\n}\n\nconst Expr *SAGenTestChecker::getRHSForBind(const\
  \ Stmt *S, const MemRegion *LHSReg, CheckerContext &C) const {\n  if (!S || !LHSReg)\n\
  \    return nullptr;\n\n  if (const auto *BO = dyn_cast<BinaryOperator>(S)) {\n\
  \    if (BO->isAssignmentOp())\n      return BO->getRHS();\n  }\n\n  if (const auto\
  \ *DS = dyn_cast<DeclStmt>(S)) {\n    if (!DS->isSingleDecl()) {\n      // Try to\
  \ match the decl whose region equals LHSReg.\n      for (const Decl *D : DS->decls())\
  \ {\n        if (const auto *VD = dyn_cast<VarDecl>(D)) {\n          if (!VD->hasInit())\n\
  \            continue;\n          // Construct the region for this VD and compare.\n\
  \          const MemRegion *VR =\n              C.getStoreManager().getRegionManager().getVarRegion(VD,\
  \ C.getLocationContext());\n          if (!VR) continue;\n          VR = VR->getBaseRegion();\n\
  \          if (!VR) continue;\n          if (VR == LHSReg)\n            return VD->getInit();\n\
  \        }\n      }\n    } else {\n      const Decl *D = DS->getSingleDecl();\n\
  \      if (const auto *VD = dyn_cast<VarDecl>(D)) {\n        if (VD->hasInit())\n\
  \          return VD->getInit();\n      }\n    }\n  }\n\n  return nullptr;\n}\n\n\
  void SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  if (!isCopyFromUser(Call, C))\n    return;\n\n  if (Call.getNumArgs() < 3)\n\
  \    return;\n\n  const Expr *DstE = Call.getArgExpr(0);\n  const Expr *CountE =\
  \ Call.getArgExpr(2);\n  if (!DstE || !CountE)\n    return;\n\n  // Find the underlying\
  \ DeclRefExpr of the destination buffer.\n  const DeclRefExpr *BufDRE = findSpecificTypeInChildren<DeclRefExpr>(DstE);\n\
  \  if (!BufDRE)\n    return;\n\n  // Get fixed-size char array info and its region.\n\
  \  llvm::APInt ArraySizeBits;\n  const MemRegion *BufReg = nullptr;\n  if (!getFixedCharArrayInfo(BufDRE,\
  \ C, ArraySizeBits, BufReg))\n    return;\n\n  // Heuristic safety checks on CountE:\n\
  \  // A) Constant evaluation\n  llvm::APSInt EvalRes;\n  if (EvaluateExprToInt(EvalRes,\
  \ CountE, C)) {\n    // If the count is a constant and <= array size, it's safe.\n\
  \    // Compare as unsigned (size_t) semantics.\n    if (EvalRes.isUnsigned() ||\
  \ EvalRes >= 0) {\n      llvm::APInt CountVal = EvalRes.isUnsigned()\n         \
  \                        ? EvalRes.getUnsigned()\n                             \
  \    : EvalRes.getExtValue();\n      if (CountVal.ule(ArraySizeBits))\n        return;\
  \ // safe\n      // If CountVal definitely exceeds ArraySize, report.\n      //\
  \ Note: copying exactly sizeof(buf) bytes is acceptable for raw bytes.\n      //\
  \ We'll treat strictly greater than array size as unsafe.\n      if (CountVal.ugt(ArraySizeBits))\
  \ {\n        ExplodedNode *N = C.generateNonFatalErrorNode();\n        if (!N)\n\
  \          return;\n        auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \            *BT, \"Unbounded copy_from_user into fixed-size buffer; clamp length\
  \ to sizeof(buf)-1\", N);\n        R->addRange(Call.getSourceRange());\n       \
  \ C.emitReport(std::move(R));\n        return;\n      }\n    }\n  } else {\n   \
  \ // B) Text/state-based checks\n    StringRef BufName = BufDRE->getDecl()->getName();\n\
  \    if (countExprIsClampedToArray(CountE, BufName, BufReg, C))\n      return; //\
  \ safe\n  }\n\n  // If none of the safety checks passed, report.\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Unbounded copy_from_user into fixed-size buffer; clamp length to sizeof(buf)-1\"\
  , N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n}\n\
  \nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\n\
  \    return;\n  LHSReg = LHSReg->getBaseRegion();\n  if (!LHSReg)\n    return;\n\
  \n  const Expr *RHS = getRHSForBind(S, LHSReg, C);\n  if (!RHS)\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n\n  // Case 1: RHS is a clamp expression\
  \ involving sizeof(array) [with optional min/min_t].\n  const DeclRefExpr *ArrayDRE\
  \ = findSpecificTypeInChildren<DeclRefExpr>(RHS);\n  llvm::APInt ArrSizeBits;\n\
  \  const MemRegion *ArrayReg = nullptr;\n  bool HasArray = false;\n  if (ArrayDRE)\
  \ {\n    HasArray = getFixedCharArrayInfo(ArrayDRE, C, ArrSizeBits, ArrayReg);\n\
  \  }\n\n  if (HasArray) {\n    bool HasSizeof = ExprHasName(RHS, \"sizeof\", C);\n\
  \    bool MentionsBuf = ExprHasName(RHS, ArrayDRE->getDecl()->getName(), C);\n \
  \   bool HasMin = ExprHasName(RHS, \"min\", C) || ExprHasName(RHS, \"min_t\", C);\n\
  \n    if ((HasSizeof && MentionsBuf) || (HasMin && HasSizeof && MentionsBuf)) {\n\
  \      // Record that LHSReg is bounded to ArrayReg.\n      State = State->set<SizeBoundMap>(LHSReg,\
  \ ArrayReg->getBaseRegion());\n      C.addTransition(State);\n      return;\n  \
  \  }\n  }\n\n  // Case 2: Propagate from another variable: X = Y; and Y is known\
  \ bounded to some array.\n  if (const auto *RHSDRE = dyn_cast<DeclRefExpr>(RHS->IgnoreParenCasts()))\
  \ {\n    const MemRegion *RHSReg = getMemRegionFromExpr(RHSDRE, C);\n    if (RHSReg)\
  \ {\n      RHSReg = RHSReg->getBaseRegion();\n      if (RHSReg) {\n        const\
  \ MemRegion *BoundTo = State->get<SizeBoundMap>(RHSReg);\n        if (BoundTo) {\n\
  \          State = State->set<SizeBoundMap>(LHSReg, BoundTo->getBaseRegion());\n\
  \          C.addTransition(State);\n          return;\n        }\n      }\n    }\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unbounded copy_from_user into fixed-size buffers and suggests\
  \ clamping length\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nscsi: lpfc: Prevent lpfc_debugfs_lockstat_write()\
  \ buffer overflow\n\nA static code analysis tool flagged the possibility of buffer\
  \ overflow when\nusing copy_from_user() for a debugfs entry.\n\nCurrently, it is\
  \ possible that copy_from_user() copies more bytes than what\nwould fit in the mybuf\
  \ char array.  Add a min() restriction check between\nsizeof(mybuf) - 1 and nbytes\
  \ passed from the userspace buffer to protect\nagainst buffer overflow.\n\nLink:\
  \ https://lore.kernel.org/r/20230301231626.9621-2-justintee8345@gmail.com\nSigned-off-by:\
  \ Justin Tee <justin.tee@broadcom.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>\n\
  \n## Buggy Code\n\n```c\n// Function: lpfc_debugfs_lockstat_write in drivers/scsi/lpfc/lpfc_debugfs.c\n\
  static ssize_t\nlpfc_debugfs_lockstat_write(struct file *file, const char __user\
  \ *buf,\n\t\t\t    size_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug =\
  \ file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\
  \tstruct lpfc_sli4_hdw_queue *qp;\n\tchar mybuf[64];\n\tchar *pbuf;\n\tint i;\n\n\
  \tmemset(mybuf, 0, sizeof(mybuf));\n\n\tif (copy_from_user(mybuf, buf, nbytes))\n\
  \t\treturn -EFAULT;\n\tpbuf = &mybuf[0];\n\n\tif ((strncmp(pbuf, \"reset\", strlen(\"\
  reset\")) == 0) ||\n\t    (strncmp(pbuf, \"zero\", strlen(\"zero\")) == 0)) {\n\t\
  \tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\t\tqp = &phba->sli4_hba.hdwq[i];\n\
  \t\t\tqp->lock_conflict.alloc_xri_get = 0;\n\t\t\tqp->lock_conflict.alloc_xri_put\
  \ = 0;\n\t\t\tqp->lock_conflict.free_xri = 0;\n\t\t\tqp->lock_conflict.wq_access\
  \ = 0;\n\t\t\tqp->lock_conflict.alloc_pvt_pool = 0;\n\t\t\tqp->lock_conflict.mv_from_pvt_pool\
  \ = 0;\n\t\t\tqp->lock_conflict.mv_to_pub_pool = 0;\n\t\t\tqp->lock_conflict.mv_to_pvt_pool\
  \ = 0;\n\t\t\tqp->lock_conflict.free_pvt_pool = 0;\n\t\t\tqp->lock_conflict.free_pub_pool\
  \ = 0;\n\t\t\tqp->lock_conflict.wq_access = 0;\n\t\t}\n\t}\n\treturn nbytes;\n}\n\
  ```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/scsi/lpfc/lpfc_debugfs.c\
  \ b/drivers/scsi/lpfc/lpfc_debugfs.c\nindex f5252e45a48a..3e365e5e194a 100644\n\
  --- a/drivers/scsi/lpfc/lpfc_debugfs.c\n+++ b/drivers/scsi/lpfc/lpfc_debugfs.c\n\
  @@ -2157,10 +2157,13 @@ lpfc_debugfs_lockstat_write(struct file *file, const char\
  \ __user *buf,\n \tchar mybuf[64];\n \tchar *pbuf;\n \tint i;\n+\tsize_t bsize;\n\
  \ \n \tmemset(mybuf, 0, sizeof(mybuf));\n \n-\tif (copy_from_user(mybuf, buf, nbytes))\n\
  +\tbsize = min(nbytes, (sizeof(mybuf) - 1));\n+\n+\tif (copy_from_user(mybuf, buf,\
  \ bsize))\n \t\treturn -EFAULT;\n \tpbuf = &mybuf[0];\n \n@@ -2181,7 +2184,7 @@\
  \ lpfc_debugfs_lockstat_write(struct file *file, const char __user *buf,\n \t\t\t\
  qp->lock_conflict.wq_access = 0;\n \t\t}\n \t}\n-\treturn nbytes;\n+\treturn bsize;\n\
  \ }\n #endif\n \n```\n"
pattern: "## Bug Pattern\n\nCopying user-provided data into a fixed-size buffer without\
  \ bounding the copy length by the buffer size:\n\n- Pattern:\n  - Fixed-size buffer\
  \ on stack/heap:\n    - char buf[64];\n  - Untrusted length from userspace (e.g.,\
  \ write(2) nbytes) used directly:\n    - copy_from_user(buf, user_ptr, nbytes);\n\
  \  - No clamp like min(nbytes, sizeof(buf) - 1) before copy.\n  - Often also followed\
  \ by treating buf as a string and/or returning nbytes.\n\nThis leads to potential\
  \ buffer overflow (and non-NUL-terminated strings)."
plan: "Plan\n\n1) Program state\n- Use one program state map to reduce false positives\
  \ by tracking variables that were previously clamped to a specific array size.\n\
  \  - REGISTER_MAP_WITH_PROGRAMSTATE(SizeBoundMap, const MemRegion*, const MemRegion*)\n\
  \    - Key: MemRegion of a scalar/size variable used as a length/count.\n    - Value:\
  \ MemRegion of the array it was bounded to (e.g., via sizeof(array) or min(...,\
  \ sizeof(array))).\n\n2) Callbacks to use\n- checkPreCall: Detect unsafe copy_from_user\
  \ calls.\n- checkBind: Learn when a size variable is clamped to an array\u2019s\
  \ size (via sizeof/min), and propagate that information through assignments/initializers.\n\
  \n3) checkPreCall: detect unbounded copy_from_user into fixed-size buffers\n- Identify\
  \ the target function:\n  - If Call.getCalleeIdentifier()->getName() != \"copy_from_user\"\
  , return.\n- Extract arguments:\n  - DestArg = Call.getArgExpr(0)\n  - CountArg\
  \ = Call.getArgExpr(2)\n- Find the destination array and its size:\n  - Use findSpecificTypeInChildren<DeclRefExpr>(DestArg)\
  \ to get the underlying DeclRefExpr of the buffer variable (handles mybuf, &mybuf[0],\
  \ mybuf + 0, etc.).\n  - If no DeclRefExpr found, return (we only warn for actual\
  \ fixed-size arrays).\n  - Get the array size with getArraySizeFromExpr(ArraySize,\
  \ DeclRefExpr).\n    - If it\u2019s not a ConstantArrayType, return.\n  - Optionally\
  \ reduce false positives by restricting to character arrays:\n    - From the ConstantArrayType,\
  \ fetch element type and only proceed if it\u2019s a character type (char, unsigned\
  \ char).\n- Determine if the count is safely bounded:\n  - If EvaluateExprToInt(EvalRes,\
  \ CountArg, C) succeeds:\n    - If EvalRes <= ArraySize: consider safe, return.\n\
  \    - Else: definitely unsafe, report.\n  - Else (non-constant CountArg), apply\
  \ progressively more conservative safeness checks:\n    - Textual clamp checks using\
  \ ExprHasName on CountArg:\n      - If ExprHasName(CountArg, \"sizeof\") AND ExprHasName(CountArg,\
  \ <bufName>) => safe, return.\n      - If ExprHasName(CountArg, \"min\") OR ExprHasName(CountArg,\
  \ \"min_t\"), AND ExprHasName(CountArg, \"sizeof\"), AND ExprHasName(CountArg, <bufName>)\
  \ => safe, return.\n        - Note: <bufName> is from DeclRefExpr->getDecl()->getNameAsString().\n\
  \    - State-based clamp checks via SizeBoundMap:\n      - Get CountArg\u2019s MemRegion\
  \ with getMemRegionFromExpr(CountArg, C). If non-null:\n        - Look up in State->get<SizeBoundMap>(CountRegion).\
  \ If present and equals DestArrayRegion (use getMemRegionFromExpr on the DeclRefExpr\
  \ for the array), consider safe, return.\n- If none of the above safeness checks\
  \ pass, report:\n  - Message: \"Unbounded copy_from_user into fixed-size buffer;\
  \ clamp length to sizeof(buf)-1\"\n  - Create a non-fatal error node and emit a\
  \ PathSensitiveBugReport. Add the call\u2019s source range as the primary location.\n\
  \n4) checkBind: learn \u201Ccount\u201D variables clamped by sizeof(array)\n- Goal:\
  \ Populate SizeBoundMap so that later calls passing a pre-clamped variable are not\
  \ flagged.\n- For S in checkBind:\n  - Extract LHS variable region:\n    - If Loc\
  \ is a loc::MemRegionVal, get LHSRegion. If null, return.\n  - Find the RHS expression\
  \ from S:\n    - If S is a BinaryOperator with assignment, RHS = B->getRHS().\n\
  \    - Else if S is a DeclStmt with initializer, for each VarDecl with init, RHS\
  \ = VD->getInit().\n    - Otherwise, return.\n  - Try to detect if RHS clamps to\
  \ a specific array:\n    - Find an array DeclRefExpr on RHS: ArrayDRE = findSpecificTypeInChildren<DeclRefExpr>(RHS).\n\
  \    - Verify it is a constant array using getArraySizeFromExpr(ArraySize, ArrayDRE).\
  \ If false, skip (we only care about fixed-size buffers).\n    - Heuristic safety\
  \ patterns on RHS:\n      - If ExprHasName(RHS, \"sizeof\") AND ExprHasName(RHS,\
  \ ArrayDRE->getDecl()->getName()) => likely bounded.\n      - Optionally, also accept\
  \ when ExprHasName(RHS, \"min\") OR ExprHasName(RHS, \"min_t\") alongside the conditions\
  \ above.\n    - If bounded, set SizeBoundMap[LHSRegion] = ArrayRegion where ArrayRegion\
  \ = getMemRegionFromExpr(ArrayDRE, C).\n  - Propagate previously learned bounds\
  \ through aliases:\n    - If RHS is a DeclRefExpr of a scalar variable (count-like)\
  \ whose MemRegion is in SizeBoundMap (i.e., X = Y; and Y was known bounded to array\
  \ A), then set SizeBoundMap[LHSRegion] = SizeBoundMap[RHSRegion].\n- Do not over-propagate\
  \ through arbitrary expressions; only propagate:\n  - Direct sizeof/min expressions\
  \ involving a fixed-size array.\n  - Direct copies from a variable that is already\
  \ in SizeBoundMap.\n\n5) Notes and heuristics to minimize false positives\n- Only\
  \ warn when destination is a fixed-size array (ConstantArrayType).\n- Prefer restricting\
  \ to character arrays for this checker\u2019s intent (copying user data into char\
  \ buffers).\n- Treat expressions explicitly mentioning sizeof(buf) (and optionally\
  \ min/min_t) as safe.\n- Treat explicitly constant CountArg <= sizeof(buf) as safe.\n\
  - Recognize precomputed clamped variables via SizeBoundMap mapping to the same array.\n\
  - Do not require \u201C- 1\u201D to be present; copying up to sizeof(buf) is acceptable\
  \ for raw bytes. The message can suggest sizeof(buf) - 1 to hint at string usage\
  \ without enforcing it.\n\n6) Utility functions used\n- findSpecificTypeInChildren<DeclRefExpr>(Expr):\
  \ to recover the underlying array from complex address expressions.\n- getArraySizeFromExpr(ArraySize,\
  \ Expr): to extract constant array size.\n- ExprHasName(Expr, \"sizeof\"/\"min\"\
  /bufName, C): to recognize textual clamp patterns.\n- getMemRegionFromExpr(Expr,\
  \ C): to build/compare MemRegions for SizeBoundMap.\n- EvaluateExprToInt(EvalRes,\
  \ CountArg, C): to detect constant counts.\n\n7) Bug reporting\n- Create a checker-local\
  \ BugType (e.g., \"Unbounded user copy into fixed-size buffer\").\n- In checkPreCall\
  \ when issuing a report, generate a non-fatal error node and emit a PathSensitiveBugReport\
  \ with a concise message:\n  - \"Unbounded copy_from_user into fixed-size buffer;\
  \ clamp length to sizeof(buf)-1\"\n- Point to the copy_from_user call and, if useful,\
  \ add a note pointing to the destination buffer declaration (DeclRefExpr location)."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Type.h\"\n#include \"llvm/ADT/APInt.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(SizeBoundMap,\
  \ const MemRegion*, const MemRegion*)\n\nnamespace {\nclass SAGenTestChecker : public\
  \ Checker<check::PreCall, check::Bind> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unbounded user copy\
  \ into fixed-size buffer\", \"Memory Safety\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      bool isCopyFromUser(const CallEvent &Call, CheckerContext &C) const;\n  \
  \    bool getFixedCharArrayInfo(const DeclRefExpr *DRE, CheckerContext &C,\n   \
  \                              llvm::APInt &ArraySize, const MemRegion *&ArrayReg)\
  \ const;\n      bool countExprIsClampedToArray(const Expr *CountE, StringRef BufName,\n\
  \                                     const MemRegion *BufReg, CheckerContext &C)\
  \ const;\n      const Expr *getRHSForBind(const Stmt *S, const MemRegion *LHSReg,\
  \ CheckerContext &C) const;\n};\n\nstatic bool isCharLike(QualType QT) {\n  QT =\
  \ QT.getUnqualifiedType();\n  if (const Type *Ty = QT.getTypePtrOrNull()) {\n  \
  \  if (Ty->isCharType())\n      return true;\n    if (const BuiltinType *BT = dyn_cast<BuiltinType>(Ty))\
  \ {\n      return BT->getKind() == BuiltinType::SChar ||\n             BT->getKind()\
  \ == BuiltinType::UChar;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isCopyFromUser(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n  // Use text-based name check as suggested\
  \ to be robust.\n  return ExprHasName(OriginExpr, \"copy_from_user\", C);\n}\n\n\
  bool SAGenTestChecker::getFixedCharArrayInfo(const DeclRefExpr *DRE, CheckerContext\
  \ &C,\n                                             llvm::APInt &ArraySize,\n  \
  \                                           const MemRegion *&ArrayReg) const {\n\
  \  if (!DRE)\n    return false;\n\n  // Check that the DeclRefExpr refers to a fixed-size\
  \ array and get its size.\n  if (!getArraySizeFromExpr(ArraySize, DRE))\n    return\
  \ false;\n\n  // Verify the element type is char-like (char/signed char/unsigned\
  \ char).\n  const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n\
  \    return false;\n\n  QualType QT = VD->getType();\n  const ConstantArrayType\
  \ *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr());\n  if (!CAT)\n    return\
  \ false;\n\n  if (!isCharLike(CAT->getElementType()))\n    return false;\n\n  //\
  \ Get the MemRegion for the array variable.\n  ArrayReg = getMemRegionFromExpr(DRE,\
  \ C);\n  if (!ArrayReg)\n    return false;\n  ArrayReg = ArrayReg->getBaseRegion();\n\
  \  if (!ArrayReg)\n    return false;\n\n  return true;\n}\n\nbool SAGenTestChecker::countExprIsClampedToArray(const\
  \ Expr *CountE, StringRef BufName,\n                                           \
  \      const MemRegion *BufReg, CheckerContext &C) const {\n  if (!CountE)\n   \
  \ return false;\n\n  // 1) Constant check: if CountE is a constant <= sizeof(buf),\
  \ it's safe.\n  // We cannot compute sizeof(buf) here without array size, so this\
  \ branch\n  // will be handled by the caller when they know the array size.\n  //\
  \ Here we only handle text/state checks.\n\n  // 2) Textual clamp using sizeof and\
  \ optionally min/min_t.\n  bool HasSizeof = ExprHasName(CountE, \"sizeof\", C);\n\
  \  bool MentionsBuf = ExprHasName(CountE, BufName, C);\n  bool HasMin = ExprHasName(CountE,\
  \ \"min\", C) || ExprHasName(CountE, \"min_t\", C);\n\n  if (HasSizeof && MentionsBuf)\n\
  \    return true; // e.g., sizeof(buf) - 1, or sizeof(buf)\n\n  if (HasMin && HasSizeof\
  \ && MentionsBuf)\n    return true; // e.g., min(n, sizeof(buf) - 1)\n\n  // 3)\
  \ State-based clamp: has this CountE been previously bounded to this array?\n  const\
  \ MemRegion *CountReg = getMemRegionFromExpr(CountE, C);\n  if (CountReg) {\n  \
  \  CountReg = CountReg->getBaseRegion();\n    if (CountReg) {\n      ProgramStateRef\
  \ State = C.getState();\n      auto BoundToPtr = State->get<SizeBoundMap>(CountReg);\n\
  \      if (BoundToPtr && (*BoundToPtr)->getBaseRegion() == BufReg)\n        return\
  \ true;\n    }\n  }\n\n  return false;\n}\n\nconst Expr *SAGenTestChecker::getRHSForBind(const\
  \ Stmt *S, const MemRegion *LHSReg, CheckerContext &C) const {\n  if (!S || !LHSReg)\n\
  \    return nullptr;\n\n  if (const auto *BO = dyn_cast<BinaryOperator>(S)) {\n\
  \    if (BO->isAssignmentOp())\n      return BO->getRHS();\n  }\n\n  if (const auto\
  \ *DS = dyn_cast<DeclStmt>(S)) {\n    if (!DS->isSingleDecl()) {\n      // Try to\
  \ match the decl whose region equals LHSReg.\n      for (const Decl *D : DS->decls())\
  \ {\n        if (const auto *VD = dyn_cast<VarDecl>(D)) {\n          if (!VD->hasInit())\n\
  \            continue;\n          // Construct the region for this VD and compare.\n\
  \          const MemRegion *VR =\n              C.getStoreManager().getRegionManager().getVarRegion(VD,\
  \ C.getLocationContext());\n          if (!VR) continue;\n          VR = VR->getBaseRegion();\n\
  \          if (!VR) continue;\n          if (VR == LHSReg)\n            return VD->getInit();\n\
  \        }\n      }\n    } else {\n      const Decl *D = DS->getSingleDecl();\n\
  \      if (const auto *VD = dyn_cast<VarDecl>(D)) {\n        if (VD->hasInit())\n\
  \          return VD->getInit();\n      }\n    }\n  }\n\n  return nullptr;\n}\n\n\
  void SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  if (!isCopyFromUser(Call, C))\n    return;\n\n  if (Call.getNumArgs() < 3)\n\
  \    return;\n\n  const Expr *DstE = Call.getArgExpr(0);\n  const Expr *CountE =\
  \ Call.getArgExpr(2);\n  if (!DstE || !CountE)\n    return;\n\n  // Find the underlying\
  \ DeclRefExpr of the destination buffer.\n  const DeclRefExpr *BufDRE = findSpecificTypeInChildren<DeclRefExpr>(DstE);\n\
  \  if (!BufDRE)\n    return;\n\n  // Get fixed-size char array info and its region.\n\
  \  llvm::APInt ArraySizeBits;\n  const MemRegion *BufReg = nullptr;\n  if (!getFixedCharArrayInfo(BufDRE,\
  \ C, ArraySizeBits, BufReg))\n    return;\n\n  // Heuristic safety checks on CountE:\n\
  \  // A) Constant evaluation\n  llvm::APSInt EvalRes;\n  if (EvaluateExprToInt(EvalRes,\
  \ CountE, C)) {\n    // If the count is a constant and <= array size, it's safe.\n\
  \    // Compare as unsigned (size_t) semantics.\n    if (EvalRes.isUnsigned() ||\
  \ EvalRes.isNonNegative()) {\n      uint64_t CountVal = EvalRes.isUnsigned()\n \
  \                             ? EvalRes.getZExtValue()\n                       \
  \       : static_cast<uint64_t>(EvalRes.getSExtValue());\n      uint64_t ArraySize\
  \ = ArraySizeBits.getZExtValue();\n      if (CountVal <= ArraySize)\n        return;\
  \ // safe\n      // If CountVal definitely exceeds ArraySize, report.\n      //\
  \ Note: copying exactly sizeof(buf) bytes is acceptable for raw bytes.\n      //\
  \ We'll treat strictly greater than array size as unsafe.\n      if (CountVal >\
  \ ArraySize) {\n        ExplodedNode *N = C.generateNonFatalErrorNode();\n     \
  \   if (!N)\n          return;\n        auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \            *BT, \"Unbounded copy_from_user into fixed-size buffer; clamp length\
  \ to sizeof(buf)-1\", N);\n        R->addRange(Call.getSourceRange());\n       \
  \ C.emitReport(std::move(R));\n        return;\n      }\n    }\n  } else {\n   \
  \ // B) Text/state-based checks\n    StringRef BufName = BufDRE->getDecl()->getName();\n\
  \    if (countExprIsClampedToArray(CountE, BufName, BufReg, C))\n      return; //\
  \ safe\n  }\n\n  // If none of the safety checks passed, report.\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Unbounded copy_from_user into fixed-size buffer; clamp length to sizeof(buf)-1\"\
  , N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n}\n\
  \nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\n\
  \    return;\n  LHSReg = LHSReg->getBaseRegion();\n  if (!LHSReg)\n    return;\n\
  \n  const Expr *RHS = getRHSForBind(S, LHSReg, C);\n  if (!RHS)\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n\n  // Case 1: RHS is a clamp expression\
  \ involving sizeof(array) [with optional min/min_t].\n  const DeclRefExpr *ArrayDRE\
  \ = findSpecificTypeInChildren<DeclRefExpr>(RHS);\n  llvm::APInt ArrSizeBits;\n\
  \  const MemRegion *ArrayReg = nullptr;\n  bool HasArray = false;\n  if (ArrayDRE)\
  \ {\n    HasArray = getFixedCharArrayInfo(ArrayDRE, C, ArrSizeBits, ArrayReg);\n\
  \  }\n\n  if (HasArray) {\n    bool HasSizeof = ExprHasName(RHS, \"sizeof\", C);\n\
  \    bool MentionsBuf = ExprHasName(RHS, ArrayDRE->getDecl()->getName(), C);\n \
  \   bool HasMin = ExprHasName(RHS, \"min\", C) || ExprHasName(RHS, \"min_t\", C);\n\
  \n    if ((HasSizeof && MentionsBuf) || (HasMin && HasSizeof && MentionsBuf)) {\n\
  \      // Record that LHSReg is bounded to ArrayReg.\n      State = State->set<SizeBoundMap>(LHSReg,\
  \ ArrayReg->getBaseRegion());\n      C.addTransition(State);\n      return;\n  \
  \  }\n  }\n\n  // Case 2: Propagate from another variable: X = Y; and Y is known\
  \ bounded to some array.\n  if (const auto *RHSDRE = dyn_cast<DeclRefExpr>(RHS->IgnoreParenCasts()))\
  \ {\n    const MemRegion *RHSReg = getMemRegionFromExpr(RHSDRE, C);\n    if (RHSReg)\
  \ {\n      RHSReg = RHSReg->getBaseRegion();\n      if (RHSReg) {\n        auto\
  \ BoundToPtr = State->get<SizeBoundMap>(RHSReg);\n        if (BoundToPtr) {\n  \
  \        State = State->set<SizeBoundMap>(LHSReg, (*BoundToPtr)->getBaseRegion());\n\
  \          C.addTransition(State);\n          return;\n        }\n      }\n    }\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unbounded copy_from_user into fixed-size buffers and suggests\
  \ clamping length\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
