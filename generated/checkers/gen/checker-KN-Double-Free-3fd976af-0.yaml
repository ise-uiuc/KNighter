_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3fd976afe9743110f20a23f93b7ff9693f2be4bf
commit_type: Double-Free
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"\
  clang/AST/DeclCXX.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\
  \n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nusing\
  \ namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom\
  \ program state needed.\n // If necessary\n\nnamespace {\n\nstatic bool isPinctrlMapRecord(QualType\
  \ QT) {\n  if (const auto *RT = QT->getAs<RecordType>()) {\n    const RecordDecl\
  \ *RD = RT->getDecl();\n    if (!RD)\n      return false;\n    IdentifierInfo *II\
  \ = RD->getIdentifier();\n    if (!II)\n      return false;\n    return II->getName()\
  \ == \"pinctrl_map\";\n  }\n  return false;\n}\n\nstatic bool isPinctrlMapPtr(QualType\
  \ QT) {\n  if (const auto *PT = QT->getAs<PointerType>()) {\n    return isPinctrlMapRecord(PT->getPointeeType());\n\
  \  }\n  return false;\n}\n\nstatic bool isPinctrlMapPtrPtr(QualType QT) {\n  if\
  \ (const auto *PTOuter = QT->getAs<PointerType>()) {\n    QualType Middle = PTOuter->getPointeeType();\n\
  \    if (const auto *PTInner = Middle->getAs<PointerType>()) {\n      return isPinctrlMapRecord(PTInner->getPointeeType());\n\
  \    }\n  }\n  return false;\n}\n\nstatic const Expr *ignoreCastsAndParens(const\
  \ Expr *E) {\n  if (!E) return nullptr;\n  return E->IgnoreParenImpCasts();\n}\n\
  \nstatic const Expr *ignoreCastsParensAndAddrOf(const Expr *E) {\n  if (!E) return\
  \ nullptr;\n  E = E->IgnoreParenImpCasts();\n  if (const auto *UO = dyn_cast<UnaryOperator>(E))\
  \ {\n    if (UO->getOpcode() == UO_AddrOf)\n      return UO->getSubExpr()->IgnoreParenImpCasts();\n\
  \  }\n  return E;\n}\n\nstatic const FunctionDecl *getFunctionFromExpr(const Expr\
  \ *E) {\n  E = ignoreCastsParensAndAddrOf(E);\n  if (!E) return nullptr;\n  if (const\
  \ auto *DRE = dyn_cast<DeclRefExpr>(E)) {\n    return dyn_cast<FunctionDecl>(DRE->getDecl());\n\
  \  }\n  return nullptr;\n}\n\nstatic bool isManualFreeName(StringRef Name) {\n \
  \ return Name == \"pinconf_generic_dt_free_map\" || Name == \"pinctrl_utils_free_map\"\
  ;\n}\n\nstatic bool isDevmAllocatorName(StringRef Name) {\n  return Name == \"devm_kcalloc\"\
  \ ||\n         Name == \"devm_kmalloc\" ||\n         Name == \"devm_kmalloc_array\"\
  \ ||\n         Name == \"devm_kzalloc\" ||\n         Name == \"devm_kmemdup\" ||\n\
  \         Name == \"devm_krealloc\";\n}\n\nstatic const CallExpr *getDirectCall(const\
  \ Expr *E) {\n  E = ignoreCastsAndParens(E);\n  return dyn_cast_or_null<CallExpr>(E);\n\
  }\n\nclass SAGenTestChecker : public Checker<check::ASTDecl<VarDecl>,\n        \
  \                                check::ASTDecl<FunctionDecl>,\n               \
  \                         check::ASTCodeBody> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   // Functions wired as .dt_node_to_map in a struct that also sets .dt_free_map\n\
  \   // to a manual-free helper.\n   mutable llvm::SmallPtrSet<const FunctionDecl*,\
  \ 32> DangerousDtNodeToMapFns;\n\n   // Track which functions we've already scanned\
  \ to avoid duplicate reports.\n   mutable llvm::SmallPtrSet<const FunctionDecl*,\
  \ 32> ScannedFns;\n\n   // Track function definitions we've seen (may be scanned\
  \ later when we\n   // discover the struct wiring).\n   mutable llvm::SmallPtrSet<const\
  \ FunctionDecl*, 64> SeenFunctionDefs;\n\n   public:\n      SAGenTestChecker() :\
  \ BT(new BugType(this, \"Double free: devm-managed map with dt_free_map\", \"Memory\
  \ Management\")) {}\n\n      void checkASTDecl(const VarDecl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const;\n      void checkASTDecl(const FunctionDecl *D,\
  \ AnalysisManager &Mgr, BugReporter &BR) const;\n      void checkASTCodeBody(const\
  \ Decl *D, AnalysisManager &Mgr, BugReporter &BR) const;\n\n   private:\n\n    \
  \  const ParmVarDecl *findMapParam(const FunctionDecl *FD) const;\n      void scanFunctionForBug(const\
  \ FunctionDecl *FD, AnalysisManager &Mgr, BugReporter &BR) const;\n\n      // Helper\
  \ to add to Dangerous set and try immediate scanning if body known.\n      void\
  \ markDangerousAndMaybeScan(const FunctionDecl *FD, AnalysisManager &Mgr, BugReporter\
  \ &BR) const;\n};\n\nclass OpsInitVisitor : public RecursiveASTVisitor<OpsInitVisitor>\
  \ {\n  const ASTContext &Ctx;\npublic:\n  const FunctionDecl *NodeToMapFn = nullptr;\n\
  \  bool HasManualFree = false;\n\n  explicit OpsInitVisitor(const ASTContext &Ctx)\
  \ : Ctx(Ctx) {}\n\n  bool VisitDesignatedInitExpr(DesignatedInitExpr *DIE) {\n \
  \   // Check each designator\n    for (unsigned i = 0, e = DIE->getNumDesignators();\
  \ i != e; ++i) {\n      const DesignatedInitExpr::Designator &Des = DIE->getDesignator(i);\n\
  \      if (!Des.isFieldDesignator())\n        continue;\n\n      IdentifierInfo\
  \ *II = Des.getFieldName();\n      if (!II)\n        continue;\n\n      StringRef\
  \ FieldName = II->getName();\n      const Expr *Init = DIE->getInit();\n      if\
  \ (!Init)\n        continue;\n\n      if (FieldName == \"dt_node_to_map\") {\n \
  \       const FunctionDecl *FD = getFunctionFromExpr(Init);\n        if (FD)\n \
  \         NodeToMapFn = FD;\n      } else if (FieldName == \"dt_free_map\") {\n\
  \        const FunctionDecl *FD = getFunctionFromExpr(Init);\n        if (FD) {\n\
  \          IdentifierInfo *FII = FD->getIdentifier();\n          if (FII && isManualFreeName(FII->getName()))\n\
  \            HasManualFree = true;\n        } else {\n          // Fallback: try\
  \ to match by text is not available, so ignore.\n        }\n      }\n    }\n   \
  \ return true;\n  }\n};\n\nclass DevmMapBodyVisitor : public RecursiveASTVisitor<DevmMapBodyVisitor>\
  \ {\npublic:\n  const ParmVarDecl *MapParam = nullptr;\n  ASTContext &Ctx;\n\n \
  \ bool Found = false;\n  const CallExpr *BadCallSite = nullptr;        // devm_*\
  \ call to anchor report\n  const BinaryOperator *BadAssignSite = nullptr; // fallback\
  \ anchor\n\n  // Track local variables of type struct pinctrl_map* that are assigned\
  \ from devm_*.\n  llvm::SmallPtrSet<const VarDecl*, 16> DevmVars;\n  llvm::DenseMap<const\
  \ VarDecl*, const CallExpr*> DevmVarToCall;\n\n  // RHS vars used in *map = var\
  \ assignments to resolve after traversal if needed.\n  llvm::SmallVector<const VarDecl*,\
  \ 8> PendingRHSVarsInMapAssign;\n\n  explicit DevmMapBodyVisitor(const ParmVarDecl\
  \ *MP, ASTContext &C) : MapParam(MP), Ctx(C) {}\n\n  bool VisitDeclStmt(DeclStmt\
  \ *DS) {\n    if (Found) return true;\n    for (Decl *D : DS->decls()) {\n     \
  \ if (auto *VD = dyn_cast<VarDecl>(D)) {\n        QualType T = VD->getType();\n\
  \        if (!isPinctrlMapPtr(T))\n          continue;\n\n        const Expr *Init\
  \ = VD->getInit();\n        if (!Init) continue;\n        const CallExpr *CE = getDirectCall(Init);\n\
  \        if (!CE) continue;\n        if (const FunctionDecl *Callee = CE->getDirectCallee())\
  \ {\n          IdentifierInfo *II = Callee->getIdentifier();\n          if (II &&\
  \ isDevmAllocatorName(II->getName())) {\n            DevmVars.insert(VD);\n    \
  \        DevmVarToCall[VD] = CE;\n          }\n        }\n      }\n    }\n    return\
  \ true;\n  }\n\n  bool VisitBinaryOperator(BinaryOperator *BO) {\n    if (Found)\
  \ return true;\n    if (BO->getOpcode() != BO_Assign)\n      return true;\n\n  \
  \  const Expr *LHS = ignoreCastsAndParens(BO->getLHS());\n    const Expr *RHS =\
  \ BO->getRHS();\n\n    // Case: var = devm_*(...)\n    if (const auto *LHS_DRE =\
  \ dyn_cast<DeclRefExpr>(LHS)) {\n      const VarDecl *VD = dyn_cast<VarDecl>(LHS_DRE->getDecl());\n\
  \      if (VD && isPinctrlMapPtr(VD->getType())) {\n        if (const CallExpr *CE\
  \ = getDirectCall(RHS)) {\n          if (const FunctionDecl *Callee = CE->getDirectCallee())\
  \ {\n            if (IdentifierInfo *II = Callee->getIdentifier()) {\n         \
  \     if (isDevmAllocatorName(II->getName())) {\n                DevmVars.insert(VD);\n\
  \                DevmVarToCall[VD] = CE;\n              }\n            }\n     \
  \     }\n        }\n      }\n    }\n\n    // Case: *map = ...\n    if (const auto\
  \ *UO = dyn_cast<UnaryOperator>(LHS)) {\n      if (UO->getOpcode() == UO_Deref)\
  \ {\n        const Expr *Sub = ignoreCastsAndParens(UO->getSubExpr());\n       \
  \ if (const auto *DRE = dyn_cast<DeclRefExpr>(Sub)) {\n          if (DRE->getDecl()\
  \ == MapParam) {\n            // RHS direct devm_* call\n            if (const CallExpr\
  \ *CE = getDirectCall(RHS)) {\n              if (const FunctionDecl *Callee = CE->getDirectCallee())\
  \ {\n                if (IdentifierInfo *II = Callee->getIdentifier()) {\n     \
  \             if (isDevmAllocatorName(II->getName())) {\n                    Found\
  \ = true;\n                    BadCallSite = CE;\n                    BadAssignSite\
  \ = BO;\n                    return true;\n                  }\n               \
  \ }\n              }\n            }\n            // RHS is a variable that might\
  \ be from devm_* earlier\n            const Expr *R = ignoreCastsAndParens(RHS);\n\
  \            if (const auto *RHS_DRE = dyn_cast<DeclRefExpr>(R)) {\n           \
  \   if (const VarDecl *RVD = dyn_cast<VarDecl>(RHS_DRE->getDecl())) {\n        \
  \        PendingRHSVarsInMapAssign.push_back(RVD);\n              }\n          \
  \  }\n            BadAssignSite = BO; // remember as fallback anchor\n         \
  \ }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  void finalize() {\n\
  \    if (Found) return;\n    // Resolve pending RHS vars\n    for (const VarDecl\
  \ *VD : PendingRHSVarsInMapAssign) {\n      if (DevmVars.contains(VD)) {\n     \
  \   Found = true;\n        auto It = DevmVarToCall.find(VD);\n        if (It !=\
  \ DevmVarToCall.end())\n          BadCallSite = It->second;\n        break;\n  \
  \    }\n    }\n  }\n};\n\nconst ParmVarDecl *SAGenTestChecker::findMapParam(const\
  \ FunctionDecl *FD) const {\n  for (const ParmVarDecl *P : FD->parameters()) {\n\
  \    if (isPinctrlMapPtrPtr(P->getType()))\n      return P;\n  }\n  return nullptr;\n\
  }\n\nvoid SAGenTestChecker::scanFunctionForBug(const FunctionDecl *FD, AnalysisManager\
  \ &Mgr, BugReporter &BR) const {\n  if (!FD || ScannedFns.contains(FD))\n    return;\n\
  \  if (!FD->doesThisDeclarationHaveABody())\n    return;\n\n  const ParmVarDecl\
  \ *MapParam = findMapParam(FD);\n  if (!MapParam)\n    return;\n\n  Stmt *Body =\
  \ const_cast<Stmt*>(FD->getBody());\n  if (!Body)\n    return;\n\n  DevmMapBodyVisitor\
  \ V(MapParam, Mgr.getASTContext());\n  V.TraverseStmt(Body);\n  V.finalize();\n\n\
  \  if (V.Found) {\n    const Stmt *Anchor = V.BadCallSite ? static_cast<const Stmt*>(V.BadCallSite)\n\
  \                                       : static_cast<const Stmt*>(V.BadAssignSite\
  \ ? V.BadAssignSite : Body);\n    PathDiagnosticLocation Loc = PathDiagnosticLocation::createBegin(\n\
  \        Anchor, BR.getSourceManager(), Mgr.getAnalysisDeclContext(FD));\n    auto\
  \ R = std::make_unique<BasicBugReport>(\n        *BT, \"devm_* allocation for pinctrl\
  \ map mixed with dt_free_map causes double free\", Loc);\n    if (V.BadCallSite)\n\
  \      R->addRange(V.BadCallSite->getSourceRange());\n    BR.emitReport(std::move(R));\n\
  \  }\n\n  ScannedFns.insert(FD);\n}\n\nvoid SAGenTestChecker::markDangerousAndMaybeScan(const\
  \ FunctionDecl *FD, AnalysisManager &Mgr, BugReporter &BR) const {\n  if (!FD)\n\
  \    return;\n  DangerousDtNodeToMapFns.insert(FD);\n  // If we've already seen\
  \ the body, or even if not, try scanning now.\n  if (FD->doesThisDeclarationHaveABody())\n\
  \    scanFunctionForBug(FD, Mgr, BR);\n}\n\nvoid SAGenTestChecker::checkASTDecl(const\
  \ VarDecl *D, AnalysisManager &Mgr, BugReporter &BR) const {\n  if (!D)\n    return;\n\
  \  const Expr *Init = D->getInit();\n  if (!Init)\n    return;\n\n  OpsInitVisitor\
  \ V(Mgr.getASTContext());\n  V.TraverseStmt(const_cast<Expr*>(Init));\n\n  if (V.NodeToMapFn\
  \ && V.HasManualFree) {\n    markDangerousAndMaybeScan(V.NodeToMapFn, Mgr, BR);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkASTDecl(const FunctionDecl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const {\n  if (!D)\n    return;\n  if (!D->doesThisDeclarationHaveABody())\n\
  \    return;\n\n  SeenFunctionDefs.insert(D);\n\n  // If we already know it's dangerous,\
  \ scan immediately.\n  if (DangerousDtNodeToMapFns.contains(D))\n    scanFunctionForBug(D,\
  \ Mgr, BR);\n}\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const {\n  const auto *FD = dyn_cast<FunctionDecl>(D);\n\
  \  if (!FD)\n    return;\n\n  // If it's marked dangerous, scan; otherwise, it may\
  \ be discovered later\n  // when the struct variable with .dt_free_map is encountered.\n\
  \  if (DangerousDtNodeToMapFns.contains(FD))\n    scanFunctionForBug(FD, Mgr, BR);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects devm_* allocation for pinctrl map when dt_free_map is used, causing\
  \ double free\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\npinctrl: nuvoton: fix a double free in ma35_pinctrl_dt_node_to_map_func()\n\
  \n'new_map' is allocated using devm_* which takes care of freeing the\nallocated\
  \ data on device removal, call to\n\n\t.dt_free_map = pinconf_generic_dt_free_map\n\
  \ndouble frees the map as pinconf_generic_dt_free_map() calls\npinctrl_utils_free_map().\n\
  \nFix this by using kcalloc() instead of auto-managed devm_kcalloc().\n\nCc: stable@vger.kernel.org\n\
  Fixes: f805e356313b (\"pinctrl: nuvoton: Add ma35d1 pinctrl and GPIO driver\")\n\
  Reported-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>\nSigned-off-by:\
  \ Harshit Mogalapalli <harshit.m.mogalapalli@oracle.com>\nLink: https://lore.kernel.org/20241010205237.1245318-1-harshit.m.mogalapalli@oracle.com\n\
  Signed-off-by: Linus Walleij <linus.walleij@linaro.org>\n\n## Buggy Code\n\n```c\n\
  // Function: ma35_pinctrl_dt_node_to_map_func in drivers/pinctrl/nuvoton/pinctrl-ma35.c\n\
  static int ma35_pinctrl_dt_node_to_map_func(struct pinctrl_dev *pctldev,\n\t\t\t\
  \t\t    struct device_node *np,\n\t\t\t\t\t    struct pinctrl_map **map,\n\t\t\t\
  \t\t    unsigned int *num_maps)\n{\n\tstruct ma35_pinctrl *npctl = pinctrl_dev_get_drvdata(pctldev);\n\
  \tstruct ma35_pin_group *grp;\n\tstruct pinctrl_map *new_map;\n\tstruct device_node\
  \ *parent;\n\tint map_num = 1;\n\tint i;\n\n\t/*\n\t * first find the group of this\
  \ node and check if we need create\n\t * config maps for pins\n\t */\n\tgrp = ma35_pinctrl_find_group_by_name(npctl,\
  \ np->name);\n\tif (!grp) {\n\t\tdev_err(npctl->dev, \"unable to find group for\
  \ node %s\\n\", np->name);\n\t\treturn -EINVAL;\n\t}\n\n\tmap_num += grp->npins;\n\
  \tnew_map = devm_kcalloc(pctldev->dev, map_num, sizeof(*new_map), GFP_KERNEL);\n\
  \tif (!new_map)\n\t\treturn -ENOMEM;\n\n\t*map = new_map;\n\t*num_maps = map_num;\n\
  \t/* create mux map */\n\tparent = of_get_parent(np);\n\tif (!parent)\n\t\treturn\
  \ -EINVAL;\n\n\tnew_map[0].type = PIN_MAP_TYPE_MUX_GROUP;\n\tnew_map[0].data.mux.function\
  \ = parent->name;\n\tnew_map[0].data.mux.group = np->name;\n\tof_node_put(parent);\n\
  \n\tnew_map++;\n\tfor (i = 0; i < grp->npins; i++) {\n\t\tnew_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;\n\
  \t\tnew_map[i].data.configs.group_or_pin = pin_get_name(pctldev, grp->pins[i]);\n\
  \t\tnew_map[i].data.configs.configs = grp->settings[i].configs;\n\t\tnew_map[i].data.configs.num_configs\
  \ = grp->settings[i].nconfigs;\n\t}\n\tdev_dbg(pctldev->dev, \"maps: function %s\
  \ group %s num %d\\n\",\n\t\t(*map)->data.mux.function, (*map)->data.mux.group,\
  \ map_num);\n\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/pinctrl/nuvoton/pinctrl-ma35.c\
  \ b/drivers/pinctrl/nuvoton/pinctrl-ma35.c\nindex 1fa00a23534a..59c4e7c6cdde 100644\n\
  --- a/drivers/pinctrl/nuvoton/pinctrl-ma35.c\n+++ b/drivers/pinctrl/nuvoton/pinctrl-ma35.c\n\
  @@ -218,7 +218,7 @@ static int ma35_pinctrl_dt_node_to_map_func(struct pinctrl_dev\
  \ *pctldev,\n \t}\n \n \tmap_num += grp->npins;\n-\tnew_map = devm_kcalloc(pctldev->dev,\
  \ map_num, sizeof(*new_map), GFP_KERNEL);\n+\tnew_map = kcalloc(map_num, sizeof(*new_map),\
  \ GFP_KERNEL);\n \tif (!new_map)\n \t\treturn -ENOMEM;\n \n```\n"
pattern: "## Bug Pattern\n\nAllocating a pinctrl map with devm_* (device-managed)\
  \ in dt_node_to_map() while also using a .dt_free_map callback (e.g., pinconf_generic_dt_free_map\
  \ \u2192 pinctrl_utils_free_map) that manually kfree()s the same map, leading to\
  \ a double free.\n\nExample:\nnew_map = devm_kcalloc(dev, map_num, sizeof(*new_map),\
  \ GFP_KERNEL);\n...\n.dt_free_map = pinconf_generic_dt_free_map;  // eventually\
  \ kfree(new_map)\n\nCorrect pattern: use kcalloc()/kfree() (or avoid manual free)\
  \ consistently; do not mix devm_* allocations with manual free callbacks."
plan: "1) Program state\n- No custom program state is needed. This checker is most\
  \ naturally implemented as an AST-level consistency check:\n  - Detect that a function\
  \ is wired as .dt_node_to_map in a struct where .dt_free_map is set to a manual-free\
  \ helper (pinconf_generic_dt_free_map or pinctrl_utils_free_map).\n  - Inside that\
  \ function body, detect devm_* allocations used for the returned pinctrl map (either\
  \ directly assigned to *map or via a temporary).\n\n2) Callbacks and implementation\
  \ details\n\nStep A \u2014 Collect the wiring between .dt_node_to_map and .dt_free_map\
  \ (checkASTDecl)\n- Goal: Find structs that initialize both:\n  - .dt_node_to_map\
  \ = some_function\n  - .dt_free_map = pinconf_generic_dt_free_map (or pinctrl_utils_free_map)\n\
  - Data kept in checker instance (no ProgramState):\n  - Map< const VarDecl*, { const\
  \ FunctionDecl* NodeToMapFn; bool HasManualFree; } >\n  - Set< const FunctionDecl*\
  \ > DangerousDtNodeToMapFns (all NodeToMap functions in structs that also set .dt_free_map\
  \ to a manual-free helper)\n\n- How to implement:\n  1) In checkASTDecl(const FunctionDecl*,\
  \ ...) do nothing.\n  2) In checkASTDecl(const VarDecl *D, ...):\n     - If D has\
  \ an initializer and its type is a RecordType (struct), inspect the initializer:\n\
  \       - If InitListExpr/DesignatedInitExprs are present, iterate each designated\
  \ initializer.\n       - For each DesignatedInitExpr, read the field designator\
  \ name:\n         - If it\u2019s \"dt_node_to_map\": extract the referenced FunctionDecl\
  \ (handle '&fn', implicit casts, etc.).\n         - If it\u2019s \"dt_free_map\"\
  : extract the referenced entity and check name equality against:\n           - \"\
  pinconf_generic_dt_free_map\"\n           - \"pinctrl_utils_free_map\"\n       \
  \    Use ExprHasName(...) helper on the initializer expression to robustly match\
  \ the name.\n       - Store the findings in the map for this VarDecl (NodeToMapFn\
  \ and HasManualFree).\n     - If after processing the initializer we have both NodeToMapFn\
  \ != nullptr and HasManualFree == true, insert NodeToMapFn into DangerousDtNodeToMapFns.\n\
  \nNotes:\n- You don\u2019t need to depend on the type being specifically struct\
  \ pinctrl_ops or pinctrl_desc; just rely on field names in designated initializers.\n\
  - Handle both direct DeclRefExpr and address-of function (&func) patterns.\n\nStep\
  \ B \u2014 Within dangerous .dt_node_to_map functions, detect devm_* allocation\
  \ of pinctrl_map used as the returned map (checkASTCodeBody)\n- Goal: For any FunctionDecl\
  \ F in DangerousDtNodeToMapFns, ensure it does not allocate the pinctrl map with\
  \ devm_*.\n- Detection patterns to look for in F\u2019s body:\n  1) Direct assignment:\n\
  \     - BinaryOperator (BO_Assign) where LHS is dereference of the 'map' parameter,\
  \ i.e., UnaryOperator '*' applied to the parameter that has the type struct pinctrl_map\
  \ **.\n     - RHS is a CallExpr to a known devm allocator (e.g., devm_kcalloc, devm_kmalloc,\
  \ devm_kmalloc_array, devm_kzalloc).\n  2) Indirect assignment via a temporary:\n\
  \     - BinaryOperator (BO_Assign) where LHS is a variable Var of type struct pinctrl_map*\
  \ and RHS is a CallExpr to a known devm allocator.\n     - Later in the same function,\
  \ a BinaryOperator (BO_Assign) where LHS is UnaryOperator '*' on the 'map' parameter\
  \ (struct pinctrl_map **), and RHS uses the same Var (match by DeclRefExpr to Var\
  \ or use ExprHasName to match Var\u2019s name).\n\n- How to implement:\n  1) First,\
  \ identify the 'map' parameter:\n     - Iterate F->parameters().\n     - Find a\
  \ ParmVarDecl whose type is a pointer-to-pointer to a record named \"pinctrl_map\"\
  :\n       - For the type T:\n         - If T is PointerType, get PointeeType P1.\n\
  \         - If P1 is PointerType, get PointeeType P2.\n         - If P2 is RecordType\
  \ whose RecordDecl has name \"pinctrl_map\", this is the 'map' parameter.\n  2)\
  \ Walk the body statements (a simple recursive AST walk or a stack-based traversal)\
  \ and collect:\n     - All assignments (BinaryOperator with opcode BO_Assign).\n\
  \     - For each assignment:\n       - Case 1 (direct):\n         - If LHS is UnaryOperator\
  \ '*' of DeclRefExpr to the 'map' parameter:\n           - If RHS is a CallExpr\
  \ whose callee name matches a known devm allocator (see list below), record a violation\
  \ immediately.\n       - Case 2 (indirect via temp):\n         - If LHS is a DeclRefExpr\
  \ bound to a local VarDecl of type struct pinctrl_map* and RHS is a CallExpr to\
  \ a known devm allocator, remember this VarDecl as DevmAllocMapVar and remember\
  \ the CallExpr for reporting.\n     - After collecting DevmAllocMapVar, scan assignments\
  \ again for \"*map = DevmAllocMapVar\". To match RHS:\n       - Prefer matching\
  \ via DeclRefExpr to the same VarDecl.\n       - If casts or implicit conversions\
  \ exist, use ExprHasName(RHS, VarDecl->getName()) as a fallback.\n  3) If either\
  \ pattern is found, create a report.\n\n- Known devm allocators to match (callee\
  \ name exact match):\n  - \"devm_kcalloc\"\n  - \"devm_kmalloc\"\n  - \"devm_kmalloc_array\"\
  \n  - \"devm_kzalloc\"\n  - \"devm_kmemdup\"\n  - \"devm_krealloc\"\n  (This list\
  \ is conservative for map allocations; matching any of these is fine since mixing\
  \ with dt_free_map is the core issue.)\n\n- Reporting:\n  - Use checkASTCodeBody\u2019\
  s BugReporter &BR to emit a BasicBugReport.\n  - Bug type: \"Double free: devm-managed\
  \ map with dt_free_map\".\n  - Message: \"devm_* allocation for pinctrl map mixed\
  \ with dt_free_map causes double free\".\n  - Location: prefer the CallExpr of the\
  \ devm_* allocation; if only indirect evidence is available, anchor at the \"*map\
  \ =\" assignment.\n  - Only report once per function body (guard with a local boolean).\n\
  \nStep C \u2014 Helper details and utilities\n- Function/type helpers:\n  - Use\
  \ ExprHasName(E, \"pinconf_generic_dt_free_map\", C) and ExprHasName(E, \"pinctrl_utils_free_map\"\
  , C) when checking .dt_free_map initializers in DesignatedInitExpr.\n  - To robustly\
  \ get the function from a designated initializer:\n    - Strip ImplicitCastExpr\
  \ and UnaryOperator(UO_AddrOf).\n    - Expect DeclRefExpr -> FunctionDecl.\n  -\
  \ To check pinctrl_map types:\n    - For a QualType QT:\n      - PointerType level\
  \ 1: struct pinctrl_map*\n      - PointerType level 2: struct pinctrl_map**\n  \
  \    - Use getAs<PointerType>(), then getPointeeType().getTypePtr()->getAs<RecordType>()\
  \ and compare RecordDecl->getName() to \"pinctrl_map\".\n\n- AST search:\n  - A\
  \ simple manual traversal of Stmt children is enough. Optionally, use findSpecificTypeInChildren<CallExpr>\
  \ or <BinaryOperator> for convenience in tight scopes, but a small DFS over the\
  \ function body is straightforward.\n\n3) Summary of concise logic\n- checkASTDecl:\n\
  \  - Parse struct variable initializers with designated initializers.\n  - If a\
  \ variable sets both .dt_node_to_map = F and .dt_free_map is a manual-free function,\
  \ add F to DangerousDtNodeToMapFns.\n- checkASTCodeBody:\n  - If D is a FunctionDecl\
  \ F present in DangerousDtNodeToMapFns:\n    - Find the parameter of type struct\
  \ pinctrl_map **.\n    - Detect either:\n      - \"*map = devm_* (...)\" directly,\
  \ or\n      - \"Var: pinctrl_map* = devm_* (...)\" and later \"*map = Var\".\n \
  \   - If found, emit a BasicBugReport at the devm_* call (or the assignment) with\
  \ the short message.\n\n4) Report text\n- Use a short message: \"devm_* allocation\
  \ for pinctrl map mixed with dt_free_map causes double free\"."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"\
  clang/AST/DeclCXX.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\
  \n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nusing\
  \ namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom\
  \ program state needed.\n// If necessary\n\nnamespace {\n\nstatic bool isPinctrlMapRecord(QualType\
  \ QT) {\n  if (const auto *RT = QT->getAs<RecordType>()) {\n    const RecordDecl\
  \ *RD = RT->getDecl();\n    if (!RD)\n      return false;\n    IdentifierInfo *II\
  \ = RD->getIdentifier();\n    if (!II)\n      return false;\n    return II->getName()\
  \ == \"pinctrl_map\";\n  }\n  return false;\n}\n\nstatic bool isPinctrlMapPtr(QualType\
  \ QT) {\n  if (const auto *PT = QT->getAs<PointerType>()) {\n    return isPinctrlMapRecord(PT->getPointeeType());\n\
  \  }\n  return false;\n}\n\nstatic bool isPinctrlMapPtrPtr(QualType QT) {\n  if\
  \ (const auto *PTOuter = QT->getAs<PointerType>()) {\n    QualType Middle = PTOuter->getPointeeType();\n\
  \    if (const auto *PTInner = Middle->getAs<PointerType>()) {\n      return isPinctrlMapRecord(PTInner->getPointeeType());\n\
  \    }\n  }\n  return false;\n}\n\nstatic const Expr *ignoreCastsAndParens(const\
  \ Expr *E) {\n  if (!E) return nullptr;\n  return E->IgnoreParenImpCasts();\n}\n\
  \nstatic const Expr *ignoreCastsParensAndAddrOf(const Expr *E) {\n  if (!E) return\
  \ nullptr;\n  E = E->IgnoreParenImpCasts();\n  if (const auto *UO = dyn_cast<UnaryOperator>(E))\
  \ {\n    if (UO->getOpcode() == UO_AddrOf)\n      return UO->getSubExpr()->IgnoreParenImpCasts();\n\
  \  }\n  return E;\n}\n\nstatic const FunctionDecl *getFunctionFromExpr(const Expr\
  \ *E) {\n  E = ignoreCastsParensAndAddrOf(E);\n  if (!E) return nullptr;\n  if (const\
  \ auto *DRE = dyn_cast<DeclRefExpr>(E)) {\n    return dyn_cast<FunctionDecl>(DRE->getDecl());\n\
  \  }\n  return nullptr;\n}\n\nstatic bool isManualFreeName(StringRef Name) {\n \
  \ return Name == \"pinconf_generic_dt_free_map\" || Name == \"pinctrl_utils_free_map\"\
  ;\n}\n\nstatic bool isDevmAllocatorName(StringRef Name) {\n  return Name == \"devm_kcalloc\"\
  \ ||\n         Name == \"devm_kmalloc\" ||\n         Name == \"devm_kmalloc_array\"\
  \ ||\n         Name == \"devm_kzalloc\" ||\n         Name == \"devm_kmemdup\" ||\n\
  \         Name == \"devm_krealloc\";\n}\n\nstatic const CallExpr *getDirectCall(const\
  \ Expr *E) {\n  E = ignoreCastsAndParens(E);\n  return dyn_cast_or_null<CallExpr>(E);\n\
  }\n\nclass SAGenTestChecker : public Checker<check::ASTDecl<VarDecl>,\n        \
  \                                check::ASTDecl<FunctionDecl>,\n               \
  \                         check::ASTCodeBody> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   // Functions wired as .dt_node_to_map in a struct that also sets .dt_free_map\n\
  \   // to a manual-free helper.\n   mutable llvm::SmallPtrSet<const FunctionDecl*,\
  \ 32> DangerousDtNodeToMapFns;\n\n   // Track which functions we've already scanned\
  \ to avoid duplicate reports.\n   mutable llvm::SmallPtrSet<const FunctionDecl*,\
  \ 32> ScannedFns;\n\n   // Track function definitions we've seen (may be scanned\
  \ later when we\n   // discover the struct wiring).\n   mutable llvm::SmallPtrSet<const\
  \ FunctionDecl*, 32> SeenFunctionDefs;\n\n   public:\n      SAGenTestChecker() :\
  \ BT(new BugType(this, \"Double free: devm-managed map with dt_free_map\", \"Memory\
  \ Management\")) {}\n\n      void checkASTDecl(const VarDecl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const;\n      void checkASTDecl(const FunctionDecl *D,\
  \ AnalysisManager &Mgr, BugReporter &BR) const;\n      void checkASTCodeBody(const\
  \ Decl *D, AnalysisManager &Mgr, BugReporter &BR) const;\n\n   private:\n\n    \
  \  const ParmVarDecl *findMapParam(const FunctionDecl *FD) const;\n      void scanFunctionForBug(const\
  \ FunctionDecl *FD, AnalysisManager &Mgr, BugReporter &BR) const;\n\n      // Helper\
  \ to add to Dangerous set and try immediate scanning if body known.\n      void\
  \ markDangerousAndMaybeScan(const FunctionDecl *FD, AnalysisManager &Mgr, BugReporter\
  \ &BR) const;\n};\n\nclass OpsInitVisitor : public RecursiveASTVisitor<OpsInitVisitor>\
  \ {\n  const ASTContext &Ctx;\npublic:\n  const FunctionDecl *NodeToMapFn = nullptr;\n\
  \  bool HasManualFree = false;\n\n  explicit OpsInitVisitor(const ASTContext &Ctx)\
  \ : Ctx(Ctx) {}\n\n  bool VisitDesignatedInitExpr(DesignatedInitExpr *DIE) {\n \
  \   // Check each designator\n    for (const auto &Des : DIE->designators()) {\n\
  \      if (!Des.isFieldDesignator())\n        continue;\n\n      const IdentifierInfo\
  \ *II = Des.getFieldName();\n      if (!II)\n        continue;\n\n      StringRef\
  \ FieldName = II->getName();\n      const Expr *Init = DIE->getInit();\n      if\
  \ (!Init)\n        continue;\n\n      if (FieldName == \"dt_node_to_map\") {\n \
  \       const FunctionDecl *FD = getFunctionFromExpr(Init);\n        if (FD)\n \
  \         NodeToMapFn = FD;\n      } else if (FieldName == \"dt_free_map\") {\n\
  \        const FunctionDecl *FD = getFunctionFromExpr(Init);\n        if (FD) {\n\
  \          IdentifierInfo *FII = FD->getIdentifier();\n          if (FII && isManualFreeName(FII->getName()))\n\
  \            HasManualFree = true;\n        } else {\n          // Fallback: try\
  \ to match by text is not available, so ignore.\n        }\n      }\n    }\n   \
  \ return true;\n  }\n};\n\nclass DevmMapBodyVisitor : public RecursiveASTVisitor<DevmMapBodyVisitor>\
  \ {\npublic:\n  const ParmVarDecl *MapParam = nullptr;\n  ASTContext &Ctx;\n\n \
  \ bool Found = false;\n  const CallExpr *BadCallSite = nullptr;        // devm_*\
  \ call to anchor report\n  const BinaryOperator *BadAssignSite = nullptr; // fallback\
  \ anchor\n\n  // Track local variables of type struct pinctrl_map* that are assigned\
  \ from devm_*.\n  llvm::SmallPtrSet<const VarDecl*, 16> DevmVars;\n  llvm::DenseMap<const\
  \ VarDecl*, const CallExpr*> DevmVarToCall;\n\n  // RHS vars used in *map = var\
  \ assignments to resolve after traversal if needed.\n  llvm::SmallVector<const VarDecl*,\
  \ 8> PendingRHSVarsInMapAssign;\n\n  explicit DevmMapBodyVisitor(const ParmVarDecl\
  \ *MP, ASTContext &C) : MapParam(MP), Ctx(C) {}\n\n  bool VisitDeclStmt(DeclStmt\
  \ *DS) {\n    if (Found) return true;\n    for (Decl *D : DS->decls()) {\n     \
  \ if (auto *VD = dyn_cast<VarDecl>(D)) {\n        QualType T = VD->getType();\n\
  \        if (!isPinctrlMapPtr(T))\n          continue;\n\n        const Expr *Init\
  \ = VD->getInit();\n        if (!Init) continue;\n        const CallExpr *CE = getDirectCall(Init);\n\
  \        if (!CE) continue;\n        if (const FunctionDecl *Callee = CE->getDirectCallee())\
  \ {\n          IdentifierInfo *II = Callee->getIdentifier();\n          if (II &&\
  \ isDevmAllocatorName(II->getName())) {\n            DevmVars.insert(VD);\n    \
  \        DevmVarToCall[VD] = CE;\n          }\n        }\n      }\n    }\n    return\
  \ true;\n  }\n\n  bool VisitBinaryOperator(BinaryOperator *BO) {\n    if (Found)\
  \ return true;\n    if (BO->getOpcode() != BO_Assign)\n      return true;\n\n  \
  \  const Expr *LHS = ignoreCastsAndParens(BO->getLHS());\n    const Expr *RHS =\
  \ BO->getRHS();\n\n    // Case: var = devm_*(...)\n    if (const auto *LHS_DRE =\
  \ dyn_cast<DeclRefExpr>(LHS)) {\n      const VarDecl *VD = dyn_cast<VarDecl>(LHS_DRE->getDecl());\n\
  \      if (VD && isPinctrlMapPtr(VD->getType())) {\n        if (const CallExpr *CE\
  \ = getDirectCall(RHS)) {\n          if (const FunctionDecl *Callee = CE->getDirectCallee())\
  \ {\n            if (IdentifierInfo *II = Callee->getIdentifier()) {\n         \
  \     if (isDevmAllocatorName(II->getName())) {\n                DevmVars.insert(VD);\n\
  \                DevmVarToCall[VD] = CE;\n              }\n            }\n     \
  \     }\n        }\n      }\n    }\n\n    // Case: *map = ...\n    if (const auto\
  \ *UO = dyn_cast<UnaryOperator>(LHS)) {\n      if (UO->getOpcode() == UO_Deref)\
  \ {\n        const Expr *Sub = ignoreCastsAndParens(UO->getSubExpr());\n       \
  \ if (const auto *DRE = dyn_cast<DeclRefExpr>(Sub)) {\n          if (DRE->getDecl()\
  \ == MapParam) {\n            // RHS direct devm_* call\n            if (const CallExpr\
  \ *CE = getDirectCall(RHS)) {\n              if (const FunctionDecl *Callee = CE->getDirectCallee())\
  \ {\n                if (IdentifierInfo *II = Callee->getIdentifier()) {\n     \
  \             if (isDevmAllocatorName(II->getName())) {\n                    Found\
  \ = true;\n                    BadCallSite = CE;\n                    BadAssignSite\
  \ = BO;\n                    return true;\n                  }\n               \
  \ }\n              }\n            }\n            // RHS is a variable that might\
  \ be from devm_* earlier\n            const Expr *R = ignoreCastsAndParens(RHS);\n\
  \            if (const auto *RHS_DRE = dyn_cast<DeclRefExpr>(R)) {\n           \
  \   if (const VarDecl *RVD = dyn_cast<VarDecl>(RHS_DRE->getDecl())) {\n        \
  \        PendingRHSVarsInMapAssign.push_back(RVD);\n              }\n          \
  \  }\n            BadAssignSite = BO; // remember as fallback anchor\n         \
  \ }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  void finalize() {\n\
  \    if (Found) return;\n    // Resolve pending RHS vars\n    for (const VarDecl\
  \ *VD : PendingRHSVarsInMapAssign) {\n      if (DevmVars.contains(VD)) {\n     \
  \   Found = true;\n        auto It = DevmVarToCall.find(VD);\n        if (It !=\
  \ DevmVarToCall.end())\n          BadCallSite = It->second;\n        break;\n  \
  \    }\n    }\n  }\n};\n\nconst ParmVarDecl *SAGenTestChecker::findMapParam(const\
  \ FunctionDecl *FD) const {\n  for (const ParmVarDecl *P : FD->parameters()) {\n\
  \    if (isPinctrlMapPtrPtr(P->getType()))\n      return P;\n  }\n  return nullptr;\n\
  }\n\nvoid SAGenTestChecker::scanFunctionForBug(const FunctionDecl *FD, AnalysisManager\
  \ &Mgr, BugReporter &BR) const {\n  if (!FD || ScannedFns.contains(FD))\n    return;\n\
  \  if (!FD->doesThisDeclarationHaveABody())\n    return;\n\n  const ParmVarDecl\
  \ *MapParam = findMapParam(FD);\n  if (!MapParam)\n    return;\n\n  Stmt *Body =\
  \ const_cast<Stmt*>(FD->getBody());\n  if (!Body)\n    return;\n\n  DevmMapBodyVisitor\
  \ V(MapParam, Mgr.getASTContext());\n  V.TraverseStmt(Body);\n  V.finalize();\n\n\
  \  if (V.Found) {\n    const Stmt *Anchor = V.BadCallSite ? static_cast<const Stmt*>(V.BadCallSite)\n\
  \                                       : static_cast<const Stmt*>(V.BadAssignSite\
  \ ? V.BadAssignSite : Body);\n    PathDiagnosticLocation Loc = PathDiagnosticLocation::createBegin(\n\
  \        Anchor, BR.getSourceManager(), Mgr.getAnalysisDeclContext(FD));\n    auto\
  \ R = std::make_unique<BasicBugReport>(\n        *BT, \"devm_* allocation for pinctrl\
  \ map mixed with dt_free_map causes double free\", Loc);\n    if (V.BadCallSite)\n\
  \      R->addRange(V.BadCallSite->getSourceRange());\n    BR.emitReport(std::move(R));\n\
  \  }\n\n  ScannedFns.insert(FD);\n}\n\nvoid SAGenTestChecker::markDangerousAndMaybeScan(const\
  \ FunctionDecl *FD, AnalysisManager &Mgr, BugReporter &BR) const {\n  if (!FD)\n\
  \    return;\n  DangerousDtNodeToMapFns.insert(FD);\n  // If we've already seen\
  \ the body, or even if not, try scanning now.\n  if (FD->doesThisDeclarationHaveABody())\n\
  \    scanFunctionForBug(FD, Mgr, BR);\n}\n\nvoid SAGenTestChecker::checkASTDecl(const\
  \ VarDecl *D, AnalysisManager &Mgr, BugReporter &BR) const {\n  if (!D)\n    return;\n\
  \  const Expr *Init = D->getInit();\n  if (!Init)\n    return;\n\n  OpsInitVisitor\
  \ V(Mgr.getASTContext());\n  V.TraverseStmt(const_cast<Expr*>(Init));\n\n  if (V.NodeToMapFn\
  \ && V.HasManualFree) {\n    markDangerousAndMaybeScan(V.NodeToMapFn, Mgr, BR);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkASTDecl(const FunctionDecl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const {\n  if (!D)\n    return;\n  if (!D->doesThisDeclarationHaveABody())\n\
  \    return;\n\n  SeenFunctionDefs.insert(D);\n\n  // If we already know it's dangerous,\
  \ scan immediately.\n  if (DangerousDtNodeToMapFns.contains(D))\n    scanFunctionForBug(D,\
  \ Mgr, BR);\n}\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const {\n  const auto *FD = dyn_cast<FunctionDecl>(D);\n\
  \  if (!FD)\n    return;\n\n  // If it's marked dangerous, scan; otherwise, it may\
  \ be discovered later\n  // when the struct variable with .dt_free_map is encountered.\n\
  \  if (DangerousDtNodeToMapFns.contains(FD))\n    scanFunctionForBug(FD, Mgr, BR);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects devm_* allocation for pinctrl map when dt_free_map is used, causing\
  \ double free\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
