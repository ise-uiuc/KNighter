_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 39b13dce1a91cdfc3bec9238f9e89094551bd428
commit_type: Double-Free
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Decl.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program state to map\
  \ the return symbol of devm_add_action_or_reset()\n// to its 'cleanup' function\
  \ and 'data' pointer.\nREGISTER_MAP_WITH_PROGRAMSTATE(DevmRetToCleanupFDMap, SymbolRef,\
  \ const FunctionDecl*)\nREGISTER_MAP_WITH_PROGRAMSTATE(DevmRetToDataRegionMap, SymbolRef,\
  \ const MemRegion*)\n\n// Program state to record that we are on the failure path\
  \ (non-zero return)\n// for a specific (data region -> cleanup function) pair.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(ActiveFailureMap, const MemRegion*, const FunctionDecl*)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n\
  \        check::PreCall,\n        eval::Assume> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Manual cleanup\
  \ after devm_add_action_or_reset failure\", \"Linux kernel API misuse\")) {}\n\n\
  \      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n   \
  \   void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n      ProgramStateRef\
  \ evalAssume(ProgramStateRef State, SVal Cond, bool Assumption) const;\n\n   private:\n\
  \      static const FunctionDecl *getFunctionDeclFromExpr(const Expr *E);\n    \
  \  static bool isDevmAddActionOrReset(const CallEvent &Call, CheckerContext &C);\n\
  \      void reportDoubleCleanup(const CallEvent &Call, CheckerContext &C) const;\n\
  };\n\nconst FunctionDecl *SAGenTestChecker::getFunctionDeclFromExpr(const Expr *E)\
  \ {\n  if (!E)\n    return nullptr;\n\n  const Expr *Cur = E->IgnoreParenImpCasts();\n\
  \  if (const auto *UO = dyn_cast<UnaryOperator>(Cur)) {\n    if (UO->getOpcode()\
  \ == UO_AddrOf)\n      Cur = UO->getSubExpr()->IgnoreParenImpCasts();\n  }\n\n \
  \ if (const auto *DRE = dyn_cast<DeclRefExpr>(Cur)) {\n    return dyn_cast<FunctionDecl>(DRE->getDecl());\n\
  \  }\n  return nullptr;\n}\n\nbool SAGenTestChecker::isDevmAddActionOrReset(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  // Prefer source-text name check as suggested.\n\
  \  return ExprHasName(Origin, \"devm_add_action_or_reset\", C);\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isDevmAddActionOrReset(Call,\
  \ C))\n    return;\n\n  // Expect signature: int devm_add_action_or_reset(dev, cleanup,\
  \ data)\n  if (Call.getNumArgs() < 3)\n    return;\n\n  // Extract cleanup function\
  \ decl from 2nd argument.\n  const Expr *CleanupArg = Call.getArgExpr(1);\n  const\
  \ FunctionDecl *CleanupFD = getFunctionDeclFromExpr(CleanupArg);\n  if (!CleanupFD)\n\
  \    return;\n\n  // Extract data pointer region from 3rd argument.\n  const Expr\
  \ *DataArg = Call.getArgExpr(2);\n  const MemRegion *DataReg = getMemRegionFromExpr(DataArg,\
  \ C);\n  if (!DataReg)\n    return;\n\n  DataReg = DataReg->getBaseRegion();\n \
  \ if (!DataReg)\n    return;\n\n  // Get the return symbol of the call.\n  SymbolRef\
  \ RetSym = Call.getReturnValue().getAsSymbol();\n  if (!RetSym)\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n  State = State->set<DevmRetToCleanupFDMap>(RetSym,\
  \ CleanupFD);\n  State = State->set<DevmRetToDataRegionMap>(RetSym, DataReg);\n\
  \  C.addTransition(State);\n}\n\nProgramStateRef SAGenTestChecker::evalAssume(ProgramStateRef\
  \ State, SVal Cond, bool Assumption) const {\n  if (!State)\n    return State;\n\
  \n  // We only care when the condition is exactly the return symbol of\n  // devm_add_action_or_reset().\n\
  \  SymbolRef Sym = Cond.getAsSymbol();\n  if (!Sym)\n    return State;\n\n  const\
  \ FunctionDecl *const *FDPtr = State->get<DevmRetToCleanupFDMap>(Sym);\n  const\
  \ MemRegion *const *MRPtr = State->get<DevmRetToDataRegionMap>(Sym);\n  if (!FDPtr\
  \ || !MRPtr)\n    return State;\n\n  const FunctionDecl *CleanupFD = *FDPtr;\n \
  \ const MemRegion *DataReg = *MRPtr;\n\n  // Erase the temporary mapping regardless\
  \ of the branch to avoid stale entries.\n  State = State->remove<DevmRetToCleanupFDMap>(Sym);\n\
  \  State = State->remove<DevmRetToDataRegionMap>(Sym);\n\n  // On non-zero (true)\
  \ branch, devm_add_action_or_reset failed,\n  // and it already invoked the cleanup(data).\n\
  \  if (Assumption && CleanupFD && DataReg) {\n    State = State->set<ActiveFailureMap>(DataReg,\
  \ CleanupFD);\n  }\n\n  return State;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // We only handle direct calls to a function (i.e., we have a FunctionDecl).\n\
  \  const Decl *D = Call.getDecl();\n  const auto *CalleeFD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!CalleeFD)\n    return;\n\n  // We expect cleanup(void *data) - at least\
  \ 1 arg is required.\n  if (Call.getNumArgs() < 1)\n    return;\n\n  const Expr\
  \ *DataArg = Call.getArgExpr(0);\n  const MemRegion *ArgReg = getMemRegionFromExpr(DataArg,\
  \ C);\n  if (!ArgReg)\n    return;\n\n  ArgReg = ArgReg->getBaseRegion();\n  if\
  \ (!ArgReg)\n    return;\n\n  // Check if we are currently on a failure path for\
  \ this (data -> cleanup) pair.\n  const FunctionDecl *const *TrackedFD = State->get<ActiveFailureMap>(ArgReg);\n\
  \  if (!TrackedFD || !*TrackedFD)\n    return;\n\n  if (*TrackedFD == CalleeFD)\
  \ {\n    reportDoubleCleanup(Call, C);\n  }\n}\n\nvoid SAGenTestChecker::reportDoubleCleanup(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Manual cleanup after devm_add_action_or_reset() failure (double free)\"\
  , N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects manual cleanup after devm_add_action_or_reset() failure that\
  \ leads to double free\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nfirmware: arm_scmi: Fix the double free in scmi_debugfs_common_setup()\n\
  \nClang static checker(scan-build) throws below warning\uFF1A\n  |  drivers/firmware/arm_scmi/driver.c:line\
  \ 2915, column 2\n  |        Attempt to free released memory.\n\nWhen devm_add_action_or_reset()\
  \ fails, scmi_debugfs_common_cleanup()\nwill run twice which causes double free\
  \ of 'dbg->name'.\n\nRemove the redundant scmi_debugfs_common_cleanup() to fix this\
  \ problem.\n\nFixes: c3d4aed763ce (\"firmware: arm_scmi: Populate a common SCMI\
  \ debugfs root\")\nSigned-off-by: Su Hui <suhui@nfschina.com>\nReviewed-by: Cristian\
  \ Marussi <cristian.marussi@arm.com>\nMessage-Id: <20241011104001.1546476-1-suhui@nfschina.com>\n\
  Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>\n\n## Buggy Code\n\n```c\n//\
  \ Function: scmi_debugfs_common_setup in drivers/firmware/arm_scmi/driver.c\nstatic\
  \ struct scmi_debug_info *scmi_debugfs_common_setup(struct scmi_info *info)\n{\n\
  \tchar top_dir[16];\n\tstruct dentry *trans, *top_dentry;\n\tstruct scmi_debug_info\
  \ *dbg;\n\tconst char *c_ptr = NULL;\n\n\tdbg = devm_kzalloc(info->dev, sizeof(*dbg),\
  \ GFP_KERNEL);\n\tif (!dbg)\n\t\treturn NULL;\n\n\tdbg->name = kstrdup(of_node_full_name(info->dev->of_node),\
  \ GFP_KERNEL);\n\tif (!dbg->name) {\n\t\tdevm_kfree(info->dev, dbg);\n\t\treturn\
  \ NULL;\n\t}\n\n\tof_property_read_string(info->dev->of_node, \"compatible\", &c_ptr);\n\
  \tdbg->type = kstrdup(c_ptr, GFP_KERNEL);\n\tif (!dbg->type) {\n\t\tkfree(dbg->name);\n\
  \t\tdevm_kfree(info->dev, dbg);\n\t\treturn NULL;\n\t}\n\n\tsnprintf(top_dir, 16,\
  \ \"%d\", info->id);\n\ttop_dentry = debugfs_create_dir(top_dir, scmi_top_dentry);\n\
  \ttrans = debugfs_create_dir(\"transport\", top_dentry);\n\n\tdbg->is_atomic = info->desc->atomic_enabled\
  \ &&\n\t\t\t\tis_transport_polling_capable(info->desc);\n\n\tdebugfs_create_str(\"\
  instance_name\", 0400, top_dentry,\n\t\t\t   (char **)&dbg->name);\n\n\tdebugfs_create_u32(\"\
  atomic_threshold_us\", 0400, top_dentry,\n\t\t\t   &info->atomic_threshold);\n\n\
  \tdebugfs_create_str(\"type\", 0400, trans, (char **)&dbg->type);\n\n\tdebugfs_create_bool(\"\
  is_atomic\", 0400, trans, &dbg->is_atomic);\n\n\tdebugfs_create_u32(\"max_rx_timeout_ms\"\
  , 0400, trans,\n\t\t\t   (u32 *)&info->desc->max_rx_timeout_ms);\n\n\tdebugfs_create_u32(\"\
  max_msg_size\", 0400, trans,\n\t\t\t   (u32 *)&info->desc->max_msg_size);\n\n\t\
  debugfs_create_u32(\"tx_max_msg\", 0400, trans,\n\t\t\t   (u32 *)&info->tx_minfo.max_msg);\n\
  \n\tdebugfs_create_u32(\"rx_max_msg\", 0400, trans,\n\t\t\t   (u32 *)&info->rx_minfo.max_msg);\n\
  \n\tif (IS_ENABLED(CONFIG_ARM_SCMI_DEBUG_COUNTERS))\n\t\tscmi_debugfs_counters_setup(dbg,\
  \ trans);\n\n\tdbg->top_dentry = top_dentry;\n\n\tif (devm_add_action_or_reset(info->dev,\n\
  \t\t\t\t     scmi_debugfs_common_cleanup, dbg)) {\n\t\tscmi_debugfs_common_cleanup(dbg);\n\
  \t\treturn NULL;\n\t}\n\n\treturn dbg;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/firmware/arm_scmi/driver.c b/drivers/firmware/arm_scmi/driver.c\n\
  index 88c5c4ff4bb6..a477b5ade38d 100644\n--- a/drivers/firmware/arm_scmi/driver.c\n\
  +++ b/drivers/firmware/arm_scmi/driver.c\n@@ -2976,10 +2976,8 @@ static struct scmi_debug_info\
  \ *scmi_debugfs_common_setup(struct scmi_info *info)\n \tdbg->top_dentry = top_dentry;\n\
  \ \n \tif (devm_add_action_or_reset(info->dev,\n-\t\t\t\t     scmi_debugfs_common_cleanup,\
  \ dbg)) {\n-\t\tscmi_debugfs_common_cleanup(dbg);\n+\t\t\t\t     scmi_debugfs_common_cleanup,\
  \ dbg))\n \t\treturn NULL;\n-\t}\n \n \treturn dbg;\n }\n```\n"
pattern: "## Bug Pattern\n\nCalling devm_add_action_or_reset(dev, cleanup, data) and\
  \ then, on non-zero return, manually invoking the same cleanup(data). Since devm_add_action_or_reset\
  \ automatically calls the action on registration failure, the explicit cleanup call\
  \ causes the cleanup to run twice (double free/destroy of resources managed by the\
  \ cleanup).\n\nExample anti-pattern:\nif (devm_add_action_or_reset(dev, cleanup,\
  \ data)) {\n    cleanup(data);  // BUG: already called by devm_add_action_or_reset\
  \ on failure\n    return NULL;\n}"
plan: "Plan to detect \u201Cmanual cleanup after devm_add_action_or_reset() failure\u201D\
  \ (double free)\n\n1) Program state customization\n- REGISTER_MAP_WITH_PROGRAMSTATE(DevmRetToActionMap,\
  \ SymbolRef, ActionInfo)\n  - ActionInfo fields:\n    - const FunctionDecl *CleanupFD\n\
  \    - const MemRegion *DataRegion\n- REGISTER_SET_WITH_PROGRAMSTATE(ActiveFailureSet,\
  \ FailureKey)\n  - FailureKey fields:\n    - const FunctionDecl *CleanupFD\n   \
  \ - const MemRegion *DataRegion\n- Rationale:\n  - DevmRetToActionMap ties the symbolic\
  \ return value of devm_add_action_or_reset to the cleanup function and its data\
  \ argument.\n  - ActiveFailureSet marks that along the current path, we are in the\
  \ \u201Cfailure branch\u201D (non-zero return) for that specific cleanup+data pair,\
  \ i.e., the cleanup is already invoked by devm_add_action_or_reset and any manual\
  \ call is a double cleanup.\n\n2) Callback selection and implementation details\n\
  \n2.1) checkPostCall: record devm_add_action_or_reset calls\n- Goal: Capture the\
  \ cleanup function and data pointer passed into devm_add_action_or_reset and associate\
  \ them with the call\u2019s symbolic return value.\n- Steps:\n  - Identify the function:\n\
  \    - Prefer Call.getCalleeIdentifier()->getName().equals(\"devm_add_action_or_reset\"\
  ).\n    - Fallback if needed: ExprHasName(Call.getOriginExpr()->getCallee(), \"\
  devm_add_action_or_reset\", C).\n  - Ensure at least 3 arguments are present: (dev,\
  \ cleanup, data).\n  - Extract cleanup function decl (CleanupFD):\n    - From Arg1\
  \ (2nd parameter): strip parens/implicits.\n    - If DeclRefExpr to FunctionDecl,\
  \ record that FunctionDecl.\n    - If UnaryOperator \u2018&\u2019 over DeclRefExpr\
  \ to FunctionDecl, record that FunctionDecl.\n    - If no direct FunctionDecl is\
  \ available (e.g., variable func pointer), skip for simplicity.\n  - Extract data\
  \ region (DataRegion):\n    - From Arg2 (3rd parameter): use getMemRegionFromExpr(Arg2,\
  \ C).\n    - If null, skip (we need this to match later).\n  - Obtain the call return\
  \ SVal and its SymbolRef:\n    - SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\n\
  \    - If no symbol, skip (constant fold won\u2019t branch as needed).\n  - Insert\
  \ into DevmRetToActionMap: map RetSym -> {CleanupFD, DataRegion}.\n\n2.2) evalAssume:\
  \ activate the \u201Cfailure branch\u201D context\n- Goal: When the analyzer splits\
  \ on a branch condition that is exactly the return symbol of a recorded devm_add_action_or_reset(),\
  \ mark the true branch as the failure path.\n- Steps:\n  - If Cond is a DefinedSVal\
  \ with an underlying SymbolRef Sym:\n    - Look up Sym in DevmRetToActionMap.\n\
  \    - If found:\n      - If Assumption == true: we are on the non-zero (failure)\
  \ path.\n        - Construct FailureKey {CleanupFD, DataRegion} from ActionInfo.\n\
  \        - Add FailureKey to ActiveFailureSet in this successor state.\n      -\
  \ If Assumption == false: do not add it (success path).\n      - Optionally erase\
  \ Sym from DevmRetToActionMap in both successor states to avoid stale entries.\n\
  - Scope:\n  - This handles the two most common code shapes:\n    - if (devm_add_action_or_reset(...))\
  \ { ... }\n    - int ret = devm_add_action_or_reset(...); if (ret) { ... }\n  -\
  \ For simplicity, this plan does not attempt to parse complex conditions such as\
  \ (ret != 0) or (ret < 0).\n\n2.3) checkPreCall: detect manual cleanup in the failure\
  \ branch\n- Goal: When a function call occurs, if it matches the cleanup function\
  \ and data tracked in the failure branch, report a bug (double cleanup).\n- Steps:\n\
  \  - Extract current callee FunctionDecl FD:\n    - If available via Call.getDecl(),\
  \ use it.\n    - Else try Call.getCalleeIdentifier() name, but only proceed if we\
  \ have a FunctionDecl (the plan matches only direct calls to the function).\n  -\
  \ If FD is null, skip (we only handle direct function calls).\n  - Extract the first\
  \ argument\u2019s region (assumes signature cleanup(void *data)):\n    - If Call.getNumArgs()\
  \ == 0, skip.\n    - const MemRegion *ArgRegion = getMemRegionFromExpr(Call.getArgExpr(0),\
  \ C).\n    - If null, skip.\n  - Construct FailureKey K = {FD, ArgRegion}.\n  -\
  \ If K is in ActiveFailureSet:\n    - Report a bug, as the cleanup is being explicitly\
  \ called on the failure path where devm_add_action_or_reset already invoked it.\n\
  \    - Create a non-fatal error node and emit a PathSensitiveBugReport with a short\
  \ message:\n      - \u201CManual cleanup after devm_add_action_or_reset() failure\
  \ (double free).\u201D\n    - Optionally, add notes:\n      - At the original devm_add_action_or_reset\
  \ call site: \u201Cdevm_add_action_or_reset invokes the action on failure.\u201D\
  \n      - At the manual cleanup call site: \u201CExplicit cleanup here duplicates\
  \ the failure cleanup.\u201D\n\n2.4) Optional hygiene\n- checkBeginFunction:\n \
  \ - No special action required; program state maps/sets start empty per path.\n\
  - checkEndFunction / checkRegionChanges:\n  - Not required for this pattern.\n\n\
  3) Matching details and utilities\n\n- Function name checks:\n  - Use Call.getCalleeIdentifier()\
  \ for devm_add_action_or_reset.\n  - Fallback to ExprHasName when needed but prefer\
  \ identifier-based matching.\n- Extracting function decl from the \u201Ccleanup\u201D\
  \ argument:\n  - Accept either \u2018cleanup\u2019 or \u2018&cleanup\u2019 forms.\n\
  \  - Only proceed when a direct FunctionDecl is obtained; ignore indirect function-pointer\
  \ variables for simplicity.\n- Extracting the data region:\n  - Use getMemRegionFromExpr\
  \ for robust comparison under casts/implicits.\n\n4) Reporting\n- Use generateNonFatalErrorNode\
  \ to create a node.\n- Use std::make_unique<PathSensitiveBugReport> with category\
  \ like \u201CLinux kernel API misuse\u201D.\n- Message: \u201CManual cleanup after\
  \ devm_add_action_or_reset() failure (double free).\u201D\n- Provide the cleanup\
  \ call as the primary location. Optionally, add a note at the devm_add_action_or_reset()\
  \ call.\n\n5) Limits and simplifications\n- The checker focuses on:\n  - Direct\
  \ if(cond) where cond is the call result or a variable holding the call result used\
  \ as a boolean.\n  - Direct call to the same cleanup function by name, with the\
  \ same data pointer as first argument.\n- It does not attempt to:\n  - Parse complex\
  \ relational conditions (ret != 0, ret < 0).\n  - Match cleanup invoked through\
  \ function-pointer variables or aliases.\n  - Track aliasing of the data pointer;\
  \ it compares regions directly.\n\nThis minimal, path-sensitive plan reliably flags\
  \ the common anti-pattern:\nif (devm_add_action_or_reset(dev, cleanup, data)) {\n\
  \    cleanup(data); // double cleanup\n}"
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Decl.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program state to map\
  \ the return symbol of devm_add_action_or_reset()\n// to its 'cleanup' function\
  \ and 'data' pointer.\nREGISTER_MAP_WITH_PROGRAMSTATE(DevmRetToCleanupFDMap, SymbolRef,\
  \ const FunctionDecl*)\nREGISTER_MAP_WITH_PROGRAMSTATE(DevmRetToDataRegionMap, SymbolRef,\
  \ const MemRegion*)\n\n// Program state to record that we are on the failure path\
  \ (non-zero return)\n// for a specific (data region -> cleanup function) pair.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(ActiveFailureMap, const MemRegion*, const FunctionDecl*)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n\
  \        check::PreCall,\n        eval::Assume> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Manual cleanup\
  \ after devm_add_action_or_reset failure\", \"Linux kernel API misuse\")) {}\n\n\
  \      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n   \
  \   void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n      ProgramStateRef\
  \ evalAssume(ProgramStateRef State, SVal Cond, bool Assumption) const;\n\n   private:\n\
  \      static const FunctionDecl *getFunctionDeclFromExpr(const Expr *E);\n    \
  \  static bool isDevmAddActionOrReset(const CallEvent &Call, CheckerContext &C);\n\
  \      void reportDoubleCleanup(const CallEvent &Call, CheckerContext &C) const;\n\
  };\n\nconst FunctionDecl *SAGenTestChecker::getFunctionDeclFromExpr(const Expr *E)\
  \ {\n  if (!E)\n    return nullptr;\n\n  const Expr *Cur = E->IgnoreParenImpCasts();\n\
  \  if (const auto *UO = dyn_cast<UnaryOperator>(Cur)) {\n    if (UO->getOpcode()\
  \ == UO_AddrOf)\n      Cur = UO->getSubExpr()->IgnoreParenImpCasts();\n  }\n\n \
  \ if (const auto *DRE = dyn_cast<DeclRefExpr>(Cur)) {\n    return dyn_cast<FunctionDecl>(DRE->getDecl());\n\
  \  }\n  return nullptr;\n}\n\nbool SAGenTestChecker::isDevmAddActionOrReset(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  // Prefer source-text name check as suggested.\n\
  \  return ExprHasName(Origin, \"devm_add_action_or_reset\", C);\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isDevmAddActionOrReset(Call,\
  \ C))\n    return;\n\n  // Expect signature: int devm_add_action_or_reset(dev, cleanup,\
  \ data)\n  if (Call.getNumArgs() < 3)\n    return;\n\n  // Extract cleanup function\
  \ decl from 2nd argument.\n  const Expr *CleanupArg = Call.getArgExpr(1);\n  const\
  \ FunctionDecl *CleanupFD = getFunctionDeclFromExpr(CleanupArg);\n  if (!CleanupFD)\n\
  \    return;\n\n  // Extract data pointer region from 3rd argument.\n  const Expr\
  \ *DataArg = Call.getArgExpr(2);\n  const MemRegion *DataReg = getMemRegionFromExpr(DataArg,\
  \ C);\n  if (!DataReg)\n    return;\n\n  DataReg = DataReg->getBaseRegion();\n \
  \ if (!DataReg)\n    return;\n\n  // Get the return symbol of the call.\n  SymbolRef\
  \ RetSym = Call.getReturnValue().getAsSymbol();\n  if (!RetSym)\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n  State = State->set<DevmRetToCleanupFDMap>(RetSym,\
  \ CleanupFD);\n  State = State->set<DevmRetToDataRegionMap>(RetSym, DataReg);\n\
  \  C.addTransition(State);\n}\n\nProgramStateRef SAGenTestChecker::evalAssume(ProgramStateRef\
  \ State, SVal Cond, bool Assumption) const {\n  if (!State)\n    return State;\n\
  \n  // We only care when the condition is exactly the return symbol of\n  // devm_add_action_or_reset().\n\
  \  SymbolRef Sym = Cond.getAsSymbol();\n  if (!Sym)\n    return State;\n\n  const\
  \ FunctionDecl *const *FDPtr = State->get<DevmRetToCleanupFDMap>(Sym);\n  const\
  \ MemRegion *const *MRPtr = State->get<DevmRetToDataRegionMap>(Sym);\n  if (!FDPtr\
  \ || !MRPtr)\n    return State;\n\n  const FunctionDecl *CleanupFD = *FDPtr;\n \
  \ const MemRegion *DataReg = *MRPtr;\n\n  // Erase the temporary mapping regardless\
  \ of the branch to avoid stale entries.\n  State = State->remove<DevmRetToCleanupFDMap>(Sym);\n\
  \  State = State->remove<DevmRetToDataRegionMap>(Sym);\n\n  // On non-zero (true)\
  \ branch, devm_add_action_or_reset failed,\n  // and it already invoked the cleanup(data).\n\
  \  if (Assumption && CleanupFD && DataReg) {\n    State = State->set<ActiveFailureMap>(DataReg,\
  \ CleanupFD);\n  }\n\n  return State;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // We only handle direct calls to a function (i.e., we have a FunctionDecl).\n\
  \  const Decl *D = Call.getDecl();\n  const auto *CalleeFD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!CalleeFD)\n    return;\n\n  // We expect cleanup(void *data) - at least\
  \ 1 arg is required.\n  if (Call.getNumArgs() < 1)\n    return;\n\n  const Expr\
  \ *DataArg = Call.getArgExpr(0);\n  const MemRegion *ArgReg = getMemRegionFromExpr(DataArg,\
  \ C);\n  if (!ArgReg)\n    return;\n\n  ArgReg = ArgReg->getBaseRegion();\n  if\
  \ (!ArgReg)\n    return;\n\n  // Check if we are currently on a failure path for\
  \ this (data -> cleanup) pair.\n  const FunctionDecl *const *TrackedFD = State->get<ActiveFailureMap>(ArgReg);\n\
  \  if (!TrackedFD || !*TrackedFD)\n    return;\n\n  if (*TrackedFD == CalleeFD)\
  \ {\n    reportDoubleCleanup(Call, C);\n  }\n}\n\nvoid SAGenTestChecker::reportDoubleCleanup(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Manual cleanup after devm_add_action_or_reset() failure (double free)\"\
  , N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects manual cleanup after devm_add_action_or_reset() failure that\
  \ leads to double free\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
