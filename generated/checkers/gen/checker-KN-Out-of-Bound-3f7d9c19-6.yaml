_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3f7d9c1964fcd16d02a8a9d4fd6f6cb60c4cc530
commit_type: Out-of-Bound
index: 6
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Basic/SourceManager.h\"\
  \n#include \"clang/Basic/LangOptions.h\"\n#include <string>\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// Program states\nREGISTER_MAP_WITH_PROGRAMSTATE(DevLenKindMap,\
  \ const MemRegion*, unsigned)\nREGISTER_MAP_WITH_PROGRAMSTATE(DevLenCheckedMap,\
  \ const MemRegion*, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(DevLenOriginSite, const\
  \ MemRegion*, const Stmt*)\n\nnamespace {\n\nenum DevLenKind : unsigned {\n  RSS_KEY_SIZE\
  \ = 1\n};\n\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\
  \ : public Checker<check::Bind,\n                                        check::BranchCondition,\n\
  \                                        check::EndFunction> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unvalidated\
  \ device length used for RSS key\", \"API Misuse\")) {}\n\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n      void checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C) const;\n\n   private:\n\n      bool isInVirtnetProbe(CheckerContext\
  \ &C) const;\n      void markAllKindChecked(ProgramStateRef &State, unsigned Kind)\
  \ const;\n};\n\nbool SAGenTestChecker::isInVirtnetProbe(CheckerContext &C) const\
  \ {\n  const LocationContext *LCtx = C.getLocationContext();\n  if (!LCtx)\n   \
  \ return false;\n  const Decl *D = LCtx->getDecl();\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!FD)\n    return false;\n  // Limit scope to virtnet_probe to reduce false\
  \ positives\n  return FD->getName().equals(\"virtnet_probe\");\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  if (!S || !isInVirtnetProbe(C))\n\
  \    return;\n\n  // Look for binding from a call expression, specifically virtio_cread8(...,\
  \ rss_max_key_size)\n  const CallExpr *CE = findSpecificTypeInChildren<const CallExpr>(S);\n\
  \  if (!CE)\n    return;\n\n  // Verify function and field names by source text\n\
  \  if (!ExprHasName(CE, \"virtio_cread8\", C))\n    return;\n  if (!ExprHasName(CE,\
  \ \"rss_max_key_size\", C))\n    return;\n\n  // Get the destination region being\
  \ assigned/bound\n  const MemRegion *DstReg = Loc.getAsRegion();\n  if (!DstReg)\n\
  \    return;\n\n  DstReg = DstReg->getBaseRegion();\n  if (!DstReg)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n  // Track this device length as RSS_KEY_SIZE\
  \ and initially unchecked\n  State = State->set<DevLenKindMap>(DstReg, (unsigned)RSS_KEY_SIZE);\n\
  \  State = State->set<DevLenCheckedMap>(DstReg, false);\n  State = State->set<DevLenOriginSite>(DstReg,\
  \ S);\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::markAllKindChecked(ProgramStateRef\
  \ &State, unsigned Kind) const {\n  auto Map = State->get<DevLenKindMap>();\n  for\
  \ (auto It = Map.begin(), E = Map.end(); It != E; ++It) {\n    const MemRegion *MR\
  \ = It->first;\n    unsigned K = It->second;\n    if (K == Kind) {\n      // Only\
  \ set to true if it was tracked before\n      const bool *Checked = State->get<DevLenCheckedMap>(MR);\n\
  \      if (!Checked || !*Checked) {\n        State = State->set<DevLenCheckedMap>(MR,\
  \ true);\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!isInVirtnetProbe(C))\n   \
  \ return;\n\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE)\n\
  \    return;\n\n  // Consider the length \"validated\" if a condition mentions both:\n\
  \  // - rss_key_size\n  // - VIRTIO_NET_RSS_MAX_KEY_SIZE\n  bool HasLen = ExprHasName(CondE,\
  \ \"rss_key_size\", C);\n  bool HasMax = ExprHasName(CondE, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C);\n  if (!HasLen || !HasMax)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  markAllKindChecked(State, (unsigned)RSS_KEY_SIZE);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkEndFunction(const ReturnStmt *RS, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  auto KindMap = State->get<DevLenKindMap>();\n\
  \n  for (auto It = KindMap.begin(), E = KindMap.end(); It != E; ++It) {\n    const\
  \ MemRegion *MR = It->first;\n    unsigned Kind = It->second;\n\n    if (Kind !=\
  \ (unsigned)RSS_KEY_SIZE)\n      continue;\n\n    const bool *Checked = State->get<DevLenCheckedMap>(MR);\n\
  \    if (Checked && *Checked)\n      continue;\n\n    // Not checked: report a bug.\n\
  \    ExplodedNode *N = C.generateNonFatalErrorNode();\n    if (!N)\n      continue;\n\
  \n    const Stmt *Origin = State->get<DevLenOriginSite>(MR);\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Device length (rss_max_key_size) not validated against VIRTIO_NET_RSS_MAX_KEY_SIZE.\"\
  , N);\n\n    if (Origin)\n      R->addRange(Origin->getSourceRange());\n\n    C.emitReport(std::move(R));\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects using device-provided rss_max_key_size without validating against\
  \ VIRTIO_NET_RSS_MAX_KEY_SIZE\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nvirtio_net: Add hash_key_length check\n\nAdd hash_key_length\
  \ check in virtnet_probe() to avoid possible out of\nbound errors when setting/reading\
  \ the hash key.\n\nFixes: c7114b1249fa (\"drivers/net/virtio_net: Added basic RSS\
  \ support.\")\nSigned-off-by: Philo Lu <lulie@linux.alibaba.com>\nSigned-off-by:\
  \ Xuan Zhuo <xuanzhuo@linux.alibaba.com>\nAcked-by: Joe Damato <jdamato@fastly.com>\n\
  Acked-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: virtnet_probe in drivers/net/virtio_net.c\n\
  static int virtnet_probe(struct virtio_device *vdev)\n{\n\tint i, err = -ENOMEM;\n\
  \tstruct net_device *dev;\n\tstruct virtnet_info *vi;\n\tu16 max_queue_pairs;\n\t\
  int mtu = 0;\n\n\t/* Find if host supports multiqueue/rss virtio_net device */\n\
  \tmax_queue_pairs = 1;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MQ) || virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_RSS))\n\t\tmax_queue_pairs =\n\t\t     virtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config, max_virtqueue_pairs));\n\n\t/* We need at least 2 queue's */\n\
  \tif (max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||\n\t    max_queue_pairs\
  \ > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||\n\t    !virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\
  \t\tmax_queue_pairs = 1;\n\n\t/* Allocate ourselves a network device with room for\
  \ our info */\n\tdev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);\n\
  \tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* Set up network device as normal. */\n\t\
  dev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE |\n\t\t\t   IFF_TX_SKB_NO_LINEAR;\n\
  \tdev->netdev_ops = &virtnet_netdev;\n\tdev->stat_ops = &virtnet_stat_ops;\n\tdev->features\
  \ = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev,\
  \ &vdev->dev);\n\n\t/* Do we support \"hardware\" checksums? */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_CSUM)) {\n\t\t/* This opens up the world of extra features. */\n\t\
  \tdev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\t\tif (csum)\n\t\t\tdev->features\
  \ |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO))\
  \ {\n\t\t\tdev->hw_features |= NETIF_F_TSO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\
  \t\t}\n\t\t/* Individual feature bits: what can host handle? */\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_ECN))\n\t\t\tdev->hw_features |= NETIF_F_TSO_ECN;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_USO))\n\t\t\tdev->hw_features |= NETIF_F_GSO_UDP_L4;\n\n\t\t\
  dev->features |= NETIF_F_GSO_ROBUST;\n\n\t\tif (gso)\n\t\t\tdev->features |= dev->hw_features\
  \ & NETIF_F_ALL_TSO;\n\t\t/* (!csum && gso) case will be fixed by register_netdev()\
  \ */\n\t}\n\n\t/* 1. With VIRTIO_NET_F_GUEST_CSUM negotiation, the driver doesn't\n\
  \t * need to calculate checksums for partially checksummed packets,\n\t * as they're\
  \ considered valid by the upper layer.\n\t * 2. Without VIRTIO_NET_F_GUEST_CSUM\
  \ negotiation, the driver only\n\t * receives fully checksummed packets. The device\
  \ may assist in\n\t * validating these packets' checksums, so the driver won't have\
  \ to.\n\t */\n\tdev->features |= NETIF_F_RXCSUM;\n\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_GUEST_TSO4) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6))\n\
  \t\tdev->features |= NETIF_F_GRO_HW;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS))\n\
  \t\tdev->hw_features |= NETIF_F_GRO_HW;\n\n\tdev->vlan_features = dev->features;\n\
  \tdev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT;\n\n\t/* MTU\
  \ range: 68 - 65535 */\n\tdev->min_mtu = MIN_MTU;\n\tdev->max_mtu = MAX_MTU;\n\n\
  \t/* Configuration may specify what MAC to use.  Otherwise random. */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MAC)) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tvirtio_cread_bytes(vdev,\n\
  \t\t\t\t   offsetof(struct virtio_net_config, mac),\n\t\t\t\t   addr, ETH_ALEN);\n\
  \t\teth_hw_addr_set(dev, addr);\n\t} else {\n\t\teth_hw_addr_random(dev);\n\t\t\
  dev_info(&vdev->dev, \"Assigned random MAC address %pM\\n\",\n\t\t\t dev->dev_addr);\n\
  \t}\n\n\t/* Set up our device-specific information */\n\tvi = netdev_priv(dev);\n\
  \tvi->dev = dev;\n\tvi->vdev = vdev;\n\tvdev->priv = vi;\n\n\tINIT_WORK(&vi->config_work,\
  \ virtnet_config_changed_work);\n\tINIT_WORK(&vi->rx_mode_work, virtnet_rx_mode_work);\n\
  \tspin_lock_init(&vi->refill_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))\
  \ {\n\t\tvi->mergeable_rx_bufs = true;\n\t\tdev->xdp_features |= NETDEV_XDP_ACT_RX_SG;\n\
  \t}\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HASH_REPORT))\n\t\tvi->has_rss_hash_report\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_RSS)) {\n\t\tvi->has_rss\
  \ = true;\n\n\t\tvi->rss_indir_table_size =\n\t\t\tvirtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config,\n\t\t\t\trss_max_indirection_table_length));\n\t}\n\terr =\
  \ rss_indirection_table_alloc(&vi->rss, vi->rss_indir_table_size);\n\tif (err)\n\
  \t\tgoto free;\n\n\tif (vi->has_rss || vi->has_rss_hash_report) {\n\t\tvi->rss_key_size\
  \ =\n\t\t\tvirtio_cread8(vdev, offsetof(struct virtio_net_config, rss_max_key_size));\n\
  \n\t\tvi->rss_hash_types_supported =\n\t\t    virtio_cread32(vdev, offsetof(struct\
  \ virtio_net_config, supported_hash_types));\n\t\tvi->rss_hash_types_supported &=\n\
  \t\t\t\t~(VIRTIO_NET_RSS_HASH_TYPE_IP_EX |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_TCP_EX\
  \ |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_UDP_EX);\n\n\t\tdev->hw_features |= NETIF_F_RXHASH;\n\
  \t\tdev->xdp_metadata_ops = &virtnet_xdp_metadata_ops;\n\t}\n\n\tif (vi->has_rss_hash_report)\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_v1_hash);\n\telse if (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MRG_RXBUF) ||\n\t\t virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\telse\n\t\tvi->hdr_len\
  \ = sizeof(struct virtio_net_hdr);\n\n\tif (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT)\
  \ ||\n\t    virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\tvi->any_header_sg\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\t\tvi->has_cvq\
  \ = true;\n\n\tmutex_init(&vi->cvq_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MTU))\
  \ {\n\t\tmtu = virtio_cread16(vdev,\n\t\t\t\t     offsetof(struct virtio_net_config,\n\
  \t\t\t\t\t      mtu));\n\t\tif (mtu < dev->min_mtu) {\n\t\t\t/* Should never trigger:\
  \ MTU was previously validated\n\t\t\t * in virtnet_validate.\n\t\t\t */\n\t\t\t\
  dev_err(&vdev->dev,\n\t\t\t\t\"device MTU appears to have changed it is now %d <\
  \ %d\",\n\t\t\t\tmtu, dev->min_mtu);\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\
  \t}\n\n\t\tdev->mtu = mtu;\n\t\tdev->max_mtu = mtu;\n\t}\n\n\tvirtnet_set_big_packets(vi,\
  \ mtu);\n\n\tif (vi->any_header_sg)\n\t\tdev->needed_headroom = vi->hdr_len;\n\n\
  \t/* Enable multiqueue by default */\n\tif (num_online_cpus() >= max_queue_pairs)\n\
  \t\tvi->curr_queue_pairs = max_queue_pairs;\n\telse\n\t\tvi->curr_queue_pairs =\
  \ num_online_cpus();\n\tvi->max_queue_pairs = max_queue_pairs;\n\n\t/* Allocate/initialize\
  \ the rx/tx queues, and invoke find_vqs */\n\terr = init_vqs(vi);\n\tif (err)\n\t\
  \tgoto free;\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_NOTF_COAL)) {\n\t\
  \tvi->intr_coal_rx.max_usecs = 0;\n\t\tvi->intr_coal_tx.max_usecs = 0;\n\t\tvi->intr_coal_rx.max_packets\
  \ = 0;\n\n\t\t/* Keep the default values of the coalescing parameters\n\t\t * aligned\
  \ with the default napi_tx state.\n\t\t */\n\t\tif (vi->sq[0].napi.weight)\n\t\t\
  \tvi->intr_coal_tx.max_packets = 1;\n\t\telse\n\t\t\tvi->intr_coal_tx.max_packets\
  \ = 0;\n\t}\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_VQ_NOTF_COAL)) {\n\
  \t\t/* The reason is the same as VIRTIO_NET_F_NOTF_COAL. */\n\t\tfor (i = 0; i <\
  \ vi->max_queue_pairs; i++)\n\t\t\tif (vi->sq[i].napi.weight)\n\t\t\t\tvi->sq[i].intr_coal.max_packets\
  \ = 1;\n\n\t\terr = virtnet_init_irq_moder(vi);\n\t\tif (err)\n\t\t\tgoto free;\n\
  \t}\n\n#ifdef CONFIG_SYSFS\n\tif (vi->mergeable_rx_bufs)\n\t\tdev->sysfs_rx_queue_group\
  \ = &virtio_net_mrg_rx_group;\n#endif\n\tnetif_set_real_num_tx_queues(dev, vi->curr_queue_pairs);\n\
  \tnetif_set_real_num_rx_queues(dev, vi->curr_queue_pairs);\n\n\tvirtnet_init_settings(dev);\n\
  \n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_STANDBY)) {\n\t\tvi->failover = net_failover_create(vi->dev);\n\
  \t\tif (IS_ERR(vi->failover)) {\n\t\t\terr = PTR_ERR(vi->failover);\n\t\t\tgoto\
  \ free_vqs;\n\t\t}\n\t}\n\n\tif (vi->has_rss || vi->has_rss_hash_report)\n\t\tvirtnet_init_default_rss(vi);\n\
  \n\tenable_rx_mode_work(vi);\n\n\t/* serialize netdev register + virtio_device_ready()\
  \ with ndo_open() */\n\trtnl_lock();\n\n\terr = register_netdevice(dev);\n\tif (err)\
  \ {\n\t\tpr_debug(\"virtio_net: registering device failed\\n\");\n\t\trtnl_unlock();\n\
  \t\tgoto free_failover;\n\t}\n\n\t/* Disable config change notification until ndo_open.\
  \ */\n\tvirtio_config_driver_disable(vi->vdev);\n\n\tvirtio_device_ready(vdev);\n\
  \n\tvirtnet_set_queues(vi, vi->curr_queue_pairs);\n\n\t/* a random MAC address has\
  \ been assigned, notify the device.\n\t * We don't fail probe if VIRTIO_NET_F_CTRL_MAC_ADDR\
  \ is not there\n\t * because many devices work fine without getting MAC explicitly\n\
  \t */\n\tif (!virtio_has_feature(vdev, VIRTIO_NET_F_MAC) &&\n\t    virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_CTRL_MAC_ADDR)) {\n\t\tstruct scatterlist sg;\n\n\t\tsg_init_one(&sg,\
  \ dev->dev_addr, dev->addr_len);\n\t\tif (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MAC,\n\
  \t\t\t\t\t  VIRTIO_NET_CTRL_MAC_ADDR_SET, &sg)) {\n\t\t\tpr_debug(\"virtio_net:\
  \ setting MAC address failed\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr = -EINVAL;\n\
  \t\t\tgoto free_unregister_netdev;\n\t\t}\n\t}\n\n\tif (virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_DEVICE_STATS)) {\n\t\tstruct virtio_net_stats_capabilities *stats_cap\
  \  __free(kfree) = NULL;\n\t\tstruct scatterlist sg;\n\t\t__le64 v;\n\n\t\tstats_cap\
  \ = kzalloc(sizeof(*stats_cap), GFP_KERNEL);\n\t\tif (!stats_cap) {\n\t\t\trtnl_unlock();\n\
  \t\t\terr = -ENOMEM;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tsg_init_one(&sg,\
  \ stats_cap, sizeof(*stats_cap));\n\n\t\tif (!virtnet_send_command_reply(vi, VIRTIO_NET_CTRL_STATS,\n\
  \t\t\t\t\t\tVIRTIO_NET_CTRL_STATS_QUERY,\n\t\t\t\t\t\tNULL, &sg)) {\n\t\t\tpr_debug(\"\
  virtio_net: fail to get stats capability\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr\
  \ = -EINVAL;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tv = stats_cap->supported_stats_types[0];\n\
  \t\tvi->device_stats_cap = le64_to_cpu(v);\n\t}\n\n\t/* Assume link up if device\
  \ can't report link status,\n\t   otherwise get link status from config. */\n\t\
  netif_carrier_off(dev);\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS))\
  \ {\n\t\tvirtnet_config_changed_work(&vi->config_work);\n\t} else {\n\t\tvi->status\
  \ = VIRTIO_NET_S_LINK_UP;\n\t\tvirtnet_update_settings(vi);\n\t\tnetif_carrier_on(dev);\n\
  \t}\n\n\tfor (i = 0; i < ARRAY_SIZE(guest_offloads); i++)\n\t\tif (virtio_has_feature(vi->vdev,\
  \ guest_offloads[i]))\n\t\t\tset_bit(guest_offloads[i], &vi->guest_offloads);\n\t\
  vi->guest_offloads_capable = vi->guest_offloads;\n\n\trtnl_unlock();\n\n\terr =\
  \ virtnet_cpu_notif_add(vi);\n\tif (err) {\n\t\tpr_debug(\"virtio_net: registering\
  \ cpu notifier failed\\n\");\n\t\tgoto free_unregister_netdev;\n\t}\n\n\tpr_debug(\"\
  virtnet: registered device %s with %d RX and TX vq's\\n\",\n\t\t dev->name, max_queue_pairs);\n\
  \n\treturn 0;\n\nfree_unregister_netdev:\n\tunregister_netdev(dev);\nfree_failover:\n\
  \tnet_failover_destroy(vi->failover);\nfree_vqs:\n\tvirtio_reset_device(vdev);\n\
  \tcancel_delayed_work_sync(&vi->refill);\n\tfree_receive_page_frags(vi);\n\tvirtnet_del_vqs(vi);\n\
  free:\n\tfree_netdev(dev);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c\nindex 4b507007d242..545dda8ec077\
  \ 100644\n--- a/drivers/net/virtio_net.c\n+++ b/drivers/net/virtio_net.c\n@@ -6451,6\
  \ +6451,12 @@ static int virtnet_probe(struct virtio_device *vdev)\n \tif (vi->has_rss\
  \ || vi->has_rss_hash_report) {\n \t\tvi->rss_key_size =\n \t\t\tvirtio_cread8(vdev,\
  \ offsetof(struct virtio_net_config, rss_max_key_size));\n+\t\tif (vi->rss_key_size\
  \ > VIRTIO_NET_RSS_MAX_KEY_SIZE) {\n+\t\t\tdev_err(&vdev->dev, \"rss_max_key_size=%u\
  \ exceeds the limit %u.\\n\",\n+\t\t\t\tvi->rss_key_size, VIRTIO_NET_RSS_MAX_KEY_SIZE);\n\
  +\t\t\terr = -EINVAL;\n+\t\t\tgoto free;\n+\t\t}\n \n \t\tvi->rss_hash_types_supported\
  \ =\n \t\t    virtio_cread32(vdev, offsetof(struct virtio_net_config, supported_hash_types));\n\
  ```\n"
pattern: "## Bug Pattern\n\nUsing a device-provided length field (e.g., rss_max_key_size\
  \ read from virtio config) to size/copy data into a fixed-size buffer without validating\
  \ it against the driver\u2019s maximum (VIRTIO_NET_RSS_MAX_KEY_SIZE), leading to\
  \ potential out-of-bounds access.\n\nExample:\nvi->rss_key_size = virtio_cread8(vdev,\
  \ offsetof(struct virtio_net_config, rss_max_key_size));\n/* missing check: vi->rss_key_size\
  \ <= VIRTIO_NET_RSS_MAX_KEY_SIZE */\n/* later used to read/set RSS key into a fixed-size\
  \ buffer */"
plan: "1) Program state\n\n- Define three program-state containers to track the \u201C\
  device-provided length\u201D variable and its validation status.\n  - REGISTER_MAP_WITH_PROGRAMSTATE(DevLenKindMap,\
  \ const MemRegion*, unsigned)\n    - Purpose: classify tracked variables by a small\
  \ enum \u201CKind\u201D.\n    - Use Kind = 1 for RSS_KEY_SIZE (rss_max_key_size).\n\
  \  - REGISTER_MAP_WITH_PROGRAMSTATE(DevLenCheckedMap, const MemRegion*, bool)\n\
  \    - Purpose: whether the length has been validated against the driver\u2019s\
  \ maximum.\n  - REGISTER_MAP_WITH_PROGRAMSTATE(DevLenOriginSite, const MemRegion*,\
  \ const Stmt*)\n    - Purpose: remember where we first saw the assignment (for better\
  \ bug location).\n\n- No pointer-alias map is needed for this checker because we\
  \ will target the well-known field (vi->rss_key_size) directly and look for a matching\
  \ validation in the same function.\n\n2) Callback selection and implementation details\n\
  \nStep A: Detect the device length assignment from virtio config\n- Callback: checkBind\n\
  - Goal: find and record when a value is read from virtio_cread8(..., offsetof(...,\
  \ rss_max_key_size)) into a variable/field (e.g., vi->rss_key_size).\n\nImplementation\
  \ details:\n- In checkBind(Loc, Val, S, C):\n  - Using findSpecificTypeInChildren<const\
  \ CallExpr>(S), check whether the RHS is a call expression.\n  - If true, analyze\
  \ the call expression text with ExprHasName:\n    - Require both:\n      - ExprHasName(CallExpr,\
  \ \"virtio_cread8\")\n      - ExprHasName(CallExpr, \"rss_max_key_size\")\n    -\
  \ Optionally also ensure we are inside the function named \u201Cvirtnet_probe\u201D\
  \ (using C.getCurrentAnalysisDeclContext()->getDecl()->getAsFunction()->getNameAsString())\
  \ to reduce false positives.\n  - Extract the LHS memory region:\n    - From the\
  \ bind destination S, find the LHS expression (e.g., via findSpecificTypeInChildren<const\
  \ BinaryOperator>(S) and then get LHS) or directly through the \u201CLoc\u201D argument\
  \ if it is a location for an lvalue.\n    - Use getMemRegionFromExpr(LHS, C) to\
  \ get the MemRegion.\n  - If the region is valid, set:\n    - DevLenKindMap[Region]\
  \ = 1 (RSS_KEY_SIZE)\n    - DevLenCheckedMap[Region] = false\n    - DevLenOriginSite[Region]\
  \ = S\n  - Add the updated state via C.addTransition(State).\n\nStep B: Detect the\
  \ presence of a correctness check (<= MAX) in conditions\n- Callback: checkBranchCondition\n\
  - Goal: consider the length \u201Cvalidated\u201D if the function contains a condition\
  \ that compares this variable to VIRTIO_NET_RSS_MAX_KEY_SIZE.\n\nImplementation\
  \ details:\n- In checkBranchCondition(const Stmt *Condition, CheckerContext &C):\n\
  \  - If the condition source contains both:\n    - \"rss_key_size\"\n    - \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  \n    - using ExprHasName(Condition, ...) checks.\n  - If so, mark all DevLenKindMap\
  \ entries of Kind == RSS_KEY_SIZE as checked.\n    - Retrieve the DevLenKindMap\
  \ via State->get<DevLenKindMap>() and iterate.\n    - For each Region with Kind\
  \ == RSS_KEY_SIZE, set DevLenCheckedMap[Region] = true.\n    - Transition to the\
  \ updated state.\n- Optional improvement (if you want to be more precise):\n  -\
  \ Try to extract the specific MemRegion of the variable used in the condition:\n\
  \    - Use getMemRegionFromExpr on the sub-expression that refers to the variable\
  \ (MemberExpr/DeclRefExpr).\n    - If the region is tracked in DevLenKindMap and\
  \ Kind == RSS_KEY_SIZE, set only that region to checked.\n- Optional improvement\
  \ 2 (alternative \u201Cmin/clamp\u201D style validation):\n  - In checkPostCall,\
  \ if you see a call to min/min_t/clamp/clamp_t whose source text includes both \"\
  rss_key_size\" and \"VIRTIO_NET_RSS_MAX_KEY_SIZE\", and the result is assigned back\
  \ to the same LHS region tracked in DevLenKindMap, then mark DevLenCheckedMap[Region]\
  \ = true.\n\nStep C: Accept constraint-based validation (optional)\n- Callback:\
  \ checkBranchCondition or evalAssume\n- Goal: be robust if users write comparisons\
  \ other than direct textual check.\n\nImplementation details:\n- After detecting\
  \ a comparison involving the tracked symbol, you can use inferSymbolMaxVal(Sym,\
  \ C) to see if the analyzer already constrained the symbol to be \u2264 VIRTIO_NET_RSS_MAX_KEY_SIZE.\n\
  - If inferred max value exists and is \u2264 MAX, mark checked.\n- This is optional;\
  \ the textual check in Step B is sufficient for this pattern.\n\nStep D: Report\
  \ if no validation was found by the end of the function\n- Callback: checkEndFunction\n\
  - Goal: if any tracked RSS_KEY_SIZE variable remains unchecked by function end,\
  \ report a bug.\n\nImplementation details:\n- In checkEndFunction(..., Ctx):\n \
  \ - Retrieve DevLenKindMap and DevLenCheckedMap.\n  - For every Region where Kind\
  \ == RSS_KEY_SIZE and DevLenCheckedMap[Region] == false:\n    - Create a non-fatal\
  \ error node with Ctx.generateNonFatalErrorNode().\n    - Use the statement saved\
  \ in DevLenOriginSite[Region] as the \u201Cinteresting location\u201D.\n    - Emit\
  \ a PathSensitiveBugReport with a short message, e.g.:\n      - \"Device length\
  \ rss_max_key_size is not validated against VIRTIO_NET_RSS_MAX_KEY_SIZE.\"\n   \
  \ - Mark the region and the origin statement as \u201Cinteresting\u201D in the bug\
  \ report.\n  - Do not forget to add a transition if you updated the state.\n\n3)\
  \ Notes to keep it simple and precise\n\n- Focus on the specific pattern:\n  - The\
  \ read function: virtio_cread8\n  - The device field: rss_max_key_size\n  - The\
  \ in-function variable/field: vi->rss_key_size (though the checker only needs the\
  \ MemRegion of the LHS, not the exact name).\n  - The max macro: VIRTIO_NET_RSS_MAX_KEY_SIZE\n\
  - Prefer in-function validation detection:\n  - If you see a branch condition with\
  \ both \u201Crss_key_size\u201D and \u201CVIRTIO_NET_RSS_MAX_KEY_SIZE\u201D, treat\
  \ it as validated.\n  - Optionally accept min/min_t/clamp style checks as validation\
  \ in checkPostCall via ExprHasName on the call expression.\n- Keep scope tight (optional\
  \ but recommended):\n  - Only run the logic in functions whose name contains \u201C\
  virtnet_probe\u201D to minimize false positives. You can guard each step with a\
  \ function-name check.\n- No need for alias tracking or interprocedural propagation\
  \ for this pattern\u2014the patch\u2019s fix is local in virtnet_probe.\n\n4) Bug\
  \ report message\n\n- Short and clear:\n  - Title: \u201CUnvalidated device length\
  \ used for RSS key\u201D\n  - Message: \u201CDevice length (rss_max_key_size) not\
  \ validated against VIRTIO_NET_RSS_MAX_KEY_SIZE.\u201D\n- Point to the assignment\
  \ site (where virtio_cread8 value was bound) as the primary location."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Basic/SourceManager.h\"\
  \n#include \"clang/Basic/LangOptions.h\"\n#include <string>\n#include <memory>\n\
  \nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program\
  \ states\nREGISTER_MAP_WITH_PROGRAMSTATE(DevLenKindMap, const MemRegion*, unsigned)\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(DevLenCheckedMap, const MemRegion*, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(DevLenOriginSite,\
  \ const MemRegion*, const Stmt*)\n\nnamespace {\n\nenum DevLenKind : unsigned {\n\
  \  RSS_KEY_SIZE = 1\n};\n\n/* The checker callbacks are to be decided. */\nclass\
  \ SAGenTestChecker : public Checker<check::Bind,\n                             \
  \           check::BranchCondition,\n                                        check::EndFunction>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unvalidated device length used for RSS key\", \"API Misuse\"\
  )) {}\n\n      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const;\n      void checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const;\n      void checkEndFunction(const ReturnStmt *RS, CheckerContext &C)\
  \ const;\n\n   private:\n\n      bool isInVirtnetProbe(CheckerContext &C) const;\n\
  \      void markAllKindChecked(ProgramStateRef &State, unsigned Kind) const;\n};\n\
  \nbool SAGenTestChecker::isInVirtnetProbe(CheckerContext &C) const {\n  const LocationContext\
  \ *LCtx = C.getLocationContext();\n  if (!LCtx)\n    return false;\n  const Decl\
  \ *D = LCtx->getDecl();\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!FD)\n    return false;\n  // Limit scope to virtnet_probe to reduce false\
  \ positives\n  return FD->getName().equals(\"virtnet_probe\");\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  if (!S || !isInVirtnetProbe(C))\n\
  \    return;\n\n  // Look for binding from a call expression, specifically virtio_cread8(...,\
  \ rss_max_key_size)\n  const CallExpr *CE = findSpecificTypeInChildren<const CallExpr>(S);\n\
  \  if (!CE)\n    return;\n\n  // Verify function and field names by source text\n\
  \  if (!ExprHasName(CE, \"virtio_cread8\", C))\n    return;\n  if (!ExprHasName(CE,\
  \ \"rss_max_key_size\", C))\n    return;\n\n  // Get the destination region being\
  \ assigned/bound\n  const MemRegion *DstReg = Loc.getAsRegion();\n  if (!DstReg)\n\
  \    return;\n\n  DstReg = DstReg->getBaseRegion();\n  if (!DstReg)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n  // Track this device length as RSS_KEY_SIZE\
  \ and initially unchecked\n  State = State->set<DevLenKindMap>(DstReg, (unsigned)RSS_KEY_SIZE);\n\
  \  State = State->set<DevLenCheckedMap>(DstReg, false);\n  State = State->set<DevLenOriginSite>(DstReg,\
  \ S);\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::markAllKindChecked(ProgramStateRef\
  \ &State, unsigned Kind) const {\n  auto Map = State->get<DevLenKindMap>();\n  for\
  \ (auto It = Map.begin(), E = Map.end(); It != E; ++It) {\n    const MemRegion *MR\
  \ = It->first;\n    unsigned K = It->second;\n    if (K == Kind) {\n      // Only\
  \ set to true if it was tracked before\n      const bool *Checked = State->get<DevLenCheckedMap>(MR);\n\
  \      if (!Checked || !*Checked) {\n        State = State->set<DevLenCheckedMap>(MR,\
  \ true);\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!isInVirtnetProbe(C))\n   \
  \ return;\n\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE)\n\
  \    return;\n\n  // Consider the length \"validated\" if a condition mentions both:\n\
  \  // - rss_key_size\n  // - VIRTIO_NET_RSS_MAX_KEY_SIZE\n  bool HasLen = ExprHasName(CondE,\
  \ \"rss_key_size\", C);\n  bool HasMax = ExprHasName(CondE, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C);\n  if (!HasLen || !HasMax)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  markAllKindChecked(State, (unsigned)RSS_KEY_SIZE);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkEndFunction(const ReturnStmt *RS, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  auto KindMap = State->get<DevLenKindMap>();\n\
  \n  for (auto It = KindMap.begin(), E = KindMap.end(); It != E; ++It) {\n    const\
  \ MemRegion *MR = It->first;\n    unsigned Kind = It->second;\n\n    if (Kind !=\
  \ (unsigned)RSS_KEY_SIZE)\n      continue;\n\n    const bool *Checked = State->get<DevLenCheckedMap>(MR);\n\
  \    if (Checked && *Checked)\n      continue;\n\n    // Not checked: report a bug.\n\
  \    ExplodedNode *N = C.generateNonFatalErrorNode();\n    if (!N)\n      continue;\n\
  \n    const Stmt *const *OriginPtr = State->get<DevLenOriginSite>(MR);\n    const\
  \ Stmt *Origin = OriginPtr ? *OriginPtr : nullptr;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Device length (rss_max_key_size) not validated against VIRTIO_NET_RSS_MAX_KEY_SIZE.\"\
  , N);\n\n    if (Origin)\n      R->addRange(Origin->getSourceRange());\n\n    C.emitReport(std::move(R));\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects using device-provided rss_max_key_size without validating against\
  \ VIRTIO_NET_RSS_MAX_KEY_SIZE\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
