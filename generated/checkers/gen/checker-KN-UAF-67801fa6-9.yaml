_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 67801fa67b94ebd0e4da7a77ac2d9f321b75fbe0
commit_type: UAF
index: 9
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Basic/SourceManager.h\"\
  \n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Lex/Lexer.h\"\n#include\
  \ <string>\n#include <vector>\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Map a published object's base MemRegion to the Stmt\
  \ where it was published\nREGISTER_MAP_WITH_PROGRAMSTATE(PublishedObjMap, const\
  \ MemRegion*, const Stmt*)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<\n\
  \    check::PostCall,\n    check::Bind\n  > {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Publish-before-init\
  \ leads to UAF\", \"Concurrency/Ordering\")) {}\n\n      void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      bool isPublishCall(const CallEvent &Call, unsigned &ObjIdx, CheckerContext\
  \ &C) const;\n      const MemRegion *getPublishedObjRegion(const CallEvent &Call,\
  \ unsigned ObjIdx, CheckerContext &C) const;\n      bool looksSuspiciousFieldWrite(const\
  \ Expr *LHS, CheckerContext &C) const;\n      void reportPublishBeforeInit(const\
  \ MemRegion *ObjReg, const Stmt *StoreS, const Stmt *PublishS, CheckerContext &C)\
  \ const;\n};\n\n// Return true if Call is xa_alloc/xa_alloc_cyclic/idr_alloc/idr_alloc_cyclic.\n\
  // Sets ObjIdx to the argument index of the published object.\nbool SAGenTestChecker::isPublishCall(const\
  \ CallEvent &Call, unsigned &ObjIdx, CheckerContext &C) const {\n  const Expr *Origin\
  \ = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n\n  // xa_alloc(...,\
  \ obj, ...)\n  if (ExprHasName(Origin, \"xa_alloc\", C)) {\n    // xa_alloc(xa,\
  \ idp, entry, ...)\n    ObjIdx = 2;\n    return true;\n  }\n  if (ExprHasName(Origin,\
  \ \"xa_alloc_cyclic\", C)) {\n    // xa_alloc_cyclic(xa, idp, entry, ...)\n    ObjIdx\
  \ = 2;\n    return true;\n  }\n  // idr_alloc(..., obj, ...)\n  if (ExprHasName(Origin,\
  \ \"idr_alloc\", C)) {\n    // idr_alloc(idr, ptr, ...)\n    ObjIdx = 1;\n    return\
  \ true;\n  }\n  if (ExprHasName(Origin, \"idr_alloc_cyclic\", C)) {\n    // idr_alloc_cyclic(idr,\
  \ ptr, ...)\n    ObjIdx = 1;\n    return true;\n  }\n\n  return false;\n}\n\nconst\
  \ MemRegion *SAGenTestChecker::getPublishedObjRegion(const CallEvent &Call, unsigned\
  \ ObjIdx, CheckerContext &C) const {\n  if (ObjIdx >= Call.getNumArgs())\n    return\
  \ nullptr;\n\n  const Expr *ArgE = Call.getArgExpr(ObjIdx);\n  if (!ArgE)\n    return\
  \ nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(ArgE, C);\n  if (!MR)\n\
  \    return nullptr;\n\n  MR = MR->getBaseRegion();\n  return MR;\n}\n\nbool SAGenTestChecker::looksSuspiciousFieldWrite(const\
  \ Expr *LHS, CheckerContext &C) const {\n  if (!LHS)\n    return false;\n\n  static\
  \ const char *SuspiciousNames[] = {\n      \"ref\", \"kref\", \"refs\", \"owner\"\
  , \"file\", \"xef\", \"ops\", \"state\", \"id\", \"list\", \"node\"\n  };\n\n  const\
  \ Expr *E = LHS->IgnoreParenCasts();\n  if (const auto *ME = dyn_cast<MemberExpr>(E))\
  \ {\n    if (const ValueDecl *VD = ME->getMemberDecl()) {\n      StringRef Name\
  \ = VD->getName();\n      for (const char *Sub : SuspiciousNames) {\n        if\
  \ (Name.contains(Sub))\n          return true;\n      }\n    }\n    // Fallback\
  \ to textual search if needed\n    for (const char *Sub : SuspiciousNames) {\n \
  \     if (ExprHasName(LHS, Sub, C))\n        return true;\n    }\n    return false;\n\
  \  }\n\n  // Array subscripts or other lvalues - use textual fallback\n  for (const\
  \ char *Sub : SuspiciousNames) {\n    if (ExprHasName(LHS, Sub, C))\n      return\
  \ true;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n \
  \ unsigned ObjIdx = 0;\n  if (!isPublishCall(Call, ObjIdx, C))\n    return;\n\n\
  \  const MemRegion *ObjReg = getPublishedObjRegion(Call, ObjIdx, C);\n  if (!ObjReg)\n\
  \    return;\n\n  // Remember that this object was published here.\n  const Stmt\
  \ *Where = Call.getOriginExpr();\n  State = State->set<PublishedObjMap>(ObjReg,\
  \ Where);\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::reportPublishBeforeInit(const\
  \ MemRegion *ObjReg,\n                                               const Stmt\
  \ *StoreS,\n                                               const Stmt *PublishS,\n\
  \                                               CheckerContext &C) const {\n  if\
  \ (!BT)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if\
  \ (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n  \
  \    *BT, \"Published object via xa_alloc/idr_alloc before completing initialization\"\
  , N);\n\n  if (StoreS)\n    R->addRange(StoreS->getSourceRange());\n\n  if (PublishS)\
  \ {\n    PathDiagnosticLocation PubLoc =\n        PathDiagnosticLocation::createBegin(PublishS,\
  \ C.getSourceManager(),\n                                            C.getLocationContext());\n\
  \    R->addNote(\"Object is published here\", PubLoc);\n  }\n\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal /*Val*/, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *LReg\
  \ = Loc.getAsRegion();\n  if (!LReg)\n    return;\n\n  // We are only interested\
  \ in stores to fields/elements of a published object.\n  const MemRegion *BaseReg\
  \ = LReg->getBaseRegion();\n  if (!BaseReg)\n    return;\n\n  const Stmt *PublishSite\
  \ = State->get<PublishedObjMap>(BaseReg);\n  if (!PublishSite)\n    return;\n\n\
  \  // Try to get LHS expression for field-name heuristics.\n  const Expr *LHS =\
  \ nullptr;\n  if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S)) {\n    if\
  \ (BO->isAssignmentOp())\n      LHS = BO->getLHS();\n  } else if (const auto *UO\
  \ = dyn_cast_or_null<UnaryOperator>(S)) {\n    // e.g., ++obj->ref or similar -\
  \ treat as a write\n    if (UO->isIncrementDecrementOp())\n      LHS = UO->getSubExpr();\n\
  \  }\n\n  // If we have an LHS, apply suspicious field-name filter to reduce FPs.\n\
  \  if (LHS && !looksSuspiciousFieldWrite(LHS, C))\n    return;\n\n  // Report and\
  \ optionally silence further reports for this object by removing it.\n  reportPublishBeforeInit(BaseReg,\
  \ S, PublishSite, C);\n  State = State->remove<PublishedObjMap>(BaseReg);\n  C.addTransition(State);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects publishing an object via xa_alloc/idr_alloc before completing\
  \ initialization (may cause UAF)\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/xe/queue: move xa_alloc to prevent UAF\n\nEvil\
  \ user can guess the next id of the queue before the ioctl completes\nand then call\
  \ queue destroy ioctl to trigger UAF since create ioctl is\nstill referencing the\
  \ same queue. Move the xa_alloc all the way to the end\nto prevent this.\n\nv2:\n\
  \ - Rebase\n\nFixes: 2149ded63079 (\"drm/xe: Fix use after free when client stats\
  \ are captured\")\nSigned-off-by: Matthew Auld <matthew.auld@intel.com>\nCc: Matthew\
  \ Brost <matthew.brost@intel.com>\nReviewed-by: Nirmoy Das <nirmoy.das@intel.com>\n\
  Reviewed-by: Matthew Brost <matthew.brost@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20240925071426.144015-4-matthew.auld@intel.com\n\
  (cherry picked from commit 16536582ddbebdbdf9e1d7af321bbba2bf955a87)\nSigned-off-by:\
  \ Lucas De Marchi <lucas.demarchi@intel.com>\n\n## Buggy Code\n\n```c\n// Function:\
  \ xe_exec_queue_create_ioctl in drivers/gpu/drm/xe/xe_exec_queue.c\nint xe_exec_queue_create_ioctl(struct\
  \ drm_device *dev, void *data,\n\t\t\t       struct drm_file *file)\n{\n\tstruct\
  \ xe_device *xe = to_xe_device(dev);\n\tstruct xe_file *xef = to_xe_file(file);\n\
  \tstruct drm_xe_exec_queue_create *args = data;\n\tstruct drm_xe_engine_class_instance\
  \ eci[XE_HW_ENGINE_MAX_INSTANCE];\n\tstruct drm_xe_engine_class_instance __user\
  \ *user_eci =\n\t\tu64_to_user_ptr(args->instances);\n\tstruct xe_hw_engine *hwe;\n\
  \tstruct xe_vm *vm;\n\tstruct xe_gt *gt;\n\tstruct xe_tile *tile;\n\tstruct xe_exec_queue\
  \ *q = NULL;\n\tu32 logical_mask;\n\tu32 id;\n\tu32 len;\n\tint err;\n\n\tif (XE_IOCTL_DBG(xe,\
  \ args->flags) ||\n\t    XE_IOCTL_DBG(xe, args->reserved[0] || args->reserved[1]))\n\
  \t\treturn -EINVAL;\n\n\tlen = args->width * args->num_placements;\n\tif (XE_IOCTL_DBG(xe,\
  \ !len || len > XE_HW_ENGINE_MAX_INSTANCE))\n\t\treturn -EINVAL;\n\n\terr = __copy_from_user(eci,\
  \ user_eci,\n\t\t\t       sizeof(struct drm_xe_engine_class_instance) *\n\t\t\t\
  \       len);\n\tif (XE_IOCTL_DBG(xe, err))\n\t\treturn -EFAULT;\n\n\tif (XE_IOCTL_DBG(xe,\
  \ eci[0].gt_id >= xe->info.gt_count))\n\t\treturn -EINVAL;\n\n\tif (eci[0].engine_class\
  \ == DRM_XE_ENGINE_CLASS_VM_BIND) {\n\t\tif (XE_IOCTL_DBG(xe, args->width != 1)\
  \ ||\n\t\t    XE_IOCTL_DBG(xe, args->num_placements != 1) ||\n\t\t    XE_IOCTL_DBG(xe,\
  \ eci[0].engine_instance != 0))\n\t\t\treturn -EINVAL;\n\n\t\tfor_each_tile(tile,\
  \ xe, id) {\n\t\t\tstruct xe_exec_queue *new;\n\t\t\tu32 flags = EXEC_QUEUE_FLAG_VM;\n\
  \n\t\t\tif (id)\n\t\t\t\tflags |= EXEC_QUEUE_FLAG_BIND_ENGINE_CHILD;\n\n\t\t\tnew\
  \ = xe_exec_queue_create_bind(xe, tile, flags,\n\t\t\t\t\t\t\targs->extensions);\n\
  \t\t\tif (IS_ERR(new)) {\n\t\t\t\terr = PTR_ERR(new);\n\t\t\t\tif (q)\n\t\t\t\t\t\
  goto put_exec_queue;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (id == 0)\n\t\t\t\t\
  q = new;\n\t\t\telse\n\t\t\t\tlist_add_tail(&new->multi_gt_list,\n\t\t\t\t\t   \
  \   &q->multi_gt_link);\n\t\t}\n\t} else {\n\t\tgt = xe_device_get_gt(xe, eci[0].gt_id);\n\
  \t\tlogical_mask = calc_validate_logical_mask(xe, gt, eci,\n\t\t\t\t\t\t\t  args->width,\n\
  \t\t\t\t\t\t\t  args->num_placements);\n\t\tif (XE_IOCTL_DBG(xe, !logical_mask))\n\
  \t\t\treturn -EINVAL;\n\n\t\thwe = xe_hw_engine_lookup(xe, eci[0]);\n\t\tif (XE_IOCTL_DBG(xe,\
  \ !hwe))\n\t\t\treturn -EINVAL;\n\n\t\tvm = xe_vm_lookup(xef, args->vm_id);\n\t\t\
  if (XE_IOCTL_DBG(xe, !vm))\n\t\t\treturn -ENOENT;\n\n\t\terr = down_read_interruptible(&vm->lock);\n\
  \t\tif (err) {\n\t\t\txe_vm_put(vm);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (XE_IOCTL_DBG(xe,\
  \ xe_vm_is_closed_or_banned(vm))) {\n\t\t\tup_read(&vm->lock);\n\t\t\txe_vm_put(vm);\n\
  \t\t\treturn -ENOENT;\n\t\t}\n\n\t\tq = xe_exec_queue_create(xe, vm, logical_mask,\n\
  \t\t\t\t\t args->width, hwe, 0,\n\t\t\t\t\t args->extensions);\n\t\tup_read(&vm->lock);\n\
  \t\txe_vm_put(vm);\n\t\tif (IS_ERR(q))\n\t\t\treturn PTR_ERR(q);\n\n\t\tif (xe_vm_in_preempt_fence_mode(vm))\
  \ {\n\t\t\tq->lr.context = dma_fence_context_alloc(1);\n\n\t\t\terr = xe_vm_add_compute_exec_queue(vm,\
  \ q);\n\t\t\tif (XE_IOCTL_DBG(xe, err))\n\t\t\t\tgoto put_exec_queue;\n\t\t}\n\n\
  \t\tif (q->vm && q->hwe->hw_engine_group) {\n\t\t\terr = xe_hw_engine_group_add_exec_queue(q->hwe->hw_engine_group,\
  \ q);\n\t\t\tif (err)\n\t\t\t\tgoto put_exec_queue;\n\t\t}\n\t}\n\n\terr = xa_alloc(&xef->exec_queue.xa,\
  \ &id, q, xa_limit_32b, GFP_KERNEL);\n\tif (err)\n\t\tgoto kill_exec_queue;\n\n\t\
  args->exec_queue_id = id;\n\tq->xef = xe_file_get(xef);\n\n\treturn 0;\n\nkill_exec_queue:\n\
  \txe_exec_queue_kill(q);\nput_exec_queue:\n\txe_exec_queue_put(q);\n\treturn err;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/xe/xe_exec_queue.c\
  \ b/drivers/gpu/drm/xe/xe_exec_queue.c\nindex 7743ebdcbf4b..d098d2dd1b2d 100644\n\
  --- a/drivers/gpu/drm/xe/xe_exec_queue.c\n+++ b/drivers/gpu/drm/xe/xe_exec_queue.c\n\
  @@ -635,12 +635,14 @@ int xe_exec_queue_create_ioctl(struct drm_device *dev, void\
  \ *data,\n \t\t}\n \t}\n \n+\tq->xef = xe_file_get(xef);\n+\n+\t/* user id alloc\
  \ must always be last in ioctl to prevent UAF */\n \terr = xa_alloc(&xef->exec_queue.xa,\
  \ &id, q, xa_limit_32b, GFP_KERNEL);\n \tif (err)\n \t\tgoto kill_exec_queue;\n\
  \ \n \targs->exec_queue_id = id;\n-\tq->xef = xe_file_get(xef);\n \n \treturn 0;\n\
  \ \n```\n"
pattern: '## Bug Pattern


  Publishing a newly created object into a user-visible ID registry (e.g., xarray/idr
  via xa_alloc/idr_alloc) before the object is fully initialized and all required
  references are taken. Specifically:

  - Calling xa_alloc(&xa, &id, obj, ...) before completing initialization (e.g., setting
  obj->refs/owner fields) or before the create path stops using obj.

  - This makes the object accessible to other ioctls which can look it up by ID and
  destroy/free it while the create ioctl still references or initializes it, leading
  to a use-after-free.


  Correct pattern: finish all object initialization and take needed references first,
  then perform the ID allocation/publication as the last step.'
plan: "Plan to detect \u201Cpublish-before-init\u201D with xa_alloc/idr_alloc leading\
  \ to UAF\n\n1) Program state customization\n- REGISTER_MAP_WITH_PROGRAMSTATE(PublishedObjMap,\
  \ const MemRegion*, const Stmt*)\n  - Maps the published object\u2019s base region\
  \ to the CallExpr (as const Stmt*) where it was published to the ID registry. This\
  \ lets us know an object has been made visible and from which point forward further\
  \ field-inits are suspicious.\n\nNo other custom state is needed. We will not model\
  \ aliases explicitly; we will compare the pointee region of the base expression\
  \ of stores with the stored object region, which is sufficient for CSA\u2019s region\
  \ model.\n\n2) Helper utilities and tables\n- Known publish APIs and object-parameter\
  \ index:\n  - xa_alloc(..., obj, ...) => Name: \"xa_alloc\", ObjParamIndex: 2\n\
  \  - xa_alloc_cyclic(..., obj, ...) => \"xa_alloc_cyclic\", ObjParamIndex: 2\n \
  \ - idr_alloc(..., obj, ...) => \"idr_alloc\", ObjParamIndex: 1\n  - idr_alloc_cyclic(...,\
  \ obj, ...) => \"idr_alloc_cyclic\", ObjParamIndex: 1\n- Suspicious field name substrings\
  \ to reduce false positives:\n  - {\"ref\", \"kref\", \"refs\", \"owner\", \"file\"\
  , \"xef\", \"ops\", \"state\", \"id\", \"list\", \"node\"}\n- Helpers to implement:\n\
  \  - bool isPublishCall(const CallEvent &Call, unsigned &ObjIdx)\n    - Check callee\
  \ name against the table above; on match, set ObjIdx and return true.\n  - const\
  \ MemRegion *getPublishedObjRegion(const CallEvent &Call, unsigned ObjIdx, CheckerContext\
  \ &C)\n    - Fetch the CallArgExpr(ObjIdx); use getMemRegionFromExpr to obtain the\
  \ pointee MemRegion.\n  - bool isStoreToPublishedObjectField(const Stmt *S, CheckerContext\
  \ &C, const MemRegion *&BaseObjReg, std::string &FieldText)\n    - For an assignment\
  \ (checkBind), if LHS is a MemberExpr or ArraySubscriptExpr, get the base expression,\
  \ obtain its pointee region via getMemRegionFromExpr, and if it is present in PublishedObjMap,\
  \ return true. Use either MemberExpr\u2019s field name or fallback to ExprHasName\
  \ on LHS to extract text; store it in FieldText.\n  - bool looksSuspiciousFieldWrite(const\
  \ Expr *LHS, CheckerContext &C)\n    - Use ExprHasName(LHS, substr) over the list\
  \ above; return true if any match. If LHS is a MemberExpr and you can read the field\
  \ identifier, also check the field name directly.\n\n3) Callback selection and detailed\
  \ behavior\n\nA) checkPostCall(const CallEvent &Call, CheckerContext &C) const\n\
  - Purpose: Detect and remember when an object is published into an ID registry (xa/idrs).\n\
  - Steps:\n  1. If isPublishCall(Call, ObjIdx) is true:\n     - Obtain const MemRegion\
  \ *ObjReg = getPublishedObjRegion(Call, ObjIdx, C).\n     - If ObjReg is non-null:\n\
  \       - State = State->set<PublishedObjMap>(ObjReg, Call.getOriginExpr() or Call.getStmt()).\n\
  \     - Do nothing else here; we are only marking that \u201Cfrom now on, writes\
  \ to ObjReg fields are after publication.\u201D\n\nB) checkBind(SVal Loc, SVal Val,\
  \ const Stmt *S, CheckerContext &C) const\n- Purpose: Flag field initializations\
  \ happening after publication.\n- Steps:\n  1. Extract the LHS expression from S\
  \ (it will be a BinaryOperator \u2018=\u2019 or compound assignment; CSA calls checkBind\
  \ for any store). Retrieve the exact Stmt S and, if possible, the LHS Expr via standard\
  \ AST query (dyn_cast<BinaryOperator>(S)).\n  2. If LHS is a MemberExpr (obj->field\
  \ / obj.field) or ArraySubscriptExpr with a base expression:\n     - Get the base\
  \ expression (for MemberExpr: ME->getBase()).\n     - const MemRegion *BaseObjReg\
  \ = getMemRegionFromExpr(BaseExpr, C).\n     - If BaseObjReg is non-null and exists\
  \ in PublishedObjMap:\n       - Optionally reduce FPs: if looksSuspiciousFieldWrite(LHS,\
  \ C) is false, skip; otherwise continue.\n       - Create a non-fatal error node.\n\
  \       - Emit a PathSensitiveBugReport with:\n         - Title: \"Object published\
  \ before initialization\"\n         - Message: \"Field is initialized after publishing\
  \ object via ID registry; move xa_alloc/idr_alloc to the end.\"\n         - Add\
  \ the publication call Stmt (stored in PublishedObjMap) as a note/range if available,\
  \ and highlight the LHS as the violating store.\n       - You can optionally erase\
  \ BaseObjReg from the map to avoid duplicate reports per object; or keep it to report\
  \ all subsequent writes. Prefer erasing after first report to avoid noise.\n\nC)\
  \ checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const\n- Purpose: Cleanup\
  \ state.\n- Steps:\n  - Clear all entries in PublishedObjMap to avoid leakage across\
  \ functions.\n\n4) Reporting details\n- Bug type: Static BugType(\"Publish-before-init\
  \ leads to UAF\", \"Concurrency/Ordering\")\n- Report message (short and clear):\n\
  \  - \"Published object via xa_alloc/idr_alloc before completing initialization\"\
  \n- Additional note (optional if your framework supports):\n  - At publication call:\
  \ \"Object is made user-visible here\"\n  - At the first post-publication field\
  \ write: \"Field initialized after publication\"\n\n5) Scope limiting to reduce\
  \ false positives (optional but recommended)\n- Apply the checker unconditionally\
  \ to all functions, but it will only activate after a publish call.\n- Additionally,\
  \ to further reduce noise, you may:\n  - Only warn on the first post-publication\
  \ write that matches suspiciousFieldName substrings (e.g., owner/ref/xef).\n  -\
  \ Optionally detect and prioritize writes that are assigning results of functions\
  \ named \u201C*get*\u201D (e.g., xe_file_get) into object fields after publication.\
  \ This can be derived from the RHS in checkBind by checking if it is a call expression\
  \ whose callee name contains \"get\".\n\n6) How this flags the target patch issue\n\
  - In the buggy code, xa_alloc(&xef->exec_queue.xa, &id, q, ...) occurs while there\
  \ are still writes to q afterwards (q->xef = xe_file_get(xef)).\n- The checker records\
  \ q as published at xa_alloc (checkPostCall).\n- Later, when it sees q->xef = ...\
  \ (checkBind), it recognizes a field init after publication, matches \u201Cxef\u201D\
  \ as suspicious, and reports.\n- The fixed code moves q->xef assignment before xa_alloc,\
  \ so no writes to q occur after publication; the checker stays silent."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Basic/SourceManager.h\"\
  \n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Lex/Lexer.h\"\n#include\
  \ <string>\n#include <vector>\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Map a published object's base MemRegion to the Stmt\
  \ where it was published\nREGISTER_MAP_WITH_PROGRAMSTATE(PublishedObjMap, const\
  \ MemRegion*, const Stmt*)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<\n\
  \    check::PostCall,\n    check::Bind\n  > {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Publish-before-init\
  \ leads to UAF\", \"Concurrency/Ordering\")) {}\n\n      void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      bool isPublishCall(const CallEvent &Call, unsigned &ObjIdx, CheckerContext\
  \ &C) const;\n      const MemRegion *getPublishedObjRegion(const CallEvent &Call,\
  \ unsigned ObjIdx, CheckerContext &C) const;\n      bool looksSuspiciousFieldWrite(const\
  \ Expr *LHS, CheckerContext &C) const;\n      void reportPublishBeforeInit(const\
  \ MemRegion *ObjReg, const Stmt *StoreS, const Stmt *PublishS, CheckerContext &C)\
  \ const;\n};\n\n// Return true if Call is xa_alloc/xa_alloc_cyclic/idr_alloc/idr_alloc_cyclic.\n\
  // Sets ObjIdx to the argument index of the published object.\nbool SAGenTestChecker::isPublishCall(const\
  \ CallEvent &Call, unsigned &ObjIdx, CheckerContext &C) const {\n  const Expr *Origin\
  \ = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n\n  // xa_alloc(...,\
  \ obj, ...)\n  if (ExprHasName(Origin, \"xa_alloc\", C)) {\n    // xa_alloc(xa,\
  \ idp, entry, ...)\n    ObjIdx = 2;\n    return true;\n  }\n  if (ExprHasName(Origin,\
  \ \"xa_alloc_cyclic\", C)) {\n    // xa_alloc_cyclic(xa, idp, entry, ...)\n    ObjIdx\
  \ = 2;\n    return true;\n  }\n  // idr_alloc(..., obj, ...)\n  if (ExprHasName(Origin,\
  \ \"idr_alloc\", C)) {\n    // idr_alloc(idr, ptr, ...)\n    ObjIdx = 1;\n    return\
  \ true;\n  }\n  if (ExprHasName(Origin, \"idr_alloc_cyclic\", C)) {\n    // idr_alloc_cyclic(idr,\
  \ ptr, ...)\n    ObjIdx = 1;\n    return true;\n  }\n\n  return false;\n}\n\nconst\
  \ MemRegion *SAGenTestChecker::getPublishedObjRegion(const CallEvent &Call, unsigned\
  \ ObjIdx, CheckerContext &C) const {\n  if (ObjIdx >= Call.getNumArgs())\n    return\
  \ nullptr;\n\n  const Expr *ArgE = Call.getArgExpr(ObjIdx);\n  if (!ArgE)\n    return\
  \ nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(ArgE, C);\n  if (!MR)\n\
  \    return nullptr;\n\n  MR = MR->getBaseRegion();\n  return MR;\n}\n\nbool SAGenTestChecker::looksSuspiciousFieldWrite(const\
  \ Expr *LHS, CheckerContext &C) const {\n  if (!LHS)\n    return false;\n\n  static\
  \ const char *SuspiciousNames[] = {\n      \"ref\", \"kref\", \"refs\", \"owner\"\
  , \"file\", \"xef\", \"ops\", \"state\", \"id\", \"list\", \"node\"\n  };\n\n  const\
  \ Expr *E = LHS->IgnoreParenCasts();\n  if (const auto *ME = dyn_cast<MemberExpr>(E))\
  \ {\n    if (const ValueDecl *VD = ME->getMemberDecl()) {\n      StringRef Name\
  \ = VD->getName();\n      for (const char *Sub : SuspiciousNames) {\n        if\
  \ (Name.contains(Sub))\n          return true;\n      }\n    }\n    // Fallback\
  \ to textual search if needed\n    for (const char *Sub : SuspiciousNames) {\n \
  \     if (ExprHasName(LHS, Sub, C))\n        return true;\n    }\n    return false;\n\
  \  }\n\n  // Array subscripts or other lvalues - use textual fallback\n  for (const\
  \ char *Sub : SuspiciousNames) {\n    if (ExprHasName(LHS, Sub, C))\n      return\
  \ true;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n \
  \ unsigned ObjIdx = 0;\n  if (!isPublishCall(Call, ObjIdx, C))\n    return;\n\n\
  \  const MemRegion *ObjReg = getPublishedObjRegion(Call, ObjIdx, C);\n  if (!ObjReg)\n\
  \    return;\n\n  // Remember that this object was published here.\n  const Stmt\
  \ *Where = Call.getOriginExpr();\n  State = State->set<PublishedObjMap>(ObjReg,\
  \ Where);\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::reportPublishBeforeInit(const\
  \ MemRegion *ObjReg,\n                                               const Stmt\
  \ *StoreS,\n                                               const Stmt *PublishS,\n\
  \                                               CheckerContext &C) const {\n  if\
  \ (!BT)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if\
  \ (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n  \
  \    *BT, \"Published object via xa_alloc/idr_alloc before completing initialization\"\
  , N);\n\n  if (StoreS)\n    R->addRange(StoreS->getSourceRange());\n\n  if (PublishS)\
  \ {\n    PathDiagnosticLocation PubLoc =\n        PathDiagnosticLocation::createBegin(PublishS,\
  \ C.getSourceManager(),\n                                            C.getLocationContext());\n\
  \    R->addNote(\"Object is published here\", PubLoc);\n  }\n\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal /*Val*/, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *LReg\
  \ = Loc.getAsRegion();\n  if (!LReg)\n    return;\n\n  // We are only interested\
  \ in stores to fields/elements of a published object.\n  const MemRegion *BaseReg\
  \ = LReg->getBaseRegion();\n  if (!BaseReg)\n    return;\n\n  // get<PublishedObjMap>(Key)\
  \ returns a pointer to the mapped value (or null).\n  const Stmt *const *PublishSitePtr\
  \ = State->get<PublishedObjMap>(BaseReg);\n  if (!PublishSitePtr)\n    return;\n\
  \  const Stmt *PublishSite = *PublishSitePtr;\n\n  // Try to get LHS expression\
  \ for field-name heuristics.\n  const Expr *LHS = nullptr;\n  if (const auto *BO\
  \ = dyn_cast_or_null<BinaryOperator>(S)) {\n    if (BO->isAssignmentOp())\n    \
  \  LHS = BO->getLHS();\n  } else if (const auto *UO = dyn_cast_or_null<UnaryOperator>(S))\
  \ {\n    // e.g., ++obj->ref or similar - treat as a write\n    if (UO->isIncrementDecrementOp())\n\
  \      LHS = UO->getSubExpr();\n  }\n\n  // If we have an LHS, apply suspicious\
  \ field-name filter to reduce FPs.\n  if (LHS && !looksSuspiciousFieldWrite(LHS,\
  \ C))\n    return;\n\n  // Report and optionally silence further reports for this\
  \ object by removing it.\n  reportPublishBeforeInit(BaseReg, S, PublishSite, C);\n\
  \  State = State->remove<PublishedObjMap>(BaseReg);\n  C.addTransition(State);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects publishing an object via xa_alloc/idr_alloc before completing\
  \ initialization (may cause UAF)\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
