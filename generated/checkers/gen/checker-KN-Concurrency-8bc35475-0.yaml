_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 8bc35475ef1a23b0e224f3242eb11c76cab0ea88
commit_type: Concurrency
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"llvm/ADT/SmallVector.h\"\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// No custom program states needed.\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<check::BranchCondition>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\n\
  \        : BT(new BugType(this, \"Speculative shared read before guard\", \"Concurrency\"\
  )) {}\n\n      void checkBranchCondition(const Stmt *Condition, CheckerContext &C)\
  \ const;\n\n   private:\n\n      // Helpers\n      const IfStmt *getEnclosingIf(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n      void getParentCompoundAndPrevStmt(const\
  \ IfStmt *IS,\n                                        const CheckerContext &C,\n\
  \                                        const CompoundStmt *&CS,\n            \
  \                            const Stmt *&Prev) const;\n\n      const VarDecl *getAssignedVar(const\
  \ Stmt *S, const Expr *&InitOrRHS) const;\n\n      bool containsDeclRefToVar(const\
  \ Stmt *S, const VarDecl *VD) const;\n\n      bool exprContainsUseOfVar(const Expr\
  \ *E, const VarDecl *VD) const {\n        if (!E || !VD) return false;\n       \
  \ return containsDeclRefToVar(E, VD);\n      }\n\n      bool stmtContainsUseOfVar(const\
  \ Stmt *S, const VarDecl *VD) const {\n        if (!S || !VD) return false;\n  \
  \      return containsDeclRefToVar(S, VD);\n      }\n\n      void collectConjuncts(const\
  \ Expr *Cond, llvm::SmallVector<const Expr*, 8> &Conj) const;\n\n      bool isPotentialRacyRead(const\
  \ Expr *E, CheckerContext &C) const;\n\n      void report(const Stmt *Highlight,\
  \ CheckerContext &C) const;\n};\n\nconst IfStmt *SAGenTestChecker::getEnclosingIf(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  return findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n}\n\nvoid SAGenTestChecker::getParentCompoundAndPrevStmt(const IfStmt *IS,\n\
  \                                                    const CheckerContext &C,\n\
  \                                                    const CompoundStmt *&CS,\n\
  \                                                    const Stmt *&Prev) const {\n\
  \  CS = findSpecificTypeInParents<CompoundStmt>(IS, const_cast<CheckerContext&>(C));\n\
  \  Prev = nullptr;\n  if (!CS || !IS) return;\n\n  const Stmt *PrevCandidate = nullptr;\n\
  \  for (const Stmt *S : CS->body()) {\n    if (S == IS) {\n      Prev = PrevCandidate;\n\
  \      return;\n    }\n    PrevCandidate = S;\n  }\n}\n\nconst VarDecl *SAGenTestChecker::getAssignedVar(const\
  \ Stmt *S, const Expr *&InitOrRHS) const {\n  InitOrRHS = nullptr;\n  if (!S) return\
  \ nullptr;\n\n  // Case 1: Declaration with initializer: e.g., \"unsigned long x\
  \ = *p;\"\n  if (const auto *DS = dyn_cast<DeclStmt>(S)) {\n    if (DS->isSingleDecl())\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl())) {\n    \
  \    if (VD->hasInit()) {\n          InitOrRHS = VD->getInit();\n          return\
  \ VD;\n        }\n      }\n    }\n  }\n\n  // Case 2: Simple assignment: e.g., \"\
  x = *p;\"\n  if (const auto *ES = dyn_cast<Expr>(S)) {\n    const Expr *E = ES->IgnoreParenImpCasts();\n\
  \    if (const auto *BO = dyn_cast<BinaryOperator>(E)) {\n      if (BO->getOpcode()\
  \ == BO_Assign) {\n        const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \        if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS)) {\n          if (const\
  \ auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n            InitOrRHS = BO->getRHS();\n\
  \            return VD;\n          }\n        }\n      }\n    }\n  }\n\n  return\
  \ nullptr;\n}\n\nbool SAGenTestChecker::containsDeclRefToVar(const Stmt *S, const\
  \ VarDecl *VD) const {\n  if (!S || !VD) return false;\n\n  if (const auto *DRE\
  \ = dyn_cast<DeclRefExpr>(S)) {\n    if (DRE->getDecl() == VD)\n      return true;\n\
  \  }\n\n  for (const Stmt *Child : S->children()) {\n    if (Child && containsDeclRefToVar(Child,\
  \ VD))\n      return true;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::collectConjuncts(const\
  \ Expr *Cond, llvm::SmallVector<const Expr*, 8> &Conj) const {\n  if (!Cond) return;\n\
  \  const Expr *E = Cond->IgnoreParenImpCasts();\n  if (const auto *BO = dyn_cast<BinaryOperator>(E))\
  \ {\n    if (BO->getOpcode() == BO_LAnd) {\n      collectConjuncts(BO->getLHS(),\
  \ Conj);\n      collectConjuncts(BO->getRHS(), Conj);\n      return;\n    }\n  }\n\
  \  Conj.push_back(E);\n}\n\nbool SAGenTestChecker::isPotentialRacyRead(const Expr\
  \ *E, CheckerContext &C) const {\n  if (!E) return false;\n\n  // Heuristic recursive\
  \ scan\n  std::function<bool(const Stmt*)> Scan = [&](const Stmt *S) -> bool {\n\
  \    if (!S) return false;\n\n    // Known racy patterns\n    if (const auto *UO\
  \ = dyn_cast<UnaryOperator>(S)) {\n      if (UO->getOpcode() == UO_Deref)\n    \
  \    return true;\n    }\n    if (isa<ArraySubscriptExpr>(S))\n      return true;\n\
  \    if (const auto *ME = dyn_cast<MemberExpr>(S)) {\n      if (ME->isArrow())\n\
  \        return true;\n    }\n\n    // Kernel-specific textual hints\n    if (const\
  \ auto *E2 = dyn_cast<Expr>(S)) {\n      if (ExprHasName(E2, \"work_data_bits\"\
  , C))\n        return true;\n      if (ExprHasName(E2, \"->data\", C))\n       \
  \ return true;\n    }\n\n    for (const Stmt *Child : S->children()) {\n      if\
  \ (Child && Scan(Child))\n        return true;\n    }\n    return false;\n  };\n\
  \n  return Scan(E);\n}\n\nvoid SAGenTestChecker::report(const Stmt *Highlight, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Speculative read of shared state before guard; move the read inside the guarded\
  \ branch\", N);\n  if (Highlight)\n    R->addRange(Highlight->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!Condition)\n    return;\n\n\
  \  const IfStmt *IS = getEnclosingIf(Condition, C);\n  if (!IS)\n    return;\n\n\
  \  // Find the previous statement in the same compound block.\n  const CompoundStmt\
  \ *CS = nullptr;\n  const Stmt *Prev = nullptr;\n  getParentCompoundAndPrevStmt(IS,\
  \ C, CS, Prev);\n  if (!Prev)\n    return;\n\n  // Extract the variable assigned/initialized\
  \ in Prev and the RHS expression.\n  const Expr *InitOrRHS = nullptr;\n  const VarDecl\
  \ *VD = getAssignedVar(Prev, InitOrRHS);\n  if (!VD || !InitOrRHS)\n    return;\n\
  \n  // We only care if the previous assignment looks like a potentially racy read.\n\
  \  if (!isPotentialRacyRead(InitOrRHS, C))\n    return;\n\n  // Get the condition\
  \ expression\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n\
  \    return;\n  CondE = CondE->IgnoreParenImpCasts();\n\n  bool Reported = false;\n\
  \n  // Shape 1: if (Guard && Uses(VD) && ...)\n  {\n    llvm::SmallVector<const\
  \ Expr*, 8> Conj;\n    collectConjuncts(CondE, Conj);\n    if (Conj.size() >= 2)\
  \ {\n      const Expr *Guard = Conj[0];\n      bool GuardUsesVD = exprContainsUseOfVar(Guard,\
  \ VD);\n      bool RestUseVD = false;\n      for (size_t i = 1; i < Conj.size();\
  \ ++i) {\n        if (exprContainsUseOfVar(Conj[i], VD)) {\n          RestUseVD\
  \ = true;\n          break;\n        }\n      }\n      if (!GuardUsesVD && RestUseVD)\
  \ {\n        report(InitOrRHS, C);\n        Reported = true;\n      }\n    }\n \
  \ }\n\n  // Shape 2: if (Guard) { Uses(VD) } [else doesn't use VD], and Cond doesn't\
  \ use VD\n  if (!Reported) {\n    if (!exprContainsUseOfVar(CondE, VD)) {\n    \
  \  const Stmt *ThenS = IS->getThen();\n      const Stmt *ElseS = IS->getElse();\n\
  \n      if (ThenS && stmtContainsUseOfVar(ThenS, VD)) {\n        bool ElseUses =\
  \ ElseS && stmtContainsUseOfVar(ElseS, VD);\n        if (!ElseUses) {\n        \
  \  report(InitOrRHS, C);\n          Reported = true;\n        }\n      }\n    }\n\
  \  }\n\n  // No state change required; purely structural checker.\n}\n\n} // end\
  \ anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects speculative shared reads performed before a guarding condition\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nworkqueue: Fix spruious data race in __flush_work()\n\
  \nWhen flushing a work item for cancellation, __flush_work() knows that it\nexclusively\
  \ owns the work item through its PENDING bit. 134874e2eee9\n(\"workqueue: Allow\
  \ cancel_work_sync() and disable_work() from atomic\ncontexts on BH work items\"\
  ) added a read of @work->data to determine whether\nto use busy wait for BH work\
  \ items that are being canceled. While the read\nis safe when @from_cancel, @work->data\
  \ was read before testing @from_cancel\nto simplify code structure:\n\n\tdata =\
  \ *work_data_bits(work);\n\tif (from_cancel &&\n\t    !WARN_ON_ONCE(data & WORK_STRUCT_PWQ)\
  \ && (data & WORK_OFFQ_BH)) {\n\nWhile the read data was never used if !@from_cancel,\
  \ this could trigger\nKCSAN data race detection spuriously:\n\n  ==================================================================\n\
  \  BUG: KCSAN: data-race in __flush_work / __flush_work\n\n  write to 0xffff8881223aa3e8\
  \ of 8 bytes by task 3998 on cpu 0:\n   instrument_write include/linux/instrumented.h:41\
  \ [inline]\n   ___set_bit include/asm-generic/bitops/instrumented-non-atomic.h:28\
  \ [inline]\n   insert_wq_barrier kernel/workqueue.c:3790 [inline]\n   start_flush_work\
  \ kernel/workqueue.c:4142 [inline]\n   __flush_work+0x30b/0x570 kernel/workqueue.c:4178\n\
  \   flush_work kernel/workqueue.c:4229 [inline]\n   ...\n\n  read to 0xffff8881223aa3e8\
  \ of 8 bytes by task 50 on cpu 1:\n   __flush_work+0x42a/0x570 kernel/workqueue.c:4188\n\
  \   flush_work kernel/workqueue.c:4229 [inline]\n   flush_delayed_work+0x66/0x70\
  \ kernel/workqueue.c:4251\n   ...\n\n  value changed: 0x0000000000400000 -> 0xffff88810006c00d\n\
  \nReorganize the code so that @from_cancel is tested before @work->data is\naccessed.\
  \ The only problem is triggering KCSAN detection spuriously. This\nshouldn't need\
  \ READ_ONCE() or other access qualifiers.\n\nNo functional changes.\n\nSigned-off-by:\
  \ Tejun Heo <tj@kernel.org>\nReported-by: syzbot+b3e4f2f51ed645fd5df2@syzkaller.appspotmail.com\n\
  Fixes: 134874e2eee9 (\"workqueue: Allow cancel_work_sync() and disable_work() from\
  \ atomic contexts on BH work items\")\nLink: http://lkml.kernel.org/r/000000000000ae429e061eea2157@google.com\n\
  Cc: Jens Axboe <axboe@kernel.dk>\n\n## Buggy Code\n\n```c\n// Function: __flush_work\
  \ in kernel/workqueue.c\nstatic bool __flush_work(struct work_struct *work, bool\
  \ from_cancel)\n{\n\tstruct wq_barrier barr;\n\tunsigned long data;\n\n\tif (WARN_ON(!wq_online))\n\
  \t\treturn false;\n\n\tif (WARN_ON(!work->func))\n\t\treturn false;\n\n\tif (!start_flush_work(work,\
  \ &barr, from_cancel))\n\t\treturn false;\n\n\t/*\n\t * start_flush_work() returned\
  \ %true. If @from_cancel is set, we know\n\t * that @work must have been executing\
  \ during start_flush_work() and\n\t * can't currently be queued. Its data must contain\
  \ OFFQ bits. If @work\n\t * was queued on a BH workqueue, we also know that it was\
  \ running in the\n\t * BH context and thus can be busy-waited.\n\t */\n\tdata =\
  \ *work_data_bits(work);\n\tif (from_cancel &&\n\t    !WARN_ON_ONCE(data & WORK_STRUCT_PWQ)\
  \ && (data & WORK_OFFQ_BH)) {\n\t\t/*\n\t\t * On RT, prevent a live lock when %current\
  \ preempted soft\n\t\t * interrupt processing or prevents ksoftirqd from running\
  \ by\n\t\t * keeping flipping BH. If the BH work item runs on a different\n\t\t\
  \ * CPU then this has no effect other than doing the BH\n\t\t * disable/enable dance\
  \ for nothing. This is copied from\n\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  \t\t */\n\t\twhile (!try_wait_for_completion(&barr.done)) {\n\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tlocal_bh_enable();\n\t\t\t} else {\n\t\
  \t\t\tcpu_relax();\n\t\t\t}\n\t\t}\n\t} else {\n\t\twait_for_completion(&barr.done);\n\
  \t}\n\n\tdestroy_work_on_stack(&barr.work);\n\treturn true;\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/kernel/workqueue.c b/kernel/workqueue.c\nindex\
  \ d56bd2277e58..ef174d8c1f63 100644\n--- a/kernel/workqueue.c\n+++ b/kernel/workqueue.c\n\
  @@ -4166,7 +4166,6 @@ static bool start_flush_work(struct work_struct *work, struct\
  \ wq_barrier *barr,\n static bool __flush_work(struct work_struct *work, bool from_cancel)\n\
  \ {\n \tstruct wq_barrier barr;\n-\tunsigned long data;\n \n \tif (WARN_ON(!wq_online))\n\
  \ \t\treturn false;\n@@ -4184,29 +4183,35 @@ static bool __flush_work(struct work_struct\
  \ *work, bool from_cancel)\n \t * was queued on a BH workqueue, we also know that\
  \ it was running in the\n \t * BH context and thus can be busy-waited.\n \t */\n\
  -\tdata = *work_data_bits(work);\n-\tif (from_cancel &&\n-\t    !WARN_ON_ONCE(data\
  \ & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_BH)) {\n-\t\t/*\n-\t\t * On RT, prevent\
  \ a live lock when %current preempted soft\n-\t\t * interrupt processing or prevents\
  \ ksoftirqd from running by\n-\t\t * keeping flipping BH. If the BH work item runs\
  \ on a different\n-\t\t * CPU then this has no effect other than doing the BH\n\
  -\t\t * disable/enable dance for nothing. This is copied from\n-\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  -\t\t */\n-\t\twhile (!try_wait_for_completion(&barr.done)) {\n-\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n-\t\t\t\tlocal_bh_disable();\n-\t\t\t\tlocal_bh_enable();\n-\t\t\t} else {\n\
  -\t\t\t\tcpu_relax();\n+\tif (from_cancel) {\n+\t\tunsigned long data = *work_data_bits(work);\n\
  +\n+\t\tif (!WARN_ON_ONCE(data & WORK_STRUCT_PWQ) &&\n+\t\t    (data & WORK_OFFQ_BH))\
  \ {\n+\t\t\t/*\n+\t\t\t * On RT, prevent a live lock when %current preempted\n+\t\
  \t\t * soft interrupt processing or prevents ksoftirqd from\n+\t\t\t * running by\
  \ keeping flipping BH. If the BH work item\n+\t\t\t * runs on a different CPU then\
  \ this has no effect other\n+\t\t\t * than doing the BH disable/enable dance for\
  \ nothing.\n+\t\t\t * This is copied from\n+\t\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  +\t\t\t */\n+\t\t\twhile (!try_wait_for_completion(&barr.done)) {\n+\t\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n+\t\t\t\t\tlocal_bh_disable();\n+\t\t\t\t\tlocal_bh_enable();\n+\t\t\t\t} else\
  \ {\n+\t\t\t\t\tcpu_relax();\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tgoto out_destroy;\n \t\
  \t}\n-\t} else {\n-\t\twait_for_completion(&barr.done);\n \t}\n \n+\twait_for_completion(&barr.done);\n\
  +\n+out_destroy:\n \tdestroy_work_on_stack(&barr.work);\n \treturn true;\n }\n```\n"
pattern: "## Bug Pattern\n\nUnconditionally reading a shared/concurrently modified\
  \ field before checking the precondition that guarantees safe access, even when\
  \ the value is only needed in one guarded branch. This speculative/early read happens\
  \ without synchronization and can race with concurrent writers, triggering KCSAN/data-race\
  \ reports despite the value being discarded when the guard is false.\n\nPattern\
  \ example:\n- Buggy:\n  - data = *shared_field;\n  - if (safe_to_access) use data;\n\
  - Correct:\n  - if (safe_to_access) {\n      data = *shared_field;\n      use data;\n\
  \    }\n\nIn the patch: reading work->data occurred before verifying from_cancel\
  \ (the condition that implies exclusive ownership), causing a spurious data race.\
  \ Moving the read inside the from_cancel branch fixes it."
plan: "1) Program state\n- Do not customize program states. This checker can be purely\
  \ AST- and path-structure based, using only the current CFG/AST to recognize the\
  \ pattern. No REGISTER_MAP_WITH_PROGRAMSTATE is needed.\n\n2) Callbacks to use\n\
  - checkBranchCondition: the single main callback. We analyze each if-condition to\
  \ detect the \u201Cearly/speculative read before guard\u201D shape and report.\n\
  \n3) Detailed steps and implementation\n\nA. Core idea to match\n- We want to detect\
  \ when a value is read from a potentially-shared/concurrently-modified memory location\
  \ unconditionally before an if, but is only needed under a guard inside that if.\n\
  - We will implement two common shapes:\n  1) AND-condition shape:\n     - Pattern:\
  \ decl/assign immediately before if, followed by if (Guard && Uses(VarReadFromShared)\
  \ && ...).\n     - Fix is to move the read into the guarded branch after Guard is\
  \ true.\n  2) Guard-then shape:\n     - Pattern: decl/assign immediately before\
  \ if, followed by if (Guard) { Uses(VarReadFromShared) ... } else { ... } where\
  \ the Var is not used in the else path.\n     - Fix is to move the read into the\
  \ then-branch.\n\nB. Utility helpers to implement\n- Parse helpers:\n  - findSpecificTypeInParents<IfStmt>(Condition,\
  \ C): get the IfStmt for the given condition expression.\n  - Write a small function\
  \ getParentCompoundAndPrevStmt(const IfStmt *IS, const CheckerContext &C, const\
  \ CompoundStmt *&CS, const Stmt *&Prev):\n    - Use findSpecificTypeInParents<CompoundStmt>(IS,\
  \ C).\n    - Iterate CS->body() to locate IS and find its immediate previous sibling\
  \ statement Prev (nullptr if none).\n- Variable-use helpers:\n  - const VarDecl\
  \ *getAssignedVar(const Stmt *S, const Expr *&InitOrRHS):\n    - If S is a DeclStmt\
  \ with a single VarDecl having an initializer, return that VarDecl and set InitOrRHS\
  \ to the initializer.\n    - If S is a BinaryOperator (BO_Assign) with LHS DeclRefExpr\
  \ to a VarDecl, return that VarDecl and set InitOrRHS to RHS.\n    - Otherwise return\
  \ nullptr.\n  - bool stmtContainsUseOfVar(const Stmt *S, const VarDecl *VD):\n \
  \   - Recursively traverse S to find any DeclRefExpr referring to VD.\n  - void\
  \ collectConjuncts(const Expr *Cond, SmallVector<const Expr*, 4> &Conj):\n    -\
  \ Decompose a left-associative chain of BO_LAnd into a vector from left to right.\
  \ For non-BO_LAnd, push the Cond as a single element.\n  - bool exprContainsUseOfVar(const\
  \ Expr *E, const VarDecl *VD):\n    - Similar traversal to stmtContainsUseOfVar.\n\
  - Racy-read classification helper:\n  - bool isPotentialRacyRead(const Expr *E,\
  \ CheckerContext &C):\n    - Return true if any of the following holds anywhere\
  \ in E (walk recursively):\n      - A UnaryOperator with opcode UO_Deref (explicit\
  \ dereference).\n      - An ArraySubscriptExpr.\n      - A MemberExpr where isArrow()\
  \ is true (pointer member access) or which textually contains \u201C->\u201D as\
  \ a heuristic.\n      - Additionally, allow textual heuristics via ExprHasName(E,\
  \ \"work_data_bits\", C) or ExprHasName(E, \"->data\", C) to capture common kernel\
  \ patterns. This targets the given bug and similar drivers/kernel code.\n    - This\
  \ remains a conservative heuristic to capture \u201Creads likely from shared/concurrently\
  \ modified memory\u201D.\n\nC. Detection in checkBranchCondition\n- Input: const\
  \ Stmt *Condition, CheckerContext &C.\n- Steps:\n  1) Find the IfStmt:\n     - const\
  \ IfStmt *IS = findSpecificTypeInParents<IfStmt>(Condition, C).\n     - If null,\
  \ return.\n  2) Find the immediate previous statement in the same block:\n     -\
  \ const CompoundStmt *CS; const Stmt *Prev;\n     - getParentCompoundAndPrevStmt(IS,\
  \ C, CS, Prev);\n     - If Prev is null, return.\n  3) Try to extract a variable\
  \ assignment that happens in Prev:\n     - const Expr *InitOrRHS = nullptr;\n  \
  \   - const VarDecl *VD = getAssignedVar(Prev, InitOrRHS);\n     - If VD == nullptr\
  \ or InitOrRHS == nullptr, return.\n     - If !isPotentialRacyRead(InitOrRHS, C),\
  \ return. We require the previous assignment to look like a load/deref/member/array\
  \ read that could be shared.\n  4) Identify the two shapes:\n\n     Shape 1: AND-condition\
  \ shape\n     - Decompose the condition into conjuncts using collectConjuncts.\n\
  \     - If there are at least 2 conjuncts:\n       - Let Guard = conjuncts[0].\n\
  \       - Check that Guard does not reference VD: !exprContainsUseOfVar(Guard, VD).\n\
  \       - Check that at least one of the remaining conjuncts references VD.\n  \
  \     - If satisfied, we have the pattern \u201CV = read; if (Guard && uses(V))\
  \ ...\u201D.\n       - Emit a report.\n\n     Shape 2: Guard-then shape\n     -\
  \ If the condition does not match the AND-condition shape, or even if it does but\
  \ you also want to catch more, check:\n       - Let ThenS = IS->getThen(); Let ElseS\
  \ = IS->getElse();\n       - If exprContainsUseOfVar(cast<Expr>(Condition), VD)\
  \ is true, skip this shape (we only handle pure if (Guard) {...} here).\n      \
  \ - If stmtContainsUseOfVar(ThenS, VD) is true AND (ElseS is null OR stmtContainsUseOfVar(ElseS,\
  \ VD) is false):\n         - We have \u201CV = read; if (Guard) { uses(V) } [else\
  \ doesn\u2019t use V]\u201D.\n         - Emit a report.\n\n  5) Bug report:\n  \
  \   - Create a BugType once, e.g., \u201CSpeculative shared read before guard\u201D\
  .\n     - Use generateNonFatalErrorNode(C.getState()) to create a node; if null,\
  \ return.\n     - Create PathSensitiveBugReport with a short message:\n       -\
  \ \u201CSpeculative read of shared state before guard; move the read inside the\
  \ guarded branch.\u201D\n     - Point the report location at the previous assignment\
  \ statement (Prev) or at InitOrRHS\u2019s source range for a precise highlight.\n\
  \     - Emit with C.emitReport(...).\n\nD. Notes and heuristics tuning\n- The isPotentialRacyRead\
  \ test is deliberately heuristic, but tailored to the kernel pattern illustrated:\n\
  \  - Unary '*' of a call (e.g., *work_data_bits(work)).\n  - Member access via '->'\
  \ or array indexing before a guard.\n  - Use ExprHasName for known helpers like\
  \ \u201Cwork_data_bits\u201D or \u201C->data\u201D to reduce false positives in\
  \ kernel code.\n- To reduce noise:\n  - Require the immediate previous statement\
  \ be the read-producing assignment/decl-init.\n  - Require the assigned variable\
  \ to be referenced only in guarded position(s) as described.\n  - Ensure the leftmost\
  \ guard conjunct does not use the variable (so moving the read under the guard is\
  \ feasible).\n\nE. Optional extensions (if needed later)\n- Extend the textual heuristics\
  \ table for more kernel helpers or struct fields known to be concurrently updated.\n\
  - Add a quick check that the guard identifier name looks like a guard (e.g., \u201C\
  from_\u201D, \u201Cis_\u201D, \u201Chas_\u201D, \u201Csafe_\u201D) using ExprHasName\
  \ on the leftmost conjunct; keep off by default.\n- Consider also detecting patterns\
  \ where the read is used only within a loop or a nested if inside the then-branch;\
  \ this can be done by reusing stmtContainsUseOfVar on nested constructs.\n\nSummary\n\
  - No program state.\n- One main callback: checkBranchCondition.\n- Find the IfStmt\
  \ and its previous sibling statement in the same CompoundStmt.\n- If the previous\
  \ statement initializes/assigns a variable from a potential shared read, and that\
  \ variable is only used in a guarded position (AND-condition right conjuncts or\
  \ inside then-only), warn to move the read into the guarded branch."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"llvm/ADT/SmallVector.h\"\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// No custom program states needed.\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<check::BranchCondition>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\n\
  \        : BT(new BugType(this, \"Speculative shared read before guard\", \"Concurrency\"\
  )) {}\n\n      void checkBranchCondition(const Stmt *Condition, CheckerContext &C)\
  \ const;\n\n   private:\n\n      // Helpers\n      const IfStmt *getEnclosingIf(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n      void getParentCompoundAndPrevStmt(const\
  \ IfStmt *IS,\n                                        const CheckerContext &C,\n\
  \                                        const CompoundStmt *&CS,\n            \
  \                            const Stmt *&Prev) const;\n\n      const VarDecl *getAssignedVar(const\
  \ Stmt *S, const Expr *&InitOrRHS) const;\n\n      bool containsDeclRefToVar(const\
  \ Stmt *S, const VarDecl *VD) const;\n\n      bool exprContainsUseOfVar(const Expr\
  \ *E, const VarDecl *VD) const {\n        if (!E || !VD) return false;\n       \
  \ return containsDeclRefToVar(E, VD);\n      }\n\n      bool stmtContainsUseOfVar(const\
  \ Stmt *S, const VarDecl *VD) const {\n        if (!S || !VD) return false;\n  \
  \      return containsDeclRefToVar(S, VD);\n      }\n\n      void collectConjuncts(const\
  \ Expr *Cond, llvm::SmallVector<const Expr*, 8> &Conj) const;\n\n      bool isPotentialRacyRead(const\
  \ Expr *E, CheckerContext &C) const;\n\n      void report(const Stmt *Highlight,\
  \ CheckerContext &C) const;\n};\n\nconst IfStmt *SAGenTestChecker::getEnclosingIf(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  return findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n}\n\nvoid SAGenTestChecker::getParentCompoundAndPrevStmt(const IfStmt *IS,\n\
  \                                                    const CheckerContext &C,\n\
  \                                                    const CompoundStmt *&CS,\n\
  \                                                    const Stmt *&Prev) const {\n\
  \  CS = findSpecificTypeInParents<CompoundStmt>(IS, const_cast<CheckerContext&>(C));\n\
  \  Prev = nullptr;\n  if (!CS || !IS) return;\n\n  const Stmt *PrevCandidate = nullptr;\n\
  \  for (const Stmt *S : CS->body()) {\n    if (S == IS) {\n      Prev = PrevCandidate;\n\
  \      return;\n    }\n    PrevCandidate = S;\n  }\n}\n\nconst VarDecl *SAGenTestChecker::getAssignedVar(const\
  \ Stmt *S, const Expr *&InitOrRHS) const {\n  InitOrRHS = nullptr;\n  if (!S) return\
  \ nullptr;\n\n  // Case 1: Declaration with initializer: e.g., \"unsigned long x\
  \ = *p;\"\n  if (const auto *DS = dyn_cast<DeclStmt>(S)) {\n    if (DS->isSingleDecl())\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl())) {\n    \
  \    if (VD->hasInit()) {\n          InitOrRHS = VD->getInit();\n          return\
  \ VD;\n        }\n      }\n    }\n  }\n\n  // Case 2: Simple assignment: e.g., \"\
  x = *p;\"\n  if (const auto *ES = dyn_cast<Expr>(S)) {\n    const Expr *E = ES->IgnoreParenImpCasts();\n\
  \    if (const auto *BO = dyn_cast<BinaryOperator>(E)) {\n      if (BO->getOpcode()\
  \ == BO_Assign) {\n        const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \        if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS)) {\n          if (const\
  \ auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n            InitOrRHS = BO->getRHS();\n\
  \            return VD;\n          }\n        }\n      }\n    }\n  }\n\n  return\
  \ nullptr;\n}\n\nbool SAGenTestChecker::containsDeclRefToVar(const Stmt *S, const\
  \ VarDecl *VD) const {\n  if (!S || !VD) return false;\n\n  if (const auto *DRE\
  \ = dyn_cast<DeclRefExpr>(S)) {\n    if (DRE->getDecl() == VD)\n      return true;\n\
  \  }\n\n  for (const Stmt *Child : S->children()) {\n    if (Child && containsDeclRefToVar(Child,\
  \ VD))\n      return true;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::collectConjuncts(const\
  \ Expr *Cond, llvm::SmallVector<const Expr*, 8> &Conj) const {\n  if (!Cond) return;\n\
  \  const Expr *E = Cond->IgnoreParenImpCasts();\n  if (const auto *BO = dyn_cast<BinaryOperator>(E))\
  \ {\n    if (BO->getOpcode() == BO_LAnd) {\n      collectConjuncts(BO->getLHS(),\
  \ Conj);\n      collectConjuncts(BO->getRHS(), Conj);\n      return;\n    }\n  }\n\
  \  Conj.push_back(E);\n}\n\nbool SAGenTestChecker::isPotentialRacyRead(const Expr\
  \ *E, CheckerContext &C) const {\n  if (!E) return false;\n\n  // Heuristic recursive\
  \ scan\n  std::function<bool(const Stmt*)> Scan = [&](const Stmt *S) -> bool {\n\
  \    if (!S) return false;\n\n    // Known racy patterns\n    if (const auto *UO\
  \ = dyn_cast<UnaryOperator>(S)) {\n      if (UO->getOpcode() == UO_Deref)\n    \
  \    return true;\n    }\n    if (isa<ArraySubscriptExpr>(S))\n      return true;\n\
  \    if (const auto *ME = dyn_cast<MemberExpr>(S)) {\n      if (ME->isArrow())\n\
  \        return true;\n    }\n\n    // Kernel-specific textual hints\n    if (const\
  \ auto *E2 = dyn_cast<Expr>(S)) {\n      if (ExprHasName(E2, \"work_data_bits\"\
  , C))\n        return true;\n      if (ExprHasName(E2, \"->data\", C))\n       \
  \ return true;\n    }\n\n    for (const Stmt *Child : S->children()) {\n      if\
  \ (Child && Scan(Child))\n        return true;\n    }\n    return false;\n  };\n\
  \n  return Scan(E);\n}\n\nvoid SAGenTestChecker::report(const Stmt *Highlight, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Speculative read of shared state before guard; move the read inside the guarded\
  \ branch\", N);\n  if (Highlight)\n    R->addRange(Highlight->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!Condition)\n    return;\n\n\
  \  const IfStmt *IS = getEnclosingIf(Condition, C);\n  if (!IS)\n    return;\n\n\
  \  // Find the previous statement in the same compound block.\n  const CompoundStmt\
  \ *CS = nullptr;\n  const Stmt *Prev = nullptr;\n  getParentCompoundAndPrevStmt(IS,\
  \ C, CS, Prev);\n  if (!Prev)\n    return;\n\n  // Extract the variable assigned/initialized\
  \ in Prev and the RHS expression.\n  const Expr *InitOrRHS = nullptr;\n  const VarDecl\
  \ *VD = getAssignedVar(Prev, InitOrRHS);\n  if (!VD || !InitOrRHS)\n    return;\n\
  \n  // We only care if the previous assignment looks like a potentially racy read.\n\
  \  if (!isPotentialRacyRead(InitOrRHS, C))\n    return;\n\n  // Get the condition\
  \ expression\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n\
  \    return;\n  CondE = CondE->IgnoreParenImpCasts();\n\n  bool Reported = false;\n\
  \n  // Shape 1: if (Guard && Uses(VD) && ...)\n  {\n    llvm::SmallVector<const\
  \ Expr*, 8> Conj;\n    collectConjuncts(CondE, Conj);\n    if (Conj.size() >= 2)\
  \ {\n      const Expr *Guard = Conj[0];\n      bool GuardUsesVD = exprContainsUseOfVar(Guard,\
  \ VD);\n      bool RestUseVD = false;\n      for (size_t i = 1; i < Conj.size();\
  \ ++i) {\n        if (exprContainsUseOfVar(Conj[i], VD)) {\n          RestUseVD\
  \ = true;\n          break;\n        }\n      }\n      if (!GuardUsesVD && RestUseVD)\
  \ {\n        report(InitOrRHS, C);\n        Reported = true;\n      }\n    }\n \
  \ }\n\n  // Shape 2: if (Guard) { Uses(VD) } [else doesn't use VD], and Cond doesn't\
  \ use VD\n  if (!Reported) {\n    if (!exprContainsUseOfVar(CondE, VD)) {\n    \
  \  const Stmt *ThenS = IS->getThen();\n      const Stmt *ElseS = IS->getElse();\n\
  \n      if (ThenS && stmtContainsUseOfVar(ThenS, VD)) {\n        bool ElseUses =\
  \ ElseS && stmtContainsUseOfVar(ElseS, VD);\n        if (!ElseUses) {\n        \
  \  report(InitOrRHS, C);\n          Reported = true;\n        }\n      }\n    }\n\
  \  }\n\n  // No state change required; purely structural checker.\n}\n\n} // end\
  \ anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects speculative shared reads performed before a guarding condition\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
