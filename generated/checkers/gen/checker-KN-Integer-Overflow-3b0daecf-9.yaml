_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3b0daecfeac0103aba8b293df07a0cbaf8b43f29
commit_type: Integer-Overflow
index: 9
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"\
  clang/Lex/Lexer.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\
  \n#include <limits>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No custom program states needed.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PostCall> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Allocator size multiplication\
  \ may overflow\", \"API Misuse\")) {}\n\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n   private:\n      // Helpers\n      static\
  \ bool isFunctionNamed(const CallEvent &Call, CheckerContext &C, StringRef Name);\n\
  \      static bool isArrayAllocator(const CallEvent &Call, CheckerContext &C);\n\
  \      static bool isScalarAllocator(const CallEvent &Call, CheckerContext &C);\n\
  \      static const BinaryOperator *findMulInSizeExpr(const Expr *E);\n      static\
  \ const UnaryExprOrTypeTraitExpr *findSizeofInExpr(const Expr *E);\n      static\
  \ bool getElementSizeFromSizeof(const UnaryExprOrTypeTraitExpr *UE, const ASTContext\
  \ &ACtx, uint64_t &Out);\n      static bool tryGetSymbolForExpr(const Expr *E, CheckerContext\
  \ &C, SymbolRef &OutSym);\n      static bool isProvablySafeCount(SymbolRef CountSym,\
  \ uint64_t ElemSize, CheckerContext &C);\n};\n\nbool SAGenTestChecker::isFunctionNamed(const\
  \ CallEvent &Call, CheckerContext &C, StringRef Name) {\n  const Expr *Origin =\
  \ Call.getOriginExpr();\n  if (!Origin)\n    return false;\n  return ExprHasName(Origin,\
  \ Name, C);\n}\n\nbool SAGenTestChecker::isArrayAllocator(const CallEvent &Call,\
  \ CheckerContext &C) {\n  // Known safe array allocators\n  static const char *Names[]\
  \ = {\n      \"kcalloc\", \"kmalloc_array\", \"kvcalloc\", \"devm_kcalloc\"\n  };\n\
  \  for (auto *N : Names)\n    if (isFunctionNamed(Call, C, N))\n      return true;\n\
  \  return false;\n}\n\nbool SAGenTestChecker::isScalarAllocator(const CallEvent\
  \ &Call, CheckerContext &C) {\n  // Scalar allocators with single size parameter\n\
  \  static const char *Names[] = {\n      \"kmalloc\", \"kzalloc\", \"kvzalloc\"\
  , \"kmalloc_node\", \"kzalloc_node\",\n      \"devm_kmalloc\", \"devm_kzalloc\"\n\
  \  };\n  for (auto *N : Names)\n    if (isFunctionNamed(Call, C, N))\n      return\
  \ true;\n  return false;\n}\n\nconst BinaryOperator *SAGenTestChecker::findMulInSizeExpr(const\
  \ Expr *E) {\n  if (!E)\n    return nullptr;\n  // Find a BinaryOperator somewhere\
  \ under E\n  if (const auto *BO = findSpecificTypeInChildren<BinaryOperator>(E))\
  \ {\n    if (BO->getOpcode() == BO_Mul)\n      return BO;\n  }\n  return nullptr;\n\
  }\n\nconst UnaryExprOrTypeTraitExpr *SAGenTestChecker::findSizeofInExpr(const Expr\
  \ *E) {\n  if (!E)\n    return nullptr;\n  if (const auto *UE = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(E))\
  \ {\n    if (UE->getKind() == UETT_SizeOf)\n      return UE;\n  }\n  return nullptr;\n\
  }\n\nbool SAGenTestChecker::getElementSizeFromSizeof(const UnaryExprOrTypeTraitExpr\
  \ *UE,\n                                                const ASTContext &ACtx,\
  \ uint64_t &Out) {\n  if (!UE)\n    return false;\n\n  // Try to evaluate sizeof\
  \ expression directly first\n  llvm::APSInt EvalRes;\n  Expr::EvalResult ER;\n \
  \ if (UE->EvaluateAsInt(ER, ACtx)) {\n    EvalRes = ER.Val.getInt();\n    Out =\
  \ EvalRes.getZExtValue();\n    return true;\n  }\n\n  // Fallback: compute from\
  \ type if available\n  QualType QT;\n  if (UE->isArgumentType())\n    QT = UE->getArgumentType();\n\
  \  else if (const Expr *ArgE = UE->getArgumentExpr())\n    QT = ArgE->getType();\n\
  \n  if (QT.isNull())\n    return false;\n\n  CharUnits CU = ACtx.getTypeSizeInChars(QT);\n\
  \  Out = static_cast<uint64_t>(CU.getQuantity());\n  return true;\n}\n\nbool SAGenTestChecker::tryGetSymbolForExpr(const\
  \ Expr *E, CheckerContext &C, SymbolRef &OutSym) {\n  if (!E)\n    return false;\n\
  \  ProgramStateRef State = C.getState();\n  SVal V = State->getSVal(E, C.getLocationContext());\n\
  \  if (SymbolRef S = V.getAsSymbol()) {\n    OutSym = S;\n    return true;\n  }\n\
  \  return false;\n}\n\nbool SAGenTestChecker::isProvablySafeCount(SymbolRef CountSym,\
  \ uint64_t ElemSize, CheckerContext &C) {\n  if (!CountSym || ElemSize == 0)\n \
  \   return false;\n\n  const llvm::APSInt *MaxVAPS = inferSymbolMaxVal(CountSym,\
  \ C);\n  if (!MaxVAPS)\n    return false;\n\n  // Compute the maximum size_t value\
  \ based on target size.\n  const ASTContext &ACtx = C.getASTContext();\n  unsigned\
  \ SizeTBits = ACtx.getTypeSize(ACtx.getSizeType());\n  uint64_t MaxSizeT;\n  if\
  \ (SizeTBits >= 64)\n    MaxSizeT = std::numeric_limits<uint64_t>::max();\n  else\n\
  \    MaxSizeT = (SizeTBits == 0) ? 0ULL : ((1ULL << SizeTBits) - 1ULL);\n\n  if\
  \ (ElemSize == 0)\n    return false;\n\n  uint64_t LimitCount = MaxSizeT / ElemSize;\n\
  \n  // Compare max bound of CountSym with limit.\n  uint64_t SymMax = MaxVAPS->getZExtValue();\n\
  \  return SymMax <= LimitCount;\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // Ignore safe array allocators\
  \ outright.\n  if (isArrayAllocator(Call, C))\n    return;\n\n  // Only handle scalar\
  \ allocators from our target set.\n  if (!isScalarAllocator(Call, C))\n    return;\n\
  \n  if (Call.getNumArgs() == 0)\n    return;\n\n  const Expr *SizeE = Call.getArgExpr(0);\n\
  \  if (!SizeE)\n    return;\n  SizeE = SizeE->IgnoreParenImpCasts();\n\n  // Suppress\
  \ if compile-time constant size (cannot overflow dynamically).\n  llvm::APSInt CEval;\n\
  \  if (EvaluateExprToInt(CEval, SizeE, C))\n    return;\n\n  // Look for a multiplication\
  \ in the size expression.\n  const BinaryOperator *Mul = findMulInSizeExpr(SizeE);\n\
  \  if (!Mul)\n    return;\n\n  // Verify the mul is a sizeof(...) * count pattern.\n\
  \  const Expr *LHS = Mul->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS =\
  \ Mul->getRHS()->IgnoreParenImpCasts();\n\n  const UnaryExprOrTypeTraitExpr *SizeofOnLHS\
  \ = findSizeofInExpr(LHS);\n  const UnaryExprOrTypeTraitExpr *SizeofOnRHS = findSizeofInExpr(RHS);\n\
  \n  // Fallback text search if AST pattern isn't found.\n  if (!SizeofOnLHS && ExprHasName(LHS,\
  \ \"sizeof\", C))\n    SizeofOnLHS = findSizeofInExpr(LHS);\n  if (!SizeofOnRHS\
  \ && ExprHasName(RHS, \"sizeof\", C))\n    SizeofOnRHS = findSizeofInExpr(RHS);\n\
  \n  if (!SizeofOnLHS && !SizeofOnRHS)\n    return; // Not a sizeof(...) * count\
  \ shape.\n\n  // Optional suppression via symbolic bounds:\n  // If exactly one\
  \ side has sizeof, try to get a symbol for the other side\n  // and check its maximal\
  \ value against SIZE_MAX / elem_size.\n  const Expr *CountExpr = nullptr;\n  const\
  \ UnaryExprOrTypeTraitExpr *SizeofExpr = nullptr;\n  if (SizeofOnLHS && !SizeofOnRHS)\
  \ {\n    SizeofExpr = SizeofOnLHS;\n    CountExpr = RHS;\n  } else if (!SizeofOnLHS\
  \ && SizeofOnRHS) {\n    SizeofExpr = SizeofOnRHS;\n    CountExpr = LHS;\n  }\n\n\
  \  bool Suppress = false;\n  if (CountExpr && SizeofExpr) {\n    uint64_t ElemSize\
  \ = 0;\n    if (getElementSizeFromSizeof(SizeofExpr, C.getASTContext(), ElemSize)\
  \ && ElemSize > 0) {\n      SymbolRef CountSym = nullptr;\n      if (tryGetSymbolForExpr(CountExpr,\
  \ C, CountSym)) {\n        if (isProvablySafeCount(CountSym, ElemSize, C))\n   \
  \       Suppress = true;\n      }\n    }\n  }\n\n  if (Suppress)\n    return;\n\n\
  \  // Report warning: multiplication-based size in scalar allocator -> suggest array\
  \ allocators.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n\
  \      \"Size uses sizeof(...) * count in kmalloc/kzalloc; use kcalloc/kmalloc_array\
  \ to avoid overflow\",\n      N);\n\n  // Highlight the size argument.\n  if (const\
  \ Expr *Arg0 = Call.getArgExpr(0))\n    R->addRange(Arg0->getSourceRange());\n\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects kmalloc/kzalloc with sizeof(...)\
  \ * count; suggest kcalloc/kmalloc_array to avoid overflow\",\n      \"\");\n}\n\
  \nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\namdkfd: use calloc instead of kzalloc to avoid integer\
  \ overflow\n\nThis uses calloc instead of doing the multiplication which might\n\
  overflow.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: kfd_ioctl_get_process_apertures_new in drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\t\t\t\tstruct\
  \ kfd_process *p, void *data)\n{\n\tstruct kfd_ioctl_get_process_apertures_new_args\
  \ *args = data;\n\tstruct kfd_process_device_apertures *pa;\n\tint ret;\n\tint i;\n\
  \n\tdev_dbg(kfd_device, \"get apertures for PASID 0x%x\", p->pasid);\n\n\tif (args->num_of_nodes\
  \ == 0) {\n\t\t/* Return number of nodes, so that user space can alloacate\n\t\t\
  \ * sufficient memory\n\t\t */\n\t\tmutex_lock(&p->mutex);\n\t\targs->num_of_nodes\
  \ = p->n_pdds;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Fill in process-aperture information\
  \ for all available\n\t * nodes, but not more than args->num_of_nodes as that is\n\
  \t * the amount of memory allocated by user\n\t */\n\tpa = kzalloc((sizeof(struct\
  \ kfd_process_device_apertures) *\n\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n\t\
  if (!pa)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&p->mutex);\n\n\tif (!p->n_pdds) {\n\
  \t\targs->num_of_nodes = 0;\n\t\tkfree(pa);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Run\
  \ over all pdd of the process */\n\tfor (i = 0; i < min(p->n_pdds, args->num_of_nodes);\
  \ i++) {\n\t\tstruct kfd_process_device *pdd = p->pdds[i];\n\n\t\tpa[i].gpu_id =\
  \ pdd->dev->id;\n\t\tpa[i].lds_base = pdd->lds_base;\n\t\tpa[i].lds_limit = pdd->lds_limit;\n\
  \t\tpa[i].gpuvm_base = pdd->gpuvm_base;\n\t\tpa[i].gpuvm_limit = pdd->gpuvm_limit;\n\
  \t\tpa[i].scratch_base = pdd->scratch_base;\n\t\tpa[i].scratch_limit = pdd->scratch_limit;\n\
  \n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpu id %u\\n\", pdd->dev->id);\n\t\tdev_dbg(kfd_device,\n\
  \t\t\t\"lds_base %llX\\n\", pdd->lds_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"lds_limit\
  \ %llX\\n\", pdd->lds_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_base %llX\\\
  n\", pdd->gpuvm_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_limit %llX\\n\",\
  \ pdd->gpuvm_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_base %llX\\n\", pdd->scratch_base);\n\
  \t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_limit %llX\\n\", pdd->scratch_limit);\n\
  \t}\n\tmutex_unlock(&p->mutex);\n\n\targs->num_of_nodes = i;\n\tret = copy_to_user(\n\
  \t\t\t(void __user *)args->kfd_process_device_apertures_ptr,\n\t\t\tpa,\n\t\t\t\
  (i * sizeof(struct kfd_process_device_apertures)));\n\tkfree(pa);\n\treturn ret\
  \ ? -EFAULT : 0;\n\nout_unlock:\n\tmutex_unlock(&p->mutex);\n\treturn 0;\n}\n```\n\
  \n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\
  \ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\nindex f9631f4b1a02..55aa74cbc532 100644\n\
  --- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  @@ -779,8 +779,8 @@ static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\
  \ \t * nodes, but not more than args->num_of_nodes as that is\n \t * the amount\
  \ of memory allocated by user\n \t */\n-\tpa = kzalloc((sizeof(struct kfd_process_device_apertures)\
  \ *\n-\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n+\tpa = kcalloc(args->num_of_nodes,\
  \ sizeof(struct kfd_process_device_apertures),\n+\t\t     GFP_KERNEL);\n \tif (!pa)\n\
  \ \t\treturn -ENOMEM;\n \n```\n"
pattern: '## Bug Pattern


  Allocating an array with kmalloc/kzalloc using manual multiplication (e.g., kzalloc(sizeof(elem)
  * n, GFP_KERNEL)) without overflow checking. If n is large or user-controlled, the
  size multiplication can overflow, causing an undersized allocation and subsequent
  out-of-bounds writes when filling n elements. The correct pattern is to use array
  allocators (kcalloc/kmalloc_array) which perform overflow checking.'
plan: "Plan\n\n1) Program state\n- No custom program state is necessary. This checker\
  \ is a pattern detector on call sites.\n\n2) Callbacks\n- Use checkPostCall as the\
  \ single entry point to detect the pattern. No alias or path reasoning is required.\n\
  \n3) Detection logic in checkPostCall\n- Identify relevant allocator functions:\n\
  \  - Bad (scalar) allocators taking a single size expression: kmalloc, kzalloc,\
  \ kvzalloc, kmalloc_node, kzalloc_node, devm_kmalloc, devm_kzalloc.\n  - Exclude\
  \ array allocators: kcalloc, kmalloc_array, kvcalloc, devm_kcalloc (never warn for\
  \ these).\n- For calls to the bad allocators:\n  - Determine the index of the size\
  \ argument:\n    - For all listed bad allocators, the size argument is arg[0].\n\
  \  - Extract the size expression: const Expr *SizeE = Call.getArgExpr(0)->IgnoreParenImpCasts().\n\
  \  - Find a multiplication in the size expression:\n    - Use findSpecificTypeInChildren<BinaryOperator>(SizeE).\n\
  \    - If a BinaryOperator is found, require BO_Mul (ignore other ops).\n    - If\
  \ not found at the top level, repeat once more by calling findSpecificTypeInChildren\
  \ starting from SizeE to find any descendant BinaryOperator and ensure it is BO_Mul.\n\
  \    - If no multiplication is found, do not warn.\n  - Check that the multiplication\
  \ involves a sizeof:\n    - On the found multiplication expression M (BinaryOperator\
  \ '*'), inspect both operands (LHS, RHS). For each:\n      - Use findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(operand)\
  \ and confirm Kind == UETT_SizeOf.\n      - Alternatively, as a fallback, use ExprHasName(operand,\
  \ \"sizeof\", C).\n    - If neither side contains a sizeof subtree, do not warn.\n\
  \  - Optional suppression for obvious constant-safe sizes:\n    - If EvaluateExprToInt(EvalRes,\
  \ SizeE, C) returns true (i.e., a compile-time constant), do not warn.\n  - Optional\
  \ suppression using symbolic max bounds (reduce noise):\n    - If exactly one side\
  \ contains sizeof(T) and the other side is a DeclRefExpr (or reduces to a symbol):\n\
  \      - Extract sizeof(T) as an integer:\n        - The sizeof AST is a UnaryExprOrTypeTraitExpr.\
  \ Get its argument\u2019s type, then compute element size in bytes using C.getASTContext().getTypeSizeInChars(QT).getQuantity()\
  \ (or evaluate the sizeof expr directly via EvaluateExprToInt).\n      - Obtain\
  \ the symbol for the count side via ProgramState SVal lookup or from Call.getArgSVal(0)\
  \ subtree; if you can get SymbolRef CountSym, then:\n        - Use inferSymbolMaxVal(CountSym,\
  \ C) to get a max bound.\n        - Compute limit = SIZE_MAX / elem_size (use ASTContext.getTypeSize(C.getASTContext().getSizeType())\
  \ to get size_t width and build an APSInt of all-ones).\n        - If maxVal <=\
  \ limit, skip reporting; otherwise, continue to warn.\n    - If any of the above\
  \ steps fail, proceed with warning (conservative).\n  - Emit a report:\n    - Create\
  \ a BugType once (e.g., \"Potential overflow in size calculation for kmalloc/kzalloc\"\
  ).\n    - Generate a non-fatal error node and emit a PathSensitiveBugReport at the\
  \ call expression.\n    - Short message: \"Size uses sizeof(...) * count in kmalloc/kzalloc;\
  \ use kcalloc/kmalloc_array to avoid overflow.\"\n    - Point the primary location\
  \ to the size argument (SizeE) if available.\n    - Optionally, add a note with\
  \ the function name to guide remediation: \"Replace with kcalloc(count, sizeof(elem),\
  \ ...).\"\n\n4) Helper details\n- Function filtering:\n  - Implement a small helper\
  \ isScalarAllocator(const CallEvent &Call) that matches callee names from a small\
  \ set:\n    - {\"kmalloc\", \"kzalloc\", \"kvzalloc\", \"kmalloc_node\", \"kzalloc_node\"\
  , \"devm_kmalloc\", \"devm_kzalloc\"}.\n  - Implement isArrayAllocator similarly\
  \ ({\"kcalloc\", \"kmalloc_array\", \"kvcalloc\", \"devm_kcalloc\"}) and early-return\
  \ if true.\n- Size argument retrieval:\n  - For all targeted scalar allocators,\
  \ the size expression is argument 0; ignore parens/implicit casts.\n- Finding sizeof:\n\
  \  - Use findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr> to detect sizeof anywhere\
  \ under an operand.\n- Constant evaluation:\n  - Use EvaluateExprToInt on the full\
  \ SizeE to drop compile-time-constant sizes.\n- Symbolic maximum (optional noise\
  \ reduction):\n  - If the non-sizeof multiplicand is a simple DeclRefExpr or resolves\
  \ to a symbolic SVal, attempt inferSymbolMaxVal and compare against the computed\
  \ limit as described above.\n\n5) Scope and limitations\n- The checker focuses on\
  \ direct multiplications in the size argument for scalar allocators. It intentionally\
  \ does not handle more complex overflow-protected patterns (e.g., array_size helpers)\
  \ because those won\u2019t present as a direct sizeof * count multiply or will fail\
  \ the sizeof detection.\n- This is a best-effort structural check; if conditions\
  \ are statically constant-safe or prove bounded under the size limit, it suppresses\
  \ warnings; otherwise, it warns.\n\n6) Chosen callbacks summary\n- checkPostCall:\n\
  \  - Detect bad allocator calls with multiplied size expressions involving sizeof.\n\
  \  - Suppress on compile-time constant or provably bounded count (optional).\n \
  \ - Emit a concise report recommending kcalloc/kmalloc_array."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"\
  clang/Lex/Lexer.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\
  \n#include <limits>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No custom program states needed.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PostCall> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Allocator size multiplication\
  \ may overflow\", \"API Misuse\")) {}\n\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n   private:\n      // Helpers\n      static\
  \ bool isFunctionNamed(const CallEvent &Call, CheckerContext &C, StringRef Name);\n\
  \      static bool isArrayAllocator(const CallEvent &Call, CheckerContext &C);\n\
  \      static bool isScalarAllocator(const CallEvent &Call, CheckerContext &C);\n\
  \      static const BinaryOperator *findMulInSizeExpr(const Expr *E);\n      static\
  \ const UnaryExprOrTypeTraitExpr *findSizeofInExpr(const Expr *E);\n      static\
  \ bool getElementSizeFromSizeof(const UnaryExprOrTypeTraitExpr *UE, const ASTContext\
  \ &ACtx, uint64_t &Out);\n      static bool tryGetSymbolForExpr(const Expr *E, CheckerContext\
  \ &C, SymbolRef &OutSym);\n      static bool isProvablySafeCount(SymbolRef CountSym,\
  \ uint64_t ElemSize, CheckerContext &C);\n};\n\nbool SAGenTestChecker::isFunctionNamed(const\
  \ CallEvent &Call, CheckerContext &C, StringRef Name) {\n  const Expr *Origin =\
  \ Call.getOriginExpr();\n  if (!Origin)\n    return false;\n  return ExprHasName(Origin,\
  \ Name, C);\n}\n\nbool SAGenTestChecker::isArrayAllocator(const CallEvent &Call,\
  \ CheckerContext &C) {\n  // Known safe array allocators\n  static const char *Names[]\
  \ = {\n      \"kcalloc\", \"kmalloc_array\", \"kvcalloc\", \"devm_kcalloc\"\n  };\n\
  \  for (auto *N : Names)\n    if (isFunctionNamed(Call, C, N))\n      return true;\n\
  \  return false;\n}\n\nbool SAGenTestChecker::isScalarAllocator(const CallEvent\
  \ &Call, CheckerContext &C) {\n  // Scalar allocators with single size parameter\n\
  \  static const char *Names[] = {\n      \"kmalloc\", \"kzalloc\", \"kvzalloc\"\
  , \"kmalloc_node\", \"kzalloc_node\",\n      \"devm_kmalloc\", \"devm_kzalloc\"\n\
  \  };\n  for (auto *N : Names)\n    if (isFunctionNamed(Call, C, N))\n      return\
  \ true;\n  return false;\n}\n\nconst BinaryOperator *SAGenTestChecker::findMulInSizeExpr(const\
  \ Expr *E) {\n  if (!E)\n    return nullptr;\n  // Find a BinaryOperator somewhere\
  \ under E\n  if (const auto *BO = findSpecificTypeInChildren<BinaryOperator>(E))\
  \ {\n    if (BO->getOpcode() == BO_Mul)\n      return BO;\n  }\n  return nullptr;\n\
  }\n\nconst UnaryExprOrTypeTraitExpr *SAGenTestChecker::findSizeofInExpr(const Expr\
  \ *E) {\n  if (!E)\n    return nullptr;\n  if (const auto *UE = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(E))\
  \ {\n    if (UE->getKind() == UETT_SizeOf)\n      return UE;\n  }\n  return nullptr;\n\
  }\n\nbool SAGenTestChecker::getElementSizeFromSizeof(const UnaryExprOrTypeTraitExpr\
  \ *UE,\n                                                const ASTContext &ACtx,\
  \ uint64_t &Out) {\n  if (!UE)\n    return false;\n\n  // Try to evaluate sizeof\
  \ expression directly first\n  llvm::APSInt EvalRes;\n  Expr::EvalResult ER;\n \
  \ if (UE->EvaluateAsInt(ER, ACtx)) {\n    EvalRes = ER.Val.getInt();\n    Out =\
  \ EvalRes.getZExtValue();\n    return true;\n  }\n\n  // Fallback: compute from\
  \ type if available\n  QualType QT;\n  if (UE->isArgumentType())\n    QT = UE->getArgumentType();\n\
  \  else if (const Expr *ArgE = UE->getArgumentExpr())\n    QT = ArgE->getType();\n\
  \n  if (QT.isNull())\n    return false;\n\n  CharUnits CU = ACtx.getTypeSizeInChars(QT);\n\
  \  Out = static_cast<uint64_t>(CU.getQuantity());\n  return true;\n}\n\nbool SAGenTestChecker::tryGetSymbolForExpr(const\
  \ Expr *E, CheckerContext &C, SymbolRef &OutSym) {\n  if (!E)\n    return false;\n\
  \  ProgramStateRef State = C.getState();\n  SVal V = State->getSVal(E, C.getLocationContext());\n\
  \  if (SymbolRef S = V.getAsSymbol()) {\n    OutSym = S;\n    return true;\n  }\n\
  \  return false;\n}\n\nbool SAGenTestChecker::isProvablySafeCount(SymbolRef CountSym,\
  \ uint64_t ElemSize, CheckerContext &C) {\n  if (!CountSym || ElemSize == 0)\n \
  \   return false;\n\n  const llvm::APSInt *MaxVAPS = inferSymbolMaxVal(CountSym,\
  \ C);\n  if (!MaxVAPS)\n    return false;\n\n  // Compute the maximum size_t value\
  \ based on target size.\n  const ASTContext &ACtx = C.getASTContext();\n  unsigned\
  \ SizeTBits = ACtx.getTypeSize(ACtx.getSizeType());\n  uint64_t MaxSizeT;\n  if\
  \ (SizeTBits >= 64)\n    MaxSizeT = std::numeric_limits<uint64_t>::max();\n  else\n\
  \    MaxSizeT = (SizeTBits == 0) ? 0ULL : ((1ULL << SizeTBits) - 1ULL);\n\n  if\
  \ (ElemSize == 0)\n    return false;\n\n  uint64_t LimitCount = MaxSizeT / ElemSize;\n\
  \n  // Compare max bound of CountSym with limit.\n  uint64_t SymMax = MaxVAPS->getZExtValue();\n\
  \  return SymMax <= LimitCount;\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // Ignore safe array allocators\
  \ outright.\n  if (isArrayAllocator(Call, C))\n    return;\n\n  // Only handle scalar\
  \ allocators from our target set.\n  if (!isScalarAllocator(Call, C))\n    return;\n\
  \n  if (Call.getNumArgs() == 0)\n    return;\n\n  const Expr *SizeE = Call.getArgExpr(0);\n\
  \  if (!SizeE)\n    return;\n  SizeE = SizeE->IgnoreParenImpCasts();\n\n  // Suppress\
  \ if compile-time constant size (cannot overflow dynamically).\n  llvm::APSInt CEval;\n\
  \  if (EvaluateExprToInt(CEval, SizeE, C))\n    return;\n\n  // Look for a multiplication\
  \ in the size expression.\n  const BinaryOperator *Mul = findMulInSizeExpr(SizeE);\n\
  \  if (!Mul)\n    return;\n\n  // Verify the mul is a sizeof(...) * count pattern.\n\
  \  const Expr *LHS = Mul->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS =\
  \ Mul->getRHS()->IgnoreParenImpCasts();\n\n  const UnaryExprOrTypeTraitExpr *SizeofOnLHS\
  \ = findSizeofInExpr(LHS);\n  const UnaryExprOrTypeTraitExpr *SizeofOnRHS = findSizeofInExpr(RHS);\n\
  \n  // Fallback text search if AST pattern isn't found.\n  if (!SizeofOnLHS && ExprHasName(LHS,\
  \ \"sizeof\", C))\n    SizeofOnLHS = findSizeofInExpr(LHS);\n  if (!SizeofOnRHS\
  \ && ExprHasName(RHS, \"sizeof\", C))\n    SizeofOnRHS = findSizeofInExpr(RHS);\n\
  \n  if (!SizeofOnLHS && !SizeofOnRHS)\n    return; // Not a sizeof(...) * count\
  \ shape.\n\n  // Optional suppression via symbolic bounds:\n  // If exactly one\
  \ side has sizeof, try to get a symbol for the other side\n  // and check its maximal\
  \ value against SIZE_MAX / elem_size.\n  const Expr *CountExpr = nullptr;\n  const\
  \ UnaryExprOrTypeTraitExpr *SizeofExpr = nullptr;\n  if (SizeofOnLHS && !SizeofOnRHS)\
  \ {\n    SizeofExpr = SizeofOnLHS;\n    CountExpr = RHS;\n  } else if (!SizeofOnLHS\
  \ && SizeofOnRHS) {\n    SizeofExpr = SizeofOnRHS;\n    CountExpr = LHS;\n  }\n\n\
  \  bool Suppress = false;\n  if (CountExpr && SizeofExpr) {\n    uint64_t ElemSize\
  \ = 0;\n    if (getElementSizeFromSizeof(SizeofExpr, C.getASTContext(), ElemSize)\
  \ && ElemSize > 0) {\n      SymbolRef CountSym = nullptr;\n      if (tryGetSymbolForExpr(CountExpr,\
  \ C, CountSym)) {\n        if (isProvablySafeCount(CountSym, ElemSize, C))\n   \
  \       Suppress = true;\n      }\n    }\n  }\n\n  if (Suppress)\n    return;\n\n\
  \  // Report warning: multiplication-based size in scalar allocator -> suggest array\
  \ allocators.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n\
  \      \"Size uses sizeof(...) * count in kmalloc/kzalloc; use kcalloc/kmalloc_array\
  \ to avoid overflow\",\n      N);\n\n  // Highlight the size argument.\n  if (const\
  \ Expr *Arg0 = Call.getArgExpr(0))\n    R->addRange(Arg0->getSourceRange());\n\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects kmalloc/kzalloc with sizeof(...)\
  \ * count; suggest kcalloc/kmalloc_array to avoid overflow\",\n      \"\");\n}\n\
  \nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
