_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 81137162bfaa7278785b24c1fd2e9e74f082e8e4
commit_type: Buffer-Overflow
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include <string>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No program state customization needed.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unbounded string\
  \ copy into fixed-size buffer\", \"Memory Safety\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n      // Helper to\
  \ check if call is to an unbounded copy API like strcpy\n      static bool isUnboundedCopy(const\
  \ CallEvent &Call, CheckerContext &C);\n\n      // Get constant array size and element\
  \ type from a destination expression\n      static bool getFixedArraySize(const\
  \ Expr *E, llvm::APInt &OutSize, QualType &ElemTy, CheckerContext &C);\n\n     \
  \ // Check if element type is a character type (char, signed char, unsigned char)\n\
  \      static bool isCharType(QualType T);\n\n      // Try to extract constant array\
  \ info from a QualType\n      static bool getConstArrayInfo(QualType QT, llvm::APInt\
  \ &OutSize, QualType &ElemTy);\n};\n\nbool SAGenTestChecker::isUnboundedCopy(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n\n  // Prefer robust textual matching function\
  \ provided.\n  if (ExprHasName(OriginExpr, \"strcpy\", C))\n    return true;\n\n\
  \  return false;\n}\n\nbool SAGenTestChecker::getConstArrayInfo(QualType QT, llvm::APInt\
  \ &OutSize, QualType &ElemTy) {\n  if (const auto *CAT = dyn_cast_or_null<ConstantArrayType>(QT.getTypePtr()))\
  \ {\n    OutSize = CAT->getSize();\n    ElemTy = CAT->getElementType();\n    return\
  \ true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isCharType(QualType T)\
  \ {\n  T = T.getCanonicalType();\n  if (T->isAnyCharacterType())\n    return true;\n\
  \n  if (const auto *BT = T->getAs<BuiltinType>()) {\n    switch (BT->getKind())\
  \ {\n    case BuiltinType::SChar:\n    case BuiltinType::UChar:\n    case BuiltinType::Char_S:\n\
  \    case BuiltinType::Char_U:\n    case BuiltinType::Char8:\n      return true;\n\
  \    default:\n      break;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getFixedArraySize(const\
  \ Expr *E, llvm::APInt &OutSize, QualType &ElemTy, CheckerContext &C) {\n  if (!E)\n\
  \    return false;\n\n  const Expr *Cur = E->IgnoreImpCasts();\n\n  // Handle &arr[0]\n\
  \  if (const auto *UO = dyn_cast<UnaryOperator>(Cur)) {\n    if (UO->getOpcode()\
  \ == UO_AddrOf) {\n      Cur = UO->getSubExpr()->IgnoreImpCasts();\n    }\n  }\n\
  \n  // Direct variable reference of an array\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(Cur))\
  \ {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n      return\
  \ getConstArrayInfo(VD->getType(), OutSize, ElemTy);\n    }\n  }\n\n  // Struct/union\
  \ member array like di.name\n  if (const auto *ME = dyn_cast<MemberExpr>(Cur)) {\n\
  \    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n      return\
  \ getConstArrayInfo(FD->getType(), OutSize, ElemTy);\n    }\n  }\n\n  // Array subscript\
  \ like arr[0] or s.name[0]\n  if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(Cur))\
  \ {\n    const Expr *Base = ASE->getBase()->IgnoreImpCasts();\n    const Expr *Idx\
  \ = ASE->getIdx()->IgnoreImpCasts();\n\n    // Evaluate index, ensure it is 0\n\
  \    llvm::APSInt IdxVal;\n    if (!EvaluateExprToInt(IdxVal, Idx, C))\n      return\
  \ false;\n    if (IdxVal != 0)\n      return false;\n\n    // Base can be DeclRefExpr\
  \ or MemberExpr (array)\n    if (const auto *BDRE = dyn_cast<DeclRefExpr>(Base))\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(BDRE->getDecl())) {\n        return\
  \ getConstArrayInfo(VD->getType(), OutSize, ElemTy);\n      }\n    } else if (const\
  \ auto *BME = dyn_cast<MemberExpr>(Base)) {\n      if (const auto *FD = dyn_cast<FieldDecl>(BME->getMemberDecl()))\
  \ {\n        return getConstArrayInfo(FD->getType(), OutSize, ElemTy);\n      }\n\
  \    }\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  if (!isUnboundedCopy(Call, C))\n    return;\n\
  \n  if (Call.getNumArgs() < 2)\n    return;\n\n  const Expr *DestE = Call.getArgExpr(0);\n\
  \  if (!DestE)\n    return;\n\n  llvm::APInt DestSize(64, 0);\n  QualType ElemTy;\n\
  \  if (!getFixedArraySize(DestE, DestSize, ElemTy, C))\n    return;\n\n  if (!isCharType(ElemTy))\n\
  \    return;\n\n  // Optional refinement if source is string literal\n  const Expr\
  \ *SrcE = Call.getArgExpr(1);\n  if (!SrcE)\n    return;\n\n  llvm::APInt StringLen;\n\
  \  bool DefiniteOverflow = false;\n  if (getStringSize(StringLen, SrcE)) {\n   \
  \ // strcpy copies src length + 1 (for NUL). If StringLen >= DestSize, definite\
  \ overflow.\n    if (StringLen.uge(DestSize))\n      DefiniteOverflow = true;\n\
  \    else\n      return; // Clearly safe with literal smaller than dest.\n  }\n\n\
  \  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n\
  \  std::string Msg;\n  if (DefiniteOverflow) {\n    unsigned long long D = DestSize.getLimitedValue();\n\
  \    unsigned long long S = StringLen.getLimitedValue();\n    Msg = \"strcpy may\
  \ overflow fixed-size buffer (dest size \" + std::to_string(D) +\n          \",\
  \ source literal length \" + std::to_string(S) + \")\";\n  } else {\n    Msg = \"\
  Unbounded copy into fixed-size buffer; use strscpy(dest, src, sizeof(dest))\";\n\
  \  }\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n  R->addRange(DestE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects unbounded string copies (e.g.,\
  \ strcpy) into fixed-size buffers; suggests strscpy with sizeof(dest)\",\n     \
  \ \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: hci_core: Fix possible buffer overflow\n\
  \nstruct hci_dev_info has a fixed size name[8] field so in the event that\nhdev->name\
  \ is bigger than that strcpy would attempt to write past its\nsize, so this fixes\
  \ this problem by switching to use strscpy.\n\nFixes: dcda165706b9 (\"Bluetooth:\
  \ hci_core: Fix build warnings\")\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\n\
  \n## Buggy Code\n\n```c\n// Function: hci_get_dev_info in net/bluetooth/hci_core.c\n\
  int hci_get_dev_info(void __user *arg)\n{\n\tstruct hci_dev *hdev;\n\tstruct hci_dev_info\
  \ di;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (copy_from_user(&di, arg,\
  \ sizeof(di)))\n\t\treturn -EFAULT;\n\n\thdev = hci_dev_get(di.dev_id);\n\tif (!hdev)\n\
  \t\treturn -ENODEV;\n\n\t/* When the auto-off is configured it means the transport\n\
  \t * is running, but in that case still indicate that the\n\t * device is actually\
  \ down.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_AUTO_OFF))\n\t\tflags = hdev->flags\
  \ & ~BIT(HCI_UP);\n\telse\n\t\tflags = hdev->flags;\n\n\tstrcpy(di.name, hdev->name);\n\
  \tdi.bdaddr   = hdev->bdaddr;\n\tdi.type     = (hdev->bus & 0x0f) | ((hdev->dev_type\
  \ & 0x03) << 4);\n\tdi.flags    = flags;\n\tdi.pkt_type = hdev->pkt_type;\n\tif\
  \ (lmp_bredr_capable(hdev)) {\n\t\tdi.acl_mtu  = hdev->acl_mtu;\n\t\tdi.acl_pkts\
  \ = hdev->acl_pkts;\n\t\tdi.sco_mtu  = hdev->sco_mtu;\n\t\tdi.sco_pkts = hdev->sco_pkts;\n\
  \t} else {\n\t\tdi.acl_mtu  = hdev->le_mtu;\n\t\tdi.acl_pkts = hdev->le_pkts;\n\t\
  \tdi.sco_mtu  = 0;\n\t\tdi.sco_pkts = 0;\n\t}\n\tdi.link_policy = hdev->link_policy;\n\
  \tdi.link_mode   = hdev->link_mode;\n\n\tmemcpy(&di.stat, &hdev->stat, sizeof(di.stat));\n\
  \tmemcpy(&di.features, &hdev->features, sizeof(di.features));\n\n\tif (copy_to_user(arg,\
  \ &di, sizeof(di)))\n\t\terr = -EFAULT;\n\n\thci_dev_put(hdev);\n\n\treturn err;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c\n\
  index 6ca4c0df9f9c..230d2bbb933b 100644\n--- a/net/bluetooth/hci_core.c\n+++ b/net/bluetooth/hci_core.c\n\
  @@ -908,7 +908,7 @@ int hci_get_dev_info(void __user *arg)\n \telse\n \t\tflags\
  \ = hdev->flags;\n \n-\tstrcpy(di.name, hdev->name);\n+\tstrscpy(di.name, hdev->name,\
  \ sizeof(di.name));\n \tdi.bdaddr   = hdev->bdaddr;\n \tdi.type     = (hdev->bus\
  \ & 0x0f) | ((hdev->dev_type & 0x03) << 4);\n \tdi.flags    = flags;\n```\n"
pattern: "## Bug Pattern\n\nUsing an unbounded string copy (e.g., strcpy) to copy\
  \ a potentially long string into a fixed-size struct field, without enforcing the\
  \ destination buffer\u2019s size, leading to buffer overflow. Example:\n\nchar dest[8];\
  \            // fixed-size struct field\nconst char *src = hdev->name; // variable-length\
  \ string\nstrcpy(dest, src);       // overflows if src >= 8\n\nCorrect pattern:\
  \ strscpy(dest, src, sizeof(dest)) to bound and NUL-terminate."
plan: "Plan\n\n1) Program state customization\n- Not needed. This checker is a pure\
  \ AST/value-shape check around calls to unbounded string copy APIs. No alias or\
  \ path-sensitive tracking is required.\n\n2) Callback functions\n- Use only checkPreCall.\
  \ It is sufficient to intercept calls to strcpy (and optionally strcat) and examine\
  \ the destination argument\u2019s type/shape.\n\n3) checkPreCall: detect unbounded\
  \ copy into fixed-size array\n- Target functions:\n  - Identify calls whose callee\
  \ identifier is exactly \"strcpy\" (optionally include \"strcat\"). Ignore others.\n\
  - Extract destination expression:\n  - Let DestE = Call.getArgExpr(0).\n  - Strip\
  \ casts: DestBase = DestE->IgnoreImpCasts().\n- Compute the destination buffer\u2019\
  s compile-time bound:\n  - Try local/global array:\n    - If DestBase is DeclRefExpr\
  \ and refers to a VarDecl/FieldDecl with ConstantArrayType, obtain size (you may\
  \ directly reuse getArraySizeFromExpr for DeclRefExpr case).\n  - Struct field array\
  \ (di.name case):\n    - If DestBase is MemberExpr, retrieve FieldDecl = cast<FieldDecl>(ME->getMemberDecl()).\n\
  \    - Let FT = FieldDecl->getType(). If FT is ConstantArrayType, get size via cast<ConstantArrayType>(FT.getTypePtr())->getSize().\n\
  \  - Optional simple A[i] form:\n    - If DestBase is ArraySubscriptExpr with Base\
  \ being DeclRefExpr or MemberExpr that denotes ConstantArrayType and the index is\
  \ integer constant 0, treat it as the whole array and reuse the above logic.\n \
  \ - If none of the above yield a ConstantArrayType, return without reporting (destination\
  \ size unknown).\n  - Optional type check: ensure the element type of the array\
  \ is char/unsigned char/signed char to avoid false positives on non-character arrays.\n\
  - Optional source literal length refinement:\n  - Let SrcE = Call.getArgExpr(1).\n\
  \  - If SrcE is a string literal, getStringSize(StringLen, SrcE).\n    - If StringLen\
  \ >= DestSize, report as definite overflow.\n    - If StringLen < DestSize, do not\
  \ report (clearly safe).\n  - Otherwise (non-literal source), proceed to report\
  \ as a risky unbounded copy into fixed-size buffer.\n- Reporting:\n  - Create a\
  \ non-fatal error node: if (ExplodedNode *N = C.generateNonFatalErrorNode()) { ...\
  \ }.\n  - Use a PathSensitiveBugReport (short message). Example messages:\n    -\
  \ Definite overflow case: \"strcpy may overflow fixed-size buffer (dest size N,\
  \ source literal length M).\"\n    - Risky case: \"Unbounded copy into fixed-size\
  \ buffer; use strscpy(dest, src, sizeof(dest)).\"\n  - Add the destination argument\
  \ as the primary range for better highlighting (C.getSourceManager(), DestE->getSourceRange()).\n\
  \n4) Helper utilities to include in the checker (internal helpers)\n- bool isUnboundedCopy(const\
  \ CallEvent &Call):\n  - Return true if callee identifier is \"strcpy\" (optionally\
  \ also match \"strcat\").\n- bool getFixedArraySize(const Expr *E, llvm::APInt &OutSize):\n\
  \  - Try in order:\n    - If E is DeclRefExpr: use getArraySizeFromExpr(OutSize,\
  \ E).\n    - If E is MemberExpr: inspect FieldDecl->getType() for ConstantArrayType\
  \ and extract size.\n    - If E is ArraySubscriptExpr: if Base is DeclRefExpr/MemberExpr\
  \ to ConstantArrayType and index is 0 constant, reuse above; otherwise fail.\n \
  \ - Return true if size found.\n- bool isCharArrayType(QualType T):\n  - If T is\
  \ ConstantArrayType, get element type ET and check ET->isAnyCharacterType().\n-\
  \ Optional: size refinement for string literals:\n  - Use provided getStringSize\
  \ to obtain literal length quickly.\n\n5) Minimal logic summary inside checkPreCall\n\
  - If not isUnboundedCopy(Call) -> return.\n- Extract DestE. If !getFixedArraySize(DestE,\
  \ DestSize) -> return.\n- If not isCharArrayType(Field/Var element type) -> return.\n\
  - If Src is string literal and length < DestSize -> return (safe).\n- Otherwise\
  \ emit report as above, recommending strscpy(dest, src, sizeof(dest)).\n\nThis plan\
  \ precisely catches the target pattern in the patch (strcpy into di.name, a fixed-size\
  \ struct field) and remains simple by avoiding program-state management while still\
  \ reducing false positives via the string-literal length check."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include <string>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No program state customization needed.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unbounded string\
  \ copy into fixed-size buffer\", \"Memory Safety\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n      // Helper to\
  \ check if call is to an unbounded copy API like strcpy\n      static bool isUnboundedCopy(const\
  \ CallEvent &Call, CheckerContext &C);\n\n      // Get constant array size and element\
  \ type from a destination expression\n      static bool getFixedArraySize(const\
  \ Expr *E, llvm::APInt &OutSize, QualType &ElemTy, CheckerContext &C);\n\n     \
  \ // Check if element type is a character type (char, signed char, unsigned char)\n\
  \      static bool isCharType(QualType T);\n\n      // Try to extract constant array\
  \ info from a QualType\n      static bool getConstArrayInfo(QualType QT, llvm::APInt\
  \ &OutSize, QualType &ElemTy);\n};\n\nbool SAGenTestChecker::isUnboundedCopy(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n\n  // Prefer robust textual matching function\
  \ provided.\n  if (ExprHasName(OriginExpr, \"strcpy\", C))\n    return true;\n\n\
  \  return false;\n}\n\nbool SAGenTestChecker::getConstArrayInfo(QualType QT, llvm::APInt\
  \ &OutSize, QualType &ElemTy) {\n  if (const auto *CAT = dyn_cast_or_null<ConstantArrayType>(QT.getTypePtr()))\
  \ {\n    OutSize = CAT->getSize();\n    ElemTy = CAT->getElementType();\n    return\
  \ true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isCharType(QualType T)\
  \ {\n  T = T.getCanonicalType();\n  if (T->isAnyCharacterType())\n    return true;\n\
  \n  if (const auto *BT = T->getAs<BuiltinType>()) {\n    switch (BT->getKind())\
  \ {\n    case BuiltinType::SChar:\n    case BuiltinType::UChar:\n    case BuiltinType::Char_S:\n\
  \    case BuiltinType::Char_U:\n    case BuiltinType::Char8:\n      return true;\n\
  \    default:\n      break;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getFixedArraySize(const\
  \ Expr *E, llvm::APInt &OutSize, QualType &ElemTy, CheckerContext &C) {\n  if (!E)\n\
  \    return false;\n\n  const Expr *Cur = E->IgnoreImpCasts();\n\n  // Handle &arr[0]\n\
  \  if (const auto *UO = dyn_cast<UnaryOperator>(Cur)) {\n    if (UO->getOpcode()\
  \ == UO_AddrOf) {\n      Cur = UO->getSubExpr()->IgnoreImpCasts();\n    }\n  }\n\
  \n  // Direct variable reference of an array\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(Cur))\
  \ {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n      return\
  \ getConstArrayInfo(VD->getType(), OutSize, ElemTy);\n    }\n  }\n\n  // Struct/union\
  \ member array like di.name\n  if (const auto *ME = dyn_cast<MemberExpr>(Cur)) {\n\
  \    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n      return\
  \ getConstArrayInfo(FD->getType(), OutSize, ElemTy);\n    }\n  }\n\n  // Array subscript\
  \ like arr[0] or s.name[0]\n  if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(Cur))\
  \ {\n    const Expr *Base = ASE->getBase()->IgnoreImpCasts();\n    const Expr *Idx\
  \ = ASE->getIdx()->IgnoreImpCasts();\n\n    // Evaluate index, ensure it is 0\n\
  \    llvm::APSInt IdxVal;\n    if (!EvaluateExprToInt(IdxVal, Idx, C))\n      return\
  \ false;\n    if (IdxVal != 0)\n      return false;\n\n    // Base can be DeclRefExpr\
  \ or MemberExpr (array)\n    if (const auto *BDRE = dyn_cast<DeclRefExpr>(Base))\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(BDRE->getDecl())) {\n        return\
  \ getConstArrayInfo(VD->getType(), OutSize, ElemTy);\n      }\n    } else if (const\
  \ auto *BME = dyn_cast<MemberExpr>(Base)) {\n      if (const auto *FD = dyn_cast<FieldDecl>(BME->getMemberDecl()))\
  \ {\n        return getConstArrayInfo(FD->getType(), OutSize, ElemTy);\n      }\n\
  \    }\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  if (!isUnboundedCopy(Call, C))\n    return;\n\
  \n  if (Call.getNumArgs() < 2)\n    return;\n\n  const Expr *DestE = Call.getArgExpr(0);\n\
  \  if (!DestE)\n    return;\n\n  llvm::APInt DestSize(64, 0);\n  QualType ElemTy;\n\
  \  if (!getFixedArraySize(DestE, DestSize, ElemTy, C))\n    return;\n\n  if (!isCharType(ElemTy))\n\
  \    return;\n\n  // Optional refinement if source is string literal\n  const Expr\
  \ *SrcE = Call.getArgExpr(1);\n  if (!SrcE)\n    return;\n\n  llvm::APInt StringLen;\n\
  \  bool DefiniteOverflow = false;\n  if (getStringSize(StringLen, SrcE)) {\n   \
  \ // strcpy copies src length + 1 (for NUL). If StringLen >= DestSize, definite\
  \ overflow.\n    if (StringLen.uge(DestSize))\n      DefiniteOverflow = true;\n\
  \    else\n      return; // Clearly safe with literal smaller than dest.\n  }\n\n\
  \  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n\
  \  std::string Msg;\n  if (DefiniteOverflow) {\n    unsigned long long D = DestSize.getLimitedValue();\n\
  \    unsigned long long S = StringLen.getLimitedValue();\n    Msg = \"strcpy may\
  \ overflow fixed-size buffer (dest size \" + std::to_string(D) +\n          \",\
  \ source literal length \" + std::to_string(S) + \")\";\n  } else {\n    Msg = \"\
  Unbounded copy into fixed-size buffer; use strscpy(dest, src, sizeof(dest))\";\n\
  \  }\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n  R->addRange(DestE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects unbounded string copies (e.g.,\
  \ strcpy) into fixed-size buffers; suggests strscpy with sizeof(dest)\",\n     \
  \ \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
