_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 63ae548f1054a0b71678d0349c7dc9628ddd42ca
commit_type: Out-of-Bound
index: 7
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states required.\n\nnamespace {\n\
  \nclass SAGenTestChecker : public Checker<check::Location> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Out-of-bounds\
  \ LUT access\", \"Array bounds\")) {}\n\n  void checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S,\n                     CheckerContext &C) const;\n\nprivate:\n \
  \ // Helper: get the ArraySubscriptExpr related to S, either S itself or a child.\n\
  \  const ArraySubscriptExpr *getASEFromStmt(const Stmt *S, CheckerContext &C) const\
  \ {\n    if (!S)\n      return nullptr;\n    if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(S))\n\
  \      return ASE;\n    return findSpecificTypeInChildren<ArraySubscriptExpr>(S);\n\
  \  }\n\n  // Helper: determine if the array base expression textually contains \"\
  tf_pts\".\n  bool isTFPLUTBase(const Expr *Base, CheckerContext &C) const {\n  \
  \  if (!Base)\n      return false;\n    return ExprHasName(Base, \"tf_pts\", C);\n\
  \  }\n\n  // Helper: extract constant array bound from a member expression base.\n\
  \  bool getArrayBoundFromBaseExpr(const Expr *Base, CheckerContext &C,\n       \
  \                          llvm::APInt &OutBound) const {\n    if (!Base)\n    \
  \  return false;\n    const Expr *E = Base->IgnoreImpCasts();\n    // Expecting\
  \ a MemberExpr chain leading to the array field (e.g., ...tf_pts.red)\n    const\
  \ auto *ME = dyn_cast<MemberExpr>(E);\n    if (!ME)\n      return false;\n\n   \
  \ QualType MTy = ME->getType();\n    const ConstantArrayType *CAT =\n        C.getASTContext().getAsConstantArrayType(MTy);\n\
  \    if (!CAT)\n      return false;\n\n    OutBound = CAT->getSize();\n    return\
  \ true;\n  }\n\n  // Helper: find a DeclRefExpr within Idx and return its name if\
  \ possible.\n  bool getIndexVarName(const Expr *Idx, std::string &OutName) const\
  \ {\n    if (!Idx)\n      return false;\n    const Expr *I = Idx->IgnoreParenCasts();\n\
  \    if (const auto *DRE = dyn_cast<DeclRefExpr>(I)) {\n      if (const auto *VD\
  \ = dyn_cast<VarDecl>(DRE->getDecl())) {\n        OutName = VD->getName().str();\n\
  \        return true;\n      }\n    }\n    if (const auto *InnerDRE = findSpecificTypeInChildren<DeclRefExpr>(Idx))\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(InnerDRE->getDecl())) {\n    \
  \    OutName = VD->getName().str();\n        return true;\n      }\n    }\n    return\
  \ false;\n  }\n\n  // Helper: does Cond mention both the index variable and TRANSFER_FUNC_POINTS?\n\
  \  bool condMentionsIndexAndTFP(const Expr *Cond, StringRef IdxName,\n         \
  \                      CheckerContext &C) const {\n    if (!Cond || IdxName.empty())\n\
  \      return false;\n    bool HasIdx = ExprHasName(Cond, IdxName, C);\n    bool\
  \ HasTFP = ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\", C);\n    return HasIdx &&\
  \ HasTFP;\n  }\n\n  // Helper: check if there is a nearby guard (if/loop condition)\
  \ constraining index vs TRANSFER_FUNC_POINTS.\n  bool isGuardedByTFP(const Expr\
  \ *Idx, const Stmt *AccessSite,\n                      CheckerContext &C) const\
  \ {\n    std::string IdxName;\n    if (!getIndexVarName(Idx, IdxName))\n      return\
  \ false;\n\n    // Check nearest enclosing if-statement.\n    if (const IfStmt *IS\
  \ = findSpecificTypeInParents<IfStmt>(AccessSite, C)) {\n      if (condMentionsIndexAndTFP(IS->getCond(),\
  \ IdxName, C))\n        return true;\n    }\n\n    // Check nearest enclosing for/while/do\
  \ conditions.\n    if (const ForStmt *FS = findSpecificTypeInParents<ForStmt>(AccessSite,\
  \ C)) {\n      if (condMentionsIndexAndTFP(FS->getCond(), IdxName, C))\n       \
  \ return true;\n    }\n    if (const WhileStmt *WS =\n            findSpecificTypeInParents<WhileStmt>(AccessSite,\
  \ C)) {\n      if (condMentionsIndexAndTFP(WS->getCond(), IdxName, C))\n       \
  \ return true;\n    }\n    if (const DoStmt *DS = findSpecificTypeInParents<DoStmt>(AccessSite,\
  \ C)) {\n      if (condMentionsIndexAndTFP(DS->getCond(), IdxName, C))\n       \
  \ return true;\n    }\n\n    return false;\n  }\n\n  // Helper: ensure we\u2019\
  re in a for-loop that iterates the same index var (to match the target pattern).\n\
  \  bool isWithinForOverIndex(const Expr *Idx, const Stmt *AccessSite,\n        \
  \                    CheckerContext &C) const {\n    std::string IdxName;\n    if\
  \ (!getIndexVarName(Idx, IdxName))\n      return false;\n    const ForStmt *FS =\
  \ findSpecificTypeInParents<ForStmt>(AccessSite, C);\n    if (!FS)\n      return\
  \ false;\n    const Expr *Inc = FS->getInc();\n    const Expr *Cond = FS->getCond();\n\
  \    bool MentionsIdx =\n        (Inc && ExprHasName(Inc, IdxName, C)) || (Cond\
  \ && ExprHasName(Cond, IdxName, C));\n    return MentionsIdx;\n  }\n};\n\nvoid SAGenTestChecker::checkLocation(SVal\
  \ /*Loc*/, bool /*IsLoad*/,\n                                     const Stmt *S,\
  \ CheckerContext &C) const {\n  // Step A: focus on array subscript accesses.\n\
  \  const auto *ASE = getASEFromStmt(S, C);\n  if (!ASE)\n    return;\n\n  const\
  \ Expr *Base = ASE->getBase();\n  const Expr *Idx = ASE->getIdx();\n  if (!Base\
  \ || !Idx)\n    return;\n\n  // Heuristic: only consider LUT arrays under tf_pts.*\n\
  \  if (!isTFPLUTBase(Base, C))\n    return;\n\n  // Get array bound (constant-size\
  \ array only).\n  llvm::APInt ArrayBound;\n  if (!getArrayBoundFromBaseExpr(Base,\
  \ C, ArrayBound))\n    return;\n\n  // Evaluate index: constant first.\n  llvm::APSInt\
  \ IdxVal;\n  if (EvaluateExprToInt(IdxVal, Idx, C)) {\n    // Definite check: negative\
  \ or >= bound is OOB.\n    bool IsNeg = IdxVal.isSigned() ? IdxVal.isNegative()\
  \ : false;\n    uint64_t UVal = IdxVal.getZExtValue();\n    uint64_t Bound = ArrayBound.getZExtValue();\n\
  \    if (IsNeg || UVal >= Bound) {\n      // If explicitly guarded nearby, suppress.\n\
  \      if (isGuardedByTFP(Idx, S, C))\n        return;\n\n      ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n      if (!N)\n        return;\n      auto R\
  \ = std::make_unique<PathSensitiveBugReport>(\n          *BT, \"Possible out-of-bounds\
  \ LUT access: index may exceed array size\",\n          N);\n      R->addRange(ASE->getSourceRange());\n\
  \      C.emitReport(std::move(R));\n    }\n    return; // Constant and in-bounds\
  \ => safe.\n  }\n\n  // Symbolic index: ask the constraint manager for a maximum\
  \ value.\n  ProgramStateRef State = C.getState();\n  SVal IdxSVal = State->getSVal(Idx,\
  \ C.getLocationContext());\n  SymbolRef IdxSym = IdxSVal.getAsSymbol();\n  if (!IdxSym)\n\
  \    return; // Unknown index; avoid noise.\n\n  const llvm::APSInt *MaxVal = inferSymbolMaxVal(IdxSym,\
  \ C);\n  uint64_t Bound = ArrayBound.getZExtValue();\n\n  // If proven safe (max\
  \ < bound), return.\n  if (MaxVal && MaxVal->getZExtValue() < Bound)\n    return;\n\
  \n  // Require that we are inside a for-loop iterating the index var to match the\
  \ target pattern.\n  if (!isWithinForOverIndex(Idx, S, C))\n    return;\n\n  //\
  \ Suppress if there\u2019s an explicit guard against TRANSFER_FUNC_POINTS nearby.\n\
  \  if (isGuardedByTFP(Idx, S, C))\n    return;\n\n  // Potentially unsafe: emit\
  \ a warning.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n  \
  \  return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n\
  \      \"Possible out-of-bounds LUT access: index is not checked against TRANSFER_FUNC_POINTS\"\
  ,\n      N);\n  R->addRange(ASE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects missing upper-bound checks when indexing fixed-size LUT arrays\
  \ (TRANSFER_FUNC_POINTS)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Fix potential index out of bounds\
  \ in color transformation function\n\nFixes index out of bounds issue in the color\
  \ transformation function.\nThe issue could occur when the index 'i' exceeds the\
  \ number of transfer\nfunction points (TRANSFER_FUNC_POINTS).\n\nThe fix adds a\
  \ check to ensure 'i' is within bounds before accessing the\ntransfer function points.\
  \ If 'i' is out of bounds, an error message is\nlogged and the function returns\
  \ false to indicate an error.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:405\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.red'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:406\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.green'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:407\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.blue'\
  \ 1025 <= s32max\n\nFixes: b629596072e5 (\"drm/amd/display: Build unity lut for\
  \ shaper\")\nCc: Vitaly Prosyak <vitaly.prosyak@amd.com>\nCc: Charlene Liu <Charlene.Liu@amd.com>\n\
  Cc: Harry Wentland <harry.wentland@amd.com>\nCc: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>\n\
  Cc: Roman Li <roman.li@amd.com>\nCc: Aurabindo Pillai <aurabindo.pillai@amd.com>\n\
  Cc: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Srinivasan Shanmugam <srinivasan.shanmugam@amd.com>\n\
  Reviewed-by: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Alex Deucher <alexander.deucher@amd.com>\n\
  \n## Buggy Code\n\n```c\n// Function: cm_helper_translate_curve_to_hw_format in\
  \ drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nbool cm_helper_translate_curve_to_hw_format(struct\
  \ dc_context *ctx,\n\t\t\t\tconst struct dc_transfer_func *output_tf,\n\t\t\t\t\
  struct pwl_params *lut_params, bool fixpoint)\n{\n\tstruct curve_points3 *corner_points;\n\
  \tstruct pwl_result_data *rgb_resulted;\n\tstruct pwl_result_data *rgb;\n\tstruct\
  \ pwl_result_data *rgb_plus_1;\n\tstruct pwl_result_data *rgb_minus_1;\n\n\tint32_t\
  \ region_start, region_end;\n\tint32_t i;\n\tuint32_t j, k, seg_distr[MAX_REGIONS_NUMBER],\
  \ increment, start_index, hw_points;\n\n\tif (output_tf == NULL || lut_params ==\
  \ NULL || output_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\tcorner_points\
  \ = lut_params->corner_points;\n\trgb_resulted = lut_params->rgb_resulted;\n\thw_points\
  \ = 0;\n\n\tmemset(lut_params, 0, sizeof(struct pwl_params));\n\tmemset(seg_distr,\
  \ 0, sizeof(seg_distr));\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ || output_tf->tf\
  \ == TRANSFER_FUNCTION_GAMMA22) {\n\t\t/* 32 segments\n\t\t * segments are from\
  \ 2^-25 to 2^7\n\t\t */\n\t\tfor (i = 0; i < NUMBER_REGIONS ; i++)\n\t\t\tseg_distr[i]\
  \ = 3;\n\n\t\tregion_start = -MAX_LOW_POINT;\n\t\tregion_end   = NUMBER_REGIONS\
  \ - MAX_LOW_POINT;\n\t} else {\n\t\t/* 11 segments\n\t\t * segment is from 2^-10\
  \ to 2^1\n\t\t * There are less than 256 points, for optimization\n\t\t */\n\t\t\
  seg_distr[0] = 3;\n\t\tseg_distr[1] = 4;\n\t\tseg_distr[2] = 4;\n\t\tseg_distr[3]\
  \ = 4;\n\t\tseg_distr[4] = 4;\n\t\tseg_distr[5] = 4;\n\t\tseg_distr[6] = 4;\n\t\t\
  seg_distr[7] = 4;\n\t\tseg_distr[8] = 4;\n\t\tseg_distr[9] = 4;\n\t\tseg_distr[10]\
  \ = 1;\n\n\t\tregion_start = -10;\n\t\tregion_end = 1;\n\t}\n\n\tfor (i = region_end\
  \ - region_start; i < MAX_REGIONS_NUMBER ; i++)\n\t\tseg_distr[i] = -1;\n\n\tfor\
  \ (k = 0; k < MAX_REGIONS_NUMBER; k++) {\n\t\tif (seg_distr[k] != -1)\n\t\t\thw_points\
  \ += (1 << seg_distr[k]);\n\t}\n\n\tj = 0;\n\tfor (k = 0; k < (region_end - region_start);\
  \ k++) {\n\t\tincrement = NUMBER_SW_SEGMENTS / (1 << seg_distr[k]);\n\t\tstart_index\
  \ = (region_start + k + MAX_LOW_POINT) *\n\t\t\t\tNUMBER_SW_SEGMENTS;\n\t\tfor (i\
  \ = start_index; i < start_index + NUMBER_SW_SEGMENTS;\n\t\t\t\ti += increment)\
  \ {\n\t\t\tif (j == hw_points - 1)\n\t\t\t\tbreak;\n\t\t\trgb_resulted[j].red =\
  \ output_tf->tf_pts.red[i];\n\t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n\
  \t\t\trgb_resulted[j].blue = output_tf->tf_pts.blue[i];\n\t\t\tj++;\n\t\t}\n\t}\n\
  \n\t/* last point */\n\tstart_index = (region_end + MAX_LOW_POINT) * NUMBER_SW_SEGMENTS;\n\
  \trgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];\n\trgb_resulted[hw_points\
  \ - 1].green = output_tf->tf_pts.green[start_index];\n\trgb_resulted[hw_points -\
  \ 1].blue = output_tf->tf_pts.blue[start_index];\n\n\trgb_resulted[hw_points].red\
  \ = rgb_resulted[hw_points - 1].red;\n\trgb_resulted[hw_points].green = rgb_resulted[hw_points\
  \ - 1].green;\n\trgb_resulted[hw_points].blue = rgb_resulted[hw_points - 1].blue;\n\
  \n\t// All 3 color channels have same x\n\tcorner_points[0].red.x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\
  \t\t\t\t\t     dc_fixpt_from_int(region_start));\n\tcorner_points[0].green.x = corner_points[0].red.x;\n\
  \tcorner_points[0].blue.x = corner_points[0].red.x;\n\n\tcorner_points[1].red.x\
  \ = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_end));\n\
  \tcorner_points[1].green.x = corner_points[1].red.x;\n\tcorner_points[1].blue.x\
  \ = corner_points[1].red.x;\n\n\tcorner_points[0].red.y = rgb_resulted[0].red;\n\
  \tcorner_points[0].green.y = rgb_resulted[0].green;\n\tcorner_points[0].blue.y =\
  \ rgb_resulted[0].blue;\n\n\tcorner_points[0].red.slope = dc_fixpt_div(corner_points[0].red.y,\n\
  \t\t\tcorner_points[0].red.x);\n\tcorner_points[0].green.slope = dc_fixpt_div(corner_points[0].green.y,\n\
  \t\t\tcorner_points[0].green.x);\n\tcorner_points[0].blue.slope = dc_fixpt_div(corner_points[0].blue.y,\n\
  \t\t\tcorner_points[0].blue.x);\n\n\t/* see comment above, m_arrPoints[1].y should\
  \ be the Y value for the\n\t * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints\
  \ - 1)\n\t */\n\tcorner_points[1].red.y = rgb_resulted[hw_points - 1].red;\n\tcorner_points[1].green.y\
  \ = rgb_resulted[hw_points - 1].green;\n\tcorner_points[1].blue.y = rgb_resulted[hw_points\
  \ - 1].blue;\n\tcorner_points[1].red.slope = dc_fixpt_zero;\n\tcorner_points[1].green.slope\
  \ = dc_fixpt_zero;\n\tcorner_points[1].blue.slope = dc_fixpt_zero;\n\n\tif (output_tf->tf\
  \ == TRANSFER_FUNCTION_PQ) {\n\t\t/* for PQ, we want to have a straight line from\
  \ last HW X point,\n\t\t * and the slope to be such that we hit 1.0 at 10000 nits.\n\
  \t\t */\n\t\tconst struct fixed31_32 end_value =\n\t\t\t\tdc_fixpt_from_int(125);\n\
  \n\t\tcorner_points[1].red.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].red.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].red.x));\n\
  \t\tcorner_points[1].green.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].green.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].green.x));\n\
  \t\tcorner_points[1].blue.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].blue.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].blue.x));\n\
  \t}\n\n\tlut_params->hw_points_num = hw_points;\n\n\tk = 0;\n\tfor (i = 1; i < MAX_REGIONS_NUMBER;\
  \ i++) {\n\t\tif (seg_distr[k] != -1) {\n\t\t\tlut_params->arr_curve_points[k].segments_num\
  \ =\n\t\t\t\t\tseg_distr[k];\n\t\t\tlut_params->arr_curve_points[i].offset =\n\t\
  \t\t\t\tlut_params->arr_curve_points[k].offset + (1 << seg_distr[k]);\n\t\t}\n\t\
  \tk++;\n\t}\n\n\tif (seg_distr[k] != -1)\n\t\tlut_params->arr_curve_points[k].segments_num\
  \ = seg_distr[k];\n\n\trgb = rgb_resulted;\n\trgb_plus_1 = rgb_resulted + 1;\n\t\
  rgb_minus_1 = rgb;\n\n\ti = 1;\n\twhile (i != hw_points + 1) {\n\n\t\tif (i >= hw_points\
  \ - 1) {\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->red, rgb->red))\n\t\t\t\trgb_plus_1->red\
  \ = dc_fixpt_add(rgb->red, rgb_minus_1->delta_red);\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->green,\
  \ rgb->green))\n\t\t\t\trgb_plus_1->green = dc_fixpt_add(rgb->green, rgb_minus_1->delta_green);\n\
  \t\t\tif (dc_fixpt_lt(rgb_plus_1->blue, rgb->blue))\n\t\t\t\trgb_plus_1->blue =\
  \ dc_fixpt_add(rgb->blue, rgb_minus_1->delta_blue);\n\t\t}\n\n\t\trgb->delta_red\
  \   = dc_fixpt_sub(rgb_plus_1->red,   rgb->red);\n\t\trgb->delta_green = dc_fixpt_sub(rgb_plus_1->green,\
  \ rgb->green);\n\t\trgb->delta_blue  = dc_fixpt_sub(rgb_plus_1->blue,  rgb->blue);\n\
  \n\n\t\tif (fixpoint == true) {\n\t\t\tuint32_t red_clamp = dc_fixpt_clamp_u0d14(rgb->delta_red);\n\
  \t\t\tuint32_t green_clamp = dc_fixpt_clamp_u0d14(rgb->delta_green);\n\t\t\tuint32_t\
  \ blue_clamp = dc_fixpt_clamp_u0d14(rgb->delta_blue);\n\n\t\t\tif (red_clamp >>\
  \ 10 || green_clamp >> 10 || blue_clamp >> 10)\n\t\t\t\tDC_LOG_WARNING(\"Losing\
  \ delta precision while programming shaper LUT.\");\n\n\t\t\trgb->delta_red_reg\
  \   = red_clamp & 0x3ff;\n\t\t\trgb->delta_green_reg = green_clamp & 0x3ff;\n\t\t\
  \trgb->delta_blue_reg  = blue_clamp & 0x3ff;\n\t\t\trgb->red_reg         = dc_fixpt_clamp_u0d14(rgb->red);\n\
  \t\t\trgb->green_reg       = dc_fixpt_clamp_u0d14(rgb->green);\n\t\t\trgb->blue_reg\
  \        = dc_fixpt_clamp_u0d14(rgb->blue);\n\t\t}\n\n\t\t++rgb_plus_1;\n\t\trgb_minus_1\
  \ = rgb;\n\t\t++rgb;\n\t\t++i;\n\t}\n\tcm_helper_convert_to_custom_float(rgb_resulted,\n\
  \t\t\t\t\t\tlut_params->corner_points,\n\t\t\t\t\t\thw_points, fixpoint);\n\n\t\
  return true;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\
  \ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nindex b7e57aa27361..b0d192c6e63e\
  \ 100644\n--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n\
  @@ -402,6 +402,11 @@ bool cm_helper_translate_curve_to_hw_format(struct dc_context\
  \ *ctx,\n \t\t\t\ti += increment) {\n \t\t\tif (j == hw_points - 1)\n \t\t\t\tbreak;\n\
  +\t\t\tif (i >= TRANSFER_FUNC_POINTS) {\n+\t\t\t\tDC_LOG_ERROR(\"Index out of bounds:\
  \ i=%d, TRANSFER_FUNC_POINTS=%d\\n\",\n+\t\t\t\t\t     i, TRANSFER_FUNC_POINTS);\n\
  +\t\t\t\treturn false;\n+\t\t\t}\n \t\t\trgb_resulted[j].red = output_tf->tf_pts.red[i];\n\
  \ \t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n \t\t\trgb_resulted[j].blue\
  \ = output_tf->tf_pts.blue[i];\n```\n"
pattern: '## Bug Pattern


  Indexing a fixed-size LUT array using a computed loop index without verifying it
  is within bounds:

  - i is derived from region-based math (start_index and increment) and used to access
  output_tf->tf_pts.{red,green,blue}[i].

  - The code only checks j against hw_points, but never checks i against TRANSFER_FUNC_POINTS.

  - This missing upper-bound check allows i to exceed TRANSFER_FUNC_POINTS, causing
  out-of-bounds reads on the tf_pts arrays.'
plan: "1) Program state\n- No custom program-state traits or maps are required. We\
  \ will rely on:\n  - The analyzer\u2019s path-sensitive constraints via inferSymbolMaxVal.\n\
  \  - Local AST queries for constant array bounds and nearby guards.\n\n2) Callbacks\
  \ to use\n- checkLocation: Main detection of potentially OOB array subscripts.\n\
  - check::BranchCondition (optional, lightweight): Only to leverage the analyzer\u2019\
  s normal constraint splitting; no custom state is recorded.\n- No other callbacks\
  \ are necessary.\n\n3) Detailed steps\n\nStep A. Detect risky array subscripts at\
  \ memory access (checkLocation)\n- Trigger: Each load/store will invoke checkLocation.\
  \ If S is an ArraySubscriptExpr (ASE), analyze it. If not, return.\n  - Retrieve\
  \ ASE via dyn_cast<ArraySubscriptExpr>(S).\n- Compute the constant bound of the\
  \ array:\n  - Let Base = ASE->getBase()->IgnoreParenImpCasts().\n  - Extract its\
  \ type: QualType BT = Base->getType().\n  - If BT is a ConstantArrayType (auto *CAT\
  \ = dyn_cast<ConstantArrayType>(BT.getTypePtr())), then get CAT->getSize() as ArrayBound.\n\
  \  - If not a constant-size array, skip (return). We only target fixed-size LUT\
  \ arrays to reduce noise.\n- Heuristic to focus on the target pattern (reduce false\
  \ positives):\n  - If ExprHasName(Base, \"tf_pts\", C) is true, continue. Otherwise,\
  \ you may skip to reduce noise and match the target bug pattern (array lies under\
  \ tf_pts.{red,green,blue}).\n    - Optionally also allow MemberExpr chains whose\
  \ final field names are \u201Cred\u201D, \u201Cgreen\u201D, or \u201Cblue\u201D\
  \ to broaden matching within the same structure, but \u201Ctf_pts\u201D is the most\
  \ specific and sufficient for this patch.\n- Get the index expression:\n  - const\
  \ Expr *Idx = ASE->getIdx()->IgnoreParenImpCasts().\n- Determine whether the index\
  \ is provably within bounds:\n  1) Constant evaluation:\n     - Try EvaluateExprToInt(IdxVal,\
  \ Idx, C). If true and IdxVal >= ArrayBound, report a bug (definite OOB).\n    \
  \ - If IdxVal < ArrayBound, safe; return.\n  2) Symbolic evaluation:\n     - Retrieve\
  \ SymbolRef for the index: SVal IdxSVal = C.getSVal(Idx); SymbolRef IdxSym = IdxSVal.getAsSymbol();\
  \ If no symbol, return (unknown, do not warn).\n     - Use inferSymbolMaxVal(IdxSym,\
  \ C). If it returns a value MaxVal:\n       - If MaxVal < ArrayBound, it is proven\
  \ safe on this path; return.\n       - If MaxVal >= ArrayBound, it is potentially\
  \ unsafe; proceed to the next bullet to check for an explicit guard in nearby conditions.\n\
  \     - If inferSymbolMaxVal returns null (no inferred max), this is unknown and\
  \ suspect; proceed to the next bullet to check for an explicit guard in nearby conditions.\n\
  - Suppress if an explicit guard against TRANSFER_FUNC_POINTS exists nearby:\n  -\
  \ Try to find a nearby guard that constrains Idx against TRANSFER_FUNC_POINTS.\n\
  \  - Check the nearest parent IfStmt (using findSpecificTypeInParents<IfStmt>(S,\
  \ C)). If found, inspect its condition:\n    - Extract the index variable\u2019\
  s source text name (for DeclRefExpr index, IdxDRE->getDecl()->getName()).\n    -\
  \ Use ExprHasName(IfStmt->getCond(), IndexVarName, C) AND ExprHasName(IfStmt->getCond(),\
  \ \"TRANSFER_FUNC_POINTS\", C).\n    - If both names appear in the same condition\
  \ (e.g., i < TRANSFER_FUNC_POINTS, i <= TRANSFER_FUNC_POINTS - 1, i >= TRANSFER_FUNC_POINTS),\
  \ then assume this path has/handles the guard; skip warning.\n  - If no IfStmt found\
  \ or no such condition, also look at parent loop conditions:\n    - For parent ForStmt/WhileStmt,\
  \ similarly check if the loop condition contains both the index var name and \u201C\
  TRANSFER_FUNC_POINTS\u201D. If yes, skip warning.\n- If we reach here, we have:\n\
  \  - A fixed-size LUT array indexed by a computed index (often from region math).\n\
  \  - No proven constraint that index < array bound on the current path.\n  - No\
  \ explicit guard against TRANSFER_FUNC_POINTS in a dominating condition.\n  - Emit\
  \ a warning.\n\nReporting (in checkLocation)\n- Create a non-fatal error node with\
  \ C.generateNonFatalErrorNode().\n- Emit a PathSensitiveBugReport with a short message,\
  \ e.g.:\n  - \u201CPossible out-of-bounds LUT access: index is not checked against\
  \ TRANSFER_FUNC_POINTS.\u201D\n- Use the ArraySubscriptExpr as the report location.\n\
  \n4) Notes and implementation specifics\n- Constraint reasoning:\n  - Rely on inferSymbolMaxVal\
  \ to learn if current path ensures i < N. If the added check (i >= TRANSFER_FUNC_POINTS)\
  \ { return false; } is present, the analyzer will split states; on the fall-through\
  \ path inferSymbolMaxVal will return <= N-1, and the checker won\u2019t warn.\n\
  - Bound extraction:\n  - We intentionally restrict to constant-sized arrays via\
  \ ConstantArrayType to avoid false positives on pointer arithmetic.\n- Pattern focus:\n\
  \  - Restricting to bases that contain \u201Ctf_pts\u201D via ExprHasName keeps\
  \ the checker tightly targeted to the LUT pattern in this patch. If broader coverage\
  \ is desired, drop that filter, but expect more noise.\n- Utility functions used:\n\
  \  - EvaluateExprToInt: to resolve constant index i.\n  - inferSymbolMaxVal: to\
  \ query solver constraints for max(i).\n  - ExprHasName: to detect use of names\
  \ like \u201Ctf_pts\u201D, \u201CTRANSFER_FUNC_POINTS\u201D, and the index variable\
  \ within conditions.\n  - findSpecificTypeInParents: to identify enclosing IfStmt\
  \ and loop statements for nearby guards.\n- No need to track aliases or custom program\
  \ state, since we only analyze the current ASE and the solver constraints on its\
  \ index.\n\n5) Callback summary\n- checkLocation:\n  - If S is ArraySubscriptExpr\
  \ on a ConstantArrayType base and base text contains \u201Ctf_pts\u201D:\n    -\
  \ Derive bound N, resolve index value/range.\n    - If not provably < N and there\
  \ is no nearby guard using TRANSFER_FUNC_POINTS, emit report.\n- check::BranchCondition:\n\
  \  - No custom logic required; rely on analyzer constraints. No state updates."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states required.\n\nnamespace {\n\
  \nclass SAGenTestChecker : public Checker<check::Location> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Out-of-bounds\
  \ LUT access\", \"Array bounds\")) {}\n\n  void checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S,\n                     CheckerContext &C) const;\n\nprivate:\n \
  \ // Helper: get the ArraySubscriptExpr related to S, either S itself or a child.\n\
  \  const ArraySubscriptExpr *getASEFromStmt(const Stmt *S, CheckerContext &C) const\
  \ {\n    if (!S)\n      return nullptr;\n    if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(S))\n\
  \      return ASE;\n    return findSpecificTypeInChildren<ArraySubscriptExpr>(S);\n\
  \  }\n\n  // Helper: determine if the array base expression textually contains \"\
  tf_pts\".\n  bool isTFPLUTBase(const Expr *Base, CheckerContext &C) const {\n  \
  \  if (!Base)\n      return false;\n    return ExprHasName(Base, \"tf_pts\", C);\n\
  \  }\n\n  // Helper: extract constant array bound from a member expression base.\n\
  \  bool getArrayBoundFromBaseExpr(const Expr *Base, CheckerContext &C,\n       \
  \                          llvm::APInt &OutBound) const {\n    if (!Base)\n    \
  \  return false;\n    const Expr *E = Base->IgnoreImpCasts();\n    // Expecting\
  \ a MemberExpr chain leading to the array field (e.g., ...tf_pts.red)\n    const\
  \ auto *ME = dyn_cast<MemberExpr>(E);\n    if (!ME)\n      return false;\n\n   \
  \ QualType MTy = ME->getType();\n    const ConstantArrayType *CAT =\n        C.getASTContext().getAsConstantArrayType(MTy);\n\
  \    if (!CAT)\n      return false;\n\n    OutBound = CAT->getSize();\n    return\
  \ true;\n  }\n\n  // Helper: find a DeclRefExpr within Idx and return its name if\
  \ possible.\n  bool getIndexVarName(const Expr *Idx, std::string &OutName) const\
  \ {\n    if (!Idx)\n      return false;\n    const Expr *I = Idx->IgnoreParenCasts();\n\
  \    if (const auto *DRE = dyn_cast<DeclRefExpr>(I)) {\n      if (const auto *VD\
  \ = dyn_cast<VarDecl>(DRE->getDecl())) {\n        OutName = VD->getName().str();\n\
  \        return true;\n      }\n    }\n    if (const auto *InnerDRE = findSpecificTypeInChildren<DeclRefExpr>(Idx))\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(InnerDRE->getDecl())) {\n    \
  \    OutName = VD->getName().str();\n        return true;\n      }\n    }\n    return\
  \ false;\n  }\n\n  // Helper: does Cond mention both the index variable and TRANSFER_FUNC_POINTS?\n\
  \  bool condMentionsIndexAndTFP(const Expr *Cond, StringRef IdxName,\n         \
  \                      CheckerContext &C) const {\n    if (!Cond || IdxName.empty())\n\
  \      return false;\n    bool HasIdx = ExprHasName(Cond, IdxName, C);\n    bool\
  \ HasTFP = ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\", C);\n    return HasIdx &&\
  \ HasTFP;\n  }\n\n  // Helper: check if there is a nearby guard (if/loop condition)\
  \ constraining index vs TRANSFER_FUNC_POINTS.\n  bool isGuardedByTFP(const Expr\
  \ *Idx, const Stmt *AccessSite,\n                      CheckerContext &C) const\
  \ {\n    std::string IdxName;\n    if (!getIndexVarName(Idx, IdxName))\n      return\
  \ false;\n\n    // Check nearest enclosing if-statement.\n    if (const IfStmt *IS\
  \ = findSpecificTypeInParents<IfStmt>(AccessSite, C)) {\n      if (condMentionsIndexAndTFP(IS->getCond(),\
  \ IdxName, C))\n        return true;\n    }\n\n    // Check nearest enclosing for/while/do\
  \ conditions.\n    if (const ForStmt *FS = findSpecificTypeInParents<ForStmt>(AccessSite,\
  \ C)) {\n      if (condMentionsIndexAndTFP(FS->getCond(), IdxName, C))\n       \
  \ return true;\n    }\n    if (const WhileStmt *WS =\n            findSpecificTypeInParents<WhileStmt>(AccessSite,\
  \ C)) {\n      if (condMentionsIndexAndTFP(WS->getCond(), IdxName, C))\n       \
  \ return true;\n    }\n    if (const DoStmt *DS = findSpecificTypeInParents<DoStmt>(AccessSite,\
  \ C)) {\n      if (condMentionsIndexAndTFP(DS->getCond(), IdxName, C))\n       \
  \ return true;\n    }\n\n    return false;\n  }\n\n  // Helper: ensure we\u2019\
  re in a for-loop that iterates the same index var (to match the target pattern).\n\
  \  bool isWithinForOverIndex(const Expr *Idx, const Stmt *AccessSite,\n        \
  \                    CheckerContext &C) const {\n    std::string IdxName;\n    if\
  \ (!getIndexVarName(Idx, IdxName))\n      return false;\n    const ForStmt *FS =\
  \ findSpecificTypeInParents<ForStmt>(AccessSite, C);\n    if (!FS)\n      return\
  \ false;\n    const Expr *Inc = FS->getInc();\n    const Expr *Cond = FS->getCond();\n\
  \    bool MentionsIdx =\n        (Inc && ExprHasName(Inc, IdxName, C)) || (Cond\
  \ && ExprHasName(Cond, IdxName, C));\n    return MentionsIdx;\n  }\n};\n\nvoid SAGenTestChecker::checkLocation(SVal\
  \ /*Loc*/, bool /*IsLoad*/,\n                                     const Stmt *S,\
  \ CheckerContext &C) const {\n  // Step A: focus on array subscript accesses.\n\
  \  const auto *ASE = getASEFromStmt(S, C);\n  if (!ASE)\n    return;\n\n  const\
  \ Expr *Base = ASE->getBase();\n  const Expr *Idx = ASE->getIdx();\n  if (!Base\
  \ || !Idx)\n    return;\n\n  // Heuristic: only consider LUT arrays under tf_pts.*\n\
  \  if (!isTFPLUTBase(Base, C))\n    return;\n\n  // Get array bound (constant-size\
  \ array only).\n  llvm::APInt ArrayBound;\n  if (!getArrayBoundFromBaseExpr(Base,\
  \ C, ArrayBound))\n    return;\n\n  // Evaluate index: constant first.\n  llvm::APSInt\
  \ IdxVal;\n  if (EvaluateExprToInt(IdxVal, Idx, C)) {\n    // Definite check: negative\
  \ or >= bound is OOB.\n    bool IsNeg = IdxVal.isSigned() ? IdxVal.isNegative()\
  \ : false;\n    uint64_t UVal = IdxVal.getZExtValue();\n    uint64_t Bound = ArrayBound.getZExtValue();\n\
  \    if (IsNeg || UVal >= Bound) {\n      // If explicitly guarded nearby, suppress.\n\
  \      if (isGuardedByTFP(Idx, S, C))\n        return;\n\n      ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n      if (!N)\n        return;\n      auto R\
  \ = std::make_unique<PathSensitiveBugReport>(\n          *BT, \"Possible out-of-bounds\
  \ LUT access: index may exceed array size\",\n          N);\n      R->addRange(ASE->getSourceRange());\n\
  \      C.emitReport(std::move(R));\n    }\n    return; // Constant and in-bounds\
  \ => safe.\n  }\n\n  // Symbolic index: ask the constraint manager for a maximum\
  \ value.\n  ProgramStateRef State = C.getState();\n  SVal IdxSVal = State->getSVal(Idx,\
  \ C.getLocationContext());\n  SymbolRef IdxSym = IdxSVal.getAsSymbol();\n  if (!IdxSym)\n\
  \    return; // Unknown index; avoid noise.\n\n  const llvm::APSInt *MaxVal = inferSymbolMaxVal(IdxSym,\
  \ C);\n  uint64_t Bound = ArrayBound.getZExtValue();\n\n  // If proven safe (max\
  \ < bound), return.\n  if (MaxVal && MaxVal->getZExtValue() < Bound)\n    return;\n\
  \n  // Require that we are inside a for-loop iterating the index var to match the\
  \ target pattern.\n  if (!isWithinForOverIndex(Idx, S, C))\n    return;\n\n  //\
  \ Suppress if there\u2019s an explicit guard against TRANSFER_FUNC_POINTS nearby.\n\
  \  if (isGuardedByTFP(Idx, S, C))\n    return;\n\n  // Potentially unsafe: emit\
  \ a warning.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n  \
  \  return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n\
  \      \"Possible out-of-bounds LUT access: index is not checked against TRANSFER_FUNC_POINTS\"\
  ,\n      N);\n  R->addRange(ASE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects missing upper-bound checks when indexing fixed-size LUT arrays\
  \ (TRANSFER_FUNC_POINTS)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
