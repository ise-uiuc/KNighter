_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 1f886a7bfb3faf4c1021e73f045538008ce7634e
commit_type: Null-Pointer-Dereference
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/OperationKinds.h\"\
  \n#include \"clang/AST/Type.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Program state: set of symbols returned from devm_kzalloc\
  \ that may be NULL\nREGISTER_SET_WITH_PROGRAMSTATE(DevmNullableSyms, SymbolRef)\n\
  // Program state: map regions (lvalues) holding tracked symbols to that symbol\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(RegionToSym, const MemRegion *, SymbolRef)\n\nnamespace\
  \ {\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker : public\
  \ Checker<check::PostCall, check::Bind, check::BranchCondition, check::Location>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unchecked devm_kzalloc() result\", \"Null Dereference\"\
  )) {}\n\n      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \      void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \      void checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C)\
  \ const;\n\n   private:\n\n      // Helpers\n      static bool isDevmKzalloc(const\
  \ CallEvent &Call, CheckerContext &C);\n      static const Expr *getPtrExprInCondition(const\
  \ Stmt *Cond, CheckerContext &C);\n      static ProgramStateRef markCheckedIfTracked(ProgramStateRef\
  \ State, const Expr *E, CheckerContext &C);\n      static const Expr *getBaseExprFromDeref(const\
  \ Stmt *S);\n};\n\nbool SAGenTestChecker::isDevmKzalloc(const CallEvent &Call, CheckerContext\
  \ &C) {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return\
  \ false;\n  return ExprHasName(Origin, \"devm_kzalloc\", C);\n}\n\nconst Expr *SAGenTestChecker::getPtrExprInCondition(const\
  \ Stmt *Cond, CheckerContext &C) {\n  if (!Cond)\n    return nullptr;\n  const Expr\
  \ *CondE = dyn_cast<Expr>(Cond);\n  if (!CondE)\n    return nullptr;\n\n  // if\
  \ (!ptr)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if (UO->getOpcode()\
  \ == UO_LNot) {\n      return UO->getSubExpr(); // do not IgnoreImpCasts before\
  \ region extraction\n    }\n  }\n\n  // if (ptr == NULL) or if (ptr != NULL)\n \
  \ if (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr\
  \ *LHS = BO->getLHS();\n      const Expr *RHS = BO->getRHS();\n      if (!LHS ||\
  \ !RHS)\n        return nullptr;\n\n      bool LHSIsNull = LHS->isNullPointerConstant(C.getASTContext(),\n\
  \                                                  Expr::NPC_ValueDependentIsNull);\n\
  \      bool RHSIsNull = RHS->isNullPointerConstant(C.getASTContext(),\n        \
  \                                          Expr::NPC_ValueDependentIsNull);\n\n\
  \      if (LHSIsNull && !RHSIsNull)\n        return RHS;\n      if (RHSIsNull &&\
  \ !LHSIsNull)\n        return LHS;\n    }\n  }\n\n  // if (ptr)\n  return CondE;\n\
  }\n\nProgramStateRef SAGenTestChecker::markCheckedIfTracked(ProgramStateRef State,\
  \ const Expr *E, CheckerContext &C) {\n  if (!E)\n    return State;\n\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C);\n  if (!MR)\n    return State;\n\n  MR = MR->getBaseRegion();\n\
  \  if (!MR)\n    return State;\n\n  if (const SymbolRef *SymPtr = State->get<RegionToSym>(MR))\
  \ {\n    SymbolRef Sym = *SymPtr;\n    if (State->contains<DevmNullableSyms>(Sym))\
  \ {\n      State = State->remove<DevmNullableSyms>(Sym);\n    }\n  }\n  return State;\n\
  }\n\n// Find base pointer expression that is being dereferenced in statement S\n\
  const Expr *SAGenTestChecker::getBaseExprFromDeref(const Stmt *S) {\n  if (!S)\n\
  \    return nullptr;\n\n  // Look for '->'\n  if (const auto *ME = findSpecificTypeInChildren<MemberExpr>(S))\
  \ {\n    if (ME && ME->isArrow()) {\n      return ME->getBase(); // do not strip\
  \ implicit casts here\n    }\n  }\n\n  // Look for '*ptr'\n  if (const auto *UO\
  \ = findSpecificTypeInChildren<UnaryOperator>(S)) {\n    if (UO && UO->getOpcode()\
  \ == UO_Deref) {\n      return UO->getSubExpr();\n    }\n  }\n\n  // Look for 'ptr[index]'\
  \ where base is a pointer (not array lvalue)\n  if (const auto *ASE = findSpecificTypeInChildren<ArraySubscriptExpr>(S))\
  \ {\n    if (ASE) {\n      QualType BT = ASE->getBase()->getType();\n      if (!BT.isNull()\
  \ && BT->isPointerType()) {\n        return ASE->getBase();\n      }\n    }\n  }\n\
  \n  return nullptr;\n}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  if (!isDevmKzalloc(Call, C))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  SVal Ret = Call.getReturnValue();\n  if (SymbolRef Sym\
  \ = Ret.getAsSymbol()) {\n    // Mark this returned symbol as possibly NULL (unchecked)\n\
  \    State = State->add<DevmNullableSyms>(Sym);\n    C.addTransition(State);\n \
  \ }\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *LHSReg\
  \ = Loc.getAsRegion();\n  if (!LHSReg)\n    return;\n  LHSReg = LHSReg->getBaseRegion();\n\
  \  if (!LHSReg)\n    return;\n\n  bool Updated = false;\n\n  // Case 1: RHS is a\
  \ symbol directly (e.g., from devm_kzalloc return)\n  if (SymbolRef RHSym = Val.getAsSymbol())\
  \ {\n    if (State->contains<DevmNullableSyms>(RHSym)) {\n      State = State->set<RegionToSym>(LHSReg,\
  \ RHSym);\n      Updated = true;\n    }\n  }\n\n  // Case 2: RHS is an expression\
  \ referring to a region that already holds a tracked symbol\n  const Expr *RHSExpr\
  \ = nullptr;\n  if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S)) {\n  \
  \  if (BO->isAssignmentOp()) {\n      RHSExpr = BO->getRHS();\n    }\n  } else if\
  \ (const auto *DS = dyn_cast_or_null<DeclStmt>(S)) {\n    // Handle simple declarations\
  \ with initializer: int *p = q;\n    if (DS->isSingleDecl()) {\n      if (const\
  \ auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl())) {\n        if (const Expr *Init\
  \ = VD->getInit())\n          RHSExpr = Init;\n      }\n    }\n  }\n\n  if (RHSExpr)\
  \ {\n    const MemRegion *RHSReg = getMemRegionFromExpr(RHSExpr, C);\n    if (RHSReg)\
  \ {\n      RHSReg = RHSReg->getBaseRegion();\n      if (RHSReg) {\n        if (const\
  \ SymbolRef *HeldSym = State->get<RegionToSym>(RHSReg)) {\n          // Only propagate\
  \ if that symbol is still considered possibly null\n          if (State->contains<DevmNullableSyms>(*HeldSym))\
  \ {\n            State = State->set<RegionToSym>(LHSReg, *HeldSym);\n          \
  \  Updated = true;\n          }\n        }\n      }\n    }\n  }\n\n  // If not updated\
  \ and LHS had an old mapping, clear it to avoid stale associations\n  if (!Updated)\
  \ {\n    if (State->get<RegionToSym>(LHSReg)) {\n      State = State->remove<RegionToSym>(LHSReg);\n\
  \      Updated = true;\n    }\n  }\n\n  if (Updated)\n    C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  const Expr *PtrExpr =\
  \ getPtrExprInCondition(Condition, C);\n  if (!PtrExpr) {\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  State = markCheckedIfTracked(State, PtrExpr, C);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\
  \ CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\n  // Try\
  \ to find the base pointer expression being dereferenced in S\n  const Expr *Base\
  \ = getBaseExprFromDeref(S);\n  if (!Base)\n    return;\n\n  const MemRegion *BaseReg\
  \ = getMemRegionFromExpr(Base, C);\n  if (!BaseReg)\n    return;\n\n  BaseReg =\
  \ BaseReg->getBaseRegion();\n  if (!BaseReg)\n    return;\n\n  const SymbolRef *SymPtr\
  \ = State->get<RegionToSym>(BaseReg);\n  if (!SymPtr)\n    return;\n\n  SymbolRef\
  \ Sym = *SymPtr;\n  if (!State->contains<DevmNullableSyms>(Sym))\n    return;\n\n\
  \  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n\
  \  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Unchecked devm_kzalloc()\
  \ result may be NULL\", N);\n  R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects dereference of devm_kzalloc() result without a NULL check\",\n\
  \      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nspi: mchp-pci1xxx: Fix a possible null pointer dereference\
  \ in pci1xxx_spi_probe\n\nIn function pci1xxxx_spi_probe, there is a potential null\
  \ pointer that\nmay be caused by a failed memory allocation by the function devm_kzalloc.\n\
  Hence, a null pointer check needs to be added to prevent null pointer\ndereferencing\
  \ later in the code.\n\nTo fix this issue, spi_bus->spi_int[iter] should be checked.\
  \ The memory\nallocated by devm_kzalloc will be automatically released, so just\
  \ directly\nreturn -ENOMEM without worrying about memory leaks.\n\nFixes: 1cc0cbea7167\
  \ (\"spi: microchip: pci1xxxx: Add driver for SPI controller of PCI1XXXX PCIe switch\"\
  )\nSigned-off-by: Huai-Yuan Liu <qq810974084@gmail.com>\nLink: https://msgid.link/r/20240403014221.969801-1-qq810974084@gmail.com\n\
  Signed-off-by: Mark Brown <broonie@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ pci1xxxx_spi_probe in drivers/spi/spi-pci1xxxx.c\nstatic int pci1xxxx_spi_probe(struct\
  \ pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tu8 hw_inst_cnt, iter, start,\
  \ only_sec_inst;\n\tstruct pci1xxxx_spi_internal *spi_sub_ptr;\n\tstruct device\
  \ *dev = &pdev->dev;\n\tstruct pci1xxxx_spi *spi_bus;\n\tstruct spi_controller *spi_host;\n\
  \tu32 regval;\n\tint ret;\n\n\thw_inst_cnt = ent->driver_data & 0x0f;\n\tstart =\
  \ (ent->driver_data & 0xf0) >> 4;\n\tif (start == 1)\n\t\tonly_sec_inst = 1;\n\t\
  else\n\t\tonly_sec_inst = 0;\n\n\tspi_bus = devm_kzalloc(&pdev->dev,\n\t\t\t   \
  \    struct_size(spi_bus, spi_int, hw_inst_cnt),\n\t\t\t       GFP_KERNEL);\n\t\
  if (!spi_bus)\n\t\treturn -ENOMEM;\n\n\tspi_bus->dev = pdev;\n\tspi_bus->total_hw_instances\
  \ = hw_inst_cnt;\n\tpci_set_master(pdev);\n\n\tfor (iter = 0; iter < hw_inst_cnt;\
  \ iter++) {\n\t\tspi_bus->spi_int[iter] = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t\t\
  \      sizeof(struct pci1xxxx_spi_internal),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\
  \tspi_sub_ptr = spi_bus->spi_int[iter];\n\t\tspi_sub_ptr->spi_host = devm_spi_alloc_host(dev,\
  \ sizeof(struct spi_controller));\n\t\tif (!spi_sub_ptr->spi_host)\n\t\t\treturn\
  \ -ENOMEM;\n\n\t\tspi_sub_ptr->parent = spi_bus;\n\t\tspi_sub_ptr->spi_xfer_in_progress\
  \ = false;\n\n\t\tif (!iter) {\n\t\t\tret = pcim_enable_device(pdev);\n\t\t\tif\
  \ (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tret = pci_request_regions(pdev, DRV_NAME);\n\
  \t\t\tif (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tspi_bus->reg_base = pcim_iomap(pdev,\
  \ 0, pci_resource_len(pdev, 0));\n\t\t\tif (!spi_bus->reg_base) {\n\t\t\t\tret =\
  \ -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret = pci_alloc_irq_vectors(pdev,\
  \ hw_inst_cnt, hw_inst_cnt,\n\t\t\t\t\t\t    PCI_IRQ_ALL_TYPES);\n\t\t\tif (ret\
  \ < 0) {\n\t\t\t\tdev_err(&pdev->dev, \"Error allocating MSI vectors\\n\");\n\t\t\
  \t\tgoto error;\n\t\t\t}\n\n\t\t\tinit_completion(&spi_sub_ptr->spi_xfer_done);\n\
  \t\t\t/* Initialize Interrupts - SPI_INT */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ +\n\t\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\t\
  regval &= ~SPI_INTR;\n\t\t\twritel(regval, spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\
  \t\t\tspi_sub_ptr->irq = pci_irq_vector(pdev, 0);\n\n\t\t\tret = devm_request_irq(&pdev->dev,\
  \ spi_sub_ptr->irq,\n\t\t\t\t\t       pci1xxxx_spi_isr, PCI1XXXX_IRQ_FLAGS,\n\t\t\
  \t\t\t       pci_name(pdev), spi_sub_ptr);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev,\
  \ \"Unable to request irq : %d\",\n\t\t\t\t\tspi_sub_ptr->irq);\n\t\t\t\tret = -ENODEV;\n\
  \t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret = pci1xxxx_spi_dma_init(spi_bus, spi_sub_ptr->irq);\n\
  \t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\tgoto error;\n\n\t\t\t/* This register\
  \ is only applicable for 1st instance */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ + SPI_PCI_CTRL_REG_OFFSET(0));\n\t\t\tif (!only_sec_inst)\n\t\t\t\tregval |= (BIT(4));\n\
  \t\t\telse\n\t\t\t\tregval &= ~(BIT(4));\n\n\t\t\twritel(regval, spi_bus->reg_base\
  \ + SPI_PCI_CTRL_REG_OFFSET(0));\n\t\t}\n\n\t\tspi_sub_ptr->hw_inst = start++;\n\
  \n\t\tif (iter == 1) {\n\t\t\tinit_completion(&spi_sub_ptr->spi_xfer_done);\n\t\t\
  \t/* Initialize Interrupts - SPI_INT */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\t\
  regval &= ~SPI_INTR;\n\t\t\twritel(regval, spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\
  \t\t\tspi_sub_ptr->irq = pci_irq_vector(pdev, iter);\n\t\t\tret = devm_request_irq(&pdev->dev,\
  \ spi_sub_ptr->irq,\n\t\t\t\t\t       pci1xxxx_spi_isr, PCI1XXXX_IRQ_FLAGS,\n\t\t\
  \t\t\t       pci_name(pdev), spi_sub_ptr);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev,\
  \ \"Unable to request irq : %d\",\n\t\t\t\t\tspi_sub_ptr->irq);\n\t\t\t\tret = -ENODEV;\n\
  \t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tspi_host = spi_sub_ptr->spi_host;\n\t\
  \tspi_host->num_chipselect = SPI_CHIP_SEL_COUNT;\n\t\tspi_host->mode_bits = SPI_MODE_0\
  \ | SPI_MODE_3 | SPI_RX_DUAL |\n\t\t\t\t      SPI_TX_DUAL | SPI_LOOP;\n\t\tspi_host->can_dma\
  \ = pci1xxxx_spi_can_dma;\n\t\tspi_host->transfer_one = pci1xxxx_spi_transfer_one;\n\
  \n\t\tspi_host->set_cs = pci1xxxx_spi_set_cs;\n\t\tspi_host->bits_per_word_mask\
  \ = SPI_BPW_MASK(8);\n\t\tspi_host->max_speed_hz = PCI1XXXX_SPI_MAX_CLOCK_HZ;\n\t\
  \tspi_host->min_speed_hz = PCI1XXXX_SPI_MIN_CLOCK_HZ;\n\t\tspi_host->flags = SPI_CONTROLLER_MUST_TX;\n\
  \t\tspi_controller_set_devdata(spi_host, spi_sub_ptr);\n\t\tret = devm_spi_register_controller(dev,\
  \ spi_host);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\tpci_set_drvdata(pdev, spi_bus);\n\
  \n\treturn 0;\n\nerror:\n\tpci_release_regions(pdev);\n\treturn ret;\n}\n```\n\n\
  ## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/spi/spi-pci1xxxx.c b/drivers/spi/spi-pci1xxxx.c\n\
  index 969965d7bc98..cc18d320370f 100644\n--- a/drivers/spi/spi-pci1xxxx.c\n+++ b/drivers/spi/spi-pci1xxxx.c\n\
  @@ -725,6 +725,8 @@ static int pci1xxxx_spi_probe(struct pci_dev *pdev, const struct\
  \ pci_device_id *\n \t\tspi_bus->spi_int[iter] = devm_kzalloc(&pdev->dev,\n \t\t\
  \t\t\t\t      sizeof(struct pci1xxxx_spi_internal),\n \t\t\t\t\t\t      GFP_KERNEL);\n\
  +\t\tif (!spi_bus->spi_int[iter])\n+\t\t\treturn -ENOMEM;\n \t\tspi_sub_ptr = spi_bus->spi_int[iter];\n\
  \ \t\tspi_sub_ptr->spi_host = devm_spi_alloc_host(dev, sizeof(struct spi_controller));\n\
  \ \t\tif (!spi_sub_ptr->spi_host)\n```\n"
pattern: '## Bug Pattern


  Allocating a per-instance structure with devm_kzalloc() and then immediately dereferencing
  it (directly or via an alias) without checking for NULL. For example:


  spi_bus->spi_int[i] = devm_kzalloc(dev, sizeof(*spi_bus->spi_int[i]), GFP_KERNEL);

  /* Missing NULL check here */

  spi_sub_ptr = spi_bus->spi_int[i];

  spi_sub_ptr->spi_host = devm_spi_alloc_host(dev, sizeof(struct spi_controller));


  This pattern risks a NULL pointer dereference if devm_kzalloc() fails.'
plan: "1) Program state\n\n- REGISTER_SET_WITH_PROGRAMSTATE(DevmNullableSyms, SymbolRef)\n\
  \  - Contains symbols returned by devm_kzalloc() that \u201Cmay be NULL\u201D and\
  \ have not yet been checked.\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(RegionToSym, const\
  \ MemRegion *, SymbolRef)\n  - Maps lvalue regions (variables, array elements, fields)\
  \ that currently hold a devm_kzalloc() result to its symbol. This lets us recognize\
  \ checks/dereferences via the original field/array element or any alias variable.\n\
  \nRationale: Keep it as simple as possible. We only need to know which symbols are\
  \ possibly-null (unchecked) and which lvalue regions hold them at any given point.\
  \ Removing a symbol from DevmNullableSyms means it has been checked (we don\u2019\
  t need an extra \u201Cchecked\u201D map).\n\n\n2) Helper utilities\n\n- isDevmKzalloc(const\
  \ CallEvent &Call)\n  - Return true if Call.getCalleeIdentifier()->getName() ==\
  \ \"devm_kzalloc\".\n\n- getPtrExprInCondition(const Stmt *Cond)\n  - Given an if/switch/while\
  \ condition, return the pointer expression that is being null-checked if the condition\
  \ is one of:\n    - if (ptr) or if (!ptr): strip parens/implicit casts; detect UnaryOperator\
  \ \u2018!\u2019 and its subexpr; else use the expr itself.\n    - if (ptr == NULL)\
  \ or if (ptr != NULL): detect BinaryOperator \u2018==\u2019/\u2018!=\u2019 where\
  \ one side is null (integer literal 0, GNUNullExpr, CXXNullPtrLiteralExpr) and return\
  \ the other side.\n  - Always call IgnoreParenImpCasts() on subexpressions.\n\n\
  - markCheckedIfTracked(const Expr *E, CheckerContext &C)\n  - Use getMemRegionFromExpr(E,\
  \ C) to get the region R.\n  - Look up RegionToSym[R] -> Sym. If found and Sym \u2208\
  \ DevmNullableSyms, remove Sym from DevmNullableSyms.\n  - This handles both if\
  \ (!spi_bus->spi_int[i]) and if (!spi_sub_ptr).\n\n- getBaseExprFromDeref(const\
  \ Stmt *S)\n  - For a dereference-like access:\n    - If S (or a child) is a MemberExpr\
  \ ME and ME->isArrow() is true, return ME->getBase()->IgnoreParenImpCasts().\n \
  \   - Else if S (or a child) is a UnaryOperator UO with opcode UO_Deref, return\
  \ UO->getSubExpr()->IgnoreParenImpCasts().\n    - Else if S (or a child) is an ArraySubscriptExpr\
  \ ASE and the base type of ASE->getBase() is a pointer, return ASE->getBase()->IgnoreParenImpCasts().\n\
  \  - Use findSpecificTypeInChildren<MemberExpr/UnaryOperator/ArraySubscriptExpr>\
  \ to find the node if S isn\u2019t exactly one of these.\n  - Return nullptr if\
  \ nothing matches.\n\n\n3) Callbacks and logic\n\nA) checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C)\n- If not isDevmKzalloc(Call), return.\n- Get the return\
  \ value: SVal Ret = Call.getReturnValue().\n- If SymbolRef Sym = Ret.getAsSymbol():\n\
  \  - State = State->add<DevmNullableSyms>(Sym).\n  - Do not bind anything here;\
  \ binding of the value into a variable/field happens in checkBind.\n\nWhy: devm_kzalloc\
  \ can return NULL; we mark the returned symbol as possibly NULL.\n\nB) checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C)\n- const MemRegion *LHSReg =\
  \ Loc.getAsRegion(); if !LHSReg return.\n- If SymbolRef RHSym = Val.getAsSymbol():\n\
  \  - If RHSym \u2208 DevmNullableSyms:\n    - State = State->set<RegionToSym>(LHSReg,\
  \ RHSym).\n    - This covers:\n      - spi_bus->spi_int[i] = devm_kzalloc(...);\n\
  \      - spi_sub_ptr = spi_bus->spi_int[i]; (RHS resolves to the same symbol)\n\
  - If RHS is not a symbol, no action needed.\n\nWhy: propagate the symbol to every\
  \ lvalue region that stores it so that later checks/dereferences via fields, array\
  \ elements, or aliases are recognized.\n\nC) checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C)\n- Extract pointer expression E = getPtrExprInCondition(Condition).\n\
  - If E is null, return.\n- Call markCheckedIfTracked(E, C).\n  - If the condition\
  \ checks spi_bus->spi_int[i] or an alias like spi_sub_ptr, the symbol will be removed\
  \ from DevmNullableSyms for the current path.\n\nWhy: any explicit NULL-check counts\
  \ as \u201Cchecked\u201D for our purposes.\n\nD) checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S, CheckerContext &C)\n- Identify whether S corresponds to a pointer\
  \ dereference base:\n  - const Expr *Base = getBaseExprFromDeref(S).\n  - If !Base,\
  \ return.\n- const MemRegion *BaseReg = getMemRegionFromExpr(Base, C).\n  - If !BaseReg,\
  \ return.\n- Look up Sym = RegionToSym[BaseReg].\n  - If not found, return.\n- If\
  \ Sym \u2208 DevmNullableSyms:\n  - This means the devm_kzalloc() result stored\
  \ in BaseReg has not been checked on this path and is now being dereferenced.\n\
  \  - Generate a non-fatal error node and emit:\n    - PathSensitiveBugReport with\
  \ a short message:\n      \"Unchecked devm_kzalloc() result may be NULL\"\n    -\
  \ Attach the current statement S as the location.\n\nWhy: we catch dereferences\
  \ through \u201C->\u201D, \u201C*ptr\u201D, or \u201Cptr[i]\u201D that occur before\
  \ any NULL check.\n\nNotes:\n- We do not try to be clever about path-sensitive inequality\
  \ vs equality; the analyzer will naturally split paths, and our state updates apply\
  \ per-path.\n- We do not need to handle freeing or device-managed lifetimes; this\
  \ checker is solely about missing NULL checks before dereference.\n\n\n4) Minimal\
  \ extra details\n\n- No need to implement evalCall or evalAssume.\n- No need for\
  \ additional region invalidation handling.\n- Only the above four callbacks are\
  \ required for this pattern.\n\n5) Summary of the detection flow on the target pattern\n\
  \n- devm_kzalloc(...) returns Sym0 \u2192 add Sym0 to DevmNullableSyms.\n- Assignment\
  \ spi_bus->spi_int[i] = (Sym0) \u2192 RegionToSym[ElementRegion(spi_int[i])] = Sym0.\n\
  - Assignment spi_sub_ptr = spi_bus->spi_int[i] \u2192 RegionToSym[VarRegion(spi_sub_ptr)]\
  \ = Sym0.\n- If no null-check seen on either spi_bus->spi_int[i] or spi_sub_ptr\
  \ (i.e., Sym0 still \u2208 DevmNullableSyms),\n  then when encountering spi_sub_ptr->...\
  \ (MemberExpr with arrow) or spi_bus->spi_int[i]->..., checkLocation triggers:\n\
  \  - Base region resolves to VarRegion(spi_sub_ptr) or ElementRegion(spi_int[i]).\n\
  \  - We find Sym0 and report \u201CUnchecked devm_kzalloc() result may be NULL\u201D\
  ."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/OperationKinds.h\"\
  \n#include \"clang/AST/Type.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Program state: set of symbols returned from devm_kzalloc\
  \ that may be NULL\nREGISTER_SET_WITH_PROGRAMSTATE(DevmNullableSyms, SymbolRef)\n\
  // Program state: map regions (lvalues) holding tracked symbols to that symbol\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(RegionToSym, const MemRegion *, SymbolRef)\n\nnamespace\
  \ {\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker : public\
  \ Checker<check::PostCall, check::Bind, check::BranchCondition, check::Location>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unchecked devm_kzalloc() result\", \"Null Dereference\"\
  )) {}\n\n      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \      void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \      void checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C)\
  \ const;\n\n   private:\n\n      // Helpers\n      static bool isDevmKzalloc(const\
  \ CallEvent &Call, CheckerContext &C);\n      static const Expr *getPtrExprInCondition(const\
  \ Stmt *Cond, CheckerContext &C);\n      static ProgramStateRef markCheckedIfTracked(ProgramStateRef\
  \ State, const Expr *E, CheckerContext &C);\n      static const Expr *getBaseExprFromDeref(const\
  \ Stmt *S);\n};\n\nbool SAGenTestChecker::isDevmKzalloc(const CallEvent &Call, CheckerContext\
  \ &C) {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return\
  \ false;\n  return ExprHasName(Origin, \"devm_kzalloc\", C);\n}\n\nconst Expr *SAGenTestChecker::getPtrExprInCondition(const\
  \ Stmt *Cond, CheckerContext &C) {\n  if (!Cond)\n    return nullptr;\n  const Expr\
  \ *CondE = dyn_cast<Expr>(Cond);\n  if (!CondE)\n    return nullptr;\n\n  // if\
  \ (!ptr)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if (UO->getOpcode()\
  \ == UO_LNot) {\n      return UO->getSubExpr(); // do not IgnoreImpCasts before\
  \ region extraction\n    }\n  }\n\n  // if (ptr == NULL) or if (ptr != NULL)\n \
  \ if (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr\
  \ *LHS = BO->getLHS();\n      const Expr *RHS = BO->getRHS();\n      if (!LHS ||\
  \ !RHS)\n        return nullptr;\n\n      bool LHSIsNull = LHS->isNullPointerConstant(C.getASTContext(),\n\
  \                                                  Expr::NPC_ValueDependentIsNull);\n\
  \      bool RHSIsNull = RHS->isNullPointerConstant(C.getASTContext(),\n        \
  \                                          Expr::NPC_ValueDependentIsNull);\n\n\
  \      if (LHSIsNull && !RHSIsNull)\n        return RHS;\n      if (RHSIsNull &&\
  \ !LHSIsNull)\n        return LHS;\n    }\n  }\n\n  // if (ptr)\n  return CondE;\n\
  }\n\nProgramStateRef SAGenTestChecker::markCheckedIfTracked(ProgramStateRef State,\
  \ const Expr *E, CheckerContext &C) {\n  if (!E)\n    return State;\n\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C);\n  if (!MR)\n    return State;\n\n  MR = MR->getBaseRegion();\n\
  \  if (!MR)\n    return State;\n\n  if (const SymbolRef *SymPtr = State->get<RegionToSym>(MR))\
  \ {\n    SymbolRef Sym = *SymPtr;\n    if (State->contains<DevmNullableSyms>(Sym))\
  \ {\n      State = State->remove<DevmNullableSyms>(Sym);\n    }\n  }\n  return State;\n\
  }\n\n// Find base pointer expression that is being dereferenced in statement S\n\
  const Expr *SAGenTestChecker::getBaseExprFromDeref(const Stmt *S) {\n  if (!S)\n\
  \    return nullptr;\n\n  // Look for '->'\n  if (const auto *ME = findSpecificTypeInChildren<MemberExpr>(S))\
  \ {\n    if (ME && ME->isArrow()) {\n      return ME->getBase(); // do not strip\
  \ implicit casts here\n    }\n  }\n\n  // Look for '*ptr'\n  if (const auto *UO\
  \ = findSpecificTypeInChildren<UnaryOperator>(S)) {\n    if (UO && UO->getOpcode()\
  \ == UO_Deref) {\n      return UO->getSubExpr();\n    }\n  }\n\n  // Look for 'ptr[index]'\
  \ where base is a pointer (not array lvalue)\n  if (const auto *ASE = findSpecificTypeInChildren<ArraySubscriptExpr>(S))\
  \ {\n    if (ASE) {\n      QualType BT = ASE->getBase()->getType();\n      if (!BT.isNull()\
  \ && BT->isPointerType()) {\n        return ASE->getBase();\n      }\n    }\n  }\n\
  \n  return nullptr;\n}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  if (!isDevmKzalloc(Call, C))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  SVal Ret = Call.getReturnValue();\n  if (SymbolRef Sym\
  \ = Ret.getAsSymbol()) {\n    // Mark this returned symbol as possibly NULL (unchecked)\n\
  \    State = State->add<DevmNullableSyms>(Sym);\n    C.addTransition(State);\n \
  \ }\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *LHSReg\
  \ = Loc.getAsRegion();\n  if (!LHSReg)\n    return;\n  LHSReg = LHSReg->getBaseRegion();\n\
  \  if (!LHSReg)\n    return;\n\n  bool Updated = false;\n\n  // Case 1: RHS is a\
  \ symbol directly (e.g., from devm_kzalloc return)\n  if (SymbolRef RHSym = Val.getAsSymbol())\
  \ {\n    if (State->contains<DevmNullableSyms>(RHSym)) {\n      State = State->set<RegionToSym>(LHSReg,\
  \ RHSym);\n      Updated = true;\n    }\n  }\n\n  // Case 2: RHS is an expression\
  \ referring to a region that already holds a tracked symbol\n  const Expr *RHSExpr\
  \ = nullptr;\n  if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S)) {\n  \
  \  if (BO->isAssignmentOp()) {\n      RHSExpr = BO->getRHS();\n    }\n  } else if\
  \ (const auto *DS = dyn_cast_or_null<DeclStmt>(S)) {\n    // Handle simple declarations\
  \ with initializer: int *p = q;\n    if (DS->isSingleDecl()) {\n      if (const\
  \ auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl())) {\n        if (const Expr *Init\
  \ = VD->getInit())\n          RHSExpr = Init;\n      }\n    }\n  }\n\n  if (RHSExpr)\
  \ {\n    const MemRegion *RHSReg = getMemRegionFromExpr(RHSExpr, C);\n    if (RHSReg)\
  \ {\n      RHSReg = RHSReg->getBaseRegion();\n      if (RHSReg) {\n        if (const\
  \ SymbolRef *HeldSym = State->get<RegionToSym>(RHSReg)) {\n          // Only propagate\
  \ if that symbol is still considered possibly null\n          if (State->contains<DevmNullableSyms>(*HeldSym))\
  \ {\n            State = State->set<RegionToSym>(LHSReg, *HeldSym);\n          \
  \  Updated = true;\n          }\n        }\n      }\n    }\n  }\n\n  // If not updated\
  \ and LHS had an old mapping, clear it to avoid stale associations\n  if (!Updated)\
  \ {\n    if (State->get<RegionToSym>(LHSReg)) {\n      State = State->remove<RegionToSym>(LHSReg);\n\
  \      Updated = true;\n    }\n  }\n\n  if (Updated)\n    C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  const Expr *PtrExpr =\
  \ getPtrExprInCondition(Condition, C);\n  if (!PtrExpr) {\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  State = markCheckedIfTracked(State, PtrExpr, C);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\
  \ CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\n  // Try\
  \ to find the base pointer expression being dereferenced in S\n  const Expr *Base\
  \ = getBaseExprFromDeref(S);\n  if (!Base)\n    return;\n\n  const MemRegion *BaseReg\
  \ = getMemRegionFromExpr(Base, C);\n  if (!BaseReg)\n    return;\n\n  BaseReg =\
  \ BaseReg->getBaseRegion();\n  if (!BaseReg)\n    return;\n\n  const SymbolRef *SymPtr\
  \ = State->get<RegionToSym>(BaseReg);\n  if (!SymPtr)\n    return;\n\n  SymbolRef\
  \ Sym = *SymPtr;\n  if (!State->contains<DevmNullableSyms>(Sym))\n    return;\n\n\
  \  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n\
  \  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Unchecked devm_kzalloc()\
  \ result may be NULL\", N);\n  R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects dereference of devm_kzalloc() result without a NULL check\",\n\
  \      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: -1
tp_score: 1
