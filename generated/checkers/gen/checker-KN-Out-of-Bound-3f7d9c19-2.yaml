_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3f7d9c1964fcd16d02a8a9d4fd6f6cb60c4cc530
commit_type: Out-of-Bound
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\nREGISTER_SET_WITH_PROGRAMSTATE(UncheckedLenSet,\
  \ const MemRegion*)\n\nnamespace {\nclass SAGenTestChecker : public Checker<\n \
  \   check::PostCall,\n    check::PreCall,\n    check::BranchCondition> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"Unvalidated device length\", \"API Misuse\")) {}\n\n      void\
  \ checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n\n      bool isInVirtnetProbe(CheckerContext\
  \ &C) const;\n      const BinaryOperator *getEnclosingAssignment(const Expr *E,\
  \ CheckerContext &C) const;\n      const MemRegion *getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) const;\n      void reportUnvalidatedUse(const CallEvent\
  \ &Call, CheckerContext &C, const Expr *ArgE = nullptr) const;\n      bool isVirtioCread8Call(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      bool isVirtnetInitDefaultRss(const\
  \ CallEvent &Call, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isInVirtnetProbe(CheckerContext\
  \ &C) const {\n  const LocationContext *LCtx = C.getLocationContext();\n  if (!LCtx)\
  \ return false;\n  const Decl *D = LCtx->getDecl();\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!FD) return false;\n  return FD->getNameAsString() == \"virtnet_probe\";\n\
  }\n\nconst BinaryOperator *SAGenTestChecker::getEnclosingAssignment(const Expr *E,\
  \ CheckerContext &C) const {\n  if (!E) return nullptr;\n  const BinaryOperator\
  \ *BO = findSpecificTypeInParents<BinaryOperator>(E, C);\n  if (BO && BO->isAssignmentOp())\n\
  \    return BO;\n  return nullptr;\n}\n\nconst MemRegion *SAGenTestChecker::getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E) return nullptr;\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C);\n  if (!MR) return nullptr;\n  MR = MR->getBaseRegion();\n\
  \  return MR;\n}\n\nbool SAGenTestChecker::isVirtioCread8Call(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n  if\
  \ (!Origin) return false;\n  return ExprHasName(Origin, \"virtio_cread8\", C);\n\
  }\n\nbool SAGenTestChecker::isVirtnetInitDefaultRss(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin) return\
  \ false;\n  return ExprHasName(Origin, \"virtnet_init_default_rss\", C);\n}\n\n\
  void SAGenTestChecker::reportUnvalidatedUse(const CallEvent &Call, CheckerContext\
  \ &C, const Expr *ArgE) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N) return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n     \
  \ *BT, \"rss_key_size used without validating against VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , N);\n  if (ArgE)\n    R->addRange(ArgE->getSourceRange());\n  else\n    R->addRange(Call.getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // Only care within virtnet_probe\
  \ to keep noise low and match the target bug.\n  if (!isInVirtnetProbe(C))\n   \
  \ return;\n\n  if (!isVirtioCread8Call(Call, C))\n    return;\n\n  // Ensure the\
  \ offset argument mentions rss_max_key_size.\n  if (Call.getNumArgs() < 2)\n   \
  \ return;\n  const Expr *OffArg = Call.getArgExpr(1);\n  if (!OffArg)\n    return;\n\
  \n  if (!ExprHasName(OffArg, \"rss_max_key_size\", C))\n    return;\n\n  // Find\
  \ the assignment receiving the virtio_cread8 result.\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  const BinaryOperator *AssignBO = getEnclosingAssignment(Origin, C);\n  if (!AssignBO)\n\
  \    return;\n\n  const Expr *LHS = AssignBO->getLHS();\n  if (!LHS)\n    return;\n\
  \n  // Heuristic: ensure LHS name contains rss_key_size to match the exact field.\n\
  \  if (!ExprHasName(LHS, \"rss_key_size\", C))\n    return;\n\n  const MemRegion\
  \ *LHSRegBase = getBaseRegionFromExpr(LHS, C);\n  if (!LHSRegBase)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n  if (!State->contains<UncheckedLenSet>(LHSRegBase))\
  \ {\n    State = State->add<UncheckedLenSet>(LHSRegBase);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!isInVirtnetProbe(C))\n    return;\n\n  ProgramStateRef State\
  \ = C.getState();\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  const\
  \ BinaryOperator *BO = nullptr;\n\n  if (CondE) {\n    if (const auto *TryBO = dyn_cast<BinaryOperator>(CondE->IgnoreParenImpCasts()))\n\
  \      BO = TryBO;\n  }\n  if (!BO) {\n    // Try to find a binary operator within\
  \ the condition tree.\n    BO = findSpecificTypeInChildren<BinaryOperator>(Condition);\n\
  \  }\n  if (!BO)\n    return;\n\n  BinaryOperatorKind Op = BO->getOpcode();\n  switch\
  \ (Op) {\n    case BO_LT: case BO_LE: case BO_GT: case BO_GE: case BO_EQ: case BO_NE:\n\
  \      break;\n    default:\n      return; // Not a comparison\n  }\n\n  const Expr\
  \ *LHS = BO->getLHS();\n  const Expr *RHS = BO->getRHS();\n  if (!LHS || !RHS)\n\
  \    return;\n\n  bool LHSHasMax = ExprHasName(LHS, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C);\n  bool RHSHasMax = ExprHasName(RHS, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\", C);\n\
  \  if (!LHSHasMax && !RHSHasMax)\n    return;\n\n  const Expr *LenExpr = LHSHasMax\
  \ ? RHS : LHS;\n\n  // We also accept textual presence of rss_key_size in the comparison\
  \ as a strong hint.\n  if (!ExprHasName(LenExpr, \"rss_key_size\", C))\n    return;\n\
  \n  const MemRegion *LenRegBase = getBaseRegionFromExpr(LenExpr, C);\n  if (!LenRegBase)\n\
  \    return;\n\n  if (State->contains<UncheckedLenSet>(LenRegBase)) {\n    State\
  \ = State->remove<UncheckedLenSet>(LenRegBase);\n    C.addTransition(State);\n \
  \ }\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  if (!isInVirtnetProbe(C))\n    return;\n\n  ProgramStateRef State\
  \ = C.getState();\n\n  // 1) General case: any call argument expression that mentions\
  \ rss_key_size\n  // and maps to an unvalidated region should be reported.\n  for\
  \ (unsigned i = 0, e = Call.getNumArgs(); i != e; ++i) {\n    const Expr *ArgE =\
  \ Call.getArgExpr(i);\n    if (!ArgE)\n      continue;\n\n    // Only consider arguments\
  \ that refer to rss_key_size to avoid false positives.\n    if (!ExprHasName(ArgE,\
  \ \"rss_key_size\", C))\n      continue;\n\n    const MemRegion *ArgBase = getBaseRegionFromExpr(ArgE,\
  \ C);\n    if (!ArgBase)\n      continue;\n\n    if (State->contains<UncheckedLenSet>(ArgBase))\
  \ {\n      reportUnvalidatedUse(Call, C, ArgE);\n      // Don't return; keep looking\
  \ for multiple uses in the same call if any.\n    }\n  }\n\n  // 2) Specific sink:\
  \ virtnet_init_default_rss(vi)\n  // This function will set default RSS using rss_key_size;\
  \ if the 'vi'\n  // region is still unvalidated, warn here even if rss_key_size\
  \ isn't passed\n  // explicitly as an argument.\n  if (isVirtnetInitDefaultRss(Call,\
  \ C) && Call.getNumArgs() >= 1) {\n    const Expr *ViArg = Call.getArgExpr(0);\n\
  \    if (ViArg) {\n      const MemRegion *ViBase = getBaseRegionFromExpr(ViArg,\
  \ C);\n      if (ViBase && State->contains<UncheckedLenSet>(ViBase)) {\n       \
  \ reportUnvalidatedUse(Call, C, ViArg);\n      }\n    }\n  }\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect unvalidated rss_key_size against VIRTIO_NET_RSS_MAX_KEY_SIZE before\
  \ use\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nvirtio_net: Add hash_key_length check\n\nAdd hash_key_length\
  \ check in virtnet_probe() to avoid possible out of\nbound errors when setting/reading\
  \ the hash key.\n\nFixes: c7114b1249fa (\"drivers/net/virtio_net: Added basic RSS\
  \ support.\")\nSigned-off-by: Philo Lu <lulie@linux.alibaba.com>\nSigned-off-by:\
  \ Xuan Zhuo <xuanzhuo@linux.alibaba.com>\nAcked-by: Joe Damato <jdamato@fastly.com>\n\
  Acked-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: virtnet_probe in drivers/net/virtio_net.c\n\
  static int virtnet_probe(struct virtio_device *vdev)\n{\n\tint i, err = -ENOMEM;\n\
  \tstruct net_device *dev;\n\tstruct virtnet_info *vi;\n\tu16 max_queue_pairs;\n\t\
  int mtu = 0;\n\n\t/* Find if host supports multiqueue/rss virtio_net device */\n\
  \tmax_queue_pairs = 1;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MQ) || virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_RSS))\n\t\tmax_queue_pairs =\n\t\t     virtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config, max_virtqueue_pairs));\n\n\t/* We need at least 2 queue's */\n\
  \tif (max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||\n\t    max_queue_pairs\
  \ > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||\n\t    !virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\
  \t\tmax_queue_pairs = 1;\n\n\t/* Allocate ourselves a network device with room for\
  \ our info */\n\tdev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);\n\
  \tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* Set up network device as normal. */\n\t\
  dev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE |\n\t\t\t   IFF_TX_SKB_NO_LINEAR;\n\
  \tdev->netdev_ops = &virtnet_netdev;\n\tdev->stat_ops = &virtnet_stat_ops;\n\tdev->features\
  \ = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev,\
  \ &vdev->dev);\n\n\t/* Do we support \"hardware\" checksums? */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_CSUM)) {\n\t\t/* This opens up the world of extra features. */\n\t\
  \tdev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\t\tif (csum)\n\t\t\tdev->features\
  \ |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO))\
  \ {\n\t\t\tdev->hw_features |= NETIF_F_TSO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\
  \t\t}\n\t\t/* Individual feature bits: what can host handle? */\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_ECN))\n\t\t\tdev->hw_features |= NETIF_F_TSO_ECN;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_USO))\n\t\t\tdev->hw_features |= NETIF_F_GSO_UDP_L4;\n\n\t\t\
  dev->features |= NETIF_F_GSO_ROBUST;\n\n\t\tif (gso)\n\t\t\tdev->features |= dev->hw_features\
  \ & NETIF_F_ALL_TSO;\n\t\t/* (!csum && gso) case will be fixed by register_netdev()\
  \ */\n\t}\n\n\t/* 1. With VIRTIO_NET_F_GUEST_CSUM negotiation, the driver doesn't\n\
  \t * need to calculate checksums for partially checksummed packets,\n\t * as they're\
  \ considered valid by the upper layer.\n\t * 2. Without VIRTIO_NET_F_GUEST_CSUM\
  \ negotiation, the driver only\n\t * receives fully checksummed packets. The device\
  \ may assist in\n\t * validating these packets' checksums, so the driver won't have\
  \ to.\n\t */\n\tdev->features |= NETIF_F_RXCSUM;\n\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_GUEST_TSO4) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6))\n\
  \t\tdev->features |= NETIF_F_GRO_HW;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS))\n\
  \t\tdev->hw_features |= NETIF_F_GRO_HW;\n\n\tdev->vlan_features = dev->features;\n\
  \tdev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT;\n\n\t/* MTU\
  \ range: 68 - 65535 */\n\tdev->min_mtu = MIN_MTU;\n\tdev->max_mtu = MAX_MTU;\n\n\
  \t/* Configuration may specify what MAC to use.  Otherwise random. */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MAC)) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tvirtio_cread_bytes(vdev,\n\
  \t\t\t\t   offsetof(struct virtio_net_config, mac),\n\t\t\t\t   addr, ETH_ALEN);\n\
  \t\teth_hw_addr_set(dev, addr);\n\t} else {\n\t\teth_hw_addr_random(dev);\n\t\t\
  dev_info(&vdev->dev, \"Assigned random MAC address %pM\\n\",\n\t\t\t dev->dev_addr);\n\
  \t}\n\n\t/* Set up our device-specific information */\n\tvi = netdev_priv(dev);\n\
  \tvi->dev = dev;\n\tvi->vdev = vdev;\n\tvdev->priv = vi;\n\n\tINIT_WORK(&vi->config_work,\
  \ virtnet_config_changed_work);\n\tINIT_WORK(&vi->rx_mode_work, virtnet_rx_mode_work);\n\
  \tspin_lock_init(&vi->refill_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))\
  \ {\n\t\tvi->mergeable_rx_bufs = true;\n\t\tdev->xdp_features |= NETDEV_XDP_ACT_RX_SG;\n\
  \t}\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HASH_REPORT))\n\t\tvi->has_rss_hash_report\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_RSS)) {\n\t\tvi->has_rss\
  \ = true;\n\n\t\tvi->rss_indir_table_size =\n\t\t\tvirtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config,\n\t\t\t\trss_max_indirection_table_length));\n\t}\n\terr =\
  \ rss_indirection_table_alloc(&vi->rss, vi->rss_indir_table_size);\n\tif (err)\n\
  \t\tgoto free;\n\n\tif (vi->has_rss || vi->has_rss_hash_report) {\n\t\tvi->rss_key_size\
  \ =\n\t\t\tvirtio_cread8(vdev, offsetof(struct virtio_net_config, rss_max_key_size));\n\
  \n\t\tvi->rss_hash_types_supported =\n\t\t    virtio_cread32(vdev, offsetof(struct\
  \ virtio_net_config, supported_hash_types));\n\t\tvi->rss_hash_types_supported &=\n\
  \t\t\t\t~(VIRTIO_NET_RSS_HASH_TYPE_IP_EX |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_TCP_EX\
  \ |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_UDP_EX);\n\n\t\tdev->hw_features |= NETIF_F_RXHASH;\n\
  \t\tdev->xdp_metadata_ops = &virtnet_xdp_metadata_ops;\n\t}\n\n\tif (vi->has_rss_hash_report)\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_v1_hash);\n\telse if (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MRG_RXBUF) ||\n\t\t virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\telse\n\t\tvi->hdr_len\
  \ = sizeof(struct virtio_net_hdr);\n\n\tif (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT)\
  \ ||\n\t    virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\tvi->any_header_sg\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\t\tvi->has_cvq\
  \ = true;\n\n\tmutex_init(&vi->cvq_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MTU))\
  \ {\n\t\tmtu = virtio_cread16(vdev,\n\t\t\t\t     offsetof(struct virtio_net_config,\n\
  \t\t\t\t\t      mtu));\n\t\tif (mtu < dev->min_mtu) {\n\t\t\t/* Should never trigger:\
  \ MTU was previously validated\n\t\t\t * in virtnet_validate.\n\t\t\t */\n\t\t\t\
  dev_err(&vdev->dev,\n\t\t\t\t\"device MTU appears to have changed it is now %d <\
  \ %d\",\n\t\t\t\tmtu, dev->min_mtu);\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\
  \t}\n\n\t\tdev->mtu = mtu;\n\t\tdev->max_mtu = mtu;\n\t}\n\n\tvirtnet_set_big_packets(vi,\
  \ mtu);\n\n\tif (vi->any_header_sg)\n\t\tdev->needed_headroom = vi->hdr_len;\n\n\
  \t/* Enable multiqueue by default */\n\tif (num_online_cpus() >= max_queue_pairs)\n\
  \t\tvi->curr_queue_pairs = max_queue_pairs;\n\telse\n\t\tvi->curr_queue_pairs =\
  \ num_online_cpus();\n\tvi->max_queue_pairs = max_queue_pairs;\n\n\t/* Allocate/initialize\
  \ the rx/tx queues, and invoke find_vqs */\n\terr = init_vqs(vi);\n\tif (err)\n\t\
  \tgoto free;\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_NOTF_COAL)) {\n\t\
  \tvi->intr_coal_rx.max_usecs = 0;\n\t\tvi->intr_coal_tx.max_usecs = 0;\n\t\tvi->intr_coal_rx.max_packets\
  \ = 0;\n\n\t\t/* Keep the default values of the coalescing parameters\n\t\t * aligned\
  \ with the default napi_tx state.\n\t\t */\n\t\tif (vi->sq[0].napi.weight)\n\t\t\
  \tvi->intr_coal_tx.max_packets = 1;\n\t\telse\n\t\t\tvi->intr_coal_tx.max_packets\
  \ = 0;\n\t}\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_VQ_NOTF_COAL)) {\n\
  \t\t/* The reason is the same as VIRTIO_NET_F_NOTF_COAL. */\n\t\tfor (i = 0; i <\
  \ vi->max_queue_pairs; i++)\n\t\t\tif (vi->sq[i].napi.weight)\n\t\t\t\tvi->sq[i].intr_coal.max_packets\
  \ = 1;\n\n\t\terr = virtnet_init_irq_moder(vi);\n\t\tif (err)\n\t\t\tgoto free;\n\
  \t}\n\n#ifdef CONFIG_SYSFS\n\tif (vi->mergeable_rx_bufs)\n\t\tdev->sysfs_rx_queue_group\
  \ = &virtio_net_mrg_rx_group;\n#endif\n\tnetif_set_real_num_tx_queues(dev, vi->curr_queue_pairs);\n\
  \tnetif_set_real_num_rx_queues(dev, vi->curr_queue_pairs);\n\n\tvirtnet_init_settings(dev);\n\
  \n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_STANDBY)) {\n\t\tvi->failover = net_failover_create(vi->dev);\n\
  \t\tif (IS_ERR(vi->failover)) {\n\t\t\terr = PTR_ERR(vi->failover);\n\t\t\tgoto\
  \ free_vqs;\n\t\t}\n\t}\n\n\tif (vi->has_rss || vi->has_rss_hash_report)\n\t\tvirtnet_init_default_rss(vi);\n\
  \n\tenable_rx_mode_work(vi);\n\n\t/* serialize netdev register + virtio_device_ready()\
  \ with ndo_open() */\n\trtnl_lock();\n\n\terr = register_netdevice(dev);\n\tif (err)\
  \ {\n\t\tpr_debug(\"virtio_net: registering device failed\\n\");\n\t\trtnl_unlock();\n\
  \t\tgoto free_failover;\n\t}\n\n\t/* Disable config change notification until ndo_open.\
  \ */\n\tvirtio_config_driver_disable(vi->vdev);\n\n\tvirtio_device_ready(vdev);\n\
  \n\tvirtnet_set_queues(vi, vi->curr_queue_pairs);\n\n\t/* a random MAC address has\
  \ been assigned, notify the device.\n\t * We don't fail probe if VIRTIO_NET_F_CTRL_MAC_ADDR\
  \ is not there\n\t * because many devices work fine without getting MAC explicitly\n\
  \t */\n\tif (!virtio_has_feature(vdev, VIRTIO_NET_F_MAC) &&\n\t    virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_CTRL_MAC_ADDR)) {\n\t\tstruct scatterlist sg;\n\n\t\tsg_init_one(&sg,\
  \ dev->dev_addr, dev->addr_len);\n\t\tif (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MAC,\n\
  \t\t\t\t\t  VIRTIO_NET_CTRL_MAC_ADDR_SET, &sg)) {\n\t\t\tpr_debug(\"virtio_net:\
  \ setting MAC address failed\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr = -EINVAL;\n\
  \t\t\tgoto free_unregister_netdev;\n\t\t}\n\t}\n\n\tif (virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_DEVICE_STATS)) {\n\t\tstruct virtio_net_stats_capabilities *stats_cap\
  \  __free(kfree) = NULL;\n\t\tstruct scatterlist sg;\n\t\t__le64 v;\n\n\t\tstats_cap\
  \ = kzalloc(sizeof(*stats_cap), GFP_KERNEL);\n\t\tif (!stats_cap) {\n\t\t\trtnl_unlock();\n\
  \t\t\terr = -ENOMEM;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tsg_init_one(&sg,\
  \ stats_cap, sizeof(*stats_cap));\n\n\t\tif (!virtnet_send_command_reply(vi, VIRTIO_NET_CTRL_STATS,\n\
  \t\t\t\t\t\tVIRTIO_NET_CTRL_STATS_QUERY,\n\t\t\t\t\t\tNULL, &sg)) {\n\t\t\tpr_debug(\"\
  virtio_net: fail to get stats capability\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr\
  \ = -EINVAL;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tv = stats_cap->supported_stats_types[0];\n\
  \t\tvi->device_stats_cap = le64_to_cpu(v);\n\t}\n\n\t/* Assume link up if device\
  \ can't report link status,\n\t   otherwise get link status from config. */\n\t\
  netif_carrier_off(dev);\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS))\
  \ {\n\t\tvirtnet_config_changed_work(&vi->config_work);\n\t} else {\n\t\tvi->status\
  \ = VIRTIO_NET_S_LINK_UP;\n\t\tvirtnet_update_settings(vi);\n\t\tnetif_carrier_on(dev);\n\
  \t}\n\n\tfor (i = 0; i < ARRAY_SIZE(guest_offloads); i++)\n\t\tif (virtio_has_feature(vi->vdev,\
  \ guest_offloads[i]))\n\t\t\tset_bit(guest_offloads[i], &vi->guest_offloads);\n\t\
  vi->guest_offloads_capable = vi->guest_offloads;\n\n\trtnl_unlock();\n\n\terr =\
  \ virtnet_cpu_notif_add(vi);\n\tif (err) {\n\t\tpr_debug(\"virtio_net: registering\
  \ cpu notifier failed\\n\");\n\t\tgoto free_unregister_netdev;\n\t}\n\n\tpr_debug(\"\
  virtnet: registered device %s with %d RX and TX vq's\\n\",\n\t\t dev->name, max_queue_pairs);\n\
  \n\treturn 0;\n\nfree_unregister_netdev:\n\tunregister_netdev(dev);\nfree_failover:\n\
  \tnet_failover_destroy(vi->failover);\nfree_vqs:\n\tvirtio_reset_device(vdev);\n\
  \tcancel_delayed_work_sync(&vi->refill);\n\tfree_receive_page_frags(vi);\n\tvirtnet_del_vqs(vi);\n\
  free:\n\tfree_netdev(dev);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c\nindex 4b507007d242..545dda8ec077\
  \ 100644\n--- a/drivers/net/virtio_net.c\n+++ b/drivers/net/virtio_net.c\n@@ -6451,6\
  \ +6451,12 @@ static int virtnet_probe(struct virtio_device *vdev)\n \tif (vi->has_rss\
  \ || vi->has_rss_hash_report) {\n \t\tvi->rss_key_size =\n \t\t\tvirtio_cread8(vdev,\
  \ offsetof(struct virtio_net_config, rss_max_key_size));\n+\t\tif (vi->rss_key_size\
  \ > VIRTIO_NET_RSS_MAX_KEY_SIZE) {\n+\t\t\tdev_err(&vdev->dev, \"rss_max_key_size=%u\
  \ exceeds the limit %u.\\n\",\n+\t\t\t\tvi->rss_key_size, VIRTIO_NET_RSS_MAX_KEY_SIZE);\n\
  +\t\t\terr = -EINVAL;\n+\t\t\tgoto free;\n+\t\t}\n \n \t\tvi->rss_hash_types_supported\
  \ =\n \t\t    virtio_cread32(vdev, offsetof(struct virtio_net_config, supported_hash_types));\n\
  ```\n"
pattern: "## Bug Pattern\n\nTrusting a device-reported length (rss_max_key_size) without\
  \ validating it against the driver\u2019s fixed maximum (VIRTIO_NET_RSS_MAX_KEY_SIZE)\
  \ before using it for buffer operations. This missing bounds check can lead to out-of-bounds\
  \ reads/writes when setting or reading the RSS hash key."
plan: "1) Program state\n\n- REGISTER_SET_WITH_PROGRAMSTATE(UncheckedLenSet, const\
  \ MemRegion*)\n  - Tracks struct/variable regions that hold a device-reported RSS\
  \ key length which has not yet been validated against VIRTIO_NET_RSS_MAX_KEY_SIZE.\n\
  \  - We will add the region when rss_max_key_size is read from the device and assigned\
  \ (unvalidated), and remove it when we detect a proper max-bound check.\n\nNo other\
  \ custom traits/maps are needed.\n\n\n2) Callbacks and how to implement them\n\n\
  A) checkPostCall (mark \u201Cdevice-reported length\u201D as unvalidated)\n- Goal:\
  \ Detect vi->rss_key_size = virtio_cread8(vdev, offsetof(..., rss_max_key_size))\n\
  - Steps:\n  1. Identify call to virtio_cread8:\n     - If Call.getCalleeIdentifier()\
  \ exists and name equals \"virtio_cread8\".\n  2. Ensure the offset argument corresponds\
  \ to rss_max_key_size:\n     - Let OffArg = Call.getArgExpr(1); if ExprHasName(OffArg,\
  \ \"rss_max_key_size\", C) is true, treat it as RSS key size read.\n  3. Find the\
  \ LHS of the assignment:\n     - Retrieve the origin expression of the call, E =\
  \ Call.getOriginExpr().\n     - Use findSpecificTypeInParents<BinaryOperator>(E,\
  \ C) and ensure it\u2019s an assignment operator (isAssignmentOp()).\n     - Extract\
  \ LHS expression from the BinaryOperator.\n  4. Obtain the LHS memory region:\n\
  \     - const MemRegion* LHSReg = getMemRegionFromExpr(LHSExpr, C).\n     - If LHSReg\
  \ is not null, add it to UncheckedLenSet: State->add<UncheckedLenSet>(LHSReg).\n\
  \  5. Optional (scope restriction): If desired to reduce noise, check enclosing\
  \ function name equals \"virtnet_probe\" via C.getLocationContext()->getDecl()->getAsFunction()->getNameAsString()\
  \ before adding to the set.\n\nRationale: This marks the field (e.g., vi->rss_key_size)\
  \ as \u201Cdevice-reported, not yet validated\u201D immediately after reading it\
  \ from the device.\n\n\nB) checkBranchCondition (mark as validated when compared\
  \ to the fixed max)\n- Goal: Detect the presence of an explicit bounds check against\
  \ VIRTIO_NET_RSS_MAX_KEY_SIZE.\n- Steps:\n  1. Get the branch condition Stmt* Cond.\n\
  \  2. Try dyn_cast<BinaryOperator>(Cond) (or findSpecificTypeInChildren<BinaryOperator>(Cond)\
  \ if necessary):\n     - If not a BinaryOperator, return.\n     - Only consider\
  \ relational comparisons: >, >=, <, <=, ==, !=.\n  3. Extract LHS and RHS expressions.\n\
  \  4. Determine if one side contains the macro name VIRTIO_NET_RSS_MAX_KEY_SIZE:\n\
  \     - If ExprHasName(LHS, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\", C) or ExprHasName(RHS,\
  \ \"VIRTIO_NET_RSS_MAX_KEY_SIZE\", C) is true, proceed.\n  5. Identify the other\
  \ side as the \u201Clength\u201D expression:\n     - Let LenExpr be the non-macro\
  \ side (LHS if RHS was macro, RHS if LHS was macro).\n     - Try to obtain its region:\
  \ const MemRegion* LenReg = getMemRegionFromExpr(LenExpr, C).\n  6. If LenReg is\
  \ in UncheckedLenSet, remove it:\n     - State = State->remove<UncheckedLenSet>(LenReg);\
  \ C.add_transition(State).\n  7. Notes:\n     - Accept any comparison operator here\
  \ (>, >=, <=, <, ==, !=), since presence of comparison against the macro is sufficient\
  \ evidence of validation for this checker.\n     - This is intentionally simple:\
  \ if the code checks the value against the constant, we consider it validated.\n\
  \nRationale: The bug fix added a \u201Cif (rss_key_size > VIRTIO_NET_RSS_MAX_KEY_SIZE)\
  \ { \u2026goto free; }\u201D check. Detecting any comparison with the macro is a\
  \ good proxy that validation exists.\n\n\nC) checkPreCall (report usage of unvalidated\
  \ device length)\n- Goal: Report when the unvalidated rss_key_size is used as an\
  \ argument in a call (e.g., for buffer sizing, setting/reading the hash key).\n\
  - Steps:\n  1. For the current call, iterate all arguments:\n     - For each arg\
  \ expression A:\n       - First, try to directly obtain a region: const MemRegion*\
  \ ArgReg = getMemRegionFromExpr(A, C).\n         - If ArgReg is non-null and ArgReg\
  \ is in UncheckedLenSet, we have a use of an unvalidated device length. Report (see\
  \ D).\n       - If ArgReg is null or not in the set, use a text-based fallback:\n\
  \         - If ExprHasName(A, \"rss_key_size\", C) is true, try to resolve the region\
  \ of the corresponding field by locating a MemberExpr inside A using findSpecificTypeInChildren<MemberExpr>(A)\
  \ and then getMemRegionFromExpr on that MemberExpr. If that region is in UncheckedLenSet,\
  \ report.\n  2. Optionally, to reduce noise, restrict sinks to known size-taking\
  \ APIs if desired:\n     - For instance, if Call name is \"sg_init_one\" (3rd argument\
  \ is size), or other known helper functions that set/read RSS key length. But the\
  \ general \"any call arg uses rss_key_size\" is acceptable and simple.\n  3. If\
  \ a report is emitted, do not alter state; multiple reports can occur on different\
  \ paths, which is acceptable.\n\nRationale: Using the device-provided length for\
  \ operations without validation is the dangerous behavior we want to flag.\n\n\n\
  D) Bug reporting helper\n- When a violation is detected in checkPreCall:\n  - Use\
  \ ExplodedNode* N = C.generateNonFatalErrorNode(); if (!N) return;\n  - Create a\
  \ static BugType (e.g., \"Unvalidated device length\").\n  - Build a short message:\
  \ \"rss_max_key_size used without validating against VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  .\n  - Emit a PathSensitiveBugReport with the current statement as the location.\n\
  - Keep the message short and clear as requested.\n\n\nE) Optional: checkEndFunction\n\
  - Not required. We only report at actual uses (sinks). No need to warn on mere presence\
  \ of unvalidated value if it is never used.\n\n\n3) Heuristics/Utilities used\n\n\
  - ExprHasName to:\n  - Recognize the offset argument containing \"rss_max_key_size\"\
  .\n  - Find comparisons to \"VIRTIO_NET_RSS_MAX_KEY_SIZE\".\n  - Fallback detection\
  \ of argument expressions mentioning \"rss_key_size\".\n- findSpecificTypeInParents<BinaryOperator>\
  \ to find the assignment receiving virtio_cread8 return.\n- findSpecificTypeInChildren<MemberExpr>\
  \ as a fallback to re-discover the MemberExpr for region retrieval when needed.\n\
  - getMemRegionFromExpr to convert LHS and argument expressions into MemRegion for\
  \ set membership in UncheckedLenSet.\n\n4) Constraints and simplifications\n\n-\
  \ We assume that explicit textual comparisons to VIRTIO_NET_RSS_MAX_KEY_SIZE in\
  \ a branch condition indicate proper validation. This keeps the checker simple and\
  \ matches the patch style.\n- We intentionally target the concrete field/macro names:\n\
  \  - Source: \"rss_max_key_size\" via virtio_cread8\u2019s offset argument.\n  -\
  \ Validation: \"VIRTIO_NET_RSS_MAX_KEY_SIZE\".\n  - Use: arguments that reference\
  \ \"rss_key_size\".\n- Alias tracking is not necessary here because the tracked\
  \ object is a scalar field and we directly look for its usage by name or by region\
  \ when possible.\n- If desired, the checker can be scoped to function \"virtnet_probe\"\
  \ to reduce noise; otherwise it works globally for the same pattern."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\nREGISTER_SET_WITH_PROGRAMSTATE(UncheckedLenSet,\
  \ const MemRegion*)\n\nnamespace {\nclass SAGenTestChecker : public Checker<\n \
  \   check::PostCall,\n    check::PreCall,\n    check::BranchCondition> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"Unvalidated device length\", \"API Misuse\")) {}\n\n      void\
  \ checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n\n      bool isInVirtnetProbe(CheckerContext\
  \ &C) const;\n      const BinaryOperator *getEnclosingAssignment(const Expr *E,\
  \ CheckerContext &C) const;\n      const MemRegion *getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) const;\n      void reportUnvalidatedUse(const CallEvent\
  \ &Call, CheckerContext &C, const Expr *ArgE = nullptr) const;\n      bool isVirtioCread8Call(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      bool isVirtnetInitDefaultRss(const\
  \ CallEvent &Call, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isInVirtnetProbe(CheckerContext\
  \ &C) const {\n  const LocationContext *LCtx = C.getLocationContext();\n  if (!LCtx)\
  \ return false;\n  const Decl *D = LCtx->getDecl();\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!FD) return false;\n  return FD->getNameAsString() == \"virtnet_probe\";\n\
  }\n\nconst BinaryOperator *SAGenTestChecker::getEnclosingAssignment(const Expr *E,\
  \ CheckerContext &C) const {\n  if (!E) return nullptr;\n  const BinaryOperator\
  \ *BO = findSpecificTypeInParents<BinaryOperator>(E, C);\n  if (BO && BO->isAssignmentOp())\n\
  \    return BO;\n  return nullptr;\n}\n\nconst MemRegion *SAGenTestChecker::getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E) return nullptr;\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C);\n  if (!MR) return nullptr;\n  MR = MR->getBaseRegion();\n\
  \  return MR;\n}\n\nbool SAGenTestChecker::isVirtioCread8Call(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n  if\
  \ (!Origin) return false;\n  return ExprHasName(Origin, \"virtio_cread8\", C);\n\
  }\n\nbool SAGenTestChecker::isVirtnetInitDefaultRss(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin) return\
  \ false;\n  return ExprHasName(Origin, \"virtnet_init_default_rss\", C);\n}\n\n\
  void SAGenTestChecker::reportUnvalidatedUse(const CallEvent &Call, CheckerContext\
  \ &C, const Expr *ArgE) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N) return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n     \
  \ *BT, \"rss_key_size used without validating against VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , N);\n  if (ArgE)\n    R->addRange(ArgE->getSourceRange());\n  else\n    R->addRange(Call.getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // Only care within virtnet_probe\
  \ to keep noise low and match the target bug.\n  if (!isInVirtnetProbe(C))\n   \
  \ return;\n\n  if (!isVirtioCread8Call(Call, C))\n    return;\n\n  // Ensure the\
  \ offset argument mentions rss_max_key_size.\n  if (Call.getNumArgs() < 2)\n   \
  \ return;\n  const Expr *OffArg = Call.getArgExpr(1);\n  if (!OffArg)\n    return;\n\
  \n  if (!ExprHasName(OffArg, \"rss_max_key_size\", C))\n    return;\n\n  // Find\
  \ the assignment receiving the virtio_cread8 result.\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  const BinaryOperator *AssignBO = getEnclosingAssignment(Origin, C);\n  if (!AssignBO)\n\
  \    return;\n\n  const Expr *LHS = AssignBO->getLHS();\n  if (!LHS)\n    return;\n\
  \n  // Heuristic: ensure LHS name contains rss_key_size to match the exact field.\n\
  \  if (!ExprHasName(LHS, \"rss_key_size\", C))\n    return;\n\n  const MemRegion\
  \ *LHSRegBase = getBaseRegionFromExpr(LHS, C);\n  if (!LHSRegBase)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n  if (!State->contains<UncheckedLenSet>(LHSRegBase))\
  \ {\n    State = State->add<UncheckedLenSet>(LHSRegBase);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!isInVirtnetProbe(C))\n    return;\n\n  ProgramStateRef State\
  \ = C.getState();\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  const\
  \ BinaryOperator *BO = nullptr;\n\n  if (CondE) {\n    if (const auto *TryBO = dyn_cast<BinaryOperator>(CondE->IgnoreParenImpCasts()))\n\
  \      BO = TryBO;\n  }\n  if (!BO) {\n    // Try to find a binary operator within\
  \ the condition tree.\n    BO = findSpecificTypeInChildren<BinaryOperator>(Condition);\n\
  \  }\n  if (!BO)\n    return;\n\n  BinaryOperatorKind Op = BO->getOpcode();\n  switch\
  \ (Op) {\n    case BO_LT: case BO_LE: case BO_GT: case BO_GE: case BO_EQ: case BO_NE:\n\
  \      break;\n    default:\n      return; // Not a comparison\n  }\n\n  const Expr\
  \ *LHS = BO->getLHS();\n  const Expr *RHS = BO->getRHS();\n  if (!LHS || !RHS)\n\
  \    return;\n\n  bool LHSHasMax = ExprHasName(LHS, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C);\n  bool RHSHasMax = ExprHasName(RHS, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\", C);\n\
  \  if (!LHSHasMax && !RHSHasMax)\n    return;\n\n  const Expr *LenExpr = LHSHasMax\
  \ ? RHS : LHS;\n\n  // We also accept textual presence of rss_key_size in the comparison\
  \ as a strong hint.\n  if (!ExprHasName(LenExpr, \"rss_key_size\", C))\n    return;\n\
  \n  const MemRegion *LenRegBase = getBaseRegionFromExpr(LenExpr, C);\n  if (!LenRegBase)\n\
  \    return;\n\n  if (State->contains<UncheckedLenSet>(LenRegBase)) {\n    State\
  \ = State->remove<UncheckedLenSet>(LenRegBase);\n    C.addTransition(State);\n \
  \ }\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  if (!isInVirtnetProbe(C))\n    return;\n\n  ProgramStateRef State\
  \ = C.getState();\n\n  // 1) General case: any call argument expression that mentions\
  \ rss_key_size\n  // and maps to an unvalidated region should be reported.\n  for\
  \ (unsigned i = 0, e = Call.getNumArgs(); i != e; ++i) {\n    const Expr *ArgE =\
  \ Call.getArgExpr(i);\n    if (!ArgE)\n      continue;\n\n    // Only consider arguments\
  \ that refer to rss_key_size to avoid false positives.\n    if (!ExprHasName(ArgE,\
  \ \"rss_key_size\", C))\n      continue;\n\n    const MemRegion *ArgBase = getBaseRegionFromExpr(ArgE,\
  \ C);\n    if (!ArgBase)\n      continue;\n\n    if (State->contains<UncheckedLenSet>(ArgBase))\
  \ {\n      reportUnvalidatedUse(Call, C, ArgE);\n      // Don't return; keep looking\
  \ for multiple uses in the same call if any.\n    }\n  }\n\n  // 2) Specific sink:\
  \ virtnet_init_default_rss(vi)\n  // This function will set default RSS using rss_key_size;\
  \ if the 'vi'\n  // region is still unvalidated, warn here even if rss_key_size\
  \ isn't passed\n  // explicitly as an argument.\n  if (isVirtnetInitDefaultRss(Call,\
  \ C) && Call.getNumArgs() >= 1) {\n    const Expr *ViArg = Call.getArgExpr(0);\n\
  \    if (ViArg) {\n      const MemRegion *ViBase = getBaseRegionFromExpr(ViArg,\
  \ C);\n      if (ViBase && State->contains<UncheckedLenSet>(ViBase)) {\n       \
  \ reportUnvalidatedUse(Call, C, ViArg);\n      }\n    }\n  }\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect unvalidated rss_key_size against VIRTIO_NET_RSS_MAX_KEY_SIZE before\
  \ use\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
