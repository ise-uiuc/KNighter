_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 2e29b9971ac54dec88baa58856a230ec2f2a2dff
commit_type: Null-Pointer-Dereference
index: 5
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"clang/AST/ASTContext.h\"\n#include\
  \ \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// No custom program state required.\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<check::BranchCondition>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Wrong NULL check after allocation\", \"Memory Management\"\
  )) {}\n\n      void checkBranchCondition(const Stmt *Condition, CheckerContext &C)\
  \ const;\n\n   private:\n      // Helpers\n      const Expr *getCheckedPtrExprRaw(const\
  \ Stmt *Condition, CheckerContext &C) const;\n      bool isNullExpr(const Expr *E,\
  \ CheckerContext &C) const;\n      bool isKernelAllocator(const CallExpr *CE, CheckerContext\
  \ &C) const;\n      bool returnsENOMEM(const Stmt *S, CheckerContext &C) const;\n\
  \      StringRef getExprText(const Expr *E, CheckerContext &C) const;\n};\n\nstatic\
  \ const CompoundStmt *getEnclosingCompound(const Stmt *S, CheckerContext &C) {\n\
  \  return findSpecificTypeInParents<CompoundStmt>(S, C);\n}\n\nstatic const IfStmt\
  \ *getEnclosingIf(const Stmt *S, CheckerContext &C) {\n  return findSpecificTypeInParents<IfStmt>(S,\
  \ C);\n}\n\nStringRef SAGenTestChecker::getExprText(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E)\n    return StringRef();\n  const SourceManager &SM = C.getSourceManager();\n\
  \  const LangOptions &LangOpts = C.getLangOpts();\n  CharSourceRange Range = CharSourceRange::getTokenRange(E->getSourceRange());\n\
  \  return Lexer::getSourceText(Range, SM, LangOpts);\n}\n\nbool SAGenTestChecker::isNullExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n  return E->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull);\n}\n\nbool SAGenTestChecker::isKernelAllocator(const\
  \ CallExpr *CE, CheckerContext &C) const {\n  if (!CE)\n    return false;\n  //\
  \ Use source-text based matching for robustness in the absence of direct callee.\n\
  \  const Expr *E = CE;\n  return ExprHasName(E, \"kzalloc\", C) ||\n         ExprHasName(E,\
  \ \"kmalloc\", C) ||\n         ExprHasName(E, \"kcalloc\", C) ||\n         ExprHasName(E,\
  \ \"kvzalloc\", C) ||\n         ExprHasName(E, \"vzalloc\", C) ||\n         ExprHasName(E,\
  \ \"devm_kzalloc\", C);\n}\n\nbool SAGenTestChecker::returnsENOMEM(const Stmt *S,\
  \ CheckerContext &C) const {\n  if (!S)\n    return false;\n\n  // Find a ReturnStmt\
  \ inside S (only one is needed to confirm).\n  const ReturnStmt *RS = findSpecificTypeInChildren<ReturnStmt>(S);\n\
  \  if (!RS)\n    return false;\n\n  const Expr *RetE = RS->getRetValue();\n  if\
  \ (!RetE)\n    return false;\n\n  // If the return expression mentions ENOMEM, accept.\n\
  \  if (ExprHasName(RetE, \"ENOMEM\", C))\n    return true;\n\n  // If it is a constant\
  \ negative integer (e.g., -12), accept.\n  llvm::APSInt Val;\n  if (EvaluateExprToInt(Val,\
  \ RetE, C)) {\n    if (Val.isSigned() ? Val.isNegative() : Val == 0) {\n      //\
  \ If unsigned, can't be negative; otherwise check negativity.\n      if (Val.isSigned()\
  \ && Val.isNegative())\n        return true;\n    }\n  }\n  return false;\n}\n\n\
  const Expr *SAGenTestChecker::getCheckedPtrExprRaw(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!Condition)\n    return nullptr;\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n\
  \  if (!CondE)\n    return nullptr;\n\n  // Analyze the structure while keeping\
  \ access to raw sub-expressions\n  const Expr *Stripped = CondE->IgnoreParenImpCasts();\n\
  \n  // if (!ptr)\n  if (const auto *UO = dyn_cast<UnaryOperator>(Stripped)) {\n\
  \    if (UO->getOpcode() == UO_LNot) {\n      const Expr *InnerRaw = UO->getSubExpr();\
  \ // Raw subexpr for region extraction\n      if (InnerRaw && InnerRaw->getType()->isPointerType())\n\
  \        return InnerRaw;\n    }\n  }\n\n  // if (ptr == NULL) or if (ptr != NULL)\n\
  \  if (const auto *BO = dyn_cast<BinaryOperator>(Stripped)) {\n    if (BO->getOpcode()\
  \ == BO_EQ || BO->getOpcode() == BO_NE) {\n      const Expr *LHSRaw = BO->getLHS();\n\
  \      const Expr *RHSRaw = BO->getRHS();\n      if (!LHSRaw || !RHSRaw)\n     \
  \   return nullptr;\n\n      const Expr *LHS = LHSRaw->IgnoreParenImpCasts();\n\
  \      const Expr *RHS = RHSRaw->IgnoreParenImpCasts();\n\n      bool LHSIsNull\
  \ = isNullExpr(LHS, C);\n      bool RHSIsNull = isNullExpr(RHS, C);\n\n      if\
  \ (LHSIsNull && !RHSIsNull && RHSRaw->getType()->isPointerType())\n        return\
  \ RHSRaw;\n      if (RHSIsNull && !LHSIsNull && LHSRaw->getType()->isPointerType())\n\
  \        return LHSRaw;\n    }\n  }\n\n  // if (ptr)\n  if (Stripped->getType()->isPointerType())\n\
  \    return CondE; // raw condition expr\n\n  return nullptr;\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  // Step 3.1: Extract the pointer\
  \ expression being NULL-checked.\n  const Expr *CheckedPtrExpr = getCheckedPtrExprRaw(Condition,\
  \ C);\n  if (!CheckedPtrExpr)\n    return;\n\n  // Step 3.2: Find enclosing IfStmt\
  \ and previous statement in the same CompoundStmt.\n  const IfStmt *IfS = getEnclosingIf(Condition,\
  \ C);\n  if (!IfS)\n    return;\n\n  const CompoundStmt *CS = getEnclosingCompound(IfS,\
  \ C);\n  if (!CS)\n    return;\n\n  const Stmt *PrevS = nullptr;\n  for (const Stmt\
  \ *Child : CS->body()) {\n    if (Child == IfS)\n      break;\n    PrevS = Child;\n\
  \  }\n  if (!PrevS)\n    return;\n\n  // Step 3.3: Check if previous statement is\
  \ an assignment from an allocator call.\n  const BinaryOperator *Assign = dyn_cast<BinaryOperator>(PrevS);\n\
  \  if (!Assign || Assign->getOpcode() != BO_Assign)\n    return;\n\n  const Expr\
  \ *LHSRaw = Assign->getLHS();\n  const Expr *RHSRaw = Assign->getRHS();\n  if (!LHSRaw\
  \ || !RHSRaw)\n    return;\n\n  const CallExpr *AllocCE = dyn_cast<CallExpr>(RHSRaw->IgnoreParenImpCasts());\n\
  \  if (!AllocCE)\n    return;\n  if (!isKernelAllocator(AllocCE, C))\n    return;\n\
  \n  // Step 3.4: Compare allocated target and checked pointer.\n  const MemRegion\
  \ *AllocReg = getMemRegionFromExpr(LHSRaw, C);\n  const MemRegion *CheckReg = getMemRegionFromExpr(CheckedPtrExpr,\
  \ C);\n  if (AllocReg)\n    AllocReg = AllocReg->getBaseRegion();\n  if (CheckReg)\n\
  \    CheckReg = CheckReg->getBaseRegion();\n\n  bool SameRegion = (AllocReg && CheckReg\
  \ && AllocReg == CheckReg);\n\n  // If regions are equal, it's fine.\n  if (SameRegion)\n\
  \    return;\n\n  // Optional heuristic: if both are member expressions but their\
  \ base objects differ, be conservative and bail out.\n  const Expr *LHSNoCasts =\
  \ LHSRaw->IgnoreParenImpCasts();\n  const Expr *ChkNoCasts = CheckedPtrExpr->IgnoreParenImpCasts();\n\
  \  if (const auto *LME = dyn_cast<MemberExpr>(LHSNoCasts)) {\n    if (const auto\
  \ *RME = dyn_cast<MemberExpr>(ChkNoCasts)) {\n      const Expr *LBase = LME->getBase();\n\
  \      const Expr *RBase = RME->getBase();\n      if (LBase && RBase) {\n      \
  \  const MemRegion *LBReg = getMemRegionFromExpr(LBase, C);\n        const MemRegion\
  \ *RBReg = getMemRegionFromExpr(RBase, C);\n        if (LBReg) LBReg = LBReg->getBaseRegion();\n\
  \        if (RBReg) RBReg = RBReg->getBaseRegion();\n        if (LBReg && RBReg\
  \ && LBReg != RBReg) {\n          // Different base objects - likely unrelated,\
  \ avoid reporting.\n          return;\n        }\n      }\n    }\n  }\n\n  // Fallback\
  \ text equality check to avoid false positives if regions are unavailable.\n  if\
  \ (!SameRegion) {\n    StringRef LHSText = getExprText(LHSRaw, C);\n    StringRef\
  \ ChkText = getExprText(CheckedPtrExpr, C);\n    if (!LHSText.empty() && !ChkText.empty()\
  \ && LHSText == ChkText) {\n      // Same text implies same pointer; do not report.\n\
  \      return;\n    }\n  }\n\n  // Step 3.5: Heuristic: ensure this is an OOM check\
  \ site (returning -ENOMEM)\n  const Stmt *ThenS = IfS->getThen();\n  if (!returnsENOMEM(ThenS,\
  \ C))\n    return;\n\n  // Step 3.6: Report the bug.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Wrong pointer checked after allocation; should check the allocated\
  \ pointer\", N);\n\n  // Highlight the condition and the allocation call site\n\
  \  R->addRange(Condition->getSourceRange());\n  R->addRange(AllocCE->getSourceRange());\n\
  \n  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"\
  C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects checking the wrong pointer\
  \ for NULL immediately after allocation\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\narm64/sme: Fix NULL check after kzalloc\n\nFix following\
  \ coccicheck error:\n./arch/arm64/kernel/process.c:322:2-23: alloc with no test,\
  \ possible model on line 326\n\nHere should be dst->thread.sve_state.\n\nFixes:\
  \ 8bd7f91c03d8 (\"arm64/sme: Implement traps and syscall handling for SME\")\nSigned-off-by:\
  \ Wan Jiabing <wanjiabing@vivo.com>\nReviwed-by: Mark Brown <broonie@kernel.org>\n\
  Link: https://lore.kernel.org/r/20220426113054.630983-1-wanjiabing@vivo.com\nSigned-off-by:\
  \ Catalin Marinas <catalin.marinas@arm.com>\n\n## Buggy Code\n\n```c\n// Function:\
  \ arch_dup_task_struct in arch/arm64/kernel/process.c\nint arch_dup_task_struct(struct\
  \ task_struct *dst, struct task_struct *src)\n{\n\tif (current->mm)\n\t\tfpsimd_preserve_current_state();\n\
  \t*dst = *src;\n\n\t/* We rely on the above assignment to initialize dst's thread_flags:\
  \ */\n\tBUILD_BUG_ON(!IS_ENABLED(CONFIG_THREAD_INFO_IN_TASK));\n\n\t/*\n\t * Detach\
  \ src's sve_state (if any) from dst so that it does not\n\t * get erroneously used\
  \ or freed prematurely.  dst's copies\n\t * will be allocated on demand later on\
  \ if dst uses SVE.\n\t * For consistency, also clear TIF_SVE here: this could be\
  \ done\n\t * later in copy_process(), but to avoid tripping up future\n\t * maintainers\
  \ it is best not to leave TIF flags and buffers in\n\t * an inconsistent state,\
  \ even temporarily.\n\t */\n\tdst->thread.sve_state = NULL;\n\tclear_tsk_thread_flag(dst,\
  \ TIF_SVE);\n\n\t/*\n\t * In the unlikely event that we create a new thread with\
  \ ZA\n\t * enabled we should retain the ZA state so duplicate it here.\n\t * This\
  \ may be shortly freed if we exec() or if CLONE_SETTLS\n\t * but it's simpler to\
  \ do it here. To avoid confusing the rest\n\t * of the code ensure that we have\
  \ a sve_state allocated\n\t * whenever za_state is allocated.\n\t */\n\tif (thread_za_enabled(&src->thread))\
  \ {\n\t\tdst->thread.sve_state = kzalloc(sve_state_size(src),\n\t\t\t\t\t\tGFP_KERNEL);\n\
  \t\tif (!dst->thread.za_state)\n\t\t\treturn -ENOMEM;\n\t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n\t\t\t\t\t       za_state_size(src),\n\t\t\t\t\
  \t       GFP_KERNEL);\n\t\tif (!dst->thread.za_state) {\n\t\t\tkfree(dst->thread.sve_state);\n\
  \t\t\tdst->thread.sve_state = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\
  \tdst->thread.za_state = NULL;\n\t\tclear_tsk_thread_flag(dst, TIF_SME);\n\t}\n\n\
  \t/* clear any pending asynchronous tag fault raised by the parent */\n\tclear_tsk_thread_flag(dst,\
  \ TIF_MTE_ASYNC_FAULT);\n\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c\nindex 99c293513817..9734c9fb1a32\
  \ 100644\n--- a/arch/arm64/kernel/process.c\n+++ b/arch/arm64/kernel/process.c\n\
  @@ -321,7 +321,7 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct\
  \ *src)\n \tif (thread_za_enabled(&src->thread)) {\n \t\tdst->thread.sve_state =\
  \ kzalloc(sve_state_size(src),\n \t\t\t\t\t\tGFP_KERNEL);\n-\t\tif (!dst->thread.za_state)\n\
  +\t\tif (!dst->thread.sve_state)\n \t\t\treturn -ENOMEM;\n \t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n \t\t\t\t\t       za_state_size(src),\n```\n"
pattern: "## Bug Pattern\n\nChecking the wrong pointer for NULL after allocating memory.\n\
  \nPattern:\nptrA = kzalloc(size, GFP_KERNEL);\nif (!ptrB)   // BUG: should check\
  \ ptrA\n    return -ENOMEM;\n\nIn the patch, memory is allocated for dst->thread.sve_state,\
  \ but the code erroneously checks dst->thread.za_state instead. This can both miss\
  \ allocation failures of sve_state and incorrectly report errors based on an unrelated\
  \ pointer, leading to inconsistent state or later NULL dereferences."
plan: "Plan: Detect wrong pointer checked for NULL immediately after allocation\n\n\
  1) Program state\n- No custom program state is needed. We will pattern-match in\
  \ the AST around an if-condition and its immediately preceding statement.\n\n2)\
  \ Callbacks\n- Use only checkBranchCondition. This allows us to:\n  - Read the expression\
  \ being checked in an if-condition.\n  - Find the surrounding IfStmt.\n  - Locate\
  \ the immediately previous statement in the same CompoundStmt.\n  - Verify it is\
  \ an assignment from a kzalloc-like allocator.\n  - Compare the checked pointer\
  \ with the allocation target.\n  - Optionally confirm error-return behavior (eg,\
  \ returning -ENOMEM) to reduce false positives.\n\n3) Detailed steps for checkBranchCondition\n\
  - Step 3.1: Extract the pointer being NULL-checked from the condition.\n  - Implement\
  \ a local helper getCheckedPtrExpr(const Stmt *Condition):\n    - Normalize the\
  \ condition by ignoring implicit casts (IgnoreImpCasts).\n    - Handle patterns:\n\
  \      - UnaryOperator: if (UO_LNot) return inner expr if it has pointer type.\n\
  \      - BinaryOperator: if (BO_EQ or BO_NE), and one side is null (IntegerLiteral\
  \ 0, GNUNullExpr, CXXNullPtrLiteralExpr), return the non-null side if it has pointer\
  \ type.\n      - Direct pointer-as-condition: if (E) where E is a pointer expression\
  \ (after IgnoreImpCasts), return E.\n    - Return nullptr if not a standard NULL-check\
  \ form.\n  - If getCheckedPtrExpr returns nullptr, exit.\n\n- Step 3.2: Find the\
  \ enclosing IfStmt and the immediately previous statement.\n  - Use findSpecificTypeInParents<IfStmt>(Condition,\
  \ C) to get the IfStmt If.\n  - Use findSpecificTypeInParents<CompoundStmt>(If,\
  \ C) to get the surrounding CompoundStmt CS.\n  - Iterate CS->body() to locate If;\
  \ track the previous statement PrevS (must be directly adjacent to If).\n  - If\
  \ no previous statement found (or If is first in the block), exit.\n\n- Step 3.3:\
  \ Check if the previous statement is an assignment from an allocation call.\n  -\
  \ If PrevS is not a BinaryOperator with opcode BO_Assign, exit.\n  - Let LHS = Assign->getLHS()->IgnoreImpCasts(),\
  \ RHS = Assign->getRHS()->IgnoreImpCasts().\n  - Ensure RHS is a CallExpr CE; otherwise\
  \ exit.\n  - Implement a local helper isKernelAllocator(const CallExpr *CE) that\
  \ matches callee names:\n    - Return true for: \"kzalloc\", \"kmalloc\", \"kcalloc\"\
  , \"kvzalloc\", \"vzalloc\", \"devm_kzalloc\" (include common zeroing allocators;\
  \ kzalloc is necessary for the target bug).\n  - If not an allocator call, exit.\n\
  \n- Step 3.4: Compare the allocation target with the checked pointer.\n  - Let CheckedE\
  \ = getCheckedPtrExpr(Condition).\n  - Compute regions:\n    - RegionAlloc = getMemRegionFromExpr(LHS,\
  \ C).\n    - RegionChecked = getMemRegionFromExpr(CheckedE, C).\n  - If either region\
  \ is null (symbolic region not available), fall back to a conservative text comparison:\n\
  \    - Extract source text of LHS and CheckedE via ExprHasName or Lexer::getSourceText\
  \ and compare string equality. If equal, consider it correct, else continue.\n \
  \ - If RegionAlloc equals RegionChecked, it\u2019s a correct check; exit.\n  - Optional\
  \ false-positive mitigation:\n    - If both LHS and CheckedE are MemberExpr, check\
  \ they share the same base region (get base expr of each, compare getMemRegionFromExpr\
  \ on bases). If they don\u2019t share a base and you want to be conservative, exit.\
  \ This keeps the checker focused on patterns like dst->thread.sve_state vs dst->thread.za_state.\n\
  \n- Step 3.5: Heuristics to ensure it\u2019s an out-of-memory error check site (to\
  \ reduce noise).\n  - Inspect the IfStmt\u2019s then-branch:\n    - Find a ReturnStmt\
  \ inside the then-branch: use findSpecificTypeInChildren<ReturnStmt>(If->getThen()).\n\
  \    - If a ReturnStmt exists, check its expression:\n      - If ExprHasName(ReturnExpr,\
  \ \"ENOMEM\", C) is true, proceed to report.\n      - Otherwise, if EvaluateExprToInt\
  \ returns a negative value, proceed to report.\n    - If no return is found, you\
  \ can optionally look for a goto to an error label, but to keep it simple, require\
  \ the return heuristic above.\n\n- Step 3.6: Report the bug.\n  - Create a BugType\
  \ once (for example in the checker constructor or lazily) named \"Wrong NULL check\
  \ after allocation\".\n  - Build an error node with generateNonFatalErrorNode and\
  \ emit:\n    - PathSensitiveBugReport with a short message like: \"Wrong pointer\
  \ checked after allocation; should check the allocated pointer.\"\n    - Highlight\
  \ the condition range (Condition->getSourceRange()).\n    - Optionally add a note\
  \ pointing to the allocation site (PrevS) like \"Allocated here\" by adding a range\
  \ of the RHS call expression.\n  - Do not suppress the path; this is a correctness\
  \ issue.\n\n4) Helper functions to implement in the checker (minimal, local)\n-\
  \ getCheckedPtrExpr(const Stmt *Condition): as described in Step 3.1.\n- isNullExpr(const\
  \ Expr *E): checks for 0 literal or a null literal expression kinds.\n- isKernelAllocator(const\
  \ CallExpr *CE): match function callee names listed in Step 3.3.\n- returnsENOMEM(const\
  \ Stmt *S, CheckerContext &C): find ReturnStmt in S and check for \"ENOMEM\" with\
  \ ExprHasName or a negative integral literal with EvaluateExprToInt.\n\n5) Notes\
  \ and guardrails\n- Scope: Only warn when the if-condition is immediately after\
  \ the allocation assignment within the same CompoundStmt. This mirrors the targeted\
  \ bug shape and keeps false positives low.\n- Expressions: Support both DeclRefExpr\
  \ and MemberExpr on LHS/condition. Compare MemRegions when possible; fallback to\
  \ textual comparison if regions are not available.\n- Allocators: The core pattern\
  \ is kzalloc; include a small set of similar allocators to be robust, but require\
  \ the error-return heuristic (ENOMEM/negative) to fire the diagnostic.\n- No pointer\
  \ alias tracking is necessary for this pattern; the detection focuses on adjacency\
  \ and mismatched expressions."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"clang/AST/ASTContext.h\"\n#include\
  \ \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// No custom program state required.\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<check::BranchCondition>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Wrong NULL check after allocation\", \"Memory Management\"\
  )) {}\n\n      void checkBranchCondition(const Stmt *Condition, CheckerContext &C)\
  \ const;\n\n   private:\n      // Helpers\n      const Expr *getCheckedPtrExprRaw(const\
  \ Stmt *Condition, CheckerContext &C) const;\n      bool isNullExpr(const Expr *E,\
  \ CheckerContext &C) const;\n      bool isKernelAllocator(const CallExpr *CE, CheckerContext\
  \ &C) const;\n      bool returnsENOMEM(const Stmt *S, CheckerContext &C) const;\n\
  \      StringRef getExprText(const Expr *E, CheckerContext &C) const;\n};\n\nstatic\
  \ const CompoundStmt *getEnclosingCompound(const Stmt *S, CheckerContext &C) {\n\
  \  return findSpecificTypeInParents<CompoundStmt>(S, C);\n}\n\nstatic const IfStmt\
  \ *getEnclosingIf(const Stmt *S, CheckerContext &C) {\n  return findSpecificTypeInParents<IfStmt>(S,\
  \ C);\n}\n\nStringRef SAGenTestChecker::getExprText(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E)\n    return StringRef();\n  const SourceManager &SM = C.getSourceManager();\n\
  \  const LangOptions &LangOpts = C.getLangOpts();\n  CharSourceRange Range = CharSourceRange::getTokenRange(E->getSourceRange());\n\
  \  return Lexer::getSourceText(Range, SM, LangOpts);\n}\n\nbool SAGenTestChecker::isNullExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n  return E->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull);\n}\n\nbool SAGenTestChecker::isKernelAllocator(const\
  \ CallExpr *CE, CheckerContext &C) const {\n  if (!CE)\n    return false;\n  //\
  \ Use source-text based matching for robustness in the absence of direct callee.\n\
  \  const Expr *E = CE;\n  return ExprHasName(E, \"kzalloc\", C) ||\n         ExprHasName(E,\
  \ \"kmalloc\", C) ||\n         ExprHasName(E, \"kcalloc\", C) ||\n         ExprHasName(E,\
  \ \"kvzalloc\", C) ||\n         ExprHasName(E, \"vzalloc\", C) ||\n         ExprHasName(E,\
  \ \"devm_kzalloc\", C);\n}\n\nbool SAGenTestChecker::returnsENOMEM(const Stmt *S,\
  \ CheckerContext &C) const {\n  if (!S)\n    return false;\n\n  // Find a ReturnStmt\
  \ inside S (only one is needed to confirm).\n  const ReturnStmt *RS = findSpecificTypeInChildren<ReturnStmt>(S);\n\
  \  if (!RS)\n    return false;\n\n  const Expr *RetE = RS->getRetValue();\n  if\
  \ (!RetE)\n    return false;\n\n  // If the return expression mentions ENOMEM, accept.\n\
  \  if (ExprHasName(RetE, \"ENOMEM\", C))\n    return true;\n\n  // If it is a constant\
  \ negative integer (e.g., -12), accept.\n  llvm::APSInt Val;\n  if (EvaluateExprToInt(Val,\
  \ RetE, C)) {\n    if (Val.isSigned() ? Val.isNegative() : Val == 0) {\n      //\
  \ If unsigned, can't be negative; otherwise check negativity.\n      if (Val.isSigned()\
  \ && Val.isNegative())\n        return true;\n    }\n  }\n  return false;\n}\n\n\
  const Expr *SAGenTestChecker::getCheckedPtrExprRaw(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!Condition)\n    return nullptr;\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n\
  \  if (!CondE)\n    return nullptr;\n\n  // Analyze the structure while keeping\
  \ access to raw sub-expressions\n  const Expr *Stripped = CondE->IgnoreParenImpCasts();\n\
  \n  // if (!ptr)\n  if (const auto *UO = dyn_cast<UnaryOperator>(Stripped)) {\n\
  \    if (UO->getOpcode() == UO_LNot) {\n      const Expr *InnerRaw = UO->getSubExpr();\
  \ // Raw subexpr for region extraction\n      if (InnerRaw && InnerRaw->getType()->isPointerType())\n\
  \        return InnerRaw;\n    }\n  }\n\n  // if (ptr == NULL) or if (ptr != NULL)\n\
  \  if (const auto *BO = dyn_cast<BinaryOperator>(Stripped)) {\n    if (BO->getOpcode()\
  \ == BO_EQ || BO->getOpcode() == BO_NE) {\n      const Expr *LHSRaw = BO->getLHS();\n\
  \      const Expr *RHSRaw = BO->getRHS();\n      if (!LHSRaw || !RHSRaw)\n     \
  \   return nullptr;\n\n      const Expr *LHS = LHSRaw->IgnoreParenImpCasts();\n\
  \      const Expr *RHS = RHSRaw->IgnoreParenImpCasts();\n\n      bool LHSIsNull\
  \ = isNullExpr(LHS, C);\n      bool RHSIsNull = isNullExpr(RHS, C);\n\n      if\
  \ (LHSIsNull && !RHSIsNull && RHSRaw->getType()->isPointerType())\n        return\
  \ RHSRaw;\n      if (RHSIsNull && !LHSIsNull && LHSRaw->getType()->isPointerType())\n\
  \        return LHSRaw;\n    }\n  }\n\n  // if (ptr)\n  if (Stripped->getType()->isPointerType())\n\
  \    return CondE; // raw condition expr\n\n  return nullptr;\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  // Step 3.1: Extract the pointer\
  \ expression being NULL-checked.\n  const Expr *CheckedPtrExpr = getCheckedPtrExprRaw(Condition,\
  \ C);\n  if (!CheckedPtrExpr)\n    return;\n\n  // Step 3.2: Find enclosing IfStmt\
  \ and previous statement in the same CompoundStmt.\n  const IfStmt *IfS = getEnclosingIf(Condition,\
  \ C);\n  if (!IfS)\n    return;\n\n  const CompoundStmt *CS = getEnclosingCompound(IfS,\
  \ C);\n  if (!CS)\n    return;\n\n  const Stmt *PrevS = nullptr;\n  for (const Stmt\
  \ *Child : CS->body()) {\n    if (Child == IfS)\n      break;\n    PrevS = Child;\n\
  \  }\n  if (!PrevS)\n    return;\n\n  // Step 3.3: Check if previous statement is\
  \ an assignment from an allocator call.\n  const BinaryOperator *Assign = dyn_cast<BinaryOperator>(PrevS);\n\
  \  if (!Assign || Assign->getOpcode() != BO_Assign)\n    return;\n\n  const Expr\
  \ *LHSRaw = Assign->getLHS();\n  const Expr *RHSRaw = Assign->getRHS();\n  if (!LHSRaw\
  \ || !RHSRaw)\n    return;\n\n  const CallExpr *AllocCE = dyn_cast<CallExpr>(RHSRaw->IgnoreParenImpCasts());\n\
  \  if (!AllocCE)\n    return;\n  if (!isKernelAllocator(AllocCE, C))\n    return;\n\
  \n  // Step 3.4: Compare allocated target and checked pointer.\n  const MemRegion\
  \ *AllocReg = getMemRegionFromExpr(LHSRaw, C);\n  const MemRegion *CheckReg = getMemRegionFromExpr(CheckedPtrExpr,\
  \ C);\n  if (AllocReg)\n    AllocReg = AllocReg->getBaseRegion();\n  if (CheckReg)\n\
  \    CheckReg = CheckReg->getBaseRegion();\n\n  bool SameRegion = (AllocReg && CheckReg\
  \ && AllocReg == CheckReg);\n\n  // If regions are equal, it's fine.\n  if (SameRegion)\n\
  \    return;\n\n  // Optional heuristic: if both are member expressions but their\
  \ base objects differ, be conservative and bail out.\n  const Expr *LHSNoCasts =\
  \ LHSRaw->IgnoreParenImpCasts();\n  const Expr *ChkNoCasts = CheckedPtrExpr->IgnoreParenImpCasts();\n\
  \  if (const auto *LME = dyn_cast<MemberExpr>(LHSNoCasts)) {\n    if (const auto\
  \ *RME = dyn_cast<MemberExpr>(ChkNoCasts)) {\n      const Expr *LBase = LME->getBase();\n\
  \      const Expr *RBase = RME->getBase();\n      if (LBase && RBase) {\n      \
  \  const MemRegion *LBReg = getMemRegionFromExpr(LBase, C);\n        const MemRegion\
  \ *RBReg = getMemRegionFromExpr(RBase, C);\n        if (LBReg) LBReg = LBReg->getBaseRegion();\n\
  \        if (RBReg) RBReg = RBReg->getBaseRegion();\n        if (LBReg && RBReg\
  \ && LBReg != RBReg) {\n          // Different base objects - likely unrelated,\
  \ avoid reporting.\n          return;\n        }\n      }\n    }\n  }\n\n  // Fallback\
  \ text equality check to avoid false positives if regions are unavailable.\n  if\
  \ (!SameRegion) {\n    StringRef LHSText = getExprText(LHSRaw, C);\n    StringRef\
  \ ChkText = getExprText(CheckedPtrExpr, C);\n    if (!LHSText.empty() && !ChkText.empty()\
  \ && LHSText == ChkText) {\n      // Same text implies same pointer; do not report.\n\
  \      return;\n    }\n  }\n\n  // Step 3.5: Heuristic: ensure this is an OOM check\
  \ site (returning -ENOMEM)\n  const Stmt *ThenS = IfS->getThen();\n  if (!returnsENOMEM(ThenS,\
  \ C))\n    return;\n\n  // Step 3.6: Report the bug.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Wrong pointer checked after allocation; should check the allocated\
  \ pointer\", N);\n\n  // Highlight the condition and the allocation call site\n\
  \  R->addRange(Condition->getSourceRange());\n  R->addRange(AllocCE->getSourceRange());\n\
  \n  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"\
  C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects checking the wrong pointer\
  \ for NULL immediately after allocation\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
