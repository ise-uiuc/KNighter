_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: ac19c4c3d02e19b365209d2cee409671e1fb66bb
commit_type: Misuse
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states are required for this checker.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  public:\n  SAGenTestChecker()\n      : BT(new BugType(this,\n                  \
  \     \"Open-coded size multiplication may overflow\",\n                       \"\
  Integer Overflow\")) {}\n\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\nprivate:\n  // Return true if this is a target function, and set\
  \ SizeIdx to the size arg.\n  bool isTargetFunction(const CallEvent &Call, CheckerContext\
  \ &C,\n                        unsigned &SizeIdx) const;\n\n  // Return true if\
  \ E is a sizeof(...) expression.\n  static bool isSizeofExpr(const Expr *E);\n\n\
  \  // Report a concise diagnostic on SizeE.\n  void report(const Expr *SizeE, CheckerContext\
  \ &C) const;\n};\n\n// Determine if the call is to copy_from_user or copy_to_user\
  \ and set size index.\nbool SAGenTestChecker::isTargetFunction(const CallEvent &Call,\n\
  \                                        CheckerContext &C,\n                  \
  \                      unsigned &SizeIdx) const {\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE)\n    return false;\n\n  // Use text-based matching as suggested.\n \
  \ if (ExprHasName(OE, \"copy_from_user\", C) || ExprHasName(OE, \"copy_to_user\"\
  , C)) {\n    // Signature: (dst, src, n) -> size index = 2\n    if (Call.getNumArgs()\
  \ > 2) {\n      SizeIdx = 2;\n      return true;\n    }\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isSizeofExpr(const Expr *E) {\n  E = E ? E->IgnoreParenImpCasts()\
  \ : nullptr;\n  if (!E)\n    return false;\n  if (const auto *U = dyn_cast<UnaryExprOrTypeTraitExpr>(E))\
  \ {\n    return U->getKind() == UETT_SizeOf;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::report(const\
  \ Expr *SizeE, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Size is computed as sizeof(x) * count; use array_size() to avoid overflow\"\
  , N);\n  if (SizeE)\n    R->addRange(SizeE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  unsigned SizeIdx = 0;\n  if (!isTargetFunction(Call, C, SizeIdx))\n\
  \    return;\n\n  if (SizeIdx >= Call.getNumArgs())\n    return;\n\n  const Expr\
  \ *SizeE = Call.getArgExpr(SizeIdx);\n  if (!SizeE)\n    return;\n\n  // If already\
  \ using safe helpers, skip.\n  if (ExprHasName(SizeE, \"array_size\", C) || ExprHasName(SizeE,\
  \ \"struct_size\", C))\n    return;\n\n  const Expr *E = SizeE->IgnoreParenImpCasts();\n\
  \  const auto *BO = dyn_cast<BinaryOperator>(E);\n  if (!BO || BO->getOpcode() !=\
  \ BO_Mul)\n    return;\n\n  const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \  const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n\n  bool LIsSizeof = isSizeofExpr(L);\n\
  \  bool RIsSizeof = isSizeofExpr(R);\n\n  // We care about exactly one side being\
  \ sizeof(...)\n  if (LIsSizeof == RIsSizeof)\n    return;\n\n  const Expr *CountExpr\
  \ = LIsSizeof ? R : L;\n  if (!CountExpr)\n    return;\n\n  // If count is a compile-time\
  \ constant, skip (low risk).\n  llvm::APSInt Dummy;\n  if (EvaluateExprToInt(Dummy,\
  \ CountExpr, C))\n    return;\n\n  // Otherwise, this matches the open-coded sizeof\
  \ * count pattern.\n  report(SizeE, C);\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects open-coded sizeof(x) * count\
  \ in size arguments; suggests array_size()\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbcachefs: Use array_size() in call to copy_from_user()\n\
  \nUse array_size() helper, instead of the open-coded version in\ncall to copy_from_user().\n\
  \nSigned-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>\nSigned-off-by: Kent\
  \ Overstreet <kent.overstreet@linux.dev>\n\n## Buggy Code\n\n```c\n// Function:\
  \ bch2_ioctl_fsck_offline in fs/bcachefs/chardev.c\nstatic long bch2_ioctl_fsck_offline(struct\
  \ bch_ioctl_fsck_offline __user *user_arg)\n{\n\tstruct bch_ioctl_fsck_offline arg;\n\
  \tstruct fsck_thread *thr = NULL;\n\tu64 *devs = NULL;\n\tlong ret = 0;\n\n\tif\
  \ (copy_from_user(&arg, user_arg, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\tif (arg.flags)\n\
  \t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t\
  if (!(devs = kcalloc(arg.nr_devs, sizeof(*devs), GFP_KERNEL)) ||\n\t    !(thr =\
  \ kzalloc(sizeof(*thr), GFP_KERNEL)) ||\n\t    !(thr->devs = kcalloc(arg.nr_devs,\
  \ sizeof(*thr->devs), GFP_KERNEL))) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\
  \tthr->opts = bch2_opts_empty();\n\tthr->nr_devs = arg.nr_devs;\n\tthr->output.buf\t\
  = PRINTBUF;\n\tthr->output.buf.atomic++;\n\tspin_lock_init(&thr->output.lock);\n\
  \tinit_waitqueue_head(&thr->output.wait);\n\tdarray_init(&thr->output2);\n\n\tif\
  \ (copy_from_user(devs, &user_arg->devs[0], sizeof(user_arg->devs[0]) * arg.nr_devs))\
  \ {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tfor (size_t i = 0; i < arg.nr_devs;\
  \ i++) {\n\t\tthr->devs[i] = strndup_user((char __user *)(unsigned long) devs[i],\
  \ PATH_MAX);\n\t\tret = PTR_ERR_OR_ZERO(thr->devs[i]);\n\t\tif (ret)\n\t\t\tgoto\
  \ err;\n\t}\n\n\tif (arg.opts) {\n\t\tchar *optstr = strndup_user((char __user *)(unsigned\
  \ long) arg.opts, 1 << 16);\n\n\t\tret =   PTR_ERR_OR_ZERO(optstr) ?:\n\t\t\tbch2_parse_mount_opts(NULL,\
  \ &thr->opts, optstr);\n\t\tkfree(optstr);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\t\
  }\n\n\topt_set(thr->opts, log_output, (u64)(unsigned long)&thr->output);\n\n\tret\
  \ = run_thread_with_file(&thr->thr,\n\t\t\t\t   &fsck_thread_ops,\n\t\t\t\t   bch2_fsck_offline_thread_fn,\n\
  \t\t\t\t   \"bch-fsck\");\nerr:\n\tif (ret < 0) {\n\t\tif (thr)\n\t\t\tbch2_fsck_thread_free(thr);\n\
  \t\tpr_err(\"ret %s\", bch2_err_str(ret));\n\t}\n\tkfree(devs);\n\treturn ret;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/fs/bcachefs/chardev.c b/fs/bcachefs/chardev.c\n\
  index 08922f7e380a..295b1f4e9ece 100644\n--- a/fs/bcachefs/chardev.c\n+++ b/fs/bcachefs/chardev.c\n\
  @@ -360,7 +360,8 @@ static long bch2_ioctl_fsck_offline(struct bch_ioctl_fsck_offline\
  \ __user *user_a\n \tinit_waitqueue_head(&thr->output.wait);\n \tdarray_init(&thr->output2);\n\
  \ \n-\tif (copy_from_user(devs, &user_arg->devs[0], sizeof(user_arg->devs[0]) *\
  \ arg.nr_devs)) {\n+\tif (copy_from_user(devs, &user_arg->devs[0],\n+\t\t\t   array_size(sizeof(user_arg->devs[0]),\
  \ arg.nr_devs))) {\n \t\tret = -EINVAL;\n \t\tgoto err;\n \t}\n```\n"
pattern: '## Bug Pattern


  Manually computing the byte count for a memory operation as sizeof(element) * count
  where count can come from userspace, without overflow checking. This open-coded
  multiplication can overflow size_t and wrap around, causing copy_from_user (or similar
  APIs) to operate on an incorrect size. The correct pattern is to use overflow-checked
  helpers like array_size(element_size, count) (or struct_size) for size calculations
  passed to copy/alloc functions.'
plan: "1) Program state\n- No custom program state is required for the minimal, robust\
  \ version of this checker. We only need to inspect call expressions and the shape\
  \ of their size argument.\n- Optional refinement (not required): A lightweight \u201C\
  from user\u201D taint to further reduce false positives:\n  - REGISTER_SET_WITH_PROGRAMSTATE(UserTaintedRegions,\
  \ const MemRegion *)\n  - In checkPostCall of copy_from_user, mark the destination\
  \ region as tainted.\n  - In checkBind, propagate taint from RHS to LHS for simple\
  \ assignments.\n  - In checkPreCall (when checking the multiplication), prefer to\
  \ warn only if the \u201Ccount\u201D expression resolves to a region in UserTaintedRegions\
  \ or to a symbol derived from it.\n  - This is an optional step, keep the core checker\
  \ simple.\n\n2) Callbacks and implementation details\n\nA. checkPreCall\n- Goal:\
  \ Flag calls where a size argument is computed as sizeof(element) * count (open-coded\
  \ multiplication) instead of using overflow-safe helpers like array_size() or struct_size().\n\
  - Steps:\n  1) Identify target functions and the index of their size parameter:\n\
  \     - copy_from_user(dst, src, n) => size index 2 (0-based).\n     - copy_to_user(dst,\
  \ src, n) => size index 2 (0-based).\n     - (Optional: extendable list via a small\
  \ table of {FunctionName, SizeParamIndex}.)\n  2) If callee matches one of the above,\
  \ get the size argument expression: const Expr *SizeE = Call.getArgExpr(SizeIdx).\n\
  \     - Ignore implicit casts and parentheses: E = SizeE->IgnoreParenImpCasts().\n\
  \     - As a quick guard, if ExprHasName(SizeE, \"array_size\", C) or ExprHasName(SizeE,\
  \ \"struct_size\", C), return (already safe).\n  3) Detect the open-coded multiplication:\n\
  \     - If E is a BinaryOperator with opcode == BO_Mul:\n       - Let L = LHS->IgnoreParenImpCasts(),\
  \ R = RHS->IgnoreParenImpCasts().\n       - Define helper isSizeofExpr(const Expr\
  \ *X): returns true if dyn_cast<UnaryExprOrTypeTraitExpr>(X) with getKind()==UETT_SizeOf.\n\
  \       - If !(isSizeofExpr(L) XOR isSizeofExpr(R)): return (we care only about\
  \ exactly one side being sizeof; both sides being sizeof is unusual and not our\
  \ target).\n       - Let CountExpr be the non-sizeof side.\n       - If EvaluateExprToInt(EvalRes,\
  \ CountExpr, C) succeeds, return (constant count; very low risk of overflow).\n\
  \       - (Optional refinement if you implemented taint:) If getMemRegionFromExpr(CountExpr,\
  \ C) is not in UserTaintedRegions and the symbol max value can be inferred as small\
  \ via inferSymbolMaxVal (e.g., maxVal <= 4096), consider skipping to reduce noise.\n\
  \  4) Report:\n     - Create a BugType once (e.g., \"Open-coded size multiplication\
  \ may overflow\").\n     - Generate a non-fatal error node.\n     - Emit a concise\
  \ message like: \"Size is computed as sizeof(x) * count; use array_size() to avoid\
  \ overflow.\"\n     - Point the report to SizeE\u2019s source range.\n\nB. (Optional)\
  \ checkPostCall (for optional taint, not required for minimal checker)\n- Goal:\
  \ Mark memory written by copy_from_user as \u201Cfrom user\u201D.\n- Steps:\n  1)\
  \ If the callee is copy_from_user:\n     - Get the destination pointer expression\
  \ (arg 0). Obtain its MemRegion via getMemRegionFromExpr().\n     - Insert that\
  \ MemRegion into UserTaintedRegions.\n\nC. (Optional) checkBind (for optional taint\
  \ propagation)\n- Goal: Propagate \u201Cfrom user\u201D taint through simple assignments\
  \ that bind values to variables used later as counts.\n- Steps:\n  1) When binding\
  \ Loc = Val:\n     - If Val is an SVal associated with a region in UserTaintedRegions\
  \ (or a symbol derived from one), and Loc resolves to a MemRegion, add that region\
  \ into UserTaintedRegions.\n     - Keep propagation simple; do not attempt deep\
  \ expression tracking\u2014just direct assignments.\n\n3) Helper utilities to use\n\
  - EvaluateExprToInt: to skip cases where count is a compile-time constant (lower\
  \ false positives).\n- ExprHasName: to early-exit if the code already uses array_size()\
  \ / struct_size().\n- getMemRegionFromExpr: needed if you implement the optional\
  \ taint refinement.\n- findSpecificTypeInChildren/Parents: not required for the\
  \ minimal version.\n\n4) Notes and heuristics\n- Keep the initial scope narrow:\
  \ only copy_from_user and copy_to_user with size arg at index 2. This already covers\
  \ the provided patch pattern.\n- Multiplication shape to detect: sizeof(...) * Expr\
  \ or Expr * sizeof(...).\n- Skip if CountExpr is constant-evaluable.\n- Do not warn\
  \ if array_size() or struct_size() is already used.\n- Message should be short and\
  \ clear:\n  - \"Size is computed as sizeof(x) * count; use array_size() to avoid\
  \ overflow.\"\n\n5) Summary flow\n- checkPreCall:\n  - Match function and size arg\
  \ index.\n  - If size arg is a multiplication with exactly one sizeof operand and\
  \ the other operand is non-constant, warn.\n- Optional: Use checkPostCall and checkBind\
  \ for a small taint system to reduce false positives by focusing on user-influenced\
  \ counts."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states are required for this checker.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  public:\n  SAGenTestChecker()\n      : BT(new BugType(this,\n                  \
  \     \"Open-coded size multiplication may overflow\",\n                       \"\
  Integer Overflow\")) {}\n\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\nprivate:\n  // Return true if this is a target function, and set\
  \ SizeIdx to the size arg.\n  bool isTargetFunction(const CallEvent &Call, CheckerContext\
  \ &C,\n                        unsigned &SizeIdx) const;\n\n  // Return true if\
  \ E is a sizeof(...) expression.\n  static bool isSizeofExpr(const Expr *E);\n\n\
  \  // Report a concise diagnostic on SizeE.\n  void report(const Expr *SizeE, CheckerContext\
  \ &C) const;\n};\n\n// Determine if the call is to copy_from_user or copy_to_user\
  \ and set size index.\nbool SAGenTestChecker::isTargetFunction(const CallEvent &Call,\n\
  \                                        CheckerContext &C,\n                  \
  \                      unsigned &SizeIdx) const {\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE)\n    return false;\n\n  // Use text-based matching as suggested.\n \
  \ if (ExprHasName(OE, \"copy_from_user\", C) || ExprHasName(OE, \"copy_to_user\"\
  , C)) {\n    // Signature: (dst, src, n) -> size index = 2\n    if (Call.getNumArgs()\
  \ > 2) {\n      SizeIdx = 2;\n      return true;\n    }\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isSizeofExpr(const Expr *E) {\n  E = E ? E->IgnoreParenImpCasts()\
  \ : nullptr;\n  if (!E)\n    return false;\n  if (const auto *U = dyn_cast<UnaryExprOrTypeTraitExpr>(E))\
  \ {\n    return U->getKind() == UETT_SizeOf;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::report(const\
  \ Expr *SizeE, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Size is computed as sizeof(x) * count; use array_size() to avoid overflow\"\
  , N);\n  if (SizeE)\n    R->addRange(SizeE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  unsigned SizeIdx = 0;\n  if (!isTargetFunction(Call, C, SizeIdx))\n\
  \    return;\n\n  if (SizeIdx >= Call.getNumArgs())\n    return;\n\n  const Expr\
  \ *SizeE = Call.getArgExpr(SizeIdx);\n  if (!SizeE)\n    return;\n\n  // If already\
  \ using safe helpers, skip.\n  if (ExprHasName(SizeE, \"array_size\", C) || ExprHasName(SizeE,\
  \ \"struct_size\", C))\n    return;\n\n  const Expr *E = SizeE->IgnoreParenImpCasts();\n\
  \  const auto *BO = dyn_cast<BinaryOperator>(E);\n  if (!BO || BO->getOpcode() !=\
  \ BO_Mul)\n    return;\n\n  const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \  const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n\n  bool LIsSizeof = isSizeofExpr(L);\n\
  \  bool RIsSizeof = isSizeofExpr(R);\n\n  // We care about exactly one side being\
  \ sizeof(...)\n  if (LIsSizeof == RIsSizeof)\n    return;\n\n  const Expr *CountExpr\
  \ = LIsSizeof ? R : L;\n  if (!CountExpr)\n    return;\n\n  // If count is a compile-time\
  \ constant, skip (low risk).\n  llvm::APSInt Dummy;\n  if (EvaluateExprToInt(Dummy,\
  \ CountExpr, C))\n    return;\n\n  // Otherwise, this matches the open-coded sizeof\
  \ * count pattern.\n  report(SizeE, C);\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects open-coded sizeof(x) * count\
  \ in size arguments; suggests array_size()\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
