_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: b58b1b883b9b702e25204dbe2b221eecc8ecd159
commit_type: Buffer-Overflow
index: 4
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(DeltaToIterMap, const MemRegion*, const\
  \ MemRegion*)\n\nnamespace {\n\nclass SAGenTestChecker\n    : public Checker<\n\
  \          check::Bind,\n          check::PostStmt<BinaryOperator>,\n          check::PostStmt<CompoundAssignOperator>>\
  \ {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n \
  \     : BT(std::make_unique<BugType>(this,\n                                   \
  \  \"iov_iter count underflow risk\",\n                                     \"Integer\"\
  )) {}\n\n  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C)\
  \ const;\n  void checkPostStmt(const BinaryOperator *BO, CheckerContext &C) const;\n\
  \  void checkPostStmt(const CompoundAssignOperator *CAO,\n                     CheckerContext\
  \ &C) const;\n\nprivate:\n  // Helpers\n  static bool isUnsignedIntegral(QualType\
  \ QT);\n  static const MemRegion *getVarRegionFromExpr(const Expr *E,\n        \
  \                                       CheckerContext &C);\n  static const MemRegion\
  \ *getIterBaseFromMemberExpr(const Expr *E,\n                                  \
  \                  CheckerContext &C);\n  static bool isIovAvailExpr(const Expr\
  \ *E, const MemRegion *&IterMR,\n                             CheckerContext &C);\n\
  \  static bool isRoundUpExpr(const Expr *E, CheckerContext &C);\n  void report(const\
  \ Stmt *S, CheckerContext &C) const;\n};\n\n/* ===================== Helper Implementations\
  \ ===================== */\n\nbool SAGenTestChecker::isUnsignedIntegral(QualType\
  \ QT) {\n  if (QT.isNull())\n    return false;\n  QT = QT.getCanonicalType();\n\
  \  return QT->isUnsignedIntegerType();\n}\n\nconst MemRegion *SAGenTestChecker::getVarRegionFromExpr(const\
  \ Expr *E,\n                                                        CheckerContext\
  \ &C) {\n  if (!E)\n    return nullptr;\n  if (isa<DeclRefExpr>(E->IgnoreParenCasts()))\
  \ {\n    const MemRegion *MR = getMemRegionFromExpr(E, C);\n    if (!MR)\n     \
  \ return nullptr;\n    return MR->getBaseRegion();\n  }\n  return nullptr;\n}\n\n\
  const MemRegion *\nSAGenTestChecker::getIterBaseFromMemberExpr(const Expr *E,\n\
  \                                            CheckerContext &C) {\n  if (!E)\n \
  \   return nullptr;\n  E = E->IgnoreParenCasts();\n  const auto *ME = dyn_cast<MemberExpr>(E);\n\
  \  if (!ME)\n    return nullptr;\n  const ValueDecl *VD = ME->getMemberDecl();\n\
  \  if (!VD)\n    return nullptr;\n  const IdentifierInfo *II = VD->getIdentifier();\n\
  \  if (!II)\n    return nullptr;\n  // We are interested in \"count\" field: iter->count\n\
  \  if (!II->isStr(\"count\"))\n    return nullptr;\n\n  const Expr *Base = ME->getBase();\n\
  \  if (!Base)\n    return nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(Base,\
  \ C);\n  if (!MR)\n    return nullptr;\n  return MR->getBaseRegion();\n}\n\nbool\
  \ SAGenTestChecker::isIovAvailExpr(const Expr *E,\n                            \
  \          const MemRegion *&IterMR,\n                                      CheckerContext\
  \ &C) {\n  IterMR = nullptr;\n  if (!E)\n    return false;\n\n  E = E->IgnoreParenCasts();\n\
  \n  // Case 1: iov_iter_count(iter)\n  if (const auto *CE = dyn_cast<CallExpr>(E))\
  \ {\n    if (ExprHasName(CE, \"iov_iter_count\", C) && CE->getNumArgs() == 1) {\n\
  \      const Expr *Arg0 = CE->getArg(0);\n      const MemRegion *MR = getMemRegionFromExpr(Arg0,\
  \ C);\n      if (!MR)\n        return false;\n      IterMR = MR->getBaseRegion();\n\
  \      return IterMR != nullptr;\n    }\n  }\n\n  // Case 2: iter->count\n  if (const\
  \ MemRegion *MR = getIterBaseFromMemberExpr(E, C)) {\n    IterMR = MR;\n    return\
  \ true;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isRoundUpExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E)\n    return false;\n  // Match common\
  \ kernel macro/function names for rounding up.\n  // Using source text via utility\
  \ to be robust to macros.\n  return ExprHasName(E, \"round_up\", C) || ExprHasName(E,\
  \ \"roundup\", C);\n}\n\nvoid SAGenTestChecker::report(const Stmt *S, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n\
  \      \"Underflow risk: avail - round_up(...) may wrap, then used to decrement\
  \ \"\n      \"iter->count. Add clamp before decrement\",\n      N);\n  if (S)\n\
  \    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n/* =====================\
  \ Core Logic ===================== */\n\nvoid SAGenTestChecker::checkBind(SVal Loc,\
  \ SVal /*Val*/, const Stmt *S,\n                                 CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *LHSReg\
  \ = Loc.getAsRegion();\n  if (!LHSReg)\n    return;\n  LHSReg = LHSReg->getBaseRegion();\n\
  \  if (!LHSReg)\n    return;\n\n  // Only record mapping for local/param variables\
  \ (not fields).\n  const auto *VR = dyn_cast<VarRegion>(LHSReg);\n  if (!VR)\n \
  \   return;\n\n  const VarDecl *VD = VR->getDecl();\n  if (!VD)\n    return;\n\n\
  \  // Prefer unsigned integral (size_t-like).\n  if (!isUnsignedIntegral(VD->getType()))\n\
  \    return;\n\n  if (!S)\n    return;\n\n  const Expr *E = dyn_cast<Expr>(S);\n\
  \  if (!E)\n    return;\n\n  E = E->IgnoreParenCasts();\n\n  // Two cases to capture\
  \ \"shorten = avail - need\" pattern:\n  // 1) Direct initializer \"size_t shorten\
  \ = avail - round_up(...);\"\n  // 2) Simple assignment \"shorten = avail - round_up(...);\"\
  \n  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {\n    if (BO->getOpcode()\
  \ == BO_Assign) {\n      const Expr *RHS = BO->getRHS();\n      if (!RHS)\n    \
  \    return;\n      RHS = RHS->IgnoreParenCasts();\n      const auto *Sub = dyn_cast<BinaryOperator>(RHS);\n\
  \      if (!Sub || Sub->getOpcode() != BO_Sub)\n        return;\n\n      const Expr\
  \ *L0 = Sub->getLHS();\n      const Expr *R0 = Sub->getRHS();\n      if (!L0 ||\
  \ !R0)\n        return;\n\n      const MemRegion *IterMR = nullptr;\n      if (isIovAvailExpr(L0,\
  \ IterMR, C) && IterMR && isRoundUpExpr(R0, C)) {\n        State = State->set<DeltaToIterMap>(LHSReg,\
  \ IterMR->getBaseRegion());\n        C.addTransition(State);\n      }\n      return;\n\
  \    } else if (BO->getOpcode() == BO_Sub) {\n      // Initializer of form \"size_t\
  \ shorten = avail - round_up(...);\"\n      const Expr *L0 = BO->getLHS();\n   \
  \   const Expr *R0 = BO->getRHS();\n      if (!L0 || !R0)\n        return;\n\n \
  \     const MemRegion *IterMR = nullptr;\n      if (isIovAvailExpr(L0, IterMR, C)\
  \ && IterMR && isRoundUpExpr(R0, C)) {\n        State = State->set<DeltaToIterMap>(LHSReg,\
  \ IterMR->getBaseRegion());\n        C.addTransition(State);\n      }\n      return;\n\
  \    }\n  }\n}\n\nvoid SAGenTestChecker::checkPostStmt(const CompoundAssignOperator\
  \ *CAO,\n                                     CheckerContext &C) const {\n  if (!CAO)\n\
  \    return;\n\n  if (CAO->getOpcode() != BO_SubAssign)\n    return;\n\n  // Match\
  \ \"iter->count -= something\"\n  const Expr *LHS = CAO->getLHS();\n  if (!LHS)\n\
  \    return;\n  const MemRegion *IterMR_LHS = getIterBaseFromMemberExpr(LHS, C);\n\
  \  if (!IterMR_LHS)\n    return;\n\n  const Expr *RHS = CAO->getRHS();\n  if (!RHS)\n\
  \    return;\n  RHS = RHS->IgnoreParenCasts();\n\n  ProgramStateRef State = C.getState();\n\
  \n  // Case A: \"iter->count -= shorten\" where shorten recorded as avail - round_up(...)\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(RHS)) {\n    const MemRegion *DeltaMR\
  \ = getVarRegionFromExpr(DRE, C);\n    if (DeltaMR) {\n      if (const MemRegion\
  \ *const *MappedIter = State->get<DeltaToIterMap>(DeltaMR)) {\n        // Ensure\
  \ the delta was computed from the same iter\n        if (*MappedIter && *MappedIter\
  \ == IterMR_LHS) {\n          report(CAO, C);\n        }\n      }\n    }\n    return;\n\
  \  }\n\n  // Case B: \"iter->count -= (avail - round_up(...))\"\n  if (const auto\
  \ *Sub = dyn_cast<BinaryOperator>(RHS)) {\n    if (Sub->getOpcode() == BO_Sub) {\n\
  \      const Expr *L0 = Sub->getLHS();\n      const Expr *R0 = Sub->getRHS();\n\
  \      const MemRegion *IterMR_RHS = nullptr;\n      if (L0 && R0 && isIovAvailExpr(L0,\
  \ IterMR_RHS, C) && IterMR_RHS &&\n          isRoundUpExpr(R0, C) && IterMR_RHS\
  \ == IterMR_LHS) {\n        report(CAO, C);\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ BinaryOperator *BO,\n                                     CheckerContext &C) const\
  \ {\n  if (!BO)\n    return;\n\n  if (BO->getOpcode() != BO_Assign)\n    return;\n\
  \n  // Match \"iter->count = iter->count - shorten\"\n  const Expr *LHS = BO->getLHS();\n\
  \  if (!LHS)\n    return;\n  const MemRegion *IterMR_LHS = getIterBaseFromMemberExpr(LHS,\
  \ C);\n  if (!IterMR_LHS)\n    return;\n\n  const Expr *RHS = BO->getRHS();\n  if\
  \ (!RHS)\n    return;\n  RHS = RHS->IgnoreParenCasts();\n\n  const auto *Sub = dyn_cast<BinaryOperator>(RHS);\n\
  \  if (!Sub || Sub->getOpcode() != BO_Sub)\n    return;\n\n  // Ensure the subtraction\
  \ is based on the same iter: \"iter->count - ...\"\n  const Expr *SubLHS = Sub->getLHS();\n\
  \  if (!SubLHS)\n    return;\n\n  bool SameIterBase = false;\n  // Either \"iter->count\
  \ - ...\" or \"iov_iter_count(iter) - ...\" referring to same iter.\n  if (const\
  \ MemRegion *IterFromMember = getIterBaseFromMemberExpr(SubLHS, C)) {\n    SameIterBase\
  \ = (IterFromMember == IterMR_LHS);\n  } else {\n    const MemRegion *IterFromAvail\
  \ = nullptr;\n    if (isIovAvailExpr(SubLHS, IterFromAvail, C) && IterFromAvail\
  \ == IterMR_LHS)\n      SameIterBase = true;\n  }\n  if (!SameIterBase)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n\n  const Expr *SubRHS = Sub->getRHS();\n\
  \  if (!SubRHS)\n    return;\n  SubRHS = SubRHS->IgnoreParenCasts();\n\n  // Case\
  \ A: \"iter->count = iter->count - shorten\"\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(SubRHS))\
  \ {\n    const MemRegion *DeltaMR = getVarRegionFromExpr(DRE, C);\n    if (DeltaMR)\
  \ {\n      if (const MemRegion *const *MappedIter = State->get<DeltaToIterMap>(DeltaMR))\
  \ {\n        if (*MappedIter && *MappedIter == IterMR_LHS) {\n          report(BO,\
  \ C);\n        }\n      }\n    }\n    return;\n  }\n\n  // Case B: \"iter->count\
  \ = iter->count - (avail - round_up(...))\"\n  if (const auto *InnerSub = dyn_cast<BinaryOperator>(SubRHS))\
  \ {\n    if (InnerSub->getOpcode() == BO_Sub) {\n      const Expr *L0 = InnerSub->getLHS();\n\
  \      const Expr *R0 = InnerSub->getRHS();\n      const MemRegion *IterMR_RHS =\
  \ nullptr;\n      if (L0 && R0 && isIovAvailExpr(L0, IterMR_RHS, C) && IterMR_RHS\
  \ &&\n          isRoundUpExpr(R0, C) && IterMR_RHS == IterMR_LHS) {\n        report(BO,\
  \ C);\n      }\n    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects iov_iter count underflow due\
  \ to subtracting round_up(...) \"\n      \"without clamping against available length\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbcachefs: fix iov_iter count underflow on sub-block\
  \ dio read\n\nbch2_direct_IO_read() checks the request offset and size for sector\n\
  alignment and then falls through to a couple calculations to shrink\nthe size of\
  \ the request based on the inode size. The problem is that\nthese checks round up\
  \ to the fs block size, which runs the risk of\nunderflowing iter->count if the\
  \ block size happens to be large\nenough. This is triggered by fstest generic/361\
  \ with a 4k block\nsize, which subsequently leads to a crash. To avoid this crash,\n\
  check that the shorten length doesn't exceed the overall length of\nthe iter.\n\n\
  Fixes:\nSigned-off-by: Brian Foster <bfoster@redhat.com>\nReviewed-by: Su Yue <glass.su@suse.com>\n\
  Signed-off-by: Kent Overstreet <kent.overstreet@linux.dev>\n\n## Buggy Code\n\n\
  ```c\n// Function: bch2_direct_IO_read in fs/bcachefs/fs-io-direct.c\nstatic int\
  \ bch2_direct_IO_read(struct kiocb *req, struct iov_iter *iter)\n{\n\tstruct file\
  \ *file = req->ki_filp;\n\tstruct bch_inode_info *inode = file_bch_inode(file);\n\
  \tstruct bch_fs *c = inode->v.i_sb->s_fs_info;\n\tstruct bch_io_opts opts;\n\tstruct\
  \ dio_read *dio;\n\tstruct bio *bio;\n\tloff_t offset = req->ki_pos;\n\tbool sync\
  \ = is_sync_kiocb(req);\n\tsize_t shorten;\n\tssize_t ret;\n\n\tbch2_inode_opts_get(&opts,\
  \ c, &inode->ei_inode);\n\n\t/* bios must be 512 byte aligned: */\n\tif ((offset|iter->count)\
  \ & (SECTOR_SIZE - 1))\n\t\treturn -EINVAL;\n\n\tret = min_t(loff_t, iter->count,\n\
  \t\t    max_t(loff_t, 0, i_size_read(&inode->v) - offset));\n\n\tif (!ret)\n\t\t\
  return ret;\n\n\tshorten = iov_iter_count(iter) - round_up(ret, block_bytes(c));\n\
  \titer->count -= shorten;\n\n\tbio = bio_alloc_bioset(NULL,\n\t\t\t       bio_iov_vecs_to_alloc(iter,\
  \ BIO_MAX_VECS),\n\t\t\t       REQ_OP_READ,\n\t\t\t       GFP_KERNEL,\n\t\t\t  \
  \     &c->dio_read_bioset);\n\n\tbio->bi_end_io = bch2_direct_IO_read_endio;\n\n\
  \tdio = container_of(bio, struct dio_read, rbio.bio);\n\tclosure_init(&dio->cl,\
  \ NULL);\n\n\t/*\n\t * this is a _really_ horrible hack just to avoid an atomic\
  \ sub at the\n\t * end:\n\t */\n\tif (!sync) {\n\t\tset_closure_fn(&dio->cl, bch2_dio_read_complete,\
  \ NULL);\n\t\tatomic_set(&dio->cl.remaining,\n\t\t\t   CLOSURE_REMAINING_INITIALIZER\
  \ -\n\t\t\t   CLOSURE_RUNNING +\n\t\t\t   CLOSURE_DESTRUCTOR);\n\t} else {\n\t\t\
  atomic_set(&dio->cl.remaining,\n\t\t\t   CLOSURE_REMAINING_INITIALIZER + 1);\n\t\
  \tdio->cl.closure_get_happened = true;\n\t}\n\n\tdio->req\t= req;\n\tdio->ret\t\
  = ret;\n\t/*\n\t * This is one of the sketchier things I've encountered: we have\
  \ to skip\n\t * the dirtying of requests that are internal from the kernel (i.e.\
  \ from\n\t * loopback), because we'll deadlock on page_lock.\n\t */\n\tdio->should_dirty\
  \ = iter_is_iovec(iter);\n\n\tgoto start;\n\twhile (iter->count) {\n\t\tbio = bio_alloc_bioset(NULL,\n\
  \t\t\t\t       bio_iov_vecs_to_alloc(iter, BIO_MAX_VECS),\n\t\t\t\t       REQ_OP_READ,\n\
  \t\t\t\t       GFP_KERNEL,\n\t\t\t\t       &c->bio_read);\n\t\tbio->bi_end_io\t\t\
  = bch2_direct_IO_read_split_endio;\nstart:\n\t\tbio->bi_opf\t\t= REQ_OP_READ|REQ_SYNC;\n\
  \t\tbio->bi_iter.bi_sector\t= offset >> 9;\n\t\tbio->bi_private\t\t= dio;\n\n\t\t\
  ret = bio_iov_iter_get_pages(bio, iter);\n\t\tif (ret < 0) {\n\t\t\t/* XXX: fault\
  \ inject this path */\n\t\t\tbio->bi_status = BLK_STS_RESOURCE;\n\t\t\tbio_endio(bio);\n\
  \t\t\tbreak;\n\t\t}\n\n\t\toffset += bio->bi_iter.bi_size;\n\n\t\tif (dio->should_dirty)\n\
  \t\t\tbio_set_pages_dirty(bio);\n\n\t\tif (iter->count)\n\t\t\tclosure_get(&dio->cl);\n\
  \n\t\tbch2_read(c, rbio_init(bio, opts), inode_inum(inode));\n\t}\n\n\titer->count\
  \ += shorten;\n\n\tif (sync) {\n\t\tclosure_sync(&dio->cl);\n\t\tclosure_debug_destroy(&dio->cl);\n\
  \t\tret = dio->ret;\n\t\tbio_check_or_release(&dio->rbio.bio, dio->should_dirty);\n\
  \t\treturn ret;\n\t} else {\n\t\treturn -EIOCBQUEUED;\n\t}\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/fs/bcachefs/fs-io-direct.c b/fs/bcachefs/fs-io-direct.c\n\
  index e3b219e19e10..33cb6da3a5ad 100644\n--- a/fs/bcachefs/fs-io-direct.c\n+++ b/fs/bcachefs/fs-io-direct.c\n\
  @@ -88,6 +88,8 @@ static int bch2_direct_IO_read(struct kiocb *req, struct iov_iter\
  \ *iter)\n \t\treturn ret;\n \n \tshorten = iov_iter_count(iter) - round_up(ret,\
  \ block_bytes(c));\n+\tif (shorten >= iter->count)\n+\t\tshorten = 0;\n \titer->count\
  \ -= shorten;\n \n \tbio = bio_alloc_bioset(NULL,\n```\n"
pattern: "## Bug Pattern\n\nComputing a size_t \u201Cshorten\u201D as the unsigned\
  \ difference between the current iov_iter length and a rounded-up (block-aligned)\
  \ length, and then subtracting it from iter->count without verifying that the rounded-up\
  \ length is not larger than the available length. This causes unsigned underflow\
  \ and wraps iter->count to a huge value.\n\nPattern:\n- need = round_up(valid_len,\
  \ block_size)\n- avail = iov_iter_count(iter)\n- shorten = avail - need;       \
  \ // underflows if need > avail\n- iter->count -= shorten;        // uses wrapped\
  \ value\n\nCorrect pattern must clamp/check:\nif (need > avail) shorten = 0; or\
  \ equivalently if (shorten >= iter->count) shorten = 0."
plan: "Plan\n\n1. Program state customization\n- REGISTER_MAP_WITH_PROGRAMSTATE(DeltaToIterMap,\
  \ const MemRegion*, const MemRegion*)\n  - Key: MemRegion of the temporary \u201C\
  shorten\u201D (or any variable) that stores avail - need.\n  - Value: MemRegion\
  \ of the base iov_iter pointer used to compute avail (the argument to iov_iter_count()\
  \ or the base of MemberExpr \u201Citer->count\u201D).\n- No other traits or maps\
  \ are necessary. Keep the state minimal and focused on correlating the delta with\
  \ the specific iter.\n\n2. Helper matchers (small internal utilities)\n- bool isIovAvailExpr(const\
  \ Expr *E, const MemRegion* &IterMR, CheckerContext &C)\n  - Return true if E is\
  \ one of:\n    - CallExpr to a function whose name is \"iov_iter_count\", and has\
  \ 1 argument; set IterMR = getMemRegionFromExpr(arg0, C).\n    - MemberExpr whose\
  \ member name is \"count\" (i.e., \u201Citer->count\u201D), and base exists; set\
  \ IterMR = getMemRegionFromExpr(base, C).\n- bool isRoundUpExpr(const Expr *E, CheckerContext\
  \ &C)\n  - Return true if ExprHasName(E, \"round_up\", C) or ExprHasName(E, \"roundup\"\
  , C).\n  - Optionally allow variants like ExprHasName(E, \"block_bytes\", C) for\
  \ strengthening, but do not require it.\n- const MemRegion* getVarRegionFromExpr(const\
  \ Expr *E, CheckerContext &C)\n  - If E is a DeclRefExpr to a local/param variable,\
  \ return its MemRegion via getMemRegionFromExpr(E, C).\n- const MemRegion* getIterBaseFromMemberExpr(const\
  \ Expr *LHS, CheckerContext &C)\n  - If LHS is a MemberExpr with field name \"count\"\
  \ and has a base expression, return getMemRegionFromExpr(base, C).\n  - Otherwise,\
  \ return nullptr.\n- bool isUnsignedIntegral(QualType QT)\n  - Use QT->isUnsignedIntegerType()\
  \ to reduce noise (optional but recommended).\n\n3. Record \u201Cshorten = avail\
  \ - need\u201D (DeclStmt)\n- Callback: checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C)\n  - For each VarDecl in DS:\n    - If it has an initializer and the type\
  \ is unsigned integer (preferably size_t), and the initializer is a BinaryOperator\
  \ with opcode BO_Sub:\n      - Let LHS = BO->getLHS(), RHS = BO->getRHS().\n   \
  \   - Check isIovAvailExpr(LHS, IterMR, C) and isRoundUpExpr(RHS, C).\n      - If\
  \ both match and IterMR != nullptr:\n        - Find the MemRegion of this variable\
  \ via getMemRegionFromExpr(DeclRefExpr to the VarDecl).\n        - Insert into DeltaToIterMap:\
  \ Map[DeltaVarMR] = IterMR.\n\n4. Record \u201Cshorten = avail - need\u201D (simple\
  \ assignment)\n- Callback: checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C)\n  - If S is a BinaryOperator of kind BO_Assign:\n    - Extract the LHS Expr\
  \ (destination) and RHS Expr (source) from S via dyn_cast<BinaryOperator>(S).\n\
  \    - If RHS is a BinaryOperator BO_Sub and type unsigned:\n      - If isIovAvailExpr(RHS->getLHS(),\
  \ IterMR, C) and isRoundUpExpr(RHS->getRHS(), C):\n        - Compute DeltaVarMR\
  \ from the LHS expression via getMemRegionFromExpr(LHS, C).\n        - If both regions\
  \ are valid, Map[DeltaVarMR] = IterMR.\n\n5. Detect dangerous decrement: \u201C\
  iter->count -= shorten\u201D or direct \u201Citer->count -= avail - need\u201D\n\
  - Callback: checkPostStmt(const CompoundAssignOperator *CAO, CheckerContext &C)\n\
  \  - If CAO->getOpcode() == BO_SubAssign:\n    - Let LHS = CAO->getLHS(); confirm\
  \ it\u2019s a MemberExpr named \"count\".\n    - Extract IterMR_LHS = getIterBaseFromMemberExpr(LHS,\
  \ C). If null, return.\n    - Let RHS = CAO->getRHS():\n      - Case A: RHS is a\
  \ DeclRefExpr to some variable:\n        - Get DeltaVarMR = getVarRegionFromExpr(RHS,\
  \ C).\n        - Lookup IterMR_Map = DeltaToIterMap[DeltaVarMR].\n        - If IterMR_Map\
  \ != nullptr and IterMR_Map == IterMR_LHS:\n          - Report bug: \u201CPossible\
  \ underflow in count adjustment: round_up() may exceed iov_iter length; clamp before\
  \ decrement.\u201D\n      - Case B: RHS is a BinaryOperator BO_Sub:\n        - If\
  \ isIovAvailExpr(RHS->getLHS(), IterMR_RHS, C) and isRoundUpExpr(RHS->getRHS(),\
  \ C) and IterMR_RHS == IterMR_LHS:\n          - Report bug as above.\n\n6. Detect\
  \ dangerous assignment form: \u201Citer->count = iter->count - shorten/ (avail -\
  \ need)\u201D\n- Callback: checkPostStmt(const BinaryOperator *BO, CheckerContext\
  \ &C)\n  - If BO->getOpcode() == BO_Assign:\n    - If LHS is MemberExpr named \"\
  count\", get IterMR_LHS.\n    - If RHS is a BinaryOperator with opcode BO_Sub:\n\
  \      - If RHS->getLHS() textually references the same \u201Citer->count\u201D\
  \ (use MemberExpr match or ExprHasName heuristics) or semantically is the same MemberExpr:\n\
  \        - For RHS->getRHS():\n          - Case A: DeclRefExpr to variable: lookup\
  \ in DeltaToIterMap and compare IterMRs; if match, report.\n          - Case B:\
  \ BinaryOperator BO_Sub with iov_iter_count/round_up pattern and IterMR matches\
  \ LHS, report.\n\n7. Reporting\n- In the reporting sites above:\n  - Create a non-fatal\
  \ error node with generateNonFatalErrorNode().\n  - Use a concise message, e.g.:\n\
  \    - \u201CUnderflow risk: avail - round_up(...) may wrap, then used to decrement\
  \ iter->count. Add clamp check.\u201D\n  - Highlight the RHS expression of the compound\
  \ assignment or the subtraction expression itself.\n\n8. Notes and simplifications\n\
  - This is a pattern checker: it does not rely on runtime values. It looks for:\n\
  \  - An unsigned delta computed as avail - round_up(...), where avail comes from\
  \ iov_iter_count(iter) or iter->count.\n  - The delta then used to decrement iter->count\
  \ via \u201C-=\u201D or \u201C= ... - ...\u201D.\n- Guard suppression:\n  - For\
  \ simplicity, do not attempt to prove presence of a safe guard (\u201Cif (shorten\
  \ >= iter->count) shorten = 0;\u201D or \u201Cif (need > avail) ...\u201D). This\
  \ avoids complex control-flow reasoning and false suppressions.\n  - If desired\
  \ later, a lightweight heuristic can be added in checkBranchCondition to look for\
  \ conditions containing both the delta variable name and \u201Citer->count\u201D\
  \ with a \u201C>=\u201D or \u201C>\u201D operator, but this is optional and not\
  \ required for a correct first version.\n- Extra robustness:\n  - Accept both \u201C\
  round_up\u201D and \u201Croundup\u201D names (macro variants).\n  - Prefer matching\
  \ unsigned destination type (size_t-like) to minimize noise.\n  - Ensure IterMR\
  \ equality (the same iter base) to avoid cross-iter false positives."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(DeltaToIterMap, const MemRegion*, const\
  \ MemRegion*)\n\nnamespace {\n\nclass SAGenTestChecker\n    : public Checker<\n\
  \          check::Bind,\n          check::PostStmt<BinaryOperator>,\n          check::PostStmt<CompoundAssignOperator>>\
  \ {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n \
  \     : BT(std::make_unique<BugType>(this,\n                                   \
  \  \"iov_iter count underflow risk\",\n                                     \"Integer\"\
  )) {}\n\n  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C)\
  \ const;\n  void checkPostStmt(const BinaryOperator *BO, CheckerContext &C) const;\n\
  \  void checkPostStmt(const CompoundAssignOperator *CAO,\n                     CheckerContext\
  \ &C) const;\n\nprivate:\n  // Helpers\n  static bool isUnsignedIntegral(QualType\
  \ QT);\n  static const MemRegion *getVarRegionFromExpr(const Expr *E,\n        \
  \                                       CheckerContext &C);\n  static const MemRegion\
  \ *getIterBaseFromMemberExpr(const Expr *E,\n                                  \
  \                  CheckerContext &C);\n  static bool isIovAvailExpr(const Expr\
  \ *E, const MemRegion *&IterMR,\n                             CheckerContext &C);\n\
  \  static bool isRoundUpExpr(const Expr *E, CheckerContext &C);\n  void report(const\
  \ Stmt *S, CheckerContext &C) const;\n};\n\n/* ===================== Helper Implementations\
  \ ===================== */\n\nbool SAGenTestChecker::isUnsignedIntegral(QualType\
  \ QT) {\n  if (QT.isNull())\n    return false;\n  QT = QT.getCanonicalType();\n\
  \  return QT->isUnsignedIntegerType();\n}\n\nconst MemRegion *SAGenTestChecker::getVarRegionFromExpr(const\
  \ Expr *E,\n                                                        CheckerContext\
  \ &C) {\n  if (!E)\n    return nullptr;\n  if (isa<DeclRefExpr>(E->IgnoreParenCasts()))\
  \ {\n    const MemRegion *MR = getMemRegionFromExpr(E, C);\n    if (!MR)\n     \
  \ return nullptr;\n    return MR->getBaseRegion();\n  }\n  return nullptr;\n}\n\n\
  const MemRegion *\nSAGenTestChecker::getIterBaseFromMemberExpr(const Expr *E,\n\
  \                                            CheckerContext &C) {\n  if (!E)\n \
  \   return nullptr;\n  E = E->IgnoreParenCasts();\n  const auto *ME = dyn_cast<MemberExpr>(E);\n\
  \  if (!ME)\n    return nullptr;\n  const ValueDecl *VD = ME->getMemberDecl();\n\
  \  if (!VD)\n    return nullptr;\n  const IdentifierInfo *II = VD->getIdentifier();\n\
  \  if (!II)\n    return nullptr;\n  // We are interested in \"count\" field: iter->count\n\
  \  if (!II->isStr(\"count\"))\n    return nullptr;\n\n  const Expr *Base = ME->getBase();\n\
  \  if (!Base)\n    return nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(Base,\
  \ C);\n  if (!MR)\n    return nullptr;\n  return MR->getBaseRegion();\n}\n\nbool\
  \ SAGenTestChecker::isIovAvailExpr(const Expr *E,\n                            \
  \          const MemRegion *&IterMR,\n                                      CheckerContext\
  \ &C) {\n  IterMR = nullptr;\n  if (!E)\n    return false;\n\n  E = E->IgnoreParenCasts();\n\
  \n  // Case 1: iov_iter_count(iter)\n  if (const auto *CE = dyn_cast<CallExpr>(E))\
  \ {\n    if (ExprHasName(CE, \"iov_iter_count\", C) && CE->getNumArgs() == 1) {\n\
  \      const Expr *Arg0 = CE->getArg(0);\n      const MemRegion *MR = getMemRegionFromExpr(Arg0,\
  \ C);\n      if (!MR)\n        return false;\n      IterMR = MR->getBaseRegion();\n\
  \      return IterMR != nullptr;\n    }\n  }\n\n  // Case 2: iter->count\n  if (const\
  \ MemRegion *MR = getIterBaseFromMemberExpr(E, C)) {\n    IterMR = MR;\n    return\
  \ true;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isRoundUpExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E)\n    return false;\n  // Match common\
  \ kernel macro/function names for rounding up.\n  // Using source text via utility\
  \ to be robust to macros.\n  return ExprHasName(E, \"round_up\", C) || ExprHasName(E,\
  \ \"roundup\", C);\n}\n\nvoid SAGenTestChecker::report(const Stmt *S, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n\
  \      \"Underflow risk: avail - round_up(...) may wrap, then used to decrement\
  \ \"\n      \"iter->count. Add clamp before decrement\",\n      N);\n  if (S)\n\
  \    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n/* =====================\
  \ Core Logic ===================== */\n\nvoid SAGenTestChecker::checkBind(SVal Loc,\
  \ SVal /*Val*/, const Stmt *S,\n                                 CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *LHSReg\
  \ = Loc.getAsRegion();\n  if (!LHSReg)\n    return;\n  LHSReg = LHSReg->getBaseRegion();\n\
  \  if (!LHSReg)\n    return;\n\n  // Only record mapping for local/param variables\
  \ (not fields).\n  const auto *VR = dyn_cast<VarRegion>(LHSReg);\n  if (!VR)\n \
  \   return;\n\n  const VarDecl *VD = VR->getDecl();\n  if (!VD)\n    return;\n\n\
  \  // Prefer unsigned integral (size_t-like).\n  if (!isUnsignedIntegral(VD->getType()))\n\
  \    return;\n\n  if (!S)\n    return;\n\n  const Expr *E = dyn_cast<Expr>(S);\n\
  \  if (!E)\n    return;\n\n  E = E->IgnoreParenCasts();\n\n  // Two cases to capture\
  \ \"shorten = avail - need\" pattern:\n  // 1) Direct initializer \"size_t shorten\
  \ = avail - round_up(...);\"\n  // 2) Simple assignment \"shorten = avail - round_up(...);\"\
  \n  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {\n    if (BO->getOpcode()\
  \ == BO_Assign) {\n      const Expr *RHS = BO->getRHS();\n      if (!RHS)\n    \
  \    return;\n      RHS = RHS->IgnoreParenCasts();\n      const auto *Sub = dyn_cast<BinaryOperator>(RHS);\n\
  \      if (!Sub || Sub->getOpcode() != BO_Sub)\n        return;\n\n      const Expr\
  \ *L0 = Sub->getLHS();\n      const Expr *R0 = Sub->getRHS();\n      if (!L0 ||\
  \ !R0)\n        return;\n\n      const MemRegion *IterMR = nullptr;\n      if (isIovAvailExpr(L0,\
  \ IterMR, C) && IterMR && isRoundUpExpr(R0, C)) {\n        State = State->set<DeltaToIterMap>(LHSReg,\
  \ IterMR->getBaseRegion());\n        C.addTransition(State);\n      }\n      return;\n\
  \    } else if (BO->getOpcode() == BO_Sub) {\n      // Initializer of form \"size_t\
  \ shorten = avail - round_up(...);\"\n      const Expr *L0 = BO->getLHS();\n   \
  \   const Expr *R0 = BO->getRHS();\n      if (!L0 || !R0)\n        return;\n\n \
  \     const MemRegion *IterMR = nullptr;\n      if (isIovAvailExpr(L0, IterMR, C)\
  \ && IterMR && isRoundUpExpr(R0, C)) {\n        State = State->set<DeltaToIterMap>(LHSReg,\
  \ IterMR->getBaseRegion());\n        C.addTransition(State);\n      }\n      return;\n\
  \    }\n  }\n}\n\nvoid SAGenTestChecker::checkPostStmt(const CompoundAssignOperator\
  \ *CAO,\n                                     CheckerContext &C) const {\n  if (!CAO)\n\
  \    return;\n\n  if (CAO->getOpcode() != BO_SubAssign)\n    return;\n\n  // Match\
  \ \"iter->count -= something\"\n  const Expr *LHS = CAO->getLHS();\n  if (!LHS)\n\
  \    return;\n  const MemRegion *IterMR_LHS = getIterBaseFromMemberExpr(LHS, C);\n\
  \  if (!IterMR_LHS)\n    return;\n\n  const Expr *RHS = CAO->getRHS();\n  if (!RHS)\n\
  \    return;\n  RHS = RHS->IgnoreParenCasts();\n\n  ProgramStateRef State = C.getState();\n\
  \n  // Case A: \"iter->count -= shorten\" where shorten recorded as avail - round_up(...)\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(RHS)) {\n    const MemRegion *DeltaMR\
  \ = getVarRegionFromExpr(DRE, C);\n    if (DeltaMR) {\n      if (const MemRegion\
  \ *const *MappedIter = State->get<DeltaToIterMap>(DeltaMR)) {\n        // Ensure\
  \ the delta was computed from the same iter\n        if (*MappedIter && *MappedIter\
  \ == IterMR_LHS) {\n          report(CAO, C);\n        }\n      }\n    }\n    return;\n\
  \  }\n\n  // Case B: \"iter->count -= (avail - round_up(...))\"\n  if (const auto\
  \ *Sub = dyn_cast<BinaryOperator>(RHS)) {\n    if (Sub->getOpcode() == BO_Sub) {\n\
  \      const Expr *L0 = Sub->getLHS();\n      const Expr *R0 = Sub->getRHS();\n\
  \      const MemRegion *IterMR_RHS = nullptr;\n      if (L0 && R0 && isIovAvailExpr(L0,\
  \ IterMR_RHS, C) && IterMR_RHS &&\n          isRoundUpExpr(R0, C) && IterMR_RHS\
  \ == IterMR_LHS) {\n        report(CAO, C);\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ BinaryOperator *BO,\n                                     CheckerContext &C) const\
  \ {\n  if (!BO)\n    return;\n\n  if (BO->getOpcode() != BO_Assign)\n    return;\n\
  \n  // Match \"iter->count = iter->count - shorten\"\n  const Expr *LHS = BO->getLHS();\n\
  \  if (!LHS)\n    return;\n  const MemRegion *IterMR_LHS = getIterBaseFromMemberExpr(LHS,\
  \ C);\n  if (!IterMR_LHS)\n    return;\n\n  const Expr *RHS = BO->getRHS();\n  if\
  \ (!RHS)\n    return;\n  RHS = RHS->IgnoreParenCasts();\n\n  const auto *Sub = dyn_cast<BinaryOperator>(RHS);\n\
  \  if (!Sub || Sub->getOpcode() != BO_Sub)\n    return;\n\n  // Ensure the subtraction\
  \ is based on the same iter: \"iter->count - ...\"\n  const Expr *SubLHS = Sub->getLHS();\n\
  \  if (!SubLHS)\n    return;\n\n  bool SameIterBase = false;\n  // Either \"iter->count\
  \ - ...\" or \"iov_iter_count(iter) - ...\" referring to same iter.\n  if (const\
  \ MemRegion *IterFromMember = getIterBaseFromMemberExpr(SubLHS, C)) {\n    SameIterBase\
  \ = (IterFromMember == IterMR_LHS);\n  } else {\n    const MemRegion *IterFromAvail\
  \ = nullptr;\n    if (isIovAvailExpr(SubLHS, IterFromAvail, C) && IterFromAvail\
  \ == IterMR_LHS)\n      SameIterBase = true;\n  }\n  if (!SameIterBase)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n\n  const Expr *SubRHS = Sub->getRHS();\n\
  \  if (!SubRHS)\n    return;\n  SubRHS = SubRHS->IgnoreParenCasts();\n\n  // Case\
  \ A: \"iter->count = iter->count - shorten\"\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(SubRHS))\
  \ {\n    const MemRegion *DeltaMR = getVarRegionFromExpr(DRE, C);\n    if (DeltaMR)\
  \ {\n      if (const MemRegion *const *MappedIter = State->get<DeltaToIterMap>(DeltaMR))\
  \ {\n        if (*MappedIter && *MappedIter == IterMR_LHS) {\n          report(BO,\
  \ C);\n        }\n      }\n    }\n    return;\n  }\n\n  // Case B: \"iter->count\
  \ = iter->count - (avail - round_up(...))\"\n  if (const auto *InnerSub = dyn_cast<BinaryOperator>(SubRHS))\
  \ {\n    if (InnerSub->getOpcode() == BO_Sub) {\n      const Expr *L0 = InnerSub->getLHS();\n\
  \      const Expr *R0 = InnerSub->getRHS();\n      const MemRegion *IterMR_RHS =\
  \ nullptr;\n      if (L0 && R0 && isIovAvailExpr(L0, IterMR_RHS, C) && IterMR_RHS\
  \ &&\n          isRoundUpExpr(R0, C) && IterMR_RHS == IterMR_LHS) {\n        report(BO,\
  \ C);\n      }\n    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects iov_iter count underflow due\
  \ to subtracting round_up(...) \"\n      \"without clamping against available length\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
