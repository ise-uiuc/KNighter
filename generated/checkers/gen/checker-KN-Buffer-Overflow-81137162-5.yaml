_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 81137162bfaa7278785b24c1fd2e9e74f082e8e4
commit_type: Buffer-Overflow
index: 5
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/ExprCXX.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"llvm/ADT/APInt.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states are necessary for this checker.\n\
  \nnamespace {\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unbounded string\
  \ copy into fixed-size buffer\", \"Buffer Overflow\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\n      bool isUnboundedStringCopy(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      bool isCharType(QualType T)\
  \ const;\n      bool getFixedArraySizeFromMemberExpr(const MemberExpr *ME, llvm::APInt\
  \ &OutSize, QualType &ElemTy) const;\n      bool getFixedArraySizeFromDestExpr(const\
  \ Expr *DestArg, llvm::APInt &OutSize, QualType &ElemTy, CheckerContext &C) const;\n\
  };\n\nbool SAGenTestChecker::isUnboundedStringCopy(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n  \
  \  return false;\n\n  // Use source-based name matching for robustness.\n  if (ExprHasName(Origin,\
  \ \"strcpy\", C))\n    return true;\n  if (ExprHasName(Origin, \"stpcpy\", C))\n\
  \    return true;\n  if (ExprHasName(Origin, \"strcat\", C))\n    return true;\n\
  \n  // Fallback to callee identifier if available.\n  if (const IdentifierInfo *II\
  \ = Call.getCalleeIdentifier()) {\n    StringRef N = II->getName();\n    return\
  \ N == \"strcpy\" || N == \"stpcpy\" || N == \"strcat\";\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isCharType(QualType T) const {\n  if (T.isNull())\n\
  \    return false;\n  // Check if the element type is any character type (char,\
  \ signed char, unsigned char).\n  return T->isAnyCharacterType();\n}\n\nbool SAGenTestChecker::getFixedArraySizeFromMemberExpr(const\
  \ MemberExpr *ME, llvm::APInt &OutSize, QualType &ElemTy) const {\n  if (!ME)\n\
  \    return false;\n\n  const ValueDecl *VD = ME->getMemberDecl();\n  if (!VD)\n\
  \    return false;\n\n  QualType FT = VD->getType();\n  const Type *Ty = FT.getTypePtrOrNull();\n\
  \  if (!Ty)\n    return false;\n\n  if (const auto *CAT = dyn_cast<ConstantArrayType>(Ty))\
  \ {\n    ElemTy = CAT->getElementType();\n    OutSize = CAT->getSize();\n    return\
  \ true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getFixedArraySizeFromDestExpr(const\
  \ Expr *DestArg, llvm::APInt &OutSize, QualType &ElemTy, CheckerContext &C) const\
  \ {\n  if (!DestArg)\n    return false;\n\n  // Strip implicit casts\n  const Expr\
  \ *E = DestArg->IgnoreImplicit();\n\n  // Try DeclRefExpr path: dest refers directly\
  \ to an array variable.\n  if (const auto *DRE = findSpecificTypeInChildren<DeclRefExpr>(E))\
  \ {\n    const ValueDecl *VD = DRE->getDecl();\n    if (const auto *VarD = dyn_cast_or_null<VarDecl>(VD))\
  \ {\n      QualType VT = VarD->getType();\n      const Type *Ty = VT.getTypePtrOrNull();\n\
  \      if (!Ty)\n        return false;\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(Ty))\
  \ {\n        ElemTy = CAT->getElementType();\n        OutSize = CAT->getSize();\n\
  \        return true;\n      }\n    }\n    // Fallthrough if not a constant array\n\
  \  }\n\n  // Try MemberExpr path: struct/union fixed-size array field.\n  if (const\
  \ auto *ME = findSpecificTypeInChildren<MemberExpr>(E)) {\n    if (getFixedArraySizeFromMemberExpr(ME,\
  \ OutSize, ElemTy))\n      return true;\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // 1) Identify unbounded string-copy\
  \ functions.\n  if (!isUnboundedStringCopy(Call, C))\n    return;\n\n  // Expect\
  \ at least 2 arguments (dest, src).\n  if (Call.getNumArgs() < 2)\n    return;\n\
  \n  // 2) Analyze the destination argument to ensure it is a fixed-size char array.\n\
  \  const Expr *DestArg = Call.getArgExpr(0);\n  llvm::APInt Capacity;\n  QualType\
  \ ElemTy;\n\n  if (!getFixedArraySizeFromDestExpr(DestArg, Capacity, ElemTy, C))\n\
  \    return;\n\n  if (!isCharType(ElemTy))\n    return;\n\n  // 3) Inspect the source\
  \ argument.\n  const Expr *SrcArg = Call.getArgExpr(1);\n  llvm::APInt StringSize;\n\
  \n  // If the source is a string literal with a known length:\n  if (getStringSize(StringSize,\
  \ SrcArg)) {\n    // StringSize is number of characters excluding the null terminator.\n\
  \    // For strcpy/stpcpy/strcat, if StringSize >= Capacity, copy can't fit including\
  \ NUL.\n    if (StringSize.uge(Capacity)) {\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \      if (!N)\n        return;\n\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"Unbounded string copy into fixed-size buffer may overflow; use\
  \ strscpy with sizeof(dest).\", N);\n      if (const Stmt *S = Call.getOriginExpr())\n\
  \        R->addRange(S->getSourceRange());\n      C.emitReport(std::move(R));\n\
  \    }\n    // If StringSize < Capacity, don't warn: the literal definitely fits.\n\
  \    return;\n  }\n\n  // If not a string literal, we cannot prove safety. Report\
  \ as potentially overflowing.\n  {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Unbounded string copy into fixed-size buffer may overflow; use strscpy\
  \ with sizeof(dest).\", N);\n    if (const Stmt *S = Call.getOriginExpr())\n   \
  \   R->addRange(S->getSourceRange());\n    C.emitReport(std::move(R));\n  }\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unbounded string copy into fixed-size buffers (use strscpy with\
  \ sizeof(dest))\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: hci_core: Fix possible buffer overflow\n\
  \nstruct hci_dev_info has a fixed size name[8] field so in the event that\nhdev->name\
  \ is bigger than that strcpy would attempt to write past its\nsize, so this fixes\
  \ this problem by switching to use strscpy.\n\nFixes: dcda165706b9 (\"Bluetooth:\
  \ hci_core: Fix build warnings\")\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\n\
  \n## Buggy Code\n\n```c\n// Function: hci_get_dev_info in net/bluetooth/hci_core.c\n\
  int hci_get_dev_info(void __user *arg)\n{\n\tstruct hci_dev *hdev;\n\tstruct hci_dev_info\
  \ di;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (copy_from_user(&di, arg,\
  \ sizeof(di)))\n\t\treturn -EFAULT;\n\n\thdev = hci_dev_get(di.dev_id);\n\tif (!hdev)\n\
  \t\treturn -ENODEV;\n\n\t/* When the auto-off is configured it means the transport\n\
  \t * is running, but in that case still indicate that the\n\t * device is actually\
  \ down.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_AUTO_OFF))\n\t\tflags = hdev->flags\
  \ & ~BIT(HCI_UP);\n\telse\n\t\tflags = hdev->flags;\n\n\tstrcpy(di.name, hdev->name);\n\
  \tdi.bdaddr   = hdev->bdaddr;\n\tdi.type     = (hdev->bus & 0x0f) | ((hdev->dev_type\
  \ & 0x03) << 4);\n\tdi.flags    = flags;\n\tdi.pkt_type = hdev->pkt_type;\n\tif\
  \ (lmp_bredr_capable(hdev)) {\n\t\tdi.acl_mtu  = hdev->acl_mtu;\n\t\tdi.acl_pkts\
  \ = hdev->acl_pkts;\n\t\tdi.sco_mtu  = hdev->sco_mtu;\n\t\tdi.sco_pkts = hdev->sco_pkts;\n\
  \t} else {\n\t\tdi.acl_mtu  = hdev->le_mtu;\n\t\tdi.acl_pkts = hdev->le_pkts;\n\t\
  \tdi.sco_mtu  = 0;\n\t\tdi.sco_pkts = 0;\n\t}\n\tdi.link_policy = hdev->link_policy;\n\
  \tdi.link_mode   = hdev->link_mode;\n\n\tmemcpy(&di.stat, &hdev->stat, sizeof(di.stat));\n\
  \tmemcpy(&di.features, &hdev->features, sizeof(di.features));\n\n\tif (copy_to_user(arg,\
  \ &di, sizeof(di)))\n\t\terr = -EFAULT;\n\n\thci_dev_put(hdev);\n\n\treturn err;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c\n\
  index 6ca4c0df9f9c..230d2bbb933b 100644\n--- a/net/bluetooth/hci_core.c\n+++ b/net/bluetooth/hci_core.c\n\
  @@ -908,7 +908,7 @@ int hci_get_dev_info(void __user *arg)\n \telse\n \t\tflags\
  \ = hdev->flags;\n \n-\tstrcpy(di.name, hdev->name);\n+\tstrscpy(di.name, hdev->name,\
  \ sizeof(di.name));\n \tdi.bdaddr   = hdev->bdaddr;\n \tdi.type     = (hdev->bus\
  \ & 0x0f) | ((hdev->dev_type & 0x03) << 4);\n \tdi.flags    = flags;\n```\n"
pattern: "## Bug Pattern\n\nUsing an unbounded string copy (e.g., strcpy) to copy\
  \ a runtime string into a fixed-size buffer (struct member) without enforcing the\
  \ destination\u2019s length, allowing overflow when the source is longer than the\
  \ destination.\n\nExample pattern:\n- char dest[FIXED_SIZE];  // e.g., name[8] in\
  \ a struct\n- strcpy(dest, src);      // src length may exceed FIXED_SIZE, causing\
  \ overflow\n\nCorrect approach: use a bounded copy (e.g., strscpy(dest, src, sizeof(dest)))."
plan: "Plan\n\n1. Program State\n- No custom program state is needed. This checker\
  \ is a pure call-site/AST inspection that reports immediately when it sees an unbounded\
  \ string copy into a fixed-size buffer.\n\n2. Callback Functions\n- Use only checkPreCall.\n\
  \n3. checkPreCall (core detection)\n- Goal: Detect calls to unbounded string-copy\
  \ APIs that target a fixed-size character array, which enables overflow when the\
  \ source length may exceed the destination capacity.\n\n- Step-by-step:\n  a) Identify\
  \ unbounded string-copy functions:\n     - Extract the callee identifier via Call.getCalleeIdentifier().\n\
  \     - If the name is one of: \"strcpy\", \"stpcpy\", \"strcat\" (you can extend\
  \ the set if needed), proceed; otherwise return.\n\n  b) Obtain and analyze the\
  \ destination argument:\n     - For strcpy/stpcpy/strcat, the destination is argument\
  \ index 0.\n     - Let DestArg = Call.getArgExpr(0).\n     - Remove implicit casts\
  \ by using DestArg->IgnoreImplicit().\n     - Find the underlying array entity:\n\
  \       - First try findSpecificTypeInChildren<DeclRefExpr>(DestArg). If found,\
  \ try to get the array size via getArraySizeFromExpr(ArraySize, DRE). If this succeeds,\
  \ we have a fixed-size array.\n       - If that fails, try findSpecificTypeInChildren<MemberExpr>(DestArg).\
  \ If found, inspect the field\u2019s type:\n         - Get FieldDecl* FD = cast<FieldDecl>(ME->getMemberDecl()).\n\
  \         - QualType FT = FD->getType().\n         - If const ConstantArrayType\
  \ *CAT = dyn_cast<ConstantArrayType>(FT.getTypePtr()), then record:\n          \
  \ - Capacity = CAT->getSize() (APInt).\n           - Element type = CAT->getElementType().\
  \ Ensure it is a character type (isAnyCharacterType() or check for char/signed char/unsigned\
  \ char).\n         - If not a ConstantArrayType, return (we only warn when destination\
  \ is a fixed-size array).\n       - If neither DeclRefExpr nor MemberExpr gives\
  \ a fixed-size array, return.\n\n  c) If destination is a fixed-size char array:\n\
  \     - Inspect the source argument (argument index 1 for strcpy/stpcpy; for strcat\
  \ the source is also index 1):\n       - Let SrcArg = Call.getArgExpr(1).\n    \
  \   - Try to determine if the source is a string literal using getStringSize(StringSize,\
  \ SrcArg).\n         - If it is a string literal:\n           - Compare StringSize\
  \ (number of characters, not including the terminating null) against Capacity.\n\
  \           - If StringSize >= Capacity, report a bug (copy will overflow or lacks\
  \ room for NUL).\n           - If StringSize < Capacity, do not report.\n      \
  \   - If it is NOT a string literal:\n           - Report a bug because the copy\
  \ is unbounded and the destination is a fixed-size array; the source\u2019s runtime\
  \ length can exceed capacity.\n\n  d) Bug reporting:\n     - Create a non-fatal\
  \ error node via generateNonFatalErrorNode().\n     - Emit a PathSensitiveBugReport\
  \ with a short message like:\n       - \"Unbounded string copy into fixed-size buffer\
  \ may overflow; use strscpy with sizeof(dest).\"\n     - Anchor the report to the\
  \ call expression\u2019s source range.\n\n4. Helpers to implement in the checker\
  \ (small, local utilities)\n- bool isUnboundedStringCopy(const CallEvent &Call):\n\
  \  - Return true if callee name is one of {\"strcpy\", \"stpcpy\", \"strcat\"}.\n\
  \n- bool getFixedArraySizeFromMemberExpr(const MemberExpr *ME, llvm::APInt &OutSize,\
  \ QualType &ElemTy):\n  - From ME->getMemberDecl()->getType(), dyn_cast to ConstantArrayType\
  \ and extract size and element type.\n\n- bool getFixedArraySizeFromDestExpr(const\
  \ Expr *DestArg, llvm::APInt &OutSize, QualType &ElemTy):\n  - Try DeclRefExpr path\
  \ using getArraySizeFromExpr.\n  - Else try MemberExpr path using getFixedArraySizeFromMemberExpr.\n\
  \  - Return true only if a ConstantArrayType of char/signed char/unsigned char is\
  \ found.\n\n5. Notes and Simplifications\n- This checker deliberately does not attempt\
  \ to prove safety via preceding guards like if (strlen(src) < sizeof(dest)) \u2026\
  ; to keep the logic simple and robust, it only:\n  - Requires that the destination\
  \ is a fixed-size char array.\n  - Requires that the call is to an unbounded copy\
  \ API.\n  - Optionally suppresses when the source is a string literal that definitely\
  \ fits (StringSize < Capacity).\n- Do not warn for bounded APIs like strscpy/strlcpy/strncpy;\
  \ this checker only targets unbounded copies as per the target patch.\n- The provided\
  \ utility functions used:\n  - findSpecificTypeInChildren to retrieve DeclRefExpr/MemberExpr\
  \ under DestArg.\n  - getArraySizeFromExpr to get array capacity from DeclRefExpr.\n\
  \  - getStringSize to evaluate string literal lengths."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/ExprCXX.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"llvm/ADT/APInt.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states are necessary for this checker.\n\
  \nnamespace {\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unbounded string\
  \ copy into fixed-size buffer\", \"Buffer Overflow\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\n      bool isUnboundedStringCopy(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      bool isCharType(QualType T)\
  \ const;\n      bool getFixedArraySizeFromMemberExpr(const MemberExpr *ME, llvm::APInt\
  \ &OutSize, QualType &ElemTy) const;\n      bool getFixedArraySizeFromDestExpr(const\
  \ Expr *DestArg, llvm::APInt &OutSize, QualType &ElemTy, CheckerContext &C) const;\n\
  };\n\nbool SAGenTestChecker::isUnboundedStringCopy(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n  \
  \  return false;\n\n  // Use source-based name matching for robustness.\n  if (ExprHasName(Origin,\
  \ \"strcpy\", C))\n    return true;\n  if (ExprHasName(Origin, \"stpcpy\", C))\n\
  \    return true;\n  if (ExprHasName(Origin, \"strcat\", C))\n    return true;\n\
  \n  // Fallback to callee identifier if available.\n  if (const IdentifierInfo *II\
  \ = Call.getCalleeIdentifier()) {\n    StringRef N = II->getName();\n    return\
  \ N == \"strcpy\" || N == \"stpcpy\" || N == \"strcat\";\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isCharType(QualType T) const {\n  if (T.isNull())\n\
  \    return false;\n  // Check if the element type is any character type (char,\
  \ signed char, unsigned char).\n  return T->isAnyCharacterType();\n}\n\nbool SAGenTestChecker::getFixedArraySizeFromMemberExpr(const\
  \ MemberExpr *ME, llvm::APInt &OutSize, QualType &ElemTy) const {\n  if (!ME)\n\
  \    return false;\n\n  const ValueDecl *VD = ME->getMemberDecl();\n  if (!VD)\n\
  \    return false;\n\n  QualType FT = VD->getType();\n  const Type *Ty = FT.getTypePtrOrNull();\n\
  \  if (!Ty)\n    return false;\n\n  if (const auto *CAT = dyn_cast<ConstantArrayType>(Ty))\
  \ {\n    ElemTy = CAT->getElementType();\n    OutSize = CAT->getSize();\n    return\
  \ true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getFixedArraySizeFromDestExpr(const\
  \ Expr *DestArg, llvm::APInt &OutSize, QualType &ElemTy, CheckerContext &C) const\
  \ {\n  if (!DestArg)\n    return false;\n\n  // Strip implicit casts\n  const Expr\
  \ *E = DestArg->IgnoreImplicit();\n\n  // Try DeclRefExpr path: dest refers directly\
  \ to an array variable.\n  if (const auto *DRE = findSpecificTypeInChildren<DeclRefExpr>(E))\
  \ {\n    const ValueDecl *VD = DRE->getDecl();\n    if (const auto *VarD = dyn_cast_or_null<VarDecl>(VD))\
  \ {\n      QualType VT = VarD->getType();\n      const Type *Ty = VT.getTypePtrOrNull();\n\
  \      if (!Ty)\n        return false;\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(Ty))\
  \ {\n        ElemTy = CAT->getElementType();\n        OutSize = CAT->getSize();\n\
  \        return true;\n      }\n    }\n    // Fallthrough if not a constant array\n\
  \  }\n\n  // Try MemberExpr path: struct/union fixed-size array field.\n  if (const\
  \ auto *ME = findSpecificTypeInChildren<MemberExpr>(E)) {\n    if (getFixedArraySizeFromMemberExpr(ME,\
  \ OutSize, ElemTy))\n      return true;\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // 1) Identify unbounded string-copy\
  \ functions.\n  if (!isUnboundedStringCopy(Call, C))\n    return;\n\n  // Expect\
  \ at least 2 arguments (dest, src).\n  if (Call.getNumArgs() < 2)\n    return;\n\
  \n  // 2) Analyze the destination argument to ensure it is a fixed-size char array.\n\
  \  const Expr *DestArg = Call.getArgExpr(0);\n  llvm::APInt Capacity;\n  QualType\
  \ ElemTy;\n\n  if (!getFixedArraySizeFromDestExpr(DestArg, Capacity, ElemTy, C))\n\
  \    return;\n\n  if (!isCharType(ElemTy))\n    return;\n\n  // 3) Inspect the source\
  \ argument.\n  const Expr *SrcArg = Call.getArgExpr(1);\n  llvm::APInt StringSize;\n\
  \n  // If the source is a string literal with a known length:\n  if (getStringSize(StringSize,\
  \ SrcArg)) {\n    // StringSize is number of characters excluding the null terminator.\n\
  \    // For strcpy/stpcpy/strcat, if StringSize >= Capacity, copy can't fit including\
  \ NUL.\n    if (StringSize.uge(Capacity)) {\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \      if (!N)\n        return;\n\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"Unbounded string copy into fixed-size buffer may overflow; use\
  \ strscpy with sizeof(dest).\", N);\n      if (const Stmt *S = Call.getOriginExpr())\n\
  \        R->addRange(S->getSourceRange());\n      C.emitReport(std::move(R));\n\
  \    }\n    // If StringSize < Capacity, don't warn: the literal definitely fits.\n\
  \    return;\n  }\n\n  // If not a string literal, we cannot prove safety. Report\
  \ as potentially overflowing.\n  {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Unbounded string copy into fixed-size buffer may overflow; use strscpy\
  \ with sizeof(dest).\", N);\n    if (const Stmt *S = Call.getOriginExpr())\n   \
  \   R->addRange(S->getSourceRange());\n    C.emitReport(std::move(R));\n  }\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unbounded string copy into fixed-size buffers (use strscpy with\
  \ sizeof(dest))\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
