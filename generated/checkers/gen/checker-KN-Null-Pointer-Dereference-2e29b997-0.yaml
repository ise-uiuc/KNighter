_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 2e29b9971ac54dec88baa58856a230ec2f2a2dff
commit_type: Null-Pointer-Dereference
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// No custom program states are needed.\n\
  \nnamespace {\nclass SAGenTestChecker : public Checker<check::BranchCondition> {\n\
  \   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Wrong NULL check after allocation\", \"Logic error\"\
  )) {}\n\n      void checkBranchCondition(const Stmt *Condition, CheckerContext &C)\
  \ const;\n\n   private:\n      // Extract the pointer expression being NULL-checked\
  \ in a condition.\n      const Expr *extractNullCheckedPtr(const Expr *Cond, CheckerContext\
  \ &C) const;\n      // Determine if a CallExpr calls a known allocator (e.g., kzalloc,\
  \ kmalloc, etc.).\n      bool isKnownAllocatorCall(const CallExpr *CE, CheckerContext\
  \ &C) const;\n      // Unwrap wrappers to reach the core expression (e.g., ExprWithCleanups).\n\
  \      const Expr *unwrapToCoreExpr(const Stmt *S) const;\n};\n\nconst Expr *SAGenTestChecker::unwrapToCoreExpr(const\
  \ Stmt *S) const {\n  const Stmt *Cur = S;\n  while (true) {\n    if (const auto\
  \ *EWC = dyn_cast<ExprWithCleanups>(Cur)) {\n      Cur = EWC->getSubExpr();\n  \
  \    continue;\n    }\n    if (const auto *FE = dyn_cast<FullExpr>(Cur)) {\n   \
  \   Cur = FE->getSubExpr();\n      continue;\n    }\n    break;\n  }\n  return dyn_cast<Expr>(Cur);\n\
  }\n\nbool SAGenTestChecker::isKnownAllocatorCall(const CallExpr *CE, CheckerContext\
  \ &C) const {\n  if (!CE)\n    return false;\n  const Expr *CalleeE = CE->getCallee();\n\
  \  if (!CalleeE)\n    return false;\n\n  // Use source-text-based name matching\
  \ for robustness as suggested.\n  static const char *Allocators[] = {\n    \"kzalloc\"\
  , \"kmalloc\", \"kcalloc\", \"kvzalloc\", \"vzalloc\", \"kvmalloc\",\n    \"devm_kzalloc\"\
  , \"devm_kmalloc\", \"devm_kcalloc\"\n  };\n  for (const char *Name : Allocators)\
  \ {\n    if (ExprHasName(CalleeE, Name, C))\n      return true;\n  }\n  return false;\n\
  }\n\nconst Expr *SAGenTestChecker::extractNullCheckedPtr(const Expr *Cond, CheckerContext\
  \ &C) const {\n  if (!Cond)\n    return nullptr;\n\n  const ASTContext &ACtx = C.getASTContext();\n\
  \  const Expr *E = Cond->IgnoreParenCasts();\n\n  if (const auto *UO = dyn_cast<UnaryOperator>(E))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *SubE = UO->getSubExpr()->IgnoreParenCasts();\n\
  \      if (SubE && SubE->getType()->isPointerType())\n        return SubE;\n   \
  \ }\n  } else if (const auto *BO = dyn_cast<BinaryOperator>(E)) {\n    BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n    if (Op == BO_EQ) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \      const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n      bool LHSIsNull\
  \ = LHS->isNullPointerConstant(ACtx, Expr::NPC_ValueDependentIsNull);\n      bool\
  \ RHSIsNull = RHS->isNullPointerConstant(ACtx, Expr::NPC_ValueDependentIsNull);\n\
  \n      if (LHSIsNull && RHS && RHS->getType()->isPointerType())\n        return\
  \ RHS;\n      if (RHSIsNull && LHS && LHS->getType()->isPointerType())\n       \
  \ return LHS;\n    }\n  }\n  return nullptr;\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!Condition)\n    return;\n\n\
  \  // Find the enclosing IfStmt for this condition.\n  const IfStmt *IfS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IfS)\n    return;\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n\
  \  if (!CondE)\n    return;\n\n  // Extract the pointer being NULL-checked in the\
  \ condition.\n  const Expr *CheckedPtrExpr = extractNullCheckedPtr(CondE, C);\n\
  \  if (!CheckedPtrExpr)\n    return;\n\n  // Find the enclosing compound statement\
  \ to get the previous sibling statement.\n  const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(IfS,\
  \ C);\n  if (!CS)\n    return;\n\n  // Locate IfS within CS and get the previous\
  \ statement.\n  const Stmt *PrevStmt = nullptr;\n  for (auto I = CS->body_begin(),\
  \ E = CS->body_end(); I != E; ++I) {\n    if (*I == IfS) {\n      if (I == CS->body_begin())\n\
  \        return; // No previous statement.\n      PrevStmt = *(std::prev(I));\n\
  \      break;\n    }\n  }\n  if (!PrevStmt)\n    return;\n\n  // Unwrap to core\
  \ expression.\n  const Expr *PrevCoreE = unwrapToCoreExpr(PrevStmt);\n  if (!PrevCoreE)\n\
  \    return;\n\n  // Ensure it's an assignment of the form LHS = allocatorCall(...);\n\
  \  const auto *BO = dyn_cast<BinaryOperator>(PrevCoreE);\n  if (!BO || BO->getOpcode()\
  \ != BO_Assign)\n    return;\n\n  const Expr *LHS = BO->getLHS(); // Do not IgnoreImplicit\
  \ before region extraction.\n  const Expr *RHS = BO->getRHS();\n  if (!LHS || !RHS)\n\
  \    return;\n\n  // RHS should be an allocator call.\n  const CallExpr *AllocCE\
  \ = dyn_cast<CallExpr>(RHS->IgnoreParenCasts());\n  if (!isKnownAllocatorCall(AllocCE,\
  \ C))\n    return;\n\n  // Both sides should be pointer-typed to be relevant.\n\
  \  if (!LHS->getType()->isPointerType())\n    return;\n  if (!CheckedPtrExpr->getType()->isPointerType())\n\
  \    return;\n\n  // Get memory regions for both the allocated pointer (LHS) and\
  \ the checked pointer.\n  const MemRegion *AllocMRRaw = getMemRegionFromExpr(LHS,\
  \ C);\n  const MemRegion *ChkMRRaw = getMemRegionFromExpr(CheckedPtrExpr, C);\n\
  \  if (!AllocMRRaw || !ChkMRRaw)\n    return;\n\n  const MemRegion *AllocMRBase\
  \ = AllocMRRaw->getBaseRegion();\n  const MemRegion *ChkMRBase = ChkMRRaw->getBaseRegion();\n\
  \  if (!AllocMRBase || !ChkMRBase)\n    return;\n\n  // We consider it a mismatch\
  \ if:\n  //  - The underlying root object is the same (same base region),\n  //\
  \  - But the specific regions differ (e.g., different fields).\n  if (AllocMRBase\
  \ == ChkMRBase && AllocMRRaw != ChkMRRaw) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Wrong pointer checked after allocation\", N);\n    R->addRange(IfS->getCond()->getSourceRange());\n\
  \    R->addRange(BO->getSourceRange());\n    C.emitReport(std::move(R));\n  }\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects checking a different pointer than the one just allocated (wrong\
  \ NULL check)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\narm64/sme: Fix NULL check after kzalloc\n\nFix following\
  \ coccicheck error:\n./arch/arm64/kernel/process.c:322:2-23: alloc with no test,\
  \ possible model on line 326\n\nHere should be dst->thread.sve_state.\n\nFixes:\
  \ 8bd7f91c03d8 (\"arm64/sme: Implement traps and syscall handling for SME\")\nSigned-off-by:\
  \ Wan Jiabing <wanjiabing@vivo.com>\nReviwed-by: Mark Brown <broonie@kernel.org>\n\
  Link: https://lore.kernel.org/r/20220426113054.630983-1-wanjiabing@vivo.com\nSigned-off-by:\
  \ Catalin Marinas <catalin.marinas@arm.com>\n\n## Buggy Code\n\n```c\n// Function:\
  \ arch_dup_task_struct in arch/arm64/kernel/process.c\nint arch_dup_task_struct(struct\
  \ task_struct *dst, struct task_struct *src)\n{\n\tif (current->mm)\n\t\tfpsimd_preserve_current_state();\n\
  \t*dst = *src;\n\n\t/* We rely on the above assignment to initialize dst's thread_flags:\
  \ */\n\tBUILD_BUG_ON(!IS_ENABLED(CONFIG_THREAD_INFO_IN_TASK));\n\n\t/*\n\t * Detach\
  \ src's sve_state (if any) from dst so that it does not\n\t * get erroneously used\
  \ or freed prematurely.  dst's copies\n\t * will be allocated on demand later on\
  \ if dst uses SVE.\n\t * For consistency, also clear TIF_SVE here: this could be\
  \ done\n\t * later in copy_process(), but to avoid tripping up future\n\t * maintainers\
  \ it is best not to leave TIF flags and buffers in\n\t * an inconsistent state,\
  \ even temporarily.\n\t */\n\tdst->thread.sve_state = NULL;\n\tclear_tsk_thread_flag(dst,\
  \ TIF_SVE);\n\n\t/*\n\t * In the unlikely event that we create a new thread with\
  \ ZA\n\t * enabled we should retain the ZA state so duplicate it here.\n\t * This\
  \ may be shortly freed if we exec() or if CLONE_SETTLS\n\t * but it's simpler to\
  \ do it here. To avoid confusing the rest\n\t * of the code ensure that we have\
  \ a sve_state allocated\n\t * whenever za_state is allocated.\n\t */\n\tif (thread_za_enabled(&src->thread))\
  \ {\n\t\tdst->thread.sve_state = kzalloc(sve_state_size(src),\n\t\t\t\t\t\tGFP_KERNEL);\n\
  \t\tif (!dst->thread.za_state)\n\t\t\treturn -ENOMEM;\n\t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n\t\t\t\t\t       za_state_size(src),\n\t\t\t\t\
  \t       GFP_KERNEL);\n\t\tif (!dst->thread.za_state) {\n\t\t\tkfree(dst->thread.sve_state);\n\
  \t\t\tdst->thread.sve_state = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\
  \tdst->thread.za_state = NULL;\n\t\tclear_tsk_thread_flag(dst, TIF_SME);\n\t}\n\n\
  \t/* clear any pending asynchronous tag fault raised by the parent */\n\tclear_tsk_thread_flag(dst,\
  \ TIF_MTE_ASYNC_FAULT);\n\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c\nindex 99c293513817..9734c9fb1a32\
  \ 100644\n--- a/arch/arm64/kernel/process.c\n+++ b/arch/arm64/kernel/process.c\n\
  @@ -321,7 +321,7 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct\
  \ *src)\n \tif (thread_za_enabled(&src->thread)) {\n \t\tdst->thread.sve_state =\
  \ kzalloc(sve_state_size(src),\n \t\t\t\t\t\tGFP_KERNEL);\n-\t\tif (!dst->thread.za_state)\n\
  +\t\tif (!dst->thread.sve_state)\n \t\t\treturn -ENOMEM;\n \t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n \t\t\t\t\t       za_state_size(src),\n```\n"
pattern: '## Bug Pattern


  Checking the wrong pointer for NULL after allocation. Specifically, after allocating
  dst->thread.sve_state with kzalloc(), the code mistakenly tests dst->thread.za_state
  instead of dst->thread.sve_state. Because the entire task_struct was previously
  copied from src, dst->thread.za_state may still be non-NULL, causing the allocation
  failure of sve_state to go undetected and leaving the structure in an inconsistent
  state.'
plan: "```\nGoal\nDetect cases where code allocates memory to a pointer Palloc (e.g.,\
  \ dst->thread.sve_state = kzalloc(...)) and then immediately checks a different\
  \ pointer Pchk for NULL (e.g., if (!dst->thread.za_state)), which likely indicates\
  \ checking the wrong pointer after allocation.\n\n1) Program State\n- No custom\
  \ program states are needed. We can detect this pattern purely from the AST structure\
  \ around the if-condition.\n\n2) Callbacks\n- Use only checkBranchCondition. This\
  \ is sufficient since we want to inspect the if-condition and the previous sibling\
  \ statement in the same block.\n\n3) Detailed Steps for checkBranchCondition\n-\
  \ Input: const Stmt *Condition, CheckerContext &C\n\n3.1) Identify IfStmt and extract\
  \ the checked pointer\n- Ascend from Condition to the enclosing IfStmt:\n  - Use\
  \ findSpecificTypeInParents<IfStmt>(Condition, C) to get the IfStmt.\n  - Bail if\
  \ not found.\n- From the IfStmt, extract the condition expression and detect if\
  \ it is a NULL-check on a pointer:\n  - Supported condition shapes:\n    - UnaryOperator\
  \ \u2018!\u2019 applied to a pointer expression E: if (!E)\n    - BinaryOperator\
  \ \u2018==\u2019 comparing a pointer expression E with NULL/0: if (E == NULL) or\
  \ if (E == 0) or if (NULL == E)\n    - (Optionally) BinaryOperator \u2018!=\u2019\
  \ can be handled too; but focus on failure checks: \u2018!\u2019 and \u2018== NULL\u2019\
  .\n  - Implement helper extractNullCheckedPtr(const Expr *Cond, CheckerContext &C)\
  \ -> const Expr*:\n    - For UnaryOperator with opcode UO_LNot: return its subexpression\
  \ if it's a pointer type.\n    - For BinaryOperator with opcode BO_EQ (and optionally\
  \ BO_NE):\n       - If one operand is a null literal (IntegerLiteral 0, GNUNullExpr,\
  \ CXXNullPtrLiteralExpr) and the other is a pointer-type expression, return the\
  \ pointer operand.\n    - Otherwise return nullptr.\n  - Let PchkExpr be the extracted\
  \ pointer expression, otherwise bail.\n\n3.2) Find the previous statement and see\
  \ if it is an allocation into some pointer\n- Ascend to the immediate CompoundStmt\
  \ that contains the IfStmt:\n  - Use findSpecificTypeInParents<CompoundStmt>(IfStmt,\
  \ C).\n  - Bail if not found.\n- Locate the IfStmt within the CompoundStmt\u2019\
  s body and get its previous sibling statement:\n  - Iterate the children of the\
  \ CompoundStmt to find the IfStmt pointer; if index i > 0, let Prev = Body[i-1].\
  \ Otherwise bail.\n- Normalize Prev to the effective inner expression if it\u2019\
  s wrapped:\n  - If Prev is an ExprWithCleanups, get its subexpression.\n  - Expect\
  \ an Expr or an ExprStmt holding a BinaryOperator.\n- Check if Prev is an assignment\
  \ of the form LHS = CallExpr(...):\n  - The core pattern we want: BinaryOperator\
  \ with opcode BO_Assign.\n  - RHS should be a CallExpr (the allocator call).\n \
  \ - LHS should be a pointer-like lvalue (DeclRefExpr, MemberExpr, etc.).\n- Verify\
  \ the callee is a known allocator that returns NULL on failure:\n  - Extract the\
  \ callee name using CE->getDirectCallee()->getNameAsString().\n  - Match against\
  \ a small allowlist: {\"kzalloc\", \"kmalloc\", \"kcalloc\", \"kvzalloc\", \"vzalloc\"\
  , \"kvmalloc\", \"devm_kzalloc\", \"devm_kmalloc\", \"devm_kcalloc\"}.\n  - If not\
  \ in the list, bail.\n\n3.3) Compare the pointer being checked vs. the pointer that\
  \ was allocated\n- Obtain MemRegions for both expressions:\n  - PallocRegion = getMemRegionFromExpr(LHS_of_assignment,\
  \ C)\n  - PchkRegion   = getMemRegionFromExpr(PchkExpr, C)\n- If both regions are\
  \ non-null and different (pointer-inequality by region pointer), treat this as a\
  \ mismatch and candidate bug.\n- If either region is null (region extraction failed),\
  \ apply a textual fallback heuristic to reduce false positives:\n  - Try to get\
  \ leaf member names if expressions are MemberExprs (e.g., \".sve_state\" vs \".za_state\"\
  ).\n  - If that\u2019s not easily accessible, use ExprHasName(LHS, \"sve_state\"\
  /\"za_state\") as a fallback:\n    - If LHS contains a field name different from\
  \ the field name in the if-condition, consider it a mismatch.\n- Optional sanity\
  \ checks to further reduce noise:\n  - Ensure both expressions are of pointer type\
  \ (check QualType->isPointerType()).\n  - Optionally ensure they share the same\
  \ base object (if the regions are field regions under the same base), by comparing\
  \ base regions (Region->getBaseRegion()) if available.\n\n3.4) Report the bug\n\
  - If a mismatch is detected:\n  - Create a BugType once (e.g., \"Wrong NULL check\
  \ after allocation\").\n  - Create a non-fatal error node (C.generateNonFatalErrorNode())\
  \ and emit a PathSensitiveBugReport or BasicBugReport.\n  - Report location: point\
  \ to the IfStmt condition range to highlight the wrong check.\n  - Short message:\
  \ \"Wrong pointer checked after allocation\".\n  - Optionally add a note/range on\
  \ the previous assignment to show the allocated target.\n\n4) Notes and Heuristics\n\
  - The checker only warns when the if-condition immediately follows the allocation\
  \ assignment in the same compound block; this minimizes false positives and matches\
  \ the target bug pattern.\n- Focus primarily on failure-style checks: if (!ptr)\
  \ or if (ptr == NULL). Supporting \u2018!= NULL\u2019 is optional.\n- The approach\
  \ is AST-local; no path-sensitive state or alias tracking is needed.\n\n5) Utility\
  \ Functions Used\n- findSpecificTypeInParents<T>(...)\n- getMemRegionFromExpr(...)\n\
  - ExprHasName(...)\n\n6) Chosen Clang Static Analyzer Hooks\n- checkBranchCondition:\
  \ Core logic implemented here. No other hooks are required.\n```"
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// No custom program states are needed.\n\
  \nnamespace {\nclass SAGenTestChecker : public Checker<check::BranchCondition> {\n\
  \   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Wrong NULL check after allocation\", \"Logic error\"\
  )) {}\n\n      void checkBranchCondition(const Stmt *Condition, CheckerContext &C)\
  \ const;\n\n   private:\n      // Extract the pointer expression being NULL-checked\
  \ in a condition.\n      const Expr *extractNullCheckedPtr(const Expr *Cond, CheckerContext\
  \ &C) const;\n      // Determine if a CallExpr calls a known allocator (e.g., kzalloc,\
  \ kmalloc, etc.).\n      bool isKnownAllocatorCall(const CallExpr *CE, CheckerContext\
  \ &C) const;\n      // Unwrap wrappers to reach the core expression (e.g., ExprWithCleanups).\n\
  \      const Expr *unwrapToCoreExpr(const Stmt *S) const;\n};\n\nconst Expr *SAGenTestChecker::unwrapToCoreExpr(const\
  \ Stmt *S) const {\n  const Stmt *Cur = S;\n  while (true) {\n    if (const auto\
  \ *EWC = dyn_cast<ExprWithCleanups>(Cur)) {\n      Cur = EWC->getSubExpr();\n  \
  \    continue;\n    }\n    if (const auto *FE = dyn_cast<FullExpr>(Cur)) {\n   \
  \   Cur = FE->getSubExpr();\n      continue;\n    }\n    break;\n  }\n  return dyn_cast<Expr>(Cur);\n\
  }\n\nbool SAGenTestChecker::isKnownAllocatorCall(const CallExpr *CE, CheckerContext\
  \ &C) const {\n  if (!CE)\n    return false;\n  const Expr *CalleeE = CE->getCallee();\n\
  \  if (!CalleeE)\n    return false;\n\n  // Use source-text-based name matching\
  \ for robustness as suggested.\n  static const char *Allocators[] = {\n    \"kzalloc\"\
  , \"kmalloc\", \"kcalloc\", \"kvzalloc\", \"vzalloc\", \"kvmalloc\",\n    \"devm_kzalloc\"\
  , \"devm_kmalloc\", \"devm_kcalloc\"\n  };\n  for (const char *Name : Allocators)\
  \ {\n    if (ExprHasName(CalleeE, Name, C))\n      return true;\n  }\n  return false;\n\
  }\n\nconst Expr *SAGenTestChecker::extractNullCheckedPtr(const Expr *Cond, CheckerContext\
  \ &C) const {\n  if (!Cond)\n    return nullptr;\n\n  ASTContext &ACtx = C.getASTContext();\n\
  \  const Expr *E = Cond->IgnoreParenCasts();\n\n  if (const auto *UO = dyn_cast<UnaryOperator>(E))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *SubE = UO->getSubExpr()->IgnoreParenCasts();\n\
  \      if (SubE && SubE->getType()->isPointerType())\n        return SubE;\n   \
  \ }\n  } else if (const auto *BO = dyn_cast<BinaryOperator>(E)) {\n    BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n    if (Op == BO_EQ) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \      const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n      bool LHSIsNull\
  \ = LHS->isNullPointerConstant(ACtx, Expr::NPC_ValueDependentIsNull);\n      bool\
  \ RHSIsNull = RHS->isNullPointerConstant(ACtx, Expr::NPC_ValueDependentIsNull);\n\
  \n      if (LHSIsNull && RHS && RHS->getType()->isPointerType())\n        return\
  \ RHS;\n      if (RHSIsNull && LHS && LHS->getType()->isPointerType())\n       \
  \ return LHS;\n    }\n  }\n  return nullptr;\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!Condition)\n    return;\n\n\
  \  // Find the enclosing IfStmt for this condition.\n  const IfStmt *IfS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IfS)\n    return;\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n\
  \  if (!CondE)\n    return;\n\n  // Extract the pointer being NULL-checked in the\
  \ condition.\n  const Expr *CheckedPtrExpr = extractNullCheckedPtr(CondE, C);\n\
  \  if (!CheckedPtrExpr)\n    return;\n\n  // Find the enclosing compound statement\
  \ to get the previous sibling statement.\n  const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(IfS,\
  \ C);\n  if (!CS)\n    return;\n\n  // Locate IfS within CS and get the previous\
  \ statement.\n  const Stmt *PrevStmt = nullptr;\n  for (auto I = CS->body_begin(),\
  \ E = CS->body_end(); I != E; ++I) {\n    if (*I == IfS) {\n      if (I == CS->body_begin())\n\
  \        return; // No previous statement.\n      PrevStmt = *(std::prev(I));\n\
  \      break;\n    }\n  }\n  if (!PrevStmt)\n    return;\n\n  // Unwrap to core\
  \ expression.\n  const Expr *PrevCoreE = unwrapToCoreExpr(PrevStmt);\n  if (!PrevCoreE)\n\
  \    return;\n\n  // Ensure it's an assignment of the form LHS = allocatorCall(...);\n\
  \  const auto *BO = dyn_cast<BinaryOperator>(PrevCoreE);\n  if (!BO || BO->getOpcode()\
  \ != BO_Assign)\n    return;\n\n  const Expr *LHS = BO->getLHS(); // Do not IgnoreImplicit\
  \ before region extraction.\n  const Expr *RHS = BO->getRHS();\n  if (!LHS || !RHS)\n\
  \    return;\n\n  // RHS should be an allocator call.\n  const CallExpr *AllocCE\
  \ = dyn_cast<CallExpr>(RHS->IgnoreParenCasts());\n  if (!isKnownAllocatorCall(AllocCE,\
  \ C))\n    return;\n\n  // Both sides should be pointer-typed to be relevant.\n\
  \  if (!LHS->getType()->isPointerType())\n    return;\n  if (!CheckedPtrExpr->getType()->isPointerType())\n\
  \    return;\n\n  // Get memory regions for both the allocated pointer (LHS) and\
  \ the checked pointer.\n  const MemRegion *AllocMRRaw = getMemRegionFromExpr(LHS,\
  \ C);\n  const MemRegion *ChkMRRaw = getMemRegionFromExpr(CheckedPtrExpr, C);\n\
  \  if (!AllocMRRaw || !ChkMRRaw)\n    return;\n\n  const MemRegion *AllocMRBase\
  \ = AllocMRRaw->getBaseRegion();\n  const MemRegion *ChkMRBase = ChkMRRaw->getBaseRegion();\n\
  \  if (!AllocMRBase || !ChkMRBase)\n    return;\n\n  // We consider it a mismatch\
  \ if:\n  //  - The underlying root object is the same (same base region),\n  //\
  \  - But the specific regions differ (e.g., different fields).\n  if (AllocMRBase\
  \ == ChkMRBase && AllocMRRaw != ChkMRRaw) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Wrong pointer checked after allocation\", N);\n    R->addRange(IfS->getCond()->getSourceRange());\n\
  \    R->addRange(BO->getSourceRange());\n    C.emitReport(std::move(R));\n  }\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects checking a different pointer than the one just allocated (wrong\
  \ NULL check)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
