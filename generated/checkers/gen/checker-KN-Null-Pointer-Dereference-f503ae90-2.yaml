_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: f503ae90c7355e8506e68498fe84c1357894cd5b
commit_type: Null-Pointer-Dereference
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include \"llvm/ADT/SmallPtrSet.h\"\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// Tracks pointers that may be NULL and are not\
  \ yet checked.\n// true => possibly NULL and unchecked; false => checked (non-NULL).\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(PossiblyNullPtrMap, const MemRegion*, bool)\n// Tracks\
  \ pointer aliases created by assignments/copies.\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap,\
  \ const MemRegion*, const MemRegion*)\n\nnamespace {\nclass SAGenTestChecker\n \
  \ : public Checker<\n      check::PostCall,\n      check::Bind,\n      check::BranchCondition,\n\
  \      check::PreStmt<MemberExpr>,\n      check::PreStmt<UnaryOperator>\n    > {\n\
  \   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"NULL dereference of capability pointer\", \"API Misuse\"\
  )) {}\n\n      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \      void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \      void checkPreStmt(const MemberExpr *ME, CheckerContext &C) const;\n     \
  \ void checkPreStmt(const UnaryOperator *UO, CheckerContext &C) const;\n\n   private:\n\
  \      // Helper: resolve alias root using PtrAliasMap (guard against cycles).\n\
  \      const MemRegion* resolveRoot(const MemRegion *R, ProgramStateRef State) const;\n\
  \n      // Helper: check if a call is to a known nullable getter.\n      bool isKnownNullableGetter(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n      // Helper: mark a pointer\
  \ as checked in PossiblyNullPtrMap.\n      ProgramStateRef markChecked(ProgramStateRef\
  \ State, const MemRegion *R) const;\n\n      // Helper: examine condition expression\
  \ and extract a pointer expr if it's a NULL-check form.\n      const Expr* getPtrExprFromCondition(const\
  \ Expr *CondE, CheckerContext &C) const;\n\n      // Reporting\n      void reportPossibleNullDeref(const\
  \ Stmt *S, CheckerContext &C) const;\n};\n\nconst MemRegion* SAGenTestChecker::resolveRoot(const\
  \ MemRegion *R, ProgramStateRef State) const {\n  if (!R)\n    return nullptr;\n\
  \n  const MemRegion *Cur = R->getBaseRegion();\n  llvm::SmallPtrSet<const MemRegion*,\
  \ 8> Visited;\n  Visited.insert(Cur);\n\n  while (true) {\n    const MemRegion *Next\
  \ = State->get<PtrAliasMap>(Cur);\n    if (!Next)\n      break;\n    Next = Next->getBaseRegion();\n\
  \    if (Next == Cur)\n      break;\n    if (!Visited.insert(Next).second)\n   \
  \   break;\n    Cur = Next;\n  }\n  return Cur;\n}\n\nbool SAGenTestChecker::isKnownNullableGetter(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  return ExprHasName(Origin, \"mt76_connac_get_he_phy_cap\"\
  , C);\n}\n\nProgramStateRef SAGenTestChecker::markChecked(ProgramStateRef State,\
  \ const MemRegion *R) const {\n  if (!R)\n    return State;\n  const MemRegion *Root\
  \ = resolveRoot(R, State);\n  if (!Root)\n    return State;\n\n  const bool *Cur\
  \ = State->get<PossiblyNullPtrMap>(Root);\n  if (Cur && *Cur == true) {\n    State\
  \ = State->set<PossiblyNullPtrMap>(Root, false);\n  }\n  return State;\n}\n\nconst\
  \ Expr* SAGenTestChecker::getPtrExprFromCondition(const Expr *CondE, CheckerContext\
  \ &C) const {\n  if (!CondE)\n    return nullptr;\n\n  CondE = CondE->IgnoreParenCasts();\n\
  \n  // if (!ptr)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE)) {\n   \
  \ if (UO->getOpcode() == UO_LNot) {\n      const Expr *SubE = UO->getSubExpr();\n\
  \      return SubE ? SubE->IgnoreParenCasts() : nullptr;\n    }\n  }\n\n  // if\
  \ (ptr == NULL) or if (ptr != NULL)\n  if (const auto *BO = dyn_cast<BinaryOperator>(CondE))\
  \ {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n    if (Op == BO_EQ || Op\
  \ == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n     \
  \ const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n      llvm::APSInt Val;\n\
  \      bool LHSIsZero = EvaluateExprToInt(Val, LHS, C) && Val == 0;\n      bool\
  \ RHSIsZero = EvaluateExprToInt(Val, RHS, C) && Val == 0;\n\n      if (!LHSIsZero\
  \ && RHSIsZero)\n        return LHS;\n      if (!RHSIsZero && LHSIsZero)\n     \
  \   return RHS;\n\n      // Fallback for macro NULL name\n      if (!LHSIsZero &&\
  \ ExprHasName(RHS, \"NULL\", C))\n        return LHS;\n      if (!RHSIsZero && ExprHasName(LHS,\
  \ \"NULL\", C))\n        return RHS;\n    }\n  }\n\n  // if (ptr)\n  // For bare\
  \ pointer in condition, we consider it a check use.\n  return CondE;\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  if (!isKnownNullableGetter(Call, C))\n    return;\n\n  ProgramStateRef State\
  \ = C.getState();\n  const Expr *E = Call.getOriginExpr();\n  if (!E)\n    return;\n\
  \n  const MemRegion *MR = getMemRegionFromExpr(E, C);\n  if (!MR)\n    return;\n\
  \  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\n  // Mark return value\
  \ as possibly NULL and unchecked.\n  State = State->set<PossiblyNullPtrMap>(MR,\
  \ true);\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\
  \ {\n    C.addTransition(State);\n    return;\n  }\n  LHSReg = LHSReg->getBaseRegion();\n\
  \  if (!LHSReg) {\n    C.addTransition(State);\n    return;\n  }\n\n  // If binding\
  \ a pointer value from another region, record alias and propagate status.\n  if\
  \ (const MemRegion *RHSReg = Val.getAsRegion()) {\n    RHSReg = RHSReg->getBaseRegion();\n\
  \    if (RHSReg) {\n      const MemRegion *LRoot = resolveRoot(LHSReg, State);\n\
  \      const MemRegion *RRoot = resolveRoot(RHSReg, State);\n      if (LRoot &&\
  \ RRoot) {\n        State = State->set<PtrAliasMap>(LRoot, RRoot);\n        State\
  \ = State->set<PtrAliasMap>(RRoot, LRoot);\n\n        if (const bool *Flag = State->get<PossiblyNullPtrMap>(RRoot))\
  \ {\n          State = State->set<PossiblyNullPtrMap>(LRoot, *Flag);\n        }\n\
  \      }\n    }\n  } else {\n    // If assigned a concrete NULL, mark as possibly\
  \ NULL and unchecked.\n    if (Val.isZeroConstant()) {\n      const MemRegion *LRoot\
  \ = resolveRoot(LHSReg, State);\n      if (LRoot)\n        State = State->set<PossiblyNullPtrMap>(LRoot,\
  \ true);\n    }\n  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE) {\n    C.addTransition(C.getState());\n    return;\n  }\n\n  const\
  \ Expr *PtrExpr = getPtrExprFromCondition(CondE, C);\n  if (!PtrExpr) {\n    C.addTransition(C.getState());\n\
  \    return;\n  }\n\n  ProgramStateRef State = C.getState();\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(PtrExpr, C);\n  if (MR) {\n    MR = MR->getBaseRegion();\n\
  \    if (MR) {\n      State = markChecked(State, MR);\n    }\n  }\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkPreStmt(const MemberExpr *ME, CheckerContext &C)\
  \ const {\n  if (!ME || !ME->isArrow())\n    return;\n\n  const Expr *Base = ME->getBase();\n\
  \  if (!Base)\n    return;\n\n  ProgramStateRef State = C.getState();\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(Base, C);\n  if (!MR)\n    return;\n\n  MR = MR->getBaseRegion();\n\
  \  if (!MR)\n    return;\n\n  const MemRegion *Root = resolveRoot(MR, State);\n\
  \  if (!Root)\n    return;\n\n  const bool *Flag = State->get<PossiblyNullPtrMap>(Root);\n\
  \  if (Flag && *Flag) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Possible NULL dereference of capability pointer (mt76_connac_get_he_phy_cap)\"\
  , N);\n    R->addRange(ME->getSourceRange());\n    C.emitReport(std::move(R));\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkPreStmt(const UnaryOperator *UO, CheckerContext\
  \ &C) const {\n  if (!UO || UO->getOpcode() != UO_Deref)\n    return;\n\n  const\
  \ Expr *SubE = UO->getSubExpr();\n  if (!SubE)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  const MemRegion *MR = getMemRegionFromExpr(SubE, C);\n\
  \  if (!MR)\n    return;\n\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  const MemRegion *Root = resolveRoot(MR, State);\n  if (!Root)\n    return;\n\
  \n  const bool *Flag = State->get<PossiblyNullPtrMap>(Root);\n  if (Flag && *Flag)\
  \ {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n    if (!N)\n      return;\n\
  \n    auto R = std::make_unique<PathSensitiveBugReport>(\n        *BT, \"Possible\
  \ NULL dereference of capability pointer (mt76_connac_get_he_phy_cap)\", N);\n \
  \   R->addRange(UO->getSourceRange());\n    C.emitReport(std::move(R));\n  }\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects dereferencing result of mt76_connac_get_he_phy_cap without NULL\
  \ check\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nwifi: mt76: mt7996: fix NULL pointer dereference in\
  \ mt7996_mcu_sta_bfer_he\n\nFix the NULL pointer dereference in mt7996_mcu_sta_bfer_he\n\
  routine adding an sta interface to the mt7996 driver.\n\nFound by code review.\n\
  \nCc: stable@vger.kernel.org\nFixes: 98686cd21624 (\"wifi: mt76: mt7996: add driver\
  \ for MediaTek Wi-Fi 7 (802.11be) devices\")\nSigned-off-by: Ma Ke <make24@iscas.ac.cn>\n\
  Link: https://patch.msgid.link/20240813081242.3991814-1-make24@iscas.ac.cn\nSigned-off-by:\
  \ Felix Fietkau <nbd@nbd.name>\n\n## Buggy Code\n\n```c\n// Function: mt7996_mcu_sta_bfer_he\
  \ in drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nstatic void\nmt7996_mcu_sta_bfer_he(struct\
  \ ieee80211_sta *sta, struct ieee80211_vif *vif,\n\t\t       struct mt7996_phy *phy,\
  \ struct sta_rec_bf *bf)\n{\n\tstruct ieee80211_sta_he_cap *pc = &sta->deflink.he_cap;\n\
  \tstruct ieee80211_he_cap_elem *pe = &pc->he_cap_elem;\n\tconst struct ieee80211_sta_he_cap\
  \ *vc =\n\t\tmt76_connac_get_he_phy_cap(phy->mt76, vif);\n\tconst struct ieee80211_he_cap_elem\
  \ *ve = &vc->he_cap_elem;\n\tu16 mcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80);\n\
  \tu8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\tu8 snd_dim, sts;\n\n\tbf->tx_mode\
  \ = MT_PHY_TYPE_HE_SU;\n\n\tmt7996_mcu_sta_sounding_rate(bf);\n\n\tbf->trigger_su\
  \ = HE_PHY(CAP6_TRIG_SU_BEAMFORMING_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\tbf->trigger_mu\
  \ = HE_PHY(CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\
  \tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK,\n\t\t\t ve->phy_cap_info[5]);\n\
  \tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_MASK,\n\t\t     pe->phy_cap_info[4]);\n\
  \tbf->nrow = min_t(u8, snd_dim, sts);\n\tbf->ncol = min_t(u8, nss_mcs, bf->nrow);\n\
  \tbf->ibf_ncol = bf->ncol;\n\n\tif (sta->deflink.bandwidth != IEEE80211_STA_RX_BW_160)\n\
  \t\treturn;\n\n\t/* go over for 160MHz and 80p80 */\n\tif (pe->phy_cap_info[0] &\n\
  \t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G) {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_160);\n\
  \t\tnss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\n\t\tbf->ncol_gt_bw80 = nss_mcs;\n\
  \t}\n\n\tif (pe->phy_cap_info[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)\
  \ {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80p80);\n\t\tnss_mcs =\
  \ mt7996_mcu_get_sta_nss(mcs_map);\n\n\t\tif (bf->ncol_gt_bw80)\n\t\t\tbf->ncol_gt_bw80\
  \ = min_t(u8, bf->ncol_gt_bw80, nss_mcs);\n\t\telse\n\t\t\tbf->ncol_gt_bw80 = nss_mcs;\n\
  \t}\n\n\tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_MASK,\n\t\t\t\
  \ ve->phy_cap_info[5]);\n\tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_MASK,\n\
  \t\t     pe->phy_cap_info[4]);\n\n\tbf->nrow_gt_bw80 = min_t(int, snd_dim, sts);\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\
  \ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nindex e8d34bfbb41a..8855095fef10\
  \ 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n\
  @@ -1544,6 +1544,9 @@ mt7996_mcu_sta_bfer_he(struct ieee80211_sta *sta, struct ieee80211_vif\
  \ *vif,\n \tu8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n \tu8 snd_dim, sts;\n\
  \ \n+\tif (!vc)\n+\t\treturn;\n+\n \tbf->tx_mode = MT_PHY_TYPE_HE_SU;\n \n \tmt7996_mcu_sta_sounding_rate(bf);\n\
  ```\n"
pattern: '## Bug Pattern


  Using a pointer returned from a capability-retrieval helper (mt76_connac_get_he_phy_cap())
  without checking for NULL, then immediately dereferencing it (e.g., ve = &vc->he_cap_elem;
  ve->phy_cap_info[...]): this leads to a NULL pointer dereference when the helper
  can validly return NULL (e.g., unsupported HE capability).'
plan: "1) Program state\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(PossiblyNullPtrMap, const\
  \ MemRegion*, bool)\n  - Tracks pointers that may be NULL and are not yet checked.\n\
  \  - Value true means \u201Cpossibly NULL and unchecked\u201D; false means \u201C\
  checked (non-NULL)\u201D.\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const\
  \ MemRegion*, const MemRegion*)\n  - Tracks pointer aliases created by assignments/copies.\n\
  \  - Always resolve through this map to find the ultimate base region to query/update\
  \ in PossiblyNullPtrMap.\n\n- Helper: resolveRoot(const MemRegion* R, ProgramStateRef\
  \ S)\n  - Follow PtrAliasMap chain to the ultimate base region (guard against cycles).\n\
  \  - Always use root when reading/writing PossiblyNullPtrMap.\n\n2) Known nullable-return\
  \ helper\n\n- Implement isKnownNullableGetter(const CallEvent &Call):\n  - Return\
  \ true when the callee name is \"mt76_connac_get_he_phy_cap\".\n  - (Optionally,\
  \ keep a small string list in case more getters appear.)\n\n3) checkPostCall\n\n\
  - Purpose: mark return values from known capability getters as possibly NULL (unchecked).\n\
  - Steps:\n  - If isKnownNullableGetter(Call) is true:\n    - Obtain the region representing\
  \ the call\u2019s return using getMemRegionFromExpr(Call.getOriginExpr(), C).\n\
  \    - If non-null, resolve root and set PossiblyNullPtrMap[root] = true.\n  - Do\
  \ nothing for other calls.\n\n4) checkBind\n\n- Purpose: track pointer aliasing\
  \ and propagate possibly-null status.\n- Steps:\n  - Only handle pointer-typed bindings:\n\
  \    - Obtain LHS region (Loc) with getAsRegion() from Loc; obtain RHS region from\
  \ Val (getAsRegion()).\n    - If both regions exist:\n      - Update PtrAliasMap[LHSroot]\
  \ = RHSroot (use resolveRoot for both ends).\n      - If RHSroot is in PossiblyNullPtrMap,\
  \ copy its boolean to LHSroot (i.e., set PossiblyNullPtrMap[LHSroot] = PossiblyNullPtrMap[RHSroot]).\n\
  \  - If RHS is a concrete null (Val.isZeroConstant()) and LHS is a region, it is\
  \ safe to set PossiblyNullPtrMap[LHSroot] = true (still \u201Cunchecked\u201D),\
  \ since it models that LHS may be NULL without a check.\n\n5) checkBranchCondition\n\
  \n- Purpose: mark a pointer as \u201Cchecked\u201D when the condition tests it against\
  \ NULL (or truthiness).\n- Steps:\n  - Strip parens/implicit casts from Condition.\n\
  \  - Recognize these forms and extract the tested pointer expression Eptr:\n   \
  \ - if (ptr) or if (!ptr):\n      - UnaryOperator with opcode UO_LNot -> Eptr is\
  \ subexpr.\n      - Bare DeclRefExpr/MemberExpr/ImplicitCastExpr -> Eptr is the\
  \ expression itself.\n    - if (ptr == NULL) or if (ptr != NULL):\n      - BinaryOperator\
  \ with op == or !=; detect which side is NULL:\n        - Use EvaluateExprToInt\
  \ on each side; if result == 0, treat that side as NULL.\n        - Alternatively,\
  \ fall back to ExprHasName(side, \"NULL\", C) for macro NULL.\n      - Eptr is the\
  \ non-NULL side.\n  - From Eptr, get its region via getMemRegionFromExpr(Eptr, C).\n\
  \  - If region exists:\n    - resolve root.\n    - Mark PossiblyNullPtrMap[root]\
  \ = false (checked).\n    - Also consider propagating to direct aliases: iterate\
  \ PtrAliasMap entries where value equals root and set those to false as well (optional\
  \ but helpful).\n\n6) checkPreStmt for MemberExpr\n\n- Purpose: detect dereference\
  \ via \u201C->\u201D on a pointer that may be NULL and is not checked.\n- Steps:\n\
  \  - Implement checkPreStmt(const MemberExpr *ME, CheckerContext &C).\n  - If ME->isArrow()\
  \ is false, ignore.\n  - Get the base expression: const Expr *Base = ME->getBase();\n\
  \  - Get its region: const MemRegion *R = getMemRegionFromExpr(Base, C).\n  - If\
  \ no region, return.\n  - Resolve root = resolveRoot(R, State).\n  - Query PossiblyNullPtrMap[root]:\n\
  \    - If found and true (unchecked), report a bug at ME:\n      - Generate a non-fatal\
  \ error node and emit a PathSensitiveBugReport with message:\n        - \"Possible\
  \ NULL dereference of capability pointer (mt76_connac_get_he_phy_cap)\"\n      -\
  \ Add ME->getSourceRange() as the report range.\n    - Otherwise, do nothing.\n\n\
  7) checkPreStmt for UnaryOperator (optional but recommended)\n\n- Purpose: catch\
  \ other pointer dereferences via \u201C*ptr\u201D.\n- Steps:\n  - Implement checkPreStmt(const\
  \ UnaryOperator *UO, CheckerContext &C).\n  - If UO->getOpcode() != UO_Deref, ignore.\n\
  \  - Get subexpr region via getMemRegionFromExpr(UO->getSubExpr(), C).\n  - Resolve\
  \ root; query PossiblyNullPtrMap[root] and report as in step 6.\n\n8) Additional\
  \ considerations\n\n- When a pointer is compared to NULL (BranchCondition) and then\
  \ there is a return on the NULL branch, CSA will path-split; even if we simply mark\
  \ \u201Cchecked\u201D without distinguishing true/false branches, usual patterns\
  \ like \u201Cif (!p) return; p->...\u201D will be marked as checked before the dereference\
  \ along the non-NULL path, preventing false positives.\n- Keep the checker focused\
  \ and simple: only flag dereferences of pointers originating from the known nullable\
  \ capability getter. This minimizes noise.\n\n9) Bug report\n\n- Use std::make_unique<PathSensitiveBugReport>\
  \ with a short message:\n  - \"Possible NULL dereference of capability pointer (mt76_connac_get_he_phy_cap)\"\
  \n- Anchor the report at the MemberExpr (or UnaryOperator) that dereferences the\
  \ pointer.\n\n10) Summary of callbacks used and their roles\n\n- checkPostCall:\
  \ identify and tag possibly-null return values from mt76_connac_get_he_phy_cap.\n\
  - checkBind: maintain aliasing and propagate possibly-null flag.\n- checkBranchCondition:\
  \ mark pointers as checked when a NULL-check is observed.\n- checkPreStmt<MemberExpr>:\
  \ detect \u201C->\u201D dereference on unchecked possibly-null pointers and report.\n\
  - checkPreStmt<UnaryOperator>: detect \u201C*ptr\u201D dereference on unchecked\
  \ possibly-null pointers and report."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include \"llvm/ADT/SmallPtrSet.h\"\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// Tracks pointers that may be NULL and are not\
  \ yet checked.\n// true => possibly NULL and unchecked; false => checked (non-NULL).\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(PossiblyNullPtrMap, const MemRegion*, bool)\n// Tracks\
  \ pointer aliases created by assignments/copies.\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap,\
  \ const MemRegion*, const MemRegion*)\n\nnamespace {\nclass SAGenTestChecker\n \
  \ : public Checker<\n      check::PostCall,\n      check::Bind,\n      check::BranchCondition,\n\
  \      check::PreStmt<MemberExpr>,\n      check::PreStmt<UnaryOperator>\n    > {\n\
  \   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"NULL dereference of capability pointer\", \"API Misuse\"\
  )) {}\n\n      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \      void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \      void checkPreStmt(const MemberExpr *ME, CheckerContext &C) const;\n     \
  \ void checkPreStmt(const UnaryOperator *UO, CheckerContext &C) const;\n\n   private:\n\
  \      // Helper: resolve alias root using PtrAliasMap (guard against cycles).\n\
  \      const MemRegion* resolveRoot(const MemRegion *R, ProgramStateRef State) const;\n\
  \n      // Helper: check if a call is to a known nullable getter.\n      bool isKnownNullableGetter(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n      // Helper: mark a pointer\
  \ as checked in PossiblyNullPtrMap.\n      ProgramStateRef markChecked(ProgramStateRef\
  \ State, const MemRegion *R) const;\n\n      // Helper: examine condition expression\
  \ and extract a pointer expr if it's a NULL-check form.\n      const Expr* getPtrExprFromCondition(const\
  \ Expr *CondE, CheckerContext &C) const;\n\n      // Reporting\n      void reportPossibleNullDeref(const\
  \ Stmt *S, CheckerContext &C) const;\n};\n\nconst MemRegion* SAGenTestChecker::resolveRoot(const\
  \ MemRegion *R, ProgramStateRef State) const {\n  if (!R)\n    return nullptr;\n\
  \n  const MemRegion *Cur = R->getBaseRegion();\n  llvm::SmallPtrSet<const MemRegion*,\
  \ 8> Visited;\n  Visited.insert(Cur);\n\n  while (true) {\n    const MemRegion *const\
  \ *NextPtr = State->get<PtrAliasMap>(Cur);\n    if (!NextPtr)\n      break;\n  \
  \  const MemRegion *Next = (*NextPtr)->getBaseRegion();\n    if (Next == Cur)\n\
  \      break;\n    if (!Visited.insert(Next).second)\n      break;\n    Cur = Next;\n\
  \  }\n  return Cur;\n}\n\nbool SAGenTestChecker::isKnownNullableGetter(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  return ExprHasName(Origin, \"mt76_connac_get_he_phy_cap\"\
  , C);\n}\n\nProgramStateRef SAGenTestChecker::markChecked(ProgramStateRef State,\
  \ const MemRegion *R) const {\n  if (!R)\n    return State;\n  const MemRegion *Root\
  \ = resolveRoot(R, State);\n  if (!Root)\n    return State;\n\n  const bool *Cur\
  \ = State->get<PossiblyNullPtrMap>(Root);\n  if (Cur && *Cur == true) {\n    State\
  \ = State->set<PossiblyNullPtrMap>(Root, false);\n  }\n  return State;\n}\n\nconst\
  \ Expr* SAGenTestChecker::getPtrExprFromCondition(const Expr *CondE, CheckerContext\
  \ &C) const {\n  if (!CondE)\n    return nullptr;\n\n  CondE = CondE->IgnoreParenCasts();\n\
  \n  // if (!ptr)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE)) {\n   \
  \ if (UO->getOpcode() == UO_LNot) {\n      const Expr *SubE = UO->getSubExpr();\n\
  \      return SubE ? SubE->IgnoreParenCasts() : nullptr;\n    }\n  }\n\n  // if\
  \ (ptr == NULL) or if (ptr != NULL)\n  if (const auto *BO = dyn_cast<BinaryOperator>(CondE))\
  \ {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n    if (Op == BO_EQ || Op\
  \ == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n     \
  \ const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n      llvm::APSInt Val;\n\
  \      bool LHSIsZero = EvaluateExprToInt(Val, LHS, C) && Val == 0;\n      bool\
  \ RHSIsZero = EvaluateExprToInt(Val, RHS, C) && Val == 0;\n\n      if (!LHSIsZero\
  \ && RHSIsZero)\n        return LHS;\n      if (!RHSIsZero && LHSIsZero)\n     \
  \   return RHS;\n\n      // Fallback for macro NULL name\n      if (!LHSIsZero &&\
  \ ExprHasName(RHS, \"NULL\", C))\n        return LHS;\n      if (!RHSIsZero && ExprHasName(LHS,\
  \ \"NULL\", C))\n        return RHS;\n    }\n  }\n\n  // if (ptr)\n  // For bare\
  \ pointer in condition, we consider it a check use.\n  return CondE;\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  if (!isKnownNullableGetter(Call, C))\n    return;\n\n  ProgramStateRef State\
  \ = C.getState();\n  const Expr *E = Call.getOriginExpr();\n  if (!E)\n    return;\n\
  \n  const MemRegion *MR = getMemRegionFromExpr(E, C);\n  if (!MR)\n    return;\n\
  \  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\n  // Mark return value\
  \ as possibly NULL and unchecked.\n  State = State->set<PossiblyNullPtrMap>(MR,\
  \ true);\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\
  \ {\n    C.addTransition(State);\n    return;\n  }\n  LHSReg = LHSReg->getBaseRegion();\n\
  \  if (!LHSReg) {\n    C.addTransition(State);\n    return;\n  }\n\n  // If binding\
  \ a pointer value from another region, record alias and propagate status.\n  if\
  \ (const MemRegion *RHSReg = Val.getAsRegion()) {\n    RHSReg = RHSReg->getBaseRegion();\n\
  \    if (RHSReg) {\n      const MemRegion *LRoot = resolveRoot(LHSReg, State);\n\
  \      const MemRegion *RRoot = resolveRoot(RHSReg, State);\n      if (LRoot &&\
  \ RRoot) {\n        State = State->set<PtrAliasMap>(LRoot, RRoot);\n        State\
  \ = State->set<PtrAliasMap>(RRoot, LRoot);\n\n        if (const bool *Flag = State->get<PossiblyNullPtrMap>(RRoot))\
  \ {\n          State = State->set<PossiblyNullPtrMap>(LRoot, *Flag);\n        }\n\
  \      }\n    }\n  } else {\n    // If assigned a concrete NULL, mark as possibly\
  \ NULL and unchecked.\n    if (Val.isZeroConstant()) {\n      const MemRegion *LRoot\
  \ = resolveRoot(LHSReg, State);\n      if (LRoot)\n        State = State->set<PossiblyNullPtrMap>(LRoot,\
  \ true);\n    }\n  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE) {\n    C.addTransition(C.getState());\n    return;\n  }\n\n  const\
  \ Expr *PtrExpr = getPtrExprFromCondition(CondE, C);\n  if (!PtrExpr) {\n    C.addTransition(C.getState());\n\
  \    return;\n  }\n\n  ProgramStateRef State = C.getState();\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(PtrExpr, C);\n  if (MR) {\n    MR = MR->getBaseRegion();\n\
  \    if (MR) {\n      State = markChecked(State, MR);\n    }\n  }\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkPreStmt(const MemberExpr *ME, CheckerContext &C)\
  \ const {\n  if (!ME || !ME->isArrow())\n    return;\n\n  const Expr *Base = ME->getBase();\n\
  \  if (!Base)\n    return;\n\n  ProgramStateRef State = C.getState();\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(Base, C);\n  if (!MR)\n    return;\n\n  MR = MR->getBaseRegion();\n\
  \  if (!MR)\n    return;\n\n  const MemRegion *Root = resolveRoot(MR, State);\n\
  \  if (!Root)\n    return;\n\n  const bool *Flag = State->get<PossiblyNullPtrMap>(Root);\n\
  \  if (Flag && *Flag) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Possible NULL dereference of capability pointer (mt76_connac_get_he_phy_cap)\"\
  , N);\n    R->addRange(ME->getSourceRange());\n    C.emitReport(std::move(R));\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkPreStmt(const UnaryOperator *UO, CheckerContext\
  \ &C) const {\n  if (!UO || UO->getOpcode() != UO_Deref)\n    return;\n\n  const\
  \ Expr *SubE = UO->getSubExpr();\n  if (!SubE)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  const MemRegion *MR = getMemRegionFromExpr(SubE, C);\n\
  \  if (!MR)\n    return;\n\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  const MemRegion *Root = resolveRoot(MR, State);\n  if (!Root)\n    return;\n\
  \n  const bool *Flag = State->get<PossiblyNullPtrMap>(Root);\n  if (Flag && *Flag)\
  \ {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n    if (!N)\n      return;\n\
  \n    auto R = std::make_unique<PathSensitiveBugReport>(\n        *BT, \"Possible\
  \ NULL dereference of capability pointer (mt76_connac_get_he_phy_cap)\", N);\n \
  \   R->addRange(UO->getSourceRange());\n    C.emitReport(std::move(R));\n  }\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects dereferencing result of mt76_connac_get_he_phy_cap without NULL\
  \ check\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
