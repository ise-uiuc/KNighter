_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 19ebc1e6cab334a8193398d4152deb76019b5d34
commit_type: Double-Free
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/ParentMapContext.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include\
  \ <vector>\n#include <utility>\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states are necessary for this structural\
  \ checker.\n\nnamespace {\n\nstruct LabelInfo {\n  const LabelStmt *LStmt = nullptr;\n\
  \  const LabelDecl *LDecl = nullptr;\n  SourceLocation Loc;\n};\n\nstruct GotoInfo\
  \ {\n  const GotoStmt *G = nullptr;\n  const LabelDecl *Target = nullptr;\n  SourceLocation\
  \ Loc;\n};\n\nstruct FreeSite {\n  const VarDecl *P = nullptr;                 //\
  \ pointer variable freed\n  const LabelDecl *CleanupLabel = nullptr;    // label\
  \ where free occurs\n  const CallExpr *FreeCall = nullptr;         // kfree/kvfree\
  \ call\n  SourceLocation FreeLoc;\n};\n\nstruct AssignInfo {\n  const VarDecl *P\
  \ = nullptr;\n  SourceLocation Loc;\n  bool ResetToNull = false;\n};\n\nclass BodyScanner\
  \ : public RecursiveASTVisitor<BodyScanner> {\npublic:\n  BodyScanner(ASTContext\
  \ &Ctx,\n              std::vector<LabelInfo> &Labels,\n              std::vector<GotoInfo>\
  \ &Gotos,\n              std::vector<FreeSite> &Frees,\n              std::vector<AssignInfo>\
  \ &Assigns)\n      : Ctx(Ctx), SM(Ctx.getSourceManager()), Labels(Labels), Gotos(Gotos),\n\
  \        Frees(Frees), Assigns(Assigns) {}\n\n  bool VisitLabelStmt(LabelStmt *L)\
  \ {\n    LabelInfo Info;\n    Info.LStmt = L;\n    Info.LDecl = L->getDecl();\n\
  \    Info.Loc = getExpansionLocSafe(L->getBeginLoc());\n    Labels.push_back(Info);\n\
  \n    // Scan the sub-statement for free-like calls.\n    if (Stmt *Sub = L->getSubStmt())\n\
  \      collectFreesUnder(Sub, L->getDecl());\n\n    return true;\n  }\n\n  bool\
  \ VisitGotoStmt(GotoStmt *G) {\n    GotoInfo GI;\n    GI.G = G;\n    GI.Target =\
  \ G->getLabel();\n    GI.Loc = getExpansionLocSafe(G->getGotoLoc());\n    Gotos.push_back(GI);\n\
  \    return true;\n  }\n\n  bool VisitBinaryOperator(BinaryOperator *BO) {\n   \
  \ if (!BO->isAssignmentOp())\n      return true;\n\n    const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \    const Expr *RHS = BO->getRHS();\n\n    const auto *DRE = dyn_cast<DeclRefExpr>(LHS);\n\
  \    if (!DRE)\n      return true;\n\n    const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n\
  \    if (!VD)\n      return true;\n\n    if (!VD->getType()->isAnyPointerType())\n\
  \      return true;\n\n    bool IsNull = isNullPointerExpr(RHS);\n    AssignInfo\
  \ AI;\n    AI.P = VD;\n    AI.Loc = getExpansionLocSafe(BO->getExprLoc());\n   \
  \ AI.ResetToNull = IsNull;\n    Assigns.push_back(AI);\n    return true;\n  }\n\n\
  \  bool VisitDeclStmt(DeclStmt *DS) {\n    for (auto *D : DS->decls()) {\n     \
  \ auto *VD = dyn_cast<VarDecl>(D);\n      if (!VD)\n        continue;\n      if\
  \ (!VD->getType()->isAnyPointerType())\n        continue;\n      if (!VD->hasInit())\n\
  \        continue;\n\n      const Expr *Init = VD->getInit();\n      bool IsNull\
  \ = isNullPointerExpr(Init);\n      AssignInfo AI;\n      AI.P = VD;\n      AI.Loc\
  \ = getExpansionLocSafe(VD->getLocation());\n      AI.ResetToNull = IsNull;\n  \
  \    Assigns.push_back(AI);\n    }\n    return true;\n  }\n\nprivate:\n  ASTContext\
  \ &Ctx;\n  const SourceManager &SM;\n  std::vector<LabelInfo> &Labels;\n  std::vector<GotoInfo>\
  \ &Gotos;\n  std::vector<FreeSite> &Frees;\n  std::vector<AssignInfo> &Assigns;\n\
  \n  SourceLocation getExpansionLocSafe(SourceLocation L) const {\n    if (L.isInvalid())\n\
  \      return L;\n    return SM.getExpansionLoc(L);\n  }\n\n  static bool isFreeName(StringRef\
  \ N) {\n    return N == \"kfree\" || N == \"kvfree\";\n  }\n\n  bool isNullPointerExpr(const\
  \ Expr *E) const {\n    if (!E)\n      return false;\n    E = E->IgnoreParenImpCasts();\n\
  \    // Use Clang's helper to decide null pointer constants\n    return E->isNullPointerConstant(Ctx,\
  \ Expr::NPC_ValueDependentIsNull) !=\n           Expr::NPCK_NotNull;\n  }\n\n  bool\
  \ isFreeCallOnVar(const CallExpr *CE, const VarDecl *&OutVD) const {\n    OutVD\
  \ = nullptr;\n    const FunctionDecl *FD = CE->getDirectCallee();\n    if (!FD)\n\
  \      return false;\n    const IdentifierInfo *II = FD->getIdentifier();\n    if\
  \ (!II)\n      return false;\n    if (!isFreeName(II->getName()))\n      return\
  \ false;\n\n    if (CE->getNumArgs() < 1)\n      return false;\n\n    const Expr\
  \ *Arg0 = CE->getArg(0)->IgnoreParenImpCasts();\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(Arg0))\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n        if\
  \ (VD->getType()->isAnyPointerType()) {\n          OutVD = VD;\n          return\
  \ true;\n        }\n      }\n    }\n    return false;\n  }\n\n  void collectFreesUnder(Stmt\
  \ *S, const LabelDecl *Where) {\n    if (!S)\n      return;\n\n    // Local simple\
  \ walker to look for CallExprs\n    struct LocalVisitor : public RecursiveASTVisitor<LocalVisitor>\
  \ {\n      LocalVisitor(const BodyScanner &Outer, const LabelDecl *L,\n        \
  \           std::vector<FreeSite> &Frees)\n          : Outer(Outer), LDecl(L), Frees(Frees)\
  \ {}\n\n      bool VisitCallExpr(CallExpr *CE) {\n        const VarDecl *VD = nullptr;\n\
  \        if (Outer.isFreeCallOnVar(CE, VD) && VD) {\n          FreeSite FS;\n  \
  \        FS.P = VD;\n          FS.CleanupLabel = LDecl;\n          FS.FreeCall =\
  \ CE;\n          FS.FreeLoc = Outer.getExpansionLocSafe(CE->getExprLoc());\n   \
  \       Frees.push_back(FS);\n        }\n        return true;\n      }\n\n     \
  \ const BodyScanner &Outer;\n      const LabelDecl *LDecl;\n      std::vector<FreeSite>\
  \ &Frees;\n    };\n\n    LocalVisitor LV(*this, Where, Frees);\n    LV.TraverseStmt(S);\n\
  \  }\n};\n\nclass SAGenTestChecker : public Checker<check::ASTCodeBody> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\n       \
  \ : BT(new BugType(this, \"Possible double free across retry loop\", \"Memory Error\"\
  )) {}\n\n      void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter\
  \ &BR) const;\n\n   private:\n      static SourceLocation getExpansionLocSafe(const\
  \ SourceManager &SM, SourceLocation L) {\n        if (L.isInvalid())\n         \
  \ return L;\n        return SM.getExpansionLoc(L);\n      }\n\n      static bool\
  \ before(const SourceManager &SM, SourceLocation A, SourceLocation B) {\n      \
  \  A = getExpansionLocSafe(SM, A);\n        B = getExpansionLocSafe(SM, B);\n  \
  \      return SM.isBeforeInTranslationUnit(A, B);\n      }\n\n      static bool\
  \ strictlyBetween(const SourceManager &SM, SourceLocation X,\n                 \
  \                 SourceLocation L, SourceLocation R) {\n        return before(SM,\
  \ L, X) && before(SM, X, R);\n      }\n\n      void detectAndReport(const FunctionDecl\
  \ *FD,\n                           const std::vector<LabelInfo> &Labels,\n     \
  \                      const std::vector<GotoInfo> &Gotos,\n                   \
  \        const std::vector<FreeSite> &Frees,\n                           const std::vector<AssignInfo>\
  \ &Assigns,\n                           BugReporter &BR, ASTContext &AC) const;\n\
  };\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager &Mgr,\
  \ BugReporter &BR) const {\n  const auto *FD = dyn_cast<FunctionDecl>(D);\n  if\
  \ (!FD)\n    return;\n  const Stmt *Body = FD->getBody();\n  if (!Body)\n    return;\n\
  \n  ASTContext &Ctx = Mgr.getASTContext();\n  std::vector<LabelInfo> Labels;\n \
  \ std::vector<GotoInfo> Gotos;\n  std::vector<FreeSite> Frees;\n  std::vector<AssignInfo>\
  \ Assigns;\n\n  BodyScanner Scanner(Ctx, Labels, Gotos, Frees, Assigns);\n  Scanner.TraverseStmt(const_cast<Stmt\
  \ *>(Body));\n\n  detectAndReport(FD, Labels, Gotos, Frees, Assigns, BR, Ctx);\n\
  }\n\nvoid SAGenTestChecker::detectAndReport(const FunctionDecl *FD,\n          \
  \                             const std::vector<LabelInfo> &Labels,\n          \
  \                             const std::vector<GotoInfo> &Gotos,\n            \
  \                           const std::vector<FreeSite> &Frees,\n              \
  \                         const std::vector<AssignInfo> &Assigns,\n            \
  \                           BugReporter &BR, ASTContext &AC) const {\n  const SourceManager\
  \ &SM = AC.getSourceManager();\n\n  auto getLabelLoc = [&](const LabelDecl *LD)\
  \ -> SourceLocation {\n    for (const auto &LI : Labels) {\n      if (LI.LDecl ==\
  \ LD)\n        return LI.Loc;\n    }\n    return SourceLocation();\n  };\n\n  for\
  \ (const auto &FS : Frees) {\n    if (!FS.P || !FS.CleanupLabel || !FS.FreeCall)\n\
  \      continue;\n\n    SourceLocation FreeLoc = FS.FreeLoc;\n    SourceLocation\
  \ CleanupLoc = getLabelLoc(FS.CleanupLabel);\n    if (FreeLoc.isInvalid() || CleanupLoc.isInvalid())\n\
  \      continue;\n\n    // Find a backward goto (retry) after the free.\n    for\
  \ (const auto &GR : Gotos) {\n      if (!GR.Target)\n        continue;\n\n     \
  \ SourceLocation GoLoc = GR.Loc;\n      SourceLocation TargetLoc = getLabelLoc(GR.Target);\n\
  \      if (GoLoc.isInvalid() || TargetLoc.isInvalid())\n        continue;\n\n  \
  \    // Must be: free ... goto restart_label; where restart_label is before free.\n\
  \      if (!(before(SM, FreeLoc, GoLoc) && before(SM, TargetLoc, FreeLoc)))\n  \
  \      continue;\n\n      // Safety check 1: reset to NULL between free and retry\
  \ goto\n      bool ResetBetween = false;\n      for (const auto &AI : Assigns) {\n\
  \        if (AI.P != FS.P)\n          continue;\n        if (AI.ResetToNull && strictlyBetween(SM,\
  \ AI.Loc, FreeLoc, GoLoc)) {\n          ResetBetween = true;\n          break;\n\
  \        }\n      }\n      if (ResetBetween)\n        continue; // safe for this\
  \ retry goto\n\n      // Safety check 2: earliest assignment after restart label\n\
  \      const AssignInfo *Earliest = nullptr;\n      for (const auto &AI : Assigns)\
  \ {\n        if (AI.P != FS.P)\n          continue;\n        if (before(SM, TargetLoc,\
  \ AI.Loc)) {\n          if (!Earliest || before(SM, AI.Loc, Earliest->Loc))\n  \
  \          Earliest = &AI;\n        }\n      }\n\n      // Look for an early goto\
  \ to the cleanup label between restart label and earliest assignment.\n      bool\
  \ EarlyGotoToCleanup = false;\n      for (const auto &GE : Gotos) {\n        if\
  \ (GE.Target != FS.CleanupLabel)\n          continue;\n        SourceLocation ELoc\
  \ = GE.Loc;\n        if (!before(SM, TargetLoc, ELoc))\n          continue;\n  \
  \      if (Earliest) {\n          if (before(SM, ELoc, Earliest->Loc)) {\n     \
  \       EarlyGotoToCleanup = true;\n            break;\n          }\n        } else\
  \ {\n          // No assignment after restart; any early goto to cleanup after restart\
  \ is problematic.\n          EarlyGotoToCleanup = true;\n          break;\n    \
  \    }\n      }\n\n      if (EarlyGotoToCleanup) {\n        // Report at the free\
  \ call location.\n        auto R = std::make_unique<BasicBugReport>(\n         \
  \   *BT,\n            \"Pointer freed in cleanup then retried without resetting\
  \ to NULL; \"\n            \"early goto can double free\",\n            PathDiagnosticLocation(FS.FreeCall,\
  \ SM, FD));\n        R->addRange(FS.FreeCall->getSourceRange());\n        BR.emitReport(std::move(R));\n\
  \        // No need to continue for more gotos for this FreeSite; one is enough.\n\
  \        break;\n      }\n    }\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects possible double free across\
  \ replay/retry loop due to missing NULL reset\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nsmb: client: fix possible double free in smb2_set_ea()\n\
  \nClang static checker(scan-build) warning\uFF1A\nfs/smb/client/smb2ops.c:1304:2:\
  \ Attempt to free released memory.\n 1304 |         kfree(ea);\n      |        \
  \ ^~~~~~~~~\n\nThere is a double free in such case:\n'ea is initialized to NULL'\
  \ -> 'first successful memory allocation for\nea' -> 'something failed, goto sea_exit'\
  \ -> 'first memory release for ea'\n-> 'goto replay_again' -> 'second goto sea_exit\
  \ before allocate memory\nfor ea' -> 'second memory release for ea resulted in double\
  \ free'.\n\nRe-initialie 'ea' to NULL near to the replay_again label, it can fix\
  \ this\ndouble free problem.\n\nFixes: 4f1fffa23769 (\"cifs: commands that are retried\
  \ should have replay flag set\")\nReviewed-by: Dan Carpenter <dan.carpenter@linaro.org>\n\
  Signed-off-by: Su Hui <suhui@nfschina.com>\nSigned-off-by: Steve French <stfrench@microsoft.com>\n\
  \n## Buggy Code\n\n```c\n// Function: smb2_set_ea in fs/smb/client/smb2ops.c\nstatic\
  \ int\nsmb2_set_ea(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const\
  \ char *path, const char *ea_name, const void *ea_value,\n\t    const __u16 ea_value_len,\
  \ const struct nls_table *nls_codepage,\n\t    struct cifs_sb_info *cifs_sb)\n{\n\
  \tstruct smb2_compound_vars *vars;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct\
  \ TCP_Server_Info *server;\n\tstruct smb_rqst *rqst;\n\tstruct kvec *rsp_iov;\n\t\
  __le16 *utf16_path = NULL;\n\tint ea_name_len = strlen(ea_name);\n\tint flags =\
  \ CIFS_CP_CREATE_CLOSE_OP;\n\tint len;\n\tint resp_buftype[3];\n\tstruct cifs_open_parms\
  \ oparms;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_fid fid;\n\tunsigned\
  \ int size[1];\n\tvoid *data[1];\n\tstruct smb2_file_full_ea_info *ea = NULL;\n\t\
  struct smb2_query_info_rsp *rsp;\n\tint rc, used_len = 0;\n\tint retries = 0, cur_sleep\
  \ = 1;\n\nreplay_again:\n\t/* reinitialize for possible replay */\n\tflags = CIFS_CP_CREATE_CLOSE_OP;\n\
  \toplock = SMB2_OPLOCK_LEVEL_NONE;\n\tserver = cifs_pick_channel(ses);\n\n\tif (smb3_encryption_required(tcon))\n\
  \t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tif (ea_name_len > 255)\n\t\treturn -EINVAL;\n\
  \n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path)\n\
  \t\treturn -ENOMEM;\n\n\tresp_buftype[0] = resp_buftype[1] = resp_buftype[2] = CIFS_NO_BUFFER;\n\
  \tvars = kzalloc(sizeof(*vars), GFP_KERNEL);\n\tif (!vars) {\n\t\trc = -ENOMEM;\n\
  \t\tgoto out_free_path;\n\t}\n\trqst = vars->rqst;\n\trsp_iov = vars->rsp_iov;\n\
  \n\tif (ses->server->ops->query_all_EAs) {\n\t\tif (!ea_value) {\n\t\t\trc = ses->server->ops->query_all_EAs(xid,\
  \ tcon, path,\n\t\t\t\t\t\t\t     ea_name, NULL, 0,\n\t\t\t\t\t\t\t     cifs_sb);\n\
  \t\t\tif (rc == -ENODATA)\n\t\t\t\tgoto sea_exit;\n\t\t} else {\n\t\t\t/* If we\
  \ are adding a attribute we should first check\n\t\t\t * if there will be enough\
  \ space available to store\n\t\t\t * the new EA. If not we should not add it since\
  \ we\n\t\t\t * would not be able to even read the EAs back.\n\t\t\t */\n\t\t\trc\
  \ = smb2_query_info_compound(xid, tcon, path,\n\t\t\t\t      FILE_READ_EA,\n\t\t\
  \t\t      FILE_FULL_EA_INFORMATION,\n\t\t\t\t      SMB2_O_INFO_FILE,\n\t\t\t\t \
  \     CIFSMaxBufSize -\n\t\t\t\t      MAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\t\t\t\
  \      MAX_SMB2_CLOSE_RESPONSE_SIZE,\n\t\t\t\t      &rsp_iov[1], &resp_buftype[1],\
  \ cifs_sb);\n\t\t\tif (rc == 0) {\n\t\t\t\trsp = (struct smb2_query_info_rsp *)rsp_iov[1].iov_base;\n\
  \t\t\t\tused_len = le32_to_cpu(rsp->OutputBufferLength);\n\t\t\t}\n\t\t\tfree_rsp_buf(resp_buftype[1],\
  \ rsp_iov[1].iov_base);\n\t\t\tresp_buftype[1] = CIFS_NO_BUFFER;\n\t\t\tmemset(&rsp_iov[1],\
  \ 0, sizeof(rsp_iov[1]));\n\t\t\trc = 0;\n\n\t\t\t/* Use a fudge factor of 256 bytes\
  \ in case we collide\n\t\t\t * with a different set_EAs command.\n\t\t\t */\n\t\t\
  \tif (CIFSMaxBufSize - MAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\t\t   MAX_SMB2_CLOSE_RESPONSE_SIZE\
  \ - 256 <\n\t\t\t   used_len + ea_name_len + ea_value_len + 1) {\n\t\t\t\trc = -ENOSPC;\n\
  \t\t\t\tgoto sea_exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Open */\n\trqst[0].rq_iov =\
  \ vars->open_iov;\n\trqst[0].rq_nvec = SMB2_CREATE_IOV_SIZE;\n\n\toparms = (struct\
  \ cifs_open_parms) {\n\t\t.tcon = tcon,\n\t\t.path = path,\n\t\t.desired_access\
  \ = FILE_WRITE_EA,\n\t\t.disposition = FILE_OPEN,\n\t\t.create_options = cifs_create_options(cifs_sb,\
  \ 0),\n\t\t.fid = &fid,\n\t\t.replay = !!(retries),\n\t};\n\n\trc = SMB2_open_init(tcon,\
  \ server,\n\t\t\t    &rqst[0], &oplock, &oparms, utf16_path);\n\tif (rc)\n\t\tgoto\
  \ sea_exit;\n\tsmb2_set_next_command(tcon, &rqst[0]);\n\n\n\t/* Set Info */\n\t\
  rqst[1].rq_iov = vars->si_iov;\n\trqst[1].rq_nvec = 1;\n\n\tlen = sizeof(*ea) +\
  \ ea_name_len + ea_value_len + 1;\n\tea = kzalloc(len, GFP_KERNEL);\n\tif (ea ==\
  \ NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto sea_exit;\n\t}\n\n\tea->ea_name_length =\
  \ ea_name_len;\n\tea->ea_value_length = cpu_to_le16(ea_value_len);\n\tmemcpy(ea->ea_data,\
  \ ea_name, ea_name_len + 1);\n\tmemcpy(ea->ea_data + ea_name_len + 1, ea_value,\
  \ ea_value_len);\n\n\tsize[0] = len;\n\tdata[0] = ea;\n\n\trc = SMB2_set_info_init(tcon,\
  \ server,\n\t\t\t\t&rqst[1], COMPOUND_FID,\n\t\t\t\tCOMPOUND_FID, current->tgid,\n\
  \t\t\t\tFILE_FULL_EA_INFORMATION,\n\t\t\t\tSMB2_O_INFO_FILE, 0, data, size);\n\t\
  if (rc)\n\t\tgoto sea_exit;\n\tsmb2_set_next_command(tcon, &rqst[1]);\n\tsmb2_set_related(&rqst[1]);\n\
  \n\t/* Close */\n\trqst[2].rq_iov = &vars->close_iov;\n\trqst[2].rq_nvec = 1;\n\t\
  rc = SMB2_close_init(tcon, server,\n\t\t\t     &rqst[2], COMPOUND_FID, COMPOUND_FID,\
  \ false);\n\tif (rc)\n\t\tgoto sea_exit;\n\tsmb2_set_related(&rqst[2]);\n\n\tif\
  \ (retries) {\n\t\tsmb2_set_replay(server, &rqst[0]);\n\t\tsmb2_set_replay(server,\
  \ &rqst[1]);\n\t\tsmb2_set_replay(server, &rqst[2]);\n\t}\n\n\trc = compound_send_recv(xid,\
  \ ses, server,\n\t\t\t\tflags, 3, rqst,\n\t\t\t\tresp_buftype, rsp_iov);\n\t/* no\
  \ need to bump num_remote_opens because handle immediately closed */\n\n sea_exit:\n\
  \tkfree(ea);\n\tSMB2_open_free(&rqst[0]);\n\tSMB2_set_info_free(&rqst[1]);\n\tSMB2_close_free(&rqst[2]);\n\
  \tfree_rsp_buf(resp_buftype[0], rsp_iov[0].iov_base);\n\tfree_rsp_buf(resp_buftype[1],\
  \ rsp_iov[1].iov_base);\n\tfree_rsp_buf(resp_buftype[2], rsp_iov[2].iov_base);\n\
  \tkfree(vars);\nout_free_path:\n\tkfree(utf16_path);\n\n\tif (is_replayable_error(rc)\
  \ &&\n\t    smb2_should_replay(tcon, &retries, &cur_sleep))\n\t\tgoto replay_again;\n\
  \n\treturn rc;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/fs/smb/client/smb2ops.c\
  \ b/fs/smb/client/smb2ops.c\nindex 6b385fce3f2a..24a2aa04a108 100644\n--- a/fs/smb/client/smb2ops.c\n\
  +++ b/fs/smb/client/smb2ops.c\n@@ -1158,7 +1158,7 @@ smb2_set_ea(const unsigned\
  \ int xid, struct cifs_tcon *tcon,\n \tstruct cifs_fid fid;\n \tunsigned int size[1];\n\
  \ \tvoid *data[1];\n-\tstruct smb2_file_full_ea_info *ea = NULL;\n+\tstruct smb2_file_full_ea_info\
  \ *ea;\n \tstruct smb2_query_info_rsp *rsp;\n \tint rc, used_len = 0;\n \tint retries\
  \ = 0, cur_sleep = 1;\n@@ -1179,6 +1179,7 @@ smb2_set_ea(const unsigned int xid,\
  \ struct cifs_tcon *tcon,\n \tif (!utf16_path)\n \t\treturn -ENOMEM;\n \n+\tea =\
  \ NULL;\n \tresp_buftype[0] = resp_buftype[1] = resp_buftype[2] = CIFS_NO_BUFFER;\n\
  \ \tvars = kzalloc(sizeof(*vars), GFP_KERNEL);\n \tif (!vars) {\n```\n"
pattern: "## Bug Pattern\n\nUnconditional kfree() in a common cleanup label combined\
  \ with a retry/replay loop, while the freed pointer is not reset to NULL on loop\
  \ restart. This lets a dangling pointer value persist across iterations, so an early\
  \ goto to the cleanup before reallocation triggers a second kfree() on already-freed\
  \ memory.\n\nPattern sketch:\nreplay_again:\n    /* ... */\n    if (error_before_alloc)\n\
  \        goto out;\n    p = kmalloc(...);\n    if (!p)\n        goto out;\n    /*\
  \ ... */\nout:\n    kfree(p);     /* unconditional free */\n    if (should_retry)\n\
  \        goto replay_again;  /* p not reset to NULL -> possible double free on next\
  \ early exit */"
plan: "Plan\n\n1) Program state\n- No custom program state is necessary. This checker\
  \ is purely structural (AST-based) and detects a control-flow pattern (label + goto\
  \ retry + unconditional kfree in cleanup) that can cause a double free across iterations.\n\
  \n2) Callbacks to use\n- checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter\
  \ &BR)\n  We will scan the function body AST once to find:\n  - The cleanup label\
  \ that unconditionally frees a pointer p via kfree(p).\n  - A retry goto that jumps\
  \ back to an earlier label (the \u201Crestart\u201D label).\n  - At least one early\
  \ goto to the cleanup label that can occur before p is reinitialized or reallocated\
  \ on the next iteration.\n  - Absence of p = NULL either just after the free (before\
  \ the retry goto) or right after the restart label (before any early goto to cleanup).\n\
  \n3) Detailed implementation (checkASTCodeBody)\n\n3.1) Collect structural facts\
  \ from the AST\n- Pre-scan the FunctionDecl\u2019s body (Stmt subtree) and collect\
  \ the following with source locations (use SourceManager::isBeforeInTranslationUnit\
  \ for ordering):\n  a) All LabelStmt nodes:\n     - Record: LabelStmt* L, StringRef\
  \ Name, SourceLocation Loc.\n  b) All GotoStmt nodes:\n     - Record: GotoStmt*\
  \ G, SourceLocation Loc, LabelStmt* Target (via G->getLabel()).\n  c) All cleanup\
  \ frees: For each LabelStmt L, search inside its labeled subtree for kfree/kvfree:\n\
  \     - Use findSpecificTypeInChildren<CallExpr>(L) plus a linear recursive descent\
  \ to collect all CallExpr under L.\n     - For each CallExpr CE where callee identifier\
  \ is \"kfree\" or \"kvfree\":\n       - If the first argument is a DeclRefExpr to\
  \ a VarDecl* P (pointer variable), record a candidate cleanup free site:\n     \
  \    CleanupFree = { VarDecl* P, LabelStmt* CleanupLabel L2, CallExpr* FreeCall,\
  \ SourceLocation FreeLoc }.\n       - We treat this as \u201Cunconditional free\
  \ in cleanup\u201D (the call is directly in the labeled block).\n  d) All assignments\
  \ to pointer P:\n     - While traversing, collect BinaryOperator nodes with isAssignmentOp():\n\
  \       - If LHS is a DeclRefExpr to some VarDecl* P (pointer), record an assignment\
  \ event:\n         Assign = { VarDecl* P, SourceLocation Loc, RHSKind }\n      \
  \   where RHSKind is:\n           - ResetToNull if RHS is a null pointer constant:\n\
  \             Detect with RHS->IgnoreImpCasts():\n               - IntegerLiteral\
  \ == 0, or\n               - GNUNullExpr, or\n               - CXXNullPtrLiteralExpr\
  \ (if C++).\n           - OtherWrite otherwise (including assignments from kmalloc/kzalloc/kcalloc/etc.).\n\
  \     - Optionally include initializations on DeclStmt (VarDecl with Init) as assignment\
  \ events with that init\u2019s SourceLocation.\n  e) Optionally record \u201Callocation\
  \ writes\u201D to P:\n     - For assignments P = call(...), if callee is \"kmalloc\"\
  /\"kzalloc\"/\"kcalloc\"/\"krealloc\", classify as OtherWrite. (We don\u2019t need\
  \ to distinguish, just not ResetToNull.)\n\n3.2) Identify the restart-goto pattern\
  \ per pointer P\n- For each CleanupFree {P, L2, FreeLoc}:\n  1) Find a \u201Crestart\
  \ goto\u201D:\n     - A GotoStmt G_restart whose SourceLocation G_restart.Loc is\
  \ after FreeLoc\n       and whose target label L1 has SourceLocation L1.Loc before\
  \ FreeLoc.\n     - This matches the pattern: cleanup (free) happens, then \u201C\
  if (should_retry) goto restart_label;\u201D.\n     - If no such G_restart exists,\
  \ skip this CleanupFree (no retry loop).\n  2) Check safety fix 1: reset to NULL\
  \ after free and before retry\n     - Look for any assignment event for P with ResetToNull\
  \ and with source location in (FreeLoc, G_restart.Loc). If found, this iteration\
  \ resets p to NULL before re-entering the loop; skip (safe).\n  3) Check safety\
  \ fix 2: reset to NULL near the restart label\n     - Let RestartLoc = L1.Loc.\n\
  \     - Find the earliest assignment event W to P that occurs after RestartLoc.\n\
  \       - If no such assignment exists, set WLoc = +infinity (no assignment).\n\
  \       - If the earliest assignment W is ResetToNull, we consider this iteration\
  \ safe against early gotos (p becomes NULL before any other modification); continue\
  \ only if earliest is not ResetToNull.\n  4) Check for an early goto to cleanup\
  \ before P is written after restart\n     - Look for any GotoStmt G_early that targets\
  \ L2 (cleanup label) with source location in (RestartLoc, WLoc). If any exists,\
  \ that means on the next iteration, there is a path that can go to cleanup before\
  \ p is reset/reallocated. Since cleanup unconditionally frees p and we already freed\
  \ p in the previous iteration, this is a possible double free.\n     - If found,\
  \ and step 2/3 did not find a ResetToNull, report a bug.\n\nNotes:\n- If there are\
  \ multiple restart gotos after free, it\u2019s enough to find any one that makes\
  \ the pattern true.\n- If there are multiple early gotos to L2, any one in (RestartLoc,\
  \ WLoc) suffices.\n\n3.3) Bug reporting\n- For each detected issue:\n  - Create\
  \ a BugType \u201CPossible double free across replay/retry loop\u201D.\n  - Emit\
  \ a BasicBugReport at the free call location FreeLoc (or at the restart goto location\
  \ G_restart.Loc).\n  - Message: \u201CPointer freed in cleanup then retried without\
  \ resetting to NULL; early goto can double free.\u201D\n  - Add a source range highlight\
  \ on the kfree(...) call and, if helpful, on the restart goto.\n  - Keep the message\
  \ short and clear as requested.\n\n4) Heuristics and robustness\n- Callee recognition:\n\
  \  - Compare callee identifier string with \"kfree\" and \"kvfree\".\n- Label names:\n\
  \  - Not required for correctness, but you can include label names in notes if desired.\n\
  - Assignment to NULL detection:\n  - Prefer direct AST matching as above (IntegerLiteral\
  \ 0, GNUNullExpr, CXXNullPtrLiteralExpr).\n  - If you later migrate this logic to\
  \ a path-sensitive callback (e.g., checkBind), you can use EvaluateExprToInt for\
  \ more cases.\n- Source order:\n  - Use SourceManager::isBeforeInTranslationUnit\
  \ to compare SourceLocations reliably.\n- Multiple pointers:\n  - Run the above\
  \ logic per pointer P discovered in cleanup frees. Report each offending P independently.\n\
  \n5) Optional refinements (if needed later)\n- Consider also treating \u201Cp =\
  \ NULL\u201D immediately in cleanup after kfree(p) as a safety fix (step 2 already\
  \ covers this).\n- Recognize more free-like functions if present in the target codebase\
  \ (e.g., vfree). Adjust callee matching accordingly.\n- Extend null-detection to\
  \ also recognize explicit casts to (void *)0, etc.\n\nSummary\n- No program state\
  \ is needed.\n- A single AST-body pass (checkASTCodeBody) finds the specific label/goto\
  \ retry pattern plus unconditional kfree in cleanup and absence of p = NULL reset\
  \ before re-entering the retry loop.\n- The detection is conservative and tailored\
  \ to the target bug pattern from the patch: unconditional kfree in a common cleanup\
  \ label, a retry goto to a restart label, and possible early goto to cleanup before\
  \ reallocation/reset, causing double free across iterations."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/ParentMapContext.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include\
  \ <vector>\n#include <utility>\n#include <memory>\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// No custom program states are necessary\
  \ for this structural checker.\n\nnamespace {\n\nstruct LabelInfo {\n  const LabelStmt\
  \ *LStmt = nullptr;\n  const LabelDecl *LDecl = nullptr;\n  SourceLocation Loc;\n\
  };\n\nstruct GotoInfo {\n  const GotoStmt *G = nullptr;\n  const LabelDecl *Target\
  \ = nullptr;\n  SourceLocation Loc;\n};\n\nstruct FreeSite {\n  const VarDecl *P\
  \ = nullptr;                 // pointer variable freed\n  const LabelDecl *CleanupLabel\
  \ = nullptr;    // label where free occurs\n  const CallExpr *FreeCall = nullptr;\
  \         // kfree/kvfree call\n  SourceLocation FreeLoc;\n};\n\nstruct AssignInfo\
  \ {\n  const VarDecl *P = nullptr;\n  SourceLocation Loc;\n  bool ResetToNull =\
  \ false;\n};\n\nclass BodyScanner : public RecursiveASTVisitor<BodyScanner> {\n\
  public:\n  BodyScanner(ASTContext &Ctx,\n              std::vector<LabelInfo> &Labels,\n\
  \              std::vector<GotoInfo> &Gotos,\n              std::vector<FreeSite>\
  \ &Frees,\n              std::vector<AssignInfo> &Assigns)\n      : Ctx(Ctx), SM(Ctx.getSourceManager()),\
  \ Labels(Labels), Gotos(Gotos),\n        Frees(Frees), Assigns(Assigns) {}\n\n \
  \ bool VisitLabelStmt(LabelStmt *L) {\n    LabelInfo Info;\n    Info.LStmt = L;\n\
  \    Info.LDecl = L->getDecl();\n    Info.Loc = getExpansionLocSafe(L->getBeginLoc());\n\
  \    Labels.push_back(Info);\n\n    // Scan the sub-statement for free-like calls.\n\
  \    if (Stmt *Sub = L->getSubStmt())\n      collectFreesUnder(Sub, L->getDecl());\n\
  \n    return true;\n  }\n\n  bool VisitGotoStmt(GotoStmt *G) {\n    GotoInfo GI;\n\
  \    GI.G = G;\n    GI.Target = G->getLabel();\n    GI.Loc = getExpansionLocSafe(G->getGotoLoc());\n\
  \    Gotos.push_back(GI);\n    return true;\n  }\n\n  bool VisitBinaryOperator(BinaryOperator\
  \ *BO) {\n    if (!BO->isAssignmentOp())\n      return true;\n\n    const Expr *LHS\
  \ = BO->getLHS()->IgnoreParenImpCasts();\n    const Expr *RHS = BO->getRHS();\n\n\
  \    const auto *DRE = dyn_cast<DeclRefExpr>(LHS);\n    if (!DRE)\n      return\
  \ true;\n\n    const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n    if (!VD)\n\
  \      return true;\n\n    if (!VD->getType()->isAnyPointerType())\n      return\
  \ true;\n\n    bool IsNull = isNullPointerExpr(RHS);\n    AssignInfo AI;\n    AI.P\
  \ = VD;\n    AI.Loc = getExpansionLocSafe(BO->getExprLoc());\n    AI.ResetToNull\
  \ = IsNull;\n    Assigns.push_back(AI);\n    return true;\n  }\n\n  bool VisitDeclStmt(DeclStmt\
  \ *DS) {\n    for (auto *D : DS->decls()) {\n      auto *VD = dyn_cast<VarDecl>(D);\n\
  \      if (!VD)\n        continue;\n      if (!VD->getType()->isAnyPointerType())\n\
  \        continue;\n      if (!VD->hasInit())\n        continue;\n\n      const\
  \ Expr *Init = VD->getInit();\n      bool IsNull = isNullPointerExpr(Init);\n  \
  \    AssignInfo AI;\n      AI.P = VD;\n      AI.Loc = getExpansionLocSafe(VD->getLocation());\n\
  \      AI.ResetToNull = IsNull;\n      Assigns.push_back(AI);\n    }\n    return\
  \ true;\n  }\n\nprivate:\n  ASTContext &Ctx;\n  const SourceManager &SM;\n  std::vector<LabelInfo>\
  \ &Labels;\n  std::vector<GotoInfo> &Gotos;\n  std::vector<FreeSite> &Frees;\n \
  \ std::vector<AssignInfo> &Assigns;\n\n  SourceLocation getExpansionLocSafe(SourceLocation\
  \ L) const {\n    if (L.isInvalid())\n      return L;\n    return SM.getExpansionLoc(L);\n\
  \  }\n\n  static bool isFreeName(StringRef N) {\n    return N == \"kfree\" || N\
  \ == \"kvfree\";\n  }\n\n  bool isNullPointerExpr(const Expr *E) const {\n    if\
  \ (!E)\n      return false;\n    E = E->IgnoreParenImpCasts();\n    // Use Clang's\
  \ helper to decide null pointer constants\n    return E->isNullPointerConstant(Ctx,\
  \ Expr::NPC_ValueDependentIsNull) !=\n           Expr::NPCK_NotNull;\n  }\n\n  bool\
  \ isFreeCallOnVar(const CallExpr *CE, const VarDecl *&OutVD) const {\n    OutVD\
  \ = nullptr;\n    const FunctionDecl *FD = CE->getDirectCallee();\n    if (!FD)\n\
  \      return false;\n    const IdentifierInfo *II = FD->getIdentifier();\n    if\
  \ (!II)\n      return false;\n    if (!isFreeName(II->getName()))\n      return\
  \ false;\n\n    if (CE->getNumArgs() < 1)\n      return false;\n\n    const Expr\
  \ *Arg0 = CE->getArg(0)->IgnoreParenImpCasts();\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(Arg0))\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n        if\
  \ (VD->getType()->isAnyPointerType()) {\n          OutVD = VD;\n          return\
  \ true;\n        }\n      }\n    }\n    return false;\n  }\n\n  void collectFreesUnder(Stmt\
  \ *S, const LabelDecl *Where) {\n    if (!S)\n      return;\n\n    // Local simple\
  \ walker to look for CallExprs\n    struct LocalVisitor : public RecursiveASTVisitor<LocalVisitor>\
  \ {\n      LocalVisitor(const BodyScanner &Outer, const LabelDecl *L,\n        \
  \           std::vector<FreeSite> &Frees)\n          : Outer(Outer), LDecl(L), Frees(Frees)\
  \ {}\n\n      bool VisitCallExpr(CallExpr *CE) {\n        const VarDecl *VD = nullptr;\n\
  \        if (Outer.isFreeCallOnVar(CE, VD) && VD) {\n          FreeSite FS;\n  \
  \        FS.P = VD;\n          FS.CleanupLabel = LDecl;\n          FS.FreeCall =\
  \ CE;\n          FS.FreeLoc = Outer.getExpansionLocSafe(CE->getExprLoc());\n   \
  \       Frees.push_back(FS);\n        }\n        return true;\n      }\n\n     \
  \ const BodyScanner &Outer;\n      const LabelDecl *LDecl;\n      std::vector<FreeSite>\
  \ &Frees;\n    };\n\n    LocalVisitor LV(*this, Where, Frees);\n    LV.TraverseStmt(S);\n\
  \  }\n};\n\nclass SAGenTestChecker : public Checker<check::ASTCodeBody> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\n       \
  \ : BT(new BugType(this, \"Possible double free across retry loop\", \"Memory Error\"\
  )) {}\n\n      void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter\
  \ &BR) const;\n\n   private:\n      static SourceLocation getExpansionLocSafe(const\
  \ SourceManager &SM, SourceLocation L) {\n        if (L.isInvalid())\n         \
  \ return L;\n        return SM.getExpansionLoc(L);\n      }\n\n      static bool\
  \ before(const SourceManager &SM, SourceLocation A, SourceLocation B) {\n      \
  \  A = getExpansionLocSafe(SM, A);\n        B = getExpansionLocSafe(SM, B);\n  \
  \      return SM.isBeforeInTranslationUnit(A, B);\n      }\n\n      static bool\
  \ strictlyBetween(const SourceManager &SM, SourceLocation X,\n                 \
  \                 SourceLocation L, SourceLocation R) {\n        return before(SM,\
  \ L, X) && before(SM, X, R);\n      }\n\n      void detectAndReport(const FunctionDecl\
  \ *FD,\n                           const std::vector<LabelInfo> &Labels,\n     \
  \                      const std::vector<GotoInfo> &Gotos,\n                   \
  \        const std::vector<FreeSite> &Frees,\n                           const std::vector<AssignInfo>\
  \ &Assigns,\n                           BugReporter &BR, ASTContext &AC) const;\n\
  };\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager &Mgr,\
  \ BugReporter &BR) const {\n  const auto *FD = dyn_cast<FunctionDecl>(D);\n  if\
  \ (!FD)\n    return;\n  const Stmt *Body = FD->getBody();\n  if (!Body)\n    return;\n\
  \n  ASTContext &Ctx = Mgr.getASTContext();\n  std::vector<LabelInfo> Labels;\n \
  \ std::vector<GotoInfo> Gotos;\n  std::vector<FreeSite> Frees;\n  std::vector<AssignInfo>\
  \ Assigns;\n\n  BodyScanner Scanner(Ctx, Labels, Gotos, Frees, Assigns);\n  Scanner.TraverseStmt(const_cast<Stmt\
  \ *>(Body));\n\n  detectAndReport(FD, Labels, Gotos, Frees, Assigns, BR, Ctx);\n\
  }\n\nvoid SAGenTestChecker::detectAndReport(const FunctionDecl *FD,\n          \
  \                             const std::vector<LabelInfo> &Labels,\n          \
  \                             const std::vector<GotoInfo> &Gotos,\n            \
  \                           const std::vector<FreeSite> &Frees,\n              \
  \                         const std::vector<AssignInfo> &Assigns,\n            \
  \                           BugReporter &BR, ASTContext &AC) const {\n  const SourceManager\
  \ &SM = AC.getSourceManager();\n\n  auto getLabelLoc = [&](const LabelDecl *LD)\
  \ -> SourceLocation {\n    for (const auto &LI : Labels) {\n      if (LI.LDecl ==\
  \ LD)\n        return LI.Loc;\n    }\n    return SourceLocation();\n  };\n\n  for\
  \ (const auto &FS : Frees) {\n    if (!FS.P || !FS.CleanupLabel || !FS.FreeCall)\n\
  \      continue;\n\n    SourceLocation FreeLoc = FS.FreeLoc;\n    SourceLocation\
  \ CleanupLoc = getLabelLoc(FS.CleanupLabel);\n    if (FreeLoc.isInvalid() || CleanupLoc.isInvalid())\n\
  \      continue;\n\n    // Find a backward goto (retry) after the free.\n    for\
  \ (const auto &GR : Gotos) {\n      if (!GR.Target)\n        continue;\n\n     \
  \ SourceLocation GoLoc = GR.Loc;\n      SourceLocation TargetLoc = getLabelLoc(GR.Target);\n\
  \      if (GoLoc.isInvalid() || TargetLoc.isInvalid())\n        continue;\n\n  \
  \    // Must be: free ... goto restart_label; where restart_label is before free.\n\
  \      if (!(before(SM, FreeLoc, GoLoc) && before(SM, TargetLoc, FreeLoc)))\n  \
  \      continue;\n\n      // Safety check 1: reset to NULL between free and retry\
  \ goto\n      bool ResetBetween = false;\n      for (const auto &AI : Assigns) {\n\
  \        if (AI.P != FS.P)\n          continue;\n        if (AI.ResetToNull && strictlyBetween(SM,\
  \ AI.Loc, FreeLoc, GoLoc)) {\n          ResetBetween = true;\n          break;\n\
  \        }\n      }\n      if (ResetBetween)\n        continue; // safe for this\
  \ retry goto\n\n      // Safety check 2: earliest assignment after restart label\n\
  \      const AssignInfo *Earliest = nullptr;\n      for (const auto &AI : Assigns)\
  \ {\n        if (AI.P != FS.P)\n          continue;\n        if (before(SM, TargetLoc,\
  \ AI.Loc)) {\n          if (!Earliest || before(SM, AI.Loc, Earliest->Loc))\n  \
  \          Earliest = &AI;\n        }\n      }\n\n      // Look for an early goto\
  \ to the cleanup label between restart label and earliest assignment.\n      bool\
  \ EarlyGotoToCleanup = false;\n      for (const auto &GE : Gotos) {\n        if\
  \ (GE.Target != FS.CleanupLabel)\n          continue;\n        SourceLocation ELoc\
  \ = GE.Loc;\n        if (!before(SM, TargetLoc, ELoc))\n          continue;\n  \
  \      if (Earliest) {\n          if (before(SM, ELoc, Earliest->Loc)) {\n     \
  \       EarlyGotoToCleanup = true;\n            break;\n          }\n        } else\
  \ {\n          // No assignment after restart; any early goto to cleanup after restart\
  \ is problematic.\n          EarlyGotoToCleanup = true;\n          break;\n    \
  \    }\n      }\n\n      if (EarlyGotoToCleanup) {\n        // Report at the free\
  \ call location using a SourceLocation-based PathDiagnosticLocation.\n        auto\
  \ R = std::make_unique<BasicBugReport>(\n            *BT,\n            \"Pointer\
  \ freed in cleanup then retried without resetting to NULL; \"\n            \"early\
  \ goto can double free\",\n            PathDiagnosticLocation(FS.FreeLoc, SM));\n\
  \        R->addRange(FS.FreeCall->getSourceRange());\n        BR.emitReport(std::move(R));\n\
  \        // No need to continue for more gotos for this FreeSite; one is enough.\n\
  \        break;\n      }\n    }\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects possible double free across\
  \ replay/retry loop due to missing NULL reset\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
