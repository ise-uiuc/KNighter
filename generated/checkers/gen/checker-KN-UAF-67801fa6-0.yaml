_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 67801fa67b94ebd0e4da7a77ac2d9f321b75fbe0
commit_type: UAF
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(PendingPublishMap,\
  \ SymbolRef, const MemRegion*)\nREGISTER_MAP_WITH_PROGRAMSTATE(PublishedObjMap,\
  \ const MemRegion*, bool)\n\nnamespace {\nclass SAGenTestChecker\n  : public Checker<\n\
  \      check::PostCall,\n      eval::Assume,\n      check::Location,\n      check::PreCall\n\
  \    > {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"ID publication before finishing initialization\", \"\
  API Misuse\")) {}\n\n      void checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n      ProgramStateRef evalAssume(ProgramStateRef State, SVal Cond,\
  \ bool Assumption) const;\n      void checkLocation(SVal Loc, bool IsLoad, const\
  \ Stmt *S, CheckerContext &C) const;\n      void checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n\n   private:\n      static bool isPublishCall(const\
  \ CallEvent &Call, unsigned &ObjArgIdx, CheckerContext &C);\n      static const\
  \ MemRegion *getPointeeBaseRegionFromSVal(SVal V);\n      void reportUseAfterPublish(const\
  \ Stmt *S, CheckerContext &C) const;\n      void reportUseAfterPublishForCall(const\
  \ CallEvent &Call, unsigned ArgIdx, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isPublishCall(const\
  \ CallEvent &Call, unsigned &ObjArgIdx, CheckerContext &C) {\n  const Expr *OriginExpr\
  \ = Call.getOriginExpr();\n  if (!OriginExpr)\n    return false;\n\n  // Use ExprHasName\
  \ for robust name matching\n  if (ExprHasName(OriginExpr, \"xa_alloc\", C)) {\n\
  \    ObjArgIdx = 2; // xa_alloc(..., &id, obj, ...)\n    return Call.getNumArgs()\
  \ > ObjArgIdx;\n  }\n  if (ExprHasName(OriginExpr, \"idr_alloc\", C)) {\n    ObjArgIdx\
  \ = 1; // idr_alloc(idr, obj, start, end)\n    return Call.getNumArgs() > ObjArgIdx;\n\
  \  }\n  if (ExprHasName(OriginExpr, \"idr_alloc_u32\", C)) {\n    ObjArgIdx = 1;\
  \ // idr_alloc_u32(idr, obj, &id, gfp)\n    return Call.getNumArgs() > ObjArgIdx;\n\
  \  }\n  return false;\n}\n\nconst MemRegion *SAGenTestChecker::getPointeeBaseRegionFromSVal(SVal\
  \ V) {\n  const MemRegion *MR = V.getAsRegion();\n  if (!MR)\n    return nullptr;\n\
  \  MR = MR->getBaseRegion();\n  return MR;\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  unsigned ObjIdx = 0;\n  if (!isPublishCall(Call,\
  \ ObjIdx, C))\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  // Extract\
  \ the object pointee's base region.\n  const MemRegion *ObjRegion = getPointeeBaseRegionFromSVal(Call.getArgSVal(ObjIdx));\n\
  \  if (!ObjRegion)\n    return;\n\n  // Track the return symbol to disambiguate\
  \ success via evalAssume.\n  SVal RetSVal = Call.getReturnValue();\n  SymbolRef\
  \ RetSym = RetSVal.getAsSymbol();\n\n  if (RetSym) {\n    // Pending publish until\
  \ we know the success path (err == 0)\n    State = State->set<PendingPublishMap>(RetSym,\
  \ ObjRegion);\n  } else {\n    // Fallback: if return is not symbolic, conservatively\
  \ consider published\n    State = State->set<PublishedObjMap>(ObjRegion, true);\n\
  \  }\n\n  C.addTransition(State);\n}\n\nProgramStateRef SAGenTestChecker::evalAssume(ProgramStateRef\
  \ State, SVal Cond, bool Assumption) const {\n  // We only care about conditions\
  \ looking like \"if (err)\" immediately after a publish call.\n  SymbolRef CondSym\
  \ = Cond.getAsSymbol();\n  if (!CondSym)\n    return State;\n\n  const MemRegion\
  \ *ObjRegion = State->get<PendingPublishMap>(CondSym);\n  if (!ObjRegion)\n    return\
  \ State;\n\n  // For \"if (err)\" - false branch (Assumption == false) means err\
  \ == 0 => success.\n  if (!Assumption) {\n    State = State->set<PublishedObjMap>(ObjRegion,\
  \ true);\n  }\n\n  // Remove from pending regardless of the branch, we consumed\
  \ it.\n  State = State->remove<PendingPublishMap>(CondSym);\n  return State;\n}\n\
  \nvoid SAGenTestChecker::reportUseAfterPublish(const Stmt *S, CheckerContext &C)\
  \ const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Object used\
  \ after publishing ID; make ID allocation the last step\", N);\n  if (S)\n    R->addRange(S->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::reportUseAfterPublishForCall(const\
  \ CallEvent &Call, unsigned ArgIdx, CheckerContext &C) const {\n  ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Passing object to a dereferencing function after ID publication\"\
  , N);\n  if (const Expr *E = Call.getArgExpr(ArgIdx))\n    R->addRange(E->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkLocation(SVal Loc,\
  \ bool IsLoad, const Stmt *S, CheckerContext &C) const {\n  const MemRegion *MR\
  \ = Loc.getAsRegion();\n  if (!MR)\n    return;\n\n  // Always use base region\n\
  \  const MemRegion *Base = MR->getBaseRegion();\n  if (!Base)\n    return;\n\n \
  \ ProgramStateRef State = C.getState();\n  const bool *IsPublished = State->get<PublishedObjMap>(Base);\n\
  \  if (IsPublished && *IsPublished) {\n    // Any load/store through the object\
  \ after publication is suspicious.\n    reportUseAfterPublish(S, C);\n  }\n}\n\n\
  void SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  // Ignore the publishing calls themselves here.\n  unsigned Dummy;\n  if\
  \ (isPublishCall(Call, Dummy, C))\n    return;\n\n  // If the callee is known to\
  \ dereference some pointer parameters, and we pass\n  // a published object for\
  \ those, report.\n  llvm::SmallVector<unsigned, 4> DerefParams;\n  if (!functionKnownToDeref(Call,\
  \ DerefParams))\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  for\
  \ (unsigned Idx : DerefParams) {\n    if (Idx >= Call.getNumArgs())\n      continue;\n\
  \n    const MemRegion *ArgReg = getPointeeBaseRegionFromSVal(Call.getArgSVal(Idx));\n\
  \    if (!ArgReg)\n      continue;\n\n    const bool *IsPublished = State->get<PublishedObjMap>(ArgReg);\n\
  \    if (IsPublished && *IsPublished) {\n      reportUseAfterPublishForCall(Call,\
  \ Idx, C);\n      // Don't break; continue to find all problematic args if any.\n\
  \    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects using an object after publishing it to an ID table (xa_alloc/idr_alloc)\
  \ before finishing initialization\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/xe/queue: move xa_alloc to prevent UAF\n\nEvil\
  \ user can guess the next id of the queue before the ioctl completes\nand then call\
  \ queue destroy ioctl to trigger UAF since create ioctl is\nstill referencing the\
  \ same queue. Move the xa_alloc all the way to the end\nto prevent this.\n\nv2:\n\
  \ - Rebase\n\nFixes: 2149ded63079 (\"drm/xe: Fix use after free when client stats\
  \ are captured\")\nSigned-off-by: Matthew Auld <matthew.auld@intel.com>\nCc: Matthew\
  \ Brost <matthew.brost@intel.com>\nReviewed-by: Nirmoy Das <nirmoy.das@intel.com>\n\
  Reviewed-by: Matthew Brost <matthew.brost@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20240925071426.144015-4-matthew.auld@intel.com\n\
  (cherry picked from commit 16536582ddbebdbdf9e1d7af321bbba2bf955a87)\nSigned-off-by:\
  \ Lucas De Marchi <lucas.demarchi@intel.com>\n\n## Buggy Code\n\n```c\n// Function:\
  \ xe_exec_queue_create_ioctl in drivers/gpu/drm/xe/xe_exec_queue.c\nint xe_exec_queue_create_ioctl(struct\
  \ drm_device *dev, void *data,\n\t\t\t       struct drm_file *file)\n{\n\tstruct\
  \ xe_device *xe = to_xe_device(dev);\n\tstruct xe_file *xef = to_xe_file(file);\n\
  \tstruct drm_xe_exec_queue_create *args = data;\n\tstruct drm_xe_engine_class_instance\
  \ eci[XE_HW_ENGINE_MAX_INSTANCE];\n\tstruct drm_xe_engine_class_instance __user\
  \ *user_eci =\n\t\tu64_to_user_ptr(args->instances);\n\tstruct xe_hw_engine *hwe;\n\
  \tstruct xe_vm *vm;\n\tstruct xe_gt *gt;\n\tstruct xe_tile *tile;\n\tstruct xe_exec_queue\
  \ *q = NULL;\n\tu32 logical_mask;\n\tu32 id;\n\tu32 len;\n\tint err;\n\n\tif (XE_IOCTL_DBG(xe,\
  \ args->flags) ||\n\t    XE_IOCTL_DBG(xe, args->reserved[0] || args->reserved[1]))\n\
  \t\treturn -EINVAL;\n\n\tlen = args->width * args->num_placements;\n\tif (XE_IOCTL_DBG(xe,\
  \ !len || len > XE_HW_ENGINE_MAX_INSTANCE))\n\t\treturn -EINVAL;\n\n\terr = __copy_from_user(eci,\
  \ user_eci,\n\t\t\t       sizeof(struct drm_xe_engine_class_instance) *\n\t\t\t\
  \       len);\n\tif (XE_IOCTL_DBG(xe, err))\n\t\treturn -EFAULT;\n\n\tif (XE_IOCTL_DBG(xe,\
  \ eci[0].gt_id >= xe->info.gt_count))\n\t\treturn -EINVAL;\n\n\tif (eci[0].engine_class\
  \ == DRM_XE_ENGINE_CLASS_VM_BIND) {\n\t\tif (XE_IOCTL_DBG(xe, args->width != 1)\
  \ ||\n\t\t    XE_IOCTL_DBG(xe, args->num_placements != 1) ||\n\t\t    XE_IOCTL_DBG(xe,\
  \ eci[0].engine_instance != 0))\n\t\t\treturn -EINVAL;\n\n\t\tfor_each_tile(tile,\
  \ xe, id) {\n\t\t\tstruct xe_exec_queue *new;\n\t\t\tu32 flags = EXEC_QUEUE_FLAG_VM;\n\
  \n\t\t\tif (id)\n\t\t\t\tflags |= EXEC_QUEUE_FLAG_BIND_ENGINE_CHILD;\n\n\t\t\tnew\
  \ = xe_exec_queue_create_bind(xe, tile, flags,\n\t\t\t\t\t\t\targs->extensions);\n\
  \t\t\tif (IS_ERR(new)) {\n\t\t\t\terr = PTR_ERR(new);\n\t\t\t\tif (q)\n\t\t\t\t\t\
  goto put_exec_queue;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (id == 0)\n\t\t\t\t\
  q = new;\n\t\t\telse\n\t\t\t\tlist_add_tail(&new->multi_gt_list,\n\t\t\t\t\t   \
  \   &q->multi_gt_link);\n\t\t}\n\t} else {\n\t\tgt = xe_device_get_gt(xe, eci[0].gt_id);\n\
  \t\tlogical_mask = calc_validate_logical_mask(xe, gt, eci,\n\t\t\t\t\t\t\t  args->width,\n\
  \t\t\t\t\t\t\t  args->num_placements);\n\t\tif (XE_IOCTL_DBG(xe, !logical_mask))\n\
  \t\t\treturn -EINVAL;\n\n\t\thwe = xe_hw_engine_lookup(xe, eci[0]);\n\t\tif (XE_IOCTL_DBG(xe,\
  \ !hwe))\n\t\t\treturn -EINVAL;\n\n\t\tvm = xe_vm_lookup(xef, args->vm_id);\n\t\t\
  if (XE_IOCTL_DBG(xe, !vm))\n\t\t\treturn -ENOENT;\n\n\t\terr = down_read_interruptible(&vm->lock);\n\
  \t\tif (err) {\n\t\t\txe_vm_put(vm);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (XE_IOCTL_DBG(xe,\
  \ xe_vm_is_closed_or_banned(vm))) {\n\t\t\tup_read(&vm->lock);\n\t\t\txe_vm_put(vm);\n\
  \t\t\treturn -ENOENT;\n\t\t}\n\n\t\tq = xe_exec_queue_create(xe, vm, logical_mask,\n\
  \t\t\t\t\t args->width, hwe, 0,\n\t\t\t\t\t args->extensions);\n\t\tup_read(&vm->lock);\n\
  \t\txe_vm_put(vm);\n\t\tif (IS_ERR(q))\n\t\t\treturn PTR_ERR(q);\n\n\t\tif (xe_vm_in_preempt_fence_mode(vm))\
  \ {\n\t\t\tq->lr.context = dma_fence_context_alloc(1);\n\n\t\t\terr = xe_vm_add_compute_exec_queue(vm,\
  \ q);\n\t\t\tif (XE_IOCTL_DBG(xe, err))\n\t\t\t\tgoto put_exec_queue;\n\t\t}\n\n\
  \t\tif (q->vm && q->hwe->hw_engine_group) {\n\t\t\terr = xe_hw_engine_group_add_exec_queue(q->hwe->hw_engine_group,\
  \ q);\n\t\t\tif (err)\n\t\t\t\tgoto put_exec_queue;\n\t\t}\n\t}\n\n\terr = xa_alloc(&xef->exec_queue.xa,\
  \ &id, q, xa_limit_32b, GFP_KERNEL);\n\tif (err)\n\t\tgoto kill_exec_queue;\n\n\t\
  args->exec_queue_id = id;\n\tq->xef = xe_file_get(xef);\n\n\treturn 0;\n\nkill_exec_queue:\n\
  \txe_exec_queue_kill(q);\nput_exec_queue:\n\txe_exec_queue_put(q);\n\treturn err;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/xe/xe_exec_queue.c\
  \ b/drivers/gpu/drm/xe/xe_exec_queue.c\nindex 7743ebdcbf4b..d098d2dd1b2d 100644\n\
  --- a/drivers/gpu/drm/xe/xe_exec_queue.c\n+++ b/drivers/gpu/drm/xe/xe_exec_queue.c\n\
  @@ -635,12 +635,14 @@ int xe_exec_queue_create_ioctl(struct drm_device *dev, void\
  \ *data,\n \t\t}\n \t}\n \n+\tq->xef = xe_file_get(xef);\n+\n+\t/* user id alloc\
  \ must always be last in ioctl to prevent UAF */\n \terr = xa_alloc(&xef->exec_queue.xa,\
  \ &id, q, xa_limit_32b, GFP_KERNEL);\n \tif (err)\n \t\tgoto kill_exec_queue;\n\
  \ \n \targs->exec_queue_id = id;\n-\tq->xef = xe_file_get(xef);\n \n \treturn 0;\n\
  \ \n```\n"
pattern: '## Bug Pattern


  Publishing a newly created kernel object to a user-visible ID table (e.g., via xa_alloc()/idr_alloc())
  before the object is fully initialized and before the ioctl returns. Because IDs
  are predictable, a malicious user can issue a destroy operation on the guessed ID
  while the create ioctl still uses the object, leading to a use-after-free. The fix
  is to perform all initialization and take required references first, and make the
  ID allocation/publication the last step.'
plan: "Plan to detect \u201Cpublishing ID before finishing initialization\u201D (xa_alloc/idr_alloc\
  \ done too early)\n\n1. Program state (lightweight; keep it simple)\n   - REGISTER_MAP_WITH_PROGRAMSTATE(PendingPublishMap,\
  \ SymbolRef, const MemRegion*)\n     - Maps the return symbol of a publish call\
  \ (xa_alloc/idr_alloc) to the object\u2019s pointee MemRegion. While in this map,\
  \ we treat the publication as \u201Cpending,\u201D i.e., success/error not yet disambiguated.\n\
  \   - REGISTER_MAP_WITH_PROGRAMSTATE(PublishedObjMap, const MemRegion*, bool)\n\
  \     - A set (map-to-bool) of object pointee regions that are known to be published\
  \ on the success path. Only objects in this set will trigger reports when subsequently\
  \ used.\n\n   Rationale:\n   - We avoid expensive whole-object modeling and alias\
  \ tracking. We key on the pointee MemRegion (not the pointer variable), which is\
  \ stable across aliases.\n   - We try to distinguish success paths from error paths\
  \ to reduce false positives.\n\n2. Helper predicates and utilities\n   - isPublishCall(const\
  \ CallEvent &Call, unsigned &ObjArgIdx):\n     - Return true for known publishing\
  \ APIs and set ObjArgIdx for the object pointer argument:\n       - xa_alloc: ObjArgIdx\
  \ = 2\n       - idr_alloc, idr_alloc_u32: ObjArgIdx = 1\n     - Optionally extend\
  \ with other known variants if necessary (xa_insert, idr_replace), but start with\
  \ the three above.\n   - getPointeeRegion(SVal V): return V.getAsRegion() if V is\
  \ a loc::MemRegionVal; otherwise nullptr.\n   - getRootThroughSuper(const MemRegion\
  \ *R): climb through FieldRegion/ElementRegion/CXXBaseObjectRegion/etc. until reaching\
  \ the root region.\n   - isRegionOrSubregionOf(const MemRegion *R, const MemRegion\
  \ *Base):\n     - Walk R up via getSuperRegion() and check if any ancestor equals\
  \ Base.\n\n3. checkPostCall (track publish calls and seed the \u201Cpending\u201D\
  \ state)\n   - If isPublishCall(Call, ObjArgIdx) is false, return.\n   - Obtain\
  \ the object pointee region:\n     - const MemRegion *ObjRegion = getPointeeRegion(Call.getArgSVal(ObjArgIdx));\n\
  \     - If null, return (cannot reason).\n   - Obtain the return value symbol of\
  \ the publish call:\n     - SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\n\
  \   - If RetSym is non-null:\n     - Add (RetSym -> ObjRegion) to PendingPublishMap.\
  \ Do not mark as Published yet; we\u2019ll resolve success vs. error via evalAssume.\n\
  \   - If RetSym is null (e.g., analyzer concretized it):\n     - Conservative fallback:\
  \ directly set PublishedObjMap[ObjRegion] = true. This may increase false positives\
  \ but ensures we catch clear cases.\n\n4. evalAssume (disambiguate success vs. error\
  \ on simple \u201Cif (err)\u201D patterns)\n   - Called on each branch assumption.\
  \ Use this to move from \u201Cpending\u201D to \u201Cpublished-on-success\u201D\
  \ when we see conditions of the form if (err) or if (!err).\n   - Try to extract\
  \ a symbol from Cond:\n     - if (const SymbolRef Sym = Cond.getAsSymbol()) { ...\
  \ }\n       - If Sym is in PendingPublishMap with ObjRegion:\n         - For if\
  \ (err) where Assumption == false (i.e., err == 0 path), treat as success:\n   \
  \        - State = State->set(PublishedObjMap, ObjRegion, true)\n         - In any\
  \ case (true/false), remove Sym from PendingPublishMap (we\u2019ve consumed that\
  \ pending publication).\n   - Notes:\n     - This handles the very common pattern\
  \ err = xa_alloc(...); if (err) goto error; by marking published only on the success\
  \ path (err == 0).\n     - We intentionally do not try to fully parse complex relational\
  \ conditions; the basic pattern is sufficient to drastically reduce false positives\
  \ for the Linux idiom \u201Cif (err)\u201D.\n\n5. checkLocation (flag dereference/field\
  \ access of published object after publication, before function returns)\n   - Triggered\
  \ on loads/stores (deref).\n   - Extract the MemRegion from Loc; if not a MemRegionVal,\
  \ return.\n   - Let Root = getRootThroughSuper(Region).\n   - For each ObjRegion\
  \ in PublishedObjMap:\n     - If isRegionOrSubregionOf(Root, ObjRegion) is true,\
  \ report a bug:\n       - Message: \u201CObject used after ID publication; make\
  \ xa_alloc()/idr_alloc() the last step.\u201D\n       - Create report with std::make_unique<PathSensitiveBugReport>.\n\
  \   - Rationale:\n     - Any struct field access or deref after ID publication is\
  \ the core symptom. In the provided patch, q->xef = xe_file_get(xef) after xa_alloc\
  \ is exactly this.\n\n6. checkPreCall (flag passing the published object to functions\
  \ known to dereference it)\n   - For any Call that is not a publishing call:\n \
  \    - Collect all published object regions from PublishedObjMap.\n     - For each\
  \ argument i:\n       - const MemRegion *ArgPointee = getPointeeRegion(Call.getArgSVal(i));\n\
  \       - If ArgPointee matches any ObjRegion in PublishedObjMap:\n         - Optionally\
  \ use functionKnownToDeref(Call, DerefParams):\n           - If functionKnownToDeref\
  \ is true and i is in DerefParams, report.\n         - Otherwise, be conservative\
  \ and do not report (to avoid false positives when the callee only forwards/stores).\n\
  \   - Rationale:\n     - This catches dangerous use-after-publication via function\
  \ calls that definitely deref the object pointer.\n\n7. checkPreStmt(const ReturnStmt\
  \ *) or checkEndFunction\n   - No reporting here; the reports are raised at the\
  \ first unsafe use site after publication.\n   - Let the state naturally disappear\
  \ at end-of-function. No special cleanup is required.\n\n8. Bug reporting\n   -\
  \ Use a single BugType: \u201CID publication before finishing init\u201D\n   - Short\
  \ message: \u201CObject used after ID publication; publish ID as the last step.\u201D\
  \n   - Use generateNonFatalErrorNode + PathSensitiveBugReport; attach the expression/stmt\
  \ that dereferences/uses the object after publication.\n\n9. Notes to reduce false\
  \ positives\n   - Publication is only marked as Published when:\n     - We saw the\
  \ publish call and:\n       - Either evalAssume observes a simple success path \u201C\
  err == 0\u201D (if (err)), or\n       - The publish call returned a non-symbolic\
  \ constant (fallback).\n   - We only report on:\n     - Explicit dereferences/field\
  \ accesses (via checkLocation) of the published object, or\n     - Calls to functions\
  \ known to dereference the pointer (via functionKnownToDeref) when passing the published\
  \ object as an argument.\n   - We do not require tracking \u201Ccreated objects\u201D\
  \ separately. Keying on the pointee region of the object argument of the publish\
  \ call is sufficient to identify the exact object and its later uses across aliases.\n\
  \n10. Summary of callbacks and their roles\n   - checkPostCall:\n     - Detect calls\
  \ to xa_alloc/idr_alloc*, extract the object pointee region, save (RetSym -> ObjRegion)\
  \ in PendingPublishMap, or immediately publish if RetSym is not a symbol.\n   -\
  \ evalAssume:\n     - On conditions \u201Cif (err)\u201D, move ObjRegion from pending\
  \ into PublishedObjMap on the success path (err == 0).\n   - checkLocation:\n  \
  \   - Report on any dereference or field access of a published object.\n   - checkPreCall:\n\
  \     - Report if a published object is passed to a function known to dereference\
  \ that argument.\n   - checkEndFunction/checkPreStmt(ReturnStmt):\n     - No special\
  \ action needed."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(PendingPublishMap,\
  \ SymbolRef, const MemRegion*)\nREGISTER_MAP_WITH_PROGRAMSTATE(PublishedObjMap,\
  \ const MemRegion*, bool)\n\nnamespace {\nclass SAGenTestChecker\n  : public Checker<\n\
  \      check::PostCall,\n      eval::Assume,\n      check::Location,\n      check::PreCall\n\
  \    > {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"ID publication before finishing initialization\", \"\
  API Misuse\")) {}\n\n      void checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n      ProgramStateRef evalAssume(ProgramStateRef State, SVal Cond,\
  \ bool Assumption) const;\n      void checkLocation(SVal Loc, bool IsLoad, const\
  \ Stmt *S, CheckerContext &C) const;\n      void checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n\n   private:\n      static bool isPublishCall(const\
  \ CallEvent &Call, unsigned &ObjArgIdx, CheckerContext &C);\n      static const\
  \ MemRegion *getPointeeBaseRegionFromSVal(SVal V);\n      void reportUseAfterPublish(const\
  \ Stmt *S, CheckerContext &C) const;\n      void reportUseAfterPublishForCall(const\
  \ CallEvent &Call, unsigned ArgIdx, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isPublishCall(const\
  \ CallEvent &Call, unsigned &ObjArgIdx, CheckerContext &C) {\n  const Expr *OriginExpr\
  \ = Call.getOriginExpr();\n  if (!OriginExpr)\n    return false;\n\n  // Use ExprHasName\
  \ for robust name matching\n  if (ExprHasName(OriginExpr, \"xa_alloc\", C)) {\n\
  \    ObjArgIdx = 2; // xa_alloc(..., &id, obj, ...)\n    return Call.getNumArgs()\
  \ > ObjArgIdx;\n  }\n  if (ExprHasName(OriginExpr, \"idr_alloc\", C)) {\n    ObjArgIdx\
  \ = 1; // idr_alloc(idr, obj, start, end)\n    return Call.getNumArgs() > ObjArgIdx;\n\
  \  }\n  if (ExprHasName(OriginExpr, \"idr_alloc_u32\", C)) {\n    ObjArgIdx = 1;\
  \ // idr_alloc_u32(idr, obj, &id, gfp)\n    return Call.getNumArgs() > ObjArgIdx;\n\
  \  }\n  return false;\n}\n\nconst MemRegion *SAGenTestChecker::getPointeeBaseRegionFromSVal(SVal\
  \ V) {\n  const MemRegion *MR = V.getAsRegion();\n  if (!MR)\n    return nullptr;\n\
  \  MR = MR->getBaseRegion();\n  return MR;\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  unsigned ObjIdx = 0;\n  if (!isPublishCall(Call,\
  \ ObjIdx, C))\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  // Extract\
  \ the object pointee's base region.\n  const MemRegion *ObjRegion = getPointeeBaseRegionFromSVal(Call.getArgSVal(ObjIdx));\n\
  \  if (!ObjRegion)\n    return;\n\n  // Track the return symbol to disambiguate\
  \ success via evalAssume.\n  SVal RetSVal = Call.getReturnValue();\n  SymbolRef\
  \ RetSym = RetSVal.getAsSymbol();\n\n  if (RetSym) {\n    // Pending publish until\
  \ we know the success path (err == 0)\n    State = State->set<PendingPublishMap>(RetSym,\
  \ ObjRegion);\n  } else {\n    // Fallback: if return is not symbolic, conservatively\
  \ consider published\n    State = State->set<PublishedObjMap>(ObjRegion, true);\n\
  \  }\n\n  C.addTransition(State);\n}\n\nProgramStateRef SAGenTestChecker::evalAssume(ProgramStateRef\
  \ State, SVal Cond, bool Assumption) const {\n  // We only care about conditions\
  \ looking like \"if (err)\" immediately after a publish call.\n  SymbolRef CondSym\
  \ = Cond.getAsSymbol();\n  if (!CondSym)\n    return State;\n\n  const MemRegion\
  \ *const *ObjRegionPtr = State->get<PendingPublishMap>(CondSym);\n  if (!ObjRegionPtr)\n\
  \    return State;\n  const MemRegion *ObjRegion = *ObjRegionPtr;\n\n  // For \"\
  if (err)\" - false branch (Assumption == false) means err == 0 => success.\n  if\
  \ (!Assumption) {\n    State = State->set<PublishedObjMap>(ObjRegion, true);\n \
  \ }\n\n  // Remove from pending regardless of the branch, we consumed it.\n  State\
  \ = State->remove<PendingPublishMap>(CondSym);\n  return State;\n}\n\nvoid SAGenTestChecker::reportUseAfterPublish(const\
  \ Stmt *S, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Object used after publishing ID; make ID allocation the last step\"\
  , N);\n  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::reportUseAfterPublishForCall(const CallEvent &Call,\
  \ unsigned ArgIdx, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Passing object to a dereferencing function after ID publication\"\
  , N);\n  if (const Expr *E = Call.getArgExpr(ArgIdx))\n    R->addRange(E->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkLocation(SVal Loc,\
  \ bool IsLoad, const Stmt *S, CheckerContext &C) const {\n  const MemRegion *MR\
  \ = Loc.getAsRegion();\n  if (!MR)\n    return;\n\n  // Always use base region\n\
  \  const MemRegion *Base = MR->getBaseRegion();\n  if (!Base)\n    return;\n\n \
  \ ProgramStateRef State = C.getState();\n  const bool *IsPublished = State->get<PublishedObjMap>(Base);\n\
  \  if (IsPublished && *IsPublished) {\n    // Any load/store through the object\
  \ after publication is suspicious.\n    reportUseAfterPublish(S, C);\n  }\n}\n\n\
  void SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  // Ignore the publishing calls themselves here.\n  unsigned Dummy;\n  if\
  \ (isPublishCall(Call, Dummy, C))\n    return;\n\n  // If the callee is known to\
  \ dereference some pointer parameters, and we pass\n  // a published object for\
  \ those, report.\n  llvm::SmallVector<unsigned, 4> DerefParams;\n  if (!functionKnownToDeref(Call,\
  \ DerefParams))\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  for\
  \ (unsigned Idx : DerefParams) {\n    if (Idx >= Call.getNumArgs())\n      continue;\n\
  \n    const MemRegion *ArgReg = getPointeeBaseRegionFromSVal(Call.getArgSVal(Idx));\n\
  \    if (!ArgReg)\n      continue;\n\n    const bool *IsPublished = State->get<PublishedObjMap>(ArgReg);\n\
  \    if (IsPublished && *IsPublished) {\n      reportUseAfterPublishForCall(Call,\
  \ Idx, C);\n      // Don't break; continue to find all problematic args if any.\n\
  \    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects using an object after publishing it to an ID table (xa_alloc/idr_alloc)\
  \ before finishing initialization\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
