_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: b58b1b883b9b702e25204dbe2b221eecc8ecd159
commit_type: Buffer-Overflow
index: 6
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/ExprCXX.h\"\
  \n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing\
  \ namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program\
  \ state to track \"shorten-like\" variables and their associated iter object.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(ShortenToIterMap, const MemRegion*, const MemRegion*)\n\
  // Whether a given \"shorten-like\" variable has been guarded on the current path.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(ShortenGuardedMap, const MemRegion*, bool)\n\nnamespace\
  \ {\n\nclass SAGenTestChecker : public Checker<\n    check::Bind,\n    check::BranchCondition\n\
  \  > {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"iov_iter count underflow\", \"API Misuse\")) {}\n\n \
  \     void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \      void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \n   private:\n\n      // Helpers\n      static const MemRegion* getVarRegionFromExpr(const\
  \ Expr *E, CheckerContext &C);\n      static bool isCallNamed(const Expr *E, StringRef\
  \ Name, CheckerContext &C);\n      static bool isRoundUpCall(const Expr *E, CheckerContext\
  \ &C);\n      static bool isIovIterLenExpr(const Expr *E, const MemRegion* &IterRegion,\n\
  \                                   bool &IsMemberCount, CheckerContext &C);\n \
  \     static const FieldRegion* getCountFieldRegionFromLoc(const MemRegion *MR);\n\
  \      static const MemRegion* getIterRegionFromCountFieldExpr(const Expr *E, CheckerContext\
  \ &C);\n      static bool isZeroSVal(SVal V);\n      static bool regionsEqual(const\
  \ MemRegion *A, const MemRegion *B) {\n        return A == B;\n      }\n};\n\nconst\
  \ MemRegion* SAGenTestChecker::getVarRegionFromExpr(const Expr *E, CheckerContext\
  \ &C) {\n  if (!E) return nullptr;\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR) return nullptr;\n  return MR->getBaseRegion();\n}\n\nbool SAGenTestChecker::isCallNamed(const\
  \ Expr *E, StringRef Name, CheckerContext &C) {\n  if (!E) return false;\n  const\
  \ Expr *EI = E->IgnoreParenCasts();\n  // Prefer source text check for robustness\
  \ across inline/helper wrappers.\n  return ExprHasName(EI, Name, C);\n}\n\nbool\
  \ SAGenTestChecker::isRoundUpCall(const Expr *E, CheckerContext &C) {\n  const Expr\
  \ *EI = E ? E->IgnoreParenCasts() : nullptr;\n  if (!EI) return false;\n  const\
  \ CallExpr *CE = dyn_cast<CallExpr>(EI);\n  if (!CE) return false;\n  // Use textual\
  \ name check for 'round_up'\n  return isCallNamed(EI, \"round_up\", C);\n}\n\nbool\
  \ SAGenTestChecker::isIovIterLenExpr(const Expr *E, const MemRegion* &IterRegion,\n\
  \                                        bool &IsMemberCount, CheckerContext &C)\
  \ {\n  IterRegion = nullptr;\n  IsMemberCount = false;\n  if (!E) return false;\n\
  \n  const Expr *EI = E->IgnoreParenCasts();\n\n  // Case 1: Call to iov_iter_count(iter)\n\
  \  if (const auto *Call = dyn_cast<CallExpr>(EI)) {\n    if (isCallNamed(EI, \"\
  iov_iter_count\", C)) {\n      if (Call->getNumArgs() >= 1) {\n        const Expr\
  \ *Arg0 = Call->getArg(0);\n        const MemRegion *MR = getMemRegionFromExpr(Arg0,\
  \ C);\n        if (!MR) return false;\n        IterRegion = MR->getBaseRegion();\n\
  \        IsMemberCount = false;\n        return IterRegion != nullptr;\n      }\n\
  \    }\n  }\n\n  // Case 2: MemberExpr iter->count\n  if (const auto *ME = dyn_cast<MemberExpr>(EI))\
  \ {\n    const FieldDecl *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());\n    if\
  \ (!FD) return false;\n    IdentifierInfo *II = FD->getIdentifier();\n    if (!II)\
  \ return false;\n    // field name 'count'\n    if (II->getName() == \"count\")\
  \ {\n      const Expr *Base = ME->getBase();\n      if (!Base) return false;\n \
  \     const MemRegion *MR = getMemRegionFromExpr(Base, C);\n      if (!MR) return\
  \ false;\n      IterRegion = MR->getBaseRegion();\n      IsMemberCount = true;\n\
  \      return IterRegion != nullptr;\n    }\n  }\n\n  return false;\n}\n\nconst\
  \ FieldRegion* SAGenTestChecker::getCountFieldRegionFromLoc(const MemRegion *MR)\
  \ {\n  if (!MR) return nullptr;\n  const FieldRegion *FR = dyn_cast<FieldRegion>(MR);\n\
  \  if (!FR) return nullptr;\n  const FieldDecl *FD = FR->getDecl();\n  if (!FD)\
  \ return nullptr;\n  const IdentifierInfo *II = FD->getIdentifier();\n  if (!II)\
  \ return nullptr;\n  if (II->getName() != \"count\") return nullptr;\n  return FR;\n\
  }\n\nconst MemRegion* SAGenTestChecker::getIterRegionFromCountFieldExpr(const Expr\
  \ *E, CheckerContext &C) {\n  const Expr *EI = E ? E->IgnoreParenCasts() : nullptr;\n\
  \  if (!EI) return nullptr;\n  if (const auto *ME = dyn_cast<MemberExpr>(EI)) {\n\
  \    const FieldDecl *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());\n    if (!FD)\
  \ return nullptr;\n    const IdentifierInfo *II = FD->getIdentifier();\n    if (!II\
  \ || II->getName() != \"count\") return nullptr;\n    const Expr *Base = ME->getBase();\n\
  \    if (!Base) return nullptr;\n    const MemRegion *MR = getMemRegionFromExpr(Base,\
  \ C);\n    if (!MR) return nullptr;\n    return MR->getBaseRegion();\n  }\n  return\
  \ nullptr;\n}\n\nbool SAGenTestChecker::isZeroSVal(SVal V) {\n  if (auto CI = V.getAs<nonloc::ConcreteInt>())\
  \ {\n    const llvm::APSInt &X = CI->getValue();\n    return X == 0;\n  }\n  return\
  \ false;\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S,\
  \ CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\n  const\
  \ MemRegion *LReg = Loc.getAsRegion();\n  if (!LReg) {\n    return;\n  }\n  LReg\
  \ = LReg->getBaseRegion();\n  if (!LReg)\n    return;\n\n  // 1) Detect \"shorten-like\"\
  \ computation:\n  //    shorten = iov_iter_count(iter) - round_up(...)\n  // We\
  \ analyze the statement S to find a subtraction operator.\n  if (S) {\n    // If\
  \ LHS location is a variable region, try to detect RHS pattern.\n    const BinaryOperator\
  \ *BO = findSpecificTypeInChildren<BinaryOperator>(S);\n    if (BO && BO->getOpcode()\
  \ == BO_Sub) {\n      const Expr *LHS = BO->getLHS();\n      const Expr *RHS = BO->getRHS();\n\
  \n      const MemRegion *IterRegionLHS = nullptr;\n      bool IsMemberCount = false;\n\
  \      if (isIovIterLenExpr(LHS, IterRegionLHS, IsMemberCount, C) && IterRegionLHS\
  \ && isRoundUpCall(RHS, C)) {\n        // Record mapping: shorten variable -> iter\
  \ object\n        State = State->set<ShortenToIterMap>(LReg, IterRegionLHS);\n \
  \       State = State->set<ShortenGuardedMap>(LReg, false);\n        C.addTransition(State);\n\
  \        // Do not return; this same bind might also be a store to iter->count below,\
  \ but unlikely.\n      }\n    }\n  }\n\n  // Optional safety: if a tracked \"shorten\"\
  \ variable is explicitly set to 0 later,\n  // mark it as guarded.\n  if (const\
  \ bool *Tracked = State->get<ShortenGuardedMap>(LReg)) {\n    // LReg is a shorten-like\
  \ var (guarded status exists), and if assigned 0, mark guarded.\n    if (isZeroSVal(Val))\
  \ {\n      State = State->set<ShortenGuardedMap>(LReg, true);\n      C.addTransition(State);\n\
  \    }\n  }\n\n  // 2) Detect subtracting a shorten-like variable from iter->count\n\
  \  //    - Either \"iter->count -= shorten\"\n  //    - Or \"iter->count = iter->count\
  \ - shorten\"\n  // Check if the LHS location is the 'count' field.\n  const FieldRegion\
  \ *CountFR = getCountFieldRegionFromLoc(Loc.getAsRegion());\n  if (!CountFR)\n \
  \   return;\n\n  // Extract the iter object region from LHS (iter->count).\n  const\
  \ MemRegion *IterObjReg = nullptr;\n  if (const MemRegion *Super = CountFR->getSuperRegion())\n\
  \    IterObjReg = Super->getBaseRegion();\n\n  if (!IterObjReg)\n    return;\n\n\
  \  // Analyze the statement S to determine subtract operation and RHS var.\n  const\
  \ Expr *RHSExpr = nullptr;\n  const CompoundAssignOperator *CAO = dyn_cast_or_null<CompoundAssignOperator>(S);\n\
  \  if (CAO && CAO->getOpcode() == BO_SubAssign) {\n    RHSExpr = CAO->getRHS();\n\
  \  } else {\n    // Try form \"iter->count = iter->count - shorten\"\n    const\
  \ BinaryOperator *AssignBO = dyn_cast_or_null<BinaryOperator>(S);\n    if (AssignBO\
  \ && AssignBO->getOpcode() == BO_Assign) {\n      // Find a subtraction inside RHS\n\
  \      const BinaryOperator *SubBO = findSpecificTypeInChildren<BinaryOperator>(AssignBO->getRHS());\n\
  \      if (SubBO && SubBO->getOpcode() == BO_Sub) {\n        // Ensure the LHS of\
  \ subtraction is an iter length expression corresponding to this iter\n        const\
  \ MemRegion *IterRHS = nullptr;\n        bool IsMember = false;\n        if (isIovIterLenExpr(SubBO->getLHS(),\
  \ IterRHS, IsMember, C) && IterRHS && regionsEqual(IterRHS, IterObjReg)) {\n   \
  \       RHSExpr = SubBO->getRHS();\n        }\n      }\n    }\n  }\n\n  if (!RHSExpr)\n\
  \    return;\n\n  const MemRegion *ShortenReg = getVarRegionFromExpr(RHSExpr, C);\n\
  \  if (!ShortenReg)\n    return;\n\n  // Check if RHS is a tracked shorten-like\
  \ variable\n  const MemRegion *TrackedIter = State->get<ShortenToIterMap>(ShortenReg);\n\
  \  if (!TrackedIter)\n    return;\n\n  // Confirm it's the same iter object\n  if\
  \ (!regionsEqual(TrackedIter, IterObjReg))\n    return;\n\n  const bool *Guarded\
  \ = State->get<ShortenGuardedMap>(ShortenReg);\n  bool IsGuarded = Guarded && *Guarded;\n\
  \n  if (!IsGuarded) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n  \
  \  if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Possible size_t underflow: subtracting rounded-up length from iov_iter\
  \ length without guard\", N);\n    if (S)\n      R->addRange(S->getSourceRange());\n\
  \    C.emitReport(std::move(R));\n  }\n\n  // Clean up this shorten variable on\
  \ this path to reduce duplicate reports.\n  State = State->remove<ShortenToIterMap>(ShortenReg);\n\
  \  State = State->remove<ShortenGuardedMap>(ShortenReg);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE) {\n    C.addTransition(State);\n    return;\n  }\n\n  CondE = CondE->IgnoreParenImpCasts();\n\
  \n  // Handle binary relational operators\n  if (const auto *BO = dyn_cast<BinaryOperator>(CondE))\
  \ {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n\n    // Helper lambdas to\
  \ mark guarded for one shorten region\n    auto MarkGuarded = [&](const MemRegion\
  \ *ShortenReg) {\n      if (!ShortenReg) return;\n      const bool *Old = State->get<ShortenGuardedMap>(ShortenReg);\n\
  \      if (Old == nullptr || *Old == false) {\n        State = State->set<ShortenGuardedMap>(ShortenReg,\
  \ true);\n      }\n    };\n    // Helper: mark all shortens of a given iter as guarded\n\
  \    auto MarkAllForIterGuarded = [&](const MemRegion *IterReg) {\n      if (!IterReg)\
  \ return;\n      auto M = State->get<ShortenToIterMap>();\n      for (auto I = M.begin(),\
  \ E = M.end(); I != E; ++I) {\n        const MemRegion *ShortR = I->first;\n   \
  \     const MemRegion *ItR = I->second;\n        if (regionsEqual(ItR, IterReg))\
  \ {\n          const bool *Old = State->get<ShortenGuardedMap>(ShortR);\n      \
  \    if (Old == nullptr || *Old == false) {\n            State = State->set<ShortenGuardedMap>(ShortR,\
  \ true);\n          }\n        }\n      }\n    };\n\n    const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \    const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n    // Case A: \"\
  shorten >= iter->count\" or related (>, <=, <) reversed forms indicating shorten\
  \ > count\n    // We consider:\n    //  - shorten >= iter->count  => BO_GE\n   \
  \ //  - shorten >  iter->count  => BO_GT\n    //  - iter->count <= shorten  => BO_LE\n\
  \    //  - iter->count <  shorten  => BO_LT\n    bool IsRel = (Op == BO_GE || Op\
  \ == BO_GT || Op == BO_LE || Op == BO_LT);\n    if (IsRel) {\n      // Pattern A1:\
  \ shorten [>= or >] iter->count\n      const MemRegion *ShortenRegA1 = getVarRegionFromExpr(LHS,\
  \ C);\n      const MemRegion *IterFieldA1 = getIterRegionFromCountFieldExpr(RHS,\
  \ C);\n      if ((Op == BO_GE || Op == BO_GT) && ShortenRegA1 && IterFieldA1) {\n\
  \        const MemRegion *TrackedIter = State->get<ShortenToIterMap>(ShortenRegA1);\n\
  \        if (TrackedIter && regionsEqual(TrackedIter, IterFieldA1)) {\n        \
  \  MarkGuarded(ShortenRegA1);\n          C.addTransition(State);\n          return;\n\
  \        }\n      }\n\n      // Pattern A2: iter->count [<= or <] shorten\n    \
  \  const MemRegion *IterFieldA2 = getIterRegionFromCountFieldExpr(LHS, C);\n   \
  \   const MemRegion *ShortenRegA2 = getVarRegionFromExpr(RHS, C);\n      if ((Op\
  \ == BO_LE || Op == BO_LT) && IterFieldA2 && ShortenRegA2) {\n        const MemRegion\
  \ *TrackedIter = State->get<ShortenToIterMap>(ShortenRegA2);\n        if (TrackedIter\
  \ && regionsEqual(TrackedIter, IterFieldA2)) {\n          MarkGuarded(ShortenRegA2);\n\
  \          C.addTransition(State);\n          return;\n        }\n      }\n    }\n\
  \n    // Case B: \"round_up(...) <= iov_iter_count(iter)\" (or swapped with >=),\
  \ also accept iter->count.\n    bool IsLEorGE = (Op == BO_LE || Op == BO_GE);\n\
  \    if (IsLEorGE) {\n      // Pattern B1: round_up(...) <= (iov_iter_count(iter)\
  \ | iter->count)\n      if (isRoundUpCall(LHS, C)) {\n        const MemRegion *IterR\
  \ = nullptr; bool IsMember = false;\n        if (isIovIterLenExpr(RHS, IterR, IsMember,\
  \ C) && IterR) {\n          MarkAllForIterGuarded(IterR);\n          C.addTransition(State);\n\
  \          return;\n        }\n      }\n      // Pattern B2: (iov_iter_count(iter)\
  \ | iter->count) >= round_up(...)\n      if (isRoundUpCall(RHS, C)) {\n        const\
  \ MemRegion *IterR = nullptr; bool IsMember = false;\n        if (isIovIterLenExpr(LHS,\
  \ IterR, IsMember, C) && IterR) {\n          MarkAllForIterGuarded(IterR);\n   \
  \       C.addTransition(State);\n          return;\n        }\n      }\n    }\n\
  \  }\n\n  C.addTransition(State);\n}\n\n} // end anonymous namespace\n\nextern \"\
  C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects subtracting rounded-up length\
  \ from iov_iter length without guard, causing underflow\",\n      \"\");\n}\n\n\
  extern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbcachefs: fix iov_iter count underflow on sub-block\
  \ dio read\n\nbch2_direct_IO_read() checks the request offset and size for sector\n\
  alignment and then falls through to a couple calculations to shrink\nthe size of\
  \ the request based on the inode size. The problem is that\nthese checks round up\
  \ to the fs block size, which runs the risk of\nunderflowing iter->count if the\
  \ block size happens to be large\nenough. This is triggered by fstest generic/361\
  \ with a 4k block\nsize, which subsequently leads to a crash. To avoid this crash,\n\
  check that the shorten length doesn't exceed the overall length of\nthe iter.\n\n\
  Fixes:\nSigned-off-by: Brian Foster <bfoster@redhat.com>\nReviewed-by: Su Yue <glass.su@suse.com>\n\
  Signed-off-by: Kent Overstreet <kent.overstreet@linux.dev>\n\n## Buggy Code\n\n\
  ```c\n// Function: bch2_direct_IO_read in fs/bcachefs/fs-io-direct.c\nstatic int\
  \ bch2_direct_IO_read(struct kiocb *req, struct iov_iter *iter)\n{\n\tstruct file\
  \ *file = req->ki_filp;\n\tstruct bch_inode_info *inode = file_bch_inode(file);\n\
  \tstruct bch_fs *c = inode->v.i_sb->s_fs_info;\n\tstruct bch_io_opts opts;\n\tstruct\
  \ dio_read *dio;\n\tstruct bio *bio;\n\tloff_t offset = req->ki_pos;\n\tbool sync\
  \ = is_sync_kiocb(req);\n\tsize_t shorten;\n\tssize_t ret;\n\n\tbch2_inode_opts_get(&opts,\
  \ c, &inode->ei_inode);\n\n\t/* bios must be 512 byte aligned: */\n\tif ((offset|iter->count)\
  \ & (SECTOR_SIZE - 1))\n\t\treturn -EINVAL;\n\n\tret = min_t(loff_t, iter->count,\n\
  \t\t    max_t(loff_t, 0, i_size_read(&inode->v) - offset));\n\n\tif (!ret)\n\t\t\
  return ret;\n\n\tshorten = iov_iter_count(iter) - round_up(ret, block_bytes(c));\n\
  \titer->count -= shorten;\n\n\tbio = bio_alloc_bioset(NULL,\n\t\t\t       bio_iov_vecs_to_alloc(iter,\
  \ BIO_MAX_VECS),\n\t\t\t       REQ_OP_READ,\n\t\t\t       GFP_KERNEL,\n\t\t\t  \
  \     &c->dio_read_bioset);\n\n\tbio->bi_end_io = bch2_direct_IO_read_endio;\n\n\
  \tdio = container_of(bio, struct dio_read, rbio.bio);\n\tclosure_init(&dio->cl,\
  \ NULL);\n\n\t/*\n\t * this is a _really_ horrible hack just to avoid an atomic\
  \ sub at the\n\t * end:\n\t */\n\tif (!sync) {\n\t\tset_closure_fn(&dio->cl, bch2_dio_read_complete,\
  \ NULL);\n\t\tatomic_set(&dio->cl.remaining,\n\t\t\t   CLOSURE_REMAINING_INITIALIZER\
  \ -\n\t\t\t   CLOSURE_RUNNING +\n\t\t\t   CLOSURE_DESTRUCTOR);\n\t} else {\n\t\t\
  atomic_set(&dio->cl.remaining,\n\t\t\t   CLOSURE_REMAINING_INITIALIZER + 1);\n\t\
  \tdio->cl.closure_get_happened = true;\n\t}\n\n\tdio->req\t= req;\n\tdio->ret\t\
  = ret;\n\t/*\n\t * This is one of the sketchier things I've encountered: we have\
  \ to skip\n\t * the dirtying of requests that are internal from the kernel (i.e.\
  \ from\n\t * loopback), because we'll deadlock on page_lock.\n\t */\n\tdio->should_dirty\
  \ = iter_is_iovec(iter);\n\n\tgoto start;\n\twhile (iter->count) {\n\t\tbio = bio_alloc_bioset(NULL,\n\
  \t\t\t\t       bio_iov_vecs_to_alloc(iter, BIO_MAX_VECS),\n\t\t\t\t       REQ_OP_READ,\n\
  \t\t\t\t       GFP_KERNEL,\n\t\t\t\t       &c->bio_read);\n\t\tbio->bi_end_io\t\t\
  = bch2_direct_IO_read_split_endio;\nstart:\n\t\tbio->bi_opf\t\t= REQ_OP_READ|REQ_SYNC;\n\
  \t\tbio->bi_iter.bi_sector\t= offset >> 9;\n\t\tbio->bi_private\t\t= dio;\n\n\t\t\
  ret = bio_iov_iter_get_pages(bio, iter);\n\t\tif (ret < 0) {\n\t\t\t/* XXX: fault\
  \ inject this path */\n\t\t\tbio->bi_status = BLK_STS_RESOURCE;\n\t\t\tbio_endio(bio);\n\
  \t\t\tbreak;\n\t\t}\n\n\t\toffset += bio->bi_iter.bi_size;\n\n\t\tif (dio->should_dirty)\n\
  \t\t\tbio_set_pages_dirty(bio);\n\n\t\tif (iter->count)\n\t\t\tclosure_get(&dio->cl);\n\
  \n\t\tbch2_read(c, rbio_init(bio, opts), inode_inum(inode));\n\t}\n\n\titer->count\
  \ += shorten;\n\n\tif (sync) {\n\t\tclosure_sync(&dio->cl);\n\t\tclosure_debug_destroy(&dio->cl);\n\
  \t\tret = dio->ret;\n\t\tbio_check_or_release(&dio->rbio.bio, dio->should_dirty);\n\
  \t\treturn ret;\n\t} else {\n\t\treturn -EIOCBQUEUED;\n\t}\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/fs/bcachefs/fs-io-direct.c b/fs/bcachefs/fs-io-direct.c\n\
  index e3b219e19e10..33cb6da3a5ad 100644\n--- a/fs/bcachefs/fs-io-direct.c\n+++ b/fs/bcachefs/fs-io-direct.c\n\
  @@ -88,6 +88,8 @@ static int bch2_direct_IO_read(struct kiocb *req, struct iov_iter\
  \ *iter)\n \t\treturn ret;\n \n \tshorten = iov_iter_count(iter) - round_up(ret,\
  \ block_bytes(c));\n+\tif (shorten >= iter->count)\n+\t\tshorten = 0;\n \titer->count\
  \ -= shorten;\n \n \tbio = bio_alloc_bioset(NULL,\n```\n"
pattern: "## Bug Pattern\n\nComputing a reduction length with unsigned arithmetic\
  \ as:\nshorten = iov_iter_count(iter) - round_up(request_len, block_size);\nand\
  \ then doing:\niter->count -= shorten;\nwithout verifying that round_up(request_len,\
  \ block_size) <= iov_iter_count(iter).\n\nBecause size_t is unsigned, if the rounded-up\
  \ size exceeds the current iterator length, the subtraction underflows, producing\
  \ a huge \u201Cshorten\u201D and causing iter->count to wrap/underflow to a bogus\
  \ large value."
plan: "Plan\n\n1. Program state\n- No complex aliasing is required. Track only:\n\
  \  - Which local variable (key) holds a risky difference \u201Ciov_iter length \u2212\
  \ round_up(...)\u201D and to which iter object it relates.\n  - Whether that risky\
  \ variable has been guarded by a proper comparison before using it to reduce iter->count.\n\
  - Declare two maps:\n  - REGISTER_MAP_WITH_PROGRAMSTATE(ShortenToIterMap, const\
  \ MemRegion*, const MemRegion*)\n    - Key: MemRegion of the \u201Cshorten-like\u201D\
  \ variable.\n    - Value: MemRegion of the iter object (the base region for the\
  \ iov_iter pointer/struct used to compute the length).\n  - REGISTER_MAP_WITH_PROGRAMSTATE(ShortenGuardedMap,\
  \ const MemRegion*, bool)\n    - Key: MemRegion of the \u201Cshorten-like\u201D\
  \ variable.\n    - Value: true if a guard was observed on the current path; false\
  \ or no entry means unguarded.\n\n2. Helper recognition routines (internal utilities)\n\
  - isCallNamed(E, \"name\"): dyn_cast<CallExpr>(E->IgnoreParenCasts()), then check\
  \ callee identifier. As a fallback or convenience, ExprHasName(E, \"name\", C).\n\
  - isIovIterLenExpr(E, IterRegionOut):\n  - True if E is:\n    - Call to iov_iter_count(iter):\
  \ extract argument 0 and set IterRegionOut = getMemRegionFromExpr(arg0, C).\n  \
  \  - MemberExpr like iter->count (field named \"count\"): base is the iter expr;\
  \ set IterRegionOut = getMemRegionFromExpr(base, C).\n- isRoundUpCall(E): E is call\
  \ to round_up.\n- isIterCountFieldRegion(LocRegion, IterRegion):\n  - True if LocRegion\
  \ is a FieldRegion whose field name is \"count\" and its super/base region corresponds\
  \ (or aliases) to IterRegion (pointer deref base region of iter).\n- getVarRegionFromExpr(E):\
  \ getMemRegionFromExpr(E, C) and ensure it\u2019s a VarRegion or equivalent symbol\
  \ region of a local variable.\n\n3. Detect risky \u201Cshorten\u201D computation\
  \ (checkBind)\n- Goal: When a variable gets bound to \u201Ciov_iter length \u2212\
  \ round_up(...)\u201D, record it as risky and remember which iter it belongs to.\n\
  - In checkBind(Loc, Val, S, C):\n  - Extract the destination region R = Loc.getAsRegion();\
  \ ensure it is a variable-like region (local or parameter); call this RShorten.\n\
  \  - Inspect S (the RHS expression site):\n    - Find a BinaryOperator with opcode\
  \ BO_Sub via findSpecificTypeInChildren<BinaryOperator>(S). If none, return.\n \
  \   - For that subtraction SubBO:\n      - Check LHS is an iov_iter length expression:\
  \ isIovIterLenExpr(SubBO->getLHS(), IterRegionLHS).\n      - Check RHS is a round_up\
  \ call: isRoundUpCall(SubBO->getRHS()).\n      - If both checks succeed:\n     \
  \   - State = State->set<ShortenToIterMap>(RShorten, IterRegionLHS);\n        -\
  \ State = State->set<ShortenGuardedMap>(RShorten, false);\n        - C.addTransition(State).\n\
  \  - Also handle declaration with initializer (e.g., size_t shorten = ...): it comes\
  \ through checkBind as well, so the same logic applies.\n\n4. Detect presence of\
  \ a guard (checkBranchCondition)\n- Goal: If code contains a guard ensuring \u201C\
  no underflow\u201D, mark the risky variable as guarded.\n- In checkBranchCondition(Condition,\
  \ C):\n  - Extract a BinaryOperator BO from Condition if any.\n  - Case A: Guard\
  \ of the form \u201Cshorten >= iter->count\u201D (or swapped sides):\n    - If either\
  \ side references a known shorten variable:\n      - ShortenRegion = getVarRegionFromExpr(sideExpr).\n\
  \      - Other side must be MemberExpr \"count\" of the same iter object: isIovIterLenExpr(otherSide,\
  \ IterRegionCond) and ensure it\u2019s specifically \u201Citer->count\u201D, not\
  \ iov_iter_count(); require MemberExpr with field name \"count\".\n      - If ShortenRegion\
  \ is found in ShortenToIterMap and IterRegionCond matches its IterRegion, mark guarded:\n\
  \        - State = State->set<ShortenGuardedMap>(ShortenRegion, true);\n       \
  \ - C.addTransition(State).\n  - Case B: Guard of the form \u201Cround_up(...) <=\
  \ iov_iter_count(iter)\u201D (or swapped \u2265):\n    - Detect one side is round_up\
  \ call, the other side is iov_iter length call (not MemberExpr).\n    - Extract\
  \ IterRegion from the iov_iter length side (isIovIterLenExpr(...)).\n    - For all\
  \ entries in ShortenToIterMap whose IterRegion equals this IterRegion, set ShortenGuardedMap(entryKey)\
  \ = true.\n      - Iterate map using State->get<ShortenToIterMap>(), update those\
  \ with matching IterRegion, and add transition.\n\n5. Report when subtracting the\
  \ risky variable from iter->count without guard (checkBind)\n- Goal: Warn at the\
  \ sink where iter->count is reduced by the risky variable and no guard was seen.\n\
  - In checkBind(Loc, Val, S, C):\n  - If LocRegion is a FieldRegion for \"count\"\
  \ (iter->count) and we are performing a subtraction store:\n    - Detect two common\
  \ forms by analyzing S:\n      - Compound assign: BinaryOperator BO_SubAssign like\
  \ \u201Citer->count -= X\u201D.\n        - Extract XExpr (RHS), get ShortenRegion\
  \ = getVarRegionFromExpr(XExpr). If ShortenRegion exists in ShortenToIterMap and\
  \ ShortenGuardedMap(ShortenRegion) is false (or missing), emit a report.\n     \
  \ - Simple assign with subtraction: \u201Citer->count = iter->count \u2212 X\u201D\
  .\n        - Find RHS BinaryOperator BO_Sub; locate a variable XExpr inside RHS;\
  \ ShortenRegion = getVarRegionFromExpr(XExpr). Same checks as above.\n    - Additionally\
  \ confirm that this store applies to the same iter object as recorded:\n      -\
  \ Retrieve IterRegionLHS from LocRegion (base of FieldRegion). Compare to the IterRegion\
  \ stored in ShortenToIterMap(ShortenRegion). If match and not guarded, it\u2019\
  s a hit.\n  - Reporting:\n    - Create an error node: auto N = C.generateNonFatalErrorNode();\n\
  \    - Message: \u201CPossible size_t underflow: subtracting rounded-up length from\
  \ iov_iter length without guard\u201D.\n    - Emit: PathSensitiveBugReport or BasicBugReport\
  \ with the statement S as the location.\n  - After reporting (or regardless to avoid\
  \ duplicate reports on the same path), clear the entry for ShortenRegion from both\
  \ maps for this path to reduce duplicate warnings.\n    - State = State->remove<ShortenToIterMap>(ShortenRegion);\n\
  \    - State = State->remove<ShortenGuardedMap>(ShortenRegion);\n    - C.addTransition(State).\n\
  \n6. Optional safety refinements\n- If the risky variable is subsequently assigned\
  \ a constant zero before being used (e.g., \u201Cshorten = 0;\u201D), treat that\
  \ as guarded:\n  - In checkBind, when binding to a tracked ShortenRegion and RHS\
  \ is integer literal 0, set ShortenGuardedMap(ShortenRegion) = true.\n- Clear per-function\
  \ state:\n  - In checkEndFunction, clear both maps to avoid stale state leaks across\
  \ functions.\n\n7. Callbacks summary and purpose\n- checkBind:\n  - Detect and record\
  \ risky \u201Cshorten = iov_iter_count(iter) \u2212 round_up(...)\u201D.\n  - Detect\
  \ and warn when storing \u201Citer->count -= shorten\u201D or \u201Citer->count\
  \ = iter->count \u2212 shorten\u201D without guard.\n  - Optionally mark guarded\
  \ when \u201Cshorten = 0\u201D.\n- checkBranchCondition:\n  - Mark \u201Cshorten\u201D\
  \ as guarded if seeing \u201Cshorten >= iter->count\u201D test for the same iter.\n\
  \  - Mark all \u201Cshorten\u201D tied to an iter as guarded if seeing \u201Cround_up(...)\
  \ <= iov_iter_count(iter)\u201D for that iter.\n- checkEndFunction:\n  - Cleanup\
  \ state (optional, but keeps state minimal).\n\n8. Notes to minimize false positives\n\
  - Only track \u201Cshorten-like\u201D variables when the subtraction shape exactly\
  \ matches:\n  - LHS is iov_iter_count(iter) or iter->count (MemberExpr \u201Ccount\u201D\
  ).\n  - RHS is round_up(...).\n- Only warn when the same tracked variable is used\
  \ to reduce the same iter->count field and no guard has been seen on the current\
  \ path."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/ExprCXX.h\"\
  \n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing\
  \ namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program\
  \ state to track \"shorten-like\" variables and their associated iter object.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(ShortenToIterMap, const MemRegion*, const MemRegion*)\n\
  // Whether a given \"shorten-like\" variable has been guarded on the current path.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(ShortenGuardedMap, const MemRegion*, bool)\n\nnamespace\
  \ {\n\nclass SAGenTestChecker : public Checker<\n    check::Bind,\n    check::BranchCondition\n\
  \  > {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"iov_iter count underflow\", \"API Misuse\")) {}\n\n \
  \     void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \      void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \n   private:\n\n      // Helpers\n      static const MemRegion* getVarRegionFromExpr(const\
  \ Expr *E, CheckerContext &C);\n      static bool isCallNamed(const Expr *E, StringRef\
  \ Name, CheckerContext &C);\n      static bool isRoundUpCall(const Expr *E, CheckerContext\
  \ &C);\n      static bool isIovIterLenExpr(const Expr *E, const MemRegion* &IterRegion,\n\
  \                                   bool &IsMemberCount, CheckerContext &C);\n \
  \     static const FieldRegion* getCountFieldRegionFromLoc(const MemRegion *MR);\n\
  \      static const MemRegion* getIterRegionFromCountFieldExpr(const Expr *E, CheckerContext\
  \ &C);\n      static bool isZeroSVal(SVal V);\n      static bool regionsEqual(const\
  \ MemRegion *A, const MemRegion *B) {\n        return A == B;\n      }\n};\n\nconst\
  \ MemRegion* SAGenTestChecker::getVarRegionFromExpr(const Expr *E, CheckerContext\
  \ &C) {\n  if (!E) return nullptr;\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR) return nullptr;\n  return MR->getBaseRegion();\n}\n\nbool SAGenTestChecker::isCallNamed(const\
  \ Expr *E, StringRef Name, CheckerContext &C) {\n  if (!E) return false;\n  const\
  \ Expr *EI = E->IgnoreParenCasts();\n  // Prefer source text check for robustness\
  \ across inline/helper wrappers.\n  return ExprHasName(EI, Name, C);\n}\n\nbool\
  \ SAGenTestChecker::isRoundUpCall(const Expr *E, CheckerContext &C) {\n  const Expr\
  \ *EI = E ? E->IgnoreParenCasts() : nullptr;\n  if (!EI) return false;\n  const\
  \ CallExpr *CE = dyn_cast<CallExpr>(EI);\n  if (!CE) return false;\n  // Use textual\
  \ name check for 'round_up'\n  return isCallNamed(EI, \"round_up\", C);\n}\n\nbool\
  \ SAGenTestChecker::isIovIterLenExpr(const Expr *E, const MemRegion* &IterRegion,\n\
  \                                        bool &IsMemberCount, CheckerContext &C)\
  \ {\n  IterRegion = nullptr;\n  IsMemberCount = false;\n  if (!E) return false;\n\
  \n  const Expr *EI = E->IgnoreParenCasts();\n\n  // Case 1: Call to iov_iter_count(iter)\n\
  \  if (const auto *Call = dyn_cast<CallExpr>(EI)) {\n    if (isCallNamed(EI, \"\
  iov_iter_count\", C)) {\n      if (Call->getNumArgs() >= 1) {\n        const Expr\
  \ *Arg0 = Call->getArg(0);\n        const MemRegion *MR = getMemRegionFromExpr(Arg0,\
  \ C);\n        if (!MR) return false;\n        IterRegion = MR->getBaseRegion();\n\
  \        IsMemberCount = false;\n        return IterRegion != nullptr;\n      }\n\
  \    }\n  }\n\n  // Case 2: MemberExpr iter->count\n  if (const auto *ME = dyn_cast<MemberExpr>(EI))\
  \ {\n    const FieldDecl *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());\n    if\
  \ (!FD) return false;\n    IdentifierInfo *II = FD->getIdentifier();\n    if (!II)\
  \ return false;\n    // field name 'count'\n    if (II->getName() == \"count\")\
  \ {\n      const Expr *Base = ME->getBase();\n      if (!Base) return false;\n \
  \     const MemRegion *MR = getMemRegionFromExpr(Base, C);\n      if (!MR) return\
  \ false;\n      IterRegion = MR->getBaseRegion();\n      IsMemberCount = true;\n\
  \      return IterRegion != nullptr;\n    }\n  }\n\n  return false;\n}\n\nconst\
  \ FieldRegion* SAGenTestChecker::getCountFieldRegionFromLoc(const MemRegion *MR)\
  \ {\n  if (!MR) return nullptr;\n  const FieldRegion *FR = dyn_cast<FieldRegion>(MR);\n\
  \  if (!FR) return nullptr;\n  const FieldDecl *FD = FR->getDecl();\n  if (!FD)\
  \ return nullptr;\n  const IdentifierInfo *II = FD->getIdentifier();\n  if (!II)\
  \ return nullptr;\n  if (II->getName() != \"count\") return nullptr;\n  return FR;\n\
  }\n\nconst MemRegion* SAGenTestChecker::getIterRegionFromCountFieldExpr(const Expr\
  \ *E, CheckerContext &C) {\n  const Expr *EI = E ? E->IgnoreParenCasts() : nullptr;\n\
  \  if (!EI) return nullptr;\n  if (const auto *ME = dyn_cast<MemberExpr>(EI)) {\n\
  \    const FieldDecl *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());\n    if (!FD)\
  \ return nullptr;\n    const IdentifierInfo *II = FD->getIdentifier();\n    if (!II\
  \ || II->getName() != \"count\") return nullptr;\n    const Expr *Base = ME->getBase();\n\
  \    if (!Base) return nullptr;\n    const MemRegion *MR = getMemRegionFromExpr(Base,\
  \ C);\n    if (!MR) return nullptr;\n    return MR->getBaseRegion();\n  }\n  return\
  \ nullptr;\n}\n\nbool SAGenTestChecker::isZeroSVal(SVal V) {\n  if (auto CI = V.getAs<nonloc::ConcreteInt>())\
  \ {\n    const llvm::APSInt &X = CI->getValue();\n    return X == 0;\n  }\n  return\
  \ false;\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S,\
  \ CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\n  const\
  \ MemRegion *LReg = Loc.getAsRegion();\n  if (!LReg) {\n    return;\n  }\n  LReg\
  \ = LReg->getBaseRegion();\n  if (!LReg)\n    return;\n\n  // 1) Detect \"shorten-like\"\
  \ computation:\n  //    shorten = iov_iter_count(iter) - round_up(...)\n  // We\
  \ analyze the statement S to find a subtraction operator.\n  if (S) {\n    // If\
  \ LHS location is a variable region, try to detect RHS pattern.\n    const BinaryOperator\
  \ *BO = findSpecificTypeInChildren<BinaryOperator>(S);\n    if (BO && BO->getOpcode()\
  \ == BO_Sub) {\n      const Expr *LHS = BO->getLHS();\n      const Expr *RHS = BO->getRHS();\n\
  \n      const MemRegion *IterRegionLHS = nullptr;\n      bool IsMemberCount = false;\n\
  \      if (isIovIterLenExpr(LHS, IterRegionLHS, IsMemberCount, C) && IterRegionLHS\
  \ && isRoundUpCall(RHS, C)) {\n        // Record mapping: shorten variable -> iter\
  \ object\n        State = State->set<ShortenToIterMap>(LReg, IterRegionLHS);\n \
  \       State = State->set<ShortenGuardedMap>(LReg, false);\n        C.addTransition(State);\n\
  \        // Do not return; this same bind might also be a store to iter->count below,\
  \ but unlikely.\n      }\n    }\n  }\n\n  // Optional safety: if a tracked \"shorten\"\
  \ variable is explicitly set to 0 later,\n  // mark it as guarded.\n  if (const\
  \ bool *Tracked = State->get<ShortenGuardedMap>(LReg)) {\n    // LReg is a shorten-like\
  \ var (guarded status exists), and if assigned 0, mark guarded.\n    if (isZeroSVal(Val))\
  \ {\n      State = State->set<ShortenGuardedMap>(LReg, true);\n      C.addTransition(State);\n\
  \    }\n  }\n\n  // 2) Detect subtracting a shorten-like variable from iter->count\n\
  \  //    - Either \"iter->count -= shorten\"\n  //    - Or \"iter->count = iter->count\
  \ - shorten\"\n  // Check if the LHS location is the 'count' field.\n  const FieldRegion\
  \ *CountFR = getCountFieldRegionFromLoc(Loc.getAsRegion());\n  if (!CountFR)\n \
  \   return;\n\n  // Extract the iter object region from LHS (iter->count).\n  const\
  \ MemRegion *IterObjReg = nullptr;\n  if (const MemRegion *Super = CountFR->getSuperRegion())\n\
  \    IterObjReg = Super->getBaseRegion();\n\n  if (!IterObjReg)\n    return;\n\n\
  \  // Analyze the statement S to determine subtract operation and RHS var.\n  const\
  \ Expr *RHSExpr = nullptr;\n  const CompoundAssignOperator *CAO = dyn_cast_or_null<CompoundAssignOperator>(S);\n\
  \  if (CAO && CAO->getOpcode() == BO_SubAssign) {\n    RHSExpr = CAO->getRHS();\n\
  \  } else {\n    // Try form \"iter->count = iter->count - shorten\"\n    const\
  \ BinaryOperator *AssignBO = dyn_cast_or_null<BinaryOperator>(S);\n    if (AssignBO\
  \ && AssignBO->getOpcode() == BO_Assign) {\n      // Find a subtraction inside RHS\n\
  \      const BinaryOperator *SubBO = findSpecificTypeInChildren<BinaryOperator>(AssignBO->getRHS());\n\
  \      if (SubBO && SubBO->getOpcode() == BO_Sub) {\n        // Ensure the LHS of\
  \ subtraction is an iter length expression corresponding to this iter\n        const\
  \ MemRegion *IterRHS = nullptr;\n        bool IsMember = false;\n        if (isIovIterLenExpr(SubBO->getLHS(),\
  \ IterRHS, IsMember, C) && IterRHS && regionsEqual(IterRHS, IterObjReg)) {\n   \
  \       RHSExpr = SubBO->getRHS();\n        }\n      }\n    }\n  }\n\n  if (!RHSExpr)\n\
  \    return;\n\n  const MemRegion *ShortenReg = getVarRegionFromExpr(RHSExpr, C);\n\
  \  if (!ShortenReg)\n    return;\n\n  // Check if RHS is a tracked shorten-like\
  \ variable\n  const MemRegion *const *TrackedIterPtr = State->get<ShortenToIterMap>(ShortenReg);\n\
  \  if (!TrackedIterPtr)\n    return;\n  const MemRegion *TrackedIter = *TrackedIterPtr;\n\
  \n  // Confirm it's the same iter object\n  if (!regionsEqual(TrackedIter, IterObjReg))\n\
  \    return;\n\n  const bool *Guarded = State->get<ShortenGuardedMap>(ShortenReg);\n\
  \  bool IsGuarded = Guarded && *Guarded;\n\n  if (!IsGuarded) {\n    ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n    if (!N)\n      return;\n\n    auto R\
  \ = std::make_unique<PathSensitiveBugReport>(\n        *BT, \"Possible size_t underflow:\
  \ subtracting rounded-up length from iov_iter length without guard\", N);\n    if\
  \ (S)\n      R->addRange(S->getSourceRange());\n    C.emitReport(std::move(R));\n\
  \  }\n\n  // Clean up this shorten variable on this path to reduce duplicate reports.\n\
  \  State = State->remove<ShortenToIterMap>(ShortenReg);\n  State = State->remove<ShortenGuardedMap>(ShortenReg);\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE) {\n   \
  \ C.addTransition(State);\n    return;\n  }\n\n  CondE = CondE->IgnoreParenImpCasts();\n\
  \n  // Handle binary relational operators\n  if (const auto *BO = dyn_cast<BinaryOperator>(CondE))\
  \ {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n\n    // Helper lambdas to\
  \ mark guarded for one shorten region\n    auto MarkGuarded = [&](const MemRegion\
  \ *ShortenReg) {\n      if (!ShortenReg) return;\n      const bool *Old = State->get<ShortenGuardedMap>(ShortenReg);\n\
  \      if (Old == nullptr || *Old == false) {\n        State = State->set<ShortenGuardedMap>(ShortenReg,\
  \ true);\n      }\n    };\n    // Helper: mark all shortens of a given iter as guarded\n\
  \    auto MarkAllForIterGuarded = [&](const MemRegion *IterReg) {\n      if (!IterReg)\
  \ return;\n      auto M = State->get<ShortenToIterMap>();\n      for (auto I = M.begin(),\
  \ E = M.end(); I != E; ++I) {\n        const MemRegion *ShortR = I->first;\n   \
  \     const MemRegion *ItR = I->second;\n        if (regionsEqual(ItR, IterReg))\
  \ {\n          const bool *Old = State->get<ShortenGuardedMap>(ShortR);\n      \
  \    if (Old == nullptr || *Old == false) {\n            State = State->set<ShortenGuardedMap>(ShortR,\
  \ true);\n          }\n        }\n      }\n    };\n\n    const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \    const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n    // Case A: \"\
  shorten >= iter->count\" or related (>, <=, <) reversed forms indicating shorten\
  \ > count\n    // We consider:\n    //  - shorten >= iter->count  => BO_GE\n   \
  \ //  - shorten >  iter->count  => BO_GT\n    //  - iter->count <= shorten  => BO_LE\n\
  \    //  - iter->count <  shorten  => BO_LT\n    bool IsRel = (Op == BO_GE || Op\
  \ == BO_GT || Op == BO_LE || Op == BO_LT);\n    if (IsRel) {\n      // Pattern A1:\
  \ shorten [>= or >] iter->count\n      const MemRegion *ShortenRegA1 = getVarRegionFromExpr(LHS,\
  \ C);\n      const MemRegion *IterFieldA1 = getIterRegionFromCountFieldExpr(RHS,\
  \ C);\n      if ((Op == BO_GE || Op == BO_GT) && ShortenRegA1 && IterFieldA1) {\n\
  \        const MemRegion *const *TrackedIterPtr = State->get<ShortenToIterMap>(ShortenRegA1);\n\
  \        if (TrackedIterPtr) {\n          const MemRegion *TrackedIter = *TrackedIterPtr;\n\
  \          if (regionsEqual(TrackedIter, IterFieldA1)) {\n            MarkGuarded(ShortenRegA1);\n\
  \            C.addTransition(State);\n            return;\n          }\n       \
  \ }\n      }\n\n      // Pattern A2: iter->count [<= or <] shorten\n      const\
  \ MemRegion *IterFieldA2 = getIterRegionFromCountFieldExpr(LHS, C);\n      const\
  \ MemRegion *ShortenRegA2 = getVarRegionFromExpr(RHS, C);\n      if ((Op == BO_LE\
  \ || Op == BO_LT) && IterFieldA2 && ShortenRegA2) {\n        const MemRegion *const\
  \ *TrackedIterPtr = State->get<ShortenToIterMap>(ShortenRegA2);\n        if (TrackedIterPtr)\
  \ {\n          const MemRegion *TrackedIter = *TrackedIterPtr;\n          if (regionsEqual(TrackedIter,\
  \ IterFieldA2)) {\n            MarkGuarded(ShortenRegA2);\n            C.addTransition(State);\n\
  \            return;\n          }\n        }\n      }\n    }\n\n    // Case B: \"\
  round_up(...) <= iov_iter_count(iter)\" (or swapped with >=), also accept iter->count.\n\
  \    bool IsLEorGE = (Op == BO_LE || Op == BO_GE);\n    if (IsLEorGE) {\n      //\
  \ Pattern B1: round_up(...) <= (iov_iter_count(iter) | iter->count)\n      if (isRoundUpCall(LHS,\
  \ C)) {\n        const MemRegion *IterR = nullptr; bool IsMember = false;\n    \
  \    if (isIovIterLenExpr(RHS, IterR, IsMember, C) && IterR) {\n          MarkAllForIterGuarded(IterR);\n\
  \          C.addTransition(State);\n          return;\n        }\n      }\n    \
  \  // Pattern B2: (iov_iter_count(iter) | iter->count) >= round_up(...)\n      if\
  \ (isRoundUpCall(RHS, C)) {\n        const MemRegion *IterR = nullptr; bool IsMember\
  \ = false;\n        if (isIovIterLenExpr(LHS, IterR, IsMember, C) && IterR) {\n\
  \          MarkAllForIterGuarded(IterR);\n          C.addTransition(State);\n  \
  \        return;\n        }\n      }\n    }\n  }\n\n  C.addTransition(State);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects subtracting rounded-up length from iov_iter length without guard,\
  \ causing underflow\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
