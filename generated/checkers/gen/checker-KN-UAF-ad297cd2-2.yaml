_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: ad297cd2db8953e2202970e9504cab247b6c7cb4
commit_type: UAF
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state: map from private object (netdev_priv return) to its owner net_device\
  \ object.\nREGISTER_MAP_WITH_PROGRAMSTATE(PrivToNetdevMap, const MemRegion*, const\
  \ MemRegion*)\n// Program state: set of freed net_device objects (freed by free_netdev).\n\
  REGISTER_SET_WITH_PROGRAMSTATE(FreedNetdevSet, const MemRegion*)\n\nnamespace {\n\
  /* The checker callbacks are to be decided. */\nclass SAGenTestChecker : public\
  \ Checker<check::PostCall, check::Location> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Use-after-free\
  \ of netdev_priv data\", \"Memory Management\")) {}\n\n      void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkLocation(SVal Loc,\
  \ bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\n   private:\n\n     \
  \ bool isNamedCall(const CallEvent &Call, StringRef Name, CheckerContext &C) const;\n\
  \      void reportUAF(const Stmt *S, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isNamedCall(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) const {\n  const Expr *Origin\
  \ = Call.getOriginExpr();\n  if (Origin && ExprHasName(Origin, Name, C))\n    return\
  \ true;\n\n  if (const IdentifierInfo *ID = Call.getCalleeIdentifier())\n    return\
  \ ID->getName() == Name;\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  if (!State)\n    return;\n\n  // Track netdev_priv(netdev) -> returns pointer\
  \ to private area belonging to netdev.\n  if (isNamedCall(Call, \"netdev_priv\"\
  , C)) {\n    if (Call.getNumArgs() < 1)\n      return;\n\n    const Expr *Arg0E\
  \ = Call.getArgExpr(0);\n    if (!Arg0E)\n      return;\n\n    const MemRegion *NetdevObj\
  \ = getMemRegionFromExpr(Arg0E, C);\n    if (!NetdevObj)\n      return;\n    NetdevObj\
  \ = NetdevObj->getBaseRegion();\n    if (!NetdevObj)\n      return;\n\n    const\
  \ MemRegion *PrivObj = Call.getReturnValue().getAsRegion();\n    if (!PrivObj)\n\
  \      return;\n    PrivObj = PrivObj->getBaseRegion();\n    if (!PrivObj)\n   \
  \   return;\n\n    State = State->set<PrivToNetdevMap>(PrivObj, NetdevObj);\n  \
  \  C.addTransition(State);\n    return;\n  }\n\n  // Track free_netdev(netdev) ->\
  \ mark netdev as freed.\n  if (isNamedCall(Call, \"free_netdev\", C)) {\n    if\
  \ (Call.getNumArgs() < 1)\n      return;\n\n    const Expr *Arg0E = Call.getArgExpr(0);\n\
  \    if (!Arg0E)\n      return;\n\n    const MemRegion *NetdevObj = getMemRegionFromExpr(Arg0E,\
  \ C);\n    if (!NetdevObj)\n      return;\n    NetdevObj = NetdevObj->getBaseRegion();\n\
  \    if (!NetdevObj)\n      return;\n\n    State = State->add<FreedNetdevSet>(NetdevObj);\n\
  \    C.addTransition(State);\n    return;\n  }\n}\n\nvoid SAGenTestChecker::reportUAF(const\
  \ Stmt *S, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Use-after-free: netdev_priv data used after free_netdev\", N);\n \
  \ if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\
  \ CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n  if (!State)\n\
  \    return;\n\n  const MemRegion *MR = Loc.getAsRegion();\n  if (!MR)\n    return;\n\
  \n  const MemRegion *Base = MR->getBaseRegion();\n  if (!Base)\n    return;\n\n\
  \  // Is this access within a private object returned by netdev_priv?\n  const MemRegion\
  \ *OwnerNetdev = State->get<PrivToNetdevMap>(Base);\n  if (!OwnerNetdev)\n    return;\n\
  \n  // Was the owning net_device freed?\n  if (State->contains<FreedNetdevSet>(OwnerNetdev))\
  \ {\n    reportUAF(S, C);\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect use-after-free by accessing\
  \ netdev_priv data after free_netdev\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet: qcom/emac: fix UAF in emac_remove\n\nadpt is\
  \ netdev private data and it cannot be\nused after free_netdev() call. Using adpt\
  \ after free_netdev()\ncan cause UAF bug. Fix it by moving free_netdev() at the\
  \ end of the\nfunction.\n\nFixes: 54e19bc74f33 (\"net: qcom/emac: do not use devm\
  \ on internal phy pdev\")\nSigned-off-by: Pavel Skripkin <paskripkin@gmail.com>\n\
  Signed-off-by: David S. Miller <davem@davemloft.net>\n\n## Buggy Code\n\n```c\n\
  // Function: emac_remove in drivers/net/ethernet/qualcomm/emac/emac.c\nstatic int\
  \ emac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(&pdev->dev);\n\
  \tstruct emac_adapter *adpt = netdev_priv(netdev);\n\n\tunregister_netdev(netdev);\n\
  \tnetif_napi_del(&adpt->rx_q.napi);\n\n\temac_clks_teardown(adpt);\n\n\tput_device(&adpt->phydev->mdio.dev);\n\
  \tmdiobus_unregister(adpt->mii_bus);\n\tfree_netdev(netdev);\n\n\tif (adpt->phy.digital)\n\
  \t\tiounmap(adpt->phy.digital);\n\tiounmap(adpt->phy.base);\n\n\treturn 0;\n}\n\
  ```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/net/ethernet/qualcomm/emac/emac.c\
  \ b/drivers/net/ethernet/qualcomm/emac/emac.c\nindex 8543bf3c3484..ad655f0a4965\
  \ 100644\n--- a/drivers/net/ethernet/qualcomm/emac/emac.c\n+++ b/drivers/net/ethernet/qualcomm/emac/emac.c\n\
  @@ -735,12 +735,13 @@ static int emac_remove(struct platform_device *pdev)\n \n\
  \ \tput_device(&adpt->phydev->mdio.dev);\n \tmdiobus_unregister(adpt->mii_bus);\n\
  -\tfree_netdev(netdev);\n \n \tif (adpt->phy.digital)\n \t\tiounmap(adpt->phy.digital);\n\
  \ \tiounmap(adpt->phy.base);\n \n+\tfree_netdev(netdev);\n+\n \treturn 0;\n }\n\
  \ \n```\n"
pattern: "## Bug Pattern\n\nUse-after-free caused by accessing netdev_priv(netdev)\
  \ data after calling free_netdev(netdev). Specifically, retrieving a driver\u2019\
  s private adapter pointer (e.g., struct emac_adapter *adpt = netdev_priv(netdev))\
  \ and then invoking free_netdev(netdev) before finishing cleanup that still dereferences\
  \ adpt (e.g., iounmap(adpt->...)). Since free_netdev() frees both struct net_device\
  \ and its private area, any subsequent use of adpt is a UAF."
plan: "Plan\n\n1. Program state\n- REGISTER_MAP_WITH_PROGRAMSTATE(PrivToNetdevMap,\
  \ const MemRegion*, const MemRegion*)\n  - Key: the MemRegion of the \u201Cprivate\
  \ area object\u201D pointed to by netdev_priv(netdev) (i.e., the pointee region\
  \ of the return value).\n  - Value: the MemRegion of the struct net_device object\
  \ (i.e., the pointee region of the netdev argument).\n- REGISTER_SET_WITH_PROGRAMSTATE(FreedNetdevSet,\
  \ const MemRegion*)\n  - Elements: MemRegions of struct net_device objects that\
  \ have been freed via free_netdev(netdev).\n\nRationale: We only need to know which\
  \ \u201Cprivate object\u201D belongs to which net_device and whether that net_device\
  \ was freed. We do not need alias tracking because the dereference will always be\
  \ on the private object region (or its subregions), independent of which pointer\
  \ variable is used.\n\n2. Callback functions and implementation\n\n2.1 checkPostCall\n\
  - Goal:\n  - Track netdev_priv() to associate returned private object to its owner\
  \ net_device object.\n  - Track free_netdev() to mark the corresponding net_device\
  \ as freed.\n\n- Steps:\n  - Identify netdev_priv calls:\n    - Prefer Call.getCalleeIdentifier()->getName()\
  \ == \"netdev_priv\".\n    - If callee identifier is null (e.g., macro/inline),\
  \ fallback to ExprHasName(Call.getOriginExpr(), \"netdev_priv\").\n  - When netdev_priv\
  \ is detected:\n    - Obtain net_device object region:\n      - const MemRegion*\
  \ NetdevObj = getMemRegionFromExpr(Call.getArgExpr(0), C); // This yields the pointee\
  \ region of the net_device object.\n      - If null, return.\n    - Obtain returned\
  \ private object region:\n      - const MemRegion* PrivObj = Call.getReturnValue().getAsRegion();\n\
  \      - If null, return.\n    - Update state: State = State->set<PrivToNetdevMap>(PrivObj,\
  \ NetdevObj);\n    - C.addTransition(State).\n\n  - Identify free_netdev calls:\n\
  \    - Same identification strategy: name \"free_netdev\" or ExprHasName fallback.\n\
  \  - When free_netdev is detected:\n    - Obtain net_device object region:\n   \
  \   - const MemRegion* NetdevObj = getMemRegionFromExpr(Call.getArgExpr(0), C);\n\
  \      - If null, return.\n    - Update state: State = State->add<FreedNetdevSet>(NetdevObj);\n\
  \    - C.addTransition(State).\n\n2.2 checkLocation\n- Goal: Detect dereferences\
  \ of private data after the owning net_device was freed.\n\n- Trigger: For both\
  \ loads and stores (IsLoad or not), because either direction implies dereference.\n\
  \n- Steps:\n  - Extract accessed region:\n    - const MemRegion* MR = Loc.getAsRegion();\n\
  \    - If null, return.\n  - Compute the base object region by walking super-regions:\n\
  \    - const MemRegion* Base = MR;\n    - while (const auto *SR = dyn_cast<SubRegion>(Base))\
  \ Base = SR->getSuperRegion();\n  - Check if Base is a private object known to belong\
  \ to a net_device:\n    - auto OwnerIt = State->get<PrivToNetdevMap>().lookup(Base);\n\
  \    - If none, return.\n  - Check if the owning net_device was freed:\n    - if\
  \ (State->contains<FreedNetdevSet>(OwnerIt)) {\n        - ExplodedNode* N = C.generateNonFatalErrorNode();\n\
  \        - If N, emit a PathSensitiveBugReport with a short message:\n         \
  \ - \u201CUse-after-free: netdev_priv data used after free_netdev\u201D\n      \
  \  - Add the source range of S to the report for clarity.\n      }\n\nRationale:\
  \ For expressions like adpt->phy.digital or adpt->phy.base, the analyzer computes\
  \ loads from subregions of the private object. Walking up to the base region aligns\
  \ the access with the PrivToNetdevMap key.\n\n2.3 Optional: checkPreCall (to catch\
  \ API calls known to dereference their pointer args)\n- Not required for the target\
  \ pattern because field/member accesses already trigger checkLocation. If desired,\
  \ we can add:\n  - Use functionKnownToDeref(Call, DerefParams) to detect calls that\
  \ dereference arguments.\n  - For each param index in DerefParams:\n    - Obtain\
  \ argument region ArgR = getMemRegionFromExpr(Call.getArgExpr(i), C).\n    - Walk\
  \ to base as above.\n    - If base is in PrivToNetdevMap and its owner is in FreedNetdevSet,\
  \ report the same UAF bug at Call.getOriginExpr().\n- Keep disabled unless needed,\
  \ to avoid noise.\n\n3. Notes on details\n- getMemRegionFromExpr must return the\
  \ pointee object region:\n  - In both netdev_priv(arg0) and free_netdev(arg0), the\
  \ argument is a net_device*; the returned SVal is a loc::MemRegionVal pointing to\
  \ the net_device object region. getMemRegionFromExpr leverages State->getSVal(E,\
  \ \u2026).getAsRegion() to obtain exactly that object region.\n  - For netdev_priv\
  \ return, Call.getReturnValue().getAsRegion() yields the private object region \u201C\
  owned by\u201D the net_device. This is the region that will appear as the base (or\
  \ ancestor) for subsequent member accesses (e.g., adpt->\u2026).\n- We do not need\
  \ pointer alias maps. The checkLocation works on the accessed object region, independent\
  \ of which pointer variable produced it.\n- Report once per access site. Use generateNonFatalErrorNode\
  \ and PathSensitiveBugReport with a short message, per the requirement.\n\n4. Summary\
  \ of what to implement\n- Program state:\n  - PrivToNetdevMap: private-object-region\
  \ -> net_device-object-region\n  - FreedNetdevSet: net_device-object-region\n- Callbacks:\n\
  \  - checkPostCall:\n    - Track netdev_priv() returns and map to owner net_device.\n\
  \    - Track free_netdev() and mark the net_device region as freed.\n  - checkLocation:\n\
  \    - On any load/store, walk to base region; if it is a private object whose owner\
  \ net_device is freed, report UAF."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state: map from private object (netdev_priv return) to its owner net_device\
  \ object.\nREGISTER_MAP_WITH_PROGRAMSTATE(PrivToNetdevMap, const MemRegion*, const\
  \ MemRegion*)\n// Program state: set of freed net_device objects (freed by free_netdev).\n\
  REGISTER_SET_WITH_PROGRAMSTATE(FreedNetdevSet, const MemRegion*)\n\nnamespace {\n\
  /* The checker callbacks are to be decided. */\nclass SAGenTestChecker : public\
  \ Checker<check::PostCall, check::Location> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Use-after-free\
  \ of netdev_priv data\", \"Memory Management\")) {}\n\n      void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkLocation(SVal Loc,\
  \ bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\n   private:\n\n     \
  \ bool isNamedCall(const CallEvent &Call, StringRef Name, CheckerContext &C) const;\n\
  \      void reportUAF(const Stmt *S, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isNamedCall(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) const {\n  const Expr *Origin\
  \ = Call.getOriginExpr();\n  if (Origin && ExprHasName(Origin, Name, C))\n    return\
  \ true;\n\n  if (const IdentifierInfo *ID = Call.getCalleeIdentifier())\n    return\
  \ ID->getName() == Name;\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  if (!State)\n    return;\n\n  // Track netdev_priv(netdev) -> returns pointer\
  \ to private area belonging to netdev.\n  if (isNamedCall(Call, \"netdev_priv\"\
  , C)) {\n    if (Call.getNumArgs() < 1)\n      return;\n\n    const Expr *Arg0E\
  \ = Call.getArgExpr(0);\n    if (!Arg0E)\n      return;\n\n    const MemRegion *NetdevObj\
  \ = getMemRegionFromExpr(Arg0E, C);\n    if (!NetdevObj)\n      return;\n    NetdevObj\
  \ = NetdevObj->getBaseRegion();\n    if (!NetdevObj)\n      return;\n\n    const\
  \ MemRegion *PrivObj = Call.getReturnValue().getAsRegion();\n    if (!PrivObj)\n\
  \      return;\n    PrivObj = PrivObj->getBaseRegion();\n    if (!PrivObj)\n   \
  \   return;\n\n    State = State->set<PrivToNetdevMap>(PrivObj, NetdevObj);\n  \
  \  C.addTransition(State);\n    return;\n  }\n\n  // Track free_netdev(netdev) ->\
  \ mark netdev as freed.\n  if (isNamedCall(Call, \"free_netdev\", C)) {\n    if\
  \ (Call.getNumArgs() < 1)\n      return;\n\n    const Expr *Arg0E = Call.getArgExpr(0);\n\
  \    if (!Arg0E)\n      return;\n\n    const MemRegion *NetdevObj = getMemRegionFromExpr(Arg0E,\
  \ C);\n    if (!NetdevObj)\n      return;\n    NetdevObj = NetdevObj->getBaseRegion();\n\
  \    if (!NetdevObj)\n      return;\n\n    State = State->add<FreedNetdevSet>(NetdevObj);\n\
  \    C.addTransition(State);\n    return;\n  }\n}\n\nvoid SAGenTestChecker::reportUAF(const\
  \ Stmt *S, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Use-after-free: netdev_priv data used after free_netdev\", N);\n \
  \ if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\
  \ CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n  if (!State)\n\
  \    return;\n\n  const MemRegion *MR = Loc.getAsRegion();\n  if (!MR)\n    return;\n\
  \n  const MemRegion *Base = MR->getBaseRegion();\n  if (!Base)\n    return;\n\n\
  \  // Is this access within a private object returned by netdev_priv?\n  const MemRegion\
  \ *const *OwnerNetdevPtr = State->get<PrivToNetdevMap>(Base);\n  if (!OwnerNetdevPtr)\n\
  \    return;\n  const MemRegion *OwnerNetdev = *OwnerNetdevPtr;\n\n  // Was the\
  \ owning net_device freed?\n  if (State->contains<FreedNetdevSet>(OwnerNetdev))\
  \ {\n    reportUAF(S, C);\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect use-after-free by accessing\
  \ netdev_priv data after free_netdev\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
