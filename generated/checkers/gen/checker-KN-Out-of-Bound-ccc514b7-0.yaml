_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: ccc514b7e7acbd301219cbaec0fc0bfe5741acee
commit_type: Out-of-Bound
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"clang/Basic/SourceManager.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n\
  #include <string>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\nnamespace {\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\
  \ : public Checker<check::ASTCodeBody> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Parallel-array index\
  \ overflow\", \"Array bounds\")) {}\n\n      void checkASTCodeBody(const Decl *D,\
  \ AnalysisManager &Mgr, BugReporter &BR) const;\n\n   private:\n\n      // Helpers\
  \ for loop recognition and array access analysis\n      static bool getCanonicalLoop(const\
  \ ForStmt *FS,\n                                   const VarDecl *&LoopVar,\n  \
  \                                 const Expr *&BoundExpr,\n                    \
  \               bool &IsStrictLess,\n                                   ASTContext\
  \ &Ctx);\n\n      static bool evalToInt(const Expr *E, APSInt &Out, ASTContext &Ctx);\n\
  \n      static bool indexIsLoopVar(const Expr *Idx, const VarDecl *V);\n\n     \
  \ static bool getArraySizeFromSubscriptBase(const Expr *Base, llvm::APInt &ArraySize,\
  \ ASTContext &Ctx);\n\n      static std::string getArrayName(const Expr *Base);\n\
  \n      void report(const ArraySubscriptExpr *ASE,\n                  uint64_t BoundVal,\n\
  \                  StringRef ArrName,\n                  uint64_t ArrSize,\n   \
  \               BugReporter &BR,\n                  ASTContext &Ctx) const;\n};\n\
  \n//========================== Helper Implementations ==========================//\n\
  \nbool SAGenTestChecker::evalToInt(const Expr *E, APSInt &Out, ASTContext &Ctx)\
  \ {\n  if (!E)\n    return false;\n  Expr::EvalResult ER;\n  if (E->EvaluateAsInt(ER,\
  \ Ctx)) {\n    Out = ER.Val.getInt();\n    return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::getCanonicalLoop(const ForStmt *FS,\n              \
  \                          const VarDecl *&LoopVar,\n                          \
  \              const Expr *&BoundExpr,\n                                       \
  \ bool &IsStrictLess,\n                                        ASTContext &Ctx)\
  \ {\n  LoopVar = nullptr;\n  BoundExpr = nullptr;\n  IsStrictLess = true;\n\n  if\
  \ (!FS)\n    return false;\n\n  // 1) Init: either \"int i = 0;\" or \"i = 0;\"\n\
  \  const Stmt *InitS = FS->getInit();\n  const VarDecl *V = nullptr;\n\n  if (const\
  \ auto *DS = dyn_cast_or_null<DeclStmt>(InitS)) {\n    if (!DS->isSingleDecl())\n\
  \      return false;\n    const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());\n\
  \    if (!VD || !VD->hasInit())\n      return false;\n    APSInt InitVal;\n    if\
  \ (!evalToInt(VD->getInit()->IgnoreParenImpCasts(), InitVal, Ctx))\n      return\
  \ false;\n    if (InitVal != 0)\n      return false;\n    V = VD;\n  } else if (const\
  \ auto *BO = dyn_cast_or_null<BinaryOperator>(InitS)) {\n    if (BO->getOpcode()\
  \ != BO_Assign)\n      return false;\n    const auto *LHS = dyn_cast<DeclRefExpr>(BO->getLHS()->IgnoreParenImpCasts());\n\
  \    if (!LHS)\n      return false;\n    const auto *VD = dyn_cast<VarDecl>(LHS->getDecl());\n\
  \    if (!VD)\n      return false;\n    APSInt InitVal;\n    if (!evalToInt(BO->getRHS()->IgnoreParenImpCasts(),\
  \ InitVal, Ctx))\n      return false;\n    if (InitVal != 0)\n      return false;\n\
  \    V = VD;\n  } else {\n    return false;\n  }\n\n  // 2) Condition: \"i < Bound\"\
  \ or \"i <= Bound\"\n  const Expr *CondE = FS->getCond();\n  if (!CondE)\n    return\
  \ false;\n  CondE = CondE->IgnoreParenImpCasts();\n  const auto *CBO = dyn_cast<BinaryOperator>(CondE);\n\
  \  if (!CBO)\n    return false;\n\n  BinaryOperator::Opcode Op = CBO->getOpcode();\n\
  \  if (Op != BO_LT && Op != BO_LE)\n    return false;\n\n  const auto *L = dyn_cast<DeclRefExpr>(CBO->getLHS()->IgnoreParenImpCasts());\n\
  \  if (!L)\n    return false;\n  const auto *LVD = dyn_cast<VarDecl>(L->getDecl());\n\
  \  if (!LVD || LVD != V)\n    return false;\n\n  IsStrictLess = (Op == BO_LT);\n\
  \  BoundExpr = CBO->getRHS();\n\n  // We do not strictly enforce increment pattern,\
  \ as per plan.\n\n  LoopVar = V;\n  return true;\n}\n\nbool SAGenTestChecker::indexIsLoopVar(const\
  \ Expr *Idx, const VarDecl *V) {\n  if (!Idx || !V)\n    return false;\n  Idx =\
  \ Idx->IgnoreParenImpCasts();\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(Idx))\
  \ {\n    return DRE->getDecl() == V;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getArraySizeFromSubscriptBase(const\
  \ Expr *Base, llvm::APInt &ArraySize, ASTContext &Ctx) {\n  if (!Base)\n    return\
  \ false;\n\n  // Case 1: direct DeclRefExpr to a variable with ConstantArrayType\n\
  \  if (getArraySizeFromExpr(ArraySize, Base))\n    return true;\n\n  // Case 2:\
  \ MemberExpr (struct or pointer-to-struct field)\n  const MemberExpr *ME = dyn_cast<MemberExpr>(Base->IgnoreParenImpCasts());\n\
  \  if (!ME) {\n    // Try searching downward as a fallback\n    ME = findSpecificTypeInChildren<MemberExpr>(Base);\n\
  \  }\n  if (ME) {\n    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl()))\
  \ {\n      QualType T = FD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(T.getTypePtr()))\
  \ {\n        ArraySize = CAT->getSize();\n        return true;\n      }\n    }\n\
  \  }\n\n  // Unknown or pointer-based indexing: skip\n  return false;\n}\n\nstd::string\
  \ SAGenTestChecker::getArrayName(const Expr *Base) {\n  if (!Base)\n    return std::string();\n\
  \n  Base = Base->IgnoreParenImpCasts();\n\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(Base))\
  \ {\n    if (const auto *VD = dyn_cast<ValueDecl>(DRE->getDecl()))\n      return\
  \ VD->getNameAsString();\n  }\n\n  if (const auto *ME = dyn_cast<MemberExpr>(Base))\
  \ {\n    if (const auto *VD = dyn_cast<ValueDecl>(ME->getMemberDecl()))\n      return\
  \ VD->getNameAsString();\n  }\n\n  // Fallback: try to find a nested MemberExpr\n\
  \  if (const auto *ME2 = findSpecificTypeInChildren<MemberExpr>(Base)) {\n    if\
  \ (const auto *VD = dyn_cast<ValueDecl>(ME2->getMemberDecl()))\n      return VD->getNameAsString();\n\
  \  }\n\n  return std::string();\n}\n\nvoid SAGenTestChecker::report(const ArraySubscriptExpr\
  \ *ASE,\n                              uint64_t BoundVal,\n                    \
  \          StringRef ArrName,\n                              uint64_t ArrSize,\n\
  \                              BugReporter &BR,\n                              ASTContext\
  \ &Ctx) const {\n  if (!ASE)\n    return;\n\n  SmallString<128> Msg;\n  llvm::raw_svector_ostream\
  \ OS(Msg);\n  OS << \"Loop bound \" << BoundVal << \" exceeds array '\" << ArrName\n\
  \     << \"' size \" << ArrSize << \"; \" << ArrName << \"[i] may be out of bounds\"\
  ;\n\n  PathDiagnosticLocation Loc =\n      PathDiagnosticLocation::createBegin(ASE,\
  \ BR.getSourceManager(), Ctx);\n\n  auto R = std::make_unique<BasicBugReport>(*BT,\
  \ OS.str(), Loc);\n  R->addRange(ASE->getSourceRange());\n  BR.emitReport(std::move(R));\n\
  }\n\n//============================ Main AST Callback =============================//\n\
  \nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter\
  \ &BR) const {\n  if (!D)\n    return;\n  const Stmt *Body = D->getBody();\n  if\
  \ (!Body)\n    return;\n\n  ASTContext &Ctx = Mgr.getASTContext();\n\n  // Visitor\
  \ to find ForStmt and analyze them.\n  class Visitor : public RecursiveASTVisitor<Visitor>\
  \ {\n    const SAGenTestChecker *Checker;\n    BugReporter &BR;\n    ASTContext\
  \ &Ctx;\n\n  public:\n    Visitor(const SAGenTestChecker *Checker, BugReporter &BR,\
  \ ASTContext &Ctx)\n        : Checker(Checker), BR(BR), Ctx(Ctx) {}\n\n    bool\
  \ VisitForStmt(const ForStmt *FS) {\n      const VarDecl *LoopVar = nullptr;\n \
  \     const Expr *BoundExpr = nullptr;\n      bool IsStrictLess = true;\n\n    \
  \  if (!SAGenTestChecker::getCanonicalLoop(FS, LoopVar, BoundExpr, IsStrictLess,\
  \ Ctx))\n        return true;\n\n      APSInt BoundAPS;\n      if (!SAGenTestChecker::evalToInt(BoundExpr->IgnoreParenImpCasts(),\
  \ BoundAPS, Ctx))\n        return true;\n\n      uint64_t BoundVal = BoundAPS.isSigned()\
  \ ? BoundAPS.getExtValue() : BoundAPS.getZExtValue();\n      // We only handle non-negative\
  \ bounds\n      if ((BoundAPS.isSigned() && BoundAPS.isNegative()))\n        return\
  \ true;\n\n      // Collect array subscripts with index equal to the loop variable\n\
  \      class BodyVisitor : public RecursiveASTVisitor<BodyVisitor> {\n        const\
  \ VarDecl *V;\n        llvm::SmallVector<const ArraySubscriptExpr *, 8> &Out;\n\
  \      public:\n        BodyVisitor(const VarDecl *V, llvm::SmallVector<const ArraySubscriptExpr\
  \ *, 8> &Out)\n            : V(V), Out(Out) {}\n\n        bool VisitArraySubscriptExpr(const\
  \ ArraySubscriptExpr *ASE) {\n          if (!ASE)\n            return true;\n  \
  \        const Expr *Idx = ASE->getIdx();\n          if (SAGenTestChecker::indexIsLoopVar(Idx,\
  \ V)) {\n            Out.push_back(ASE);\n          }\n          return true;\n\
  \        }\n      };\n\n      llvm::SmallVector<const ArraySubscriptExpr *, 8> Accesses;\n\
  \      BodyVisitor BV(LoopVar, Accesses);\n      if (const Stmt *LoopBody = FS->getBody())\n\
  \        BV.TraverseStmt(const_cast<Stmt *>(LoopBody));\n\n      // Report per array\
  \ per loop (avoid duplicates)\n      llvm::SmallPtrSet<const ValueDecl *, 8> Reported;\n\
  \n      for (const ArraySubscriptExpr *ASE : Accesses) {\n        if (!ASE)\n  \
  \        continue;\n\n        llvm::APInt ArrSizeAP;\n        if (!SAGenTestChecker::getArraySizeFromSubscriptBase(ASE->getBase(),\
  \ ArrSizeAP, Ctx))\n          continue;\n\n        uint64_t ArrSize = ArrSizeAP.getLimitedValue(UINT64_MAX);\n\
  \n        bool IsBug = false;\n        if (IsStrictLess) {\n          // for (i\
  \ = 0; i < Bound) accessing A[i]: overflow if Bound > ArrSize\n          if (BoundVal\
  \ > ArrSize)\n            IsBug = true;\n        } else {\n          // for (i =\
  \ 0; i <= Bound) accessing A[i]: overflow if Bound >= ArrSize\n          if (BoundVal\
  \ >= ArrSize)\n            IsBug = true;\n        }\n\n        if (!IsBug)\n   \
  \       continue;\n\n        // Identify the array's ValueDecl to deduplicate\n\
  \        const ValueDecl *VDKey = nullptr;\n        const Expr *Base = ASE->getBase()->IgnoreParenImpCasts();\n\
  \        if (const auto *DRE = dyn_cast<DeclRefExpr>(Base)) {\n          VDKey =\
  \ dyn_cast<ValueDecl>(DRE->getDecl());\n        } else if (const auto *ME = dyn_cast<MemberExpr>(Base))\
  \ {\n          VDKey = dyn_cast<ValueDecl>(ME->getMemberDecl());\n        } else\
  \ if (const auto *ME2 = findSpecificTypeInChildren<MemberExpr>(ASE->getBase()))\
  \ {\n          VDKey = dyn_cast<ValueDecl>(ME2->getMemberDecl());\n        }\n\n\
  \        if (VDKey && Reported.contains(VDKey))\n          continue;\n        if\
  \ (VDKey)\n          Reported.insert(VDKey);\n\n        std::string Name = SAGenTestChecker::getArrayName(ASE->getBase());\n\
  \        Checker->report(ASE, BoundVal, Name.empty() ? StringRef(\"array\") : StringRef(Name),\n\
  \                        ArrSize, BR, Ctx);\n      }\n\n      return true;\n   \
  \ }\n  };\n\n  Visitor V(this, BR, Ctx);\n  V.TraverseStmt(const_cast<Stmt *>(Body));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect loops that index into a smaller parallel array using a larger\
  \ loop bound\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Fix possible buffer overflow in 'find_dcfclk_for_voltage()'\n\
  \nwhen 'find_dcfclk_for_voltage()' function is looping over\nVG_NUM_SOC_VOLTAGE_LEVELS\
  \ (which is 8), but the size of the DcfClocks\narray is VG_NUM_DCFCLK_DPM_LEVELS\
  \ (which is 7).\n\nWhen the loop variable i reaches 7, the function tries to access\n\
  clock_table->DcfClocks[7]. However, since the size of the DcfClocks\narray is 7,\
  \ the valid indices are 0 to 6. Index 7 is beyond the size of\nthe array, leading\
  \ to a buffer overflow.\n\nReported by smatch & thus fixing the below:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/clk_mgr/dcn301/vg_clk_mgr.c:550\
  \ find_dcfclk_for_voltage() error: buffer overflow 'clock_table->DcfClocks' 7 <=\
  \ 7\n\nFixes: 3a83e4e64bb1 (\"drm/amd/display: Add dcn3.01 support to DC (v2)\"\
  )\nCc: Roman Li <Roman.Li@amd.com>\nCc: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>\n\
  Cc: Aurabindo Pillai <aurabindo.pillai@amd.com>\nSigned-off-by: Srinivasan Shanmugam\
  \ <srinivasan.shanmugam@amd.com>\nReviewed-by: Roman Li <roman.li@amd.com>\nSigned-off-by:\
  \ Alex Deucher <alexander.deucher@amd.com>\n\n## Buggy Code\n\n```c\n// Function:\
  \ find_dcfclk_for_voltage in drivers/gpu/drm/amd/display/dc/clk_mgr/dcn301/vg_clk_mgr.c\n\
  static unsigned int find_dcfclk_for_voltage(const struct vg_dpm_clocks *clock_table,\n\
  \t\tunsigned int voltage)\n{\n\tint i;\n\n\tfor (i = 0; i < VG_NUM_SOC_VOLTAGE_LEVELS;\
  \ i++) {\n\t\tif (clock_table->SocVoltage[i] == voltage)\n\t\t\treturn clock_table->DcfClocks[i];\n\
  \t}\n\n\tASSERT(0);\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git\
  \ a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn301/vg_clk_mgr.c b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn301/vg_clk_mgr.c\n\
  index a5489fe6875f..aa9fd1dc550a 100644\n--- a/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn301/vg_clk_mgr.c\n\
  +++ b/drivers/gpu/drm/amd/display/dc/clk_mgr/dcn301/vg_clk_mgr.c\n@@ -546,6 +546,8\
  \ @@ static unsigned int find_dcfclk_for_voltage(const struct vg_dpm_clocks *clock_ta\n\
  \ \tint i;\n \n \tfor (i = 0; i < VG_NUM_SOC_VOLTAGE_LEVELS; i++) {\n+\t\tif (i\
  \ >= VG_NUM_DCFCLK_DPM_LEVELS)\n+\t\t\tbreak;\n \t\tif (clock_table->SocVoltage[i]\
  \ == voltage)\n \t\t\treturn clock_table->DcfClocks[i];\n \t}\n```\n"
pattern: "## Bug Pattern\n\nIterating over two parallel arrays with the same index\
  \ while using the length/limit of the larger array as the loop bound, and then indexing\
  \ into the smaller array without an additional bound check. Concretely:\n\nfor (i\
  \ = 0; i < SIZE_A; i++) {   // SIZE_A > SIZE_B\n    if (A[i] == key)\n        return\
  \ B[i];             // out-of-bounds when i >= SIZE_B\n}\n\nHere, A has SIZE_A elements\
  \ and B has SIZE_B elements; the loop uses SIZE_A but also accesses B[i], causing\
  \ a buffer overflow when i reaches SIZE_B.."
plan: "1) Program state\n- No custom program state is needed. This checker is a structural/AST\
  \ pattern check.\n\n2) Callback functions\n- Use only checkASTCodeBody. It lets\
  \ us inspect each function body and search for the for-loop pattern.\n\n3) Detailed\
  \ steps\n\nStep A. Scan function bodies for candidate for-loops (checkASTCodeBody)\n\
  - Iterate all statements in the function body and collect ForStmt nodes.\n- For\
  \ each ForStmt F, try to recognize a canonical \u201Czero-to-bound\u201D loop:\n\
  \  - Init: either\n    - DeclStmt with a single VarDecl V initialized to integer\
  \ 0, or\n    - BinaryOperator \u201Ci = 0\u201D with LHS a DeclRefExpr to a VarDecl\
  \ V.\n  - Condition: a BinaryOperator using V and a bound expression, specifically\n\
  \    - \u201Ci < BoundExpr\u201D (primary target), optionally also support \u201C\
  i <= BoundExpr\u201D.\n  - Increment: do not strictly enforce form; it can be i++,\
  \ ++i, i += 1, etc. We only need to know the loop index variable V.\n- If the loop\
  \ does not meet the above shape, skip it (keep the checker simple and precise).\n\
  \nImplementation notes:\n- Extract the loop variable:\n  - If init is DeclStmt:\
  \ get the VarDecl* V and ensure its initializer evaluates to 0 with EvaluateExprToInt.\n\
  \  - If init is BinaryOperator: ensure it is an assignment, LHS is DeclRefExpr to\
  \ V, and RHS evaluates to 0.\n- Extract and validate the condition:\n  - Expect\
  \ a BinaryOperator (BO_LT or optionally BO_LE).\n  - Ensure the LHS is V (DeclRefExpr\
  \ to the same VarDecl).\n  - Record the BoundExpr (the RHS).\n- Evaluate BoundExpr\
  \ to an integer constant using EvaluateExprToInt. If it fails, skip this loop (to\
  \ avoid false positives).\n- Store:\n  - VarDecl* LoopVar\n  - APSInt BoundVal\n\
  \  - A flag indicating whether the operator was \u201C<\u201D or \u201C<=\u201D\
  \ (CompareKind).\n\nStep B. Find arrays indexed by the loop variable inside the\
  \ loop body\n- Traverse the loop body subtree and collect all ArraySubscriptExpr\
  \ (ASE) nodes.\n- For each ASE:\n  - Check that index expression is exactly the\
  \ loop variable (DeclRefExpr to VarDecl V) after IgnoreImpCasts. If not, skip.\n\
  \  - Determine the constant size of the array being indexed (the base of the subscript):\n\
  \    - Case 1: Base is ultimately a DeclRefExpr to a VarDecl with array type.\n\
  \      - Use the provided getArraySizeFromExpr(\u2026).\n    - Case 2: Base contains\
  \ a MemberExpr (e.g., obj.field[i], ptr->field[i]).\n      - Find the MemberExpr\
  \ child with findSpecificTypeInChildren<MemberExpr>(ASE->getBase()).\n      - Get\
  \ the FieldDecl* from MemberExpr::getMemberDecl().\n      - From FieldDecl->getType(),\
  \ retrieve the ConstantArrayType. If present, obtain its size.\n    - If the base\
  \ is a pointer (no ConstantArrayType), or the array size cannot be determined, skip\
  \ this ASE.\n  - If we successfully obtain ArraySize (APInt -> uint64_t), compare\
  \ it with the loop bound:\n    - For \u201Ci < Bound\u201D: if BoundVal > ArraySize,\
  \ this array access may go out-of-bounds.\n    - For \u201Ci <= Bound\u201D: if\
  \ BoundVal >= ArraySize, this array access may go out-of-bounds.\n  - If the comparison\
  \ indicates a possible overflow, record this ASE as a violation with:\n    - The\
  \ array name (from DeclRefExpr or MemberExpr pretty name).\n    - The computed ArraySize\
  \ and BoundVal.\n    - The SourceRange of the ASE for reporting.\n\nNotes to reduce\
  \ noise (optional but simple):\n- Only flag when index is exactly the loop variable\
  \ (no offsets like i+1).\n- Only flag when loop starts at 0 (already enforced).\n\
  - This matches the target pattern while keeping implementation simple and precise.\n\
  \nStep C. Report the bug (inside checkASTCodeBody)\n- For each recorded violation,\
  \ emit a BasicBugReport. Keep message short and clear, for example:\n  - \u201C\
  Loop bound N exceeds array \u2018X\u2019 size M; X[i] may be out of bounds.\u201D\
  \n- Attach the primary location to the ArraySubscriptExpr (ASE) and optionally highlight\
  \ the loop condition\u2019s RHS bound expression.\n- Use a single BugType for the\
  \ checker, e.g., \u201CParallel-array index overflow\u201D.\n- Prefer creating one\
  \ report per array per loop (first occurrence) to avoid duplicates.\n\n4) Helper\
  \ routines to implement in the checker\n- getCanonicalLoop(ForStmt*, VarDecl*& LoopVar,\
  \ const Expr*& BoundExpr, bool& IsStrictLess):\n  - Implements Step A (extract loop\
  \ variable, ensure init is 0, and condition is i < Bound or i <= Bound).\n- evalInt(const\
  \ Expr*, APSInt& Out, CheckerContext or ASTContext):\n  - Thin wrapper over EvaluateExprToInt\
  \ to keep code uniform in this checker.\n- indexIsLoopVar(const Expr* E, const VarDecl*\
  \ V):\n  - Return true if E->IgnoreImpCasts() is a DeclRefExpr to V.\n- getArraySizeFromSubscriptBase(const\
  \ Expr* Base, APInt& OutSize):\n  - Tries utility getArraySizeFromExpr if Base leads\
  \ to a DeclRefExpr.\n  - Otherwise, find MemberExpr child, extract FieldDecl type,\
  \ and if ConstantArrayType, return its size.\n- getArrayName(const Expr* Base):\n\
  \  - If DeclRefExpr: use DRE->getDecl()->getNameAsString().\n  - If MemberExpr:\
  \ use MemberExpr->getMemberDecl()->getNameAsString().\n  - Fallback to ExprHasName(Base,\
  \ \u2026) if you want to enrich the message, but name is optional.\n\n5) Why this\
  \ catches the target bug\n- The target bug is exactly: for (i = 0; i < SIZE_A; i++)\
  \ { if (A[i] == key) return B[i]; }\n- Our checker:\n  - Detects i from 0 to Bound\
  \ (SIZE_A);\n  - Sees an ArraySubscriptExpr B[i] in the loop body;\n  - Extracts\
  \ B\u2019s compile-time array size (SIZE_B);\n  - If Bound > SIZE_B, it reports\
  \ \u201CLoop bound SIZE_A exceeds array \u2018B\u2019 size SIZE_B\u201D, which matches\
  \ the patch\u2019s fix that introduces an extra bound check (break if i >= SIZE_B).\n\
  \n6) Chosen utilities and where used\n- EvaluateExprToInt: evaluate bound expressions\
  \ to integers.\n- findSpecificTypeInChildren<T>: find MemberExpr inside ArraySubscriptExpr\
  \ base for struct/field arrays.\n- ExprHasName (optional): can be used to improve\
  \ diagnostic text if needed.\n- getArraySizeFromExpr: used directly for DeclRefExpr\
  \ bases.\n\n7) Callbacks summary\n- checkASTCodeBody:\n  - Walk ForStmt.\n  - Extract\
  \ loop variable and bound.\n  - Walk loop body, find ArraySubscriptExpr with index\
  \ = loop var.\n  - Obtain array constant sizes and compare with bound.\n  - Emit\
  \ BasicBugReport on violations.\n\nNo other callbacks or program state needed."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"clang/Basic/SourceManager.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n\
  #include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include\
  \ \"llvm/ADT/APSInt.h\"\n#include <string>\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\nnamespace {\n/* The checker callbacks are to\
  \ be decided. */\nclass SAGenTestChecker : public Checker<check::ASTCodeBody> {\n\
  \   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Parallel-array index overflow\", \"Array bounds\")) {}\n\
  \n      void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter &BR)\
  \ const;\n\n   private:\n\n      // Helpers for loop recognition and array access\
  \ analysis\n      static bool getCanonicalLoop(const ForStmt *FS,\n            \
  \                       const VarDecl *&LoopVar,\n                             \
  \      const Expr *&BoundExpr,\n                                   bool &IsStrictLess,\n\
  \                                   ASTContext &Ctx);\n\n      static bool evalToInt(const\
  \ Expr *E, llvm::APSInt &Out, ASTContext &Ctx);\n\n      static bool indexIsLoopVar(const\
  \ Expr *Idx, const VarDecl *V);\n\n      static bool getArraySizeFromSubscriptBase(const\
  \ Expr *Base, llvm::APInt &ArraySize, ASTContext &Ctx);\n\n      static std::string\
  \ getArrayName(const Expr *Base);\n\n      void report(const ArraySubscriptExpr\
  \ *ASE,\n                  uint64_t BoundVal,\n                  StringRef ArrName,\n\
  \                  uint64_t ArrSize,\n                  BugReporter &BR,\n     \
  \             ASTContext &Ctx) const;\n};\n\n//========================== Helper\
  \ Implementations ==========================//\n\nbool SAGenTestChecker::evalToInt(const\
  \ Expr *E, llvm::APSInt &Out, ASTContext &Ctx) {\n  if (!E)\n    return false;\n\
  \  Expr::EvalResult ER;\n  if (E->EvaluateAsInt(ER, Ctx)) {\n    Out = ER.Val.getInt();\n\
  \    return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getCanonicalLoop(const\
  \ ForStmt *FS,\n                                        const VarDecl *&LoopVar,\n\
  \                                        const Expr *&BoundExpr,\n             \
  \                           bool &IsStrictLess,\n                              \
  \          ASTContext &Ctx) {\n  LoopVar = nullptr;\n  BoundExpr = nullptr;\n  IsStrictLess\
  \ = true;\n\n  if (!FS)\n    return false;\n\n  // 1) Init: either \"int i = 0;\"\
  \ or \"i = 0;\"\n  const Stmt *InitS = FS->getInit();\n  const VarDecl *V = nullptr;\n\
  \n  if (const auto *DS = dyn_cast_or_null<DeclStmt>(InitS)) {\n    if (!DS->isSingleDecl())\n\
  \      return false;\n    const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());\n\
  \    if (!VD || !VD->hasInit())\n      return false;\n    llvm::APSInt InitVal;\n\
  \    if (!evalToInt(VD->getInit()->IgnoreParenImpCasts(), InitVal, Ctx))\n     \
  \ return false;\n    if (InitVal != 0)\n      return false;\n    V = VD;\n  } else\
  \ if (const auto *BO = dyn_cast_or_null<BinaryOperator>(InitS)) {\n    if (BO->getOpcode()\
  \ != BO_Assign)\n      return false;\n    const auto *LHS = dyn_cast<DeclRefExpr>(BO->getLHS()->IgnoreParenImpCasts());\n\
  \    if (!LHS)\n      return false;\n    const auto *VD = dyn_cast<VarDecl>(LHS->getDecl());\n\
  \    if (!VD)\n      return false;\n    llvm::APSInt InitVal;\n    if (!evalToInt(BO->getRHS()->IgnoreParenImpCasts(),\
  \ InitVal, Ctx))\n      return false;\n    if (InitVal != 0)\n      return false;\n\
  \    V = VD;\n  } else {\n    return false;\n  }\n\n  // 2) Condition: \"i < Bound\"\
  \ or \"i <= Bound\"\n  const Expr *CondE = FS->getCond();\n  if (!CondE)\n    return\
  \ false;\n  CondE = CondE->IgnoreParenImpCasts();\n  const auto *CBO = dyn_cast<BinaryOperator>(CondE);\n\
  \  if (!CBO)\n    return false;\n\n  BinaryOperator::Opcode Op = CBO->getOpcode();\n\
  \  if (Op != BO_LT && Op != BO_LE)\n    return false;\n\n  const auto *L = dyn_cast<DeclRefExpr>(CBO->getLHS()->IgnoreParenImpCasts());\n\
  \  if (!L)\n    return false;\n  const auto *LVD = dyn_cast<VarDecl>(L->getDecl());\n\
  \  if (!LVD || LVD != V)\n    return false;\n\n  IsStrictLess = (Op == BO_LT);\n\
  \  BoundExpr = CBO->getRHS();\n\n  // We do not strictly enforce increment pattern,\
  \ as per plan.\n\n  LoopVar = V;\n  return true;\n}\n\nbool SAGenTestChecker::indexIsLoopVar(const\
  \ Expr *Idx, const VarDecl *V) {\n  if (!Idx || !V)\n    return false;\n  Idx =\
  \ Idx->IgnoreParenImpCasts();\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(Idx))\
  \ {\n    return DRE->getDecl() == V;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getArraySizeFromSubscriptBase(const\
  \ Expr *Base, llvm::APInt &ArraySize, ASTContext &Ctx) {\n  if (!Base)\n    return\
  \ false;\n\n  // Case 1: direct DeclRefExpr to a variable with ConstantArrayType\n\
  \  if (getArraySizeFromExpr(ArraySize, Base))\n    return true;\n\n  // Case 2:\
  \ MemberExpr (struct or pointer-to-struct field)\n  const MemberExpr *ME = dyn_cast<MemberExpr>(Base->IgnoreParenImpCasts());\n\
  \  if (!ME) {\n    // Try searching downward as a fallback\n    ME = findSpecificTypeInChildren<MemberExpr>(Base);\n\
  \  }\n  if (ME) {\n    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl()))\
  \ {\n      QualType T = FD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(T.getTypePtr()))\
  \ {\n        ArraySize = CAT->getSize();\n        return true;\n      }\n    }\n\
  \  }\n\n  // Unknown or pointer-based indexing: skip\n  return false;\n}\n\nstd::string\
  \ SAGenTestChecker::getArrayName(const Expr *Base) {\n  if (!Base)\n    return std::string();\n\
  \n  Base = Base->IgnoreParenImpCasts();\n\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(Base))\
  \ {\n    if (const auto *VD = dyn_cast<ValueDecl>(DRE->getDecl()))\n      return\
  \ VD->getNameAsString();\n  }\n\n  if (const auto *ME = dyn_cast<MemberExpr>(Base))\
  \ {\n    if (const auto *VD = dyn_cast<ValueDecl>(ME->getMemberDecl()))\n      return\
  \ VD->getNameAsString();\n  }\n\n  // Fallback: try to find a nested MemberExpr\n\
  \  if (const auto *ME2 = findSpecificTypeInChildren<MemberExpr>(Base)) {\n    if\
  \ (const auto *VD = dyn_cast<ValueDecl>(ME2->getMemberDecl()))\n      return VD->getNameAsString();\n\
  \  }\n\n  return std::string();\n}\n\nvoid SAGenTestChecker::report(const ArraySubscriptExpr\
  \ *ASE,\n                              uint64_t BoundVal,\n                    \
  \          StringRef ArrName,\n                              uint64_t ArrSize,\n\
  \                              BugReporter &BR,\n                              ASTContext\
  \ &Ctx) const {\n  if (!ASE)\n    return;\n\n  SmallString<128> Msg;\n  llvm::raw_svector_ostream\
  \ OS(Msg);\n  OS << \"Loop bound \" << BoundVal << \" exceeds array '\" << ArrName\n\
  \     << \"' size \" << ArrSize << \"; \" << ArrName << \"[i] may be out of bounds\"\
  ;\n\n  PathDiagnosticLocation Loc(ASE->getBeginLoc(), BR.getSourceManager());\n\n\
  \  auto R = std::make_unique<BasicBugReport>(*BT, OS.str(), Loc);\n  R->addRange(ASE->getSourceRange());\n\
  \  BR.emitReport(std::move(R));\n}\n\n//============================ Main AST Callback\
  \ =============================//\n\nvoid SAGenTestChecker::checkASTCodeBody(const\
  \ Decl *D, AnalysisManager &Mgr, BugReporter &BR) const {\n  if (!D)\n    return;\n\
  \  const Stmt *Body = D->getBody();\n  if (!Body)\n    return;\n\n  ASTContext &Ctx\
  \ = Mgr.getASTContext();\n\n  // Visitor to find ForStmt and analyze them.\n  class\
  \ Visitor : public RecursiveASTVisitor<Visitor> {\n    const SAGenTestChecker *Checker;\n\
  \    BugReporter &BR;\n    ASTContext &Ctx;\n\n  public:\n    Visitor(const SAGenTestChecker\
  \ *Checker, BugReporter &BR, ASTContext &Ctx)\n        : Checker(Checker), BR(BR),\
  \ Ctx(Ctx) {}\n\n    bool VisitForStmt(const ForStmt *FS) {\n      const VarDecl\
  \ *LoopVar = nullptr;\n      const Expr *BoundExpr = nullptr;\n      bool IsStrictLess\
  \ = true;\n\n      if (!SAGenTestChecker::getCanonicalLoop(FS, LoopVar, BoundExpr,\
  \ IsStrictLess, Ctx))\n        return true;\n\n      llvm::APSInt BoundAPS;\n  \
  \    if (!SAGenTestChecker::evalToInt(BoundExpr->IgnoreParenImpCasts(), BoundAPS,\
  \ Ctx))\n        return true;\n\n      uint64_t BoundVal = BoundAPS.isSigned() ?\
  \ static_cast<uint64_t>(BoundAPS.getExtValue()) : BoundAPS.getZExtValue();\n   \
  \   // We only handle non-negative bounds\n      if ((BoundAPS.isSigned() && BoundAPS.isNegative()))\n\
  \        return true;\n\n      // Collect array subscripts with index equal to the\
  \ loop variable\n      class BodyVisitor : public RecursiveASTVisitor<BodyVisitor>\
  \ {\n        const VarDecl *V;\n        llvm::SmallVector<const ArraySubscriptExpr\
  \ *, 8> &Out;\n      public:\n        BodyVisitor(const VarDecl *V, llvm::SmallVector<const\
  \ ArraySubscriptExpr *, 8> &Out)\n            : V(V), Out(Out) {}\n\n        bool\
  \ VisitArraySubscriptExpr(const ArraySubscriptExpr *ASE) {\n          if (!ASE)\n\
  \            return true;\n          const Expr *Idx = ASE->getIdx();\n        \
  \  if (SAGenTestChecker::indexIsLoopVar(Idx, V)) {\n            Out.push_back(ASE);\n\
  \          }\n          return true;\n        }\n      };\n\n      llvm::SmallVector<const\
  \ ArraySubscriptExpr *, 8> Accesses;\n      BodyVisitor BV(LoopVar, Accesses);\n\
  \      if (const Stmt *LoopBody = FS->getBody())\n        BV.TraverseStmt(const_cast<Stmt\
  \ *>(LoopBody));\n\n      // Report per array per loop (avoid duplicates)\n    \
  \  llvm::SmallPtrSet<const ValueDecl *, 8> Reported;\n\n      for (const ArraySubscriptExpr\
  \ *ASE : Accesses) {\n        if (!ASE)\n          continue;\n\n        llvm::APInt\
  \ ArrSizeAP;\n        if (!SAGenTestChecker::getArraySizeFromSubscriptBase(ASE->getBase(),\
  \ ArrSizeAP, Ctx))\n          continue;\n\n        uint64_t ArrSize = ArrSizeAP.getLimitedValue(UINT64_MAX);\n\
  \n        bool IsBug = false;\n        if (IsStrictLess) {\n          // for (i\
  \ = 0; i < Bound) accessing A[i]: overflow if Bound > ArrSize\n          if (BoundVal\
  \ > ArrSize)\n            IsBug = true;\n        } else {\n          // for (i =\
  \ 0; i <= Bound) accessing A[i]: overflow if Bound >= ArrSize\n          if (BoundVal\
  \ >= ArrSize)\n            IsBug = true;\n        }\n\n        if (!IsBug)\n   \
  \       continue;\n\n        // Identify the array's ValueDecl to deduplicate\n\
  \        const ValueDecl *VDKey = nullptr;\n        const Expr *Base = ASE->getBase()->IgnoreParenImpCasts();\n\
  \        if (const auto *DRE = dyn_cast<DeclRefExpr>(Base)) {\n          VDKey =\
  \ dyn_cast<ValueDecl>(DRE->getDecl());\n        } else if (const auto *ME = dyn_cast<MemberExpr>(Base))\
  \ {\n          VDKey = dyn_cast<ValueDecl>(ME->getMemberDecl());\n        } else\
  \ if (const auto *ME2 = findSpecificTypeInChildren<MemberExpr>(ASE->getBase()))\
  \ {\n          VDKey = dyn_cast<ValueDecl>(ME2->getMemberDecl());\n        }\n\n\
  \        if (VDKey && Reported.contains(VDKey))\n          continue;\n        if\
  \ (VDKey)\n          Reported.insert(VDKey);\n\n        std::string Name = SAGenTestChecker::getArrayName(ASE->getBase());\n\
  \        Checker->report(ASE, BoundVal, Name.empty() ? StringRef(\"array\") : StringRef(Name),\n\
  \                        ArrSize, BR, Ctx);\n      }\n\n      return true;\n   \
  \ }\n  };\n\n  Visitor V(this, BR, Ctx);\n  V.TraverseStmt(const_cast<Stmt *>(Body));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect loops that index into a smaller parallel array using a larger\
  \ loop bound\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
