_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 8bc35475ef1a23b0e224f3242eb11c76cab0ea88
commit_type: Concurrency
index: 7
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include <vector>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No custom program states are necessary.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Speculative\
  \ read before guard\", \"Concurrency\")) {}\n\n  void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\nprivate:\n  // Helper: flatten a\
  \ top-level chain of logical-and (&&) into ordered conjuncts.\n  static void collectAndConjuncts(const\
  \ Expr *E,\n                                  llvm::SmallVector<const Expr *, 8>\
  \ &Out);\n  // Helper: find the IfStmt enclosing the given condition.\n  static\
  \ const IfStmt *getEnclosingIf(const Stmt *S, CheckerContext &C);\n\n  // Helper:\
  \ find the immediately preceding non-empty statement of the IfStmt\n  // within\
  \ its parent compound statement.\n  static const Stmt *findPrevNonEmptyStmt(const\
  \ IfStmt *IS, CheckerContext &C);\n\n  // Helper: determine whether an expression\
  \ represents an unsafe early read\n  // of work->data (directly or via *work_data_bits(work)),\
  \ without READ_ONCE-like\n  // qualifiers.\n  static bool isUnsafeEarlyReadExpr(const\
  \ Expr *E, CheckerContext &C);\n\n  // Helper: check whether an expression uses\
  \ a given VarDecl via DeclRefExpr.\n  static bool exprUsesVar(const Expr *E, const\
  \ VarDecl *VD);\n\n  // Helper: check whether any conjunct (from StartIdx onward)\
  \ uses a given VarDecl.\n  static bool varUsedInConjuncts(const llvm::SmallVector<const\
  \ Expr *, 8> &Conj,\n                                 unsigned StartIdx, const VarDecl\
  \ *VD);\n\n  // Helper: simple filter to ensure RHS conjuncts look related to the\
  \ shared field.\n  static bool rhsConjunctsMentionShared(\n      const llvm::SmallVector<const\
  \ Expr *, 8> &Conj, unsigned StartIdx,\n      CheckerContext &C);\n};\n\n//------------------------------------------------------------------------------\n\
  // Collect logical-and conjuncts (left-to-right).\n//------------------------------------------------------------------------------\n\
  void SAGenTestChecker::collectAndConjuncts(const Expr *E,\n                    \
  \                       llvm::SmallVector<const Expr *, 8> &Out) {\n  if (!E)\n\
  \    return;\n  E = E->IgnoreParenCasts();\n  if (const auto *BO = dyn_cast<BinaryOperator>(E))\
  \ {\n    if (BO->getOpcode() == BO_LAnd) {\n      collectAndConjuncts(BO->getLHS(),\
  \ Out);\n      collectAndConjuncts(BO->getRHS(), Out);\n      return;\n    }\n \
  \ }\n  Out.push_back(E);\n}\n\nconst IfStmt *SAGenTestChecker::getEnclosingIf(const\
  \ Stmt *S, CheckerContext &C) {\n  return findSpecificTypeInParents<IfStmt>(S, C);\n\
  }\n\nconst Stmt *SAGenTestChecker::findPrevNonEmptyStmt(const IfStmt *IS,\n    \
  \                                               CheckerContext &C) {\n  if (!IS)\n\
  \    return nullptr;\n\n  const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(\n\
  \      dyn_cast<Stmt>(IS), C);\n  if (!CS)\n    return nullptr;\n\n  const Stmt\
  \ *Prev = nullptr;\n  for (const Stmt *Child : CS->body()) {\n    if (Child == IS)\n\
  \      break;\n    // Skip null statements (semi-colons) if any\n    if (!Child)\n\
  \      continue;\n    if (isa<NullStmt>(Child))\n      continue;\n    Prev = Child;\n\
  \  }\n  return Prev;\n}\n\nbool SAGenTestChecker::isUnsafeEarlyReadExpr(const Expr\
  \ *E, CheckerContext &C) {\n  if (!E)\n    return false;\n\n  // Reject if access\
  \ is qualified as safe.\n  if (ExprHasName(E, \"READ_ONCE\", C) ||\n      ExprHasName(E,\
  \ \"ACCESS_ONCE\", C) ||\n      ExprHasName(E, \"smp_load_acquire\", C)) {\n   \
  \ return false;\n  }\n\n  const Expr *EI = E->IgnoreParenCasts();\n\n  // Pattern\
  \ A: *work_data_bits(work)\n  if (const auto *UO = dyn_cast<UnaryOperator>(EI))\
  \ {\n    if (UO->getOpcode() == UO_Deref) {\n      const Expr *SubE = UO->getSubExpr()->IgnoreParenCasts();\n\
  \      if (const auto *CE = dyn_cast<CallExpr>(SubE)) {\n        const Expr *Callee\
  \ = CE->getCallee();\n        if (Callee && ExprHasName(Callee, \"work_data_bits\"\
  , C)) {\n          return true;\n        }\n      }\n      // Fallback textual check\
  \ for robustness\n      if (ExprHasName(SubE, \"work_data_bits\", C))\n        return\
  \ true;\n    }\n  }\n  // Textual pattern check: read via accessor call\n  if (ExprHasName(EI,\
  \ \"work_data_bits\", C))\n    return true;\n\n  // Pattern B: direct field access\
  \ like work->data or work.data\n  bool mentionsWork = ExprHasName(EI, \"work\",\
  \ C);\n  bool mentionsArrowData = ExprHasName(EI, \"->data\", C);\n  bool mentionsDotData\
  \ = ExprHasName(EI, \".data\", C);\n  if (mentionsWork && (mentionsArrowData ||\
  \ mentionsDotData))\n    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::exprUsesVar(const\
  \ Expr *E, const VarDecl *VD) {\n  if (!E || !VD)\n    return false;\n\n  struct\
  \ Finder : public RecursiveASTVisitor<Finder> {\n    const VarDecl *Target;\n  \
  \  bool Found = false;\n    explicit Finder(const VarDecl *VD) : Target(VD) {}\n\
  \    bool VisitDeclRefExpr(DeclRefExpr *DRE) {\n      if (const auto *V = dyn_cast_or_null<VarDecl>(DRE->getDecl()))\
  \ {\n        if (V == Target) {\n          Found = true;\n          return false;\
  \ // Stop early\n        }\n      }\n      return true;\n    }\n  };\n\n  Finder\
  \ F(VD);\n  F.TraverseStmt(const_cast<Expr *>(E));\n  return F.Found;\n}\n\nbool\
  \ SAGenTestChecker::varUsedInConjuncts(\n    const llvm::SmallVector<const Expr\
  \ *, 8> &Conj, unsigned StartIdx,\n    const VarDecl *VD) {\n  for (unsigned i =\
  \ StartIdx; i < Conj.size(); ++i) {\n    if (exprUsesVar(Conj[i], VD))\n      return\
  \ true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::rhsConjunctsMentionShared(\n\
  \    const llvm::SmallVector<const Expr *, 8> &Conj, unsigned StartIdx,\n    CheckerContext\
  \ &C) {\n  for (unsigned i = StartIdx; i < Conj.size(); ++i) {\n    const Expr *E\
  \ = Conj[i];\n    if (!E)\n      continue;\n    if (ExprHasName(E, \"work_data_bits\"\
  , C))\n      return true;\n    if (ExprHasName(E, \"->data\", C))\n      return\
  \ true;\n    if (ExprHasName(E, \".data\", C))\n      return true;\n    if (ExprHasName(E,\
  \ \"data\", C))\n      return true;\n  }\n  return false;\n}\n\n//------------------------------------------------------------------------------\n\
  // Main detection in branch conditions.\n//------------------------------------------------------------------------------\n\
  void SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\n           \
  \                                 CheckerContext &C) const {\n  // Find the enclosing\
  \ if-statement for this condition.\n  const IfStmt *IS = getEnclosingIf(Condition,\
  \ C);\n  if (!IS)\n    return;\n\n  const Expr *CondE = dyn_cast<Expr>(IS->getCond());\n\
  \  if (!CondE)\n    return;\n\n  llvm::SmallVector<const Expr *, 8> Conj;\n  collectAndConjuncts(CondE,\
  \ Conj);\n  if (Conj.size() < 2)\n    return;\n\n  // Guard must be the leftmost\
  \ conjunct and mention \"from_cancel\".\n  const Expr *Guard = Conj[0];\n  if (!Guard\
  \ || !ExprHasName(Guard, \"from_cancel\", C))\n    return;\n\n  // Heuristic check\
  \ that RHS conjuncts talk about the shared field.\n  if (!rhsConjunctsMentionShared(Conj,\
  \ /*StartIdx=*/1, C))\n    return;\n\n  // Look for an immediately preceding unconditional\
  \ read.\n  const Stmt *Prev = findPrevNonEmptyStmt(IS, C);\n  if (!Prev)\n    return;\n\
  \n  // Case 1: DeclStmt with single VarDecl and initializer\n  if (const auto *DS\
  \ = dyn_cast<DeclStmt>(Prev)) {\n    if (DS->isSingleDecl()) {\n      if (const\
  \ auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl())) {\n        if (VD->hasInit())\
  \ {\n          const Expr *Init = VD->getInit();\n          if (isUnsafeEarlyReadExpr(Init,\
  \ C)) {\n            // Ensure that this variable feeds into RHS conjuncts.\n  \
  \          if (varUsedInConjuncts(Conj, /*StartIdx=*/1, VD)) {\n              ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n              if (!N)\n                return;\n\
  \              auto R = std::make_unique<PathSensitiveBugReport>(\n            \
  \      *BT,\n                  \"Early read of work->data before checking from_cancel;\
  \ may race with concurrent writers.\",\n                  N);\n              R->addRange(Prev->getSourceRange());\n\
  \              C.emitReport(std::move(R));\n              return;\n            }\n\
  \          }\n        }\n      }\n    }\n  }\n\n  // Case 2: Assignment statement\
  \ storing the early read to a local variable.\n  // The assignment might be wrapped\
  \ in other statement nodes; search downwards.\n  if (const auto *Assign =\n    \
  \      findSpecificTypeInChildren<BinaryOperator>(Prev)) {\n    if (Assign->getOpcode()\
  \ == BO_Assign) {\n      const Expr *LHS = Assign->getLHS()->IgnoreParenCasts();\n\
  \      const Expr *RHS = Assign->getRHS();\n      const auto *LHSRef = dyn_cast<DeclRefExpr>(LHS);\n\
  \      const VarDecl *VD = LHSRef ? dyn_cast<VarDecl>(LHSRef->getDecl()) : nullptr;\n\
  \      if (VD && RHS && isUnsafeEarlyReadExpr(RHS, C)) {\n        // Ensure that\
  \ this variable is actually used in RHS conjuncts.\n        if (varUsedInConjuncts(Conj,\
  \ /*StartIdx=*/1, VD)) {\n          ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \          if (!N)\n            return;\n          auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \              *BT,\n              \"Early read of work->data before checking from_cancel;\
  \ may race with concurrent writers.\",\n              N);\n          R->addRange(Prev->getSourceRange());\n\
  \          C.emitReport(std::move(R));\n          return;\n        }\n      }\n\
  \    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects early/speculative read of work->data before checking from_cancel\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nworkqueue: Fix spruious data race in __flush_work()\n\
  \nWhen flushing a work item for cancellation, __flush_work() knows that it\nexclusively\
  \ owns the work item through its PENDING bit. 134874e2eee9\n(\"workqueue: Allow\
  \ cancel_work_sync() and disable_work() from atomic\ncontexts on BH work items\"\
  ) added a read of @work->data to determine whether\nto use busy wait for BH work\
  \ items that are being canceled. While the read\nis safe when @from_cancel, @work->data\
  \ was read before testing @from_cancel\nto simplify code structure:\n\n\tdata =\
  \ *work_data_bits(work);\n\tif (from_cancel &&\n\t    !WARN_ON_ONCE(data & WORK_STRUCT_PWQ)\
  \ && (data & WORK_OFFQ_BH)) {\n\nWhile the read data was never used if !@from_cancel,\
  \ this could trigger\nKCSAN data race detection spuriously:\n\n  ==================================================================\n\
  \  BUG: KCSAN: data-race in __flush_work / __flush_work\n\n  write to 0xffff8881223aa3e8\
  \ of 8 bytes by task 3998 on cpu 0:\n   instrument_write include/linux/instrumented.h:41\
  \ [inline]\n   ___set_bit include/asm-generic/bitops/instrumented-non-atomic.h:28\
  \ [inline]\n   insert_wq_barrier kernel/workqueue.c:3790 [inline]\n   start_flush_work\
  \ kernel/workqueue.c:4142 [inline]\n   __flush_work+0x30b/0x570 kernel/workqueue.c:4178\n\
  \   flush_work kernel/workqueue.c:4229 [inline]\n   ...\n\n  read to 0xffff8881223aa3e8\
  \ of 8 bytes by task 50 on cpu 1:\n   __flush_work+0x42a/0x570 kernel/workqueue.c:4188\n\
  \   flush_work kernel/workqueue.c:4229 [inline]\n   flush_delayed_work+0x66/0x70\
  \ kernel/workqueue.c:4251\n   ...\n\n  value changed: 0x0000000000400000 -> 0xffff88810006c00d\n\
  \nReorganize the code so that @from_cancel is tested before @work->data is\naccessed.\
  \ The only problem is triggering KCSAN detection spuriously. This\nshouldn't need\
  \ READ_ONCE() or other access qualifiers.\n\nNo functional changes.\n\nSigned-off-by:\
  \ Tejun Heo <tj@kernel.org>\nReported-by: syzbot+b3e4f2f51ed645fd5df2@syzkaller.appspotmail.com\n\
  Fixes: 134874e2eee9 (\"workqueue: Allow cancel_work_sync() and disable_work() from\
  \ atomic contexts on BH work items\")\nLink: http://lkml.kernel.org/r/000000000000ae429e061eea2157@google.com\n\
  Cc: Jens Axboe <axboe@kernel.dk>\n\n## Buggy Code\n\n```c\n// Function: __flush_work\
  \ in kernel/workqueue.c\nstatic bool __flush_work(struct work_struct *work, bool\
  \ from_cancel)\n{\n\tstruct wq_barrier barr;\n\tunsigned long data;\n\n\tif (WARN_ON(!wq_online))\n\
  \t\treturn false;\n\n\tif (WARN_ON(!work->func))\n\t\treturn false;\n\n\tif (!start_flush_work(work,\
  \ &barr, from_cancel))\n\t\treturn false;\n\n\t/*\n\t * start_flush_work() returned\
  \ %true. If @from_cancel is set, we know\n\t * that @work must have been executing\
  \ during start_flush_work() and\n\t * can't currently be queued. Its data must contain\
  \ OFFQ bits. If @work\n\t * was queued on a BH workqueue, we also know that it was\
  \ running in the\n\t * BH context and thus can be busy-waited.\n\t */\n\tdata =\
  \ *work_data_bits(work);\n\tif (from_cancel &&\n\t    !WARN_ON_ONCE(data & WORK_STRUCT_PWQ)\
  \ && (data & WORK_OFFQ_BH)) {\n\t\t/*\n\t\t * On RT, prevent a live lock when %current\
  \ preempted soft\n\t\t * interrupt processing or prevents ksoftirqd from running\
  \ by\n\t\t * keeping flipping BH. If the BH work item runs on a different\n\t\t\
  \ * CPU then this has no effect other than doing the BH\n\t\t * disable/enable dance\
  \ for nothing. This is copied from\n\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  \t\t */\n\t\twhile (!try_wait_for_completion(&barr.done)) {\n\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tlocal_bh_enable();\n\t\t\t} else {\n\t\
  \t\t\tcpu_relax();\n\t\t\t}\n\t\t}\n\t} else {\n\t\twait_for_completion(&barr.done);\n\
  \t}\n\n\tdestroy_work_on_stack(&barr.work);\n\treturn true;\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/kernel/workqueue.c b/kernel/workqueue.c\nindex\
  \ d56bd2277e58..ef174d8c1f63 100644\n--- a/kernel/workqueue.c\n+++ b/kernel/workqueue.c\n\
  @@ -4166,7 +4166,6 @@ static bool start_flush_work(struct work_struct *work, struct\
  \ wq_barrier *barr,\n static bool __flush_work(struct work_struct *work, bool from_cancel)\n\
  \ {\n \tstruct wq_barrier barr;\n-\tunsigned long data;\n \n \tif (WARN_ON(!wq_online))\n\
  \ \t\treturn false;\n@@ -4184,29 +4183,35 @@ static bool __flush_work(struct work_struct\
  \ *work, bool from_cancel)\n \t * was queued on a BH workqueue, we also know that\
  \ it was running in the\n \t * BH context and thus can be busy-waited.\n \t */\n\
  -\tdata = *work_data_bits(work);\n-\tif (from_cancel &&\n-\t    !WARN_ON_ONCE(data\
  \ & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_BH)) {\n-\t\t/*\n-\t\t * On RT, prevent\
  \ a live lock when %current preempted soft\n-\t\t * interrupt processing or prevents\
  \ ksoftirqd from running by\n-\t\t * keeping flipping BH. If the BH work item runs\
  \ on a different\n-\t\t * CPU then this has no effect other than doing the BH\n\
  -\t\t * disable/enable dance for nothing. This is copied from\n-\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  -\t\t */\n-\t\twhile (!try_wait_for_completion(&barr.done)) {\n-\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n-\t\t\t\tlocal_bh_disable();\n-\t\t\t\tlocal_bh_enable();\n-\t\t\t} else {\n\
  -\t\t\t\tcpu_relax();\n+\tif (from_cancel) {\n+\t\tunsigned long data = *work_data_bits(work);\n\
  +\n+\t\tif (!WARN_ON_ONCE(data & WORK_STRUCT_PWQ) &&\n+\t\t    (data & WORK_OFFQ_BH))\
  \ {\n+\t\t\t/*\n+\t\t\t * On RT, prevent a live lock when %current preempted\n+\t\
  \t\t * soft interrupt processing or prevents ksoftirqd from\n+\t\t\t * running by\
  \ keeping flipping BH. If the BH work item\n+\t\t\t * runs on a different CPU then\
  \ this has no effect other\n+\t\t\t * than doing the BH disable/enable dance for\
  \ nothing.\n+\t\t\t * This is copied from\n+\t\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  +\t\t\t */\n+\t\t\twhile (!try_wait_for_completion(&barr.done)) {\n+\t\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n+\t\t\t\t\tlocal_bh_disable();\n+\t\t\t\t\tlocal_bh_enable();\n+\t\t\t\t} else\
  \ {\n+\t\t\t\t\tcpu_relax();\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tgoto out_destroy;\n \t\
  \t}\n-\t} else {\n-\t\twait_for_completion(&barr.done);\n \t}\n \n+\twait_for_completion(&barr.done);\n\
  +\n+out_destroy:\n \tdestroy_work_on_stack(&barr.work);\n \treturn true;\n }\n```\n"
pattern: '## Bug Pattern


  Speculative/early read of a concurrently modified shared field before verifying
  the condition that makes the access safe.


  Concretely: reading work->data (via work_data_bits(work)) unconditionally, without
  locking or READ_ONCE, even though that read is only valid when from_cancel is true
  (which guarantees exclusive ownership). This unconditional read can race with concurrent
  writers and trigger KCSAN, even if the value is later unused when the condition
  is false. The correct pattern is to first check the guarding condition that provides
  synchronization (e.g., from_cancel) and only then access the shared field.'
plan: "1) Program state\n- No custom program state is necessary. This checker is a\
  \ structural/pattern checker that looks for an unconditional read of a shared field\
  \ immediately before a guarded condition that would have made the read safe.\n\n\
  2) Callback functions\n- Use only checkBranchCondition. This is sufficient to (a)\
  \ recognize the specific guarded if-condition and (b) inspect the immediately preceding\
  \ statement for the speculative/early read.\n\n3) Detailed steps\n\nStep A: Recognize\
  \ the guarded condition in checkBranchCondition\n- Input: const Stmt *Condition\
  \ (from the IfStmt condition).\n- Find the enclosing IfStmt: use findSpecificTypeInParents<IfStmt>(Condition,\
  \ C).\n- Ensure the statement is actually an IfStmt condition and top-level operator\
  \ is a logical-and (BO_LAnd). Flatten chained && into a list of conjuncts to correctly\
  \ identify \u201Cleftmost\u201D operand.\n- Identify the guard operand:\n  - Let\
  \ GuardExpr be the leftmost operand of the top-level logical-and chain.\n  - Use\
  \ ExprHasName(GuardExpr, \"from_cancel\", C) to detect the specific guard used in\
  \ the Linux kernel pattern. If false, bail out early to avoid false positives.\n\
  - Identify the \u201Cdata-dependent\u201D operand:\n  - Among the remaining conjuncts\
  \ (right-side of the leftmost &&), check if any:\n    - References a variable commonly\
  \ used for the pre-read, e.g., ExprHasName(Conjunct, \"data\", C), or\n    - Mentions\
  \ known accessors of the underlying shared field, e.g., ExprHasName(Conjunct, \"\
  work_data_bits\", C), or\n    - Mentions direct field access pattern, e.g., ExprHasName(Conjunct,\
  \ \"->data\", C).\n  - If none match, bail out. If the condition contains a call\
  \ to work_data_bits on the RHS of &&, that is safe (short-circuit) and must not\
  \ be flagged; we will only warn if we also find a prior unconditional read (see\
  \ Step B).\n\nStep B: Verify there is an immediately-preceding unconditional read\n\
  - From the IfStmt found in Step A, locate its parent CompoundStmt:\n  - Use findSpecificTypeInParents<CompoundStmt>(IfStmt,\
  \ C).\n  - Iterate through CompoundStmt body to find the index of this IfStmt; inspect\
  \ the immediately preceding statement (if any). Skip trivial NullStmt and empty\
  \ statements.\n- Accept either of the following forms for the preceding statement:\n\
  \  1) DeclStmt with a single VarDecl initialized from the shared field:\n     -\
  \ VarDecl has an initializer Expr Init.\n     - The declared variable is most often\
  \ named \u201Cdata\u201D; confirm name with VarDecl->getName() == \"data\" OR the\
  \ If condition actually uses this variable (by checking a DeclRefExpr to this VarDecl\
  \ in the If condition).\n     - Check Init expression to confirm it is an unsafe\
  \ read:\n       - Matches one of:\n         - UnaryOperator \u2018*\u2019 applied\
  \ to a call whose callee name contains \u201Cwork_data_bits\u201D.\n         - MemberExpr\
  \ pointing to something named \u201Cwork\u201D accessing \u201Cdata\u201D via \u201C\
  ->data\u201D or \u201C.data\u201D.\n       - Ensure no access-qualifiers are used\
  \ that make the read safe:\n         - Reject if Init contains \u201CREAD_ONCE\u201D\
  , \u201CACCESS_ONCE\u201D, \u201Csmp_load_acquire\u201D. Use ExprHasName to screen\
  \ these.\n  2) BinaryOperator assignment \u2018=\u2019 writing to that same variable:\n\
  \     - LHS is a DeclRefExpr to a VarDecl (often named \u201Cdata\u201D but verify\
  \ by actual usage in the If condition).\n     - RHS satisfies the same \u201Cunsafe\
  \ read\u201D criteria as in (1).\n     - Ensure RHS also does not contain READ_ONCE/ACCESS_ONCE/smp_load_acquire.\n\
  - If neither form is found immediately preceding the IfStmt, do not report (this\
  \ ensures we only warn when the read happens unconditionally before the guard condition).\n\
  \nStep C: Additional filters to limit false positives (simple and targeted)\n- Ensure\
  \ the guard operand name contains \u201Cfrom_cancel\u201D to match the intended\
  \ kernel pattern. If needed, allow \u201Cfrom_cancel\u201D to appear in a compound\
  \ expression, but it must be in the leftmost && operand.\n- When scanning RHS for\
  \ \u201C->data\u201D, also ensure the base object name likely matches the intended\
  \ target, e.g., ExprHasName(RHS, \"work\") && ExprHasName(RHS, \"->data\"). This\
  \ ties the read to work->data and reduces noise.\n- If the RHS contains any of \u201C\
  READ_ONCE\u201D, \u201CACCESS_ONCE\u201D, \u201Csmp_load_acquire\u201D, or other\
  \ clearly safe accessors, do not report.\n\nStep D: Reporting\n- Location to report:\
  \ Prefer reporting at the read site (the RHS of the DeclStmt initializer or RHS\
  \ of the assignment) because that is the speculative/early read. If extracting a\
  \ precise subrange is complex, report on the preceding statement as a whole.\n-\
  \ Generate a non-fatal error node via C.generateNonFatalErrorNode().\n- Emit a PathSensitiveBugReport\
  \ with a short message:\n  - \u201CEarly read of work->data before checking from_cancel;\
  \ may race with concurrent writers.\u201D\n- Optionally, add a note that suggests\
  \ the safe pattern:\n  - \u201CCheck from_cancel first, then read work->data (or\
  \ use READ_ONCE).\u201D\n- Use a dedicated BugType, e.g., \u201CSpeculative read\
  \ before guard\u201D.\n\n4) Helper logic to include in the checker\n- Flattening\
  \ helper for logical-and:\n  - Given an Expr for the condition, peel off nested\
  \ BO_LAnd to produce an ordered vector: [leftmost, ..., rightmost].\n- Previous-sibling\
  \ finder:\n  - Given an IfStmt and its parent CompoundStmt, iterate the body stmts\
  \ to find the IfStmt index and return the previous non-empty statement.\n- Condition-use\
  \ check:\n  - To confirm that the variable assigned in the preceding stmt is actually\
  \ used in the If condition, scan If condition for DeclRefExprs and match the VarDecl\
  \ pointer identity.\n\n5) Summary of the minimal, concrete detection rule\n- Pattern\
  \ to flag:\n  - In a function where an If condition starts with a \u201Cfrom_cancel\u201D\
  \ check (as the leftmost && operand),\n  - The statement immediately preceding that\
  \ If performs an unconditional read of work->data (directly or via *work_data_bits(work))\
  \ into a local,\n  - Without READ_ONCE/ACCESS_ONCE-like qualifiers,\n  - And that\
  \ local (or the read result) is used in the non-leftmost part(s) of the If condition.\n\
  - Report: \u201CEarly read of work->data before checking from_cancel; may race with\
  \ concurrent writers.\u201D"
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include <vector>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No custom program states are necessary.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Speculative\
  \ read before guard\", \"Concurrency\")) {}\n\n  void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\nprivate:\n  // Helper: flatten a\
  \ top-level chain of logical-and (&&) into ordered conjuncts.\n  static void collectAndConjuncts(const\
  \ Expr *E,\n                                  llvm::SmallVector<const Expr *, 8>\
  \ &Out);\n  // Helper: find the IfStmt enclosing the given condition.\n  static\
  \ const IfStmt *getEnclosingIf(const Stmt *S, CheckerContext &C);\n\n  // Helper:\
  \ find the immediately preceding non-empty statement of the IfStmt\n  // within\
  \ its parent compound statement.\n  static const Stmt *findPrevNonEmptyStmt(const\
  \ IfStmt *IS, CheckerContext &C);\n\n  // Helper: determine whether an expression\
  \ represents an unsafe early read\n  // of work->data (directly or via *work_data_bits(work)),\
  \ without READ_ONCE-like\n  // qualifiers.\n  static bool isUnsafeEarlyReadExpr(const\
  \ Expr *E, CheckerContext &C);\n\n  // Helper: check whether an expression uses\
  \ a given VarDecl via DeclRefExpr.\n  static bool exprUsesVar(const Expr *E, const\
  \ VarDecl *VD);\n\n  // Helper: check whether any conjunct (from StartIdx onward)\
  \ uses a given VarDecl.\n  static bool varUsedInConjuncts(const llvm::SmallVector<const\
  \ Expr *, 8> &Conj,\n                                 unsigned StartIdx, const VarDecl\
  \ *VD);\n\n  // Helper: simple filter to ensure RHS conjuncts look related to the\
  \ shared field.\n  static bool rhsConjunctsMentionShared(\n      const llvm::SmallVector<const\
  \ Expr *, 8> &Conj, unsigned StartIdx,\n      CheckerContext &C);\n};\n\n//------------------------------------------------------------------------------\n\
  // Collect logical-and conjuncts (left-to-right).\n//------------------------------------------------------------------------------\n\
  void SAGenTestChecker::collectAndConjuncts(const Expr *E,\n                    \
  \                       llvm::SmallVector<const Expr *, 8> &Out) {\n  if (!E)\n\
  \    return;\n  E = E->IgnoreParenCasts();\n  if (const auto *BO = dyn_cast<BinaryOperator>(E))\
  \ {\n    if (BO->getOpcode() == BO_LAnd) {\n      collectAndConjuncts(BO->getLHS(),\
  \ Out);\n      collectAndConjuncts(BO->getRHS(), Out);\n      return;\n    }\n \
  \ }\n  Out.push_back(E);\n}\n\nconst IfStmt *SAGenTestChecker::getEnclosingIf(const\
  \ Stmt *S, CheckerContext &C) {\n  return findSpecificTypeInParents<IfStmt>(S, C);\n\
  }\n\nconst Stmt *SAGenTestChecker::findPrevNonEmptyStmt(const IfStmt *IS,\n    \
  \                                               CheckerContext &C) {\n  if (!IS)\n\
  \    return nullptr;\n\n  const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(\n\
  \      dyn_cast<Stmt>(IS), C);\n  if (!CS)\n    return nullptr;\n\n  const Stmt\
  \ *Prev = nullptr;\n  for (const Stmt *Child : CS->body()) {\n    if (Child == IS)\n\
  \      break;\n    // Skip null statements (semi-colons) if any\n    if (!Child)\n\
  \      continue;\n    if (isa<NullStmt>(Child))\n      continue;\n    Prev = Child;\n\
  \  }\n  return Prev;\n}\n\nbool SAGenTestChecker::isUnsafeEarlyReadExpr(const Expr\
  \ *E, CheckerContext &C) {\n  if (!E)\n    return false;\n\n  // Reject if access\
  \ is qualified as safe.\n  if (ExprHasName(E, \"READ_ONCE\", C) ||\n      ExprHasName(E,\
  \ \"ACCESS_ONCE\", C) ||\n      ExprHasName(E, \"smp_load_acquire\", C)) {\n   \
  \ return false;\n  }\n\n  const Expr *EI = E->IgnoreParenCasts();\n\n  // Pattern\
  \ A: *work_data_bits(work)\n  if (const auto *UO = dyn_cast<UnaryOperator>(EI))\
  \ {\n    if (UO->getOpcode() == UO_Deref) {\n      const Expr *SubE = UO->getSubExpr()->IgnoreParenCasts();\n\
  \      if (const auto *CE = dyn_cast<CallExpr>(SubE)) {\n        const Expr *Callee\
  \ = CE->getCallee();\n        if (Callee && ExprHasName(Callee, \"work_data_bits\"\
  , C)) {\n          return true;\n        }\n      }\n      // Fallback textual check\
  \ for robustness\n      if (ExprHasName(SubE, \"work_data_bits\", C))\n        return\
  \ true;\n    }\n  }\n  // Textual pattern check: read via accessor call\n  if (ExprHasName(EI,\
  \ \"work_data_bits\", C))\n    return true;\n\n  // Pattern B: direct field access\
  \ like work->data or work.data\n  bool mentionsWork = ExprHasName(EI, \"work\",\
  \ C);\n  bool mentionsArrowData = ExprHasName(EI, \"->data\", C);\n  bool mentionsDotData\
  \ = ExprHasName(EI, \".data\", C);\n  if (mentionsWork && (mentionsArrowData ||\
  \ mentionsDotData))\n    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::exprUsesVar(const\
  \ Expr *E, const VarDecl *VD) {\n  if (!E || !VD)\n    return false;\n\n  struct\
  \ Finder : public RecursiveASTVisitor<Finder> {\n    const VarDecl *Target;\n  \
  \  bool Found = false;\n    explicit Finder(const VarDecl *VD) : Target(VD) {}\n\
  \    bool VisitDeclRefExpr(DeclRefExpr *DRE) {\n      if (const auto *V = dyn_cast_or_null<VarDecl>(DRE->getDecl()))\
  \ {\n        if (V == Target) {\n          Found = true;\n          return false;\
  \ // Stop early\n        }\n      }\n      return true;\n    }\n  };\n\n  Finder\
  \ F(VD);\n  F.TraverseStmt(const_cast<Expr *>(E));\n  return F.Found;\n}\n\nbool\
  \ SAGenTestChecker::varUsedInConjuncts(\n    const llvm::SmallVector<const Expr\
  \ *, 8> &Conj, unsigned StartIdx,\n    const VarDecl *VD) {\n  for (unsigned i =\
  \ StartIdx; i < Conj.size(); ++i) {\n    if (exprUsesVar(Conj[i], VD))\n      return\
  \ true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::rhsConjunctsMentionShared(\n\
  \    const llvm::SmallVector<const Expr *, 8> &Conj, unsigned StartIdx,\n    CheckerContext\
  \ &C) {\n  for (unsigned i = StartIdx; i < Conj.size(); ++i) {\n    const Expr *E\
  \ = Conj[i];\n    if (!E)\n      continue;\n    if (ExprHasName(E, \"work_data_bits\"\
  , C))\n      return true;\n    if (ExprHasName(E, \"->data\", C))\n      return\
  \ true;\n    if (ExprHasName(E, \".data\", C))\n      return true;\n    if (ExprHasName(E,\
  \ \"data\", C))\n      return true;\n  }\n  return false;\n}\n\n//------------------------------------------------------------------------------\n\
  // Main detection in branch conditions.\n//------------------------------------------------------------------------------\n\
  void SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\n           \
  \                                 CheckerContext &C) const {\n  // Find the enclosing\
  \ if-statement for this condition.\n  const IfStmt *IS = getEnclosingIf(Condition,\
  \ C);\n  if (!IS)\n    return;\n\n  const Expr *CondE = dyn_cast<Expr>(IS->getCond());\n\
  \  if (!CondE)\n    return;\n\n  llvm::SmallVector<const Expr *, 8> Conj;\n  collectAndConjuncts(CondE,\
  \ Conj);\n  if (Conj.size() < 2)\n    return;\n\n  // Guard must be the leftmost\
  \ conjunct and mention \"from_cancel\".\n  const Expr *Guard = Conj[0];\n  if (!Guard\
  \ || !ExprHasName(Guard, \"from_cancel\", C))\n    return;\n\n  // Heuristic check\
  \ that RHS conjuncts talk about the shared field.\n  if (!rhsConjunctsMentionShared(Conj,\
  \ /*StartIdx=*/1, C))\n    return;\n\n  // Look for an immediately preceding unconditional\
  \ read.\n  const Stmt *Prev = findPrevNonEmptyStmt(IS, C);\n  if (!Prev)\n    return;\n\
  \n  // Case 1: DeclStmt with single VarDecl and initializer\n  if (const auto *DS\
  \ = dyn_cast<DeclStmt>(Prev)) {\n    if (DS->isSingleDecl()) {\n      if (const\
  \ auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl())) {\n        if (VD->hasInit())\
  \ {\n          const Expr *Init = VD->getInit();\n          if (isUnsafeEarlyReadExpr(Init,\
  \ C)) {\n            // Ensure that this variable feeds into RHS conjuncts.\n  \
  \          if (varUsedInConjuncts(Conj, /*StartIdx=*/1, VD)) {\n              ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n              if (!N)\n                return;\n\
  \              auto R = std::make_unique<PathSensitiveBugReport>(\n            \
  \      *BT,\n                  \"Early read of work->data before checking from_cancel;\
  \ may race with concurrent writers.\",\n                  N);\n              R->addRange(Prev->getSourceRange());\n\
  \              C.emitReport(std::move(R));\n              return;\n            }\n\
  \          }\n        }\n      }\n    }\n  }\n\n  // Case 2: Assignment statement\
  \ storing the early read to a local variable.\n  // The assignment might be wrapped\
  \ in other statement nodes; search downwards.\n  if (const auto *Assign =\n    \
  \      findSpecificTypeInChildren<BinaryOperator>(Prev)) {\n    if (Assign->getOpcode()\
  \ == BO_Assign) {\n      const Expr *LHS = Assign->getLHS()->IgnoreParenCasts();\n\
  \      const Expr *RHS = Assign->getRHS();\n      const auto *LHSRef = dyn_cast<DeclRefExpr>(LHS);\n\
  \      const VarDecl *VD = LHSRef ? dyn_cast<VarDecl>(LHSRef->getDecl()) : nullptr;\n\
  \      if (VD && RHS && isUnsafeEarlyReadExpr(RHS, C)) {\n        // Ensure that\
  \ this variable is actually used in RHS conjuncts.\n        if (varUsedInConjuncts(Conj,\
  \ /*StartIdx=*/1, VD)) {\n          ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \          if (!N)\n            return;\n          auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \              *BT,\n              \"Early read of work->data before checking from_cancel;\
  \ may race with concurrent writers.\",\n              N);\n          R->addRange(Prev->getSourceRange());\n\
  \          C.emitReport(std::move(R));\n          return;\n        }\n      }\n\
  \    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects early/speculative read of work->data before checking from_cancel\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
