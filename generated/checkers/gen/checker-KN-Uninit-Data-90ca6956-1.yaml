_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 90ca6956d3834db4060f87700e2fcbb699c4e4fd
commit_type: Uninit-Data
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Attr.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Program state: track uninitialized auto-cleanup pointer\
  \ variables by VarDecl*.\nREGISTER_SET_WITH_PROGRAMSTATE(UninitCleanupSet, const\
  \ VarDecl *)\nREGISTER_SET_WITH_PROGRAMSTATE(ReportedSet, const VarDecl *)\n\nnamespace\
  \ {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostStmt<DeclStmt>,\n\
  \        check::Bind,\n        check::PostCall,\n        check::PreStmt<ReturnStmt>,\n\
  \        check::EndFunction> {\n\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n\
  \  SAGenTestChecker() : BT(new BugType(this, \"Auto-cleanup pointer freed uninitialized\"\
  , \"Memory Management\")) {}\n\n  void checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C) const;\n  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const;\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;\n  void checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  static\
  \ bool isLocalAutoPtrWithCleanup(const VarDecl *VD);\n  static bool cleanupIsFreeLike(const\
  \ CleanupAttr *CA);\n  static const FunctionDecl *currentFunctionDecl(CheckerContext\
  \ &C);\n\n  void markInitializedIfTracked(const VarDecl *VD, CheckerContext &C)\
  \ const;\n  void handleOutParamInitialization(const Expr *ArgE, CheckerContext &C)\
  \ const;\n  void reportUninitializedIfAny(CheckerContext &C) const;\n};\n\nbool\
  \ SAGenTestChecker::cleanupIsFreeLike(const CleanupAttr *CA) {\n  if (!CA)\n   \
  \ return false;\n  if (const FunctionDecl *FD = CA->getFunctionDecl()) {\n    StringRef\
  \ Name = FD->getName();\n    if (Name.empty())\n      return true; // be conservative\
  \ if not resolvable\n    // Common free-like functions in the kernel environment\n\
  \    if (Name.equals(\"kfree\") || Name.equals(\"kvfree\") || Name.equals(\"vfree\"\
  ))\n      return true;\n    if (Name.contains_lower(\"free\"))\n      return true;\n\
  \    return false;\n  }\n  // If we cannot resolve the function, be conservative\
  \ and consider it free-like.\n  return true;\n}\n\nbool SAGenTestChecker::isLocalAutoPtrWithCleanup(const\
  \ VarDecl *VD) {\n  if (!VD)\n    return false;\n  if (!VD->hasLocalStorage() ||\
  \ VD->isStaticLocal())\n    return false;\n  QualType QT = VD->getType();\n  if\
  \ (QT.isNull() || !QT->isPointerType())\n    return false;\n  const CleanupAttr\
  \ *CA = VD->getAttr<CleanupAttr>();\n  if (!CA)\n    return false;\n  // We only\
  \ care about cleanup handlers that are likely to free a pointer.\n  if (!cleanupIsFreeLike(CA))\n\
  \    return false;\n  return true;\n}\n\nconst FunctionDecl *SAGenTestChecker::currentFunctionDecl(CheckerContext\
  \ &C) {\n  const LocationContext *LCtx = C.getLocationContext();\n  if (!LCtx)\n\
  \    return nullptr;\n  return dyn_cast<FunctionDecl>(LCtx->getDecl());\n}\n\nvoid\
  \ SAGenTestChecker::markInitializedIfTracked(const VarDecl *VD, CheckerContext &C)\
  \ const {\n  if (!VD)\n    return;\n  ProgramStateRef State = C.getState();\n  if\
  \ (State->contains<UninitCleanupSet>(VD)) {\n    State = State->remove<UninitCleanupSet>(VD);\n\
  \    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  if (!DS)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  bool Changed = false;\n\n  for (const Decl *D : DS->decls())\
  \ {\n    const auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      continue;\n\
  \n    if (!isLocalAutoPtrWithCleanup(VD))\n      continue;\n\n    // If it has an\
  \ initializer, it's already initialized (safe).\n    if (VD->hasInit())\n      continue;\n\
  \n    if (!State->contains<UninitCleanupSet>(VD)) {\n      State = State->add<UninitCleanupSet>(VD);\n\
  \      Changed = true;\n    }\n  }\n\n  if (Changed)\n    C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  const MemRegion *MR = Loc.getAsRegion();\n  if (!MR)\n    return;\n\
  \  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\n  if (const auto *VR =\
  \ dyn_cast<VarRegion>(MR)) {\n    const VarDecl *VD = VR->getDecl();\n    if (!VD)\n\
  \      return;\n    // Any assignment to the variable counts as \"initialized\"\
  .\n    markInitializedIfTracked(VD, C);\n  }\n}\n\nvoid SAGenTestChecker::handleOutParamInitialization(const\
  \ Expr *ArgE, CheckerContext &C) const {\n  if (!ArgE)\n    return;\n\n  ArgE =\
  \ ArgE->IgnoreParenCasts();\n  if (const auto *UO = dyn_cast<UnaryOperator>(ArgE))\
  \ {\n    if (UO->getOpcode() == UO_AddrOf) {\n      const Expr *Sub = UO->getSubExpr()->IgnoreParenCasts();\n\
  \      if (const auto *DRE = dyn_cast<DeclRefExpr>(Sub)) {\n        if (const auto\
  \ *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n          // If this variable is tracked,\
  \ consider it initialized by this call.\n          markInitializedIfTracked(VD,\
  \ C);\n          return;\n        }\n      }\n    }\n  }\n\n  // Fallback via region:\
  \ passing &var results in a region value.\n  ProgramStateRef State = C.getState();\n\
  \  SVal SV = State->getSVal(ArgE, C.getLocationContext());\n  if (const MemRegion\
  \ *MR = SV.getAsRegion()) {\n    MR = MR->getBaseRegion();\n    if (const auto *VR\
  \ = dyn_cast<VarRegion>(MR)) {\n      const VarDecl *VD = VR->getDecl();\n     \
  \ if (VD)\n        markInitializedIfTracked(VD, C);\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // Heuristic: if any argument is\
  \ &var and var is tracked, treat it as initialized post-call.\n  for (unsigned i\
  \ = 0, n = Call.getNumArgs(); i < n; ++i) {\n    const Expr *ArgE = Call.getArgExpr(i);\n\
  \    handleOutParamInitialization(ArgE, C);\n  }\n}\n\nvoid SAGenTestChecker::reportUninitializedIfAny(CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  if (!State)\n    return;\n\
  \n  const FunctionDecl *CurFD = currentFunctionDecl(C);\n  if (!CurFD)\n    return;\n\
  \n  auto USet = State->get<UninitCleanupSet>();\n  if (USet.isEmpty())\n    return;\n\
  \n  for (auto It = USet.begin(); It != USet.end(); ++It) {\n    const VarDecl *VD\
  \ = *It;\n    if (!VD)\n      continue;\n\n    // Only report variables that belong\
  \ to the current function.\n    const auto *OwnerFD = dyn_cast<FunctionDecl>(VD->getDeclContext());\n\
  \    if (OwnerFD != CurFD)\n      continue;\n\n    if (State->contains<ReportedSet>(VD))\n\
  \      continue;\n\n    ProgramStateRef NewState = State->add<ReportedSet>(VD);\n\
  \    ExplodedNode *N = C.generateNonFatalErrorNode(NewState);\n    if (!N)\n   \
  \   continue;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n      \
  \  *BT, \"auto-cleanup pointer may be freed uninitialized; initialize to NULL\"\
  , N);\n    R->addRange(VD->getSourceRange());\n    R->addNote(\"Declare with '=\
  \ NULL' to ensure cleanup handler is safe\", VD->getLocation());\n    C.emitReport(std::move(R));\n\
  \n    // Update local State to include the 'reported' mark for subsequent iterations.\n\
  \    State = NewState;\n  }\n}\n\nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt\
  \ *RS, CheckerContext &C) const {\n  // On any return path, if a tracked variable\
  \ remains uninitialized, report.\n  reportUninitializedIfAny(C);\n}\n\nvoid SAGenTestChecker::checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C) const {\n  // At end of function, report if\
  \ any tracked variable remains uninitialized.\n  reportUninitializedIfAny(C);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects auto-cleanup pointers that may be freed uninitialized; suggest\
  \ initializing to NULL\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nice: Fix freeing uninitialized pointers\n\nAutomatically\
  \ cleaned up pointers need to be initialized before exiting\ntheir scope.  In this\
  \ case, they need to be initialized to NULL before\nany return statement.\n\nFixes:\
  \ 90f821d72e11 (\"ice: avoid unnecessary devm_ usage\")\nSigned-off-by: Dan Carpenter\
  \ <dan.carpenter@linaro.org>\nReviewed-by: Jiri Pirko <jiri@nvidia.com>\nReviewed-by:\
  \ Simon Horman <horms@kernel.org>\nSigned-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>\n\
  \n## Buggy Code\n\n```c\n// Function: ice_loopback_test in drivers/net/ethernet/intel/ice/ice_ethtool.c\n\
  static u64 ice_loopback_test(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv\
  \ *np = netdev_priv(netdev);\n\tstruct ice_vsi *orig_vsi = np->vsi, *test_vsi;\n\
  \tstruct ice_pf *pf = orig_vsi->back;\n\tu8 broadcast[ETH_ALEN], ret = 0;\n\tint\
  \ num_frames, valid_frames;\n\tstruct ice_tx_ring *tx_ring;\n\tstruct ice_rx_ring\
  \ *rx_ring;\n\tu8 *tx_frame __free(kfree);\n\tint i;\n\n\tnetdev_info(netdev, \"\
  loopback test\\n\");\n\n\ttest_vsi = ice_lb_vsi_setup(pf, pf->hw.port_info);\n\t\
  if (!test_vsi) {\n\t\tnetdev_err(netdev, \"Failed to create a VSI for the loopback\
  \ test\\n\");\n\t\treturn 1;\n\t}\n\n\ttest_vsi->netdev = netdev;\n\ttx_ring = test_vsi->tx_rings[0];\n\
  \trx_ring = test_vsi->rx_rings[0];\n\n\tif (ice_lbtest_prepare_rings(test_vsi))\
  \ {\n\t\tret = 2;\n\t\tgoto lbtest_vsi_close;\n\t}\n\n\tif (ice_alloc_rx_bufs(rx_ring,\
  \ rx_ring->count)) {\n\t\tret = 3;\n\t\tgoto lbtest_rings_dis;\n\t}\n\n\t/* Enable\
  \ MAC loopback in firmware */\n\tif (ice_aq_set_mac_loopback(&pf->hw, true, NULL))\
  \ {\n\t\tret = 4;\n\t\tgoto lbtest_mac_dis;\n\t}\n\n\t/* Test VSI needs to receive\
  \ broadcast packets */\n\teth_broadcast_addr(broadcast);\n\tif (ice_fltr_add_mac(test_vsi,\
  \ broadcast, ICE_FWD_TO_VSI)) {\n\t\tret = 5;\n\t\tgoto lbtest_mac_dis;\n\t}\n\n\
  \tif (ice_lbtest_create_frame(pf, &tx_frame, ICE_LB_FRAME_SIZE)) {\n\t\tret = 7;\n\
  \t\tgoto remove_mac_filters;\n\t}\n\n\tnum_frames = min_t(int, tx_ring->count, 32);\n\
  \tfor (i = 0; i < num_frames; i++) {\n\t\tif (ice_diag_send(tx_ring, tx_frame, ICE_LB_FRAME_SIZE))\
  \ {\n\t\t\tret = 8;\n\t\t\tgoto remove_mac_filters;\n\t\t}\n\t}\n\n\tvalid_frames\
  \ = ice_lbtest_receive_frames(rx_ring);\n\tif (!valid_frames)\n\t\tret = 9;\n\t\
  else if (valid_frames != num_frames)\n\t\tret = 10;\n\nremove_mac_filters:\n\tif\
  \ (ice_fltr_remove_mac(test_vsi, broadcast, ICE_FWD_TO_VSI))\n\t\tnetdev_err(netdev,\
  \ \"Could not remove MAC filter for the test VSI\\n\");\nlbtest_mac_dis:\n\t/* Disable\
  \ MAC loopback after the test is completed. */\n\tif (ice_aq_set_mac_loopback(&pf->hw,\
  \ false, NULL))\n\t\tnetdev_err(netdev, \"Could not disable MAC loopback\\n\");\n\
  lbtest_rings_dis:\n\tif (ice_lbtest_disable_rings(test_vsi))\n\t\tnetdev_err(netdev,\
  \ \"Could not disable test rings\\n\");\nlbtest_vsi_close:\n\ttest_vsi->netdev =\
  \ NULL;\n\tif (ice_vsi_release(test_vsi))\n\t\tnetdev_err(netdev, \"Failed to remove\
  \ the test VSI\\n\");\n\n\treturn ret;\n}\n```\n\n```c\n// Function: ice_set_fc\
  \ in drivers/net/ethernet/intel/ice/ice_common.c\nint\nice_set_fc(struct ice_port_info\
  \ *pi, u8 *aq_failures, bool ena_auto_link_update)\n{\n\tstruct ice_aqc_get_phy_caps_data\
  \ *pcaps __free(kfree);\n\tstruct ice_aqc_set_phy_cfg_data cfg = { 0 };\n\tstruct\
  \ ice_hw *hw;\n\tint status;\n\n\tif (!pi || !aq_failures)\n\t\treturn -EINVAL;\n\
  \n\t*aq_failures = 0;\n\thw = pi->hw;\n\n\tpcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);\n\
  \tif (!pcaps)\n\t\treturn -ENOMEM;\n\n\t/* Get the current PHY config */\n\tstatus\
  \ = ice_aq_get_phy_caps(pi, false, ICE_AQC_REPORT_ACTIVE_CFG,\n\t\t\t\t     pcaps,\
  \ NULL);\n\tif (status) {\n\t\t*aq_failures = ICE_SET_FC_AQ_FAIL_GET;\n\t\tgoto\
  \ out;\n\t}\n\n\tice_copy_phy_caps_to_cfg(pi, pcaps, &cfg);\n\n\t/* Configure the\
  \ set PHY data */\n\tstatus = ice_cfg_phy_fc(pi, &cfg, pi->fc.req_mode);\n\tif (status)\n\
  \t\tgoto out;\n\n\t/* If the capabilities have changed, then set the new config\
  \ */\n\tif (cfg.caps != pcaps->caps) {\n\t\tint retry_count, retry_max = 10;\n\n\
  \t\t/* Auto restart link so settings take effect */\n\t\tif (ena_auto_link_update)\n\
  \t\t\tcfg.caps |= ICE_AQ_PHY_ENA_AUTO_LINK_UPDT;\n\n\t\tstatus = ice_aq_set_phy_cfg(hw,\
  \ pi, &cfg, NULL);\n\t\tif (status) {\n\t\t\t*aq_failures = ICE_SET_FC_AQ_FAIL_SET;\n\
  \t\t\tgoto out;\n\t\t}\n\n\t\t/* Update the link info\n\t\t * It sometimes takes\
  \ a really long time for link to\n\t\t * come back from the atomic reset. Thus,\
  \ we wait a\n\t\t * little bit.\n\t\t */\n\t\tfor (retry_count = 0; retry_count\
  \ < retry_max; retry_count++) {\n\t\t\tstatus = ice_update_link_info(pi);\n\n\t\t\
  \tif (!status)\n\t\t\t\tbreak;\n\n\t\t\tmdelay(100);\n\t\t}\n\n\t\tif (status)\n\
  \t\t\t*aq_failures = ICE_SET_FC_AQ_FAIL_UPDATE;\n\t}\n\nout:\n\treturn status;\n\
  }\n```\n\n```c\n// Function: ice_init_hw in drivers/net/ethernet/intel/ice/ice_common.c\n\
  int ice_init_hw(struct ice_hw *hw)\n{\n\tstruct ice_aqc_get_phy_caps_data *pcaps\
  \ __free(kfree);\n\tvoid *mac_buf __free(kfree);\n\tu16 mac_buf_len;\n\tint status;\n\
  \n\t/* Set MAC type based on DeviceID */\n\tstatus = ice_set_mac_type(hw);\n\tif\
  \ (status)\n\t\treturn status;\n\n\thw->pf_id = FIELD_GET(PF_FUNC_RID_FUNC_NUM_M,\
  \ rd32(hw, PF_FUNC_RID));\n\n\tstatus = ice_reset(hw, ICE_RESET_PFR);\n\tif (status)\n\
  \t\treturn status;\n\n\tice_get_itr_intrl_gran(hw);\n\n\tstatus = ice_create_all_ctrlq(hw);\n\
  \tif (status)\n\t\tgoto err_unroll_cqinit;\n\n\tstatus = ice_fwlog_init(hw);\n\t\
  if (status)\n\t\tice_debug(hw, ICE_DBG_FW_LOG, \"Error initializing FW logging:\
  \ %d\\n\",\n\t\t\t  status);\n\n\tstatus = ice_clear_pf_cfg(hw);\n\tif (status)\n\
  \t\tgoto err_unroll_cqinit;\n\n\t/* Set bit to enable Flow Director filters */\n\
  \twr32(hw, PFQF_FD_ENA, PFQF_FD_ENA_FD_ENA_M);\n\tINIT_LIST_HEAD(&hw->fdir_list_head);\n\
  \n\tice_clear_pxe_mode(hw);\n\n\tstatus = ice_init_nvm(hw);\n\tif (status)\n\t\t\
  goto err_unroll_cqinit;\n\n\tstatus = ice_get_caps(hw);\n\tif (status)\n\t\tgoto\
  \ err_unroll_cqinit;\n\n\tif (!hw->port_info)\n\t\thw->port_info = devm_kzalloc(ice_hw_to_dev(hw),\n\
  \t\t\t\t\t     sizeof(*hw->port_info),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!hw->port_info)\
  \ {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_unroll_cqinit;\n\t}\n\n\t/* set the back\
  \ pointer to HW */\n\thw->port_info->hw = hw;\n\n\t/* Initialize port_info struct\
  \ with switch configuration data */\n\tstatus = ice_get_initial_sw_cfg(hw);\n\t\
  if (status)\n\t\tgoto err_unroll_alloc;\n\n\thw->evb_veb = true;\n\n\t/* init xarray\
  \ for identifying scheduling nodes uniquely */\n\txa_init_flags(&hw->port_info->sched_node_ids,\
  \ XA_FLAGS_ALLOC);\n\n\t/* Query the allocated resources for Tx scheduler */\n\t\
  status = ice_sched_query_res_alloc(hw);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_SCHED,\
  \ \"Failed to get scheduler allocated resources\\n\");\n\t\tgoto err_unroll_alloc;\n\
  \t}\n\tice_sched_get_psm_clk_freq(hw);\n\n\t/* Initialize port_info struct with\
  \ scheduler data */\n\tstatus = ice_sched_init_port(hw->port_info);\n\tif (status)\n\
  \t\tgoto err_unroll_sched;\n\n\tpcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);\n\t\
  if (!pcaps) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_unroll_sched;\n\t}\n\n\t/* Initialize\
  \ port_info struct with PHY capabilities */\n\tstatus = ice_aq_get_phy_caps(hw->port_info,\
  \ false,\n\t\t\t\t     ICE_AQC_REPORT_TOPO_CAP_MEDIA, pcaps,\n\t\t\t\t     NULL);\n\
  \tif (status)\n\t\tdev_warn(ice_hw_to_dev(hw), \"Get PHY capabilities failed status\
  \ = %d, continuing anyway\\n\",\n\t\t\t status);\n\n\t/* Initialize port_info struct\
  \ with link information */\n\tstatus = ice_aq_get_link_info(hw->port_info, false,\
  \ NULL, NULL);\n\tif (status)\n\t\tgoto err_unroll_sched;\n\n\t/* need a valid SW\
  \ entry point to build a Tx tree */\n\tif (!hw->sw_entry_point_layer) {\n\t\tice_debug(hw,\
  \ ICE_DBG_SCHED, \"invalid sw entry point\\n\");\n\t\tstatus = -EIO;\n\t\tgoto err_unroll_sched;\n\
  \t}\n\tINIT_LIST_HEAD(&hw->agg_list);\n\t/* Initialize max burst size */\n\tif (!hw->max_burst_size)\n\
  \t\tice_cfg_rl_burst_size(hw, ICE_SCHED_DFLT_BURST_SIZE);\n\n\tstatus = ice_init_fltr_mgmt_struct(hw);\n\
  \tif (status)\n\t\tgoto err_unroll_sched;\n\n\t/* Get MAC information */\n\t/* A\
  \ single port can report up to two (LAN and WoL) addresses */\n\tmac_buf = kcalloc(2,\
  \ sizeof(struct ice_aqc_manage_mac_read_resp),\n\t\t\t  GFP_KERNEL);\n\tif (!mac_buf)\
  \ {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_unroll_fltr_mgmt_struct;\n\t}\n\n\tmac_buf_len\
  \ = 2 * sizeof(struct ice_aqc_manage_mac_read_resp);\n\tstatus = ice_aq_manage_mac_read(hw,\
  \ mac_buf, mac_buf_len, NULL);\n\n\tif (status)\n\t\tgoto err_unroll_fltr_mgmt_struct;\n\
  \t/* enable jumbo frame support at MAC level */\n\tstatus = ice_aq_set_mac_cfg(hw,\
  \ ICE_AQ_SET_MAC_FRAME_SIZE_MAX, NULL);\n\tif (status)\n\t\tgoto err_unroll_fltr_mgmt_struct;\n\
  \t/* Obtain counter base index which would be used by flow director */\n\tstatus\
  \ = ice_alloc_fd_res_cntr(hw, &hw->fd_ctr_base);\n\tif (status)\n\t\tgoto err_unroll_fltr_mgmt_struct;\n\
  \tstatus = ice_init_hw_tbls(hw);\n\tif (status)\n\t\tgoto err_unroll_fltr_mgmt_struct;\n\
  \tmutex_init(&hw->tnl_lock);\n\treturn 0;\n\nerr_unroll_fltr_mgmt_struct:\n\tice_cleanup_fltr_mgmt_struct(hw);\n\
  err_unroll_sched:\n\tice_sched_cleanup_all(hw);\nerr_unroll_alloc:\n\tdevm_kfree(ice_hw_to_dev(hw),\
  \ hw->port_info);\nerr_unroll_cqinit:\n\tice_destroy_all_ctrlq(hw);\n\treturn status;\n\
  }\n```\n\n```c\n// Function: ice_update_link_info in drivers/net/ethernet/intel/ice/ice_common.c\n\
  int ice_update_link_info(struct ice_port_info *pi)\n{\n\tstruct ice_link_status\
  \ *li;\n\tint status;\n\n\tif (!pi)\n\t\treturn -EINVAL;\n\n\tli = &pi->phy.link_info;\n\
  \n\tstatus = ice_aq_get_link_info(pi, true, NULL, NULL);\n\tif (status)\n\t\treturn\
  \ status;\n\n\tif (li->link_info & ICE_AQ_MEDIA_AVAILABLE) {\n\t\tstruct ice_aqc_get_phy_caps_data\
  \ *pcaps __free(kfree);\n\n\t\tpcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);\n\t\t\
  if (!pcaps)\n\t\t\treturn -ENOMEM;\n\n\t\tstatus = ice_aq_get_phy_caps(pi, false,\
  \ ICE_AQC_REPORT_TOPO_CAP_MEDIA,\n\t\t\t\t\t     pcaps, NULL);\n\t}\n\n\treturn\
  \ status;\n}\n```\n\n```c\n// Function: ice_cfg_phy_fec in drivers/net/ethernet/intel/ice/ice_common.c\n\
  int\nice_cfg_phy_fec(struct ice_port_info *pi, struct ice_aqc_set_phy_cfg_data *cfg,\n\
  \t\tenum ice_fec_mode fec)\n{\n\tstruct ice_aqc_get_phy_caps_data *pcaps __free(kfree);\n\
  \tstruct ice_hw *hw;\n\tint status;\n\n\tif (!pi || !cfg)\n\t\treturn -EINVAL;\n\
  \n\thw = pi->hw;\n\n\tpcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);\n\tif (!pcaps)\n\
  \t\treturn -ENOMEM;\n\n\tstatus = ice_aq_get_phy_caps(pi, false,\n\t\t\t\t     (ice_fw_supports_report_dflt_cfg(hw)\
  \ ?\n\t\t\t\t      ICE_AQC_REPORT_DFLT_CFG :\n\t\t\t\t      ICE_AQC_REPORT_TOPO_CAP_MEDIA),\
  \ pcaps, NULL);\n\tif (status)\n\t\tgoto out;\n\n\tcfg->caps |= pcaps->caps & ICE_AQC_PHY_EN_AUTO_FEC;\n\
  \tcfg->link_fec_opt = pcaps->link_fec_options;\n\n\tswitch (fec) {\n\tcase ICE_FEC_BASER:\n\
  \t\t/* Clear RS bits, and AND BASE-R ability\n\t\t * bits and OR request bits.\n\
  \t\t */\n\t\tcfg->link_fec_opt &= ICE_AQC_PHY_FEC_10G_KR_40G_KR4_EN |\n\t\t\tICE_AQC_PHY_FEC_25G_KR_CLAUSE74_EN;\n\
  \t\tcfg->link_fec_opt |= ICE_AQC_PHY_FEC_10G_KR_40G_KR4_REQ |\n\t\t\tICE_AQC_PHY_FEC_25G_KR_REQ;\n\
  \t\tbreak;\n\tcase ICE_FEC_RS:\n\t\t/* Clear BASE-R bits, and AND RS ability\n\t\
  \t * bits and OR request bits.\n\t\t */\n\t\tcfg->link_fec_opt &= ICE_AQC_PHY_FEC_25G_RS_CLAUSE91_EN;\n\
  \t\tcfg->link_fec_opt |= ICE_AQC_PHY_FEC_25G_RS_528_REQ |\n\t\t\tICE_AQC_PHY_FEC_25G_RS_544_REQ;\n\
  \t\tbreak;\n\tcase ICE_FEC_NONE:\n\t\t/* Clear all FEC option bits. */\n\t\tcfg->link_fec_opt\
  \ &= ~ICE_AQC_PHY_FEC_MASK;\n\t\tbreak;\n\tcase ICE_FEC_AUTO:\n\t\t/* AND auto FEC\
  \ bit, and all caps bits. */\n\t\tcfg->caps &= ICE_AQC_PHY_CAPS_MASK;\n\t\tcfg->link_fec_opt\
  \ |= pcaps->link_fec_options;\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\
  \tbreak;\n\t}\n\n\tif (fec == ICE_FEC_AUTO && ice_fw_supports_link_override(hw)\
  \ &&\n\t    !ice_fw_supports_report_dflt_cfg(hw)) {\n\t\tstruct ice_link_default_override_tlv\
  \ tlv = { 0 };\n\n\t\tstatus = ice_get_link_default_override(&tlv, pi);\n\t\tif\
  \ (status)\n\t\t\tgoto out;\n\n\t\tif (!(tlv.options & ICE_LINK_OVERRIDE_STRICT_MODE)\
  \ &&\n\t\t    (tlv.options & ICE_LINK_OVERRIDE_EN))\n\t\t\tcfg->link_fec_opt = tlv.fec_options;\n\
  \t}\n\nout:\n\treturn status;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git\
  \ a/drivers/net/ethernet/intel/ice/ice_common.c b/drivers/net/ethernet/intel/ice/ice_common.c\n\
  index db4b2844e1f7..d9f6cc71d900 100644\n--- a/drivers/net/ethernet/intel/ice/ice_common.c\n\
  +++ b/drivers/net/ethernet/intel/ice/ice_common.c\n@@ -1002,8 +1002,8 @@ static\
  \ void ice_get_itr_intrl_gran(struct ice_hw *hw)\n  */\n int ice_init_hw(struct\
  \ ice_hw *hw)\n {\n-\tstruct ice_aqc_get_phy_caps_data *pcaps __free(kfree);\n-\t\
  void *mac_buf __free(kfree);\n+\tstruct ice_aqc_get_phy_caps_data *pcaps __free(kfree)\
  \ = NULL;\n+\tvoid *mac_buf __free(kfree) = NULL;\n \tu16 mac_buf_len;\n \tint status;\n\
  \ \n@@ -3272,7 +3272,7 @@ int ice_update_link_info(struct ice_port_info *pi)\n \t\
  \treturn status;\n \n \tif (li->link_info & ICE_AQ_MEDIA_AVAILABLE) {\n-\t\tstruct\
  \ ice_aqc_get_phy_caps_data *pcaps __free(kfree);\n+\t\tstruct ice_aqc_get_phy_caps_data\
  \ *pcaps __free(kfree) = NULL;\n \n \t\tpcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);\n\
  \ \t\tif (!pcaps)\n@@ -3420,7 +3420,7 @@ ice_cfg_phy_fc(struct ice_port_info *pi,\
  \ struct ice_aqc_set_phy_cfg_data *cfg,\n int\n ice_set_fc(struct ice_port_info\
  \ *pi, u8 *aq_failures, bool ena_auto_link_update)\n {\n-\tstruct ice_aqc_get_phy_caps_data\
  \ *pcaps __free(kfree);\n+\tstruct ice_aqc_get_phy_caps_data *pcaps __free(kfree)\
  \ = NULL;\n \tstruct ice_aqc_set_phy_cfg_data cfg = { 0 };\n \tstruct ice_hw *hw;\n\
  \ \tint status;\n@@ -3561,7 +3561,7 @@ int\n ice_cfg_phy_fec(struct ice_port_info\
  \ *pi, struct ice_aqc_set_phy_cfg_data *cfg,\n \t\tenum ice_fec_mode fec)\n {\n\
  -\tstruct ice_aqc_get_phy_caps_data *pcaps __free(kfree);\n+\tstruct ice_aqc_get_phy_caps_data\
  \ *pcaps __free(kfree) = NULL;\n \tstruct ice_hw *hw;\n \tint status;\n \ndiff --git\
  \ a/drivers/net/ethernet/intel/ice/ice_ethtool.c b/drivers/net/ethernet/intel/ice/ice_ethtool.c\n\
  index 255a9c8151b4..78b833b3e1d7 100644\n--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c\n\
  +++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c\n@@ -941,11 +941,11 @@ static\
  \ u64 ice_loopback_test(struct net_device *netdev)\n \tstruct ice_netdev_priv *np\
  \ = netdev_priv(netdev);\n \tstruct ice_vsi *orig_vsi = np->vsi, *test_vsi;\n \t\
  struct ice_pf *pf = orig_vsi->back;\n+\tu8 *tx_frame __free(kfree) = NULL;\n \t\
  u8 broadcast[ETH_ALEN], ret = 0;\n \tint num_frames, valid_frames;\n \tstruct ice_tx_ring\
  \ *tx_ring;\n \tstruct ice_rx_ring *rx_ring;\n-\tu8 *tx_frame __free(kfree);\n \t\
  int i;\n \n \tnetdev_info(netdev, \"loopback test\\n\");\n```\n"
pattern: "## Bug Pattern\n\nDeclaring auto-cleanup pointers (annotated with __free(kfree))\
  \ without initializing them to NULL, and then returning or leaving scope before\
  \ assigning them a valid value. This causes the cleanup handler to call kfree()\
  \ on an uninitialized/garbage pointer at scope exit.\n\nExample pattern:\nstruct\
  \ foo *p __free(kfree);  // not initialized\nif (error)\n    return -EINVAL;   \
  \        // cleanup runs: kfree(p) on uninitialized value\n\nFix: Always initialize\
  \ such auto-cleanup pointers to NULL at declaration."
plan: "Plan\n\n1. Program state\n- Define a path-sensitive set to track auto-cleanup\
  \ pointers that are currently uninitialized.\n  - REGISTER_SET_WITH_PROGRAMSTATE(UninitCleanupSet,\
  \ const VarDecl *)\n- (Optional) To avoid duplicate reports on the same path, you\
  \ can keep a reported set:\n  - REGISTER_SET_WITH_PROGRAMSTATE(ReportedSet, const\
  \ VarDecl *)\n\n2. What to detect\n- Local automatic variables of pointer type annotated\
  \ with a cleanup attribute (i.e., Linux __free(...), which maps to GCC/Clang CleanupAttr).\n\
  - If such a variable has no initializer at its declaration, treat it as \u201Cuninitialized.\u201D\
  \n- The bug is present on any path that exits the variable\u2019s scope (e.g., a\
  \ return, or end-of-function) before that variable is assigned, because the cleanup\
  \ will call kfree (or similar) on an indeterminate value.\n\n3. Callbacks and implementation\
  \ details\n\nA) checkPostStmt(const DeclStmt *DS, CheckerContext &C)\n- Purpose:\
  \ Seed the UninitCleanupSet.\n- For each VarDecl V in DS:\n  - Only consider local,\
  \ automatic storage variables:\n    - V->hasLocalStorage() and !V->isStaticLocal()\n\
  \  - Ensure the type is a pointer: V->getType()->isPointerType()\n  - Check if the\
  \ variable has a cleanup attribute:\n    - V->hasAttr<CleanupAttr>()\n    - Optionally\
  \ restrict to deallocation-like cleanup by attempting to read the CleanupAttr\u2019\
  s function name and check it contains \u201Cfree\u201D or equals \u201Ckfree\u201D\
  . If not obtainable portably, skip this restriction and apply to all CleanupAttr\
  \ pointers.\n  - If V has an initializer (V->hasInit()):\n    - Consider it \u201C\
  initialized\u201D and do nothing (even if it\u2019s not NULL; it\u2019s at least\
  \ defined).\n  - Else:\n    - Add V to UninitCleanupSet.\n- Rationale: We only warn\
  \ if a path can exit before any assignment; simply having an initializer avoids\
  \ the bug entirely.\n\nB) checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C)\n- Purpose: Mark the pointer as initialized once it is assigned.\n- If Loc\
  \ is a region binding to a VarRegion VR:\n  - Retrieve const VarDecl *V = VR->getDecl()\n\
  \  - If V is in UninitCleanupSet, remove it (the variable now has a defined value).\n\
  - This catches direct assignments like p = kzalloc(...), p = NULL, p = other_ptr,\
  \ etc.\n\nC) checkPostCall(const CallEvent &Call, CheckerContext &C)\n- Purpose:\
  \ Handle common \u201Cout-parameter\u201D initialization via passing &ptr.\n- For\
  \ each argument Arg of Call:\n  - If Arg is a UnaryOperator with kind UO_AddrOf\
  \ whose subexpression is a DeclRefExpr to a VarDecl V:\n    - If V is in UninitCleanupSet,\
  \ remove it.\n- This heuristic prevents false positives for the common kernel pattern\
  \ where functions initialize pointers via out-parameters (e.g., ice_lbtest_create_frame(pf,\
  \ &tx_frame, ...)). Without this, the variable would incorrectly remain \u201Cuninitialized\u201D\
  \ after the call.\n\nD) checkPreStmt(const ReturnStmt *RS, CheckerContext &C)\n\
  - Purpose: Report when a path returns while a tracked variable is still uninitialized.\n\
  - Lookup UninitCleanupSet from state. For each VarDecl V in the set:\n  - Emit a\
  \ bug report:\n    - Title: \u201CAuto-cleanup pointer may be freed uninitialized\u201D\
  \n    - Message: \u201CInitialize to NULL at declaration; cleanup will free an uninitialized\
  \ pointer on scope exit\u201D\n    - Location: V->getLocation() (the declaration\
  \ site is the actionable location)\n  - Optionally: Add V to ReportedSet in state\
  \ to avoid duplicate reports on the same path.\n- Note: This reports early-returns\
  \ that occur before the pointer is ever assigned.\n\nE) checkEndFunction(const ReturnStmt\
  \ *RS, CheckerContext &C)\n- Purpose: Report when function exits normally (or by\
  \ goto to a final return) and some variable remains uninitialized.\n- Same as checkPreStmt(ReturnStmt),\
  \ iterate UninitCleanupSet and report.\n- This covers cases with gotos to an epilogue\
  \ and fall-through returns.\n\n4. Heuristics and filters\n- Restrict to pointer\
  \ types with CleanupAttr.\n- Optionally narrow to cleanup functions that are known\
  \ to free memory (e.g., \u201Ckfree\u201D), if CleanupAttr exposes the callee name.\
  \ If not, checking any CleanupAttr pointer is still reasonable because passing indeterminate\
  \ pointer to a cleanup is generally unsafe.\n- Consider any initializer at declaration\
  \ as \u201Cinitialized\u201D (including NULL, 0, or other expressions). The bug\
  \ is about uninitialized cleanup pointers; a non-NULL initializer is defined, so\
  \ no UB on cleanup.\n- Do not attempt alias tracking beyond direct assignment to\
  \ the variable name and out-param write via &var. This keeps the checker simple\
  \ and effective for the kernel style used in the target patch.\n\n5. Reporting\n\
  - Use generateNonFatalErrorNode() to create the node.\n- Use std::make_unique<PathSensitiveBugReport>\
  \ with a short message.\n- Tie the primary location to the VarDecl to guide the\
  \ fix (add \u201C= NULL\u201D).\n- Message example: \u201Cauto-cleanup pointer may\
  \ be freed uninitialized; initialize to NULL\u201D\n\n6. Why this catches the target\
  \ pattern\n- In the buggy code, variables like \u201Cpcaps __free(kfree);\u201D\
  \ or \u201Cu8 *tx_frame __free(kfree);\u201D are declared without initializers.\n\
  - Many error returns or gotos occur before the first assignment (e.g., before kzalloc\
  \ or before the out-param initialization call).\n- The checker seeds these variables\
  \ as uninitialized on declaration and removes them once assigned (via direct assignment\
  \ or &var calls).\n- Any return prior to assignment triggers a warning, matching\
  \ the patch\u2019s rationale to initialize them to NULL at declaration."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/Attr.h\"\
  \n#include \"clang/Analysis/PathDiagnostic.h\"\n#include <string>\n#include <memory>\n\
  \nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program\
  \ state: track uninitialized auto-cleanup pointer variables by VarDecl*.\nREGISTER_SET_WITH_PROGRAMSTATE(UninitCleanupSet,\
  \ const VarDecl *)\nREGISTER_SET_WITH_PROGRAMSTATE(ReportedSet, const VarDecl *)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostStmt<DeclStmt>,\n\
  \        check::Bind,\n        check::PostCall,\n        check::PreStmt<ReturnStmt>,\n\
  \        check::EndFunction> {\n\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n\
  \  SAGenTestChecker() : BT(new BugType(this, \"Auto-cleanup pointer freed uninitialized\"\
  , \"Memory Management\")) {}\n\n  void checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C) const;\n  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const;\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;\n  void checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  static\
  \ bool isLocalAutoPtrWithCleanup(const VarDecl *VD);\n  static bool cleanupIsFreeLike(const\
  \ CleanupAttr *CA);\n  static const FunctionDecl *currentFunctionDecl(CheckerContext\
  \ &C);\n\n  void markInitializedIfTracked(const VarDecl *VD, CheckerContext &C)\
  \ const;\n  void handleOutParamInitialization(const Expr *ArgE, CheckerContext &C)\
  \ const;\n  void reportUninitializedIfAny(CheckerContext &C) const;\n};\n\nbool\
  \ SAGenTestChecker::cleanupIsFreeLike(const CleanupAttr *CA) {\n  if (!CA)\n   \
  \ return false;\n  if (const FunctionDecl *FD = CA->getFunctionDecl()) {\n    StringRef\
  \ Name = FD->getName();\n    if (Name.empty())\n      return true; // be conservative\
  \ if not resolvable\n    // Common free-like functions in the kernel environment\n\
  \    if (Name.equals(\"kfree\") || Name.equals(\"kvfree\") || Name.equals(\"vfree\"\
  ))\n      return true;\n    // Case-insensitive substring check for \"free\".\n\
  \    std::string Lower = std::string(Name.lower());\n    if (Lower.find(\"free\"\
  ) != std::string::npos)\n      return true;\n    return false;\n  }\n  // If we\
  \ cannot resolve the function, be conservative and consider it free-like.\n  return\
  \ true;\n}\n\nbool SAGenTestChecker::isLocalAutoPtrWithCleanup(const VarDecl *VD)\
  \ {\n  if (!VD)\n    return false;\n  if (!VD->hasLocalStorage() || VD->isStaticLocal())\n\
  \    return false;\n  QualType QT = VD->getType();\n  if (QT.isNull() || !QT->isPointerType())\n\
  \    return false;\n  const CleanupAttr *CA = VD->getAttr<CleanupAttr>();\n  if\
  \ (!CA)\n    return false;\n  // We only care about cleanup handlers that are likely\
  \ to free a pointer.\n  if (!cleanupIsFreeLike(CA))\n    return false;\n  return\
  \ true;\n}\n\nconst FunctionDecl *SAGenTestChecker::currentFunctionDecl(CheckerContext\
  \ &C) {\n  const LocationContext *LCtx = C.getLocationContext();\n  if (!LCtx)\n\
  \    return nullptr;\n  return dyn_cast<FunctionDecl>(LCtx->getDecl());\n}\n\nvoid\
  \ SAGenTestChecker::markInitializedIfTracked(const VarDecl *VD, CheckerContext &C)\
  \ const {\n  if (!VD)\n    return;\n  ProgramStateRef State = C.getState();\n  if\
  \ (State->contains<UninitCleanupSet>(VD)) {\n    State = State->remove<UninitCleanupSet>(VD);\n\
  \    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  if (!DS)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  bool Changed = false;\n\n  for (const Decl *D : DS->decls())\
  \ {\n    const auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      continue;\n\
  \n    if (!isLocalAutoPtrWithCleanup(VD))\n      continue;\n\n    // If it has an\
  \ initializer, it's already initialized (safe).\n    if (VD->hasInit())\n      continue;\n\
  \n    if (!State->contains<UninitCleanupSet>(VD)) {\n      State = State->add<UninitCleanupSet>(VD);\n\
  \      Changed = true;\n    }\n  }\n\n  if (Changed)\n    C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  const MemRegion *MR = Loc.getAsRegion();\n  if (!MR)\n    return;\n\
  \  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\n  if (const auto *VR =\
  \ dyn_cast<VarRegion>(MR)) {\n    const VarDecl *VD = VR->getDecl();\n    if (!VD)\n\
  \      return;\n    // Any assignment to the variable counts as \"initialized\"\
  .\n    markInitializedIfTracked(VD, C);\n  }\n}\n\nvoid SAGenTestChecker::handleOutParamInitialization(const\
  \ Expr *ArgE, CheckerContext &C) const {\n  if (!ArgE)\n    return;\n\n  ArgE =\
  \ ArgE->IgnoreParenCasts();\n  if (const auto *UO = dyn_cast<UnaryOperator>(ArgE))\
  \ {\n    if (UO->getOpcode() == UO_AddrOf) {\n      const Expr *Sub = UO->getSubExpr()->IgnoreParenCasts();\n\
  \      if (const auto *DRE = dyn_cast<DeclRefExpr>(Sub)) {\n        if (const auto\
  \ *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n          // If this variable is tracked,\
  \ consider it initialized by this call.\n          markInitializedIfTracked(VD,\
  \ C);\n          return;\n        }\n      }\n    }\n  }\n\n  // Fallback via region:\
  \ passing &var results in a region value.\n  ProgramStateRef State = C.getState();\n\
  \  SVal SV = State->getSVal(ArgE, C.getLocationContext());\n  if (const MemRegion\
  \ *MR = SV.getAsRegion()) {\n    MR = MR->getBaseRegion();\n    if (const auto *VR\
  \ = dyn_cast<VarRegion>(MR)) {\n      const VarDecl *VD = VR->getDecl();\n     \
  \ if (VD)\n        markInitializedIfTracked(VD, C);\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // Heuristic: if any argument is\
  \ &var and var is tracked, treat it as initialized post-call.\n  for (unsigned i\
  \ = 0, n = Call.getNumArgs(); i < n; ++i) {\n    const Expr *ArgE = Call.getArgExpr(i);\n\
  \    handleOutParamInitialization(ArgE, C);\n  }\n}\n\nvoid SAGenTestChecker::reportUninitializedIfAny(CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  if (!State)\n    return;\n\
  \n  const FunctionDecl *CurFD = currentFunctionDecl(C);\n  if (!CurFD)\n    return;\n\
  \n  auto USet = State->get<UninitCleanupSet>();\n  if (USet.isEmpty())\n    return;\n\
  \n  for (auto It = USet.begin(); It != USet.end(); ++It) {\n    const VarDecl *VD\
  \ = *It;\n    if (!VD)\n      continue;\n\n    // Only report variables that belong\
  \ to the current function.\n    const auto *OwnerFD = dyn_cast<FunctionDecl>(VD->getDeclContext());\n\
  \    if (OwnerFD != CurFD)\n      continue;\n\n    if (State->contains<ReportedSet>(VD))\n\
  \      continue;\n\n    ProgramStateRef NewState = State->add<ReportedSet>(VD);\n\
  \    ExplodedNode *N = C.generateNonFatalErrorNode(NewState);\n    if (!N)\n   \
  \   continue;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n      \
  \  *BT, \"auto-cleanup pointer may be freed uninitialized; initialize to NULL\"\
  , N);\n    R->addRange(VD->getSourceRange());\n    PathDiagnosticLocation L = PathDiagnosticLocation::createBegin(VD,\
  \ C.getASTContext().getSourceManager());\n    R->addNote(\"Declare with '= NULL'\
  \ to ensure cleanup handler is safe\", L);\n    C.emitReport(std::move(R));\n\n\
  \    // Update local State to include the 'reported' mark for subsequent iterations.\n\
  \    State = NewState;\n  }\n}\n\nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt\
  \ *RS, CheckerContext &C) const {\n  // On any return path, if a tracked variable\
  \ remains uninitialized, report.\n  reportUninitializedIfAny(C);\n}\n\nvoid SAGenTestChecker::checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C) const {\n  // At end of function, report if\
  \ any tracked variable remains uninitialized.\n  reportUninitializedIfAny(C);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects auto-cleanup pointers that may be freed uninitialized; suggest\
  \ initializing to NULL\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 2
tp_score: 2
