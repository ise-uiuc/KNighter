_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3f7d9c1964fcd16d02a8a9d4fd6f6cb60c4cc530
commit_type: Out-of-Bound
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Basic/SourceManager.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// Track device-provided length regions and whether\
  \ they are validated.\nREGISTER_MAP_WITH_PROGRAMSTATE(DeviceLenMap, const MemRegion*,\
  \ bool)\n\nnamespace {\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n\
  \        check::PreCall,\n        check::BranchCondition,\n        check::Bind>\
  \ {\n\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unvalidated device length\", \"Memory Safety\")) {}\n\
  \n      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n  \
  \    void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n      void\
  \ checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n      void\
  \ checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\n   private:\n\
  \      // Helpers\n      static bool isVirtioCreadScalar(const CallEvent &Call,\
  \ CheckerContext &C);\n      static bool isRelevantOffsetExpr(const Expr *E, CheckerContext\
  \ &C);\n      static const MemRegion* getBaseRegionFromExpr(const Expr *E, CheckerContext\
  \ &C);\n\n      static bool isMemCopyLike(const CallEvent &Call, unsigned &SizeIdx,\
  \ unsigned &BufIdx, CheckerContext &C);\n      static bool tryGetArraySizeForBufferArg(const\
  \ Expr *BufExpr, CheckerContext &C, llvm::APInt &ArraySize);\n\n      static bool\
  \ exprHasRSSMaxMacro(const Expr *E, CheckerContext &C);\n\n      void markLenValidatedOnBranch(const\
  \ BinaryOperator *BO, CheckerContext &C) const;\n      void reportUnvalidatedUse(const\
  \ CallEvent &Call, CheckerContext &C) const;\n};\n\nstatic const MemRegion* getTrackedRegionFromState(ProgramStateRef\
  \ State, const MemRegion *MR) {\n  if (!MR) return nullptr;\n  MR = MR->getBaseRegion();\n\
  \  if (!MR) return nullptr;\n  const bool *Val = State->get<DeviceLenMap>(MR);\n\
  \  return Val ? MR : nullptr;\n}\n\nbool SAGenTestChecker::isVirtioCreadScalar(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin) return false;\n\n  // Use ExprHasName for robustness\n  if (ExprHasName(Origin,\
  \ \"virtio_cread8\", C)) return true;\n  if (ExprHasName(Origin, \"virtio_cread16\"\
  , C)) return true;\n  if (ExprHasName(Origin, \"virtio_cread32\", C)) return true;\n\
  \  return false;\n}\n\nbool SAGenTestChecker::isRelevantOffsetExpr(const Expr *E,\
  \ CheckerContext &C) {\n  if (!E) return false;\n  // We only care about reading\
  \ rss_max_key_size or hash_key_length offsets\n  if (ExprHasName(E, \"rss_max_key_size\"\
  , C)) return true;\n  if (ExprHasName(E, \"hash_key_length\", C)) return true;\n\
  \  return false;\n}\n\nconst MemRegion* SAGenTestChecker::getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) {\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR) return nullptr;\n  MR = MR->getBaseRegion();\n  return MR;\n}\n\
  \nbool SAGenTestChecker::isMemCopyLike(const CallEvent &Call, unsigned &SizeIdx,\
  \ unsigned &BufIdx, CheckerContext &C) {\n  SizeIdx = BufIdx = (unsigned)-1;\n \
  \ const Expr *Origin = Call.getOriginExpr();\n  if (!Origin) return false;\n\n \
  \ // memcpy(dst, src, len)\n  if (ExprHasName(Origin, \"memcpy\", C)) {\n    if\
  \ (Call.getNumArgs() >= 3) {\n      BufIdx = 0; SizeIdx = 2; return true;\n    }\n\
  \  }\n  // memmove(dst, src, len)\n  if (ExprHasName(Origin, \"memmove\", C)) {\n\
  \    if (Call.getNumArgs() >= 3) {\n      BufIdx = 0; SizeIdx = 2; return true;\n\
  \    }\n  }\n  // virtio_cread_bytes(dev, off, buf, len)\n  if (ExprHasName(Origin,\
  \ \"virtio_cread_bytes\", C)) {\n    if (Call.getNumArgs() >= 4) {\n      BufIdx\
  \ = 2; SizeIdx = 3; return true;\n    }\n  }\n  // virtio_cwrite_bytes(dev, off,\
  \ buf, len)\n  if (ExprHasName(Origin, \"virtio_cwrite_bytes\", C)) {\n    if (Call.getNumArgs()\
  \ >= 4) {\n      BufIdx = 2; SizeIdx = 3; return true;\n    }\n  }\n  // sg_init_one(sg,\
  \ buf, len)\n  if (ExprHasName(Origin, \"sg_init_one\", C)) {\n    if (Call.getNumArgs()\
  \ >= 3) {\n      BufIdx = 1; SizeIdx = 2; return true;\n    }\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::tryGetArraySizeForBufferArg(const Expr *BufExpr, CheckerContext\
  \ &C, llvm::APInt &ArraySize) {\n  if (!BufExpr) return false;\n\n  // Try directly\n\
  \  if (getArraySizeFromExpr(ArraySize, BufExpr))\n    return true;\n\n  // Try to\
  \ find a DeclRefExpr child\n  if (const auto *DRE = findSpecificTypeInChildren<DeclRefExpr>(BufExpr))\
  \ {\n    if (getArraySizeFromExpr(ArraySize, DRE))\n      return true;\n  }\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::exprHasRSSMaxMacro(const Expr *E, CheckerContext\
  \ &C) {\n  if (!E) return false;\n  return ExprHasName(E, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C);\n}\n\n// Step A: Mark device-provided size as unvalidated after virtio_cread8/16/32\
  \ for rss_max_key_size/hash_key_length\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isVirtioCreadScalar(Call,\
  \ C))\n    return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n  const Expr\
  \ *OffsetExpr = Call.getArgExpr(1);\n  if (!isRelevantOffsetExpr(OffsetExpr, C))\n\
  \    return;\n\n  // Find assignment of the call result: LHS = virtio_creadX(...)\n\
  \  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin) return;\n\n  const\
  \ BinaryOperator *BO = findSpecificTypeInParents<BinaryOperator>(Origin, C);\n \
  \ if (!BO || !BO->isAssignmentOp())\n    return;\n\n  const Expr *LHS = BO->getLHS();\n\
  \  if (!LHS) return;\n\n  const MemRegion *LHSMR = getBaseRegionFromExpr(LHS, C);\n\
  \  if (!LHSMR) return;\n\n  ProgramStateRef State = C.getState();\n  State = State->set<DeviceLenMap>(LHSMR,\
  \ /*Validated=*/false);\n  C.addTransition(State);\n}\n\n// Step B: Recognize validation\
  \ branches and mark as validated on safe branch\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!Condition) return;\n\n  const\
  \ Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE) return;\n\n  // Strip\
  \ parens/casts\n  CondE = CondE->IgnoreParenCasts();\n\n  const BinaryOperator *BO\
  \ = dyn_cast<BinaryOperator>(CondE);\n  if (!BO) {\n    // Try find a binary operator\
  \ in children if directly not available\n    BO = findSpecificTypeInChildren<BinaryOperator>(Condition);\n\
  \  }\n  if (!BO) return;\n\n  // Only consider comparison operators\n  BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n  switch (Op) {\n  case BO_LT: case BO_LE: case BO_GT:\
  \ case BO_GE:\n    break;\n  default:\n    return;\n  }\n\n  ProgramStateRef State\
  \ = C.getState();\n\n  const Expr *LHS = BO->getLHS();\n  const Expr *RHS = BO->getRHS();\n\
  \  if (!LHS || !RHS) return;\n\n  const MemRegion *LHSReg = getBaseRegionFromExpr(LHS,\
  \ C);\n  const MemRegion *RHSReg = getBaseRegionFromExpr(RHS, C);\n\n  const bool\
  \ *LHSTrackedVal = LHSReg ? State->get<DeviceLenMap>(LHSReg) : nullptr;\n  const\
  \ bool *RHSTrackedVal = RHSReg ? State->get<DeviceLenMap>(RHSReg) : nullptr;\n\n\
  \  bool RHSHasMax = exprHasRSSMaxMacro(RHS, C);\n  bool LHSHasMax = exprHasRSSMaxMacro(LHS,\
  \ C);\n\n  const MemRegion *SizeReg = nullptr;\n  bool SafeOnTrue = false;\n  bool\
  \ Matched = false;\n\n  // Case 1: size (tracked) on LHS, macro on RHS\n  if (LHSTrackedVal\
  \ && RHSHasMax) {\n    SizeReg = LHSReg;\n    Matched = true;\n    // size < = MAX\
  \  -> True branch safe\n    // size < MAX     -> True branch safe\n    // size >\
  \ = MAX   -> False branch safe\n    // size > MAX     -> False branch safe\n   \
  \ if (Op == BO_LT || Op == BO_LE)\n      SafeOnTrue = true;\n    else if (Op ==\
  \ BO_GT || Op == BO_GE)\n      SafeOnTrue = false;\n  }\n\n  // Case 2: macro on\
  \ LHS, size (tracked) on RHS\n  if (!Matched && RHSTrackedVal && LHSHasMax) {\n\
  \    SizeReg = RHSReg;\n    Matched = true;\n    // MAX > size  -> True branch safe\n\
  \    // MAX >= size -> True branch safe\n    // MAX < size  -> False branch safe\n\
  \    // MAX <= size -> False branch safe\n    if (Op == BO_GT || Op == BO_GE)\n\
  \      SafeOnTrue = true;\n    else if (Op == BO_LT || Op == BO_LE)\n      SafeOnTrue\
  \ = false;\n  }\n\n  if (!Matched || !SizeReg)\n    return;\n\n  // Create two states\
  \ for the branch; mark validated on safe branch.\n  ProgramStateRef StateT = State;\n\
  \  ProgramStateRef StateF = State;\n\n  if (SafeOnTrue) {\n    StateT = StateT->set<DeviceLenMap>(SizeReg,\
  \ true);\n  } else {\n    StateF = StateF->set<DeviceLenMap>(SizeReg, true);\n \
  \ }\n\n  C.addTransition(StateT);\n  C.addTransition(StateF);\n}\n\n// Step C: Detect\
  \ unsafe uses of unvalidated device length as a size for memory operations\nvoid\
  \ SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  unsigned SizeIdx = 0, BufIdx = 0;\n  if (!isMemCopyLike(Call, SizeIdx, BufIdx,\
  \ C))\n    return;\n\n  if (Call.getNumArgs() <= std::max(SizeIdx, BufIdx))\n  \
  \  return;\n\n  const Expr *SizeExpr = Call.getArgExpr(SizeIdx);\n  const MemRegion\
  \ *SizeReg = getBaseRegionFromExpr(SizeExpr, C);\n  ProgramStateRef State = C.getState();\n\
  \n  // If no region, try name-based heuristic: only proceed when name matches expected\
  \ size fields.\n  if (!SizeReg) {\n    if (!(ExprHasName(SizeExpr, \"rss_key_size\"\
  , C) || ExprHasName(SizeExpr, \"hash_key_length\", C)))\n      return;\n    // We\
  \ still need a region to consult the map. Try again.\n    SizeReg = getBaseRegionFromExpr(SizeExpr,\
  \ C);\n  }\n  if (!SizeReg)\n    return;\n\n  const bool *Validated = State->get<DeviceLenMap>(SizeReg);\n\
  \  if (!Validated || *Validated == true)\n    return; // Not tracked or already\
  \ validated\n\n  // Destination buffer should be a fixed-size array\n  const Expr\
  \ *BufExpr = Call.getArgExpr(BufIdx);\n  llvm::APInt ArraySize;\n  if (!tryGetArraySizeForBufferArg(BufExpr,\
  \ C, ArraySize))\n    return;\n\n  // We have an unvalidated device length being\
  \ used to copy into a fixed-size buffer -> warn\n  reportUnvalidatedUse(Call, C);\n\
  }\n\n// Step D: Propagate device length taint on simple assignments\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  if (!S) return;\n\n\
  \  const BinaryOperator *BO = findSpecificTypeInParents<BinaryOperator>(S, C);\n\
  \  if (!BO || !BO->isAssignmentOp())\n    return;\n\n  const Expr *LHS = BO->getLHS();\n\
  \  const Expr *RHS = BO->getRHS();\n  if (!LHS || !RHS) return;\n\n  const MemRegion\
  \ *SrcReg = getBaseRegionFromExpr(RHS, C);\n  const MemRegion *DstReg = getBaseRegionFromExpr(LHS,\
  \ C);\n  if (!SrcReg || !DstReg) return;\n\n  ProgramStateRef State = C.getState();\n\
  \  const bool *SrcTracked = State->get<DeviceLenMap>(SrcReg);\n  if (!SrcTracked)\
  \ return;\n\n  State = State->set<DeviceLenMap>(DstReg, *SrcTracked);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::reportUnvalidatedUse(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Unvalidated\
  \ device length used as copy size; check against VIRTIO_NET_RSS_MAX_KEY_SIZE.\"\
  , N);\n  if (const Stmt *S = Call.getOriginExpr())\n    R->addRange(S->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects use of unvalidated device-provided\
  \ lengths for memory operations (virtio rss key size)\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nvirtio_net: Add hash_key_length check\n\nAdd hash_key_length\
  \ check in virtnet_probe() to avoid possible out of\nbound errors when setting/reading\
  \ the hash key.\n\nFixes: c7114b1249fa (\"drivers/net/virtio_net: Added basic RSS\
  \ support.\")\nSigned-off-by: Philo Lu <lulie@linux.alibaba.com>\nSigned-off-by:\
  \ Xuan Zhuo <xuanzhuo@linux.alibaba.com>\nAcked-by: Joe Damato <jdamato@fastly.com>\n\
  Acked-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: virtnet_probe in drivers/net/virtio_net.c\n\
  static int virtnet_probe(struct virtio_device *vdev)\n{\n\tint i, err = -ENOMEM;\n\
  \tstruct net_device *dev;\n\tstruct virtnet_info *vi;\n\tu16 max_queue_pairs;\n\t\
  int mtu = 0;\n\n\t/* Find if host supports multiqueue/rss virtio_net device */\n\
  \tmax_queue_pairs = 1;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MQ) || virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_RSS))\n\t\tmax_queue_pairs =\n\t\t     virtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config, max_virtqueue_pairs));\n\n\t/* We need at least 2 queue's */\n\
  \tif (max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||\n\t    max_queue_pairs\
  \ > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||\n\t    !virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\
  \t\tmax_queue_pairs = 1;\n\n\t/* Allocate ourselves a network device with room for\
  \ our info */\n\tdev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);\n\
  \tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* Set up network device as normal. */\n\t\
  dev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE |\n\t\t\t   IFF_TX_SKB_NO_LINEAR;\n\
  \tdev->netdev_ops = &virtnet_netdev;\n\tdev->stat_ops = &virtnet_stat_ops;\n\tdev->features\
  \ = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev,\
  \ &vdev->dev);\n\n\t/* Do we support \"hardware\" checksums? */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_CSUM)) {\n\t\t/* This opens up the world of extra features. */\n\t\
  \tdev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\t\tif (csum)\n\t\t\tdev->features\
  \ |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO))\
  \ {\n\t\t\tdev->hw_features |= NETIF_F_TSO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\
  \t\t}\n\t\t/* Individual feature bits: what can host handle? */\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_ECN))\n\t\t\tdev->hw_features |= NETIF_F_TSO_ECN;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_USO))\n\t\t\tdev->hw_features |= NETIF_F_GSO_UDP_L4;\n\n\t\t\
  dev->features |= NETIF_F_GSO_ROBUST;\n\n\t\tif (gso)\n\t\t\tdev->features |= dev->hw_features\
  \ & NETIF_F_ALL_TSO;\n\t\t/* (!csum && gso) case will be fixed by register_netdev()\
  \ */\n\t}\n\n\t/* 1. With VIRTIO_NET_F_GUEST_CSUM negotiation, the driver doesn't\n\
  \t * need to calculate checksums for partially checksummed packets,\n\t * as they're\
  \ considered valid by the upper layer.\n\t * 2. Without VIRTIO_NET_F_GUEST_CSUM\
  \ negotiation, the driver only\n\t * receives fully checksummed packets. The device\
  \ may assist in\n\t * validating these packets' checksums, so the driver won't have\
  \ to.\n\t */\n\tdev->features |= NETIF_F_RXCSUM;\n\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_GUEST_TSO4) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6))\n\
  \t\tdev->features |= NETIF_F_GRO_HW;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS))\n\
  \t\tdev->hw_features |= NETIF_F_GRO_HW;\n\n\tdev->vlan_features = dev->features;\n\
  \tdev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT;\n\n\t/* MTU\
  \ range: 68 - 65535 */\n\tdev->min_mtu = MIN_MTU;\n\tdev->max_mtu = MAX_MTU;\n\n\
  \t/* Configuration may specify what MAC to use.  Otherwise random. */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MAC)) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tvirtio_cread_bytes(vdev,\n\
  \t\t\t\t   offsetof(struct virtio_net_config, mac),\n\t\t\t\t   addr, ETH_ALEN);\n\
  \t\teth_hw_addr_set(dev, addr);\n\t} else {\n\t\teth_hw_addr_random(dev);\n\t\t\
  dev_info(&vdev->dev, \"Assigned random MAC address %pM\\n\",\n\t\t\t dev->dev_addr);\n\
  \t}\n\n\t/* Set up our device-specific information */\n\tvi = netdev_priv(dev);\n\
  \tvi->dev = dev;\n\tvi->vdev = vdev;\n\tvdev->priv = vi;\n\n\tINIT_WORK(&vi->config_work,\
  \ virtnet_config_changed_work);\n\tINIT_WORK(&vi->rx_mode_work, virtnet_rx_mode_work);\n\
  \tspin_lock_init(&vi->refill_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))\
  \ {\n\t\tvi->mergeable_rx_bufs = true;\n\t\tdev->xdp_features |= NETDEV_XDP_ACT_RX_SG;\n\
  \t}\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HASH_REPORT))\n\t\tvi->has_rss_hash_report\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_RSS)) {\n\t\tvi->has_rss\
  \ = true;\n\n\t\tvi->rss_indir_table_size =\n\t\t\tvirtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config,\n\t\t\t\trss_max_indirection_table_length));\n\t}\n\terr =\
  \ rss_indirection_table_alloc(&vi->rss, vi->rss_indir_table_size);\n\tif (err)\n\
  \t\tgoto free;\n\n\tif (vi->has_rss || vi->has_rss_hash_report) {\n\t\tvi->rss_key_size\
  \ =\n\t\t\tvirtio_cread8(vdev, offsetof(struct virtio_net_config, rss_max_key_size));\n\
  \n\t\tvi->rss_hash_types_supported =\n\t\t    virtio_cread32(vdev, offsetof(struct\
  \ virtio_net_config, supported_hash_types));\n\t\tvi->rss_hash_types_supported &=\n\
  \t\t\t\t~(VIRTIO_NET_RSS_HASH_TYPE_IP_EX |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_TCP_EX\
  \ |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_UDP_EX);\n\n\t\tdev->hw_features |= NETIF_F_RXHASH;\n\
  \t\tdev->xdp_metadata_ops = &virtnet_xdp_metadata_ops;\n\t}\n\n\tif (vi->has_rss_hash_report)\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_v1_hash);\n\telse if (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MRG_RXBUF) ||\n\t\t virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\telse\n\t\tvi->hdr_len\
  \ = sizeof(struct virtio_net_hdr);\n\n\tif (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT)\
  \ ||\n\t    virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\tvi->any_header_sg\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\t\tvi->has_cvq\
  \ = true;\n\n\tmutex_init(&vi->cvq_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MTU))\
  \ {\n\t\tmtu = virtio_cread16(vdev,\n\t\t\t\t     offsetof(struct virtio_net_config,\n\
  \t\t\t\t\t      mtu));\n\t\tif (mtu < dev->min_mtu) {\n\t\t\t/* Should never trigger:\
  \ MTU was previously validated\n\t\t\t * in virtnet_validate.\n\t\t\t */\n\t\t\t\
  dev_err(&vdev->dev,\n\t\t\t\t\"device MTU appears to have changed it is now %d <\
  \ %d\",\n\t\t\t\tmtu, dev->min_mtu);\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\
  \t}\n\n\t\tdev->mtu = mtu;\n\t\tdev->max_mtu = mtu;\n\t}\n\n\tvirtnet_set_big_packets(vi,\
  \ mtu);\n\n\tif (vi->any_header_sg)\n\t\tdev->needed_headroom = vi->hdr_len;\n\n\
  \t/* Enable multiqueue by default */\n\tif (num_online_cpus() >= max_queue_pairs)\n\
  \t\tvi->curr_queue_pairs = max_queue_pairs;\n\telse\n\t\tvi->curr_queue_pairs =\
  \ num_online_cpus();\n\tvi->max_queue_pairs = max_queue_pairs;\n\n\t/* Allocate/initialize\
  \ the rx/tx queues, and invoke find_vqs */\n\terr = init_vqs(vi);\n\tif (err)\n\t\
  \tgoto free;\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_NOTF_COAL)) {\n\t\
  \tvi->intr_coal_rx.max_usecs = 0;\n\t\tvi->intr_coal_tx.max_usecs = 0;\n\t\tvi->intr_coal_rx.max_packets\
  \ = 0;\n\n\t\t/* Keep the default values of the coalescing parameters\n\t\t * aligned\
  \ with the default napi_tx state.\n\t\t */\n\t\tif (vi->sq[0].napi.weight)\n\t\t\
  \tvi->intr_coal_tx.max_packets = 1;\n\t\telse\n\t\t\tvi->intr_coal_tx.max_packets\
  \ = 0;\n\t}\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_VQ_NOTF_COAL)) {\n\
  \t\t/* The reason is the same as VIRTIO_NET_F_NOTF_COAL. */\n\t\tfor (i = 0; i <\
  \ vi->max_queue_pairs; i++)\n\t\t\tif (vi->sq[i].napi.weight)\n\t\t\t\tvi->sq[i].intr_coal.max_packets\
  \ = 1;\n\n\t\terr = virtnet_init_irq_moder(vi);\n\t\tif (err)\n\t\t\tgoto free;\n\
  \t}\n\n#ifdef CONFIG_SYSFS\n\tif (vi->mergeable_rx_bufs)\n\t\tdev->sysfs_rx_queue_group\
  \ = &virtio_net_mrg_rx_group;\n#endif\n\tnetif_set_real_num_tx_queues(dev, vi->curr_queue_pairs);\n\
  \tnetif_set_real_num_rx_queues(dev, vi->curr_queue_pairs);\n\n\tvirtnet_init_settings(dev);\n\
  \n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_STANDBY)) {\n\t\tvi->failover = net_failover_create(vi->dev);\n\
  \t\tif (IS_ERR(vi->failover)) {\n\t\t\terr = PTR_ERR(vi->failover);\n\t\t\tgoto\
  \ free_vqs;\n\t\t}\n\t}\n\n\tif (vi->has_rss || vi->has_rss_hash_report)\n\t\tvirtnet_init_default_rss(vi);\n\
  \n\tenable_rx_mode_work(vi);\n\n\t/* serialize netdev register + virtio_device_ready()\
  \ with ndo_open() */\n\trtnl_lock();\n\n\terr = register_netdevice(dev);\n\tif (err)\
  \ {\n\t\tpr_debug(\"virtio_net: registering device failed\\n\");\n\t\trtnl_unlock();\n\
  \t\tgoto free_failover;\n\t}\n\n\t/* Disable config change notification until ndo_open.\
  \ */\n\tvirtio_config_driver_disable(vi->vdev);\n\n\tvirtio_device_ready(vdev);\n\
  \n\tvirtnet_set_queues(vi, vi->curr_queue_pairs);\n\n\t/* a random MAC address has\
  \ been assigned, notify the device.\n\t * We don't fail probe if VIRTIO_NET_F_CTRL_MAC_ADDR\
  \ is not there\n\t * because many devices work fine without getting MAC explicitly\n\
  \t */\n\tif (!virtio_has_feature(vdev, VIRTIO_NET_F_MAC) &&\n\t    virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_CTRL_MAC_ADDR)) {\n\t\tstruct scatterlist sg;\n\n\t\tsg_init_one(&sg,\
  \ dev->dev_addr, dev->addr_len);\n\t\tif (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MAC,\n\
  \t\t\t\t\t  VIRTIO_NET_CTRL_MAC_ADDR_SET, &sg)) {\n\t\t\tpr_debug(\"virtio_net:\
  \ setting MAC address failed\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr = -EINVAL;\n\
  \t\t\tgoto free_unregister_netdev;\n\t\t}\n\t}\n\n\tif (virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_DEVICE_STATS)) {\n\t\tstruct virtio_net_stats_capabilities *stats_cap\
  \  __free(kfree) = NULL;\n\t\tstruct scatterlist sg;\n\t\t__le64 v;\n\n\t\tstats_cap\
  \ = kzalloc(sizeof(*stats_cap), GFP_KERNEL);\n\t\tif (!stats_cap) {\n\t\t\trtnl_unlock();\n\
  \t\t\terr = -ENOMEM;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tsg_init_one(&sg,\
  \ stats_cap, sizeof(*stats_cap));\n\n\t\tif (!virtnet_send_command_reply(vi, VIRTIO_NET_CTRL_STATS,\n\
  \t\t\t\t\t\tVIRTIO_NET_CTRL_STATS_QUERY,\n\t\t\t\t\t\tNULL, &sg)) {\n\t\t\tpr_debug(\"\
  virtio_net: fail to get stats capability\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr\
  \ = -EINVAL;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tv = stats_cap->supported_stats_types[0];\n\
  \t\tvi->device_stats_cap = le64_to_cpu(v);\n\t}\n\n\t/* Assume link up if device\
  \ can't report link status,\n\t   otherwise get link status from config. */\n\t\
  netif_carrier_off(dev);\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS))\
  \ {\n\t\tvirtnet_config_changed_work(&vi->config_work);\n\t} else {\n\t\tvi->status\
  \ = VIRTIO_NET_S_LINK_UP;\n\t\tvirtnet_update_settings(vi);\n\t\tnetif_carrier_on(dev);\n\
  \t}\n\n\tfor (i = 0; i < ARRAY_SIZE(guest_offloads); i++)\n\t\tif (virtio_has_feature(vi->vdev,\
  \ guest_offloads[i]))\n\t\t\tset_bit(guest_offloads[i], &vi->guest_offloads);\n\t\
  vi->guest_offloads_capable = vi->guest_offloads;\n\n\trtnl_unlock();\n\n\terr =\
  \ virtnet_cpu_notif_add(vi);\n\tif (err) {\n\t\tpr_debug(\"virtio_net: registering\
  \ cpu notifier failed\\n\");\n\t\tgoto free_unregister_netdev;\n\t}\n\n\tpr_debug(\"\
  virtnet: registered device %s with %d RX and TX vq's\\n\",\n\t\t dev->name, max_queue_pairs);\n\
  \n\treturn 0;\n\nfree_unregister_netdev:\n\tunregister_netdev(dev);\nfree_failover:\n\
  \tnet_failover_destroy(vi->failover);\nfree_vqs:\n\tvirtio_reset_device(vdev);\n\
  \tcancel_delayed_work_sync(&vi->refill);\n\tfree_receive_page_frags(vi);\n\tvirtnet_del_vqs(vi);\n\
  free:\n\tfree_netdev(dev);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c\nindex 4b507007d242..545dda8ec077\
  \ 100644\n--- a/drivers/net/virtio_net.c\n+++ b/drivers/net/virtio_net.c\n@@ -6451,6\
  \ +6451,12 @@ static int virtnet_probe(struct virtio_device *vdev)\n \tif (vi->has_rss\
  \ || vi->has_rss_hash_report) {\n \t\tvi->rss_key_size =\n \t\t\tvirtio_cread8(vdev,\
  \ offsetof(struct virtio_net_config, rss_max_key_size));\n+\t\tif (vi->rss_key_size\
  \ > VIRTIO_NET_RSS_MAX_KEY_SIZE) {\n+\t\t\tdev_err(&vdev->dev, \"rss_max_key_size=%u\
  \ exceeds the limit %u.\\n\",\n+\t\t\t\tvi->rss_key_size, VIRTIO_NET_RSS_MAX_KEY_SIZE);\n\
  +\t\t\terr = -EINVAL;\n+\t\t\tgoto free;\n+\t\t}\n \n \t\tvi->rss_hash_types_supported\
  \ =\n \t\t    virtio_cread32(vdev, offsetof(struct virtio_net_config, supported_hash_types));\n\
  ```\n"
pattern: '## Bug Pattern


  Using a device-provided size field (rss_max_key_size) without validating it against
  the protocol-defined maximum (VIRTIO_NET_RSS_MAX_KEY_SIZE) before using it to set/read
  data into a fixed-size buffer. In short: trusting an unvalidated length from hardware
  (virtio config) for memory operations, leading to potential out-of-bounds access.'
plan: "1) Program state\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(DeviceLenMap, const MemRegion*,\
  \ bool)\n  - Tracks \u201Cdevice-provided length\u201D regions and whether they\
  \ have been validated.\n  - Key: MemRegion of the integer/field storing the length\
  \ (e.g., vi->rss_key_size).\n  - Value: false = unvalidated, true = validated (checked\
  \ against the protocol-defined max).\n\n- Optional (only if you need simple scalar\
  \ aliasing):\n  - We will not create a separate alias map. Instead, we will propagate\
  \ the DeviceLenMap entry in checkBind when a value is assigned from a tracked source\
  \ to a new destination (see Step 4). This keeps the state simple.\n\n2) Callback\
  \ functions and how to implement them\n\nStep A \u2014 Mark device-provided size\
  \ as \u201Cunvalidated\u201D right after reading from device\n- Use: checkPostCall\n\
  - Goal: Detect reads of rss_max_key_size (or hash key length) via virtio_cread8/16/32\
  \ and taint the returned value as \u201Cunvalidated device length.\u201D\n\nImplementation\
  \ details:\n- Identify calls by callee name:\n  - virtio_cread8, virtio_cread16,\
  \ virtio_cread32\n- Confirm the call reads the relevant field:\n  - Inspect the\
  \ 2nd argument (the offset expression).\n  - If ExprHasName(offsetExpr, \"rss_max_key_size\"\
  ) or ExprHasName(offsetExpr, \"hash_key_length\"), treat it as the target field.\n\
  - Find where the function return is stored:\n  - Use findSpecificTypeInParents<BinaryOperator>(Call.getOriginExpr())\
  \ to find the assignment BO_Assign.\n  - Extract the LHS expression of the assignment,\
  \ and get its MemRegion using getMemRegionFromExpr.\n- Update state:\n  - State\
  \ = State->set<DeviceLenMap>(LHSMemRegion, /*Validated=*/false).\n  - addTransition(State).\n\
  \nRationale: This marks variables like vi->rss_key_size as a potentially unsafe\
  \ value until we see an explicit validation.\n\nStep B \u2014 Recognize validation\
  \ branches and mark the device length as \u201Cvalidated\u201D\n- Use: checkBranchCondition\n\
  - Goal: Detect if-conditions that validate the device-provided size against the\
  \ protocol max (e.g., VIRTIO_NET_RSS_MAX_KEY_SIZE) and mark the variable as validated\
  \ on the safe branch.\n\nImplementation details:\n- Extract the condition Stmt;\
  \ find a BinaryOperator (findSpecificTypeInParents/Children or directly dyn_cast\
  \ if Condition is a BO).\n- We care about comparisons: <, <=, >, >=, ==, != (most\
  \ common will be <= or >).\n- Detect involvement of the tracked variable:\n  - For\
  \ both LHS and RHS of the comparison, check if one side refers to a MemRegion present\
  \ in DeviceLenMap (use getMemRegionFromExpr).\n- Detect the maximum macro:\n  -\
  \ If the opposite side\u2019s expression source contains \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  \ via ExprHasName, consider this a validation check.\n- Create two branch states\
  \ and mark validation in the safe branch:\n  - For \u201Csize <= MAX\u201D: True\
  \ branch => set<DeviceLenMap>(sizeRegion, true); False branch => keep current mapping.\n\
  \  - For \u201Csize < MAX\u201D: True branch => set true.\n  - For \u201Csize >\
  \ MAX\u201D: False branch => set true (safe path is the else branch when the condition\
  \ is false).\n  - For \u201CMAX >= size\u201D: True branch => set true.\n  - For\
  \ \u201CMAX > size\u201D: True branch => set true.\n- Emit transitions for both\
  \ branches with Ctx.addTransition(StateTrue) and Ctx.addTransition(StateFalse).\n\
  \nRationale: This models the check pattern used in the fix and prevents false positives\
  \ when proper validation exists.\n\nStep C \u2014 Detect unsafe uses of unvalidated\
  \ device length as a size for memory operations\n- Use: checkPreCall\n- Goal: When\
  \ an unvalidated device length is used as a size argument to copy/read/write operations\
  \ into fixed-size buffers, report a bug.\n\nImplementation details:\n- Match calls\
  \ with a \u201Csize\u201D parameter and a destination buffer:\n  - memcpy(dst, src,\
  \ len)       => size index = 2, dst index = 0\n  - memmove(dst, src, len)      =>\
  \ size index = 2, dst index = 0\n  - virtio_cread_bytes(dev, off, buf, len)  =>\
  \ size index = 3, buf index = 2\n  - virtio_cwrite_bytes(dev, off, buf, len) =>\
  \ size index = 3, buf index = 2\n  - sg_init_one(sg, buf, len)   => size index =\
  \ 2, buf index = 1\n- Get the size expr and attempt to map it to a MemRegion:\n\
  \  - const MemRegion* LenR = getMemRegionFromExpr(Arg[sizeIndex]);\n  - If LenR\
  \ not in DeviceLenMap, attempt a name-based fallback: if ExprHasName(sizeExpr, \"\
  rss_key_size\") or \"hash_key_length\", then treat it as tracked and lookup the\
  \ region of that expr via getMemRegionFromExpr again (often it already works via\
  \ LenR).\n- If the size region is tracked and DeviceLenMap[LenR] == false (unvalidated):\n\
  \  - Try to obtain destination buffer\u2019s array size:\n    - const MemRegion*\
  \ BufR = getMemRegionFromExpr(Arg[bufIndex]);\n    - If Arg[bufIndex] is an array\
  \ variable, getArraySizeFromExpr can return the compile-time size (ArraySize).\n\
  \  - Reporting rule to minimize false positives:\n    - If ArraySize is known (i.e.,\
  \ fixed-size array), and size is unvalidated, then report. We don\u2019t need concrete\
  \ comparison because the bug is using a device-provided length without checking\
  \ against the max before a bounded copy into a fixed-size array.\n- Report:\n  -\
  \ Generate a non-fatal error node using generateNonFatalErrorNode.\n  - Create a\
  \ PathSensitiveBugReport with a short message:\n    - \u201CUnvalidated device length\
  \ used as copy size; check against VIRTIO_NET_RSS_MAX_KEY_SIZE.\u201D\n  - Attach\
  \ the call expression as the location.\n\nRationale: This targets the actual risky\
  \ use (copy into fixed-size buffer) and keeps noise low.\n\nStep D \u2014 Propagate\
  \ \u201Cdevice length\u201D taint on simple assignments\n- Use: checkBind\n- Goal:\
  \ When the device length is assigned to another scalar (e.g., len = vi->rss_key_size),\
  \ copy the validation status to the LHS region.\n\nImplementation details:\n- The\
  \ Stmt S in checkBind is the reason for the bind; look for an enclosing BinaryOperator\
  \ (assignment):\n  - const BinaryOperator* BO = findSpecificTypeInParents<BinaryOperator>(S,\
  \ C);\n  - If BO && BO->getOpcode() == BO_Assign:\n    - MemRegion* SrcR = getMemRegionFromExpr(BO->getRHS(),\
  \ C);\n    - MemRegion* DstR = getMemRegionFromExpr(BO->getLHS(), C);\n    - If\
  \ SrcR exists in DeviceLenMap, then State = State->set<DeviceLenMap>(DstR, State->get<DeviceLenMap>(SrcR)).\n\
  - addTransition(State) if changed.\n\nRationale: This lets the checker follow common\
  \ patterns where size is copied to a local before use.\n\nStep E \u2014 Optional\
  \ early warning if no validation appears (conservative)\n- Not strictly necessary.\
  \ To keep the checker precise and simple, we only warn at sinks (Step C). No extra\
  \ scans for missing checks.\n\n3) Additional matching heuristics to reduce false\
  \ positives\n\n- Source identification (Step A) is strictly tied to the virtio_cread8/16/32\
  \ calls and the specific field names \u201Crss_max_key_size\u201D or \u201Chash_key_length,\u201D\
  \ using ExprHasName on the offsetof expression. This tightly scopes the checker\
  \ to the target bug pattern.\n- Validation detection (Step B) requires the macro\
  \ name \u201CVIRTIO_NET_RSS_MAX_KEY_SIZE\u201D to appear in the condition.\n- Sink\
  \ detection (Step C) requires both:\n  - The size to be tracked and unvalidated,\
  \ and\n  - The destination buffer to have a compile-time constant array size (getArraySizeFromExpr\
  \ succeeds).\n\n4) Bug report\n\n- Type: PathSensitiveBugReport\n- Message: \u201C\
  Unvalidated device length used as copy size; check against VIRTIO_NET_RSS_MAX_KEY_SIZE.\u201D\
  \n- Location: the call site using the unvalidated length as size.\n- Only emit once\
  \ per path at the first risky sink use.\n\n5) Summary of selected CSA hooks\n\n\
  - checkPostCall:\n  - Detect virtio_cread8/16/32 reads of rss_max_key_size/hash_key_length,\
  \ mark LHS as unvalidated in DeviceLenMap.\n\n- checkBranchCondition:\n  - Detect\
  \ comparisons against VIRTIO_NET_RSS_MAX_KEY_SIZE and mark the device length as\
  \ validated on the safe branch (set DeviceLenMap[region] = true), producing two\
  \ transitions.\n\n- checkBind:\n  - Propagate validation state on simple assignments\
  \ from a tracked size to another scalar.\n\n- checkPreCall:\n  - At memcpy/memmove/virtio_cread_bytes/virtio_cwrite_bytes/sg_init_one,\
  \ if size arg is tracked unvalidated and destination buffer is a fixed-size array,\
  \ report a bug."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Basic/SourceManager.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// Track device-provided length regions and whether\
  \ they are validated.\nREGISTER_MAP_WITH_PROGRAMSTATE(DeviceLenMap, const MemRegion*,\
  \ bool)\n\nnamespace {\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n\
  \        check::PreCall,\n        check::BranchCondition,\n        check::Bind>\
  \ {\n\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unvalidated device length\", \"Memory Safety\")) {}\n\
  \n      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n  \
  \    void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n      void\
  \ checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n      void\
  \ checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\n   private:\n\
  \      // Helpers\n      static bool isVirtioCreadScalar(const CallEvent &Call,\
  \ CheckerContext &C);\n      static bool isRelevantOffsetExpr(const Expr *E, CheckerContext\
  \ &C);\n      static const MemRegion* getBaseRegionFromExpr(const Expr *E, CheckerContext\
  \ &C);\n\n      static bool isMemCopyLike(const CallEvent &Call, unsigned &SizeIdx,\
  \ unsigned &BufIdx, CheckerContext &C);\n      static bool tryGetArraySizeForBufferArg(const\
  \ Expr *BufExpr, CheckerContext &C, llvm::APInt &ArraySize);\n\n      static bool\
  \ exprHasRSSMaxMacro(const Expr *E, CheckerContext &C);\n\n      void markLenValidatedOnBranch(const\
  \ BinaryOperator *BO, CheckerContext &C) const;\n      void reportUnvalidatedUse(const\
  \ CallEvent &Call, CheckerContext &C) const;\n};\n\nstatic const MemRegion* getTrackedRegionFromState(ProgramStateRef\
  \ State, const MemRegion *MR) {\n  if (!MR) return nullptr;\n  MR = MR->getBaseRegion();\n\
  \  if (!MR) return nullptr;\n  const bool *Val = State->get<DeviceLenMap>(MR);\n\
  \  return Val ? MR : nullptr;\n}\n\nbool SAGenTestChecker::isVirtioCreadScalar(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin) return false;\n\n  // Use ExprHasName for robustness\n  if (ExprHasName(Origin,\
  \ \"virtio_cread8\", C)) return true;\n  if (ExprHasName(Origin, \"virtio_cread16\"\
  , C)) return true;\n  if (ExprHasName(Origin, \"virtio_cread32\", C)) return true;\n\
  \  return false;\n}\n\nbool SAGenTestChecker::isRelevantOffsetExpr(const Expr *E,\
  \ CheckerContext &C) {\n  if (!E) return false;\n  // We only care about reading\
  \ rss_max_key_size or hash_key_length offsets\n  if (ExprHasName(E, \"rss_max_key_size\"\
  , C)) return true;\n  if (ExprHasName(E, \"hash_key_length\", C)) return true;\n\
  \  return false;\n}\n\nconst MemRegion* SAGenTestChecker::getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) {\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR) return nullptr;\n  MR = MR->getBaseRegion();\n  return MR;\n}\n\
  \nbool SAGenTestChecker::isMemCopyLike(const CallEvent &Call, unsigned &SizeIdx,\
  \ unsigned &BufIdx, CheckerContext &C) {\n  SizeIdx = BufIdx = (unsigned)-1;\n \
  \ const Expr *Origin = Call.getOriginExpr();\n  if (!Origin) return false;\n\n \
  \ // memcpy(dst, src, len)\n  if (ExprHasName(Origin, \"memcpy\", C)) {\n    if\
  \ (Call.getNumArgs() >= 3) {\n      BufIdx = 0; SizeIdx = 2; return true;\n    }\n\
  \  }\n  // memmove(dst, src, len)\n  if (ExprHasName(Origin, \"memmove\", C)) {\n\
  \    if (Call.getNumArgs() >= 3) {\n      BufIdx = 0; SizeIdx = 2; return true;\n\
  \    }\n  }\n  // virtio_cread_bytes(dev, off, buf, len)\n  if (ExprHasName(Origin,\
  \ \"virtio_cread_bytes\", C)) {\n    if (Call.getNumArgs() >= 4) {\n      BufIdx\
  \ = 2; SizeIdx = 3; return true;\n    }\n  }\n  // virtio_cwrite_bytes(dev, off,\
  \ buf, len)\n  if (ExprHasName(Origin, \"virtio_cwrite_bytes\", C)) {\n    if (Call.getNumArgs()\
  \ >= 4) {\n      BufIdx = 2; SizeIdx = 3; return true;\n    }\n  }\n  // sg_init_one(sg,\
  \ buf, len)\n  if (ExprHasName(Origin, \"sg_init_one\", C)) {\n    if (Call.getNumArgs()\
  \ >= 3) {\n      BufIdx = 1; SizeIdx = 2; return true;\n    }\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::tryGetArraySizeForBufferArg(const Expr *BufExpr, CheckerContext\
  \ &C, llvm::APInt &ArraySize) {\n  if (!BufExpr) return false;\n\n  // Try directly\n\
  \  if (getArraySizeFromExpr(ArraySize, BufExpr))\n    return true;\n\n  // Try to\
  \ find a DeclRefExpr child\n  if (const auto *DRE = findSpecificTypeInChildren<DeclRefExpr>(BufExpr))\
  \ {\n    if (getArraySizeFromExpr(ArraySize, DRE))\n      return true;\n  }\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::exprHasRSSMaxMacro(const Expr *E, CheckerContext\
  \ &C) {\n  if (!E) return false;\n  return ExprHasName(E, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C);\n}\n\n// Step A: Mark device-provided size as unvalidated after virtio_cread8/16/32\
  \ for rss_max_key_size/hash_key_length\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isVirtioCreadScalar(Call,\
  \ C))\n    return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n  const Expr\
  \ *OffsetExpr = Call.getArgExpr(1);\n  if (!isRelevantOffsetExpr(OffsetExpr, C))\n\
  \    return;\n\n  // Find assignment of the call result: LHS = virtio_creadX(...)\n\
  \  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin) return;\n\n  const\
  \ BinaryOperator *BO = findSpecificTypeInParents<BinaryOperator>(Origin, C);\n \
  \ if (!BO || !BO->isAssignmentOp())\n    return;\n\n  const Expr *LHS = BO->getLHS();\n\
  \  if (!LHS) return;\n\n  const MemRegion *LHSMR = getBaseRegionFromExpr(LHS, C);\n\
  \  if (!LHSMR) return;\n\n  ProgramStateRef State = C.getState();\n  State = State->set<DeviceLenMap>(LHSMR,\
  \ /*Validated=*/false);\n  C.addTransition(State);\n}\n\n// Step B: Recognize validation\
  \ branches and mark as validated on safe branch\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!Condition) return;\n\n  const\
  \ Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE) return;\n\n  // Strip\
  \ parens/casts\n  CondE = CondE->IgnoreParenCasts();\n\n  const BinaryOperator *BO\
  \ = dyn_cast<BinaryOperator>(CondE);\n  if (!BO) {\n    // Try find a binary operator\
  \ in children if directly not available\n    BO = findSpecificTypeInChildren<BinaryOperator>(Condition);\n\
  \  }\n  if (!BO) return;\n\n  // Only consider comparison operators\n  BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n  switch (Op) {\n  case BO_LT: case BO_LE: case BO_GT:\
  \ case BO_GE:\n    break;\n  default:\n    return;\n  }\n\n  ProgramStateRef State\
  \ = C.getState();\n\n  const Expr *LHS = BO->getLHS();\n  const Expr *RHS = BO->getRHS();\n\
  \  if (!LHS || !RHS) return;\n\n  const MemRegion *LHSReg = getBaseRegionFromExpr(LHS,\
  \ C);\n  const MemRegion *RHSReg = getBaseRegionFromExpr(RHS, C);\n\n  const bool\
  \ *LHSTrackedVal = LHSReg ? State->get<DeviceLenMap>(LHSReg) : nullptr;\n  const\
  \ bool *RHSTrackedVal = RHSReg ? State->get<DeviceLenMap>(RHSReg) : nullptr;\n\n\
  \  bool RHSHasMax = exprHasRSSMaxMacro(RHS, C);\n  bool LHSHasMax = exprHasRSSMaxMacro(LHS,\
  \ C);\n\n  const MemRegion *SizeReg = nullptr;\n  bool SafeOnTrue = false;\n  bool\
  \ Matched = false;\n\n  // Case 1: size (tracked) on LHS, macro on RHS\n  if (LHSTrackedVal\
  \ && RHSHasMax) {\n    SizeReg = LHSReg;\n    Matched = true;\n    // size < = MAX\
  \  -> True branch safe\n    // size < MAX     -> True branch safe\n    // size >\
  \ = MAX   -> False branch safe\n    // size > MAX     -> False branch safe\n   \
  \ if (Op == BO_LT || Op == BO_LE)\n      SafeOnTrue = true;\n    else if (Op ==\
  \ BO_GT || Op == BO_GE)\n      SafeOnTrue = false;\n  }\n\n  // Case 2: macro on\
  \ LHS, size (tracked) on RHS\n  if (!Matched && RHSTrackedVal && LHSHasMax) {\n\
  \    SizeReg = RHSReg;\n    Matched = true;\n    // MAX > size  -> True branch safe\n\
  \    // MAX >= size -> True branch safe\n    // MAX < size  -> False branch safe\n\
  \    // MAX <= size -> False branch safe\n    if (Op == BO_GT || Op == BO_GE)\n\
  \      SafeOnTrue = true;\n    else if (Op == BO_LT || Op == BO_LE)\n      SafeOnTrue\
  \ = false;\n  }\n\n  if (!Matched || !SizeReg)\n    return;\n\n  // Create two states\
  \ for the branch; mark validated on safe branch.\n  ProgramStateRef StateT = State;\n\
  \  ProgramStateRef StateF = State;\n\n  if (SafeOnTrue) {\n    StateT = StateT->set<DeviceLenMap>(SizeReg,\
  \ true);\n  } else {\n    StateF = StateF->set<DeviceLenMap>(SizeReg, true);\n \
  \ }\n\n  C.addTransition(StateT);\n  C.addTransition(StateF);\n}\n\n// Step C: Detect\
  \ unsafe uses of unvalidated device length as a size for memory operations\nvoid\
  \ SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  unsigned SizeIdx = 0, BufIdx = 0;\n  if (!isMemCopyLike(Call, SizeIdx, BufIdx,\
  \ C))\n    return;\n\n  if (Call.getNumArgs() <= std::max(SizeIdx, BufIdx))\n  \
  \  return;\n\n  const Expr *SizeExpr = Call.getArgExpr(SizeIdx);\n  const MemRegion\
  \ *SizeReg = getBaseRegionFromExpr(SizeExpr, C);\n  ProgramStateRef State = C.getState();\n\
  \n  // If no region, try name-based heuristic: only proceed when name matches expected\
  \ size fields.\n  if (!SizeReg) {\n    if (!(ExprHasName(SizeExpr, \"rss_key_size\"\
  , C) || ExprHasName(SizeExpr, \"hash_key_length\", C)))\n      return;\n    // We\
  \ still need a region to consult the map. Try again.\n    SizeReg = getBaseRegionFromExpr(SizeExpr,\
  \ C);\n  }\n  if (!SizeReg)\n    return;\n\n  const bool *Validated = State->get<DeviceLenMap>(SizeReg);\n\
  \  if (!Validated || *Validated == true)\n    return; // Not tracked or already\
  \ validated\n\n  // Destination buffer should be a fixed-size array\n  const Expr\
  \ *BufExpr = Call.getArgExpr(BufIdx);\n  llvm::APInt ArraySize;\n  if (!tryGetArraySizeForBufferArg(BufExpr,\
  \ C, ArraySize))\n    return;\n\n  // We have an unvalidated device length being\
  \ used to copy into a fixed-size buffer -> warn\n  reportUnvalidatedUse(Call, C);\n\
  }\n\n// Step D: Propagate device length taint on simple assignments\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  if (!S) return;\n\n\
  \  const BinaryOperator *BO = findSpecificTypeInParents<BinaryOperator>(S, C);\n\
  \  if (!BO || !BO->isAssignmentOp())\n    return;\n\n  const Expr *LHS = BO->getLHS();\n\
  \  const Expr *RHS = BO->getRHS();\n  if (!LHS || !RHS) return;\n\n  const MemRegion\
  \ *SrcReg = getBaseRegionFromExpr(RHS, C);\n  const MemRegion *DstReg = getBaseRegionFromExpr(LHS,\
  \ C);\n  if (!SrcReg || !DstReg) return;\n\n  ProgramStateRef State = C.getState();\n\
  \  const bool *SrcTracked = State->get<DeviceLenMap>(SrcReg);\n  if (!SrcTracked)\
  \ return;\n\n  State = State->set<DeviceLenMap>(DstReg, *SrcTracked);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::reportUnvalidatedUse(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Unvalidated\
  \ device length used as copy size; check against VIRTIO_NET_RSS_MAX_KEY_SIZE.\"\
  , N);\n  if (const Stmt *S = Call.getOriginExpr())\n    R->addRange(S->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects use of unvalidated device-provided\
  \ lengths for memory operations (virtio rss key size)\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
