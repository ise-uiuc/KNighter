_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 7d42e097607c4d246d99225bf2b195b6167a210c
commit_type: Concurrency
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program states\nREGISTER_MAP_WITH_PROGRAMSTATE(CompUseMap,\
  \ const MemRegion*, unsigned)\nREGISTER_MAP_WITH_PROGRAMSTATE(CompLastUseStmt, const\
  \ MemRegion*, const Stmt*)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<\
  \ check::PostCall, check::EndFunction > {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   // Heuristic TU-wide gate: set true if we ever see wait_for_completion_timeout\n\
  \   mutable bool SawTimedWaitInTU = false;\n\n   // Flags for CompUseMap\n   static\
  \ constexpr unsigned SEEN_COMPLETE = 0x1;  // complete(&ctx->compl)\n   static constexpr\
  \ unsigned SEEN_KFREE    = 0x2;  // kfree(ctx)\n   static constexpr unsigned SEEN_DONE\
  \     = 0x4;  // completion_done(&ctx->compl)\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Workqueue timed-wait UAF risk\", \"Concurrency\")) {}\n\
  \n      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n  \
  \    void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;\n\n \
  \  private:\n      // Helpers\n      bool callIs(const CallEvent &Call, StringRef\
  \ Name, CheckerContext &C) const;\n      bool isWorkerFunction(const FunctionDecl\
  \ *FD) const;\n\n      ProgramStateRef setFlag(ProgramStateRef State, const MemRegion\
  \ *B, unsigned Flag) const;\n      ProgramStateRef setLastUse(ProgramStateRef State,\
  \ const MemRegion *B, const Stmt *S) const;\n\n      const MemRegion *getContextBaseFromCompletionArg(const\
  \ Expr *ArgE, CheckerContext &C) const;\n      const MemRegion *getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) const;\n\n      void reportMissingGuard(const MemRegion\
  \ *B, const Stmt *S, CheckerContext &C) const;\n};\n\n// Determine if Call refers\
  \ to a function with given name using source text.\nbool SAGenTestChecker::callIs(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) const {\n  const Expr *Origin\
  \ = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n  return ExprHasName(Origin,\
  \ Name, C);\n}\n\n// Identify worker function by parameter of type 'struct work_struct\
  \ *'\nbool SAGenTestChecker::isWorkerFunction(const FunctionDecl *FD) const {\n\
  \  if (!FD)\n    return false;\n\n  for (const ParmVarDecl *P : FD->parameters())\
  \ {\n    QualType QT = P->getType();\n    if (!QT->isPointerType())\n      continue;\n\
  \    QualType Pointee = QT->getPointeeType();\n    if (const RecordType *RT = Pointee->getAs<RecordType>())\
  \ {\n      const RecordDecl *RD = RT->getDecl();\n      IdentifierInfo *II = RD->getIdentifier();\n\
  \      if (II && II->getName() == \"work_struct\")\n        return true;\n    }\n\
  \  }\n  return false;\n}\n\n// Update flag bitmask for a given base region\nProgramStateRef\
  \ SAGenTestChecker::setFlag(ProgramStateRef State, const MemRegion *B, unsigned\
  \ Flag) const {\n  if (!B)\n    return State;\n  const unsigned *Old = State->get<CompUseMap>(B);\n\
  \  unsigned NewFlags = (Old ? *Old : 0) | Flag;\n  State = State->set<CompUseMap>(B,\
  \ NewFlags);\n  return State;\n}\n\n// Record the last interesting statement for\
  \ a region\nProgramStateRef SAGenTestChecker::setLastUse(ProgramStateRef State,\
  \ const MemRegion *B, const Stmt *S) const {\n  if (!B || !S)\n    return State;\n\
  \  State = State->set<CompLastUseStmt>(B, S);\n  return State;\n}\n\n// Get base\
  \ region for a pointer expression\nconst MemRegion *SAGenTestChecker::getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return nullptr;\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C);\n  if (!MR)\n    return nullptr;\n  return MR->getBaseRegion();\n\
  }\n\n// Extract the context base region from an argument expected to be &ctx->compl\
  \ or a pointer to a completion field.\n// Strategy: get region for the arg; if it's\
  \ a FieldRegion, use its super; otherwise use base.\nconst MemRegion *SAGenTestChecker::getContextBaseFromCompletionArg(const\
  \ Expr *ArgE, CheckerContext &C) const {\n  if (!ArgE)\n    return nullptr;\n\n\
  \  ProgramStateRef State = C.getState();\n  SVal V = State->getSVal(ArgE, C.getLocationContext());\n\
  \  const MemRegion *MR = V.getAsRegion();\n  if (!MR) {\n    MR = getMemRegionFromExpr(ArgE,\
  \ C);\n    if (!MR)\n      return nullptr;\n  }\n\n  MR = MR->getBaseRegion();\n\
  \  // If this is a field region (e.g., &ctx->compl), climb to its super region.\n\
  \  if (const FieldRegion *FR = dyn_cast<FieldRegion>(MR)) {\n    const MemRegion\
  \ *Super = FR->getSuperRegion();\n    if (Super)\n      return Super->getBaseRegion();\n\
  \  }\n  // Otherwise return the base region as best-effort.\n  return MR ? MR->getBaseRegion()\
  \ : nullptr;\n}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  // Heuristic gate: remember\
  \ if TU uses wait_for_completion_timeout\n  if (callIs(Call, \"wait_for_completion_timeout\"\
  , C)) {\n    SawTimedWaitInTU = true;\n    // No per-region state needed here.\n\
  \    return;\n  }\n\n  // Track complete(&ctx->compl)\n  if (callIs(Call, \"complete\"\
  , C)) {\n    const Expr *Arg0 = Call.getArgExpr(0);\n    const MemRegion *B = getContextBaseFromCompletionArg(Arg0,\
  \ C);\n    if (B) {\n      State = setFlag(State, B, SEEN_COMPLETE);\n      State\
  \ = setLastUse(State, B, Call.getOriginExpr());\n      C.addTransition(State);\n\
  \    }\n    return;\n  }\n\n  // Track completion_done(&ctx->compl)\n  if (callIs(Call,\
  \ \"completion_done\", C)) {\n    const Expr *Arg0 = Call.getArgExpr(0);\n    const\
  \ MemRegion *B = getContextBaseFromCompletionArg(Arg0, C);\n    if (B) {\n     \
  \ State = setFlag(State, B, SEEN_DONE);\n      C.addTransition(State);\n    }\n\
  \    return;\n  }\n\n  // Track kfree(ctx)\n  if (callIs(Call, \"kfree\", C)) {\n\
  \    const Expr *Arg0 = Call.getArgExpr(0);\n    const MemRegion *B = getBaseRegionFromExpr(Arg0,\
  \ C);\n    if (B) {\n      State = setFlag(State, B, SEEN_KFREE);\n      State =\
  \ setLastUse(State, B, Call.getOriginExpr());\n      C.addTransition(State);\n \
  \   }\n    return;\n  }\n}\n\nvoid SAGenTestChecker::reportMissingGuard(const MemRegion\
  \ *B, const Stmt *S, CheckerContext &C) const {\n  if (!BT)\n    return;\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Missing completion_done() guard in worker; submitter with timed wait\
  \ may free the context\", N);\n  if (S)\n    R->addRange(S->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C) const {\n  const LocationContext *LCtx = C.getLocationContext();\n\
  \  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(LCtx ? LCtx->getDecl()\
  \ : nullptr);\n  if (!FD)\n    return;\n\n  // Focus on worker functions\n  if (!isWorkerFunction(FD))\n\
  \    return;\n\n  // Heuristic: only warn if the TU uses a timed wait\n  if (!SawTimedWaitInTU)\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n\n  bool Reported = false;\n\
  \  for (auto I = State->begin<CompUseMap>(), E = State->end<CompUseMap>(); I !=\
  \ E; ++I) {\n    const MemRegion *B = I->first;\n    unsigned Flags = I->second;\n\
  \n    if ((Flags & (SEEN_COMPLETE | SEEN_KFREE)) != 0 && (Flags & SEEN_DONE) ==\
  \ 0) {\n      const Stmt *Last = State->get<CompLastUseStmt>(B);\n      reportMissingGuard(B,\
  \ Last, C);\n      Reported = true;\n    }\n  }\n\n  // If we reported, we are done.\
  \ No need to mutate state here for now.\n  (void)Reported;\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects missing completion_done() guard in workqueue worker that may\
  \ race with submitter timeout and free\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ncrypto: qat - resolve race condition during AER recovery\n\
  \nDuring the PCI AER system's error recovery process, the kernel driver\nmay encounter\
  \ a race condition with freeing the reset_data structure's\nmemory. If the device\
  \ restart will take more than 10 seconds the function\nscheduling that restart will\
  \ exit due to a timeout, and the reset_data\nstructure will be freed. However, this\
  \ data structure is used for\ncompletion notification after the restart is completed,\
  \ which leads\nto a UAF bug.\n\nThis results in a KFENCE bug notice.\n\n  BUG: KFENCE:\
  \ use-after-free read in adf_device_reset_worker+0x38/0xa0 [intel_qat]\n  Use-after-free\
  \ read at 0x00000000bc56fddf (in kfence-#142):\n  adf_device_reset_worker+0x38/0xa0\
  \ [intel_qat]\n  process_one_work+0x173/0x340\n\nTo resolve this race condition,\
  \ the memory associated to the container\nof the work_struct is freed on the worker\
  \ if the timeout expired,\notherwise on the function that schedules the worker.\n\
  The timeout detection can be done by checking if the caller is\nstill waiting for\
  \ completion or not by using completion_done() function.\n\nFixes: d8cba25d2c68\
  \ (\"crypto: qat - Intel(R) QAT driver framework\")\nCc: <stable@vger.kernel.org>\n\
  Signed-off-by: Damian Muszynski <damian.muszynski@intel.com>\nReviewed-by: Giovanni\
  \ Cabiddu <giovanni.cabiddu@intel.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\n\
  \n## Buggy Code\n\n```c\n// Function: adf_device_reset_worker in drivers/crypto/intel/qat/qat_common/adf_aer.c\n\
  static void adf_device_reset_worker(struct work_struct *work)\n{\n\tstruct adf_reset_dev_data\
  \ *reset_data =\n\t\t  container_of(work, struct adf_reset_dev_data, reset_work);\n\
  \tstruct adf_accel_dev *accel_dev = reset_data->accel_dev;\n\tunsigned long wait_jiffies\
  \ = msecs_to_jiffies(10000);\n\tstruct adf_sriov_dev_data sriov_data;\n\n\tadf_dev_restarting_notify(accel_dev);\n\
  \tif (adf_dev_restart(accel_dev)) {\n\t\t/* The device hanged and we can't restart\
  \ it so stop here */\n\t\tdev_err(&GET_DEV(accel_dev), \"Restart device failed\\\
  n\");\n\t\tif (reset_data->mode == ADF_DEV_RESET_ASYNC)\n\t\t\tkfree(reset_data);\n\
  \t\tWARN(1, \"QAT: device restart failed. Device is unusable\\n\");\n\t\treturn;\n\
  \t}\n\n\tsriov_data.accel_dev = accel_dev;\n\tinit_completion(&sriov_data.compl);\n\
  \tINIT_WORK(&sriov_data.sriov_work, adf_device_sriov_worker);\n\tqueue_work(device_sriov_wq,\
  \ &sriov_data.sriov_work);\n\tif (wait_for_completion_timeout(&sriov_data.compl,\
  \ wait_jiffies))\n\t\tadf_pf2vf_notify_restarted(accel_dev);\n\n\tadf_dev_restarted_notify(accel_dev);\n\
  \tclear_bit(ADF_STATUS_RESTARTING, &accel_dev->status);\n\n\t/* The dev is back\
  \ alive. Notify the caller if in sync mode */\n\tif (reset_data->mode == ADF_DEV_RESET_SYNC)\n\
  \t\tcomplete(&reset_data->compl);\n\telse\n\t\tkfree(reset_data);\n}\n```\n\n```c\n\
  // Function: adf_slot_reset in drivers/crypto/intel/qat/qat_common/adf_aer.c\nstatic\
  \ pci_ers_result_t adf_slot_reset(struct pci_dev *pdev)\n{\n\tstruct adf_accel_dev\
  \ *accel_dev = adf_devmgr_pci_to_accel_dev(pdev);\n\tint res = 0;\n\n\tif (!accel_dev)\
  \ {\n\t\tpr_err(\"QAT: Can't find acceleration device\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\
  \t}\n\n\tif (!pdev->is_busmaster)\n\t\tpci_set_master(pdev);\n\tpci_restore_state(pdev);\n\
  \tpci_save_state(pdev);\n\tres = adf_dev_up(accel_dev, false);\n\tif (res && res\
  \ != -EALREADY)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tadf_reenable_sriov(accel_dev);\n\
  \tadf_pf2vf_notify_restarted(accel_dev);\n\tadf_dev_restarted_notify(accel_dev);\n\
  \tclear_bit(ADF_STATUS_RESTARTING, &accel_dev->status);\n\treturn PCI_ERS_RESULT_RECOVERED;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/crypto/intel/qat/qat_common/adf_aer.c\
  \ b/drivers/crypto/intel/qat/qat_common/adf_aer.c\nindex 3597e7605a14..9da2278bd5b7\
  \ 100644\n--- a/drivers/crypto/intel/qat/qat_common/adf_aer.c\n+++ b/drivers/crypto/intel/qat/qat_common/adf_aer.c\n\
  @@ -130,7 +130,8 @@ static void adf_device_reset_worker(struct work_struct *work)\n\
  \ \tif (adf_dev_restart(accel_dev)) {\n \t\t/* The device hanged and we can't restart\
  \ it so stop here */\n \t\tdev_err(&GET_DEV(accel_dev), \"Restart device failed\\\
  n\");\n-\t\tif (reset_data->mode == ADF_DEV_RESET_ASYNC)\n+\t\tif (reset_data->mode\
  \ == ADF_DEV_RESET_ASYNC ||\n+\t\t    completion_done(&reset_data->compl))\n \t\t\
  \tkfree(reset_data);\n \t\tWARN(1, \"QAT: device restart failed. Device is unusable\\\
  n\");\n \t\treturn;\n@@ -146,11 +147,19 @@ static void adf_device_reset_worker(struct\
  \ work_struct *work)\n \tadf_dev_restarted_notify(accel_dev);\n \tclear_bit(ADF_STATUS_RESTARTING,\
  \ &accel_dev->status);\n \n-\t/* The dev is back alive. Notify the caller if in\
  \ sync mode */\n-\tif (reset_data->mode == ADF_DEV_RESET_SYNC)\n-\t\tcomplete(&reset_data->compl);\n\
  -\telse\n+\t/*\n+\t * The dev is back alive. Notify the caller if in sync mode\n\
  +\t *\n+\t * If device restart will take a more time than expected,\n+\t * the schedule_reset()\
  \ function can timeout and exit. This can be\n+\t * detected by calling the completion_done()\
  \ function. In this case\n+\t * the reset_data structure needs to be freed here.\n\
  +\t */\n+\tif (reset_data->mode == ADF_DEV_RESET_ASYNC ||\n+\t    completion_done(&reset_data->compl))\n\
  \ \t\tkfree(reset_data);\n+\telse\n+\t\tcomplete(&reset_data->compl);\n }\n \n static\
  \ int adf_dev_aer_schedule_reset(struct adf_accel_dev *accel_dev,\n@@ -183,8 +192,9\
  \ @@ static int adf_dev_aer_schedule_reset(struct adf_accel_dev *accel_dev,\n \t\
  \t\tdev_err(&GET_DEV(accel_dev),\n \t\t\t\t\"Reset device timeout expired\\n\");\n\
  \ \t\t\tret = -EFAULT;\n+\t\t} else {\n+\t\t\tkfree(reset_data);\n \t\t}\n-\t\t\
  kfree(reset_data);\n \t\treturn ret;\n \t}\n \treturn 0;\n```\n"
pattern: "## Bug Pattern\n\nFreeing a work item\u2019s heap-allocated context from\
  \ the submitter after a timed wait while the queued worker still references that\
  \ context.\n\nConcretely:\n- A structure embedding work_struct and a completion\
  \ is allocated and queued to a workqueue.\n- The submitter waits with wait_for_completion_timeout().\n\
  - On timeout it frees the context.\n- The worker later dereferences the same context\
  \ (to complete() or kfree()), causing a use-after-free or double-free.\n\nRoot cause:\
  \ No ownership/serialization between the submitter and the worker about who frees\
  \ the shared context when the wait times out. The fix ensures only one side frees\
  \ it by checking completion_done() (or equivalent coordination) before using/freeing\
  \ the context."
plan: "Plan\n\n1. Program state customizations\n- REGISTER_MAP_WITH_PROGRAMSTATE(CompUseMap,\
  \ const MemRegion*, unsigned)\n  - Bitmask per context base-region:\n    - SEEN_COMPLETE\
  \ = 0x1  // complete(&ctx->compl) observed\n    - SEEN_KFREE    = 0x2  // kfree(ctx)\
  \ observed\n    - SEEN_DONE     = 0x4  // completion_done(&ctx->compl) observed\n\
  - REGISTER_MAP_WITH_PROGRAMSTATE(CompLastUseStmt, const MemRegion*, const Stmt*)\n\
  \  - Keep a source location (Stmt*) for the last interesting call (complete or kfree)\
  \ for bug reporting.\n\nNote: Keep the state strictly intra-procedural. No need\
  \ to persist across functions. To reduce false positives, also keep a checker member\
  \ flag:\n- bool SawTimedWaitInTU = false  // Set true if we ever see wait_for_completion_timeout\
  \ anywhere; used as a TU-wide heuristic gate.\n\n2. Callback selection and implementation\
  \ details\n\nA. checkBeginFunction(Ctx)\n- Purpose: Identify worker functions and\
  \ initialize per-function state (implicit, as maps start empty).\n- Implementation:\n\
  \  - Determine if the current function is a worker by inspecting its parameters:\n\
  \    - Iterate FunctionDecl->parameters, and if any parameter\u2019s pointee record\
  \ name equals \"work_struct\" (i.e., param type is struct work_struct *), mark a\
  \ local flag IsWorkerFn = true for this invocation. No need to store in program\
  \ state; you can recompute in checkEndFunction by querying the FunctionDecl again.\n\
  \nB. checkPostCall(const CallEvent &Call, CheckerContext &C)\n- Purpose: Track the\
  \ use of completion, timeout waits, and frees.\n- Extract callee name with Call.getCalleeIdentifier()->getName().\n\
  - Handle the following functions:\n\n  1) wait_for_completion_timeout\n     - If\
  \ callee name equals \"wait_for_completion_timeout\", set SawTimedWaitInTU = true.\n\
  \     - If first argument is a completion expression like &ctx->compl:\n       -\
  \ Retrieve base region B of the completion\u2019s base expression using:\n     \
  \    - If Arg0 is UnaryOperator(&) over MemberExpr (ctx->compl), use MemberExpr->getBase()\
  \ and getMemRegionFromExpr to obtain B.\n       - No need to set any flags here;\
  \ we only globally gate on SawTimedWaitInTU.\n\n  2) complete\n     - If callee\
  \ name equals \"complete\":\n       - If Arg0 is &ctx->compl, obtain base region\
  \ B as above.\n       - Update CompUseMap[B] |= SEEN_COMPLETE.\n       - Record\
  \ CompLastUseStmt[B] = Call.getOriginExpr() (or Call.getStmt()) for reporting.\n\
  \n  3) completion_done\n     - If callee name equals \"completion_done\":\n    \
  \   - If Arg0 is &ctx->compl, obtain base region B similarly.\n       - Update CompUseMap[B]\
  \ |= SEEN_DONE.\n\n  4) kfree\n     - If callee name equals \"kfree\":\n       -\
  \ Obtain base region B from Arg0 (the ctx pointer) using getMemRegionFromExpr.\n\
  \       - Update CompUseMap[B] |= SEEN_KFREE.\n       - Record CompLastUseStmt[B]\
  \ = Call.getOriginExpr() (or Call.getStmt()).\n\nNotes:\n- Robustly extract B:\n\
  \  - For complete/completion_done: expect Arg0 to be a UnaryOperator taking address\
  \ of a MemberExpr; use the MemberExpr->getBase() as the ctx expression and call\
  \ getMemRegionFromExpr on it.\n  - For kfree: directly call getMemRegionFromExpr\
  \ on Arg0.\n- Ignore cases where B is null (unknown region).\n\nC. checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C)\n- Purpose: At function exit, decide whether\
  \ to report based on the aggregated info in CompUseMap for this function.\n- Steps:\n\
  \  - Confirm the current function is a worker: inspect FunctionDecl parameters to\
  \ see if it has struct work_struct * parameter.\n  - If not a worker, return early.\n\
  \  - Optionally reduce noise: if SawTimedWaitInTU == false, return early (we only\
  \ warn when the translation unit uses wait_for_completion_timeout somewhere).\n\
  \  - Iterate over CompUseMap entries. For each base region B:\n    - Let Flags =\
  \ CompUseMap[B].\n    - If (Flags & (SEEN_COMPLETE | SEEN_KFREE)) != 0 AND (Flags\
  \ & SEEN_DONE) == 0:\n      - This worker either completes or frees the shared context\
  \ but never guards with completion_done(). This is the dangerous pattern when submitter\
  \ times out.\n      - Create a non-fatal error node and emit a PathSensitiveBugReport\
  \ at the location CompLastUseStmt[B] if present; otherwise at function location.\n\
  \      - Message: Missing completion_done() guard in worker; submitter with timed\
  \ wait may free the context.\n- Clear maps implicitly as function state ends.\n\n\
  3. Optional enhancement (low-cost heuristic to catch submitter misuse)\n- In the\
  \ same checkPostCall, track a lightweight submitter anti-pattern in-function (does\
  \ not require path reasoning):\n  - If we see a wait_for_completion_timeout(&ctx->compl,\
  \ ..) and later in the same function we see kfree(ctx), and there is no subsequent\
  \ call to completion_done(&ctx->compl) in the same function:\n    - This suggests\
  \ the submitter frees the context after a timed wait without coordination.\n   \
  \ - You can report a lower-severity warning in checkEndFunction for non-worker functions:\n\
  \      - Message: Context freed after wait_for_completion_timeout(); ensure worker\
  \ guards with completion_done() or free only on success.\n- This step is optional;\
  \ keep it off by default to minimize noise.\n\n4. Utilities used\n- getMemRegionFromExpr\
  \ to map expressions to MemRegion for stable identification of the shared context\
  \ pointer.\n- findSpecificTypeInParents / findSpecificTypeInChildren not strictly\
  \ necessary here.\n- ExprHasName not needed; we rely on callee names.\n- EvaluateExprToInt\
  \ and inferSymbolMaxVal not needed.\n\n5. Reporting\n- Create a single BugType at\
  \ checker construction time (e.g., \"Workqueue timed-wait UAF risk\").\n- Use generateNonFatalErrorNode\
  \ to create a node and std::make_unique<PathSensitiveBugReport> for reporting.\n\
  - Keep the message short and clear:\n  - \"Missing completion_done() guard in worker;\
  \ submitter with timed wait may free the context\"\n- Attach a range to the offending\
  \ call (kfree or complete) using CompLastUseStmt[B].\n\nWhy this detects the target\
  \ pattern\n- The bug arises when a worker completes or frees a shared context while\
  \ the submitter might have timed out and already freed that context. The kernel\
  \ fix added completion_done() checks before choosing between complete() and kfree(),\
  \ exactly what this checker enforces.\n- Restricting to worker functions (struct\
  \ work_struct * parameter) and requiring that the TU uses wait_for_completion_timeout\
  \ keeps false positives low while matching the scenario in the patch."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program states\nREGISTER_MAP_WITH_PROGRAMSTATE(CompUseMap,\
  \ const MemRegion*, unsigned)\nREGISTER_MAP_WITH_PROGRAMSTATE(CompLastUseStmt, const\
  \ MemRegion*, const Stmt*)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<\
  \ check::PostCall, check::EndFunction > {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   // Heuristic TU-wide gate: set true if we ever see wait_for_completion_timeout\n\
  \   mutable bool SawTimedWaitInTU = false;\n\n   // Flags for CompUseMap\n   static\
  \ constexpr unsigned SEEN_COMPLETE = 0x1;  // complete(&ctx->compl)\n   static constexpr\
  \ unsigned SEEN_KFREE    = 0x2;  // kfree(ctx)\n   static constexpr unsigned SEEN_DONE\
  \     = 0x4;  // completion_done(&ctx->compl)\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Workqueue timed-wait UAF risk\", \"Concurrency\")) {}\n\
  \n      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n  \
  \    void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;\n\n \
  \  private:\n      // Helpers\n      bool callIs(const CallEvent &Call, StringRef\
  \ Name, CheckerContext &C) const;\n      bool isWorkerFunction(const FunctionDecl\
  \ *FD) const;\n\n      ProgramStateRef setFlag(ProgramStateRef State, const MemRegion\
  \ *B, unsigned Flag) const;\n      ProgramStateRef setLastUse(ProgramStateRef State,\
  \ const MemRegion *B, const Stmt *S) const;\n\n      const MemRegion *getContextBaseFromCompletionArg(const\
  \ Expr *ArgE, CheckerContext &C) const;\n      const MemRegion *getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) const;\n\n      void reportMissingGuard(const MemRegion\
  \ *B, const Stmt *S, CheckerContext &C) const;\n};\n\n// Determine if Call refers\
  \ to a function with given name using source text.\nbool SAGenTestChecker::callIs(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) const {\n  const Expr *Origin\
  \ = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n  return ExprHasName(Origin,\
  \ Name, C);\n}\n\n// Identify worker function by parameter of type 'struct work_struct\
  \ *'\nbool SAGenTestChecker::isWorkerFunction(const FunctionDecl *FD) const {\n\
  \  if (!FD)\n    return false;\n\n  for (const ParmVarDecl *P : FD->parameters())\
  \ {\n    QualType QT = P->getType();\n    if (!QT->isPointerType())\n      continue;\n\
  \    QualType Pointee = QT->getPointeeType();\n    if (const RecordType *RT = Pointee->getAs<RecordType>())\
  \ {\n      const RecordDecl *RD = RT->getDecl();\n      IdentifierInfo *II = RD->getIdentifier();\n\
  \      if (II && II->getName() == \"work_struct\")\n        return true;\n    }\n\
  \  }\n  return false;\n}\n\n// Update flag bitmask for a given base region\nProgramStateRef\
  \ SAGenTestChecker::setFlag(ProgramStateRef State, const MemRegion *B, unsigned\
  \ Flag) const {\n  if (!B)\n    return State;\n  const unsigned *Old = State->get<CompUseMap>(B);\n\
  \  unsigned NewFlags = (Old ? *Old : 0) | Flag;\n  State = State->set<CompUseMap>(B,\
  \ NewFlags);\n  return State;\n}\n\n// Record the last interesting statement for\
  \ a region\nProgramStateRef SAGenTestChecker::setLastUse(ProgramStateRef State,\
  \ const MemRegion *B, const Stmt *S) const {\n  if (!B || !S)\n    return State;\n\
  \  State = State->set<CompLastUseStmt>(B, S);\n  return State;\n}\n\n// Get base\
  \ region for a pointer expression\nconst MemRegion *SAGenTestChecker::getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return nullptr;\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C);\n  if (!MR)\n    return nullptr;\n  return MR->getBaseRegion();\n\
  }\n\n// Extract the context base region from an argument expected to be &ctx->compl\
  \ or a pointer to a completion field.\n// Strategy: get region for the arg; if it's\
  \ a FieldRegion, use its super; otherwise use base.\nconst MemRegion *SAGenTestChecker::getContextBaseFromCompletionArg(const\
  \ Expr *ArgE, CheckerContext &C) const {\n  if (!ArgE)\n    return nullptr;\n\n\
  \  ProgramStateRef State = C.getState();\n  SVal V = State->getSVal(ArgE, C.getLocationContext());\n\
  \  const MemRegion *MR = V.getAsRegion();\n  if (!MR) {\n    MR = getMemRegionFromExpr(ArgE,\
  \ C);\n    if (!MR)\n      return nullptr;\n  }\n\n  MR = MR->getBaseRegion();\n\
  \  // If this is a field region (e.g., &ctx->compl), climb to its super region.\n\
  \  if (const FieldRegion *FR = dyn_cast<FieldRegion>(MR)) {\n    const MemRegion\
  \ *Super = FR->getSuperRegion();\n    if (Super)\n      return Super->getBaseRegion();\n\
  \  }\n  // Otherwise return the base region as best-effort.\n  return MR ? MR->getBaseRegion()\
  \ : nullptr;\n}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  // Heuristic gate: remember\
  \ if TU uses wait_for_completion_timeout\n  if (callIs(Call, \"wait_for_completion_timeout\"\
  , C)) {\n    SawTimedWaitInTU = true;\n    // No per-region state needed here.\n\
  \    return;\n  }\n\n  // Track complete(&ctx->compl)\n  if (callIs(Call, \"complete\"\
  , C)) {\n    const Expr *Arg0 = Call.getArgExpr(0);\n    const MemRegion *B = getContextBaseFromCompletionArg(Arg0,\
  \ C);\n    if (B) {\n      State = setFlag(State, B, SEEN_COMPLETE);\n      State\
  \ = setLastUse(State, B, Call.getOriginExpr());\n      C.addTransition(State);\n\
  \    }\n    return;\n  }\n\n  // Track completion_done(&ctx->compl)\n  if (callIs(Call,\
  \ \"completion_done\", C)) {\n    const Expr *Arg0 = Call.getArgExpr(0);\n    const\
  \ MemRegion *B = getContextBaseFromCompletionArg(Arg0, C);\n    if (B) {\n     \
  \ State = setFlag(State, B, SEEN_DONE);\n      C.addTransition(State);\n    }\n\
  \    return;\n  }\n\n  // Track kfree(ctx)\n  if (callIs(Call, \"kfree\", C)) {\n\
  \    const Expr *Arg0 = Call.getArgExpr(0);\n    const MemRegion *B = getBaseRegionFromExpr(Arg0,\
  \ C);\n    if (B) {\n      State = setFlag(State, B, SEEN_KFREE);\n      State =\
  \ setLastUse(State, B, Call.getOriginExpr());\n      C.addTransition(State);\n \
  \   }\n    return;\n  }\n}\n\nvoid SAGenTestChecker::reportMissingGuard(const MemRegion\
  \ *B, const Stmt *S, CheckerContext &C) const {\n  if (!BT)\n    return;\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Missing completion_done() guard in worker; submitter with timed wait\
  \ may free the context\", N);\n  if (S)\n    R->addRange(S->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C) const {\n  const LocationContext *LCtx = C.getLocationContext();\n\
  \  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(LCtx ? LCtx->getDecl()\
  \ : nullptr);\n  if (!FD)\n    return;\n\n  // Focus on worker functions\n  if (!isWorkerFunction(FD))\n\
  \    return;\n\n  // Heuristic: only warn if the TU uses a timed wait\n  if (!SawTimedWaitInTU)\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n\n  bool Reported = false;\n\
  \  CompUseMapTy Map = State->get<CompUseMap>();\n  for (CompUseMapTy::iterator I\
  \ = Map.begin(), E = Map.end(); I != E; ++I) {\n    const MemRegion *B = I->first;\n\
  \    unsigned Flags = I->second;\n\n    if ((Flags & (SEEN_COMPLETE | SEEN_KFREE))\
  \ != 0 && (Flags & SEEN_DONE) == 0) {\n      const Stmt *const *LastPtr = State->get<CompLastUseStmt>(B);\n\
  \      const Stmt *Last = LastPtr ? *LastPtr : nullptr;\n      reportMissingGuard(B,\
  \ Last, C);\n      Reported = true;\n    }\n  }\n\n  // If we reported, we are done.\
  \ No need to mutate state here for now.\n  (void)Reported;\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects missing completion_done() guard in workqueue worker that may\
  \ race with submitter timeout and free\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
