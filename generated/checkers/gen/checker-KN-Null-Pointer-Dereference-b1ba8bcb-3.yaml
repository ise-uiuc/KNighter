_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: b1ba8bcb2d1ffce11b308ce166c9cc28d989e3b9
commit_type: Null-Pointer-Dereference
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state: track optional-return symbols and regions holding them.\nREGISTER_MAP_WITH_PROGRAMSTATE(OptionalRetSyms,\
  \ SymbolRef, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(OptionalPtrRegions, const MemRegion*,\
  \ bool)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n\
  \        check::PreCall,\n        check::Bind,\n        check::Location> {\n\n \
  \ mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n      :\
  \ BT(std::make_unique<BugType>(this,\n                                     \"Optional\
  \ resource NULL dereference\",\n                                     \"Null Dereference\"\
  )) {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n  void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n  void checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n\
  \  bool isOptionalGetter(const CallEvent &Call, CheckerContext &C) const;\n  bool\
  \ maybeNullOnThisPath(const Expr *E, CheckerContext &C) const;\n  const MemRegion\
  \ *getTrackedRegion(const Expr *E, CheckerContext &C) const;\n\n  void reportDeref(const\
  \ Expr *BaseE, CheckerContext &C, StringRef Msg) const;\n};\n\nbool SAGenTestChecker::isOptionalGetter(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE)\n    return false;\n\n  QualType RetTy = Call.getResultType();\n  if\
  \ (RetTy.isNull() || !RetTy->isAnyPointerType())\n    return false;\n\n  // Recognize\
  \ known optional getters (names can be used directly via ExprHasName).\n  static\
  \ const char *Names[] = {\n      \"devm_gpiod_get_array_optional\",\n      \"gpiod_get_array_optional\"\
  ,\n      \"devm_gpiod_get_optional\",\n      \"gpiod_get_optional\",\n      \"fwnode_gpiod_get_optional\"\
  \n  };\n\n  for (const char *N : Names) {\n    if (ExprHasName(OE, N, C))\n    \
  \  return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::maybeNullOnThisPath(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n\n  ProgramStateRef\
  \ State = C.getState();\n  SVal PtrSV = State->getSVal(E, C.getLocationContext());\n\
  \n  if (!PtrSV.getAs<DefinedOrUnknownSVal>())\n    return false; // Non-sensical\n\
  \n  SValBuilder &SVB = C.getSValBuilder();\n  SVal NullSV = SVB.makeNull();\n\n\
  \  SVal EqV = SVB.evalEQ(State, PtrSV, NullSV);\n  if (EqV.isUndef())\n    return\
  \ false;\n\n  DefinedOrUnknownSVal EqDUV = EqV.castAs<DefinedOrUnknownSVal>();\n\
  \n  // If \"Ptr == NULL\" is feasible on this path, return true.\n  ProgramStateRef\
  \ ST = State->assume(EqDUV, true);\n  if (ST)\n    return true;\n\n  return false;\n\
  }\n\nconst MemRegion *SAGenTestChecker::getTrackedRegion(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E)\n    return nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR)\n    return nullptr;\n  return MR->getBaseRegion();\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  if (!isOptionalGetter(Call, C))\n    return;\n\n  ProgramStateRef State =\
  \ C.getState();\n  SVal Ret = Call.getReturnValue();\n  if (SymbolRef Sym = Ret.getAsSymbol())\
  \ {\n    State = State->set<OptionalRetSyms>(Sym, true);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  const auto *MRV = Loc.getAs<loc::MemRegionVal>();\n  if (!MRV)\n\
  \    return;\n\n  const MemRegion *DestR = MRV->getRegion();\n  if (!DestR)\n  \
  \  return;\n  DestR = DestR->getBaseRegion();\n  if (!DestR)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n\n  bool ComesFromOptional = false;\n\n  // Case A: RHS\
  \ is a symbol tagged as an optional getter result.\n  if (SymbolRef Sym = Val.getAsSymbol())\
  \ {\n    if (const bool *Found = State->get<OptionalRetSyms>(Sym)) {\n      (void)Found;\n\
  \      ComesFromOptional = true;\n    }\n  }\n\n  // Case B: RHS is a region already\
  \ tracked as optional-origin (alias propagation).\n  if (!ComesFromOptional) {\n\
  \    if (const MemRegion *SrcR = Val.getAsRegion()) {\n      SrcR = SrcR->getBaseRegion();\n\
  \      if (SrcR) {\n        if (const bool *Tracked = State->get<OptionalPtrRegions>(SrcR))\
  \ {\n          (void)Tracked;\n          ComesFromOptional = true;\n        }\n\
  \      }\n    }\n  }\n\n  if (ComesFromOptional) {\n    State = State->set<OptionalPtrRegions>(DestR,\
  \ true);\n  } else {\n    // Overwriting with an unrelated value clears the origin\
  \ tag.\n    if (State->contains<OptionalPtrRegions>(DestR)) {\n      State = State->remove<OptionalPtrRegions>(DestR);\n\
  \    }\n  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::reportDeref(const\
  \ Expr *BaseE, CheckerContext &C, StringRef Msg) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  if (BaseE)\n    R->addRange(BaseE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\
  \ CheckerContext &C) const {\n  // Look for dereferences via \"->\" on a tracked\
  \ optional pointer.\n  if (!S)\n    return;\n\n  // Find enclosing MemberExpr using\
  \ \"->\".\n  const MemberExpr *ME = findSpecificTypeInParents<MemberExpr>(S, C);\n\
  \  if (!ME) {\n    // Sometimes the statement itself is a MemberExpr.\n    ME =\
  \ dyn_cast<MemberExpr>(S);\n    if (!ME)\n      return;\n  }\n\n  if (!ME->isArrow())\n\
  \    return;\n\n  const Expr *BaseE = ME->getBase();\n  if (!BaseE)\n    return;\n\
  \  BaseE = BaseE->IgnoreParenCasts();\n\n  const MemRegion *BaseR = getTrackedRegion(BaseE,\
  \ C);\n  if (!BaseR)\n    return;\n\n  ProgramStateRef State = C.getState();\n \
  \ const bool *Tracked = State->get<OptionalPtrRegions>(BaseR);\n  if (!Tracked)\n\
  \    return;\n\n  // If this optional resource may be NULL on this path, report.\n\
  \  if (maybeNullOnThisPath(BaseE, C)) {\n    reportDeref(BaseE, C, \"Possible NULL\
  \ deref of optional resource\");\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  llvm::SmallVector<unsigned, 4>\
  \ DerefParams;\n  if (!functionKnownToDeref(Call, DerefParams))\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n\n  for (unsigned Idx : DerefParams) {\n\
  \    if (Idx >= Call.getNumArgs())\n      continue;\n\n    const Expr *ArgE = Call.getArgExpr(Idx);\n\
  \    if (!ArgE)\n      continue;\n\n    const MemRegion *ArgR = getTrackedRegion(ArgE,\
  \ C);\n    if (!ArgR)\n      continue;\n\n    if (!State->contains<OptionalPtrRegions>(ArgR))\n\
  \      continue;\n\n    if (maybeNullOnThisPath(ArgE, C)) {\n      ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n      if (!N)\n        return;\n      auto\
  \ R = std::make_unique<PathSensitiveBugReport>(\n          *BT, \"NULL optional\
  \ resource passed to a function that dereferences it\", N);\n      R->addRange(ArgE->getSourceRange());\n\
  \      C.emitReport(std::move(R));\n    }\n  }\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects dereferencing optional resources\
  \ returned by *_get_optional without NULL checks\",\n      \"\");\n}\n\nextern \"\
  C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbacklight: hx8357: Fix potential NULL pointer dereference\n\
  \nThe \"im\" pins are optional. Add missing check in the hx8357_probe().\n\nReported-by:\
  \ Dan Carpenter <dan.carpenter@linaro.org>\nCloses: https://lore.kernel.org/r/642e1230-3358-4006-a17f-3f297897ae74@moroto.mountain\n\
  Fixes: 7d84a63a39b7 (\"backlight: hx8357: Convert to agnostic GPIO API\")\nSigned-off-by:\
  \ Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nReviewed-by: Daniel Thompson\
  \ <daniel.thompson@linaro.org>\nLink: https://lore.kernel.org/r/20240114143921.550736-1-andriy.shevchenko@linux.intel.com\n\
  Signed-off-by: Lee Jones <lee@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ hx8357_probe in drivers/video/backlight/hx8357.c\nstatic int hx8357_probe(struct\
  \ spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct lcd_device *lcdev;\n\
  \tstruct hx8357_data *lcd;\n\tconst struct of_device_id *match;\n\tint i, ret;\n\
  \n\tlcd = devm_kzalloc(&spi->dev, sizeof(*lcd), GFP_KERNEL);\n\tif (!lcd)\n\t\t\
  return -ENOMEM;\n\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev,\
  \ \"SPI setup failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tlcd->spi = spi;\n\n\tmatch\
  \ = of_match_device(hx8357_dt_ids, &spi->dev);\n\tif (!match || !match->data)\n\t\
  \treturn -EINVAL;\n\n\tlcd->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\
  \tif (IS_ERR(lcd->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(lcd->reset), \"\
  failed to request reset GPIO\\n\");\n\tgpiod_set_consumer_name(lcd->reset, \"hx8357-reset\"\
  );\n\n\tlcd->im_pins = devm_gpiod_get_array_optional(dev, \"im\", GPIOD_OUT_LOW);\n\
  \tif (IS_ERR(lcd->im_pins))\n\t\treturn dev_err_probe(dev, PTR_ERR(lcd->im_pins),\
  \ \"failed to request im GPIOs\\n\");\n\tif (lcd->im_pins->ndescs < HX8357_NUM_IM_PINS)\n\
  \t\treturn dev_err_probe(dev, -EINVAL, \"not enough im GPIOs\\n\");\n\n\tfor (i\
  \ = 0; i < HX8357_NUM_IM_PINS; i++)\n\t\tgpiod_set_consumer_name(lcd->im_pins->desc[i],\
  \ \"im_pins\");\n\n\tlcdev = devm_lcd_device_register(&spi->dev, \"mxsfb\", &spi->dev,\
  \ lcd,\n\t\t\t\t\t&hx8357_ops);\n\tif (IS_ERR(lcdev)) {\n\t\tret = PTR_ERR(lcdev);\n\
  \t\treturn ret;\n\t}\n\tspi_set_drvdata(spi, lcdev);\n\n\thx8357_lcd_reset(lcdev);\n\
  \n\tret = ((int (*)(struct lcd_device *))match->data)(lcdev);\n\tif (ret) {\n\t\t\
  dev_err(&spi->dev, \"Couldn't initialize panel\\n\");\n\t\treturn ret;\n\t}\n\n\t\
  dev_info(&spi->dev, \"Panel probed\\n\");\n\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\
  \n```diff\ndiff --git a/drivers/video/backlight/hx8357.c b/drivers/video/backlight/hx8357.c\n\
  index d7298376cf74..bf18337ff0c2 100644\n--- a/drivers/video/backlight/hx8357.c\n\
  +++ b/drivers/video/backlight/hx8357.c\n@@ -609,11 +609,13 @@ static int hx8357_probe(struct\
  \ spi_device *spi)\n \tlcd->im_pins = devm_gpiod_get_array_optional(dev, \"im\"\
  , GPIOD_OUT_LOW);\n \tif (IS_ERR(lcd->im_pins))\n \t\treturn dev_err_probe(dev,\
  \ PTR_ERR(lcd->im_pins), \"failed to request im GPIOs\\n\");\n-\tif (lcd->im_pins->ndescs\
  \ < HX8357_NUM_IM_PINS)\n-\t\treturn dev_err_probe(dev, -EINVAL, \"not enough im\
  \ GPIOs\\n\");\n+\tif (lcd->im_pins) {\n+\t\tif (lcd->im_pins->ndescs < HX8357_NUM_IM_PINS)\n\
  +\t\t\treturn dev_err_probe(dev, -EINVAL, \"not enough im GPIOs\\n\");\n \n-\tfor\
  \ (i = 0; i < HX8357_NUM_IM_PINS; i++)\n-\t\tgpiod_set_consumer_name(lcd->im_pins->desc[i],\
  \ \"im_pins\");\n+\t\tfor (i = 0; i < HX8357_NUM_IM_PINS; i++)\n+\t\t\tgpiod_set_consumer_name(lcd->im_pins->desc[i],\
  \ \"im_pins\");\n+\t}\n \n \tlcdev = devm_lcd_device_register(&spi->dev, \"mxsfb\"\
  , &spi->dev, lcd,\n \t\t\t\t\t&hx8357_ops);\n```\n"
pattern: "## Bug Pattern\n\nDereferencing the return value of an \u201Coptional\u201D\
  \ resource getter without checking for NULL. In this case, devm_gpiod_get_array_optional()\
  \ can return:\n- an error via ERR_PTR (handled by IS_ERR()), or\n- NULL when the\
  \ resource is simply absent (expected for optional resources).\n\nThe code only\
  \ checked IS_ERR() and then immediately accessed fields (e.g., im_pins->ndescs,\
  \ im_pins->desc[i]), leading to a potential NULL pointer dereference when the optional\
  \ GPIO array is not provided."
plan: "Plan\n\n1) Program state customization\n- REGISTER_MAP_WITH_PROGRAMSTATE(OptionalRetSyms,\
  \ SymbolRef, bool)\n  - Tracks which return-value symbols come from \u201Coptional\u201D\
  \ getters (value is unused).\n- REGISTER_MAP_WITH_PROGRAMSTATE(OptionalPtrRegions,\
  \ const MemRegion*, bool)\n  - Tracks pointer regions (variables, fields, elements)\
  \ that currently hold a pointer originating from an \u201Coptional\u201D getter\
  \ (value is unused).\n\nRationale: We first tag the symbolic return value, then\
  \ propagate that tag to the destination region at bindings (initializations/assignments).\
  \ We only need to know \u201Coriginates from optional getter\u201D to decide whether\
  \ a dereference is unsafe if the value may be NULL.\n\n2) Helper utilities\n- isOptionalGetter(const\
  \ CallEvent &Call)\n  - Return true when callee is one of:\n    - \"devm_gpiod_get_array_optional\"\
  \n    - \"gpiod_get_array_optional\"\n    - \"devm_gpiod_get_optional\"\n    - \"\
  gpiod_get_optional\"\n    - \"fwnode_gpiod_get_optional\"\n  - Only proceed if the\
  \ return type is a pointer type (Call.getResultType()->isPointerType()).\n- maybeNullOnThisPath(const\
  \ Expr *E, CheckerContext &C)\n  - Let SVal Ptr = C.getState()->getSVal(E, C.getLocationContext()).\n\
  \  - If Ptr is not a DefinedOrUnknownSVal, return false.\n  - Use SValBuilder &SVB\
  \ = C.getSValBuilder().\n  - Compute Eq = SVB.evalEQ(State, Ptr, SVB.makeNull()).\n\
  \  - If Eq is Unknown, conservatively return true.\n  - If State->assume(Eq, true)\
  \ is non-null (i.e., \"Ptr == NULL\" is feasible), return true; else false.\n- getTrackedRegion(const\
  \ Expr *E, CheckerContext &C)\n  - Use getMemRegionFromExpr(E, C) to get region\
  \ of E.\n- Optionally, for deref sites: find base pointer Expr from a MemberExpr\
  \ \"->\" using findSpecificTypeInParents<MemberExpr>(S, C) and then ME->getBase()->IgnoreParenCasts().\n\
  \n3) checkPostCall (mark return symbols of optional getters)\n- If isOptionalGetter(Call):\n\
  \  - Get return value SVal Ret = Call.getReturnValue().\n  - If Ret has a SymbolRef\
  \ (Ret.getAsSymbol()), add it into OptionalRetSyms map.\n  - No bug report here;\
  \ just mark origin.\n\n4) checkBind (propagate origin to the bound region and aliasing)\n\
  - Extract destination region:\n  - If Loc is a loc::MemRegionVal MR, set DestR =\
  \ MR->getRegion().\n  - If no region, return.\n- Determine if RHS Val comes from\
  \ optional getter origin:\n  - Case A: RHS is a symbol and in OptionalRetSyms.\n\
  \  - Case B: RHS is a loc::MemRegionVal to some region SrcR and SrcR is in OptionalPtrRegions\
  \ (alias propagation).\n- If A or B: add (DestR, true) to OptionalPtrRegions.\n\
  - Else: if DestR is present in OptionalPtrRegions and RHS is not tracked, remove\
  \ DestR from OptionalPtrRegions (overwriting with an unrelated value clears the\
  \ origin).\n- Note: This handles both variable initialization and assignments, including\
  \ field assignments like lcd->im_pins = ...\n\n5) checkLocation (detect pointer\
  \ dereference through \u201C->\u201D)\n- Trigger: on any load/store. We are interested\
  \ in derefs such as ptr->field (MemberExpr with isArrow()) and, optionally, array\
  \ element deref off a pointer base (ArraySubscriptExpr). Keep it simple and focus\
  \ on MemberExpr \u201C->\u201D.\n- From the incoming Stmt* S, try to find the enclosing\
  \ MemberExpr via findSpecificTypeInParents<MemberExpr>(S, C).\n  - If not found,\
  \ return.\n  - If found but not ME->isArrow(), return.\n- Let BaseE = ME->getBase()->IgnoreParenCasts().\n\
  - Get the base region R = getMemRegionFromExpr(BaseE, C).\n  - If R is not in OptionalPtrRegions,\
  \ return.\n- Check potential NULL on this path:\n  - If maybeNullOnThisPath(BaseE,\
  \ C) is true, report a bug:\n    - Message: \"Possible NULL deref of optional resource\"\
  \n    - Create a non-fatal error node and a PathSensitiveBugReport.\n    - Highlight\
  \ BaseE source range if available.\n\nRationale: If only IS_ERR() was checked earlier,\
  \ the analyzer still allows BaseE to be NULL on the fall-through path; thus we can\
  \ flag this as a potential NULL deref.\n\n6) checkPreCall (passing optional pointer\
  \ to a function that dereferences it)\n- Before the call:\n  - Use functionKnownToDeref(Call,\
  \ DerefParams) to get indices of parameters that are dereferenced by callee.\n \
  \ - For each such index i:\n    - Let ArgE = Call.getArgExpr(i).\n    - Get region\
  \ R = getMemRegionFromExpr(ArgE, C). If R not in OptionalPtrRegions, continue.\n\
  \    - If maybeNullOnThisPath(ArgE, C) is true, report:\n      - Message: \"NULL\
  \ optional resource passed to a function that dereferences it\"\n      - Non-fatal\
  \ error node, PathSensitiveBugReport.\n- This catches passing optional pointers\
  \ (possibly NULL) to known-deref APIs (e.g., where the core will dereference the\
  \ pointer).\n\n7) Optional: pruning false positives with explicit null checks\n\
  - Not required. Path-sensitivity plus maybeNullOnThisPath prevents reports in branches\
  \ that proved non-NULL. We do not need to explicitly track null-checks or IS_ERR\
  \ checks in program state.\n\n8) Bug reporting\n- Maintain a BugType member (lazy-initialized)\
  \ like \u201COptionalResourceNullDeref\u201D.\n- Use generateNonFatalErrorNode(C)\
  \ and create PathSensitiveBugReport with short, clear messages:\n  - For deref:\
  \ \"Possible NULL deref of optional resource\"\n  - For call arg: \"NULL optional\
  \ resource passed to a function that dereferences it\"\n- Add a source range to\
  \ the report:\n  - For deref: BaseE->getSourceRange()\n  - For call arg: ArgE->getSourceRange()\n\
  \n9) Summary of the flow on the target patch\n- Post-call to devm_gpiod_get_array_optional\
  \ marks return symbol as optional-origin.\n- Binding to lcd->im_pins records the\
  \ field region in OptionalPtrRegions.\n- Accessing lcd->im_pins->ndescs triggers\
  \ checkLocation:\n  - Base is lcd->im_pins, tracked as optional-origin.\n  - maybeNullOnThisPath\
  \ evaluates true if code only checked IS_ERR() (i.e., NULL still feasible).\n  -\
  \ Emit: \"Possible NULL deref of optional resource\"."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include <optional>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// Program state: track optional-return symbols and regions holding\
  \ them.\nREGISTER_MAP_WITH_PROGRAMSTATE(OptionalRetSyms, SymbolRef, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(OptionalPtrRegions,\
  \ const MemRegion*, bool)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::PostCall,\n        check::PreCall,\n        check::Bind,\n     \
  \   check::Location> {\n\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n\
  \      : BT(std::make_unique<BugType>(this,\n                                  \
  \   \"Optional resource NULL dereference\",\n                                  \
  \   \"Null Dereference\")) {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \  void checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\
  \nprivate:\n  // Helpers\n  bool isOptionalGetter(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  bool maybeNullOnThisPath(const Expr *E, CheckerContext &C) const;\n\
  \  const MemRegion *getTrackedRegion(const Expr *E, CheckerContext &C) const;\n\n\
  \  void reportDeref(const Expr *BaseE, CheckerContext &C, StringRef Msg) const;\n\
  };\n\nbool SAGenTestChecker::isOptionalGetter(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  const Expr *OE = Call.getOriginExpr();\n  if (!OE)\n    return\
  \ false;\n\n  QualType RetTy = Call.getResultType();\n  if (RetTy.isNull() || !RetTy->isAnyPointerType())\n\
  \    return false;\n\n  // Recognize known optional getters (names can be used directly\
  \ via ExprHasName).\n  static const char *Names[] = {\n      \"devm_gpiod_get_array_optional\"\
  ,\n      \"gpiod_get_array_optional\",\n      \"devm_gpiod_get_optional\",\n   \
  \   \"gpiod_get_optional\",\n      \"fwnode_gpiod_get_optional\"\n  };\n\n  for\
  \ (const char *N : Names) {\n    if (ExprHasName(OE, N, C))\n      return true;\n\
  \  }\n  return false;\n}\n\nbool SAGenTestChecker::maybeNullOnThisPath(const Expr\
  \ *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n\n  ProgramStateRef\
  \ State = C.getState();\n  SVal PtrSV = State->getSVal(E, C.getLocationContext());\n\
  \n  if (!PtrSV.getAs<DefinedOrUnknownSVal>())\n    return false; // Non-sensical\n\
  \n  SValBuilder &SVB = C.getSValBuilder();\n  // Create a zero value of the expression's\
  \ type, which corresponds to NULL for pointers.\n  SVal NullSV = SVB.makeZeroVal(E->getType());\n\
  \n  SVal EqV = SVB.evalEQ(State, PtrSV, NullSV);\n  if (EqV.isUndef())\n    return\
  \ false;\n\n  DefinedOrUnknownSVal EqDUV = EqV.castAs<DefinedOrUnknownSVal>();\n\
  \n  // If \"Ptr == NULL\" is feasible on this path, return true.\n  ProgramStateRef\
  \ ST = State->assume(EqDUV, true);\n  if (ST)\n    return true;\n\n  return false;\n\
  }\n\nconst MemRegion *SAGenTestChecker::getTrackedRegion(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E)\n    return nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR)\n    return nullptr;\n  return MR->getBaseRegion();\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  if (!isOptionalGetter(Call, C))\n    return;\n\n  ProgramStateRef State =\
  \ C.getState();\n  SVal Ret = Call.getReturnValue();\n  if (SymbolRef Sym = Ret.getAsSymbol())\
  \ {\n    State = State->set<OptionalRetSyms>(Sym, true);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  std::optional<loc::MemRegionVal> MRV = Loc.getAs<loc::MemRegionVal>();\n\
  \  if (!MRV)\n    return;\n\n  const MemRegion *DestR = MRV->getRegion();\n  if\
  \ (!DestR)\n    return;\n  DestR = DestR->getBaseRegion();\n  if (!DestR)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n\n  bool ComesFromOptional = false;\n\
  \n  // Case A: RHS is a symbol tagged as an optional getter result.\n  if (SymbolRef\
  \ Sym = Val.getAsSymbol()) {\n    if (const bool *Found = State->get<OptionalRetSyms>(Sym))\
  \ {\n      (void)Found;\n      ComesFromOptional = true;\n    }\n  }\n\n  // Case\
  \ B: RHS is a region already tracked as optional-origin (alias propagation).\n \
  \ if (!ComesFromOptional) {\n    if (const MemRegion *SrcR = Val.getAsRegion())\
  \ {\n      SrcR = SrcR->getBaseRegion();\n      if (SrcR) {\n        if (const bool\
  \ *Tracked = State->get<OptionalPtrRegions>(SrcR)) {\n          (void)Tracked;\n\
  \          ComesFromOptional = true;\n        }\n      }\n    }\n  }\n\n  if (ComesFromOptional)\
  \ {\n    State = State->set<OptionalPtrRegions>(DestR, true);\n  } else {\n    //\
  \ Overwriting with an unrelated value clears the origin tag.\n    State = State->remove<OptionalPtrRegions>(DestR);\n\
  \  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::reportDeref(const\
  \ Expr *BaseE, CheckerContext &C, StringRef Msg) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  if (BaseE)\n    R->addRange(BaseE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\
  \ CheckerContext &C) const {\n  // Look for dereferences via \"->\" on a tracked\
  \ optional pointer.\n  if (!S)\n    return;\n\n  // Find enclosing MemberExpr using\
  \ \"->\".\n  const MemberExpr *ME = findSpecificTypeInParents<MemberExpr>(S, C);\n\
  \  if (!ME) {\n    // Sometimes the statement itself is a MemberExpr.\n    ME =\
  \ dyn_cast<MemberExpr>(S);\n    if (!ME)\n      return;\n  }\n\n  if (!ME->isArrow())\n\
  \    return;\n\n  const Expr *BaseE = ME->getBase();\n  if (!BaseE)\n    return;\n\
  \  BaseE = BaseE->IgnoreParenCasts();\n\n  const MemRegion *BaseR = getTrackedRegion(BaseE,\
  \ C);\n  if (!BaseR)\n    return;\n\n  ProgramStateRef State = C.getState();\n \
  \ const bool *Tracked = State->get<OptionalPtrRegions>(BaseR);\n  if (!Tracked)\n\
  \    return;\n\n  // If this optional resource may be NULL on this path, report.\n\
  \  if (maybeNullOnThisPath(BaseE, C)) {\n    reportDeref(BaseE, C, \"Possible NULL\
  \ deref of optional resource\");\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  llvm::SmallVector<unsigned, 4>\
  \ DerefParams;\n  if (!functionKnownToDeref(Call, DerefParams))\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n\n  for (unsigned Idx : DerefParams) {\n\
  \    if (Idx >= Call.getNumArgs())\n      continue;\n\n    const Expr *ArgE = Call.getArgExpr(Idx);\n\
  \    if (!ArgE)\n      continue;\n\n    const MemRegion *ArgR = getTrackedRegion(ArgE,\
  \ C);\n    if (!ArgR)\n      continue;\n\n    if (!State->get<OptionalPtrRegions>(ArgR))\n\
  \      continue;\n\n    if (maybeNullOnThisPath(ArgE, C)) {\n      ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n      if (!N)\n        return;\n      auto\
  \ R = std::make_unique<PathSensitiveBugReport>(\n          *BT, \"NULL optional\
  \ resource passed to a function that dereferences it\", N);\n      R->addRange(ArgE->getSourceRange());\n\
  \      C.emitReport(std::move(R));\n    }\n  }\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects dereferencing optional resources\
  \ returned by *_get_optional without NULL checks\",\n      \"\");\n}\n\nextern \"\
  C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
