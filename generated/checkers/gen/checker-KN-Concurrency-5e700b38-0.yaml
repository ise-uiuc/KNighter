_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 5e700b384ec13f5bcac9855cb28fcc674f1d3593
commit_type: Concurrency
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Track serdev devices whose client ops have been set.\nREGISTER_SET_WITH_PROGRAMSTATE(SerdevOpsSet,\
  \ const MemRegion *)\n// Track serdev devices we already reported on this path to\
  \ avoid duplicates.\nREGISTER_SET_WITH_PROGRAMSTATE(SerdevReported, const MemRegion\
  \ *)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall, check::PostCall>\
  \ {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker() : BT(new\
  \ BugType(this, \"Serdev open before ops\", \"API Misuse\")) {}\n\n  void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\nprivate:\n  // Helper to fetch the base MemRegion\
  \ from a call argument expression.\n  const MemRegion *getBaseRegionFromArg(const\
  \ CallEvent &Call, unsigned Idx,\n                                        CheckerContext\
  \ &C) const {\n    if (Idx >= Call.getNumArgs())\n      return nullptr;\n    const\
  \ Expr *ArgE = Call.getArgExpr(Idx);\n    if (!ArgE)\n      return nullptr;\n  \
  \  const MemRegion *MR = getMemRegionFromExpr(ArgE, C);\n    if (!MR)\n      return\
  \ nullptr;\n    return MR->getBaseRegion();\n  }\n};\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return;\n\n  // Mark ops as set for the given serdev device.\n\
  \  if (!ExprHasName(Origin, \"serdev_device_set_client_ops\", C))\n    return;\n\
  \n  const MemRegion *SerdevMR = getBaseRegionFromArg(Call, 0, C);\n  if (!SerdevMR)\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  State = State->add<SerdevOpsSet>(SerdevMR);\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return;\n\n  bool IsDevmOpen = ExprHasName(Origin, \"devm_serdev_device_open\"\
  , C);\n  bool IsOpen = ExprHasName(Origin, \"serdev_device_open\", C);\n  if (!IsDevmOpen\
  \ && !IsOpen)\n    return;\n\n  unsigned SerdevIdx = IsDevmOpen ? 1u : 0u;\n  const\
  \ MemRegion *SerdevMR = getBaseRegionFromArg(Call, SerdevIdx, C);\n  if (!SerdevMR)\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  // If ops are already\
  \ set, everything is fine.\n  if (State->contains<SerdevOpsSet>(SerdevMR))\n   \
  \ return;\n\n  // Avoid duplicate reports on the same path.\n  if (State->contains<SerdevReported>(SerdevMR))\n\
  \    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode(State);\n  if (!N)\n\
  \    return;\n\n  // Tailor the message to the specific open function used.\n  StringRef\
  \ OpenName = IsDevmOpen ? \"devm_serdev_device_open()\" : \"serdev_device_open()\"\
  ;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, (OpenName +\
  \ \" called before serdev_device_set_client_ops(); callbacks may deref NULL ops\"\
  ).str(), N);\n\n  // Highlight the call site.\n  R->addRange(Origin->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n\n  // Mark as reported to avoid duplicates and\
  \ transition the state.\n  State = State->add<SerdevReported>(SerdevMR);\n  C.addTransition(State);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects serdev ports opened before client ops are set, which may cause\
  \ NULL ops dereference\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nplatform/chrome: cros_ec_uart: properly fix race condition\n\
  \nThe cros_ec_uart_probe() function calls devm_serdev_device_open() before\nit calls\
  \ serdev_device_set_client_ops(). This can trigger a NULL pointer\ndereference:\n\
  \n    BUG: kernel NULL pointer dereference, address: 0000000000000000\n    ...\n\
  \    Call Trace:\n     <TASK>\n     ...\n     ? ttyport_receive_buf\n\nA simplified\
  \ version of crashing code is as follows:\n\n    static inline size_t serdev_controller_receive_buf(struct\
  \ serdev_controller *ctrl,\n                                                   \
  \   const u8 *data,\n                                                      size_t\
  \ count)\n    {\n            struct serdev_device *serdev = ctrl->serdev;\n\n  \
  \          if (!serdev || !serdev->ops->receive_buf) // CRASH!\n               \
  \ return 0;\n\n            return serdev->ops->receive_buf(serdev, data, count);\n\
  \    }\n\nIt assumes that if SERPORT_ACTIVE is set and serdev exists, serdev->ops\n\
  will also exist. This conflicts with the existing cros_ec_uart_probe()\nlogic, as\
  \ it first calls devm_serdev_device_open() (which sets\nSERPORT_ACTIVE), and only\
  \ later sets serdev->ops via\nserdev_device_set_client_ops().\n\nCommit 01f95d42b8f4\
  \ (\"platform/chrome: cros_ec_uart: fix race\ncondition\") attempted to fix a similar\
  \ race condition, but while doing\nso, made the window of error for this race condition\
  \ to happen much\nwider.\n\nAttempt to fix the race condition again, making sure\
  \ we fully setup\nbefore calling devm_serdev_device_open().\n\nFixes: 01f95d42b8f4\
  \ (\"platform/chrome: cros_ec_uart: fix race condition\")\nCc: stable@vger.kernel.org\n\
  Signed-off-by: Noah Loomans <noah@noahloomans.com>\nReviewed-by: Guenter Roeck <groeck@chromium.org>\n\
  Link: https://lore.kernel.org/r/20240410182618.169042-2-noah@noahloomans.com\nSigned-off-by:\
  \ Tzung-Bi Shih <tzungbi@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: cros_ec_uart_probe\
  \ in drivers/platform/chrome/cros_ec_uart.c\nstatic int cros_ec_uart_probe(struct\
  \ serdev_device *serdev)\n{\n\tstruct device *dev = &serdev->dev;\n\tstruct cros_ec_device\
  \ *ec_dev;\n\tstruct cros_ec_uart *ec_uart;\n\tint ret;\n\n\tec_uart = devm_kzalloc(dev,\
  \ sizeof(*ec_uart), GFP_KERNEL);\n\tif (!ec_uart)\n\t\treturn -ENOMEM;\n\n\tec_dev\
  \ = devm_kzalloc(dev, sizeof(*ec_dev), GFP_KERNEL);\n\tif (!ec_dev)\n\t\treturn\
  \ -ENOMEM;\n\n\tret = devm_serdev_device_open(dev, serdev);\n\tif (ret) {\n\t\t\
  dev_err(dev, \"Unable to open UART device\");\n\t\treturn ret;\n\t}\n\n\tserdev_device_set_drvdata(serdev,\
  \ ec_dev);\n\tinit_waitqueue_head(&ec_uart->response.wait_queue);\n\n\tec_uart->serdev\
  \ = serdev;\n\n\tret = cros_ec_uart_acpi_probe(ec_uart);\n\tif (ret < 0) {\n\t\t\
  dev_err(dev, \"Failed to get ACPI info (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\t\
  ret = serdev_device_set_baudrate(serdev, ec_uart->baudrate);\n\tif (ret < 0) {\n\
  \t\tdev_err(dev, \"Failed to set up host baud rate (%d)\", ret);\n\t\treturn ret;\n\
  \t}\n\n\tserdev_device_set_flow_control(serdev, ec_uart->flowcontrol);\n\n\t/* Initialize\
  \ ec_dev for cros_ec  */\n\tec_dev->phys_name = dev_name(dev);\n\tec_dev->dev =\
  \ dev;\n\tec_dev->priv = ec_uart;\n\tec_dev->irq = ec_uart->irq;\n\tec_dev->cmd_xfer\
  \ = NULL;\n\tec_dev->pkt_xfer = cros_ec_uart_pkt_xfer;\n\tec_dev->din_size = sizeof(struct\
  \ ec_host_response) +\n\t\t\t   sizeof(struct ec_response_get_protocol_info);\n\t\
  ec_dev->dout_size = sizeof(struct ec_host_request);\n\n\tserdev_device_set_client_ops(serdev,\
  \ &cros_ec_uart_client_ops);\n\n\treturn cros_ec_register(ec_dev);\n}\n```\n\n##\
  \ Bug Fix Patch\n\n```diff\ndiff --git a/drivers/platform/chrome/cros_ec_uart.c\
  \ b/drivers/platform/chrome/cros_ec_uart.c\nindex 68d80559fddc..eb5eddeb73f7 100644\n\
  --- a/drivers/platform/chrome/cros_ec_uart.c\n+++ b/drivers/platform/chrome/cros_ec_uart.c\n\
  @@ -263,12 +263,6 @@ static int cros_ec_uart_probe(struct serdev_device *serdev)\n\
  \ \tif (!ec_dev)\n \t\treturn -ENOMEM;\n \n-\tret = devm_serdev_device_open(dev,\
  \ serdev);\n-\tif (ret) {\n-\t\tdev_err(dev, \"Unable to open UART device\");\n\
  -\t\treturn ret;\n-\t}\n-\n \tserdev_device_set_drvdata(serdev, ec_dev);\n \tinit_waitqueue_head(&ec_uart->response.wait_queue);\n\
  \ \n@@ -280,14 +274,6 @@ static int cros_ec_uart_probe(struct serdev_device *serdev)\n\
  \ \t\treturn ret;\n \t}\n \n-\tret = serdev_device_set_baudrate(serdev, ec_uart->baudrate);\n\
  -\tif (ret < 0) {\n-\t\tdev_err(dev, \"Failed to set up host baud rate (%d)\", ret);\n\
  -\t\treturn ret;\n-\t}\n-\n-\tserdev_device_set_flow_control(serdev, ec_uart->flowcontrol);\n\
  -\n \t/* Initialize ec_dev for cros_ec  */\n \tec_dev->phys_name = dev_name(dev);\n\
  \ \tec_dev->dev = dev;\n@@ -301,6 +287,20 @@ static int cros_ec_uart_probe(struct\
  \ serdev_device *serdev)\n \n \tserdev_device_set_client_ops(serdev, &cros_ec_uart_client_ops);\n\
  \ \n+\tret = devm_serdev_device_open(dev, serdev);\n+\tif (ret) {\n+\t\tdev_err(dev,\
  \ \"Unable to open UART device\");\n+\t\treturn ret;\n+\t}\n+\n+\tret = serdev_device_set_baudrate(serdev,\
  \ ec_uart->baudrate);\n+\tif (ret < 0) {\n+\t\tdev_err(dev, \"Failed to set up host\
  \ baud rate (%d)\", ret);\n+\t\treturn ret;\n+\t}\n+\n+\tserdev_device_set_flow_control(serdev,\
  \ ec_uart->flowcontrol);\n+\n \treturn cros_ec_register(ec_dev);\n }\n \n```\n"
pattern: '## Bug Pattern


  Activating a serdev port before registering its client ops, i.e., calling devm_serdev_device_open()
  (which can trigger asynchronous receive callbacks) before serdev_device_set_client_ops().
  This enables the port and may invoke receive_buf while serdev->ops is still NULL,
  leading to a NULL pointer dereference.


  Example of the faulty ordering:

  - devm_serdev_device_open(dev, serdev);  // Port becomes active; callbacks may fire

  - serdev_device_set_client_ops(serdev, &ops);  // Ops set too late


  Correct pattern: set client ops (and complete necessary initialization) before opening/activating
  the device.'
plan: "Plan\n\n1) Program state customization\n- REGISTER_SET_WITH_PROGRAMSTATE(SerdevOpsSet,\
  \ const MemRegion*)\n  - Tracks serdev devices (by pointee MemRegion) for which\
  \ serdev_device_set_client_ops(...) has already been called on the current path.\n\
  - REGISTER_SET_WITH_PROGRAMSTATE(SerdevReported, const MemRegion*)\n  - Tracks serdev\
  \ devices for which we have already emitted a report to avoid duplicate diagnostics\
  \ on the same path.\n\nRationale:\n- We only need to know if \u201Cops are set\u201D\
  \ for a specific serdev device before it gets opened. A set keyed by the pointee\
  \ MemRegion of the serdev pointer is sufficient and robust across aliases, since\
  \ getMemRegionFromExpr returns the pointee\u2019s MemRegion for pointer expressions\
  \ when available.\n\n2) Callback selection and implementation details\n\nA. checkPostCall\n\
  Goal: Mark serdev device as having client ops set.\n\n- Identify serdev_device_set_client_ops:\n\
  \  - Get callee identifier (Call.getCalleeIdentifier()) and match name == \"serdev_device_set_client_ops\"\
  .\n- Extract the serdev device argument:\n  - The serdev argument is the 0-th parameter.\n\
  \  - const Expr *SerdevArg = Call.getArgExpr(0).\n  - const MemRegion *SerdevMR\
  \ = getMemRegionFromExpr(SerdevArg, C).\n- If SerdevMR is non-null:\n  - ProgramStateRef\
  \ State = C.getState();\n  - State = State->add<SerdevOpsSet>(SerdevMR);\n  - C.addTransition(State).\n\
  \nNotes:\n- If getMemRegionFromExpr returns null (unmodeled value), conservatively\
  \ do nothing; the checker stays silent rather than risking false positives.\n\n\
  B. checkPreCall\nGoal: Detect devm_serdev_device_open/serdev_device_open called\
  \ before ops are registered.\n\n- Identify target open functions:\n  - Match callee\
  \ name in {\"devm_serdev_device_open\", \"serdev_device_open\"}.\n- Extract the\
  \ serdev device argument:\n  - For devm_serdev_device_open(struct device *, struct\
  \ serdev_device *):\n    - serdev is argument index 1 (the second parameter).\n\
  \  - For serdev_device_open(struct serdev_device *):\n    - serdev is argument index\
  \ 0.\n  - Use const Expr *SerdevArg = Call.getArgExpr(Idx).\n  - const MemRegion\
  \ *SerdevMR = getMemRegionFromExpr(SerdevArg, C).\n- If SerdevMR is null: do nothing\
  \ (skip).\n- Query if ops were set:\n  - ProgramStateRef State = C.getState();\n\
  \  - bool OpsSet = State->contains<SerdevOpsSet>(SerdevMR).\n- If OpsSet is false\
  \ and we have not already reported for this region:\n  - If State->contains<SerdevReported>(SerdevMR)\
  \ is false:\n    - Generate a non-fatal error node: ExplodedNode *N = C.generateNonFatalErrorNode(State);\n\
  \    - If N is null, return.\n    - Create a BugType once (e.g., in checker constructor)\
  \ with name \"Serdev open before ops\" and category \"API Misuse\".\n    - Create\
  \ and emit report:\n      - auto R = std::make_unique<PathSensitiveBugReport>(BugType,\
  \ \"devm_serdev_device_open() called before serdev_device_set_client_ops(); callbacks\
  \ may deref NULL ops\", N);\n      - R->addRange(SerdevArg->getSourceRange());\n\
  \      - C.emitReport(std::move(R));\n    - Add SerdevMR to SerdevReported set to\
  \ avoid duplicates:\n      - State = State->add<SerdevReported>(SerdevMR);\n   \
  \   - C.addTransition(State).\n\nC. Optional: checkEndFunction\n- No special cleanup\
  \ required; the analyzer discards function-local state. This callback can be omitted.\n\
  \n3) Helper logic and notes\n- Function name matching:\n  - Use Call.getCalleeIdentifier()\
  \ and compare ID->getName() with:\n    - \"serdev_device_set_client_ops\"\n    -\
  \ \"devm_serdev_device_open\"\n    - \"serdev_device_open\"\n- Getting the serdev\
  \ MemRegion:\n  - Use provided utility getMemRegionFromExpr to retrieve the pointee\
  \ MemRegion of the serdev device pointer. This is robust across simple aliases because\
  \ the same pointee region will be carried as the symbolic MemRegion value.\n- No\
  \ alias map needed:\n  - Because we key on the pointee MemRegion of the serdev value\
  \ (not on the variable\u2019s own region), copies of the pointer will share the\
  \ same MemRegion when modeled, so explicit alias tracking via checkBind is unnecessary\
  \ here.\n- Avoid heavy heuristics:\n  - We do not restrict to functions named \"\
  *probe*\" to keep the checker general; however, if desired, adding a mild heuristic\
  \ in checkBeginFunction to record whether the analyzed function\u2019s name contains\
  \ \"probe\" and warn only within such functions is straightforward.\n\n4) Reporting\n\
  - Short, clear message:\n  - \"devm_serdev_device_open() called before serdev_device_set_client_ops();\
  \ callbacks may deref NULL ops\"\n- Point to the open call (or its serdev argument\
  \ range) for clarity, using addRange on the argument or the entire call expression\u2019\
  s source range."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Track serdev devices whose client ops have been set.\nREGISTER_SET_WITH_PROGRAMSTATE(SerdevOpsSet,\
  \ const MemRegion *)\n// Track serdev devices we already reported on this path to\
  \ avoid duplicates.\nREGISTER_SET_WITH_PROGRAMSTATE(SerdevReported, const MemRegion\
  \ *)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall, check::PostCall>\
  \ {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker() : BT(new\
  \ BugType(this, \"Serdev open before ops\", \"API Misuse\")) {}\n\n  void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\nprivate:\n  // Helper to fetch the base MemRegion\
  \ from a call argument expression.\n  const MemRegion *getBaseRegionFromArg(const\
  \ CallEvent &Call, unsigned Idx,\n                                        CheckerContext\
  \ &C) const {\n    if (Idx >= Call.getNumArgs())\n      return nullptr;\n    const\
  \ Expr *ArgE = Call.getArgExpr(Idx);\n    if (!ArgE)\n      return nullptr;\n  \
  \  const MemRegion *MR = getMemRegionFromExpr(ArgE, C);\n    if (!MR)\n      return\
  \ nullptr;\n    return MR->getBaseRegion();\n  }\n};\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return;\n\n  // Mark ops as set for the given serdev device.\n\
  \  if (!ExprHasName(Origin, \"serdev_device_set_client_ops\", C))\n    return;\n\
  \n  const MemRegion *SerdevMR = getBaseRegionFromArg(Call, 0, C);\n  if (!SerdevMR)\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  State = State->add<SerdevOpsSet>(SerdevMR);\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return;\n\n  bool IsDevmOpen = ExprHasName(Origin, \"devm_serdev_device_open\"\
  , C);\n  bool IsOpen = ExprHasName(Origin, \"serdev_device_open\", C);\n  if (!IsDevmOpen\
  \ && !IsOpen)\n    return;\n\n  unsigned SerdevIdx = IsDevmOpen ? 1u : 0u;\n  const\
  \ MemRegion *SerdevMR = getBaseRegionFromArg(Call, SerdevIdx, C);\n  if (!SerdevMR)\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  // If ops are already\
  \ set, everything is fine.\n  if (State->contains<SerdevOpsSet>(SerdevMR))\n   \
  \ return;\n\n  // Avoid duplicate reports on the same path.\n  if (State->contains<SerdevReported>(SerdevMR))\n\
  \    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode(State);\n  if (!N)\n\
  \    return;\n\n  // Tailor the message to the specific open function used.\n  StringRef\
  \ OpenName = IsDevmOpen ? \"devm_serdev_device_open()\" : \"serdev_device_open()\"\
  ;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, (OpenName +\
  \ \" called before serdev_device_set_client_ops(); callbacks may deref NULL ops\"\
  ).str(), N);\n\n  // Highlight the call site.\n  R->addRange(Origin->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n\n  // Mark as reported to avoid duplicates and\
  \ transition the state.\n  State = State->add<SerdevReported>(SerdevMR);\n  C.addTransition(State);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects serdev ports opened before client ops are set, which may cause\
  \ NULL ops dereference\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
