_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: f503ae90c7355e8506e68498fe84c1357894cd5b
commit_type: Null-Pointer-Dereference
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// Track symbols that are possibly-NULL\
  \ pointers returned by the capability helper\nREGISTER_SET_WITH_PROGRAMSTATE(UncheckedCapPtrSyms,\
  \ SymbolRef)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<\n      \
  \                     check::PostCall,\n                           check::Bind,\n\
  \                           check::Location> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Dereference\
  \ of capability pointer without NULL check\",\n                       \"API Misuse\"\
  )) {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \  void checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\
  \nprivate:\n  bool isCapHelper(const CallEvent &Call, CheckerContext &C) const;\n\
  \n  // Walk up the region chain to find the base Symbol. Set WentThroughSubRegion\n\
  \  // to true if we traversed any SubRegion (i.e., a dereference-like access).\n\
  \  SymbolRef tryGetBaseSymbolFromRegionChain(const MemRegion *R,\n             \
  \                               bool &WentThroughSubRegion) const;\n\n  bool isDefinitelyNonNull(SymbolRef\
  \ Sym, ProgramStateRef State,\n                           CheckerContext &C) const;\n\
  \n  bool shouldReport(SymbolRef Sym, bool WentThroughSubRegion,\n              \
  \      ProgramStateRef State, CheckerContext &C) const;\n\n  void reportDereference(const\
  \ Stmt *S, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isCapHelper(const\
  \ CallEvent &Call,\n                                   CheckerContext &C) const\
  \ {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n\
  \  return ExprHasName(Origin, \"mt76_connac_get_he_phy_cap\", C);\n}\n\nSymbolRef\
  \ SAGenTestChecker::tryGetBaseSymbolFromRegionChain(\n    const MemRegion *R, bool\
  \ &WentThroughSubRegion) const {\n  WentThroughSubRegion = false;\n  const MemRegion\
  \ *Cur = R;\n  while (Cur) {\n    if (const auto *SymR = dyn_cast<SymbolicRegion>(Cur))\
  \ {\n      return SymR->getSymbol();\n    }\n    if (const auto *SubR = dyn_cast<SubRegion>(Cur))\
  \ {\n      WentThroughSubRegion = true;\n      Cur = SubR->getSuperRegion();\n \
  \     continue;\n    }\n    break;\n  }\n  return nullptr;\n}\n\nbool SAGenTestChecker::isDefinitelyNonNull(SymbolRef\
  \ Sym,\n                                           ProgramStateRef State,\n    \
  \                                       CheckerContext &C) const {\n  if (!Sym ||\
  \ !State)\n    return false;\n\n  SValBuilder &SVB = C.getSValBuilder();\n  SVal\
  \ PtrVal = SVB.makeLoc(Sym);\n  if (!PtrVal.getAs<Loc>())\n    return false;\n\n\
  \  DefinedOrUnknownSVal IsNull =\n      SVB.evalEQ(State, PtrVal.castAs<Loc>(),\
  \ SVB.makeNull());\n\n  ProgramStateRef StIfNull = State->assume(IsNull, true);\n\
  \  ProgramStateRef StIfNonNull = State->assume(IsNull, false);\n\n  // Definitely\
  \ non-null if null is impossible and non-null is possible.\n  return (StIfNonNull\
  \ != nullptr) && (StIfNull == nullptr);\n}\n\nbool SAGenTestChecker::shouldReport(SymbolRef\
  \ Sym, bool WentThroughSubRegion,\n                                    ProgramStateRef\
  \ State,\n                                    CheckerContext &C) const {\n  if (!Sym\
  \ || !WentThroughSubRegion || !State)\n    return false;\n\n  // Only consider symbols\
  \ known to originate from the capability helper.\n  if (!State->contains<UncheckedCapPtrSyms>(Sym))\n\
  \    return false;\n\n  // Do not report if the pointer is proven non-null on this\
  \ path.\n  if (isDefinitelyNonNull(Sym, State, C))\n    return false;\n\n  return\
  \ true;\n}\n\nvoid SAGenTestChecker::reportDereference(const Stmt *S,\n        \
  \                                 CheckerContext &C) const {\n  ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Dereference of pointer returned by mt76_connac_get_he_phy_cap without\
  \ NULL check\", N);\n  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\n             \
  \                        CheckerContext &C) const {\n  if (!isCapHelper(Call, C))\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  SVal Ret = Call.getReturnValue();\n\
  \  SymbolRef Sym = Ret.getAsSymbol();\n  if (!Sym)\n    return;\n\n  State = State->add<UncheckedCapPtrSyms>(Sym);\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal /*Loc*/,\
  \ SVal Val, const Stmt *S,\n                                 CheckerContext &C)\
  \ const {\n  // We are interested in values that are locations derived from regions,\n\
  \  // e.g., &vc->field or vc[0], which implies dereferencing 'vc'.\n  const MemRegion\
  \ *R = Val.getAsRegion();\n  if (!R)\n    return;\n\n  bool Through = false;\n \
  \ SymbolRef BaseSym = tryGetBaseSymbolFromRegionChain(R, Through);\n  if (!BaseSym)\n\
  \    return;\n\n  if (shouldReport(BaseSym, Through, C.getState(), C))\n    reportDereference(S,\
  \ C);\n}\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool /*IsLoad*/, const\
  \ Stmt *S,\n                                     CheckerContext &C) const {\n  const\
  \ MemRegion *R = Loc.getAsRegion();\n  if (!R)\n    return;\n\n  bool Through =\
  \ false;\n  SymbolRef BaseSym = tryGetBaseSymbolFromRegionChain(R, Through);\n \
  \ if (!BaseSym)\n    return;\n\n  if (shouldReport(BaseSym, Through, C.getState(),\
  \ C))\n    reportDereference(S, C);\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects dereference of pointers returned\
  \ by mt76_connac_get_he_phy_cap without NULL check\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nwifi: mt76: mt7996: fix NULL pointer dereference in\
  \ mt7996_mcu_sta_bfer_he\n\nFix the NULL pointer dereference in mt7996_mcu_sta_bfer_he\n\
  routine adding an sta interface to the mt7996 driver.\n\nFound by code review.\n\
  \nCc: stable@vger.kernel.org\nFixes: 98686cd21624 (\"wifi: mt76: mt7996: add driver\
  \ for MediaTek Wi-Fi 7 (802.11be) devices\")\nSigned-off-by: Ma Ke <make24@iscas.ac.cn>\n\
  Link: https://patch.msgid.link/20240813081242.3991814-1-make24@iscas.ac.cn\nSigned-off-by:\
  \ Felix Fietkau <nbd@nbd.name>\n\n## Buggy Code\n\n```c\n// Function: mt7996_mcu_sta_bfer_he\
  \ in drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nstatic void\nmt7996_mcu_sta_bfer_he(struct\
  \ ieee80211_sta *sta, struct ieee80211_vif *vif,\n\t\t       struct mt7996_phy *phy,\
  \ struct sta_rec_bf *bf)\n{\n\tstruct ieee80211_sta_he_cap *pc = &sta->deflink.he_cap;\n\
  \tstruct ieee80211_he_cap_elem *pe = &pc->he_cap_elem;\n\tconst struct ieee80211_sta_he_cap\
  \ *vc =\n\t\tmt76_connac_get_he_phy_cap(phy->mt76, vif);\n\tconst struct ieee80211_he_cap_elem\
  \ *ve = &vc->he_cap_elem;\n\tu16 mcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80);\n\
  \tu8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\tu8 snd_dim, sts;\n\n\tbf->tx_mode\
  \ = MT_PHY_TYPE_HE_SU;\n\n\tmt7996_mcu_sta_sounding_rate(bf);\n\n\tbf->trigger_su\
  \ = HE_PHY(CAP6_TRIG_SU_BEAMFORMING_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\tbf->trigger_mu\
  \ = HE_PHY(CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\
  \tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK,\n\t\t\t ve->phy_cap_info[5]);\n\
  \tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_MASK,\n\t\t     pe->phy_cap_info[4]);\n\
  \tbf->nrow = min_t(u8, snd_dim, sts);\n\tbf->ncol = min_t(u8, nss_mcs, bf->nrow);\n\
  \tbf->ibf_ncol = bf->ncol;\n\n\tif (sta->deflink.bandwidth != IEEE80211_STA_RX_BW_160)\n\
  \t\treturn;\n\n\t/* go over for 160MHz and 80p80 */\n\tif (pe->phy_cap_info[0] &\n\
  \t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G) {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_160);\n\
  \t\tnss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\n\t\tbf->ncol_gt_bw80 = nss_mcs;\n\
  \t}\n\n\tif (pe->phy_cap_info[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)\
  \ {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80p80);\n\t\tnss_mcs =\
  \ mt7996_mcu_get_sta_nss(mcs_map);\n\n\t\tif (bf->ncol_gt_bw80)\n\t\t\tbf->ncol_gt_bw80\
  \ = min_t(u8, bf->ncol_gt_bw80, nss_mcs);\n\t\telse\n\t\t\tbf->ncol_gt_bw80 = nss_mcs;\n\
  \t}\n\n\tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_MASK,\n\t\t\t\
  \ ve->phy_cap_info[5]);\n\tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_MASK,\n\
  \t\t     pe->phy_cap_info[4]);\n\n\tbf->nrow_gt_bw80 = min_t(int, snd_dim, sts);\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\
  \ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nindex e8d34bfbb41a..8855095fef10\
  \ 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n\
  @@ -1544,6 +1544,9 @@ mt7996_mcu_sta_bfer_he(struct ieee80211_sta *sta, struct ieee80211_vif\
  \ *vif,\n \tu8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n \tu8 snd_dim, sts;\n\
  \ \n+\tif (!vc)\n+\t\treturn;\n+\n \tbf->tx_mode = MT_PHY_TYPE_HE_SU;\n \n \tmt7996_mcu_sta_sounding_rate(bf);\n\
  ```\n"
pattern: '## Bug Pattern


  Dereferencing a pointer returned by a capability-retrieval helper without a NULL
  check. Specifically:

  - A helper like mt76_connac_get_he_phy_cap(...) can return NULL when the capability
  is unsupported.

  - The code immediately accesses a member of this pointer (e.g., const struct ieee80211_he_cap_elem
  *ve = &vc->he_cap_elem; and ve->phy_cap_info[...]) before verifying vc != NULL.

  - This leads to a NULL pointer dereference when the capability is absent.'
plan: "1) Program state customization\n\n- Register a set of symbols that may be NULL\
  \ and are not checked yet:\n  - REGISTER_SET_WITH_PROGRAMSTATE(UncheckedCapPtrSyms,\
  \ SymbolRef)\n  - Rationale: Track the symbolic value returned by mt76_connac_get_he_phy_cap.\
  \ Using SymbolRef avoids alias tracking complexity since the same symbol flows through\
  \ assignments, casts, etc.\n\n\n2) Helper utilities (internal to the checker)\n\n\
  - isCapHelper(const CallEvent &Call):\n  - Return true if callee name equals \"\
  mt76_connac_get_he_phy_cap\".\n- tryGetBaseSymbolFromRegionChain(const MemRegion\
  \ *R, bool &WentThroughSubRegion):\n  - Walk up the region chain:\n    - If R is\
  \ ElementRegion, FieldRegion, or any SubRegion, set WentThroughSubRegion=true and\
  \ continue with its super region.\n    - If R is SymbolicRegion, return SR->getSymbol().\n\
  \    - Otherwise, return nullptr.\n  - This identifies the base symbol that the\
  \ access is derived from, and whether accessing this region required dereferencing\
  \ a pointer (WentThroughSubRegion).\n- isDefinitelyNonNull(SymbolRef Sym, ProgramStateRef\
  \ State, CheckerContext &C):\n  - Construct loc::SymbolVal Ptr = C.getSValBuilder().makeLoc(Sym)\
  \ (or loc::SymbolVal(Sym) if available).\n  - Build DefinedOrUnknownSVal IsNull\
  \ = SValBuilder.evalEQ(State, Ptr, SValBuilder.makeNull()).\n  - If State->assume(IsNull,\
  \ false) != nullptr and State->assume(IsNull, true) == nullptr, it\u2019s definitely\
  \ non-NULL.\n  - Return true in that case; otherwise false.\n- shouldReport(SymbolRef\
  \ Sym, bool WentThroughSubRegion, ProgramStateRef State, CheckerContext &C):\n \
  \ - Return true only if:\n    - Sym is in UncheckedCapPtrSyms,\n    - WentThroughSubRegion\
  \ == true (meaning we are dereferencing the pointer, e.g., via ->, [] or computing\
  \ address of a field),\n    - and not isDefinitelyNonNull(Sym, State, C).\n  - This\
  \ ensures we report only when dereference actually happens and the path does not\
  \ already guarantee non-NULL.\n\n\n3) Callback: checkPostCall\n\n- Goal: Mark the\
  \ return value of mt76_connac_get_he_phy_cap as possibly NULL and unchecked.\n-\
  \ Steps:\n  - If !isCapHelper(Call): return.\n  - Get the return SVal: SVal Ret\
  \ = Call.getReturnValue().\n  - If SymbolRef Sym = Ret.getAsSymbol() is non-null:\n\
  \    - State = C.getState()->add<UncheckedCapPtrSyms>(Sym).\n    - C.addTransition(State).\n\
  - Notes:\n  - No need to bind a region or model allocation; just track the symbol.\n\
  \n\n4) Callback: checkBind\n\n- Goal: Detect dereference via lvalue formation and\
  \ address-taking, e.g., ve = &vc->he_cap_elem; This does not necessarily perform\
  \ a memory load but still dereferences vc.\n- Steps:\n  - If Val is not a loc::MemRegionVal,\
  \ return.\n  - const MemRegion *R = Val.getAsRegion().\n  - bool Through = false;\
  \ SymbolRef BaseSym = tryGetBaseSymbolFromRegionChain(R, Through).\n  - If BaseSym\
  \ && shouldReport(BaseSym, Through, C.getState(), C):\n    - Generate a non-fatal\
  \ error node and emit a report.\n- Reporting:\n  - Create a single BugType (class\
  \ member) like: BugType BT(this, \"NULL dereference of capability pointer\", \"\
  API Misuse\").\n  - Use std::make_unique<PathSensitiveBugReport>(BT, \"Dereference\
  \ of pointer returned by mt76_connac_get_he_phy_cap without NULL check\", Node).\n\
  \  - Attach the source range of S (the Stmt argument given) if available.\n\n\n\
  5) Callback: checkLocation\n\n- Goal: Detect dereference at actual memory loads/stores\
  \ (e.g., vc->field reads, vc[i], *vc).\n- Steps:\n  - If Loc is not loc::MemRegionVal,\
  \ return.\n  - const MemRegion *R = Loc.getAsRegion().\n  - bool Through = false;\
  \ SymbolRef BaseSym = tryGetBaseSymbolFromRegionChain(R, Through).\n  - If BaseSym\
  \ && shouldReport(BaseSym, Through, C.getState(), C):\n    - Generate a non-fatal\
  \ error node and emit a report with the same bug type and message as in checkBind.\n\
  - Notes:\n  - This complements checkBind to cover both forming lvalues and actual\
  \ loads/stores.\n\n\n6) No need for alias tracking or explicit branch modeling\n\
  \n- We do not use check::BranchCondition or evalAssume.\n- Reason: We rely on the\
  \ analyzer\u2019s own path constraints when evaluating isDefinitelyNonNull at the\
  \ point of dereference. If the pointer was checked via if (vc) or similar before\
  \ dereferencing, the constraint manager will make State->assume(IsNull, true) infeasible\
  \ and we won\u2019t report.\n- This keeps the checker simple and avoids manual state\
  \ splitting and alias maps.\n\n\n7) Scope and function matching\n\n- The checker\
  \ only tracks pointers returned by mt76_connac_get_he_phy_cap (the buggy pattern\
  \ in the patch). If you want to generalize, extend isCapHelper to include other\
  \ capability-retrieval helpers known to return NULL when unsupported.\n\n\n8) Summary\
  \ of minimal implementation steps\n\n- Program state: REGISTER_SET_WITH_PROGRAMSTATE(UncheckedCapPtrSyms,\
  \ SymbolRef).\n- checkPostCall: Track return symbol of mt76_connac_get_he_phy_cap\
  \ by inserting into UncheckedCapPtrSyms.\n- checkBind: If binding a Loc that forms\
  \ an lvalue derived from a SymbolicRegion whose symbol is in UncheckedCapPtrSyms\
  \ and not provably non-NULL, report.\n- checkLocation: Same detection logic as checkBind\
  \ for loads/stores.\n- Reporting: Short message: \"Dereference of pointer returned\
  \ by mt76_connac_get_he_phy_cap without NULL check\"."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// Track symbols that are possibly-NULL\
  \ pointers returned by the capability helper\nREGISTER_SET_WITH_PROGRAMSTATE(UncheckedCapPtrSyms,\
  \ SymbolRef)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<\n      \
  \                     check::PostCall,\n                           check::Bind,\n\
  \                           check::Location> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Dereference\
  \ of capability pointer without NULL check\",\n                       \"API Misuse\"\
  )) {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \  void checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\
  \nprivate:\n  bool isCapHelper(const CallEvent &Call, CheckerContext &C) const;\n\
  \n  // Walk up the region chain to find the base Symbol. Set WentThroughSubRegion\n\
  \  // to true if we traversed any SubRegion (i.e., a dereference-like access).\n\
  \  SymbolRef tryGetBaseSymbolFromRegionChain(const MemRegion *R,\n             \
  \                               bool &WentThroughSubRegion) const;\n\n  bool isDefinitelyNonNull(SymbolRef\
  \ Sym, ProgramStateRef State,\n                           CheckerContext &C) const;\n\
  \n  bool shouldReport(SymbolRef Sym, bool WentThroughSubRegion,\n              \
  \      ProgramStateRef State, CheckerContext &C) const;\n\n  void reportDereference(const\
  \ Stmt *S, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isCapHelper(const\
  \ CallEvent &Call,\n                                   CheckerContext &C) const\
  \ {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n\
  \  return ExprHasName(Origin, \"mt76_connac_get_he_phy_cap\", C);\n}\n\nSymbolRef\
  \ SAGenTestChecker::tryGetBaseSymbolFromRegionChain(\n    const MemRegion *R, bool\
  \ &WentThroughSubRegion) const {\n  WentThroughSubRegion = false;\n  const MemRegion\
  \ *Cur = R;\n  while (Cur) {\n    if (const auto *SymR = dyn_cast<SymbolicRegion>(Cur))\
  \ {\n      return SymR->getSymbol();\n    }\n    if (const auto *SubR = dyn_cast<SubRegion>(Cur))\
  \ {\n      WentThroughSubRegion = true;\n      Cur = SubR->getSuperRegion();\n \
  \     continue;\n    }\n    break;\n  }\n  return nullptr;\n}\n\nbool SAGenTestChecker::isDefinitelyNonNull(SymbolRef\
  \ Sym,\n                                           ProgramStateRef State,\n    \
  \                                       CheckerContext &C) const {\n  if (!Sym ||\
  \ !State)\n    return false;\n\n  SValBuilder &SVB = C.getSValBuilder();\n  SVal\
  \ PtrVal = SVB.makeLoc(Sym);\n  if (!PtrVal.getAs<Loc>())\n    return false;\n\n\
  \  // Assume on the pointer's truthiness: true -> non-null, false -> null.\n  DefinedOrUnknownSVal\
  \ Cond = PtrVal.castAs<DefinedOrUnknownSVal>();\n  ProgramStateRef StIfNonNull =\
  \ State->assume(Cond, true);\n  ProgramStateRef StIfNull = State->assume(Cond, false);\n\
  \n  // Definitely non-null if null is impossible and non-null is possible.\n  return\
  \ (StIfNonNull != nullptr) && (StIfNull == nullptr);\n}\n\nbool SAGenTestChecker::shouldReport(SymbolRef\
  \ Sym, bool WentThroughSubRegion,\n                                    ProgramStateRef\
  \ State,\n                                    CheckerContext &C) const {\n  if (!Sym\
  \ || !WentThroughSubRegion || !State)\n    return false;\n\n  // Only consider symbols\
  \ known to originate from the capability helper.\n  if (!State->contains<UncheckedCapPtrSyms>(Sym))\n\
  \    return false;\n\n  // Do not report if the pointer is proven non-null on this\
  \ path.\n  if (isDefinitelyNonNull(Sym, State, C))\n    return false;\n\n  return\
  \ true;\n}\n\nvoid SAGenTestChecker::reportDereference(const Stmt *S,\n        \
  \                                 CheckerContext &C) const {\n  ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Dereference of pointer returned by mt76_connac_get_he_phy_cap without\
  \ NULL check\", N);\n  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\n             \
  \                        CheckerContext &C) const {\n  if (!isCapHelper(Call, C))\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  SVal Ret = Call.getReturnValue();\n\
  \  SymbolRef Sym = Ret.getAsSymbol();\n  if (!Sym)\n    return;\n\n  State = State->add<UncheckedCapPtrSyms>(Sym);\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal /*Loc*/,\
  \ SVal Val, const Stmt *S,\n                                 CheckerContext &C)\
  \ const {\n  // We are interested in values that are locations derived from regions,\n\
  \  // e.g., &vc->field or vc[0], which implies dereferencing 'vc'.\n  const MemRegion\
  \ *R = Val.getAsRegion();\n  if (!R)\n    return;\n\n  bool Through = false;\n \
  \ SymbolRef BaseSym = tryGetBaseSymbolFromRegionChain(R, Through);\n  if (!BaseSym)\n\
  \    return;\n\n  if (shouldReport(BaseSym, Through, C.getState(), C))\n    reportDereference(S,\
  \ C);\n}\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool /*IsLoad*/, const\
  \ Stmt *S,\n                                     CheckerContext &C) const {\n  const\
  \ MemRegion *R = Loc.getAsRegion();\n  if (!R)\n    return;\n\n  bool Through =\
  \ false;\n  SymbolRef BaseSym = tryGetBaseSymbolFromRegionChain(R, Through);\n \
  \ if (!BaseSym)\n    return;\n\n  if (shouldReport(BaseSym, Through, C.getState(),\
  \ C))\n    reportDereference(S, C);\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects dereference of pointers returned\
  \ by mt76_connac_get_he_phy_cap without NULL check\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
