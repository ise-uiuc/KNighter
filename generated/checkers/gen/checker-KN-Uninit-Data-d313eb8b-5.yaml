_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: d313eb8b77557a6d5855f42d2234bd592c7b50dd
commit_type: Uninit-Data
index: 5
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing\
  \ namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n// Track whether\
  \ a stack struct object has been explicitly zeroed via a full-object zeroing.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(StructZeroedMap, const MemRegion*, bool)\n\nnamespace\
  \ {\n\nclass SAGenTestChecker : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"Potential kernel\
  \ info leak\", \"Security\")) {}\n\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\nprivate:\n  // Helpers\n  const VarDecl *getAddrOfLocalVar(const\
  \ Expr *E) const;\n  const MemRegion *getVarRegion(const VarDecl *VD, CheckerContext\
  \ &C) const;\n\n  bool isZeroingCall(const CallEvent &Call,\n                  \
  \   const Expr *&PtrArg, const Expr *&ValArg, const Expr *&SizeArg,\n          \
  \           CheckerContext &C) const;\n\n  bool zeroValueIsConstZero(const Expr\
  \ *ValArg, CheckerContext &C) const;\n\n  bool sizeMatchesVarType(const Expr *SizeArg,\
  \ const VarDecl *VD,\n                          CheckerContext &C) const;\n\n  bool\
  \ isSinkCall(const CallEvent &Call, unsigned &SizeIdx, unsigned &DataIdx,\n    \
  \              CheckerContext &C) const;\n\n  bool hasAnyPadding(const VarDecl *VD,\
  \ CheckerContext &C) const;\n\n  void reportLeak(const CallEvent &Call, const Expr\
  \ *DataExpr, CheckerContext &C) const;\n};\n\n// ----- Helper Implementations -----\n\
  \nconst VarDecl *SAGenTestChecker::getAddrOfLocalVar(const Expr *E) const {\n  if\
  \ (!E) return nullptr;\n  const Expr *EE = E->IgnoreParenImpCasts();\n  const auto\
  \ *UO = dyn_cast<UnaryOperator>(EE);\n  if (!UO || UO->getOpcode() != UO_AddrOf)\n\
  \    return nullptr;\n\n  const Expr *Sub = UO->getSubExpr();\n  if (!Sub) return\
  \ nullptr;\n  Sub = Sub->IgnoreParenImpCasts();\n\n  const auto *DRE = dyn_cast<DeclRefExpr>(Sub);\n\
  \  if (!DRE) return nullptr;\n\n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n\
  \  if (!VD) return nullptr;\n\n  // Only consider local (automatic storage) non-parameter\
  \ variables with record type.\n  if (!VD->isLocalVarDecl())\n    return nullptr;\n\
  \n  if (!VD->getType()->isRecordType())\n    return nullptr;\n\n  return VD;\n}\n\
  \nconst MemRegion *SAGenTestChecker::getVarRegion(const VarDecl *VD, CheckerContext\
  \ &C) const {\n  if (!VD) return nullptr;\n  ProgramStateRef State = C.getState();\n\
  \  SVal LV = State->getLValue(VD, C.getLocationContext());\n  const MemRegion *MR\
  \ = LV.getAsRegion();\n  if (!MR) return nullptr;\n  return MR->getBaseRegion();\n\
  }\n\nbool SAGenTestChecker::isZeroingCall(const CallEvent &Call,\n             \
  \                        const Expr *&PtrArg, const Expr *&ValArg, const Expr *&SizeArg,\n\
  \                                     CheckerContext &C) const {\n  PtrArg = nullptr;\
  \ ValArg = nullptr; SizeArg = nullptr;\n\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // memset and builtin memset: memset(ptr,\
  \ 0, sizeof(...))\n  if (ExprHasName(Origin, \"memset\", C) || ExprHasName(Origin,\
  \ \"__builtin_memset\", C)) {\n    if (Call.getNumArgs() >= 3) {\n      PtrArg =\
  \ Call.getArgExpr(0);\n      ValArg = Call.getArgExpr(1);\n      SizeArg = Call.getArgExpr(2);\n\
  \      return PtrArg && SizeArg;\n    }\n    return false;\n  }\n\n  // memzero_explicit(ptr,\
  \ sizeof(...))\n  if (ExprHasName(Origin, \"memzero_explicit\", C)) {\n    if (Call.getNumArgs()\
  \ >= 2) {\n      PtrArg = Call.getArgExpr(0);\n      SizeArg = Call.getArgExpr(1);\n\
  \      ValArg = nullptr;\n      return PtrArg && SizeArg;\n    }\n    return false;\n\
  \  }\n\n  // bzero(ptr, sizeof(...))\n  if (ExprHasName(Origin, \"bzero\", C)) {\n\
  \    if (Call.getNumArgs() >= 2) {\n      PtrArg = Call.getArgExpr(0);\n      SizeArg\
  \ = Call.getArgExpr(1);\n      ValArg = nullptr;\n      return PtrArg && SizeArg;\n\
  \    }\n    return false;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::zeroValueIsConstZero(const\
  \ Expr *ValArg, CheckerContext &C) const {\n  if (!ValArg) return true; // Functions\
  \ without value arg are always zeroing\n  llvm::APSInt V;\n  if (!EvaluateExprToInt(V,\
  \ ValArg, C))\n    return false;\n  return V == 0;\n}\n\nbool SAGenTestChecker::sizeMatchesVarType(const\
  \ Expr *SizeArg, const VarDecl *VD,\n                                          CheckerContext\
  \ &C) const {\n  if (!SizeArg || !VD)\n    return false;\n\n  const Expr *E = SizeArg->IgnoreParenImpCasts();\n\
  \  const auto *UETT = dyn_cast<UnaryExprOrTypeTraitExpr>(E);\n  ASTContext &Ctx\
  \ = C.getASTContext();\n  QualType VarTy = VD->getType();\n\n  if (UETT && UETT->getKind()\
  \ == UETT_SizeOf) {\n    if (UETT->isArgumentType()) {\n      QualType T = UETT->getArgumentType();\n\
  \      // Compare canonical unqualified types\n      QualType T1 = Ctx.getCanonicalType(T).getUnqualifiedType();\n\
  \      QualType T2 = Ctx.getCanonicalType(VarTy).getUnqualifiedType();\n      if\
  \ (Ctx.hasSameType(T1, T2))\n        return true;\n    } else {\n      const Expr\
  \ *ArgE = UETT->getArgumentExpr();\n      if (ArgE) {\n        ArgE = ArgE->IgnoreParenImpCasts();\n\
  \        if (const auto *DRE = dyn_cast<DeclRefExpr>(ArgE)) {\n          if (DRE->getDecl()\
  \ == VD)\n            return true;\n        }\n        // Fallback: if sizeof(expr)\
  \ where expr type matches var type\n        QualType ETy = ArgE->getType();\n  \
  \      QualType T1 = Ctx.getCanonicalType(ETy).getUnqualifiedType();\n        QualType\
  \ T2 = Ctx.getCanonicalType(VarTy).getUnqualifiedType();\n        if (Ctx.hasSameType(T1,\
  \ T2))\n          return true;\n      }\n    }\n  }\n\n  // Fallback heuristic:\
  \ the size expression text contains the variable name.\n  return ExprHasName(SizeArg,\
  \ VD->getName(), C);\n}\n\nbool SAGenTestChecker::isSinkCall(const CallEvent &Call,\
  \ unsigned &SizeIdx, unsigned &DataIdx,\n                                  CheckerContext\
  \ &C) const {\n  SizeIdx = DataIdx = 0;\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // nla_put(skb, type, len, data)\n  if (ExprHasName(Origin,\
  \ \"nla_put\", C)) {\n    if (Call.getNumArgs() >= 4) {\n      SizeIdx = 2;\n  \
  \    DataIdx = 3;\n      return true;\n    }\n    return false;\n  }\n\n  if (ExprHasName(Origin,\
  \ \"nla_put_64bit\", C)) {\n    if (Call.getNumArgs() >= 5) {\n      SizeIdx = 2;\n\
  \      DataIdx = 3;\n      return true;\n    }\n    return false;\n  }\n\n  // copy_to_user(dst,\
  \ src, size) and variants\n  if (ExprHasName(Origin, \"copy_to_user\", C) ||\n \
  \     ExprHasName(Origin, \"copy_to_user_nofault\", C) ||\n      ExprHasName(Origin,\
  \ \"__copy_to_user\", C) ||\n      ExprHasName(Origin, \"__copy_to_user_inatomic\"\
  , C)) {\n    if (Call.getNumArgs() >= 3) {\n      DataIdx = 1;\n      SizeIdx =\
  \ 2;\n      return true;\n    }\n    return false;\n  }\n\n  // copy_to_user_iter(dst,\
  \ src, size) - treat similarly\n  if (ExprHasName(Origin, \"copy_to_user_iter\"\
  , C)) {\n    if (Call.getNumArgs() >= 3) {\n      DataIdx = 1;\n      SizeIdx =\
  \ 2;\n      return true;\n    }\n    return false;\n  }\n\n  return false;\n}\n\n\
  bool SAGenTestChecker::hasAnyPadding(const VarDecl *VD, CheckerContext &C) const\
  \ {\n  if (!VD) return false;\n  QualType QT = VD->getType();\n  const RecordType\
  \ *RT = QT->getAs<RecordType>();\n  if (!RT) return false;\n\n  const RecordDecl\
  \ *RD = RT->getDecl();\n  if (!RD) return false;\n  RD = RD->getDefinition();\n\
  \  if (!RD) return false;\n\n  ASTContext &Ctx = C.getASTContext();\n  const ASTRecordLayout\
  \ &L = Ctx.getASTRecordLayout(RD);\n\n  if (RD->isUnion()) {\n    // Union has padding\
  \ if its total size is greater than the largest field size.\n    uint64_t MaxFieldSize\
  \ = 0;\n    for (const FieldDecl *FD : RD->fields()) {\n      uint64_t FSz = FD->isBitField()\
  \ ? FD->getBitWidthValue(Ctx)\n                                      : Ctx.getTypeSize(FD->getType());\n\
  \      if (FSz > MaxFieldSize)\n        MaxFieldSize = FSz;\n    }\n    uint64_t\
  \ UnionSize = L.getSizeInBits();\n    return UnionSize > MaxFieldSize;\n  }\n\n\
  \  // Struct: check internal and tail padding\n  uint64_t AccEnd = 0;\n  unsigned\
  \ Index = 0;\n  for (const FieldDecl *FD : RD->fields()) {\n    uint64_t Ofs = L.getFieldOffset(Index++);\n\
  \    if (Ofs > AccEnd)\n      return true; // internal padding\n\n    uint64_t FSz\
  \ = FD->isBitField() ? FD->getBitWidthValue(Ctx)\n                             \
  \       : Ctx.getTypeSize(FD->getType());\n    uint64_t End = Ofs + FSz;\n    if\
  \ (End > AccEnd)\n      AccEnd = End;\n  }\n\n  uint64_t Total = L.getSizeInBits();\n\
  \  if (Total > AccEnd)\n    return true; // tail padding\n\n  return false;\n}\n\
  \nvoid SAGenTestChecker::reportLeak(const CallEvent &Call, const Expr *DataExpr,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n   \
  \   *BT, \"Struct with padding copied without memset; possible kernel info leak.\"\
  , N);\n\n  if (const Expr *OE = Call.getOriginExpr())\n    R->addRange(OE->getSourceRange());\n\
  \  if (DataExpr)\n    R->addRange(DataExpr->getSourceRange());\n\n  C.emitReport(std::move(R));\n\
  }\n\n// ----- Main callback -----\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\n\
  \  // A) Detect full-object zeroing of a local struct: memset(&obj, 0, sizeof(obj))\n\
  \  {\n    const Expr *PtrArg = nullptr, *ValArg = nullptr, *SizeArg = nullptr;\n\
  \    if (isZeroingCall(Call, PtrArg, ValArg, SizeArg, C)) {\n      // For memset-like,\
  \ ensure value is zero.\n      if (!zeroValueIsConstZero(ValArg, C)) {\n       \
  \ // Not a definitive zeroing, ignore.\n      } else {\n        const VarDecl *VD\
  \ = getAddrOfLocalVar(PtrArg);\n        if (VD && sizeMatchesVarType(SizeArg, VD,\
  \ C)) {\n          const MemRegion *MR = getVarRegion(VD, C);\n          if (MR)\
  \ {\n            State = State->set<StructZeroedMap>(MR, true);\n            C.addTransition(State);\n\
  \            return; // zeroing case handled\n          }\n        }\n      }\n\
  \    }\n  }\n\n  // B) Detect sinks that copy a whole struct to user space/netlink\n\
  \  {\n    unsigned SizeIdx = 0, DataIdx = 0;\n    if (!isSinkCall(Call, SizeIdx,\
  \ DataIdx, C))\n      return;\n\n    const Expr *DataE = Call.getArgExpr(DataIdx);\n\
  \    const VarDecl *VD = getAddrOfLocalVar(DataE);\n    if (!VD)\n      return;\n\
  \n    // Must match size with the struct object (i.e., copying the whole object)\n\
  \    const Expr *SizeE = Call.getArgExpr(SizeIdx);\n    if (!sizeMatchesVarType(SizeE,\
  \ VD, C))\n      return;\n\n    // If there is no padding, there is no leak from\
  \ padding.\n    if (!hasAnyPadding(VD, C))\n      return;\n\n    const MemRegion\
  \ *MR = getVarRegion(VD, C);\n    if (!MR)\n      return;\n\n    const bool *Zeroed\
  \ = State->get<StructZeroedMap>(MR);\n    if (!(Zeroed && *Zeroed)) {\n      //\
  \ Not confirmed zeroed, report potential leak.\n      reportLeak(Call, DataE, C);\n\
  \    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects copying stack structs with padding to user space without memset\
  \ zeroing\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/sched: act_skbmod: prevent kernel-infoleak\n\n\
  syzbot found that tcf_skbmod_dump() was copying four bytes\nfrom kernel stack to\
  \ user space [1].\n\nThe issue here is that 'struct tc_skbmod' has a four bytes\
  \ hole.\n\nWe need to clear the structure before filling fields.\n\n[1]\nBUG: KMSAN:\
  \ kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in copy_to_user_iter lib/iov_iter.c:24 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_and_advance2 include/linux/iov_iter.h:245\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in iterate_and_advance include/linux/iov_iter.h:271\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n  copy_to_user_iter\
  \ lib/iov_iter.c:24 [inline]\n  iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \  iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\n  iterate_and_advance\
  \ include/linux/iov_iter.h:271 [inline]\n  _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  copy_to_iter include/linux/uio.h:196 [inline]\n  simple_copy_to_iter net/core/datagram.c:532\
  \ [inline]\n  __skb_datagram_iter+0x185/0x1000 net/core/datagram.c:420\n  skb_copy_datagram_iter+0x5c/0x200\
  \ net/core/datagram.c:546\n  skb_copy_datagram_msg include/linux/skbuff.h:4050 [inline]\n\
  \  netlink_recvmsg+0x432/0x1610 net/netlink/af_netlink.c:1962\n  sock_recvmsg_nosec\
  \ net/socket.c:1046 [inline]\n  sock_recvmsg+0x2c4/0x340 net/socket.c:1068\n  __sys_recvfrom+0x35a/0x5f0\
  \ net/socket.c:2242\n  __do_sys_recvfrom net/socket.c:2260 [inline]\n  __se_sys_recvfrom\
  \ net/socket.c:2256 [inline]\n  __x64_sys_recvfrom+0x126/0x1d0 net/socket.c:2256\n\
  \ do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nUninit\
  \ was stored to memory at:\n  pskb_expand_head+0x30f/0x19d0 net/core/skbuff.c:2253\n\
  \  netlink_trim+0x2c2/0x330 net/netlink/af_netlink.c:1317\n  netlink_unicast+0x9f/0x1260\
  \ net/netlink/af_netlink.c:1351\n  nlmsg_unicast include/net/netlink.h:1144 [inline]\n\
  \  nlmsg_notify+0x21d/0x2f0 net/netlink/af_netlink.c:2610\n  rtnetlink_send+0x73/0x90\
  \ net/core/rtnetlink.c:741\n  rtnetlink_maybe_send include/linux/rtnetlink.h:17\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2048 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x146e/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nUninit was stored to memory at:\n  __nla_put lib/nlattr.c:1041 [inline]\n  nla_put+0x1c6/0x230\
  \ lib/nlattr.c:1099\n  tcf_skbmod_dump+0x23f/0xc20 net/sched/act_skbmod.c:256\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n  tcf_action_dump+0x1fd/0x460 net/sched/act_api.c:1251\n\
  \  tca_get_fill+0x519/0x7a0 net/sched/act_api.c:1628\n  tcf_add_notify_msg net/sched/act_api.c:2023\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2042 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x1365/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nLocal variable opt created at:\n  tcf_skbmod_dump+0x9d/0xc20 net/sched/act_skbmod.c:244\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n\nBytes 188-191 of 248 are uninitialized\nMemory access\
  \ of size 248 starts at ffff888117697680\nData copied to user address 00007ffe56d855f0\n\
  \nFixes: 86da71b57383 (\"net_sched: Introduce skbmod action\")\nSigned-off-by: Eric\
  \ Dumazet <edumazet@google.com>\nAcked-by: Jamal Hadi Salim <jhs@mojatatu.com>\n\
  Link: https://lore.kernel.org/r/20240403130908.93421-1-edumazet@google.com\nSigned-off-by:\
  \ Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: tcf_skbmod_dump\
  \ in net/sched/act_skbmod.c\nstatic int tcf_skbmod_dump(struct sk_buff *skb, struct\
  \ tc_action *a,\n\t\t\t   int bind, int ref)\n{\n\tstruct tcf_skbmod *d = to_skbmod(a);\n\
  \tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_skbmod_params  *p;\n\t\
  struct tc_skbmod opt = {\n\t\t.index   = d->tcf_index,\n\t\t.refcnt  = refcount_read(&d->tcf_refcnt)\
  \ - ref,\n\t\t.bindcnt = atomic_read(&d->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t\
  \ t;\n\n\tspin_lock_bh(&d->tcf_lock);\n\topt.action = d->tcf_action;\n\tp = rcu_dereference_protected(d->skbmod_p,\n\
  \t\t\t\t      lockdep_is_held(&d->tcf_lock));\n\topt.flags  = p->flags;\n\tif (nla_put(skb,\
  \ TCA_SKBMOD_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_DMAC) &&\n\t    nla_put(skb, TCA_SKBMOD_DMAC, ETH_ALEN, p->eth_dst))\n\
  \t\tgoto nla_put_failure;\n\tif ((p->flags & SKBMOD_F_SMAC) &&\n\t    nla_put(skb,\
  \ TCA_SKBMOD_SMAC, ETH_ALEN, p->eth_src))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_ETYPE) &&\n\t    nla_put_u16(skb, TCA_SKBMOD_ETYPE, ntohs(p->eth_type)))\n\
  \t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &d->tcf_tm);\n\tif (nla_put_64bit(skb,\
  \ TCA_SKBMOD_TM, sizeof(t), &t, TCA_SKBMOD_PAD))\n\t\tgoto nla_put_failure;\n\n\t\
  spin_unlock_bh(&d->tcf_lock);\n\treturn skb->len;\nnla_put_failure:\n\tspin_unlock_bh(&d->tcf_lock);\n\
  \tnlmsg_trim(skb, b);\n\treturn -1;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff\
  \ --git a/net/sched/act_skbmod.c b/net/sched/act_skbmod.c\nindex 39945b139c48..cd0accaf844a\
  \ 100644\n--- a/net/sched/act_skbmod.c\n+++ b/net/sched/act_skbmod.c\n@@ -241,13\
  \ +241,13 @@ static int tcf_skbmod_dump(struct sk_buff *skb, struct tc_action *a,\n\
  \ \tstruct tcf_skbmod *d = to_skbmod(a);\n \tunsigned char *b = skb_tail_pointer(skb);\n\
  \ \tstruct tcf_skbmod_params  *p;\n-\tstruct tc_skbmod opt = {\n-\t\t.index   =\
  \ d->tcf_index,\n-\t\t.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n-\t\t.bindcnt\
  \ = atomic_read(&d->tcf_bindcnt) - bind,\n-\t};\n+\tstruct tc_skbmod opt;\n \tstruct\
  \ tcf_t t;\n \n+\tmemset(&opt, 0, sizeof(opt));\n+\topt.index   = d->tcf_index;\n\
  +\topt.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n+\topt.bindcnt = atomic_read(&d->tcf_bindcnt)\
  \ - bind;\n \tspin_lock_bh(&d->tcf_lock);\n \topt.action = d->tcf_action;\n \tp\
  \ = rcu_dereference_protected(d->skbmod_p,\n```\n"
pattern: '## Bug Pattern


  Copying a stack-allocated struct to user space using sizeof(struct) (e.g., via nla_put/copy_to_user)
  without first zeroing the entire struct, when the struct contains padding/holes.
  Only assigning selected fields (even with designated initializers) leaves padding
  bytes uninitialized, causing a kernel information leak when the raw struct memory
  is exported.


  Example:

  struct foo s;            // has padding

  s.a = ...; s.b = ...;    // fields set, padding untouched

  nla_put(skb, ATTR, sizeof(s), &s);  // leaks uninitialized padding bytes


  Correct pattern: memset(&s, 0, sizeof(s)) (or kzalloc for heap) before filling fields.'
plan: "1) Program state\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(StructZeroedMap, const\
  \ MemRegion*, bool)\n  - Meaning: for a stack struct object region, true means we\
  \ have seen a full-object zeroing (e.g., memset(&obj, 0, sizeof(obj))). If the key\
  \ is absent, treat it as not zeroed.\n\n- No other traits or alias maps are needed.\
  \ We will only match address-of the local variable directly at sinks/zeroing calls\
  \ to keep the checker simple and precise.\n\n2) Helper utilities (internal to the\
  \ checker)\n\n- getAddrOfLocalVar(const Expr *E) -> const VarDecl*\n  - Strip parens\
  \ and implicit casts. If E is UnaryOperator '&' applied to a DeclRefExpr that refers\
  \ to a VarDecl with automatic storage (local) and record type (struct/union), return\
  \ that VarDecl; else return null.\n\n- getVarRegion(const VarDecl *VD, CheckerContext\
  \ &C) -> const MemRegion*\n  - Use State->getLValue(VD, C.getLocationContext())\
  \ and getAsRegion() to obtain the VarRegion.\n\n- isZeroingCall(const CallEvent\
  \ &Call, const Expr* &PtrArg, const Expr* &ValArg, const Expr* &SizeArg) -> bool\n\
  \  - Return true if callee name is one of: \"memset\", \"__builtin_memset\", \"\
  memzero_explicit\", \"bzero\".\n  - For memset/::__builtin_memset, set PtrArg=arg0,\
  \ ValArg=arg1, SizeArg=arg2.\n  - For memzero_explicit, set PtrArg=arg0, ValArg=null,\
  \ SizeArg=arg1.\n  - For bzero, set PtrArg=arg0, ValArg=null, SizeArg=arg1.\n\n\
  - zeroValueIsConstZero(const Expr *ValArg, CheckerContext &C) -> bool\n  - For memset-like\
  \ functions that have a value argument, use EvaluateExprToInt to check that it equals\
  \ 0.\n\n- sizeMatchesVarType(const Expr *SizeArg, const VarDecl *VD, CheckerContext\
  \ &C) -> bool\n  - If SizeArg is a UnaryExprOrTypeTraitExpr (sizeof):\n    - If\
  \ sizeof(type): compare the canonical unqualified type to VD->getType() ignoring\
  \ qualifiers and attributes.\n    - If sizeof(expr): inspect the expression; if\
  \ it\u2019s a DeclRefExpr to VD or an expression with the same type as VD->getType(),\
  \ accept.\n  - Otherwise, fallback heuristic: ExprHasName(SizeArg, VD->getName(),\
  \ C).\n  - Return true if the sizeof likely refers to the same struct object or\
  \ its type.\n\n- isSinkCall(const CallEvent &Call, unsigned &SizeIdx, unsigned &DataIdx)\
  \ -> bool\n  - Recognize:\n    - \"nla_put\": SizeIdx=2, DataIdx=3\n    - \"nla_put_64bit\"\
  : SizeIdx=2, DataIdx=3\n    - \"copy_to_user\": SizeIdx=2, DataIdx=1\n    - \"copy_to_user_nofault\"\
  : SizeIdx=2, DataIdx=1\n    - \"__copy_to_user\": SizeIdx=2, DataIdx=1\n    - \"\
  __copy_to_user_inatomic\": SizeIdx=2, DataIdx=1\n    - \"copy_to_user_iter\": SizeIdx=2\
  \ (or 3 depending on variant) and DataIdx=1 (use the common 3-arg pattern: dst,\
  \ src, size)\n  - Return true and set indices if matched; otherwise false.\n\n-\
  \ hasAnyPadding(const VarDecl *VD, CheckerContext &C) -> bool\n  - Use ASTContext\
  \ &Ctx = C.getASTContext().\n  - If VD->getType() is not a RecordType, return false.\n\
  \  - Get RecordDecl *RD = VD->getType()->getAsRecordDecl().\n  - If RD is null,\
  \ return false.\n  - Use const ASTRecordLayout &L = Ctx.getASTRecordLayout(RD).\n\
  \  - Iterate RD\u2019s fields in declaration order:\n    - Keep running end-bit\
  \ offset AccEnd; initially 0.\n    - For each FieldDecl F:\n      - Get bit offset\
  \ Ofs = L.getFieldOffset(FIndex).\n      - If Ofs > AccEnd -> internal padding exists,\
  \ return true.\n      - AccEnd = Ofs + Ctx.getTypeSize(F->getType()).\n  - After\
  \ loop, if L.getSize() > AccEnd -> tail padding exists, return true.\n  - Otherwise\
  \ return false.\n\n3) Callbacks and behaviors\n\n- checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const\n  A) Detect full-object zeroing\n  - If isZeroingCall(Call,\
  \ PtrArg, ValArg, SizeArg):\n    - For memset-like calls that have ValArg, require\
  \ zeroValueIsConstZero(ValArg, C) == true. For the others (memzero_explicit/bzero),\
  \ no value check needed.\n    - Extract the local VarDecl with getAddrOfLocalVar(PtrArg).\
  \ If null, return.\n    - Verify sizeMatchesVarType(SizeArg, VD, C). If false, return.\n\
  \    - Obtain region: getVarRegion(VD, C).\n    - State = State->set<StructZeroedMap>(Region,\
  \ true); C.addTransition(State).\n    - Return.\n\n  B) Detect sinks that copy the\
  \ whole struct to user/netlink\n  - If isSinkCall(Call, SizeIdx, DataIdx):\n   \
  \ - DataE = Call.getArgExpr(DataIdx).\n    - Try to get local VarDecl: VD = getAddrOfLocalVar(DataE).\
  \ If null, return.\n    - Ensure the variable is automatic storage and has RecordType\
  \ (VD->isLocalVarDecl() and VD->getType()->isRecordType()).\n    - SizeE = Call.getArgExpr(SizeIdx).\
  \ If not sizeMatchesVarType(SizeE, VD, C), return.\n    - Optional precision filter:\
  \ if !hasAnyPadding(VD, C), return (avoid false positives when there is no padding).\n\
  \    - Get region: R = getVarRegion(VD, C).\n    - Look up map: Zeroed = State->get<StructZeroedMap>(R);\
  \ treat absent as false.\n    - If Zeroed is not true:\n      - Report a bug:\n\
  \        - Create BugType: \"Potential kernel info leak\".\n        - Generate a\
  \ non-fatal error node and emit PathSensitiveBugReport with message:\n         \
  \ \"Struct with padding copied without memset; possible kernel info leak.\"\n  \
  \    - Do not change state.\n\n- Other callbacks\n  - None required. We purposely\
  \ avoid checkBind/aliasing to keep it simple and robust for the primary pattern\
  \ (&local passed directly).\n\n4) Notes for robust matching\n\n- For detecting the\
  \ local variable in pointer arguments:\n  - Accept forms like \"&opt\", \"(void\
  \ *)&opt\", \"&(opt)\"; strip parens/casts.\n  - Do not consider heap pointers;\
  \ only direct address-of the local struct variable.\n\n- For memset-like detection:\n\
  \  - Only accept when the size is syntactically bound to the same object/type via\
  \ sizeof (per sizeMatchesVarType).\n  - This guarantees we recognize full-object\
  \ zeroing that also clears padding.\n\n- For sinks:\n  - The checker aims at the\
  \ high-signal cases where len == sizeof(obj) and data == &obj.\n  - This matches\
  \ the kernel pattern in the provided patch (nla_put with sizeof(opt), &opt).\n\n\
  - False-positive control:\n  - Only warn for local stack records.\n  - Only warn\
  \ when record layout actually has padding (hasAnyPadding == true).\n  - Only warn\
  \ when we didn\u2019t see a confirmed full-object zeroing.\n\n5) Bug report\n\n\
  - Message: \"Struct with padding copied without memset; possible kernel info leak.\"\
  \n- Location: the call expression of the sink (Call.getOriginExpr()).\n- Single\
  \ BugType for this checker; use PathSensitiveBugReport with a short note pointing\
  \ to the data argument as the tainted source if possible (track the Expr &opt as\
  \ a range)."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/Lex/Lexer.h\"\n#include\
  \ <memory>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\
  \n// Track whether a stack struct object has been explicitly zeroed via a full-object\
  \ zeroing.\nREGISTER_MAP_WITH_PROGRAMSTATE(StructZeroedMap, const MemRegion*, bool)\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this,\
  \ \"Potential kernel info leak\", \"Security\")) {}\n\n  void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  const\
  \ VarDecl *getAddrOfLocalVar(const Expr *E) const;\n  const MemRegion *getVarRegion(const\
  \ VarDecl *VD, CheckerContext &C) const;\n\n  bool isZeroingCall(const CallEvent\
  \ &Call,\n                     const Expr *&PtrArg, const Expr *&ValArg, const Expr\
  \ *&SizeArg,\n                     CheckerContext &C) const;\n\n  bool zeroValueIsConstZero(const\
  \ Expr *ValArg, CheckerContext &C) const;\n\n  bool sizeMatchesVarType(const Expr\
  \ *SizeArg, const VarDecl *VD,\n                          CheckerContext &C) const;\n\
  \n  bool isSinkCall(const CallEvent &Call, unsigned &SizeIdx, unsigned &DataIdx,\n\
  \                  CheckerContext &C) const;\n\n  bool hasAnyPadding(const VarDecl\
  \ *VD, CheckerContext &C) const;\n\n  void reportLeak(const CallEvent &Call, const\
  \ Expr *DataExpr, CheckerContext &C) const;\n};\n\n// ----- Helper Implementations\
  \ -----\n\nconst VarDecl *SAGenTestChecker::getAddrOfLocalVar(const Expr *E) const\
  \ {\n  if (!E) return nullptr;\n  const Expr *EE = E->IgnoreParenImpCasts();\n \
  \ const auto *UO = dyn_cast<UnaryOperator>(EE);\n  if (!UO || UO->getOpcode() !=\
  \ UO_AddrOf)\n    return nullptr;\n\n  const Expr *Sub = UO->getSubExpr();\n  if\
  \ (!Sub) return nullptr;\n  Sub = Sub->IgnoreParenImpCasts();\n\n  const auto *DRE\
  \ = dyn_cast<DeclRefExpr>(Sub);\n  if (!DRE) return nullptr;\n\n  const auto *VD\
  \ = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD) return nullptr;\n\n  // Only\
  \ consider local (automatic storage) non-parameter variables with record type.\n\
  \  if (!VD->isLocalVarDecl())\n    return nullptr;\n\n  if (!VD->getType()->isRecordType())\n\
  \    return nullptr;\n\n  return VD;\n}\n\nconst MemRegion *SAGenTestChecker::getVarRegion(const\
  \ VarDecl *VD, CheckerContext &C) const {\n  if (!VD) return nullptr;\n  ProgramStateRef\
  \ State = C.getState();\n  SVal LV = State->getLValue(VD, C.getLocationContext());\n\
  \  const MemRegion *MR = LV.getAsRegion();\n  if (!MR) return nullptr;\n  return\
  \ MR->getBaseRegion();\n}\n\nbool SAGenTestChecker::isZeroingCall(const CallEvent\
  \ &Call,\n                                     const Expr *&PtrArg, const Expr *&ValArg,\
  \ const Expr *&SizeArg,\n                                     CheckerContext &C)\
  \ const {\n  PtrArg = nullptr; ValArg = nullptr; SizeArg = nullptr;\n\n  const Expr\
  \ *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n\n  // memset\
  \ and builtin memset: memset(ptr, 0, sizeof(...))\n  if (ExprHasName(Origin, \"\
  memset\", C) || ExprHasName(Origin, \"__builtin_memset\", C)) {\n    if (Call.getNumArgs()\
  \ >= 3) {\n      PtrArg = Call.getArgExpr(0);\n      ValArg = Call.getArgExpr(1);\n\
  \      SizeArg = Call.getArgExpr(2);\n      return PtrArg && SizeArg;\n    }\n \
  \   return false;\n  }\n\n  // memzero_explicit(ptr, sizeof(...))\n  if (ExprHasName(Origin,\
  \ \"memzero_explicit\", C)) {\n    if (Call.getNumArgs() >= 2) {\n      PtrArg =\
  \ Call.getArgExpr(0);\n      SizeArg = Call.getArgExpr(1);\n      ValArg = nullptr;\n\
  \      return PtrArg && SizeArg;\n    }\n    return false;\n  }\n\n  // bzero(ptr,\
  \ sizeof(...))\n  if (ExprHasName(Origin, \"bzero\", C)) {\n    if (Call.getNumArgs()\
  \ >= 2) {\n      PtrArg = Call.getArgExpr(0);\n      SizeArg = Call.getArgExpr(1);\n\
  \      ValArg = nullptr;\n      return PtrArg && SizeArg;\n    }\n    return false;\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::zeroValueIsConstZero(const\
  \ Expr *ValArg, CheckerContext &C) const {\n  if (!ValArg) return true; // Functions\
  \ without value arg are always zeroing\n  llvm::APSInt V;\n  if (!EvaluateExprToInt(V,\
  \ ValArg, C))\n    return false;\n  return V == 0;\n}\n\nbool SAGenTestChecker::sizeMatchesVarType(const\
  \ Expr *SizeArg, const VarDecl *VD,\n                                          CheckerContext\
  \ &C) const {\n  if (!SizeArg || !VD)\n    return false;\n\n  const Expr *E = SizeArg->IgnoreParenImpCasts();\n\
  \  const auto *UETT = dyn_cast<UnaryExprOrTypeTraitExpr>(E);\n  ASTContext &Ctx\
  \ = C.getASTContext();\n  QualType VarTy = VD->getType();\n\n  if (UETT && UETT->getKind()\
  \ == UETT_SizeOf) {\n    if (UETT->isArgumentType()) {\n      QualType T = UETT->getArgumentType();\n\
  \      // Compare canonical unqualified types\n      QualType T1 = Ctx.getCanonicalType(T).getUnqualifiedType();\n\
  \      QualType T2 = Ctx.getCanonicalType(VarTy).getUnqualifiedType();\n      if\
  \ (Ctx.hasSameType(T1, T2))\n        return true;\n    } else {\n      const Expr\
  \ *ArgE = UETT->getArgumentExpr();\n      if (ArgE) {\n        ArgE = ArgE->IgnoreParenImpCasts();\n\
  \        if (const auto *DRE = dyn_cast<DeclRefExpr>(ArgE)) {\n          if (DRE->getDecl()\
  \ == VD)\n            return true;\n        }\n        // Fallback: if sizeof(expr)\
  \ where expr type matches var type\n        QualType ETy = ArgE->getType();\n  \
  \      QualType T1 = Ctx.getCanonicalType(ETy).getUnqualifiedType();\n        QualType\
  \ T2 = Ctx.getCanonicalType(VarTy).getUnqualifiedType();\n        if (Ctx.hasSameType(T1,\
  \ T2))\n          return true;\n      }\n    }\n  }\n\n  // Fallback heuristic:\
  \ the size expression text contains the variable name.\n  return ExprHasName(SizeArg,\
  \ VD->getName(), C);\n}\n\nbool SAGenTestChecker::isSinkCall(const CallEvent &Call,\
  \ unsigned &SizeIdx, unsigned &DataIdx,\n                                  CheckerContext\
  \ &C) const {\n  SizeIdx = DataIdx = 0;\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // nla_put(skb, type, len, data)\n  if (ExprHasName(Origin,\
  \ \"nla_put\", C)) {\n    if (Call.getNumArgs() >= 4) {\n      SizeIdx = 2;\n  \
  \    DataIdx = 3;\n      return true;\n    }\n    return false;\n  }\n\n  if (ExprHasName(Origin,\
  \ \"nla_put_64bit\", C)) {\n    if (Call.getNumArgs() >= 5) {\n      SizeIdx = 2;\n\
  \      DataIdx = 3;\n      return true;\n    }\n    return false;\n  }\n\n  // copy_to_user(dst,\
  \ src, size) and variants\n  if (ExprHasName(Origin, \"copy_to_user\", C) ||\n \
  \     ExprHasName(Origin, \"copy_to_user_nofault\", C) ||\n      ExprHasName(Origin,\
  \ \"__copy_to_user\", C) ||\n      ExprHasName(Origin, \"__copy_to_user_inatomic\"\
  , C)) {\n    if (Call.getNumArgs() >= 3) {\n      DataIdx = 1;\n      SizeIdx =\
  \ 2;\n      return true;\n    }\n    return false;\n  }\n\n  // copy_to_user_iter(dst,\
  \ src, size) - treat similarly\n  if (ExprHasName(Origin, \"copy_to_user_iter\"\
  , C)) {\n    if (Call.getNumArgs() >= 3) {\n      DataIdx = 1;\n      SizeIdx =\
  \ 2;\n      return true;\n    }\n    return false;\n  }\n\n  return false;\n}\n\n\
  bool SAGenTestChecker::hasAnyPadding(const VarDecl *VD, CheckerContext &C) const\
  \ {\n  if (!VD) return false;\n  QualType QT = VD->getType();\n  const RecordType\
  \ *RT = QT->getAs<RecordType>();\n  if (!RT) return false;\n\n  const RecordDecl\
  \ *RD = RT->getDecl();\n  if (!RD) return false;\n  RD = RD->getDefinition();\n\
  \  if (!RD) return false;\n\n  ASTContext &Ctx = C.getASTContext();\n  const ASTRecordLayout\
  \ &L = Ctx.getASTRecordLayout(RD);\n\n  if (RD->isUnion()) {\n    // Union has padding\
  \ if its total size is greater than the largest field size.\n    uint64_t MaxFieldSize\
  \ = 0;\n    for (const FieldDecl *FD : RD->fields()) {\n      uint64_t FSz = FD->isBitField()\
  \ ? FD->getBitWidthValue(Ctx)\n                                      : Ctx.getTypeSize(FD->getType());\n\
  \      if (FSz > MaxFieldSize)\n        MaxFieldSize = FSz;\n    }\n    uint64_t\
  \ UnionSize = static_cast<uint64_t>(L.getSize().getQuantity()) * Ctx.getCharWidth();\n\
  \    return UnionSize > MaxFieldSize;\n  }\n\n  // Struct: check internal and tail\
  \ padding\n  uint64_t AccEnd = 0;\n  unsigned Index = 0;\n  for (const FieldDecl\
  \ *FD : RD->fields()) {\n    uint64_t Ofs = L.getFieldOffset(Index++);\n    if (Ofs\
  \ > AccEnd)\n      return true; // internal padding\n\n    uint64_t FSz = FD->isBitField()\
  \ ? FD->getBitWidthValue(Ctx)\n                                    : Ctx.getTypeSize(FD->getType());\n\
  \    uint64_t End = Ofs + FSz;\n    if (End > AccEnd)\n      AccEnd = End;\n  }\n\
  \n  uint64_t Total = static_cast<uint64_t>(L.getSize().getQuantity()) * Ctx.getCharWidth();\n\
  \  if (Total > AccEnd)\n    return true; // tail padding\n\n  return false;\n}\n\
  \nvoid SAGenTestChecker::reportLeak(const CallEvent &Call, const Expr *DataExpr,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n   \
  \   *BT, \"Struct with padding copied without memset; possible kernel info leak.\"\
  , N);\n\n  if (const Expr *OE = Call.getOriginExpr())\n    R->addRange(OE->getSourceRange());\n\
  \  if (DataExpr)\n    R->addRange(DataExpr->getSourceRange());\n\n  C.emitReport(std::move(R));\n\
  }\n\n// ----- Main callback -----\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\n\
  \  // A) Detect full-object zeroing of a local struct: memset(&obj, 0, sizeof(obj))\n\
  \  {\n    const Expr *PtrArg = nullptr, *ValArg = nullptr, *SizeArg = nullptr;\n\
  \    if (isZeroingCall(Call, PtrArg, ValArg, SizeArg, C)) {\n      // For memset-like,\
  \ ensure value is zero.\n      if (!zeroValueIsConstZero(ValArg, C)) {\n       \
  \ // Not a definitive zeroing, ignore.\n      } else {\n        const VarDecl *VD\
  \ = getAddrOfLocalVar(PtrArg);\n        if (VD && sizeMatchesVarType(SizeArg, VD,\
  \ C)) {\n          const MemRegion *MR = getVarRegion(VD, C);\n          if (MR)\
  \ {\n            State = State->set<StructZeroedMap>(MR, true);\n            C.addTransition(State);\n\
  \            return; // zeroing case handled\n          }\n        }\n      }\n\
  \    }\n  }\n\n  // B) Detect sinks that copy a whole struct to user space/netlink\n\
  \  {\n    unsigned SizeIdx = 0, DataIdx = 0;\n    if (!isSinkCall(Call, SizeIdx,\
  \ DataIdx, C))\n      return;\n\n    const Expr *DataE = Call.getArgExpr(DataIdx);\n\
  \    const VarDecl *VD = getAddrOfLocalVar(DataE);\n    if (!VD)\n      return;\n\
  \n    // Must match size with the struct object (i.e., copying the whole object)\n\
  \    const Expr *SizeE = Call.getArgExpr(SizeIdx);\n    if (!sizeMatchesVarType(SizeE,\
  \ VD, C))\n      return;\n\n    // If there is no padding, there is no leak from\
  \ padding.\n    if (!hasAnyPadding(VD, C))\n      return;\n\n    const MemRegion\
  \ *MR = getVarRegion(VD, C);\n    if (!MR)\n      return;\n\n    const bool *Zeroed\
  \ = State->get<StructZeroedMap>(MR);\n    if (!(Zeroed && *Zeroed)) {\n      //\
  \ Not confirmed zeroed, report potential leak.\n      reportLeak(Call, DataE, C);\n\
  \    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects copying stack structs with padding to user space without memset\
  \ zeroing\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
