_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 81137162bfaa7278785b24c1fd2e9e74f082e8e4
commit_type: Buffer-Overflow
index: 8
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/APInt.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program state needed.\n\nnamespace {\n\nstatic const Expr *getUnderlyingArrayExpr(const\
  \ Expr *E) {\n  if (!E)\n    return nullptr;\n\n  // Prefer to get the subexpression\
  \ before array-to-pointer decay.\n  if (const auto *ICE = dyn_cast<ImplicitCastExpr>(E))\
  \ {\n    if (ICE->getCastKind() == CK_ArrayToPointerDecay) {\n      return ICE->getSubExpr()->IgnoreParenImpCasts();\n\
  \    }\n  }\n  return E->IgnoreParenImpCasts();\n}\n\nstatic bool getFixedCharArraySize(const\
  \ Expr *E, CheckerContext &C,\n                                  llvm::APInt &OutSize)\
  \ {\n  if (!E)\n    return false;\n\n  QualType QT = E->getType();\n  const ConstantArrayType\
  \ *CAT = C.getASTContext().getAsConstantArrayType(QT);\n  if (!CAT)\n    return\
  \ false;\n\n  QualType ElemTy = CAT->getElementType();\n  if (!ElemTy.isAnyCharacterType())\n\
  \    return false;\n\n  OutSize = CAT->getSize();\n  return true;\n}\n\n/* The checker\
  \ callbacks are to be decided. */\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unbounded string copy\", \"Security\")) {}\n\n      void\
  \ checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\
  \n      void reportStrcpyOverflow(const CallEvent &Call, CheckerContext &C,\n  \
  \                              StringRef Msg) const;\n};\n\nvoid SAGenTestChecker::reportStrcpyOverflow(const\
  \ CallEvent &Call,\n                                            CheckerContext &C,\n\
  \                                            StringRef Msg) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  // Identify strcpy\n  bool IsStrcpy = false;\n  const Expr *OriginExpr\
  \ = Call.getOriginExpr();\n  if (OriginExpr && ExprHasName(OriginExpr, \"strcpy\"\
  , C))\n    IsStrcpy = true;\n  if (const IdentifierInfo *II = Call.getCalleeIdentifier())\n\
  \    IsStrcpy = IsStrcpy || II->getName() == \"strcpy\";\n\n  if (!IsStrcpy)\n \
  \   return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n  // Get destination\
  \ argument and determine if it's a fixed-size char array.\n  const Expr *DestArg\
  \ = Call.getArgExpr(0);\n  const Expr *DestArrExpr = getUnderlyingArrayExpr(DestArg);\n\
  \  llvm::APInt DestSize;\n  if (!getFixedCharArraySize(DestArrExpr, C, DestSize))\n\
  \    return; // Only warn when destination capacity is known and char-like.\n\n\
  \  uint64_t DestCap = DestSize.getZExtValue();\n\n  // Analyze source argument.\n\
  \  const Expr *SrcArg = Call.getArgExpr(1);\n  llvm::APInt SrcLiteralLen;\n  if\
  \ (getStringSize(SrcLiteralLen, SrcArg)) {\n    // StringLiteral length excludes\
  \ the null terminator.\n    uint64_t SrcLen = SrcLiteralLen.getZExtValue();\n  \
  \  // strcpy writes SrcLen + 1 bytes including the terminator.\n    if (SrcLen >=\
  \ DestCap) {\n      reportStrcpyOverflow(Call, C,\n        \"strcpy to fixed-size\
  \ buffer overflows; use strscpy(dest, src, sizeof(dest))\");\n    }\n    // Else:\
  \ Source literal fits; no warning.\n    return;\n  }\n\n  // Non-literal or unknown\
  \ source length: warn as potentially overflowing.\n  reportStrcpyOverflow(Call,\
  \ C,\n    \"strcpy to fixed-size buffer may overflow; use strscpy(dest, src, sizeof(dest))\"\
  );\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects strcpy into fixed-size buffers; suggest strscpy with sizeof(dest)\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: hci_core: Fix possible buffer overflow\n\
  \nstruct hci_dev_info has a fixed size name[8] field so in the event that\nhdev->name\
  \ is bigger than that strcpy would attempt to write past its\nsize, so this fixes\
  \ this problem by switching to use strscpy.\n\nFixes: dcda165706b9 (\"Bluetooth:\
  \ hci_core: Fix build warnings\")\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\n\
  \n## Buggy Code\n\n```c\n// Function: hci_get_dev_info in net/bluetooth/hci_core.c\n\
  int hci_get_dev_info(void __user *arg)\n{\n\tstruct hci_dev *hdev;\n\tstruct hci_dev_info\
  \ di;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (copy_from_user(&di, arg,\
  \ sizeof(di)))\n\t\treturn -EFAULT;\n\n\thdev = hci_dev_get(di.dev_id);\n\tif (!hdev)\n\
  \t\treturn -ENODEV;\n\n\t/* When the auto-off is configured it means the transport\n\
  \t * is running, but in that case still indicate that the\n\t * device is actually\
  \ down.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_AUTO_OFF))\n\t\tflags = hdev->flags\
  \ & ~BIT(HCI_UP);\n\telse\n\t\tflags = hdev->flags;\n\n\tstrcpy(di.name, hdev->name);\n\
  \tdi.bdaddr   = hdev->bdaddr;\n\tdi.type     = (hdev->bus & 0x0f) | ((hdev->dev_type\
  \ & 0x03) << 4);\n\tdi.flags    = flags;\n\tdi.pkt_type = hdev->pkt_type;\n\tif\
  \ (lmp_bredr_capable(hdev)) {\n\t\tdi.acl_mtu  = hdev->acl_mtu;\n\t\tdi.acl_pkts\
  \ = hdev->acl_pkts;\n\t\tdi.sco_mtu  = hdev->sco_mtu;\n\t\tdi.sco_pkts = hdev->sco_pkts;\n\
  \t} else {\n\t\tdi.acl_mtu  = hdev->le_mtu;\n\t\tdi.acl_pkts = hdev->le_pkts;\n\t\
  \tdi.sco_mtu  = 0;\n\t\tdi.sco_pkts = 0;\n\t}\n\tdi.link_policy = hdev->link_policy;\n\
  \tdi.link_mode   = hdev->link_mode;\n\n\tmemcpy(&di.stat, &hdev->stat, sizeof(di.stat));\n\
  \tmemcpy(&di.features, &hdev->features, sizeof(di.features));\n\n\tif (copy_to_user(arg,\
  \ &di, sizeof(di)))\n\t\terr = -EFAULT;\n\n\thci_dev_put(hdev);\n\n\treturn err;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c\n\
  index 6ca4c0df9f9c..230d2bbb933b 100644\n--- a/net/bluetooth/hci_core.c\n+++ b/net/bluetooth/hci_core.c\n\
  @@ -908,7 +908,7 @@ int hci_get_dev_info(void __user *arg)\n \telse\n \t\tflags\
  \ = hdev->flags;\n \n-\tstrcpy(di.name, hdev->name);\n+\tstrscpy(di.name, hdev->name,\
  \ sizeof(di.name));\n \tdi.bdaddr   = hdev->bdaddr;\n \tdi.type     = (hdev->bus\
  \ & 0x0f) | ((hdev->dev_type & 0x03) << 4);\n \tdi.flags    = flags;\n```\n"
pattern: '## Bug Pattern


  Using an unbounded string copy (strcpy) to write a potentially longer source string
  (e.g., hdev->name) into a fixed-size destination buffer in a struct (e.g., di.name[8])
  without checking or limiting the length, leading to buffer overflow. The correct
  approach is a bounded copy such as strscpy(dest, src, sizeof(dest)).'
plan: "Plan\n\n1. Program state\n- No custom program state is necessary. This checker\
  \ is a local call-usage checker that inspects each strcpy call\u2019s arguments\
  \ and their types/sizes.\n\n2. Callback functions\n- Use only checkPreCall. Everything\
  \ can be determined at the moment of the call.\n\n3. checkPreCall: detect unsafe\
  \ strcpy into fixed-size arrays\n- Goal: Warn when strcpy copies into a fixed-size\
  \ character array whose capacity is known (e.g., di.name[8]) and the source length\
  \ is not provably smaller than the destination capacity. This covers the bug pattern\
  \ of unbounded copy into fixed-size buffers.\n- Steps:\n  a) Identify strcpy:\n\
  \     - Get the callee identifier via Call.getCalleeIdentifier(). If null, return.\n\
  \     - If name != \"strcpy\", return.\n\n  b) Retrieve destination (arg 0) and\
  \ determine if it is a decayed fixed-size array:\n     - Let Dest = Call.getArgExpr(0).\n\
  \     - Peel implicit casts: If Dest is an ImplicitCastExpr with cast kind CK_ArrayToPointerDecay,\
  \ then get the underlying array expression Arr = cast<ImplicitCastExpr>(Dest)->getSubExpr()->IgnoreParenImpCasts().\n\
  \     - Determine the array type and its size:\n       - QualType QT = Arr->getType().\n\
  \       - const ConstantArrayType *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr()).\n\
  \       - If CAT is null, the destination is not a compile-time fixed-size array;\
  \ return (to reduce false positives).\n       - Check that the element type is a\
  \ character type: CAT->getElementType() is \u2018char\u2019, \u2018signed char\u2019\
  , or \u2018unsigned char\u2019. If not char-like, return.\n       - Extract DestSize\
  \ = CAT->getSize() (APInt).\n\n     - Note: If Dest is not an ImplicitCastExpr with\
  \ ArrayToPointerDecay, you can still check if Dest->IgnoreParenImpCasts() has array\
  \ type (rare). Prefer the decay path.\n\n  c) Estimate the source length or bound:\n\
  \     - Let Src = Call.getArgExpr(1).\n     - Fast-path: StringLiteral\n       -\
  \ If Src is a StringLiteral (via provided getStringSize(StringSize, Src)), compute\
  \ SrcLen = StringSize (length without null terminator).\n       - If SrcLen >= DestSize\
  \ (APInt comparison), emit a bug (since strcpy copies the terminating \u2018\\0\u2019\
  , strings of length >= DestSize overflow).\n       - If SrcLen < DestSize, consider\
  \ safe and return.\n     - Otherwise, try to detect a compile-time fixed-size source\
  \ array (optional improvement; see note):\n       - If Src is also an ArrayToPointerDecay\
  \ of a ConstantArrayType (same approach as for Dest), you can compute SrcCap = source\
  \ array capacity. However, array capacity is not a strict upper bound of string\
  \ length (string can be up to capacity-1), so you cannot prove safety from this\
  \ alone. For simplicity and to align with the target pattern, do not suppress the\
  \ warning based on source capacity. Proceed to the next step.\n     - Otherwise\
  \ (unknown or non-literal source):\n       - Treat as potentially unbounded. Since\
  \ Dest is a fixed-size array and strcpy is unbounded, emit a warning.\n\n  d) Bug\
  \ reporting:\n     - Create a BugType (e.g., \"Unbounded string copy into fixed-size\
  \ buffer\") once in the checker.\n     - Generate a non-fatal error node with C.generateNonFatalErrorNode().\n\
  \     - Emit a PathSensitiveBugReport with a short message, e.g.:\n       - \"strcpy\
  \ to fixed-size buffer may overflow; use strscpy(dest, src, sizeof(dest)).\"\n \
  \    - Attach the call expression\u2019s source range as the location/range to highlight.\n\
  \n4. Helper logic details (within checkPreCall)\n- Function identification:\n  -\
  \ Use Call.getCalleeIdentifier()->getName() == \"strcpy\".\n\n- Determining fixed-size\
  \ array destination (robust handling):\n  - Primary method: Look for ImplicitCastExpr\
  \ of CK_ArrayToPointerDecay on arg0; then read the subexpression\u2019s type as\
  \ ConstantArrayType.\n  - If needed, also handle Dest->IgnoreParenImpCasts() whose\
  \ type is ConstantArrayType (edge cases).\n  - Ensure the element type is character-like\
  \ (char/signed char/unsigned char) to avoid false positives on non-string arrays.\n\
  \n- String literal length:\n  - Use provided getStringSize(StringSize, Src). Length\
  \ excludes the null-terminator. Compare as:\n    - If StringSize >= DestSize =>\
  \ overflow (report).\n    - Else safe (no report).\n\n- Optional suppression (keep\
  \ simple for initial version):\n  - Only suppress if source is a string literal\
  \ with length strictly less than destination capacity.\n  - For all other sources\
  \ (unknown, pointers, struct member arrays, etc.) consider unsafe and report.\n\n\
  5. Why this is sufficient for the target patch\n- The buggy code uses strcpy(di.name,\
  \ hdev->name) where di.name is a fixed-size array of length 8. The destination will\
  \ be recognized as a decayed ConstantArrayType with size 8. The source is not a\
  \ string literal, so the checker will emit a warning advising to use strscpy(...,\
  \ ..., sizeof(dest)), matching the provided fix.\n\n6. Notes\n- No need to track\
  \ aliases or data flow: the decision is local to each strcpy call.\n- No need to\
  \ model post-call state.\n- Keep the checker narrow to reduce FPs: only warn when\
  \ destination capacity is known at compile-time (ConstantArrayType). This precisely\
  \ targets the class of bugs fixed by switching to strscpy with sizeof(dest)."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/APInt.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program state needed.\n\nnamespace {\n\nstatic const Expr *getUnderlyingArrayExpr(const\
  \ Expr *E) {\n  if (!E)\n    return nullptr;\n\n  // Prefer to get the subexpression\
  \ before array-to-pointer decay.\n  if (const auto *ICE = dyn_cast<ImplicitCastExpr>(E))\
  \ {\n    if (ICE->getCastKind() == CK_ArrayToPointerDecay) {\n      return ICE->getSubExpr()->IgnoreParenImpCasts();\n\
  \    }\n  }\n  return E->IgnoreParenImpCasts();\n}\n\nstatic bool getFixedCharArraySize(const\
  \ Expr *E, CheckerContext &C,\n                                  llvm::APInt &OutSize)\
  \ {\n  if (!E)\n    return false;\n\n  QualType QT = E->getType();\n  const ConstantArrayType\
  \ *CAT = C.getASTContext().getAsConstantArrayType(QT);\n  if (!CAT)\n    return\
  \ false;\n\n  QualType ElemTy = CAT->getElementType();\n  if (!ElemTy->isAnyCharacterType())\n\
  \    return false;\n\n  OutSize = CAT->getSize();\n  return true;\n}\n\n/* The checker\
  \ callbacks are to be decided. */\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unbounded string copy\", \"Security\")) {}\n\n      void\
  \ checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\
  \n      void reportStrcpyOverflow(const CallEvent &Call, CheckerContext &C,\n  \
  \                              StringRef Msg) const;\n};\n\nvoid SAGenTestChecker::reportStrcpyOverflow(const\
  \ CallEvent &Call,\n                                            CheckerContext &C,\n\
  \                                            StringRef Msg) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  // Identify strcpy\n  bool IsStrcpy = false;\n  const Expr *OriginExpr\
  \ = Call.getOriginExpr();\n  if (OriginExpr && ExprHasName(OriginExpr, \"strcpy\"\
  , C))\n    IsStrcpy = true;\n  if (const IdentifierInfo *II = Call.getCalleeIdentifier())\n\
  \    IsStrcpy = IsStrcpy || II->getName() == \"strcpy\";\n\n  if (!IsStrcpy)\n \
  \   return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n  // Get destination\
  \ argument and determine if it's a fixed-size char array.\n  const Expr *DestArg\
  \ = Call.getArgExpr(0);\n  const Expr *DestArrExpr = getUnderlyingArrayExpr(DestArg);\n\
  \  llvm::APInt DestSize;\n  if (!getFixedCharArraySize(DestArrExpr, C, DestSize))\n\
  \    return; // Only warn when destination capacity is known and char-like.\n\n\
  \  uint64_t DestCap = DestSize.getZExtValue();\n\n  // Analyze source argument.\n\
  \  const Expr *SrcArg = Call.getArgExpr(1);\n  llvm::APInt SrcLiteralLen;\n  if\
  \ (getStringSize(SrcLiteralLen, SrcArg)) {\n    // StringLiteral length excludes\
  \ the null terminator.\n    uint64_t SrcLen = SrcLiteralLen.getZExtValue();\n  \
  \  // strcpy writes SrcLen + 1 bytes including the terminator.\n    if (SrcLen >=\
  \ DestCap) {\n      reportStrcpyOverflow(Call, C,\n        \"strcpy to fixed-size\
  \ buffer overflows; use strscpy(dest, src, sizeof(dest))\");\n    }\n    // Else:\
  \ Source literal fits; no warning.\n    return;\n  }\n\n  // Non-literal or unknown\
  \ source length: warn as potentially overflowing.\n  reportStrcpyOverflow(Call,\
  \ C,\n    \"strcpy to fixed-size buffer may overflow; use strscpy(dest, src, sizeof(dest))\"\
  );\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects strcpy into fixed-size buffers; suggest strscpy with sizeof(dest)\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
