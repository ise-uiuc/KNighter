_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: e61dd678601eac53d501dda1eb1bcffec7b11bd6
commit_type: Double-Free
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Program state: track device base objects whose buckets_nouse\
  \ have been freed\nREGISTER_SET_WITH_PROGRAMSTATE(ManualFreedBucketsNouse, const\
  \ MemRegion *)\nREGISTER_SET_WITH_PROGRAMSTATE(HighLevelFreedBucketsNouse, const\
  \ MemRegion *)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Double free of member\", \"Memory Management\")) {}\n\
  \n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n \
  \  private:\n      // Helpers\n      static bool isKfree(const CallEvent &Call,\
  \ CheckerContext &C);\n      static bool isBucketsHLFree(const CallEvent &Call,\
  \ CheckerContext &C);\n\n      const MemRegion *getOwnerRegionIfMember(const Expr\
  \ *Arg, StringRef MemberName,\n                                              CheckerContext\
  \ &C) const;\n\n      const MemRegion *getArgBaseRegion(const CallEvent &Call, unsigned\
  \ Idx,\n                                        CheckerContext &C) const;\n\n  \
  \    void reportDoubleFree(const CallEvent &Call, CheckerContext &C) const;\n};\n\
  \n// Determine if the call is to kfree(...)\nbool SAGenTestChecker::isKfree(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin) return false;\n  return ExprHasName(Origin, \"kfree\", C);\n}\n\n\
  // Determine if the call is to bch2_dev_buckets_free(ca)\nbool SAGenTestChecker::isBucketsHLFree(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin) return false;\n  return ExprHasName(Origin, \"bch2_dev_buckets_free\"\
  , C);\n}\n\n// If Arg contains a MemberExpr accessing the specified member, return\
  \ the base object's region.\nconst MemRegion *SAGenTestChecker::getOwnerRegionIfMember(const\
  \ Expr *Arg, StringRef MemberName,\n                                           \
  \               CheckerContext &C) const {\n  if (!Arg)\n    return nullptr;\n\n\
  \  const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(Arg);\n  if (!ME)\n\
  \    return nullptr;\n\n  const ValueDecl *MD = ME->getMemberDecl();\n  if (!MD)\n\
  \    return nullptr;\n\n  if (MD->getName() != MemberName)\n    return nullptr;\n\
  \n  const Expr *BaseE = ME->getBase();\n  if (!BaseE)\n    return nullptr;\n\n \
  \ const MemRegion *MR = getMemRegionFromExpr(BaseE, C);\n  if (!MR)\n    return\
  \ nullptr;\n\n  return MR->getBaseRegion();\n}\n\n// Get base region for an argument\
  \ expression (e.g., the device object \"ca\" for HL free)\nconst MemRegion *SAGenTestChecker::getArgBaseRegion(const\
  \ CallEvent &Call, unsigned Idx,\n                                             \
  \       CheckerContext &C) const {\n  if (Idx >= Call.getNumArgs())\n    return\
  \ nullptr;\n\n  const Expr *AE = Call.getArgExpr(Idx);\n  if (!AE)\n    return nullptr;\n\
  \n  const MemRegion *MR = getMemRegionFromExpr(AE, C);\n  if (!MR)\n    return nullptr;\n\
  \n  return MR->getBaseRegion();\n}\n\n// Report a double free\nvoid SAGenTestChecker::reportDoubleFree(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ \"Double free of buckets_nouse\", N);\n  R->addRange(Call.getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\n\
  \  // Handle high-level free: bch2_dev_buckets_free(ca)\n  if (isBucketsHLFree(Call,\
  \ C)) {\n    const MemRegion *Base = getArgBaseRegion(Call, 0, C);\n    if (!Base)\n\
  \      return;\n\n    // If manual free was already done on this base, it's a double\
  \ free\n    if (State->contains<ManualFreedBucketsNouse>(Base)) {\n      reportDoubleFree(Call,\
  \ C);\n      return;\n    }\n\n    // Remember that the HL free has been performed\
  \ for this base\n    State = State->add<HighLevelFreedBucketsNouse>(Base);\n   \
  \ C.addTransition(State);\n    return;\n  }\n\n  // Handle manual free: kfree(ca->buckets_nouse)\n\
  \  if (isKfree(Call, C)) {\n    if (Call.getNumArgs() == 0)\n      return;\n\n \
  \   const Expr *ArgE = Call.getArgExpr(0);\n    const MemRegion *Base = getOwnerRegionIfMember(ArgE,\
  \ \"buckets_nouse\", C);\n    if (!Base)\n      return; // Not freeing the specific\
  \ member we care about\n\n    // If HL free already happened, this is a double free\n\
  \    if (State->contains<HighLevelFreedBucketsNouse>(Base)) {\n      reportDoubleFree(Call,\
  \ C);\n      return;\n    }\n\n    // Record manual free of the member\n    State\
  \ = State->add<ManualFreedBucketsNouse>(Base);\n    C.addTransition(State);\n  \
  \  return;\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects double free of ca->buckets_nouse when both kfree(member) and\
  \ bch2_dev_buckets_free(ca) are called\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbcachefs: Fix double free of ca->buckets_nouse\n\n\
  Reported-by: Dan Carpenter <dan.carpenter@linaro.org>\nFixes: ffcbec6076 (\"bcachefs:\
  \ Kill opts.buckets_nouse\")\nSigned-off-by: Kent Overstreet <kent.overstreet@linux.dev>\n\
  \n## Buggy Code\n\n```c\n// Function: bch2_dev_free in fs/bcachefs/super.c\nstatic\
  \ void bch2_dev_free(struct bch_dev *ca)\n{\n\tcancel_work_sync(&ca->io_error_work);\n\
  \n\tif (ca->kobj.state_in_sysfs &&\n\t    ca->disk_sb.bdev)\n\t\tsysfs_remove_link(bdev_kobj(ca->disk_sb.bdev),\
  \ \"bcachefs\");\n\n\tif (ca->kobj.state_in_sysfs)\n\t\tkobject_del(&ca->kobj);\n\
  \n\tkfree(ca->buckets_nouse);\n\tbch2_free_super(&ca->disk_sb);\n\tbch2_dev_allocator_background_exit(ca);\n\
  \tbch2_dev_journal_exit(ca);\n\n\tfree_percpu(ca->io_done);\n\tbch2_dev_buckets_free(ca);\n\
  \tfree_page((unsigned long) ca->sb_read_scratch);\n\n\tbch2_time_stats_quantiles_exit(&ca->io_latency[WRITE]);\n\
  \tbch2_time_stats_quantiles_exit(&ca->io_latency[READ]);\n\n\tpercpu_ref_exit(&ca->io_ref);\n\
  #ifndef CONFIG_BCACHEFS_DEBUG\n\tpercpu_ref_exit(&ca->ref);\n#endif\n\tkobject_put(&ca->kobj);\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/fs/bcachefs/super.c b/fs/bcachefs/super.c\n\
  index 0455a1001fec..e7fa2de35014 100644\n--- a/fs/bcachefs/super.c\n+++ b/fs/bcachefs/super.c\n\
  @@ -1193,7 +1193,6 @@ static void bch2_dev_free(struct bch_dev *ca)\n \tif (ca->kobj.state_in_sysfs)\n\
  \ \t\tkobject_del(&ca->kobj);\n \n-\tkfree(ca->buckets_nouse);\n \tbch2_free_super(&ca->disk_sb);\n\
  \ \tbch2_dev_allocator_background_exit(ca);\n \tbch2_dev_journal_exit(ca);\n```\n"
pattern: '## Bug Pattern


  Manually freeing a member pointer in a teardown path while also calling a higher-level
  cleanup function that frees the same member. Specifically, kfree(ca->buckets_nouse)
  is performed even though bch2_dev_buckets_free(ca) already releases ca->buckets_nouse,
  causing a double free.'
plan: "Plan\n\n1. Program state\n- Register two per-path sets to remember which device\
  \ object (base) has had the specific member freed manually or by the higher-level\
  \ cleanup:\n  - REGISTER_SET_WITH_PROGRAMSTATE(ManualFreedBucketsNouse, const MemRegion*)\n\
  \  - REGISTER_SET_WITH_PROGRAMSTATE(HighLevelFreedBucketsNouse, const MemRegion*)\n\
  - No other custom state (traits/maps) is needed. We only track whether the \u201C\
  ca\u201D base object for ca->buckets_nouse was freed manually and/or via the high-level\
  \ function.\n\n2. Helper utilities\n- isKfree(const CallEvent &Call): return true\
  \ if callee identifier name is \"kfree\".\n- isBucketsHLFree(const CallEvent &Call):\
  \ return true if callee identifier name is \"bch2_dev_buckets_free\".\n- getOwnerRegionIfMember(const\
  \ Expr *Arg, StringRef MemberName, CheckerContext &C):\n  - Use findSpecificTypeInChildren<MemberExpr>(Arg)\
  \ to find a MemberExpr inside the call argument (after ignoring casts/implicits).\n\
  \  - If found, check MemberExpr->getMemberDecl()->getName() equals MemberName (\"\
  buckets_nouse\").\n  - If matches, return getMemRegionFromExpr(MemberExpr->getBase(),\
  \ C) to identify the owner object (\u201Cca\u201D).\n  - Otherwise return nullptr.\n\
  - getArgBaseRegion(const CallEvent &Call, unsigned Idx, CheckerContext &C):\n  -\
  \ For bch2_dev_buckets_free(ca), return getMemRegionFromExpr(Call.getArgExpr(0),\
  \ C).\n\n3. Main detection logic in checkPreCall\n- Goal: Report when both of these\
  \ happen on the same base object region, in any order:\n  - Manual free: kfree(ca->buckets_nouse)\n\
  \  - High-level free: bch2_dev_buckets_free(ca)\n- Steps:\n  a) Handle high-level\
  \ free call\n     - If isBucketsHLFree(Call):\n       - const MemRegion *Base =\
  \ getArgBaseRegion(Call, 0, C); if !Base return.\n       - ProgramStateRef State\
  \ = C.getState();\n       - If Base is in ManualFreedBucketsNouse set:\n       \
  \  - This path already manually freed ca->buckets_nouse; calling the HL free again\
  \ yields a double free.\n         - Generate a non-fatal error node and emit a PathSensitiveBugReport\
  \ with a short message: \"Double free of buckets_nouse\".\n       - Else:\n    \
  \     - Insert Base into HighLevelFreedBucketsNouse set and C.addTransition(NewState).\n\
  \  b) Handle manual kfree of the specific member\n     - If isKfree(Call):\n   \
  \    - const Expr *Arg = Call.getArgExpr(0);\n       - const MemRegion *Base = getOwnerRegionIfMember(Arg,\
  \ \"buckets_nouse\", C);\n       - If !Base, return (we only care about ca->buckets_nouse).\n\
  \       - ProgramStateRef State = C.getState();\n       - If Base is in HighLevelFreedBucketsNouse\
  \ set:\n         - The HL free was already (or will be) invoked; freeing this member\
  \ manually causes double free.\n         - Report with message: \"Double free of\
  \ buckets_nouse\".\n       - Else:\n         - Insert Base into ManualFreedBucketsNouse\
  \ set and C.addTransition(NewState).\n\n4. Reporting\n- Use a single BugType member\
  \ (lazy-initialized) with a clear, short name, for example: \"Double free of member\"\
  .\n- At the second event on-path (either HL free follows manual free, or manual\
  \ free follows HL free), build a non-fatal error node (generateNonFatalErrorNode).\
  \ If null, return. Otherwise create PathSensitiveBugReport with:\n  - Message: \"\
  Double free of buckets_nouse\".\n  - Location: the call expression of the second\
  \ event (Call.getSourceRange()).\n  - Emit via C.emitReport.\n\n5. Optional cleanup\n\
  - checkEndFunction: no special cleanup required; per-path state will be dropped\
  \ after function analysis. If desired, you can return a state with both sets cleared\
  \ to avoid cross-function bleed, but CSA already scopes state to contexts.\n\n6.\
  \ Notes and scope control\n- The checker is narrowly scoped to:\n  - Manual free\
  \ site: kfree(ca->buckets_nouse)\n  - High-level cleanup: bch2_dev_buckets_free(ca)\n\
  - We intentionally avoid pointer alias analysis to keep it simple and precise. Only\
  \ direct MemberExpr to \"buckets_nouse\" is flagged.\n- The order is handled symmetrically:\
  \ we report on whichever comes second along a path."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Program state: track device base objects whose buckets_nouse\
  \ have been freed\nREGISTER_SET_WITH_PROGRAMSTATE(ManualFreedBucketsNouse, const\
  \ MemRegion *)\nREGISTER_SET_WITH_PROGRAMSTATE(HighLevelFreedBucketsNouse, const\
  \ MemRegion *)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Double free of member\", \"Memory Management\")) {}\n\
  \n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n \
  \  private:\n      // Helpers\n      static bool isKfree(const CallEvent &Call,\
  \ CheckerContext &C);\n      static bool isBucketsHLFree(const CallEvent &Call,\
  \ CheckerContext &C);\n\n      const MemRegion *getOwnerRegionIfMember(const Expr\
  \ *Arg, StringRef MemberName,\n                                              CheckerContext\
  \ &C) const;\n\n      const MemRegion *getArgBaseRegion(const CallEvent &Call, unsigned\
  \ Idx,\n                                        CheckerContext &C) const;\n\n  \
  \    void reportDoubleFree(const CallEvent &Call, CheckerContext &C) const;\n};\n\
  \n// Determine if the call is to kfree(...)\nbool SAGenTestChecker::isKfree(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin) return false;\n  return ExprHasName(Origin, \"kfree\", C);\n}\n\n\
  // Determine if the call is to bch2_dev_buckets_free(ca)\nbool SAGenTestChecker::isBucketsHLFree(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin) return false;\n  return ExprHasName(Origin, \"bch2_dev_buckets_free\"\
  , C);\n}\n\n// If Arg contains a MemberExpr accessing the specified member, return\
  \ the base object's region.\nconst MemRegion *SAGenTestChecker::getOwnerRegionIfMember(const\
  \ Expr *Arg, StringRef MemberName,\n                                           \
  \               CheckerContext &C) const {\n  if (!Arg)\n    return nullptr;\n\n\
  \  const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(Arg);\n  if (!ME)\n\
  \    return nullptr;\n\n  const ValueDecl *MD = ME->getMemberDecl();\n  if (!MD)\n\
  \    return nullptr;\n\n  if (MD->getName() != MemberName)\n    return nullptr;\n\
  \n  const Expr *BaseE = ME->getBase();\n  if (!BaseE)\n    return nullptr;\n\n \
  \ const MemRegion *MR = getMemRegionFromExpr(BaseE, C);\n  if (!MR)\n    return\
  \ nullptr;\n\n  return MR->getBaseRegion();\n}\n\n// Get base region for an argument\
  \ expression (e.g., the device object \"ca\" for HL free)\nconst MemRegion *SAGenTestChecker::getArgBaseRegion(const\
  \ CallEvent &Call, unsigned Idx,\n                                             \
  \       CheckerContext &C) const {\n  if (Idx >= Call.getNumArgs())\n    return\
  \ nullptr;\n\n  const Expr *AE = Call.getArgExpr(Idx);\n  if (!AE)\n    return nullptr;\n\
  \n  const MemRegion *MR = getMemRegionFromExpr(AE, C);\n  if (!MR)\n    return nullptr;\n\
  \n  return MR->getBaseRegion();\n}\n\n// Report a double free\nvoid SAGenTestChecker::reportDoubleFree(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ \"Double free of buckets_nouse\", N);\n  R->addRange(Call.getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\n\
  \  // Handle high-level free: bch2_dev_buckets_free(ca)\n  if (isBucketsHLFree(Call,\
  \ C)) {\n    const MemRegion *Base = getArgBaseRegion(Call, 0, C);\n    if (!Base)\n\
  \      return;\n\n    // If manual free was already done on this base, it's a double\
  \ free\n    if (State->contains<ManualFreedBucketsNouse>(Base)) {\n      reportDoubleFree(Call,\
  \ C);\n      return;\n    }\n\n    // Remember that the HL free has been performed\
  \ for this base\n    State = State->add<HighLevelFreedBucketsNouse>(Base);\n   \
  \ C.addTransition(State);\n    return;\n  }\n\n  // Handle manual free: kfree(ca->buckets_nouse)\n\
  \  if (isKfree(Call, C)) {\n    if (Call.getNumArgs() == 0)\n      return;\n\n \
  \   const Expr *ArgE = Call.getArgExpr(0);\n    const MemRegion *Base = getOwnerRegionIfMember(ArgE,\
  \ \"buckets_nouse\", C);\n    if (!Base)\n      return; // Not freeing the specific\
  \ member we care about\n\n    // If HL free already happened, this is a double free\n\
  \    if (State->contains<HighLevelFreedBucketsNouse>(Base)) {\n      reportDoubleFree(Call,\
  \ C);\n      return;\n    }\n\n    // Record manual free of the member\n    State\
  \ = State->add<ManualFreedBucketsNouse>(Base);\n    C.addTransition(State);\n  \
  \  return;\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects double free of ca->buckets_nouse when both kfree(member) and\
  \ bch2_dev_buckets_free(ca) are called\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
