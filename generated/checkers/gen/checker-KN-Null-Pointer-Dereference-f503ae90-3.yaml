_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: f503ae90c7355e8506e68498fe84c1357894cd5b
commit_type: Null-Pointer-Dereference
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// Program state: map possibly-NULL\
  \ getter results to a \"checked\" flag.\n// false: unchecked; true: checked.\nREGISTER_MAP_WITH_PROGRAMSTATE(NullCkMap,\
  \ const MemRegion*, bool)\n// Program state: track pointer aliasing; map a region\
  \ to its \"root\" region.\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*,\
  \ const MemRegion*)\n\nnamespace {\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::PostCall,\n        check::Bind,\n        check::Location,\n    \
  \    check::BranchCondition> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n\
  \      SAGenTestChecker() : BT(new BugType(this, \"Dereference of possibly NULL\
  \ capability pointer\", \"API Misuse\")) {}\n\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const;\n      void checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      static bool isKnownPossiblyNullGetter(const CallEvent &Call, CheckerContext\
  \ &C);\n      static const MemRegion* findRootAlias(ProgramStateRef State, const\
  \ MemRegion *R);\n      static const MemRegion* getBaseRegionFromExpr(const Expr\
  \ *E, CheckerContext &C);\n      static ProgramStateRef setChecked(ProgramStateRef\
  \ State, const MemRegion *R);\n      void reportDeref(const Stmt *S, CheckerContext\
  \ &C, StringRef Msg = StringRef()) const;\n\n      template <typename E>\n     \
  \ static const E* findChild(const Stmt *S) {\n        return findSpecificTypeInChildren<E>(S);\n\
  \      }\n};\n\nbool SAGenTestChecker::isKnownPossiblyNullGetter(const CallEvent\
  \ &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n  if\
  \ (!Origin)\n    return false;\n  // Match exact function name as required.\n  return\
  \ ExprHasName(Origin, \"mt76_connac_get_he_phy_cap\", C);\n}\n\nconst MemRegion*\
  \ SAGenTestChecker::findRootAlias(ProgramStateRef State, const MemRegion *R) {\n\
  \  if (!R)\n    return nullptr;\n  const MemRegion *Cur = R->getBaseRegion();\n\
  \  while (true) {\n    const MemRegion *Next = State->get<PtrAliasMap>(Cur);\n \
  \   if (!Next || Next == Cur)\n      break;\n    Cur = Next->getBaseRegion();\n\
  \  }\n  return Cur;\n}\n\nconst MemRegion* SAGenTestChecker::getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E)\n    return nullptr;\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C);\n  if (!MR)\n    return nullptr;\n  return MR->getBaseRegion();\n\
  }\n\nProgramStateRef SAGenTestChecker::setChecked(ProgramStateRef State, const MemRegion\
  \ *R) {\n  if (!R)\n    return State;\n  R = R->getBaseRegion();\n  const MemRegion\
  \ *Root = findRootAlias(State, R);\n  if (!Root)\n    Root = R;\n  const bool *Checked\
  \ = State->get<NullCkMap>(Root);\n  if (Checked && *Checked == false) {\n    State\
  \ = State->set<NullCkMap>(Root, true);\n  }\n  return State;\n}\n\nvoid SAGenTestChecker::reportDeref(const\
  \ Stmt *S, CheckerContext &C, StringRef Msg) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  StringRef Message = Msg.empty()\n    ? \"Dereference\
  \ of possibly NULL capability pointer returned by mt76_connac_get_he_phy_cap\"\n\
  \    : Msg;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Message,\
  \ N);\n  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  if (!isKnownPossiblyNullGetter(Call, C))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n\
  \    return;\n\n  const MemRegion *RetRegFromExpr = getMemRegionFromExpr(Origin,\
  \ C);\n  if (!RetRegFromExpr)\n    return;\n\n  RetRegFromExpr = RetRegFromExpr->getBaseRegion();\n\
  \  if (!RetRegFromExpr)\n    return;\n\n  // Mark the getter result as \"unchecked\"\
  .\n  State = State->set<NullCkMap>(RetRegFromExpr, false);\n  // Make it its own\
  \ root in alias map.\n  State = State->set<PtrAliasMap>(RetRegFromExpr, RetRegFromExpr);\n\
  \n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Track pointer aliasing: p2 = p1;\n  if (const MemRegion *LHSReg = Loc.getAsRegion())\
  \ {\n    LHSReg = LHSReg->getBaseRegion();\n    if (LHSReg) {\n      if (const MemRegion\
  \ *RHSReg = Val.getAsRegion()) {\n        RHSReg = RHSReg->getBaseRegion();\n  \
  \      if (RHSReg) {\n          const MemRegion *Root = findRootAlias(State, RHSReg);\n\
  \          if (!Root)\n            Root = RHSReg;\n          // Only link if we\
  \ track the root or RHS is already rooted.\n          const bool *Tracked = State->get<NullCkMap>(Root);\n\
  \          if (Tracked) {\n            State = State->set<PtrAliasMap>(LHSReg, Root);\n\
  \          }\n        }\n      }\n    }\n  }\n\n  // Detect deref via address-of\
  \ member: ve = &vc->field;\n  // Look for '&' applied to an arrow member expression.\n\
  \  const UnaryOperator *UO = findChild<UnaryOperator>(S);\n  if (UO && UO->getOpcode()\
  \ == UO_AddrOf) {\n    const MemberExpr *ME = findChild<MemberExpr>(S);\n    if\
  \ (ME && ME->isArrow()) {\n      const Expr *BaseE = ME->getBase();\n      const\
  \ MemRegion *BaseReg = getBaseRegionFromExpr(BaseE, C);\n      if (BaseReg) {\n\
  \        const MemRegion *Root = findRootAlias(State, BaseReg);\n        if (!Root)\n\
  \          Root = BaseReg;\n        const bool *Checked = State->get<NullCkMap>(Root);\n\
  \        if (Checked && *Checked == false) {\n          reportDeref(S, C);\n   \
  \     }\n      }\n    }\n  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkLocation(SVal\
  \ L, bool IsLoad, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n  if (!S)\n    return;\n\n  const Expr *BaseE = nullptr;\n\n\
  \  // Prefer MemberExpr with '->'\n  if (const auto *ME = findChild<MemberExpr>(S))\
  \ {\n    if (ME->isArrow())\n      BaseE = ME->getBase();\n  }\n\n  // If not, check\
  \ for explicit dereference '*p'\n  if (!BaseE) {\n    if (const auto *UO = findChild<UnaryOperator>(S))\
  \ {\n      if (UO->getOpcode() == UO_Deref) {\n        BaseE = UO->getSubExpr();\n\
  \      }\n    }\n  }\n\n  // If not, check for array subscripting 'p[i]'\n  if (!BaseE)\
  \ {\n    if (const auto *ASE = findChild<ArraySubscriptExpr>(S)) {\n      BaseE\
  \ = ASE->getBase();\n    }\n  }\n\n  if (!BaseE)\n    return;\n\n  const MemRegion\
  \ *BaseReg = getBaseRegionFromExpr(BaseE, C);\n  if (!BaseReg)\n    return;\n\n\
  \  const MemRegion *Root = findRootAlias(State, BaseReg);\n  if (!Root)\n    Root\
  \ = BaseReg;\n\n  const bool *Checked = State->get<NullCkMap>(Root);\n  if (Checked\
  \ && *Checked == false) {\n    reportDeref(S, C);\n  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE) {\n   \
  \ C.addTransition(State);\n    return;\n  }\n\n  CondE = CondE->IgnoreParenCasts();\n\
  \n  // if (!p)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if\
  \ (UO->getOpcode() == UO_LNot) {\n      const Expr *SubE = UO->getSubExpr()->IgnoreParenCasts();\n\
  \      if (const MemRegion *MR = getBaseRegionFromExpr(SubE, C)) {\n        const\
  \ MemRegion *Root = findRootAlias(State, MR);\n        if (!Root)\n          Root\
  \ = MR;\n        const bool *Tracked = State->get<NullCkMap>(Root);\n        if\
  \ (Tracked && *Tracked == false) {\n          State = State->set<NullCkMap>(Root,\
  \ true);\n        }\n      }\n      C.addTransition(State);\n      return;\n   \
  \ }\n  }\n\n  // if (p == NULL) or if (p != NULL)\n  if (const auto *BO = dyn_cast<BinaryOperator>(CondE))\
  \ {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n    if (Op == BO_EQ || Op\
  \ == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n     \
  \ const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n      bool LHSIsNull =\
  \ LHS->isNullPointerConstant(C.getASTContext(),\n                              \
  \                    Expr::NPC_ValueDependentIsNull);\n      bool RHSIsNull = RHS->isNullPointerConstant(C.getASTContext(),\n\
  \                                                  Expr::NPC_ValueDependentIsNull);\n\
  \n      const Expr *PtrExpr = nullptr;\n      if (LHSIsNull && !RHSIsNull) PtrExpr\
  \ = RHS;\n      else if (RHSIsNull && !LHSIsNull) PtrExpr = LHS;\n\n      if (PtrExpr)\
  \ {\n        if (const MemRegion *MR = getBaseRegionFromExpr(PtrExpr, C)) {\n  \
  \        const MemRegion *Root = findRootAlias(State, MR);\n          if (!Root)\n\
  \            Root = MR;\n          const bool *Tracked = State->get<NullCkMap>(Root);\n\
  \          if (Tracked && *Tracked == false) {\n            State = State->set<NullCkMap>(Root,\
  \ true);\n          }\n        }\n      }\n      C.addTransition(State);\n     \
  \ return;\n    }\n  }\n\n  // if (p)\n  {\n    if (const MemRegion *MR = getBaseRegionFromExpr(CondE,\
  \ C)) {\n      const MemRegion *Root = findRootAlias(State, MR);\n      if (!Root)\n\
  \        Root = MR;\n      const bool *Tracked = State->get<NullCkMap>(Root);\n\
  \      if (Tracked && *Tracked == false) {\n        State = State->set<NullCkMap>(Root,\
  \ true);\n      }\n    }\n  }\n\n  C.addTransition(State);\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects dereference of capability pointer returned by mt76_connac_get_he_phy_cap\
  \ without NULL check\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nwifi: mt76: mt7996: fix NULL pointer dereference in\
  \ mt7996_mcu_sta_bfer_he\n\nFix the NULL pointer dereference in mt7996_mcu_sta_bfer_he\n\
  routine adding an sta interface to the mt7996 driver.\n\nFound by code review.\n\
  \nCc: stable@vger.kernel.org\nFixes: 98686cd21624 (\"wifi: mt76: mt7996: add driver\
  \ for MediaTek Wi-Fi 7 (802.11be) devices\")\nSigned-off-by: Ma Ke <make24@iscas.ac.cn>\n\
  Link: https://patch.msgid.link/20240813081242.3991814-1-make24@iscas.ac.cn\nSigned-off-by:\
  \ Felix Fietkau <nbd@nbd.name>\n\n## Buggy Code\n\n```c\n// Function: mt7996_mcu_sta_bfer_he\
  \ in drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nstatic void\nmt7996_mcu_sta_bfer_he(struct\
  \ ieee80211_sta *sta, struct ieee80211_vif *vif,\n\t\t       struct mt7996_phy *phy,\
  \ struct sta_rec_bf *bf)\n{\n\tstruct ieee80211_sta_he_cap *pc = &sta->deflink.he_cap;\n\
  \tstruct ieee80211_he_cap_elem *pe = &pc->he_cap_elem;\n\tconst struct ieee80211_sta_he_cap\
  \ *vc =\n\t\tmt76_connac_get_he_phy_cap(phy->mt76, vif);\n\tconst struct ieee80211_he_cap_elem\
  \ *ve = &vc->he_cap_elem;\n\tu16 mcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80);\n\
  \tu8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\tu8 snd_dim, sts;\n\n\tbf->tx_mode\
  \ = MT_PHY_TYPE_HE_SU;\n\n\tmt7996_mcu_sta_sounding_rate(bf);\n\n\tbf->trigger_su\
  \ = HE_PHY(CAP6_TRIG_SU_BEAMFORMING_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\tbf->trigger_mu\
  \ = HE_PHY(CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\
  \tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK,\n\t\t\t ve->phy_cap_info[5]);\n\
  \tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_MASK,\n\t\t     pe->phy_cap_info[4]);\n\
  \tbf->nrow = min_t(u8, snd_dim, sts);\n\tbf->ncol = min_t(u8, nss_mcs, bf->nrow);\n\
  \tbf->ibf_ncol = bf->ncol;\n\n\tif (sta->deflink.bandwidth != IEEE80211_STA_RX_BW_160)\n\
  \t\treturn;\n\n\t/* go over for 160MHz and 80p80 */\n\tif (pe->phy_cap_info[0] &\n\
  \t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G) {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_160);\n\
  \t\tnss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\n\t\tbf->ncol_gt_bw80 = nss_mcs;\n\
  \t}\n\n\tif (pe->phy_cap_info[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)\
  \ {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80p80);\n\t\tnss_mcs =\
  \ mt7996_mcu_get_sta_nss(mcs_map);\n\n\t\tif (bf->ncol_gt_bw80)\n\t\t\tbf->ncol_gt_bw80\
  \ = min_t(u8, bf->ncol_gt_bw80, nss_mcs);\n\t\telse\n\t\t\tbf->ncol_gt_bw80 = nss_mcs;\n\
  \t}\n\n\tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_MASK,\n\t\t\t\
  \ ve->phy_cap_info[5]);\n\tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_MASK,\n\
  \t\t     pe->phy_cap_info[4]);\n\n\tbf->nrow_gt_bw80 = min_t(int, snd_dim, sts);\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\
  \ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nindex e8d34bfbb41a..8855095fef10\
  \ 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n\
  @@ -1544,6 +1544,9 @@ mt7996_mcu_sta_bfer_he(struct ieee80211_sta *sta, struct ieee80211_vif\
  \ *vif,\n \tu8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n \tu8 snd_dim, sts;\n\
  \ \n+\tif (!vc)\n+\t\treturn;\n+\n \tbf->tx_mode = MT_PHY_TYPE_HE_SU;\n \n \tmt7996_mcu_sta_sounding_rate(bf);\n\
  ```\n"
pattern: "## Bug Pattern\n\nDereferencing a capability pointer returned by a getter\
  \ that may return NULL without first validating it. Specifically, using fields of\
  \ the pointer (e.g., vc->he_cap_elem / ve->phy_cap_info[\u2026]) before checking\
  \ that vc is non-NULL:\n- vc = mt76_connac_get_he_phy_cap(...)\n- ve = &vc->he_cap_elem;\
  \   // computed before validation\n- ... use ve->...          // dereference causes\
  \ NULL pointer deref if vc is NULL\n\nRoot cause: missing NULL check on the result\
  \ of a capability retrieval helper before accessing its members."
plan: "Plan: Detect dereferencing a capability pointer returned by a getter that may\
  \ be NULL (e.g., mt76_connac_get_he_phy_cap) before validating it\n\n1. Program\
  \ state\n- Use a simple state map to track pointers that originate from possibly-NULL\
  \ getters and whether they have been checked:\n  - REGISTER_MAP_WITH_PROGRAMSTATE(NullCkMap,\
  \ const MemRegion*, bool)\n    - Value false: result originates from a possibly-NULL\
  \ getter and has not been checked.\n    - Value true: the pointer (or an alias)\
  \ has been checked in some condition.\n- Track basic aliasing so that checks or\
  \ uses propagate:\n  - REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*,\
  \ const MemRegion*)\n    - Maps a pointer region to its \u201Croot/source\u201D\
  \ region (the original getter result). If a pointer is assigned from another pointer,\
  \ link the destination to the source so their \u201Cchecked\u201D state is shared.\n\
  - Helper: findRootAlias(State, R)\n  - Follow PtrAliasMap links until no mapping\
  \ exists; return the canonical root region to be used for lookups/updates in NullCkMap.\n\
  \n2. Callbacks and logic\n\nA. checkPostCall (mark possibly-NULL getter results)\n\
  - Goal: When a known getter that can return NULL is called, mark its return as unchecked.\n\
  - Implementation:\n  - Implement isKnownPossiblyNullGetter(const CallEvent &Call):\n\
  \    - Return true if callee name equals \"mt76_connac_get_he_phy_cap\".\n    -\
  \ Keep it simple and exact to avoid false positives.\n  - If true:\n    - Obtain\
  \ the return expression (Call.getOriginExpr()) and get its MemRegion using getMemRegionFromExpr.\n\
  \    - If region exists, insert into NullCkMap with value false (unchecked).\n \
  \   - Clear any PtrAliasMap mapping for this region (make it its own root).\n\n\
  B. checkBind (propagate aliases; detect \u201C&ptr->field\u201D deref)\n- Goal 1:\
  \ Track pointer aliasing p2 = p1.\n  - If Loc is a region for a pointer-typed variable\
  \ and Val is a region (another pointer):\n    - Let Rdst be destination region (from\
  \ Loc) and Rsrc be source region (from Val).\n    - Compute SrcRoot = findRootAlias(State,\
  \ Rsrc).\n    - If SrcRoot is in NullCkMap:\n      - Set PtrAliasMap[Rdst] = SrcRoot\
  \ (link destination to source root).\n      - If NullCkMap contains Rdst with a\
  \ different root, overwrite that with SrcRoot.\n      - Do not mark as checked here;\
  \ just propagate the unchecked/checked status from SrcRoot when needed by always\
  \ querying Root.\n- Goal 2: Catch deref via address-of member expression, e.g.,\
  \ ve = &vc->he_cap_elem;\n  - The expression does dereference the pointer even if\
  \ using &.\n  - In checkBind, inspect S (the assignment/initialization stmt):\n\
  \    - Find a UnaryOperator child that is address-of (&).\n    - Inside it, find\
  \ a MemberExpr child with isArrow() true (->).\n    - Get the base expression of\
  \ that MemberExpr and its MemRegion via getMemRegionFromExpr.\n    - Resolve Root\
  \ = findRootAlias(State, BaseRegion).\n    - If Root is in NullCkMap with value\
  \ false (unchecked), report a bug (see Reporting).\n  - This complements checkLocation\
  \ for the case where taking & of a member may not trigger a load.\n\nC. checkLocation\
  \ (detect deref uses such as p->f, *p, p[i])\n- Goal: When a load/store implicitly\
  \ dereferences a pointer that is known unchecked from a possibly-NULL getter, emit\
  \ a warning.\n- Implementation:\n  - Given Loc and S:\n    - Try to identify base\
  \ pointer expressions for common deref patterns in S:\n      - MemberExpr with isArrow()\
  \ true: base expression is the pointer being dereferenced.\n      - UnaryOperator\
  \ with opcode UO_Deref (*p): the subexpr is the pointer.\n      - ArraySubscriptExpr\
  \ p[i]: the base is the pointer.\n    - Use findSpecificTypeInChildren<MemberExpr/UnaryOperator/ArraySubscriptExpr>(S)\
  \ to detect these, preferring MemberExpr(->) if present.\n    - Extract the base\
  \ expression, get its MemRegion via getMemRegionFromExpr.\n    - Resolve Root =\
  \ findRootAlias(State, BaseRegion).\n    - If Root exists in NullCkMap with value\
  \ false (unchecked), emit a report.\n  - Optional conservative filter: If there\
  \ is no tracked region, do nothing; if it\u2019s tracked and checked, do nothing.\n\
  \nD. checkBranchCondition (mark pointers as checked when referenced in a condition)\n\
  - Goal: If the code references a tracked pointer in a condition (if (vc), if (vc\
  \ != NULL), if (!vc), etc.), mark it as checked to reduce false positives afterward.\n\
  - Implementation:\n  - Given Condition:\n    - Find any DeclRefExpr child; get its\
  \ MemRegion via getMemRegionFromExpr.\n    - For each such region:\n      - Resolve\
  \ Root = findRootAlias(State, Region).\n      - If Root is in NullCkMap with value\
  \ false, update that entry to true (checked).\n  - Note: This is a conservative\
  \ heuristic. We don\u2019t attempt to track branch direction; we just mark as checked\
  \ once a condition references the pointer, which is adequate for catching the immediate\
  \ \u201Cdereference before check\u201D pattern and reducing later false positives.\n\
  \n3. Reporting\n- Create a BugType once (e.g., \"Possible NULL dereference of capability\
  \ pointer\").\n- On detection in checkLocation/checkBind:\n  - Generate a non-fatal\
  \ error node.\n  - Emit a PathSensitiveBugReport with a short message:\n    - \"\
  Dereference of possibly NULL capability pointer returned by mt76_connac_get_he_phy_cap\"\
  \n  - Optionally, add a note range to the dereferencing expression (MemberExpr/UnaryOperator/ArraySubscriptExpr)\
  \ to highlight the exact use site.\n\n4. Notes on utilities usage\n- Use getMemRegionFromExpr\
  \ to convert base expressions and call expressions into MemRegion keys for the maps.\n\
  - Use findSpecificTypeInChildren to locate MemberExpr/UnaryOperator/ArraySubscriptExpr\
  \ within S for deref detection.\n- For branch condition handling, DeclRefExpr is\
  \ sufficient; we do not need to resolve NULL constants explicitly.\n- No need to\
  \ customize evalAssume or constraints; keep the checker simple and focused on the\
  \ immediate pattern.\n\n5. Summary of minimal steps\n- Track results of mt76_connac_get_he_phy_cap\
  \ as unchecked (checkPostCall).\n- Propagate pointer aliasing on assignments (checkBind).\n\
  - Detect dereferences via:\n  - checkLocation for p->f, *p, p[i].\n  - checkBind\
  \ for &p->f.\n- Mark pointers as checked when they appear in a branch condition\
  \ (checkBranchCondition).\n- Report when an unchecked pointer is dereferenced."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// Program state: map possibly-NULL\
  \ getter results to a \"checked\" flag.\n// false: unchecked; true: checked.\nREGISTER_MAP_WITH_PROGRAMSTATE(NullCkMap,\
  \ const MemRegion*, bool)\n// Program state: track pointer aliasing; map a region\
  \ to its \"root\" region.\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*,\
  \ const MemRegion*)\n\nnamespace {\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::PostCall,\n        check::Bind,\n        check::Location,\n    \
  \    check::BranchCondition> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n\
  \      SAGenTestChecker() : BT(new BugType(this, \"Dereference of possibly NULL\
  \ capability pointer\", \"API Misuse\")) {}\n\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const;\n      void checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      static bool isKnownPossiblyNullGetter(const CallEvent &Call, CheckerContext\
  \ &C);\n      static const MemRegion* findRootAlias(ProgramStateRef State, const\
  \ MemRegion *R);\n      static const MemRegion* getBaseRegionFromExpr(const Expr\
  \ *E, CheckerContext &C);\n      static ProgramStateRef setChecked(ProgramStateRef\
  \ State, const MemRegion *R);\n      void reportDeref(const Stmt *S, CheckerContext\
  \ &C, StringRef Msg = StringRef()) const;\n\n      template <typename E>\n     \
  \ static const E* findChild(const Stmt *S) {\n        return findSpecificTypeInChildren<E>(S);\n\
  \      }\n};\n\nbool SAGenTestChecker::isKnownPossiblyNullGetter(const CallEvent\
  \ &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n  if\
  \ (!Origin)\n    return false;\n  // Match exact function name as required.\n  return\
  \ ExprHasName(Origin, \"mt76_connac_get_he_phy_cap\", C);\n}\n\nconst MemRegion*\
  \ SAGenTestChecker::findRootAlias(ProgramStateRef State, const MemRegion *R) {\n\
  \  if (!R)\n    return nullptr;\n  const MemRegion *Cur = R->getBaseRegion();\n\
  \  while (true) {\n    const MemRegion *const *NextPtr = State->get<PtrAliasMap>(Cur);\n\
  \    if (!NextPtr)\n      break;\n    const MemRegion *Next = *NextPtr;\n    if\
  \ (!Next || Next == Cur)\n      break;\n    Cur = Next->getBaseRegion();\n  }\n\
  \  return Cur;\n}\n\nconst MemRegion* SAGenTestChecker::getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E)\n    return nullptr;\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C);\n  if (!MR)\n    return nullptr;\n  return MR->getBaseRegion();\n\
  }\n\nProgramStateRef SAGenTestChecker::setChecked(ProgramStateRef State, const MemRegion\
  \ *R) {\n  if (!R)\n    return State;\n  R = R->getBaseRegion();\n  const MemRegion\
  \ *Root = findRootAlias(State, R);\n  if (!Root)\n    Root = R;\n  const bool *Checked\
  \ = State->get<NullCkMap>(Root);\n  if (Checked && *Checked == false) {\n    State\
  \ = State->set<NullCkMap>(Root, true);\n  }\n  return State;\n}\n\nvoid SAGenTestChecker::reportDeref(const\
  \ Stmt *S, CheckerContext &C, StringRef Msg) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  StringRef Message = Msg.empty()\n    ? \"Dereference\
  \ of possibly NULL capability pointer returned by mt76_connac_get_he_phy_cap\"\n\
  \    : Msg;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Message,\
  \ N);\n  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  if (!isKnownPossiblyNullGetter(Call, C))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n\
  \    return;\n\n  const MemRegion *RetRegFromExpr = getMemRegionFromExpr(Origin,\
  \ C);\n  if (!RetRegFromExpr)\n    return;\n\n  RetRegFromExpr = RetRegFromExpr->getBaseRegion();\n\
  \  if (!RetRegFromExpr)\n    return;\n\n  // Mark the getter result as \"unchecked\"\
  .\n  State = State->set<NullCkMap>(RetRegFromExpr, false);\n  // Make it its own\
  \ root in alias map.\n  State = State->set<PtrAliasMap>(RetRegFromExpr, RetRegFromExpr);\n\
  \n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Track pointer aliasing: p2 = p1;\n  if (const MemRegion *LHSReg = Loc.getAsRegion())\
  \ {\n    LHSReg = LHSReg->getBaseRegion();\n    if (LHSReg) {\n      if (const MemRegion\
  \ *RHSReg = Val.getAsRegion()) {\n        RHSReg = RHSReg->getBaseRegion();\n  \
  \      if (RHSReg) {\n          const MemRegion *Root = findRootAlias(State, RHSReg);\n\
  \          if (!Root)\n            Root = RHSReg;\n          // Only link if we\
  \ track the root or RHS is already rooted.\n          const bool *Tracked = State->get<NullCkMap>(Root);\n\
  \          if (Tracked) {\n            State = State->set<PtrAliasMap>(LHSReg, Root);\n\
  \          }\n        }\n      }\n    }\n  }\n\n  // Detect deref via address-of\
  \ member: ve = &vc->field;\n  // Look for '&' applied to an arrow member expression.\n\
  \  const UnaryOperator *UO = findChild<UnaryOperator>(S);\n  if (UO && UO->getOpcode()\
  \ == UO_AddrOf) {\n    const MemberExpr *ME = findChild<MemberExpr>(S);\n    if\
  \ (ME && ME->isArrow()) {\n      const Expr *BaseE = ME->getBase();\n      const\
  \ MemRegion *BaseReg = getBaseRegionFromExpr(BaseE, C);\n      if (BaseReg) {\n\
  \        const MemRegion *Root = findRootAlias(State, BaseReg);\n        if (!Root)\n\
  \          Root = BaseReg;\n        const bool *Checked = State->get<NullCkMap>(Root);\n\
  \        if (Checked && *Checked == false) {\n          reportDeref(S, C);\n   \
  \     }\n      }\n    }\n  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkLocation(SVal\
  \ L, bool IsLoad, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n  if (!S)\n    return;\n\n  const Expr *BaseE = nullptr;\n\n\
  \  // Prefer MemberExpr with '->'\n  if (const auto *ME = findChild<MemberExpr>(S))\
  \ {\n    if (ME->isArrow())\n      BaseE = ME->getBase();\n  }\n\n  // If not, check\
  \ for explicit dereference '*p'\n  if (!BaseE) {\n    if (const auto *UO = findChild<UnaryOperator>(S))\
  \ {\n      if (UO->getOpcode() == UO_Deref) {\n        BaseE = UO->getSubExpr();\n\
  \      }\n    }\n  }\n\n  // If not, check for array subscripting 'p[i]'\n  if (!BaseE)\
  \ {\n    if (const auto *ASE = findChild<ArraySubscriptExpr>(S)) {\n      BaseE\
  \ = ASE->getBase();\n    }\n  }\n\n  if (!BaseE)\n    return;\n\n  const MemRegion\
  \ *BaseReg = getBaseRegionFromExpr(BaseE, C);\n  if (!BaseReg)\n    return;\n\n\
  \  const MemRegion *Root = findRootAlias(State, BaseReg);\n  if (!Root)\n    Root\
  \ = BaseReg;\n\n  const bool *Checked = State->get<NullCkMap>(Root);\n  if (Checked\
  \ && *Checked == false) {\n    reportDeref(S, C);\n  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE) {\n   \
  \ C.addTransition(State);\n    return;\n  }\n\n  CondE = CondE->IgnoreParenCasts();\n\
  \n  // if (!p)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if\
  \ (UO->getOpcode() == UO_LNot) {\n      const Expr *SubE = UO->getSubExpr()->IgnoreParenCasts();\n\
  \      if (const MemRegion *MR = getBaseRegionFromExpr(SubE, C)) {\n        const\
  \ MemRegion *Root = findRootAlias(State, MR);\n        if (!Root)\n          Root\
  \ = MR;\n        const bool *Tracked = State->get<NullCkMap>(Root);\n        if\
  \ (Tracked && *Tracked == false) {\n          State = State->set<NullCkMap>(Root,\
  \ true);\n        }\n      }\n      C.addTransition(State);\n      return;\n   \
  \ }\n  }\n\n  // if (p == NULL) or if (p != NULL)\n  if (const auto *BO = dyn_cast<BinaryOperator>(CondE))\
  \ {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n    if (Op == BO_EQ || Op\
  \ == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n     \
  \ const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n      bool LHSIsNull =\
  \ LHS->isNullPointerConstant(C.getASTContext(),\n                              \
  \                    Expr::NPC_ValueDependentIsNull);\n      bool RHSIsNull = RHS->isNullPointerConstant(C.getASTContext(),\n\
  \                                                  Expr::NPC_ValueDependentIsNull);\n\
  \n      const Expr *PtrExpr = nullptr;\n      if (LHSIsNull && !RHSIsNull) PtrExpr\
  \ = RHS;\n      else if (RHSIsNull && !LHSIsNull) PtrExpr = LHS;\n\n      if (PtrExpr)\
  \ {\n        if (const MemRegion *MR = getBaseRegionFromExpr(PtrExpr, C)) {\n  \
  \        const MemRegion *Root = findRootAlias(State, MR);\n          if (!Root)\n\
  \            Root = MR;\n          const bool *Tracked = State->get<NullCkMap>(Root);\n\
  \          if (Tracked && *Tracked == false) {\n            State = State->set<NullCkMap>(Root,\
  \ true);\n          }\n        }\n      }\n      C.addTransition(State);\n     \
  \ return;\n    }\n  }\n\n  // if (p)\n  {\n    if (const MemRegion *MR = getBaseRegionFromExpr(CondE,\
  \ C)) {\n      const MemRegion *Root = findRootAlias(State, MR);\n      if (!Root)\n\
  \        Root = MR;\n      const bool *Tracked = State->get<NullCkMap>(Root);\n\
  \      if (Tracked && *Tracked == false) {\n        State = State->set<NullCkMap>(Root,\
  \ true);\n      }\n    }\n  }\n\n  C.addTransition(State);\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects dereference of capability pointer returned by mt76_connac_get_he_phy_cap\
  \ without NULL check\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
