_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: ef307bc6ef04e8c1ea843231db58e3afaafa9fa6
commit_type: Concurrency
index: 7
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program states\nREGISTER_MAP_WITH_PROGRAMSTATE(LockCountMap, const MemRegion*,\
  \ unsigned)\nREGISTER_TRAIT_WITH_PROGRAMSTATE(LastUnlockedLock, const MemRegion*)\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<\n    check::BeginFunction,\n\
  \    check::EndFunction,\n    check::PreCall,\n    check::PostCall,\n    check::Bind>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unlock-before-nullify of shared pointer\", \"Concurrency\"\
  )) {}\n\n      void checkBeginFunction(CheckerContext &C) const;\n      void checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C) const;\n      void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      void checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const Stmt\
  \ *S, CheckerContext &C) const;\n\n   private:\n      // Helpers\n      bool isLockFunc(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      bool isUnlockFunc(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      const MemRegion *getLockRegionFromCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      bool isNullRHS(SVal Val, const\
  \ Expr *RHS, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isLockFunc(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  static const char *LockNames[]\
  \ = {\n    \"spin_lock\", \"spin_lock_irq\", \"spin_lock_bh\", \"spin_lock_irqsave\"\
  ,\n    \"mutex_lock\", \"read_lock\", \"write_lock\"\n  };\n  const Expr *E = Call.getOriginExpr();\n\
  \  if (!E) return false;\n  for (const char *N : LockNames) {\n    if (ExprHasName(E,\
  \ N, C))\n      return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isUnlockFunc(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  static const char *UnlockNames[]\
  \ = {\n    \"spin_unlock\", \"spin_unlock_irq\", \"spin_unlock_bh\", \"spin_unlock_irqrestore\"\
  ,\n    \"mutex_unlock\", \"read_unlock\", \"write_unlock\"\n  };\n  const Expr *E\
  \ = Call.getOriginExpr();\n  if (!E) return false;\n  for (const char *N : UnlockNames)\
  \ {\n    if (ExprHasName(E, N, C))\n      return true;\n  }\n  return false;\n}\n\
  \nconst MemRegion *SAGenTestChecker::getLockRegionFromCall(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  if (Call.getNumArgs() == 0)\n    return nullptr;\n\
  \  const Expr *Arg0 = Call.getArgExpr(0);\n  if (!Arg0)\n    return nullptr;\n \
  \ const MemRegion *MR = getMemRegionFromExpr(Arg0, C);\n  if (!MR)\n    return nullptr;\n\
  \  return MR->getBaseRegion();\n}\n\nbool SAGenTestChecker::isNullRHS(SVal V, const\
  \ Expr *RHS, CheckerContext &C) const {\n  if (auto DV = V.getAs<DefinedOrUnknownSVal>())\
  \ {\n    if (DV->isZeroConstant())\n      return true;\n  }\n\n  if (const Expr\
  \ *RE = dyn_cast_or_null<Expr>(RHS)) {\n    // Use AST check for null pointer constants\n\
  \    if (RE->isNullPointerConstant(C.getASTContext(),\n                        \
  \          Expr::NPC_ValueDependentIsNull))\n      return true;\n\n    // Fallback:\
  \ evaluate as int\n    llvm::APSInt Res;\n    if (EvaluateExprToInt(Res, RE, C))\
  \ {\n      if (Res == 0)\n        return true;\n    }\n\n    // Fallback to textual\
  \ check for NULL\n    if (ExprHasName(RE, \"NULL\", C))\n      return true;\n  }\n\
  \  return false;\n}\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  State = State->set<LastUnlockedLock>(nullptr);\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkEndFunction(const ReturnStmt\
  \ *RS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n  State\
  \ = State->set<LastUnlockedLock>(nullptr);\n  C.addTransition(State);\n}\n\nvoid\
  \ SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  ProgramStateRef State = C.getState();\n\n  if (isLockFunc(Call, C)) {\n \
  \   const MemRegion *LR = getLockRegionFromCall(Call, C);\n    if (LR) {\n     \
  \ const unsigned *Cnt = State->get<LockCountMap>(LR);\n      unsigned NewCnt = (Cnt\
  \ ? *Cnt : 0) + 1;\n      State = State->set<LockCountMap>(LR, NewCnt);\n    }\n\
  \    // Once we acquire a lock, clear the \"just-unlocked\" marker.\n    State =\
  \ State->set<LastUnlockedLock>(nullptr);\n    C.addTransition(State);\n    return;\n\
  \  }\n\n  // For any non-lock/non-unlock call, shrink the \"just-unlocked\" window.\n\
  \  if (!isUnlockFunc(Call, C)) {\n    const MemRegion *LUL = State->get<LastUnlockedLock>();\n\
  \    if (LUL) {\n      State = State->set<LastUnlockedLock>(nullptr);\n      C.addTransition(State);\n\
  \    }\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  if (isUnlockFunc(Call,\
  \ C)) {\n    const MemRegion *LR = getLockRegionFromCall(Call, C);\n    if (LR)\
  \ {\n      const unsigned *Cnt = State->get<LockCountMap>(LR);\n      if (Cnt &&\
  \ *Cnt > 1) {\n        State = State->set<LockCountMap>(LR, *Cnt - 1);\n      }\
  \ else {\n        State = State->remove<LockCountMap>(LR);\n      }\n      // Mark\
  \ this lock as just unlocked\n      State = State->set<LastUnlockedLock>(LR);\n\
  \    } else {\n      // Defensive\n      State = State->set<LastUnlockedLock>(nullptr);\n\
  \    }\n    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n  const MemRegion *JustUnlocked = State->get<LastUnlockedLock>();\n\
  \  if (!JustUnlocked)\n    return;\n\n  // Ensure the lock is not currently held.\n\
  \  if (const unsigned *Cnt = State->get<LockCountMap>(JustUnlocked)) {\n    if (*Cnt\
  \ > 0) {\n      // Clear the window and stop.\n      State = State->set<LastUnlockedLock>(nullptr);\n\
  \      C.addTransition(State);\n      return;\n    }\n  }\n\n  // We only care about\
  \ assignments, particularly to struct->pointer fields.\n  const BinaryOperator *BO\
  \ = dyn_cast_or_null<BinaryOperator>(S);\n  if (!BO || !BO->isAssignmentOp()) {\n\
  \    // Clear window after the first subsequent bind to keep \"immediate\" semantics.\n\
  \    State = State->set<LastUnlockedLock>(nullptr);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  const Expr *LHS = BO->getLHS();\n  const Expr *RHS = BO->getRHS();\n\
  \  if (!LHS || !RHS) {\n    State = State->set<LastUnlockedLock>(nullptr);\n   \
  \ C.addTransition(State);\n    return;\n  }\n\n  LHS = LHS->IgnoreParenCasts();\n\
  \  const MemberExpr *ME = dyn_cast<MemberExpr>(LHS);\n  if (!ME || !ME->isArrow())\
  \ {\n    // Not a pointer member access via '->'\n    State = State->set<LastUnlockedLock>(nullptr);\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  const ValueDecl *VD = ME->getMemberDecl();\n\
  \  const FieldDecl *FD = dyn_cast<FieldDecl>(VD);\n  if (!FD) {\n    State = State->set<LastUnlockedLock>(nullptr);\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  QualType FT = FD->getType();\n\
  \  if (!FT.getTypePtr() || !FT->isPointerType()) {\n    State = State->set<LastUnlockedLock>(nullptr);\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  // Check RHS is NULL\n  if (!isNullRHS(Val,\
  \ RHS, C)) {\n    State = State->set<LastUnlockedLock>(nullptr);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // All conditions met: just-unlocked, assignment to pointer\
  \ field, set to NULL.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if\
  \ (!N) {\n    State = State->set<LastUnlockedLock>(nullptr);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n    \
  \  *BT, \"Setting shared pointer field to NULL right after unlocking; move the assignment\
  \ before unlock\", N);\n  R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  \n  // Clear the window to avoid duplicates.\n  State = State->set<LastUnlockedLock>(nullptr);\n\
  \  C.addTransition(State);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect unlock-before-nullify of shared\
  \ pointer fields (TOCTOU race)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nusb: dwc2: fix possible NULL pointer dereference caused\
  \ by driver concurrency\n\nIn _dwc2_hcd_urb_enqueue(), \"urb->hcpriv = NULL\" is\
  \ executed without\nholding the lock \"hsotg->lock\". In _dwc2_hcd_urb_dequeue():\n\
  \n    spin_lock_irqsave(&hsotg->lock, flags);\n    ...\n\tif (!urb->hcpriv) {\n\t\
  \tdev_dbg(hsotg->dev, \"## urb->hcpriv is NULL ##\\n\");\n\t\tgoto out;\n\t}\n \
  \   rc = dwc2_hcd_urb_dequeue(hsotg, urb->hcpriv); // Use urb->hcpriv\n    ...\n\
  out:\n    spin_unlock_irqrestore(&hsotg->lock, flags);\n\nWhen _dwc2_hcd_urb_enqueue()\
  \ and _dwc2_hcd_urb_dequeue() are\nconcurrently executed, the NULL check of \"urb->hcpriv\"\
  \ can be executed\nbefore \"urb->hcpriv = NULL\". After urb->hcpriv is NULL, it\
  \ can be used\nin the function call to dwc2_hcd_urb_dequeue(), which can cause a\
  \ NULL\npointer dereference.\n\nThis possible bug is found by an experimental static\
  \ analysis tool\ndeveloped by myself. This tool analyzes the locking APIs to extract\n\
  function pairs that can be concurrently executed, and then analyzes the\ninstructions\
  \ in the paired functions to identify possible concurrency\nbugs including data\
  \ races and atomicity violations. The above possible\nbug is reported, when my tool\
  \ analyzes the source code of Linux 6.5.\n\nTo fix this possible bug, \"urb->hcpriv\
  \ = NULL\" should be executed with\nholding the lock \"hsotg->lock\". After using\
  \ this patch, my tool never\nreports the possible bug, with the kernelconfiguration\
  \ allyesconfig for\nx86_64. Because I have no associated hardware, I cannot test\
  \ the patch\nin runtime testing, and just verify it according to the code logic.\n\
  \nFixes: 33ad261aa62b (\"usb: dwc2: host: spinlock urb_enqueue\")\nSigned-off-by:\
  \ Jia-Ju Bai <baijiaju@buaa.edu.cn>\nLink: https://lore.kernel.org/r/20230926024404.832096-1-baijiaju@buaa.edu.cn\n\
  Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n\n## Buggy Code\n\
  \n```c\n// Function: _dwc2_hcd_urb_enqueue in drivers/usb/dwc2/hcd.c\nstatic int\
  \ _dwc2_hcd_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\t gfp_t mem_flags)\n\
  {\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tstruct usb_host_endpoint\
  \ *ep = urb->ep;\n\tstruct dwc2_hcd_urb *dwc2_urb;\n\tint i;\n\tint retval;\n\t\
  int alloc_bandwidth = 0;\n\tu8 ep_type = 0;\n\tu32 tflags = 0;\n\tvoid *buf;\n\t\
  unsigned long flags;\n\tstruct dwc2_qh *qh;\n\tbool qh_allocated = false;\n\tstruct\
  \ dwc2_qtd *qtd;\n\tstruct dwc2_gregs_backup *gr;\n\n\tgr = &hsotg->gr_backup;\n\
  \n\tif (dbg_urb(urb)) {\n\t\tdev_vdbg(hsotg->dev, \"DWC OTG HCD URB Enqueue\\n\"\
  );\n\t\tdwc2_dump_urb_info(hcd, urb, \"urb_enqueue\");\n\t}\n\n\tif (hsotg->hibernated)\
  \ {\n\t\tif (gr->gotgctl & GOTGCTL_CURMODE_HOST)\n\t\t\tretval = dwc2_exit_hibernation(hsotg,\
  \ 0, 0, 1);\n\t\telse\n\t\t\tretval = dwc2_exit_hibernation(hsotg, 0, 0, 0);\n\n\
  \t\tif (retval)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit hibernation failed.\\\
  n\");\n\t}\n\n\tif (hsotg->in_ppd) {\n\t\tretval = dwc2_exit_partial_power_down(hsotg,\
  \ 0, true);\n\t\tif (retval)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit partial_power_down\
  \ failed\\n\");\n\t}\n\n\tif (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_NONE\
  \ &&\n\t    hsotg->bus_suspended) {\n\t\tif (dwc2_is_device_mode(hsotg))\n\t\t\t\
  dwc2_gadget_exit_clock_gating(hsotg, 0);\n\t\telse\n\t\t\tdwc2_host_exit_clock_gating(hsotg,\
  \ 0);\n\t}\n\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tif (usb_pipetype(urb->pipe) ==\
  \ PIPE_ISOCHRONOUS ||\n\t    usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {\n\t\t\
  spin_lock_irqsave(&hsotg->lock, flags);\n\t\tif (!dwc2_hcd_is_bandwidth_allocated(hsotg,\
  \ ep))\n\t\t\talloc_bandwidth = 1;\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\
  \t}\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_CONTROL:\n\t\tep_type =\
  \ USB_ENDPOINT_XFER_CONTROL;\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\t\tep_type\
  \ = USB_ENDPOINT_XFER_ISOC;\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tep_type = USB_ENDPOINT_XFER_BULK;\n\
  \t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tep_type = USB_ENDPOINT_XFER_INT;\n\t\tbreak;\n\
  \t}\n\n\tdwc2_urb = dwc2_hcd_urb_alloc(hsotg, urb->number_of_packets,\n\t\t\t\t\
  \      mem_flags);\n\tif (!dwc2_urb)\n\t\treturn -ENOMEM;\n\n\tdwc2_hcd_urb_set_pipeinfo(hsotg,\
  \ dwc2_urb, usb_pipedevice(urb->pipe),\n\t\t\t\t  usb_pipeendpoint(urb->pipe), ep_type,\n\
  \t\t\t\t  usb_pipein(urb->pipe),\n\t\t\t\t  usb_endpoint_maxp(&ep->desc),\n\t\t\t\
  \t  usb_endpoint_maxp_mult(&ep->desc));\n\n\tbuf = urb->transfer_buffer;\n\n\tif\
  \ (hcd_uses_dma(hcd)) {\n\t\tif (!buf && (urb->transfer_dma & 3)) {\n\t\t\tdev_err(hsotg->dev,\n\
  \t\t\t\t\"%s: unaligned transfer with no transfer_buffer\",\n\t\t\t\t__func__);\n\
  \t\t\tretval = -EINVAL;\n\t\t\tgoto fail0;\n\t\t}\n\t}\n\n\tif (!(urb->transfer_flags\
  \ & URB_NO_INTERRUPT))\n\t\ttflags |= URB_GIVEBACK_ASAP;\n\tif (urb->transfer_flags\
  \ & URB_ZERO_PACKET)\n\t\ttflags |= URB_SEND_ZERO_PACKET;\n\n\tdwc2_urb->priv =\
  \ urb;\n\tdwc2_urb->buf = buf;\n\tdwc2_urb->dma = urb->transfer_dma;\n\tdwc2_urb->length\
  \ = urb->transfer_buffer_length;\n\tdwc2_urb->setup_packet = urb->setup_packet;\n\
  \tdwc2_urb->setup_dma = urb->setup_dma;\n\tdwc2_urb->flags = tflags;\n\tdwc2_urb->interval\
  \ = urb->interval;\n\tdwc2_urb->status = -EINPROGRESS;\n\n\tfor (i = 0; i < urb->number_of_packets;\
  \ ++i)\n\t\tdwc2_hcd_urb_set_iso_desc_params(dwc2_urb, i,\n\t\t\t\t\t\t urb->iso_frame_desc[i].offset,\n\
  \t\t\t\t\t\t urb->iso_frame_desc[i].length);\n\n\turb->hcpriv = dwc2_urb;\n\tqh\
  \ = (struct dwc2_qh *)ep->hcpriv;\n\t/* Create QH for the endpoint if it doesn't\
  \ exist */\n\tif (!qh) {\n\t\tqh = dwc2_hcd_qh_create(hsotg, dwc2_urb, mem_flags);\n\
  \t\tif (!qh) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail0;\n\t\t}\n\t\tep->hcpriv\
  \ = qh;\n\t\tqh_allocated = true;\n\t}\n\n\tqtd = kzalloc(sizeof(*qtd), mem_flags);\n\
  \tif (!qtd) {\n\t\tretval = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tspin_lock_irqsave(&hsotg->lock,\
  \ flags);\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval)\n\t\tgoto\
  \ fail2;\n\n\tretval = dwc2_hcd_urb_enqueue(hsotg, dwc2_urb, qh, qtd);\n\tif (retval)\n\
  \t\tgoto fail3;\n\n\tif (alloc_bandwidth) {\n\t\tdwc2_allocate_bus_bandwidth(hcd,\n\
  \t\t\t\tdwc2_hcd_get_ep_bandwidth(hsotg, ep),\n\t\t\t\turb);\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock,\
  \ flags);\n\n\treturn 0;\n\nfail3:\n\tdwc2_urb->priv = NULL;\n\tusb_hcd_unlink_urb_from_ep(hcd,\
  \ urb);\n\tif (qh_allocated && qh->channel && qh->channel->qh == qh)\n\t\tqh->channel->qh\
  \ = NULL;\nfail2:\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\turb->hcpriv\
  \ = NULL;\n\tkfree(qtd);\nfail1:\n\tif (qh_allocated) {\n\t\tstruct dwc2_qtd *qtd2,\
  \ *qtd2_tmp;\n\n\t\tep->hcpriv = NULL;\n\t\tdwc2_hcd_qh_unlink(hsotg, qh);\n\t\t\
  /* Free each QTD in the QH's QTD list */\n\t\tlist_for_each_entry_safe(qtd2, qtd2_tmp,\
  \ &qh->qtd_list,\n\t\t\t\t\t qtd_list_entry)\n\t\t\tdwc2_hcd_qtd_unlink_and_free(hsotg,\
  \ qtd2, qh);\n\t\tdwc2_hcd_qh_free(hsotg, qh);\n\t}\nfail0:\n\tkfree(dwc2_urb);\n\
  \n\treturn retval;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/usb/dwc2/hcd.c\
  \ b/drivers/usb/dwc2/hcd.c\nindex 657f1f659ffa..35c7a4df8e71 100644\n--- a/drivers/usb/dwc2/hcd.c\n\
  +++ b/drivers/usb/dwc2/hcd.c\n@@ -4769,8 +4769,8 @@ static int _dwc2_hcd_urb_enqueue(struct\
  \ usb_hcd *hcd, struct urb *urb,\n \tif (qh_allocated && qh->channel && qh->channel->qh\
  \ == qh)\n \t\tqh->channel->qh = NULL;\n fail2:\n-\tspin_unlock_irqrestore(&hsotg->lock,\
  \ flags);\n \turb->hcpriv = NULL;\n+\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\
  \ \tkfree(qtd);\n fail1:\n \tif (qh_allocated) {\n```\n"
pattern: "## Bug Pattern\n\nModifying a shared, lock-protected pointer (urb->hcpriv)\
  \ without holding its protecting spinlock (hsotg->lock), while other code checks\
  \ and uses that pointer under the lock. Specifically, releasing the lock before\
  \ updating the pointer (unlock-before-state-update) creates a TOCTOU race where\
  \ another thread can observe the pointer as non-NULL under the lock, then the first\
  \ thread sets it to NULL outside the lock, leading to a NULL dereference when the\
  \ second thread uses the stale value.\n\nPattern snippet:\n\n- Thread A (incorrect):\n\
  \  spin_unlock_irqrestore(&lock, flags);\n  shared_ptr = NULL;  // update happens\
  \ outside lock\n\n- Thread B (concurrent):\n  spin_lock_irqsave(&lock, flags);\n\
  \  if (shared_ptr)\n      use(shared_ptr);  // assumes shared_ptr won\u2019t change\
  \ while locked\n\nRoot cause: Writing to a field that is read-checked-and-used under\
  \ a specific lock without holding that same lock."
plan: "1) Program state\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(LockCountMap, const MemRegion*,\
  \ unsigned)\n  - Tracks, per lock region, how many times it is currently held in\
  \ this path (0 = not held).\n\n- REGISTER_TRAIT_WITH_PROGRAMSTATE(LastUnlockedLock,\
  \ const MemRegion*)\n  - Stores the lock region that was most recently unlocked\
  \ on this path. This is used to detect the \u201Cimmediately-after-unlock\u201D\
  \ write.\n\nRationale: We only need to know which lock was just unlocked and whether\
  \ it is currently held. No heavy aliasing or cross-function state is required.\n\
  \n\n2) Helper identification of lock/unlock calls\n\n- Define two small identifier\
  \ sets:\n  - Lock functions: {\"spin_lock\", \"spin_lock_irq\", \"spin_lock_bh\"\
  , \"spin_lock_irqsave\", \"mutex_lock\", \"read_lock\", \"write_lock\"}\n  - Unlock\
  \ functions: {\"spin_unlock\", \"spin_unlock_irq\", \"spin_unlock_bh\", \"spin_unlock_irqrestore\"\
  , \"mutex_unlock\", \"read_unlock\", \"write_unlock\"}\n\n- For both lock and unlock\
  \ APIs, the lock expression is always the first argument (index 0). Use getMemRegionFromExpr(Arg0,\
  \ C) to get the lock region.\n\n- Implement two helpers:\n  - bool isLockFunc(const\
  \ CallEvent &Call, const IdentifierInfo *&ID)\n  - bool isUnlockFunc(const CallEvent\
  \ &Call, const IdentifierInfo *&ID)\n  Return true if callee matches a known lock/unlock\
  \ function.\n\n\n3) Callbacks and logic\n\nA) checkBeginFunction\n- Clear all per-function\
  \ state at function entry:\n  - Set LockCountMap to empty.\n  - Set LastUnlockedLock\
  \ to nullptr.\n\nB) checkPreCall\n- If isLockFunc(Call):\n  - Get lock region LR\
  \ = getMemRegionFromExpr(Call.getArgExpr(0), C).\n  - If LR is non-null, increment\
  \ LR\u2019s count in LockCountMap (default 0 -> 1).\n  - Clear LastUnlockedLock\
  \ (set nullptr) to avoid stale \u201Cjust-unlocked\u201D flags once a new lock is\
  \ acquired.\n\n- Else (not a lock function):\n  - If LastUnlockedLock is set and\
  \ this is a non-unlock call, clear LastUnlockedLock.\n    - This keeps the \u201C\
  just-unlocked\u201D window very small (only until the next statement), reducing\
  \ false positives. It still allows the immediate following assignment to be detected\
  \ because checkBind for the assignment will be triggered before checkPreCall for\
  \ the next call (e.g., kfree).\n\nC) checkPostCall\n- If isUnlockFunc(Call):\n \
  \ - Get LR = getMemRegionFromExpr(Call.getArgExpr(0), C).\n  - If LR non-null:\n\
  \    - Decrement its count in LockCountMap (do not go below 0; remove if becomes\
  \ 0).\n    - Set LastUnlockedLock = LR.\n  - Else, set LastUnlockedLock = nullptr\
  \ (defensive).\n\n- Else do nothing.\n\nD) checkBind\n- Goal: detect the \u201C\
  unlock-before-state-update\u201D pattern: a write to a pointer field that sets it\
  \ to NULL immediately after an unlock of some lock.\n\n- Steps:\n  1) If LastUnlockedLock\
  \ is nullptr, return (not in the \u201Cjust unlocked\u201D window).\n  2) Also check\
  \ that LockCountMap does not currently contain LastUnlockedLock with a positive\
  \ count (i.e., lock is not currently held).\n  3) Confirm this bind is a simple\
  \ assignment to a struct-pointer member:\n     - Cast S to BinaryOperator BO and\
  \ ensure BO->isAssignmentOp().\n     - Extract LHS (BO->getLHS()) and RHS (BO->getRHS()).\n\
  \     - Ensure LHS is a MemberExpr with isArrow() true (Base->Field form). Then\
  \ get the FieldDecl FD and ensure FD->getType()->isPointerType().\n  4) Confirm\
  \ RHS is NULL:\n     - Prefer using Val (the bound value) if available: if it is\
  \ a DefinedOrUnknownSVal and represents a null pointer (isZeroConstant()) then accept.\n\
  \     - If needed, fallback to evaluating RHS as integer via EvaluateExprToInt;\
  \ true if 0. Or ExprHasName(RHS, \"NULL\", C) as a last resort.\n  5) If all conditions\
  \ hold, emit a bug:\n     - Message: \u201CSetting shared pointer field to NULL\
  \ right after unlocking; move the assignment before unlock.\u201D\n     - Use generateNonFatalErrorNode()\
  \ and PathSensitiveBugReport. Attach the current Stmt as the location. Optionally,\
  \ add a note to the unlock call site if available (you can retrieve it from the\
  \ path; not required).\n  6) Clear LastUnlockedLock (to avoid duplicate reports\
  \ for the same window).\n\nE) checkEndFunction\n- Clear LastUnlockedLock (defensive).\
  \ No other action needed.\n\n\n4) Key details and heuristics\n\n- Immediate-after-unlock\
  \ window:\n  - Set LastUnlockedLock in checkPostCall for unlock.\n  - Clear it:\n\
  \    - On checkBind after processing (reported or not).\n    - On checkPreCall for\
  \ any non-lock/non-unlock call.\n    This models \u201Cimmediately\u201D as: the\
  \ very next assignment (if any) before the next function call is considered in-window.\n\
  \n- Lock presence and matching:\n  - We do not attempt to prove which lock protects\
  \ which field. Instead, we use a robust heuristic: assignment to a struct pointer\
  \ field to NULL immediately after an unlock of any lock, while that lock is currently\
  \ not held (and we know it has just been released).\n  - This matches the target\
  \ pattern (unlock, then set shared pointer NULL), and substantially reduces false\
  \ positives by restricting to the immediate window and pointer fields only.\n\n\
  - Utility functions used:\n  - getMemRegionFromExpr to resolve the lock object across\
  \ calls.\n  - EvaluateExprToInt and ExprHasName to recognize NULL RHS when SVal\
  \ analysis is inconclusive.\n  - findSpecificTypeInChildren may be used to locate\
  \ the BinaryOperator within S if the direct cast fails (rare but can be used as\
  \ a fallback).\n\n- Function identification:\n  - Use CallEvent::getCalleeIdentifier()->getName()\
  \ to compare against known lock/unlock function names. Avoid macro confusion by\
  \ checking the function name at the call site.\n\n- Reporting:\n  - Keep the report\
  \ short and clear per instructions.\n  - A single BugType with a descriptive name\
  \ such as \u201CUnlock-before-nullify of shared pointer.\u201D\n\n\n5) Why this\
  \ detects the target patch bug\n\n- In the buggy code path, spin_unlock_irqrestore\
  \ is followed by an assignment \u201Curb->hcpriv = NULL;\u201D.\n- The checker sees\
  \ the unlock (checkPostCall), sets LastUnlockedLock, then immediately sees the assignment\
  \ (checkBind) writing a pointer field to NULL while no lock is currently held (LockCountMap\
  \ confirms), and reports.\n- The fix moves the assignment before spin_unlock, so\
  \ at the time of the assignment, LastUnlockedLock is not set (we are still inside\
  \ the locked region); the checker does not report, as desired."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program states\nREGISTER_MAP_WITH_PROGRAMSTATE(LockCountMap, const MemRegion*,\
  \ unsigned)\nREGISTER_TRAIT_WITH_PROGRAMSTATE(LastUnlockedLock, const MemRegion*)\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<\n    check::BeginFunction,\n\
  \    check::EndFunction,\n    check::PreCall,\n    check::PostCall,\n    check::Bind>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unlock-before-nullify of shared pointer\", \"Concurrency\"\
  )) {}\n\n      void checkBeginFunction(CheckerContext &C) const;\n      void checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C) const;\n      void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      void checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const Stmt\
  \ *S, CheckerContext &C) const;\n\n   private:\n      // Helpers\n      bool isLockFunc(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      bool isUnlockFunc(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      const MemRegion *getLockRegionFromCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      bool isNullRHS(SVal Val, const\
  \ Expr *RHS, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isLockFunc(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  static const char *LockNames[]\
  \ = {\n    \"spin_lock\", \"spin_lock_irq\", \"spin_lock_bh\", \"spin_lock_irqsave\"\
  ,\n    \"mutex_lock\", \"read_lock\", \"write_lock\"\n  };\n  const Expr *E = Call.getOriginExpr();\n\
  \  if (!E) return false;\n  for (const char *N : LockNames) {\n    if (ExprHasName(E,\
  \ N, C))\n      return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isUnlockFunc(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  static const char *UnlockNames[]\
  \ = {\n    \"spin_unlock\", \"spin_unlock_irq\", \"spin_unlock_bh\", \"spin_unlock_irqrestore\"\
  ,\n    \"mutex_unlock\", \"read_unlock\", \"write_unlock\"\n  };\n  const Expr *E\
  \ = Call.getOriginExpr();\n  if (!E) return false;\n  for (const char *N : UnlockNames)\
  \ {\n    if (ExprHasName(E, N, C))\n      return true;\n  }\n  return false;\n}\n\
  \nconst MemRegion *SAGenTestChecker::getLockRegionFromCall(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  if (Call.getNumArgs() == 0)\n    return nullptr;\n\
  \  const Expr *Arg0 = Call.getArgExpr(0);\n  if (!Arg0)\n    return nullptr;\n \
  \ const MemRegion *MR = getMemRegionFromExpr(Arg0, C);\n  if (!MR)\n    return nullptr;\n\
  \  return MR->getBaseRegion();\n}\n\nbool SAGenTestChecker::isNullRHS(SVal V, const\
  \ Expr *RHS, CheckerContext &C) const {\n  if (auto DV = V.getAs<DefinedOrUnknownSVal>())\
  \ {\n    if (DV->isZeroConstant())\n      return true;\n  }\n\n  if (const Expr\
  \ *RE = dyn_cast_or_null<Expr>(RHS)) {\n    // Use AST check for null pointer constants\n\
  \    if (RE->isNullPointerConstant(C.getASTContext(),\n                        \
  \          Expr::NPC_ValueDependentIsNull))\n      return true;\n\n    // Fallback:\
  \ evaluate as int\n    llvm::APSInt Res;\n    if (EvaluateExprToInt(Res, RE, C))\
  \ {\n      if (Res == 0)\n        return true;\n    }\n\n    // Fallback to textual\
  \ check for NULL\n    if (ExprHasName(RE, \"NULL\", C))\n      return true;\n  }\n\
  \  return false;\n}\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  State = State->set<LastUnlockedLock>(nullptr);\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkEndFunction(const ReturnStmt\
  \ *RS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n  State\
  \ = State->set<LastUnlockedLock>(nullptr);\n  C.addTransition(State);\n}\n\nvoid\
  \ SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  ProgramStateRef State = C.getState();\n\n  if (isLockFunc(Call, C)) {\n \
  \   const MemRegion *LR = getLockRegionFromCall(Call, C);\n    if (LR) {\n     \
  \ const unsigned *Cnt = State->get<LockCountMap>(LR);\n      unsigned NewCnt = (Cnt\
  \ ? *Cnt : 0) + 1;\n      State = State->set<LockCountMap>(LR, NewCnt);\n    }\n\
  \    // Once we acquire a lock, clear the \"just-unlocked\" marker.\n    State =\
  \ State->set<LastUnlockedLock>(nullptr);\n    C.addTransition(State);\n    return;\n\
  \  }\n\n  // For any non-lock/non-unlock call, shrink the \"just-unlocked\" window.\n\
  \  if (!isUnlockFunc(Call, C)) {\n    const MemRegion *LUL = State->get<LastUnlockedLock>();\n\
  \    if (LUL) {\n      State = State->set<LastUnlockedLock>(nullptr);\n      C.addTransition(State);\n\
  \    }\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  if (isUnlockFunc(Call,\
  \ C)) {\n    const MemRegion *LR = getLockRegionFromCall(Call, C);\n    if (LR)\
  \ {\n      const unsigned *Cnt = State->get<LockCountMap>(LR);\n      if (Cnt &&\
  \ *Cnt > 1) {\n        State = State->set<LockCountMap>(LR, *Cnt - 1);\n      }\
  \ else {\n        State = State->remove<LockCountMap>(LR);\n      }\n      // Mark\
  \ this lock as just unlocked\n      State = State->set<LastUnlockedLock>(LR);\n\
  \    } else {\n      // Defensive\n      State = State->set<LastUnlockedLock>(nullptr);\n\
  \    }\n    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n  const MemRegion *JustUnlocked = State->get<LastUnlockedLock>();\n\
  \  if (!JustUnlocked)\n    return;\n\n  // Ensure the lock is not currently held.\n\
  \  if (const unsigned *Cnt = State->get<LockCountMap>(JustUnlocked)) {\n    if (*Cnt\
  \ > 0) {\n      // Clear the window and stop.\n      State = State->set<LastUnlockedLock>(nullptr);\n\
  \      C.addTransition(State);\n      return;\n    }\n  }\n\n  // We only care about\
  \ assignments, particularly to struct->pointer fields.\n  const BinaryOperator *BO\
  \ = dyn_cast_or_null<BinaryOperator>(S);\n  if (!BO || !BO->isAssignmentOp()) {\n\
  \    // Clear window after the first subsequent bind to keep \"immediate\" semantics.\n\
  \    State = State->set<LastUnlockedLock>(nullptr);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  const Expr *LHS = BO->getLHS();\n  const Expr *RHS = BO->getRHS();\n\
  \  if (!LHS || !RHS) {\n    State = State->set<LastUnlockedLock>(nullptr);\n   \
  \ C.addTransition(State);\n    return;\n  }\n\n  LHS = LHS->IgnoreParenCasts();\n\
  \  const MemberExpr *ME = dyn_cast<MemberExpr>(LHS);\n  if (!ME || !ME->isArrow())\
  \ {\n    // Not a pointer member access via '->'\n    State = State->set<LastUnlockedLock>(nullptr);\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  const ValueDecl *VD = ME->getMemberDecl();\n\
  \  const FieldDecl *FD = dyn_cast<FieldDecl>(VD);\n  if (!FD) {\n    State = State->set<LastUnlockedLock>(nullptr);\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  QualType FT = FD->getType();\n\
  \  if (!FT.getTypePtr() || !FT->isPointerType()) {\n    State = State->set<LastUnlockedLock>(nullptr);\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  // Check RHS is NULL\n  if (!isNullRHS(Val,\
  \ RHS, C)) {\n    State = State->set<LastUnlockedLock>(nullptr);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // All conditions met: just-unlocked, assignment to pointer\
  \ field, set to NULL.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if\
  \ (!N) {\n    State = State->set<LastUnlockedLock>(nullptr);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n    \
  \  *BT, \"Setting shared pointer field to NULL right after unlocking; move the assignment\
  \ before unlock\", N);\n  R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  \n  // Clear the window to avoid duplicates.\n  State = State->set<LastUnlockedLock>(nullptr);\n\
  \  C.addTransition(State);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect unlock-before-nullify of shared\
  \ pointer fields (TOCTOU race)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
