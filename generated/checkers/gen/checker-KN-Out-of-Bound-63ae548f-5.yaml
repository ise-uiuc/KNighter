_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 63ae548f1054a0b71678d0349c7dc9628ddd42ca
commit_type: Out-of-Bound
index: 5
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"llvm/ADT/APInt.h\"\
  \n#include \"llvm/ADT/APSInt.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states needed.\n\nnamespace {\n\n\
  class SAGenTestChecker : public Checker<check::Location> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"LUT index out of\
  \ bounds\", \"Array Bounds\")) {}\n\n  void checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  bool getArrayBoundFromBaseExpr(const\
  \ Expr *BaseE, llvm::APInt &N, CheckerContext &C) const;\n  bool extractStrictUpperBoundFromCond(const\
  \ Expr *CondE, SymbolRef IdxSym,\n                                       llvm::APSInt\
  \ &StrictUB, CheckerContext &C) const;\n  bool hasSyntacticUpperBoundGuard(const\
  \ Stmt *S, const Expr *IdxE,\n                                   const llvm::APInt\
  \ &N, CheckerContext &C) const;\n  bool shouldReportForBase(const Expr *BaseE) const;\n\
  };\n\n// Get constant array size from various base expressions (DeclRefExpr or MemberExpr)\n\
  bool SAGenTestChecker::getArrayBoundFromBaseExpr(const Expr *BaseE, llvm::APInt\
  \ &N, CheckerContext &C) const {\n  if (!BaseE)\n    return false;\n\n  // Try DeclRefExpr\
  \ array\n  if (getArraySizeFromExpr(N, BaseE))\n    return true;\n\n  // Try MemberExpr\
  \ to a field that's a constant array\n  if (const auto *ME = dyn_cast<MemberExpr>(BaseE->IgnoreParenImpCasts()))\
  \ {\n    const ValueDecl *VD = ME->getMemberDecl();\n    if (!VD)\n      return\
  \ false;\n\n    QualType QT = VD->getType();\n    if (const auto *CAT = dyn_cast_or_null<ConstantArrayType>(C.getASTContext().getAsArrayType(QT)))\
  \ {\n      N = CAT->getSize();\n      return true;\n    }\n    if (const ConstantArrayType\
  \ *CAT2 = C.getASTContext().getAsConstantArrayType(QT)) {\n      N = CAT2->getSize();\n\
  \      return true;\n    }\n  }\n\n  // As a fallback, attempt from the expression's\
  \ QualType (e.g., base ME type)\n  QualType BQT = BaseE->getType();\n  if (const\
  \ ConstantArrayType *CAT3 = C.getASTContext().getAsConstantArrayType(BQT)) {\n \
  \   N = CAT3->getSize();\n    return true;\n  }\n\n  return false;\n}\n\n// Try\
  \ to get a strict upper bound (exclusive) for IdxSym from a loop/while condition.\n\
  // Returns true and sets StrictUB iff condition is of form:\n//   idx < C   => UB\
  \ = C\n//   idx <= C  => UB = C + 1\n//   C > idx   => UB = C\n//   C >= idx  =>\
  \ UB = C + 1\nbool SAGenTestChecker::extractStrictUpperBoundFromCond(const Expr\
  \ *CondE, SymbolRef IdxSym,\n                                                  \
  \     llvm::APSInt &StrictUB, CheckerContext &C) const {\n  if (!CondE || !IdxSym)\n\
  \    return false;\n\n  const Expr *E = CondE->IgnoreParenImpCasts();\n  const auto\
  \ *BO = dyn_cast<BinaryOperator>(E);\n  if (!BO)\n    return false;\n\n  BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n  if (!(Op == BO_LT || Op == BO_LE || Op == BO_GT || Op\
  \ == BO_GE))\n    return false;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \  const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n  ProgramStateRef State\
  \ = C.getState();\n  SymbolRef LHSSym = State->getSVal(LHS, C.getLocationContext()).getAsSymbol();\n\
  \  SymbolRef RHSSym = State->getSVal(RHS, C.getLocationContext()).getAsSymbol();\n\
  \n  llvm::APSInt ConstVal;\n\n  // Case 1: idx [<|<=] C\n  if (LHSSym && LHSSym\
  \ == IdxSym) {\n    if (!EvaluateExprToInt(ConstVal, RHS, C))\n      return false;\n\
  \    if (Op == BO_LT) {\n      StrictUB = ConstVal;\n      return true;\n    } else\
  \ if (Op == BO_LE) {\n      // UB = C + 1\n      StrictUB = ConstVal;\n      StrictUB\
  \ = StrictUB + 1;\n      return true;\n    }\n  }\n\n  // Case 2: C [>|>=] idx\n\
  \  if (RHSSym && RHSSym == IdxSym) {\n    if (!EvaluateExprToInt(ConstVal, LHS,\
  \ C))\n      return false;\n    if (Op == BO_GT) {\n      StrictUB = ConstVal;\n\
  \      return true;\n    } else if (Op == BO_GE) {\n      StrictUB = ConstVal;\n\
  \      StrictUB = StrictUB + 1;\n      return true;\n    }\n  }\n\n  return false;\n\
  }\n\n// Check for enclosing loop guard that provides a constant strict UB for the\
  \ same index.\n// If such UB exists and UB <= N, we treat it as adequately guarded.\n\
  bool SAGenTestChecker::hasSyntacticUpperBoundGuard(const Stmt *S, const Expr *IdxE,\n\
  \                                                   const llvm::APInt &N, CheckerContext\
  \ &C) const {\n  if (!S || !IdxE)\n    return false;\n\n  ProgramStateRef State\
  \ = C.getState();\n  SymbolRef IdxSym = State->getSVal(IdxE, C.getLocationContext()).getAsSymbol();\n\
  \  if (!IdxSym)\n    return false;\n\n  // Check enclosing ForStmt\n  if (const\
  \ ForStmt *FS = findSpecificTypeInParents<ForStmt>(S, C)) {\n    const Expr *Cond\
  \ = FS->getCond();\n    llvm::APSInt UB;\n    if (extractStrictUpperBoundFromCond(Cond,\
  \ IdxSym, UB, C)) {\n      uint64_t UBv = UB.isSigned() ? UB.extOrTrunc(64).getZExtValue()\
  \ : UB.getZExtValue();\n      uint64_t Nv = N.getLimitedValue();\n      if (UBv\
  \ <= Nv)\n        return true;\n    }\n  }\n\n  // Check enclosing WhileStmt\n \
  \ if (const WhileStmt *WS = findSpecificTypeInParents<WhileStmt>(S, C)) {\n    const\
  \ Expr *Cond = WS->getCond();\n    llvm::APSInt UB;\n    if (extractStrictUpperBoundFromCond(Cond,\
  \ IdxSym, UB, C)) {\n      uint64_t UBv = UB.isSigned() ? UB.extOrTrunc(64).getZExtValue()\
  \ : UB.getZExtValue();\n      uint64_t Nv = N.getLimitedValue();\n      if (UBv\
  \ <= Nv)\n        return true;\n    }\n  }\n\n  return false;\n}\n\n// To reduce\
  \ duplicates for rgb channels, only report for \"red\" when the base is a member\
  \ named red.\n// For other arrays (non-rgb), report normally.\nbool SAGenTestChecker::shouldReportForBase(const\
  \ Expr *BaseE) const {\n  if (!BaseE)\n    return true;\n\n  if (const auto *ME\
  \ = dyn_cast<MemberExpr>(BaseE->IgnoreParenImpCasts())) {\n    if (const auto *FD\
  \ = dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n      StringRef Name = FD->getName();\n\
  \      if (Name == \"red\")\n        return true;\n      if (Name == \"green\" ||\
  \ Name == \"blue\")\n        return false; // suppress duplicates; \"red\" will\
  \ represent the issue\n    }\n  }\n  return true;\n}\n\nvoid SAGenTestChecker::checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const {\n  if (!IsLoad ||\
  \ !S)\n    return;\n\n  // Find the array subscript involved in this memory access.\n\
  \  const ArraySubscriptExpr *ASE = nullptr;\n  if ((ASE = dyn_cast<ArraySubscriptExpr>(S))\
  \ == nullptr) {\n    ASE = findSpecificTypeInChildren<ArraySubscriptExpr>(S);\n\
  \  }\n  if (!ASE)\n    return;\n\n  const Expr *BaseE = ASE->getBase()->IgnoreParenImpCasts();\n\
  \  const Expr *IdxE = ASE->getIdx()->IgnoreParenImpCasts();\n  if (!BaseE || !IdxE)\n\
  \    return;\n\n  if (!shouldReportForBase(BaseE))\n    return;\n\n  // Get array\
  \ bound N\n  llvm::APInt N(32, 0);\n  if (!getArrayBoundFromBaseExpr(BaseE, N, C))\n\
  \    return; // Unknown bound -> avoid false positives\n\n  // Evaluate index constant\
  \ if possible\n  llvm::APSInt IdxConst;\n  if (EvaluateExprToInt(IdxConst, IdxE,\
  \ C)) {\n    // Treat negative or >= N as OOB\n    bool IsNeg = IdxConst.isSigned()\
  \ ? IdxConst.isNegative() : false;\n    uint64_t IdxVal = IdxConst.isSigned() ?\
  \ IdxConst.extOrTrunc(64).getZExtValue()\n                                     \
  \     : IdxConst.getZExtValue();\n    uint64_t Bound = N.getLimitedValue();\n  \
  \  if (IsNeg || IdxVal >= Bound) {\n      ExplodedNode *NNode = C.generateNonFatalErrorNode();\n\
  \      if (!NNode)\n        return;\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"Possible out-of-bounds LUT index; missing 'i < array_size' check.\"\
  , NNode);\n      R->addRange(IdxE->getSourceRange());\n      C.emitReport(std::move(R));\n\
  \    }\n    return; // Constant and in-bounds otherwise: safe\n  }\n\n  // Non-constant\
  \ index: use symbolic reasoning\n  ProgramStateRef State = C.getState();\n  SymbolRef\
  \ IdxSym = State->getSVal(IdxE, C.getLocationContext()).getAsSymbol();\n  if (!IdxSym)\n\
  \    return; // Can't reason: avoid FP\n\n  const llvm::APSInt *MaxV = inferSymbolMaxVal(IdxSym,\
  \ C);\n  if (MaxV) {\n    // If analyzer can prove max < N, it's safe\n    uint64_t\
  \ MaxVal = MaxV->isSigned() ? MaxV->extOrTrunc(64).getZExtValue() : MaxV->getZExtValue();\n\
  \    uint64_t Bound = N.getLimitedValue();\n    if (MaxVal < Bound)\n      return;\n\
  \    // Otherwise, try to find a syntactic guard\n    if (hasSyntacticUpperBoundGuard(S,\
  \ IdxE, N, C))\n      return;\n  } else {\n    // Unknown max bound; check for syntactic\
  \ guard\n    if (hasSyntacticUpperBoundGuard(S, IdxE, N, C))\n      return;\n  }\n\
  \n  // Report potential out-of-bounds index due to missing explicit check\n  ExplodedNode\
  \ *NNode = C.generateNonFatalErrorNode();\n  if (!NNode)\n    return;\n  auto R\
  \ = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Possible out-of-bounds\
  \ LUT index; missing 'i < array_size' check.\", NNode);\n  R->addRange(IdxE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects missing upper-bound checks\
  \ for LUT indices leading to out-of-bounds access\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Fix potential index out of bounds\
  \ in color transformation function\n\nFixes index out of bounds issue in the color\
  \ transformation function.\nThe issue could occur when the index 'i' exceeds the\
  \ number of transfer\nfunction points (TRANSFER_FUNC_POINTS).\n\nThe fix adds a\
  \ check to ensure 'i' is within bounds before accessing the\ntransfer function points.\
  \ If 'i' is out of bounds, an error message is\nlogged and the function returns\
  \ false to indicate an error.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:405\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.red'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:406\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.green'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:407\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.blue'\
  \ 1025 <= s32max\n\nFixes: b629596072e5 (\"drm/amd/display: Build unity lut for\
  \ shaper\")\nCc: Vitaly Prosyak <vitaly.prosyak@amd.com>\nCc: Charlene Liu <Charlene.Liu@amd.com>\n\
  Cc: Harry Wentland <harry.wentland@amd.com>\nCc: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>\n\
  Cc: Roman Li <roman.li@amd.com>\nCc: Aurabindo Pillai <aurabindo.pillai@amd.com>\n\
  Cc: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Srinivasan Shanmugam <srinivasan.shanmugam@amd.com>\n\
  Reviewed-by: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Alex Deucher <alexander.deucher@amd.com>\n\
  \n## Buggy Code\n\n```c\n// Function: cm_helper_translate_curve_to_hw_format in\
  \ drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nbool cm_helper_translate_curve_to_hw_format(struct\
  \ dc_context *ctx,\n\t\t\t\tconst struct dc_transfer_func *output_tf,\n\t\t\t\t\
  struct pwl_params *lut_params, bool fixpoint)\n{\n\tstruct curve_points3 *corner_points;\n\
  \tstruct pwl_result_data *rgb_resulted;\n\tstruct pwl_result_data *rgb;\n\tstruct\
  \ pwl_result_data *rgb_plus_1;\n\tstruct pwl_result_data *rgb_minus_1;\n\n\tint32_t\
  \ region_start, region_end;\n\tint32_t i;\n\tuint32_t j, k, seg_distr[MAX_REGIONS_NUMBER],\
  \ increment, start_index, hw_points;\n\n\tif (output_tf == NULL || lut_params ==\
  \ NULL || output_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\tcorner_points\
  \ = lut_params->corner_points;\n\trgb_resulted = lut_params->rgb_resulted;\n\thw_points\
  \ = 0;\n\n\tmemset(lut_params, 0, sizeof(struct pwl_params));\n\tmemset(seg_distr,\
  \ 0, sizeof(seg_distr));\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ || output_tf->tf\
  \ == TRANSFER_FUNCTION_GAMMA22) {\n\t\t/* 32 segments\n\t\t * segments are from\
  \ 2^-25 to 2^7\n\t\t */\n\t\tfor (i = 0; i < NUMBER_REGIONS ; i++)\n\t\t\tseg_distr[i]\
  \ = 3;\n\n\t\tregion_start = -MAX_LOW_POINT;\n\t\tregion_end   = NUMBER_REGIONS\
  \ - MAX_LOW_POINT;\n\t} else {\n\t\t/* 11 segments\n\t\t * segment is from 2^-10\
  \ to 2^1\n\t\t * There are less than 256 points, for optimization\n\t\t */\n\t\t\
  seg_distr[0] = 3;\n\t\tseg_distr[1] = 4;\n\t\tseg_distr[2] = 4;\n\t\tseg_distr[3]\
  \ = 4;\n\t\tseg_distr[4] = 4;\n\t\tseg_distr[5] = 4;\n\t\tseg_distr[6] = 4;\n\t\t\
  seg_distr[7] = 4;\n\t\tseg_distr[8] = 4;\n\t\tseg_distr[9] = 4;\n\t\tseg_distr[10]\
  \ = 1;\n\n\t\tregion_start = -10;\n\t\tregion_end = 1;\n\t}\n\n\tfor (i = region_end\
  \ - region_start; i < MAX_REGIONS_NUMBER ; i++)\n\t\tseg_distr[i] = -1;\n\n\tfor\
  \ (k = 0; k < MAX_REGIONS_NUMBER; k++) {\n\t\tif (seg_distr[k] != -1)\n\t\t\thw_points\
  \ += (1 << seg_distr[k]);\n\t}\n\n\tj = 0;\n\tfor (k = 0; k < (region_end - region_start);\
  \ k++) {\n\t\tincrement = NUMBER_SW_SEGMENTS / (1 << seg_distr[k]);\n\t\tstart_index\
  \ = (region_start + k + MAX_LOW_POINT) *\n\t\t\t\tNUMBER_SW_SEGMENTS;\n\t\tfor (i\
  \ = start_index; i < start_index + NUMBER_SW_SEGMENTS;\n\t\t\t\ti += increment)\
  \ {\n\t\t\tif (j == hw_points - 1)\n\t\t\t\tbreak;\n\t\t\trgb_resulted[j].red =\
  \ output_tf->tf_pts.red[i];\n\t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n\
  \t\t\trgb_resulted[j].blue = output_tf->tf_pts.blue[i];\n\t\t\tj++;\n\t\t}\n\t}\n\
  \n\t/* last point */\n\tstart_index = (region_end + MAX_LOW_POINT) * NUMBER_SW_SEGMENTS;\n\
  \trgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];\n\trgb_resulted[hw_points\
  \ - 1].green = output_tf->tf_pts.green[start_index];\n\trgb_resulted[hw_points -\
  \ 1].blue = output_tf->tf_pts.blue[start_index];\n\n\trgb_resulted[hw_points].red\
  \ = rgb_resulted[hw_points - 1].red;\n\trgb_resulted[hw_points].green = rgb_resulted[hw_points\
  \ - 1].green;\n\trgb_resulted[hw_points].blue = rgb_resulted[hw_points - 1].blue;\n\
  \n\t// All 3 color channels have same x\n\tcorner_points[0].red.x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\
  \t\t\t\t\t     dc_fixpt_from_int(region_start));\n\tcorner_points[0].green.x = corner_points[0].red.x;\n\
  \tcorner_points[0].blue.x = corner_points[0].red.x;\n\n\tcorner_points[1].red.x\
  \ = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_end));\n\
  \tcorner_points[1].green.x = corner_points[1].red.x;\n\tcorner_points[1].blue.x\
  \ = corner_points[1].red.x;\n\n\tcorner_points[0].red.y = rgb_resulted[0].red;\n\
  \tcorner_points[0].green.y = rgb_resulted[0].green;\n\tcorner_points[0].blue.y =\
  \ rgb_resulted[0].blue;\n\n\tcorner_points[0].red.slope = dc_fixpt_div(corner_points[0].red.y,\n\
  \t\t\tcorner_points[0].red.x);\n\tcorner_points[0].green.slope = dc_fixpt_div(corner_points[0].green.y,\n\
  \t\t\tcorner_points[0].green.x);\n\tcorner_points[0].blue.slope = dc_fixpt_div(corner_points[0].blue.y,\n\
  \t\t\tcorner_points[0].blue.x);\n\n\t/* see comment above, m_arrPoints[1].y should\
  \ be the Y value for the\n\t * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints\
  \ - 1)\n\t */\n\tcorner_points[1].red.y = rgb_resulted[hw_points - 1].red;\n\tcorner_points[1].green.y\
  \ = rgb_resulted[hw_points - 1].green;\n\tcorner_points[1].blue.y = rgb_resulted[hw_points\
  \ - 1].blue;\n\tcorner_points[1].red.slope = dc_fixpt_zero;\n\tcorner_points[1].green.slope\
  \ = dc_fixpt_zero;\n\tcorner_points[1].blue.slope = dc_fixpt_zero;\n\n\tif (output_tf->tf\
  \ == TRANSFER_FUNCTION_PQ) {\n\t\t/* for PQ, we want to have a straight line from\
  \ last HW X point,\n\t\t * and the slope to be such that we hit 1.0 at 10000 nits.\n\
  \t\t */\n\t\tconst struct fixed31_32 end_value =\n\t\t\t\tdc_fixpt_from_int(125);\n\
  \n\t\tcorner_points[1].red.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].red.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].red.x));\n\
  \t\tcorner_points[1].green.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].green.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].green.x));\n\
  \t\tcorner_points[1].blue.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].blue.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].blue.x));\n\
  \t}\n\n\tlut_params->hw_points_num = hw_points;\n\n\tk = 0;\n\tfor (i = 1; i < MAX_REGIONS_NUMBER;\
  \ i++) {\n\t\tif (seg_distr[k] != -1) {\n\t\t\tlut_params->arr_curve_points[k].segments_num\
  \ =\n\t\t\t\t\tseg_distr[k];\n\t\t\tlut_params->arr_curve_points[i].offset =\n\t\
  \t\t\t\tlut_params->arr_curve_points[k].offset + (1 << seg_distr[k]);\n\t\t}\n\t\
  \tk++;\n\t}\n\n\tif (seg_distr[k] != -1)\n\t\tlut_params->arr_curve_points[k].segments_num\
  \ = seg_distr[k];\n\n\trgb = rgb_resulted;\n\trgb_plus_1 = rgb_resulted + 1;\n\t\
  rgb_minus_1 = rgb;\n\n\ti = 1;\n\twhile (i != hw_points + 1) {\n\n\t\tif (i >= hw_points\
  \ - 1) {\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->red, rgb->red))\n\t\t\t\trgb_plus_1->red\
  \ = dc_fixpt_add(rgb->red, rgb_minus_1->delta_red);\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->green,\
  \ rgb->green))\n\t\t\t\trgb_plus_1->green = dc_fixpt_add(rgb->green, rgb_minus_1->delta_green);\n\
  \t\t\tif (dc_fixpt_lt(rgb_plus_1->blue, rgb->blue))\n\t\t\t\trgb_plus_1->blue =\
  \ dc_fixpt_add(rgb->blue, rgb_minus_1->delta_blue);\n\t\t}\n\n\t\trgb->delta_red\
  \   = dc_fixpt_sub(rgb_plus_1->red,   rgb->red);\n\t\trgb->delta_green = dc_fixpt_sub(rgb_plus_1->green,\
  \ rgb->green);\n\t\trgb->delta_blue  = dc_fixpt_sub(rgb_plus_1->blue,  rgb->blue);\n\
  \n\n\t\tif (fixpoint == true) {\n\t\t\tuint32_t red_clamp = dc_fixpt_clamp_u0d14(rgb->delta_red);\n\
  \t\t\tuint32_t green_clamp = dc_fixpt_clamp_u0d14(rgb->delta_green);\n\t\t\tuint32_t\
  \ blue_clamp = dc_fixpt_clamp_u0d14(rgb->delta_blue);\n\n\t\t\tif (red_clamp >>\
  \ 10 || green_clamp >> 10 || blue_clamp >> 10)\n\t\t\t\tDC_LOG_WARNING(\"Losing\
  \ delta precision while programming shaper LUT.\");\n\n\t\t\trgb->delta_red_reg\
  \   = red_clamp & 0x3ff;\n\t\t\trgb->delta_green_reg = green_clamp & 0x3ff;\n\t\t\
  \trgb->delta_blue_reg  = blue_clamp & 0x3ff;\n\t\t\trgb->red_reg         = dc_fixpt_clamp_u0d14(rgb->red);\n\
  \t\t\trgb->green_reg       = dc_fixpt_clamp_u0d14(rgb->green);\n\t\t\trgb->blue_reg\
  \        = dc_fixpt_clamp_u0d14(rgb->blue);\n\t\t}\n\n\t\t++rgb_plus_1;\n\t\trgb_minus_1\
  \ = rgb;\n\t\t++rgb;\n\t\t++i;\n\t}\n\tcm_helper_convert_to_custom_float(rgb_resulted,\n\
  \t\t\t\t\t\tlut_params->corner_points,\n\t\t\t\t\t\thw_points, fixpoint);\n\n\t\
  return true;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\
  \ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nindex b7e57aa27361..b0d192c6e63e\
  \ 100644\n--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n\
  @@ -402,6 +402,11 @@ bool cm_helper_translate_curve_to_hw_format(struct dc_context\
  \ *ctx,\n \t\t\t\ti += increment) {\n \t\t\tif (j == hw_points - 1)\n \t\t\t\tbreak;\n\
  +\t\t\tif (i >= TRANSFER_FUNC_POINTS) {\n+\t\t\t\tDC_LOG_ERROR(\"Index out of bounds:\
  \ i=%d, TRANSFER_FUNC_POINTS=%d\\n\",\n+\t\t\t\t\t     i, TRANSFER_FUNC_POINTS);\n\
  +\t\t\t\treturn false;\n+\t\t\t}\n \t\t\trgb_resulted[j].red = output_tf->tf_pts.red[i];\n\
  \ \t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n \t\t\trgb_resulted[j].blue\
  \ = output_tf->tf_pts.blue[i];\n```\n"
pattern: "## Bug Pattern\n\nUsing a computed index to access a fixed-size LUT without\
  \ validating it:\n- The loop terminates based on a different counter (j/hw_points),\
  \ while array access uses another counter (i) computed from region/segment math\
  \ (start_index, increment).\n- No check ensures i < TRANSFER_FUNC_POINTS before\
  \ indexing output_tf->tf_pts.{red,green,blue}[i].\n- This decoupling of loop termination\
  \ and the indexed array\u2019s bounds allows i to exceed the array size, causing\
  \ out-of-bounds access."
plan: "1) Program state\n- No custom program states are necessary. We will rely on:\n\
  \  - Existing path constraints (and inferSymbolMaxVal) to learn index bounds.\n\
  \  - Local AST/CFG inspection to determine the array bound and whether an explicit\
  \ guard exists.\n\n2) Callbacks and steps\n\nStep A. checkLocation(SVal Loc, bool\
  \ IsLoad, const Stmt *S, CheckerContext &C)\nGoal: Flag array subscripts that index\
  \ a fixed-size LUT with an index that may exceed the bound and is not explicitly\
  \ guarded.\n\nImplementation details:\n- Identify the array access:\n  - From S,\
  \ obtain the ArraySubscriptExpr (ASE). If S is not an ASE, try findSpecificTypeInChildren<ArraySubscriptExpr>(S).\
  \ If none, return.\n- Extract the array bound (N):\n  - Let BaseE = ASE->getBase()->IgnoreParenImpCasts().\n\
  \  - Try to get the array size N as follows:\n    - If BaseE is DeclRefExpr with\
  \ ConstantArrayType, use the provided getArraySizeFromExpr to fetch the size into\
  \ APInt N.\n    - Else if BaseE is a MemberExpr (e.g., output_tf->tf_pts.red), inspect\
  \ the referred declaration\u2019s type:\n      - FieldDecl FD = cast<FieldDecl>(ME->getMemberDecl()).\n\
  \      - If FD->getType() is ConstantArrayType, extract size (FD->getType()->getAs<ConstantArrayType>()->getSize())\
  \ into APInt N.\n    - If we still cannot obtain a constant array bound, bail (return).\n\
  \  - Note: We don\u2019t need the element region. We only care about array bound\
  \ N.\n- Extract the index:\n  - Let IdxE = ASE->getIdx()->IgnoreParenImpCasts().\n\
  \  - First, try to evaluate the index to a constant using EvaluateExprToInt(APSInt\
  \ IdxConst, IdxE, C):\n    - If evaluable and IdxConst >= N, report (go to Step\
  \ C).\n    - If evaluable and IdxConst < N, consider safe; return.\n  - Otherwise,\
  \ get the index symbol:\n    - SymbolRef IdxSym = C.getSVal(IdxE).getAsSymbol();\n\
  \    - If no symbol is available, give up (avoid FP); return.\n- Use constraints\
  \ to bound the index symbol:\n  - Query maximum value using inferSymbolMaxVal(IdxSym,\
  \ C):\n    - If maxVal exists:\n      - If maxVal >= N (i.e., analyzer cannot prove\
  \ Idx < N), continue to Step B (syntactic guard check). We will only report if there\
  \ is no known syntactic guard.\n      - Else (maxVal < N), safe; return.\n    -\
  \ If maxVal does not exist (unknown), continue to Step B (syntactic guard check).\
  \ We will only report without a guard if max is unknown and we cannot find a proper\
  \ guard.\n- Step B. Check for an explicit syntactic guard tied to the same index:\n\
  \  - Attempt to locate a surrounding loop or branch that provides a bound on Idx:\n\
  \    - Find enclosing ForStmt or WhileStmt via findSpecificTypeInParents<ForStmt>(S)\
  \ / findSpecificTypeInParents<WhileStmt>(S). If found:\n      - For ForStmt: analyze\
  \ its condition expression CondE (if any). If CondE is a BinaryOperator that compares\
  \ the same index variable with a constant bound C:\n        - Accepted safe forms:\
  \ (Idx < C), (Idx <= C-1), (C > Idx), (C-1 >= Idx). Use EvaluateExprToInt on the\
  \ constant side(s) to derive a strict upper bound. If strict upper bound <= N, treat\
  \ as guarded; return.\n      - For WhileStmt: similar analysis on its condition.\n\
  \    - If an IfStmt guard syntactically guarding the index is present just above\
  \ this access (e.g., if (Idx >= N) return/break;), CSA path constraints will already\
  \ have set bounds in the current path; inferSymbolMaxVal would be < N. Hence additional\
  \ IfStmt scanning is optional. If desired, you can scan immediate parent IfStmt\
  \ and check for comparisons with N, but this is not necessary if the earlier constraint\
  \ step is used.\n  - If no syntactic guard is found (and either maxVal >= N or maxVal\
  \ is unknown), proceed to report.\n- Step C. Report:\n  - Create a non-fatal error\
  \ node with generateNonFatalErrorNode().\n  - Emit a concise report using std::make_unique<PathSensitiveBugReport>:\n\
  \    - Checker name: e.g., \u201CLUTIndexBoundsChecker\u201D.\n    - Message: \u201C\
  Possible out-of-bounds LUT index; missing \u2018i < array_size\u2019 check.\u201D\
  \n  - Attach the ASE->getIdx() as the interesting location so the path highlights\
  \ the index expression.\n  - Note: This code typically accesses 3 channels (red/green/blue).\
  \ To limit duplicates, only report when the base MemberExpr name is \u201Cred\u201D\
  \ (or report all if desired). Implement this minor filter by inspecting MemberExpr\u2019\
  s field name.\n\n3) Helper logic (internal helpers you will write)\n- getArrayBoundFromBaseExpr(const\
  \ Expr *BaseE, llvm::APInt &N):\n  - If DeclRefExpr, use getArraySizeFromExpr(N,\
  \ BaseE).\n  - If MemberExpr, fetch FieldDecl then inspect its QualType for ConstantArrayType\
  \ and return N.\n- sameIndexSymbol(const Expr *IdxE, const Expr *OtherIdxE, CheckerContext\
  \ &C):\n  - To compare if a loop condition uses the same index variable, extract\
  \ SymbolRef via C.getSVal(\u2026 ).getAsSymbol() from both expressions and compare\
  \ pointer equality.\n- extractStrictUpperBoundFromCond(const Expr *CondE, SymbolRef\
  \ IdxSym, llvm::APSInt &StrictUB, CheckerContext &C):\n  - If CondE is BinaryOperator\
  \ comparing IdxSym with a constant C, compute StrictUB:\n    - For \u201CIdx < C\u201D\
  \ or \u201CC > Idx\u201D: StrictUB = C.\n    - For \u201CIdx <= C\u201D or \u201C\
  C >= Idx\u201D: StrictUB = C + 1.\n    - For \u201CIdx < C-1\u201D or similar simple\
  \ arithmetic on the constant side, try EvaluateExprToInt on RHS.\n  - Return true\
  \ if parsed; otherwise false.\n\n4) Why this catches the target bug\n- The buggy\
  \ code computes i from region/segment math and doesn\u2019t guard it against TRANSFER_FUNC_POINTS\
  \ before indexing output_tf->tf_pts.{red,green,blue}[i].\n- In the loop, the analyzer\
  \ will know i < start_index + NUMBER_SW_SEGMENTS. Since start_index is computed\
  \ and may exceed array size, inferSymbolMaxVal(i) will be >= N. Since no explicit\
  \ \u201Ci < N\u201D guard exists, the checker reports.\n- After the patch, the explicit\
  \ guard \u201Cif (i >= TRANSFER_FUNC_POINTS) return false;\u201D creates a path\
  \ constraint i < N for the access, making inferSymbolMaxVal < N and thus silencing\
  \ the warning.\n\n5) Notes to keep it simple and precise\n- No custom maps or traits;\
  \ let the analyzer\u2019s constraint manager provide max bounds.\n- Only warn when:\n\
  \  - Index is constant and out-of-bounds; or\n  - Symbolic index\u2019s max bound\
  \ is >= array size and there is no syntactic guard tied to that array size.\n- Keep\
  \ the message short and clear."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"llvm/ADT/APInt.h\"\
  \n#include \"llvm/ADT/APSInt.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states needed.\n\nnamespace {\n\n\
  class SAGenTestChecker : public Checker<check::Location> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"LUT index out of\
  \ bounds\", \"Array Bounds\")) {}\n\n  void checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  bool getArrayBoundFromBaseExpr(const\
  \ Expr *BaseE, llvm::APInt &N, CheckerContext &C) const;\n  bool extractStrictUpperBoundFromCond(const\
  \ Expr *CondE, SymbolRef IdxSym,\n                                       llvm::APSInt\
  \ &StrictUB, CheckerContext &C) const;\n  bool hasSyntacticUpperBoundGuard(const\
  \ Stmt *S, const Expr *IdxE,\n                                   const llvm::APInt\
  \ &N, CheckerContext &C) const;\n  bool shouldReportForBase(const Expr *BaseE) const;\n\
  };\n\n// Get constant array size from various base expressions (DeclRefExpr or MemberExpr)\n\
  bool SAGenTestChecker::getArrayBoundFromBaseExpr(const Expr *BaseE, llvm::APInt\
  \ &N, CheckerContext &C) const {\n  if (!BaseE)\n    return false;\n\n  // Try DeclRefExpr\
  \ array\n  if (getArraySizeFromExpr(N, BaseE))\n    return true;\n\n  // Try MemberExpr\
  \ to a field that's a constant array\n  if (const auto *ME = dyn_cast<MemberExpr>(BaseE->IgnoreParenImpCasts()))\
  \ {\n    const ValueDecl *VD = ME->getMemberDecl();\n    if (!VD)\n      return\
  \ false;\n\n    QualType QT = VD->getType();\n    if (const auto *CAT = dyn_cast_or_null<ConstantArrayType>(C.getASTContext().getAsArrayType(QT)))\
  \ {\n      N = CAT->getSize();\n      return true;\n    }\n    if (const ConstantArrayType\
  \ *CAT2 = C.getASTContext().getAsConstantArrayType(QT)) {\n      N = CAT2->getSize();\n\
  \      return true;\n    }\n  }\n\n  // As a fallback, attempt from the expression's\
  \ QualType (e.g., base ME type)\n  QualType BQT = BaseE->getType();\n  if (const\
  \ ConstantArrayType *CAT3 = C.getASTContext().getAsConstantArrayType(BQT)) {\n \
  \   N = CAT3->getSize();\n    return true;\n  }\n\n  return false;\n}\n\n// Try\
  \ to get a strict upper bound (exclusive) for IdxSym from a loop/while condition.\n\
  // Returns true and sets StrictUB iff condition is of form:\n//   idx < C   => UB\
  \ = C\n//   idx <= C  => UB = C + 1\n//   C > idx   => UB = C\n//   C >= idx  =>\
  \ UB = C + 1\nbool SAGenTestChecker::extractStrictUpperBoundFromCond(const Expr\
  \ *CondE, SymbolRef IdxSym,\n                                                  \
  \     llvm::APSInt &StrictUB, CheckerContext &C) const {\n  if (!CondE || !IdxSym)\n\
  \    return false;\n\n  const Expr *E = CondE->IgnoreParenImpCasts();\n  const auto\
  \ *BO = dyn_cast<BinaryOperator>(E);\n  if (!BO)\n    return false;\n\n  BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n  if (!(Op == BO_LT || Op == BO_LE || Op == BO_GT || Op\
  \ == BO_GE))\n    return false;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \  const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n  ProgramStateRef State\
  \ = C.getState();\n  SymbolRef LHSSym = State->getSVal(LHS, C.getLocationContext()).getAsSymbol();\n\
  \  SymbolRef RHSSym = State->getSVal(RHS, C.getLocationContext()).getAsSymbol();\n\
  \n  llvm::APSInt ConstVal;\n\n  // Case 1: idx [<|<=] C\n  if (LHSSym && LHSSym\
  \ == IdxSym) {\n    if (!EvaluateExprToInt(ConstVal, RHS, C))\n      return false;\n\
  \    if (Op == BO_LT) {\n      StrictUB = ConstVal;\n      return true;\n    } else\
  \ if (Op == BO_LE) {\n      // UB = C + 1\n      StrictUB = ConstVal;\n      StrictUB\
  \ = StrictUB + 1;\n      return true;\n    }\n  }\n\n  // Case 2: C [>|>=] idx\n\
  \  if (RHSSym && RHSSym == IdxSym) {\n    if (!EvaluateExprToInt(ConstVal, LHS,\
  \ C))\n      return false;\n    if (Op == BO_GT) {\n      StrictUB = ConstVal;\n\
  \      return true;\n    } else if (Op == BO_GE) {\n      StrictUB = ConstVal;\n\
  \      StrictUB = StrictUB + 1;\n      return true;\n    }\n  }\n\n  return false;\n\
  }\n\n// Check for enclosing loop guard that provides a constant strict UB for the\
  \ same index.\n// If such UB exists and UB <= N, we treat it as adequately guarded.\n\
  bool SAGenTestChecker::hasSyntacticUpperBoundGuard(const Stmt *S, const Expr *IdxE,\n\
  \                                                   const llvm::APInt &N, CheckerContext\
  \ &C) const {\n  if (!S || !IdxE)\n    return false;\n\n  ProgramStateRef State\
  \ = C.getState();\n  SymbolRef IdxSym = State->getSVal(IdxE, C.getLocationContext()).getAsSymbol();\n\
  \  if (!IdxSym)\n    return false;\n\n  // Check enclosing ForStmt\n  if (const\
  \ ForStmt *FS = findSpecificTypeInParents<ForStmt>(S, C)) {\n    const Expr *Cond\
  \ = FS->getCond();\n    llvm::APSInt UB;\n    if (extractStrictUpperBoundFromCond(Cond,\
  \ IdxSym, UB, C)) {\n      uint64_t UBv = UB.isSigned() ? UB.extOrTrunc(64).getZExtValue()\
  \ : UB.getZExtValue();\n      uint64_t Nv = N.getLimitedValue();\n      if (UBv\
  \ <= Nv)\n        return true;\n    }\n  }\n\n  // Check enclosing WhileStmt\n \
  \ if (const WhileStmt *WS = findSpecificTypeInParents<WhileStmt>(S, C)) {\n    const\
  \ Expr *Cond = WS->getCond();\n    llvm::APSInt UB;\n    if (extractStrictUpperBoundFromCond(Cond,\
  \ IdxSym, UB, C)) {\n      uint64_t UBv = UB.isSigned() ? UB.extOrTrunc(64).getZExtValue()\
  \ : UB.getZExtValue();\n      uint64_t Nv = N.getLimitedValue();\n      if (UBv\
  \ <= Nv)\n        return true;\n    }\n  }\n\n  return false;\n}\n\n// To reduce\
  \ duplicates for rgb channels, only report for \"red\" when the base is a member\
  \ named red.\n// For other arrays (non-rgb), report normally.\nbool SAGenTestChecker::shouldReportForBase(const\
  \ Expr *BaseE) const {\n  if (!BaseE)\n    return true;\n\n  if (const auto *ME\
  \ = dyn_cast<MemberExpr>(BaseE->IgnoreParenImpCasts())) {\n    if (const auto *FD\
  \ = dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n      StringRef Name = FD->getName();\n\
  \      if (Name == \"red\")\n        return true;\n      if (Name == \"green\" ||\
  \ Name == \"blue\")\n        return false; // suppress duplicates; \"red\" will\
  \ represent the issue\n    }\n  }\n  return true;\n}\n\nvoid SAGenTestChecker::checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const {\n  if (!IsLoad ||\
  \ !S)\n    return;\n\n  // Find the array subscript involved in this memory access.\n\
  \  const ArraySubscriptExpr *ASE = nullptr;\n  if ((ASE = dyn_cast<ArraySubscriptExpr>(S))\
  \ == nullptr) {\n    ASE = findSpecificTypeInChildren<ArraySubscriptExpr>(S);\n\
  \  }\n  if (!ASE)\n    return;\n\n  const Expr *BaseE = ASE->getBase()->IgnoreParenImpCasts();\n\
  \  const Expr *IdxE = ASE->getIdx()->IgnoreParenImpCasts();\n  if (!BaseE || !IdxE)\n\
  \    return;\n\n  if (!shouldReportForBase(BaseE))\n    return;\n\n  // Get array\
  \ bound N\n  llvm::APInt N(32, 0);\n  if (!getArrayBoundFromBaseExpr(BaseE, N, C))\n\
  \    return; // Unknown bound -> avoid false positives\n\n  // Evaluate index constant\
  \ if possible\n  llvm::APSInt IdxConst;\n  if (EvaluateExprToInt(IdxConst, IdxE,\
  \ C)) {\n    // Treat negative or >= N as OOB\n    bool IsNeg = IdxConst.isSigned()\
  \ ? IdxConst.isNegative() : false;\n    uint64_t IdxVal = IdxConst.isSigned() ?\
  \ IdxConst.extOrTrunc(64).getZExtValue()\n                                     \
  \     : IdxConst.getZExtValue();\n    uint64_t Bound = N.getLimitedValue();\n  \
  \  if (IsNeg || IdxVal >= Bound) {\n      ExplodedNode *NNode = C.generateNonFatalErrorNode();\n\
  \      if (!NNode)\n        return;\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"Possible out-of-bounds LUT index; missing 'i < array_size' check.\"\
  , NNode);\n      R->addRange(IdxE->getSourceRange());\n      C.emitReport(std::move(R));\n\
  \    }\n    return; // Constant and in-bounds otherwise: safe\n  }\n\n  // Non-constant\
  \ index: use symbolic reasoning\n  ProgramStateRef State = C.getState();\n  SymbolRef\
  \ IdxSym = State->getSVal(IdxE, C.getLocationContext()).getAsSymbol();\n  if (!IdxSym)\n\
  \    return; // Can't reason: avoid FP\n\n  const llvm::APSInt *MaxV = inferSymbolMaxVal(IdxSym,\
  \ C);\n  if (MaxV) {\n    // If analyzer can prove max < N, it's safe\n    uint64_t\
  \ MaxVal = MaxV->isSigned() ? MaxV->extOrTrunc(64).getZExtValue() : MaxV->getZExtValue();\n\
  \    uint64_t Bound = N.getLimitedValue();\n    if (MaxVal < Bound)\n      return;\n\
  \    // Otherwise, try to find a syntactic guard\n    if (hasSyntacticUpperBoundGuard(S,\
  \ IdxE, N, C))\n      return;\n  } else {\n    // Unknown max bound; check for syntactic\
  \ guard\n    if (hasSyntacticUpperBoundGuard(S, IdxE, N, C))\n      return;\n  }\n\
  \n  // Report potential out-of-bounds index due to missing explicit check\n  ExplodedNode\
  \ *NNode = C.generateNonFatalErrorNode();\n  if (!NNode)\n    return;\n  auto R\
  \ = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Possible out-of-bounds\
  \ LUT index; missing 'i < array_size' check.\", NNode);\n  R->addRange(IdxE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects missing upper-bound checks\
  \ for LUT indices leading to out-of-bounds access\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
