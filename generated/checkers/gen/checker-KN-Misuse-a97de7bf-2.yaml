_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: a97de7bff13b1cc825c1b1344eaed8d6c2d3e695
commit_type: Misuse
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states are necessary for this checker.\n\nnamespace {\n/* The checker callbacks\
  \ are to be decided. */\nclass SAGenTestChecker : public Checker<check::PostCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"copy_from_sockptr ignores optlen\", \"Linux API Misuse\"\
  )) {}\n\n      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \n   private:\n\n      bool hasOptlenParam(const CheckerContext &C) const;\n   \
  \   bool isFixedSizeExpr(const Expr *E) const;\n      bool exprDerivedFromOptlen(const\
  \ Expr *E, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::hasOptlenParam(const\
  \ CheckerContext &C) const {\n  const Decl *D = C.getLocationContext()->getDecl();\n\
  \  const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n  if (!FD)\n    return false;\n\
  \  for (const ParmVarDecl *P : FD->parameters()) {\n    if (!P)\n      continue;\n\
  \    if (P->getName() == \"optlen\")\n      return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isFixedSizeExpr(const Expr *E) const {\n  if (!E)\n\
  \    return false;\n  const Expr *EE = E->IgnoreParenImpCasts();\n  if (isa<IntegerLiteral>(EE))\n\
  \    return true;\n  if (const auto *UETT = dyn_cast<UnaryExprOrTypeTraitExpr>(EE))\
  \ {\n    if (UETT->getKind() == UETT_SizeOf)\n      return true;\n  }\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::exprDerivedFromOptlen(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E)\n    return false;\n\n  // Direct reference to \"optlen\"\
  \ anywhere in the expression text.\n  if (ExprHasName(E, \"optlen\", C))\n    return\
  \ true;\n\n  // If it's a DeclRefExpr to a local variable with an initializer derived\
  \ from optlen.\n  const Expr *EE = E->IgnoreParenImpCasts();\n  if (const auto *DRE\
  \ = dyn_cast<DeclRefExpr>(EE)) {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n      if (VD->hasInit()) {\n        const Expr *Init = VD->getInit();\n   \
  \     if (Init && ExprHasName(Init, \"optlen\", C))\n          return true;\n  \
  \    }\n    }\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return;\n\n  // Only target copy_from_sockptr (the buggy\
  \ usage). Do not match bt_copy_from_sockptr.\n  if (!ExprHasName(OriginExpr, \"\
  copy_from_sockptr\", C))\n    return;\n\n  // Require at least 3 args: dst, src\
  \ (optval), len\n  if (Call.getNumArgs() < 3)\n    return;\n\n  // Heuristic to\
  \ focus on setsockopt-like handlers:\n  // - function should have a parameter named\
  \ \"optlen\"\n  if (!hasOptlenParam(C))\n    return;\n\n  // - second argument should\
  \ reference/contain \"optval\"\n  const Expr *Arg1Expr = Call.getArgExpr(1);\n \
  \ if (!Arg1Expr || !ExprHasName(Arg1Expr, \"optval\", C))\n    return;\n\n  // Analyze\
  \ length argument (3rd argument)\n  const Expr *LenExpr = Call.getArgExpr(2);\n\
  \  if (!LenExpr)\n    return;\n\n  // If length is derived from optlen, it's considered\
  \ safe.\n  if (exprDerivedFromOptlen(LenExpr, C))\n    return;\n\n  // If length\
  \ is a fixed-size expression (sizeof(...) or integer literal) and not bounded by\
  \ optlen -> bug.\n  if (!isFixedSizeExpr(LenExpr))\n    return;\n\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"copy_from_sockptr size ignores optlen; use bt_copy_from_sockptr or\
  \ validate optlen\", N);\n  R->addRange(LenExpr->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects copy_from_sockptr calls using a fixed size without validating/bounding\
  \ with optlen\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: RFCOMM: Fix not validating setsockopt user\
  \ input\n\nsyzbot reported rfcomm_sock_setsockopt_old() is copying data without\n\
  checking user input length.\n\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset\n\
  include/linux/sockptr.h:49 [inline]\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr\n\
  include/linux/sockptr.h:55 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt_old\n\
  net/bluetooth/rfcomm/sock.c:632 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt+0x893/0xa70\n\
  net/bluetooth/rfcomm/sock.c:673\nRead of size 4 at addr ffff8880209a8bc3 by task\
  \ syz-executor632/5064\n\nFixes: 9f2c8a03fbb3 (\"Bluetooth: Replace RFCOMM link\
  \ mode with security level\")\nFixes: bb23c0ab8246 (\"Bluetooth: Add support for\
  \ deferring RFCOMM connection setup\")\nReported-by: syzbot <syzkaller@googlegroups.com>\n\
  Signed-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Luiz Augusto von\
  \ Dentz <luiz.von.dentz@intel.com>\n\n## Buggy Code\n\n```c\n// Function: rfcomm_sock_setsockopt\
  \ in net/bluetooth/rfcomm/sock.c\nstatic int rfcomm_sock_setsockopt(struct socket\
  \ *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\
  \tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint err = 0;\n\tsize_t\
  \ len;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\
  \treturn rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level\
  \ != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname)\
  \ {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\
  \t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned\
  \ int, sizeof(sec), optlen);\n\t\tif (copy_from_sockptr(&sec, optval, len)) {\n\t\
  \t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level > BT_SECURITY_HIGH)\
  \ {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\trfcomm_pi(sk)->sec_level =\
  \ sec.level;\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND\
  \ && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\
  \t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\
  \t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\
  \t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\n\t\tbreak;\n\
  \n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\t\
  return err;\n}\n```\n\n```c\n// Function: rfcomm_sock_setsockopt_old in net/bluetooth/rfcomm/sock.c\n\
  static int rfcomm_sock_setsockopt_old(struct socket *sock, int optname,\n\t\tsockptr_t\
  \ optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\
  \tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname)\
  \ {\n\tcase RFCOMM_LM:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\
  \t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_FIPS) {\n\t\
  \t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_AUTH)\n\t\t\t\
  rfcomm_pi(sk)->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & RFCOMM_LM_ENCRYPT)\n\t\
  \t\trfcomm_pi(sk)->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & RFCOMM_LM_SECURE)\n\
  \t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_HIGH;\n\n\t\trfcomm_pi(sk)->role_switch\
  \ = (opt & RFCOMM_LM_MASTER);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\
  \t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\
  \n```diff\ndiff --git a/net/bluetooth/rfcomm/sock.c b/net/bluetooth/rfcomm/sock.c\n\
  index b54e8a530f55..29aa07e9db9d 100644\n--- a/net/bluetooth/rfcomm/sock.c\n+++\
  \ b/net/bluetooth/rfcomm/sock.c\n@@ -629,7 +629,7 @@ static int rfcomm_sock_setsockopt_old(struct\
  \ socket *sock, int optname,\n \n \tswitch (optname) {\n \tcase RFCOMM_LM:\n-\t\t\
  if (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n+\t\tif (bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen)) {\n \t\t\terr = -EFAULT;\n \t\t\tbreak;\n \t\t}\n\
  @@ -664,7 +664,6 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level,\
  \ int optname,\n \tstruct sock *sk = sock->sk;\n \tstruct bt_security sec;\n \t\
  int err = 0;\n-\tsize_t len;\n \tu32 opt;\n \n \tBT_DBG(\"sk %p\", sk);\n@@ -686,11\
  \ +685,9 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level, int\
  \ optname,\n \n \t\tsec.level = BT_SECURITY_LOW;\n \n-\t\tlen = min_t(unsigned int,\
  \ sizeof(sec), optlen);\n-\t\tif (copy_from_sockptr(&sec, optval, len)) {\n-\t\t\
  \terr = -EFAULT;\n+\t\terr = bt_copy_from_sockptr(&sec, sizeof(sec), optval, optlen);\n\
  +\t\tif (err)\n \t\t\tbreak;\n-\t\t}\n \n \t\tif (sec.level > BT_SECURITY_HIGH)\
  \ {\n \t\t\terr = -EINVAL;\n@@ -706,10 +703,9 @@ static int rfcomm_sock_setsockopt(struct\
  \ socket *sock, int level, int optname,\n \t\t\tbreak;\n \t\t}\n \n-\t\tif (copy_from_sockptr(&opt,\
  \ optval, sizeof(u32))) {\n-\t\t\terr = -EFAULT;\n+\t\terr = bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen);\n+\t\tif (err)\n \t\t\tbreak;\n-\t\t}\n \n \t\t\
  if (opt)\n \t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n```\n"
pattern: "## Bug Pattern\n\nCalling copy_from_sockptr() with a fixed size for the\
  \ destination object without validating that optlen is at least that size (or otherwise\
  \ bounding the copy by optlen), e.g.:\n\n- if (copy_from_sockptr(&opt, optval, sizeof(opt)))\
  \ \u2026\n- if (copy_from_sockptr(&sec, optval, sizeof(sec))) \u2026\n\nThis ignores\
  \ the user-provided optlen and can:\n- overread when optval is a KERNEL_SOCKPTR\
  \ to a smaller slab object (slab-out-of-bounds), or\n- result in partially initialized\
  \ structures if optlen is shorter than expected.\n\nCorrect pattern: check optlen\
  \ >= sizeof(obj) or use a helper that validates/bounds the copy (e.g., bt_copy_from_sockptr(&obj,\
  \ sizeof(obj), optval, optlen))."
plan: "Plan\n\n1) Program state\n- No custom program state is necessary. This checker\
  \ is a pure call-pattern detector.\n\n2) Callback selection\n- Use checkPostCall\
  \ as the only callback. We will analyze each function call and report if it matches\
  \ the bug pattern.\n\n3) Detection in checkPostCall\n- Identify target calls:\n\
  \  - Retrieve the callee\u2019s IdentifierInfo from CallEvent and check if the name\
  \ equals \"copy_from_sockptr\".\n  - Ignore other function names (e.g., the fixed\
  \ helper \"bt_copy_from_sockptr\" is the correct pattern and should not be flagged).\n\
  \n- Collect arguments:\n  - For copy_from_sockptr, require at least 3 arguments.\n\
  \  - Arg0: destination buffer (ignored for decision).\n  - Arg1: source sockptr,\
  \ typically named optval.\n  - Arg2: length expression (LenExpr) that we must analyze.\n\
  \n- Require setsockopt context heuristics (to minimize false positives):\n  - Ensure\
  \ we are in a function that has a parameter named \"optlen\".\n    - Get FunctionDecl\
  \ from C.getLocationContext()->getDecl(), iterate parameters, check getNameAsString()\
  \ == \"optlen\".\n  - Ensure the 2nd argument\u2019s source text contains \"optval\"\
  \ (ExprHasName(Arg1, \"optval\", C)).\n\n- Decide if the length is a fixed size\
  \ and not bounded by optlen:\n  - Define a small helper (inline in the checker)\
  \ isFixedSizeExpr(E):\n    - Let EE = E->IgnoreParenImpCasts().\n    - Return true\
  \ if EE is:\n      - UnaryExprOrTypeTraitExpr with kind UETT_SizeOf, or\n      -\
  \ IntegerLiteral (or CharacterLiteral if present).\n  - Check whether LenExpr is\
  \ bounded by optlen:\n    - If ExprHasName(LenExpr, \"optlen\", C) => bounded, do\
  \ not warn.\n    - Else if LenExpr is a DeclRefExpr to a VarDecl and VarDecl->hasInit():\n\
  \      - If ExprHasName(VarDecl->getInit(), \"optlen\", C) => bounded (e.g., len\
  \ = min(..., optlen)), do not warn.\n  - If isFixedSizeExpr(LenExpr) is true and\
  \ not bounded by optlen as per above checks, then we have the bug pattern.\n\n-\
  \ Emit report:\n  - Create a BugType once in the checker (e.g., BT.reset(new BugType(this,\
  \ \"copy_from_sockptr ignores optlen\", \"Linux API Misuse\"))).\n  - Create a non-fatal\
  \ error node: if (!N) N = C.generateNonFatalErrorNode(); if (!N) return; (standard\
  \ pattern).\n  - Emit a concise message:\n    - \"copy_from_sockptr size ignores\
  \ optlen; use bt_copy_from_sockptr or validate optlen\"\n  - Attach the report to\
  \ the call expression\u2019s source range:\n    - Use Call.getSourceRange() or the\
  \ third argument source range to highlight.\n\n4) Notes/heuristics to reduce noise\n\
  - Only report when:\n  - Function has parameter named \"optlen\", and\n  - The second\
  \ argument contains \"optval\", and\n  - The length (third argument) is a fixed-size\
  \ expression (sizeof(...) or integer literal) and not bounded/derived from \"optlen\"\
  \ by the simple checks above.\n- This focuses the checker on setsockopt-like handlers\
  \ and avoids flagging unrelated copy_from_sockptr uses.\n\n5) Optional enhancements\
  \ (if desired, but not required)\n- Also match \"copy_from_sockptr\" calls where\
  \ LenExpr is a DeclRefExpr with no init but later re-assigned; this requires scanning\
  \ CFG or previous statements and is intentionally omitted to keep the checker simple\
  \ and robust.\n- To extend coverage, you may add \"copy_from_sockptr_offset\" with\
  \ appropriate index for the length argument once its signature is confirmed; otherwise,\
  \ leave it out to avoid false positives.\n\nCallbacks summary\n- checkPostCall:\n\
  \  - If callee is \"copy_from_sockptr\":\n    - Check for presence of function parameter\
  \ \"optlen\".\n    - Verify Arg1 mentions \"optval\".\n    - Analyze Arg2 (length):\n\
  \      - If fixed-size and not referencing/derived from \"optlen\", report the bug.\n\
  - No other callbacks are used."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states are necessary for this checker.\n\nnamespace {\n/* The checker callbacks\
  \ are to be decided. */\nclass SAGenTestChecker : public Checker<check::PostCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"copy_from_sockptr ignores optlen\", \"Linux API Misuse\"\
  )) {}\n\n      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \n   private:\n\n      bool hasOptlenParam(const CheckerContext &C) const;\n   \
  \   bool isFixedSizeExpr(const Expr *E) const;\n      bool exprDerivedFromOptlen(const\
  \ Expr *E, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::hasOptlenParam(const\
  \ CheckerContext &C) const {\n  const Decl *D = C.getLocationContext()->getDecl();\n\
  \  const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n  if (!FD)\n    return false;\n\
  \  for (const ParmVarDecl *P : FD->parameters()) {\n    if (!P)\n      continue;\n\
  \    if (P->getName() == \"optlen\")\n      return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isFixedSizeExpr(const Expr *E) const {\n  if (!E)\n\
  \    return false;\n  const Expr *EE = E->IgnoreParenImpCasts();\n  if (isa<IntegerLiteral>(EE))\n\
  \    return true;\n  if (const auto *UETT = dyn_cast<UnaryExprOrTypeTraitExpr>(EE))\
  \ {\n    if (UETT->getKind() == UETT_SizeOf)\n      return true;\n  }\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::exprDerivedFromOptlen(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E)\n    return false;\n\n  // Direct reference to \"optlen\"\
  \ anywhere in the expression text.\n  if (ExprHasName(E, \"optlen\", C))\n    return\
  \ true;\n\n  // If it's a DeclRefExpr to a local variable with an initializer derived\
  \ from optlen.\n  const Expr *EE = E->IgnoreParenImpCasts();\n  if (const auto *DRE\
  \ = dyn_cast<DeclRefExpr>(EE)) {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n      if (VD->hasInit()) {\n        const Expr *Init = VD->getInit();\n   \
  \     if (Init && ExprHasName(Init, \"optlen\", C))\n          return true;\n  \
  \    }\n    }\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return;\n\n  // Only target copy_from_sockptr (the buggy\
  \ usage). Do not match bt_copy_from_sockptr.\n  if (!ExprHasName(OriginExpr, \"\
  copy_from_sockptr\", C))\n    return;\n\n  // Require at least 3 args: dst, src\
  \ (optval), len\n  if (Call.getNumArgs() < 3)\n    return;\n\n  // Heuristic to\
  \ focus on setsockopt-like handlers:\n  // - function should have a parameter named\
  \ \"optlen\"\n  if (!hasOptlenParam(C))\n    return;\n\n  // - second argument should\
  \ reference/contain \"optval\"\n  const Expr *Arg1Expr = Call.getArgExpr(1);\n \
  \ if (!Arg1Expr || !ExprHasName(Arg1Expr, \"optval\", C))\n    return;\n\n  // Analyze\
  \ length argument (3rd argument)\n  const Expr *LenExpr = Call.getArgExpr(2);\n\
  \  if (!LenExpr)\n    return;\n\n  // If length is derived from optlen, it's considered\
  \ safe.\n  if (exprDerivedFromOptlen(LenExpr, C))\n    return;\n\n  // If length\
  \ is a fixed-size expression (sizeof(...) or integer literal) and not bounded by\
  \ optlen -> bug.\n  if (!isFixedSizeExpr(LenExpr))\n    return;\n\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"copy_from_sockptr size ignores optlen; use bt_copy_from_sockptr or\
  \ validate optlen\", N);\n  R->addRange(LenExpr->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects copy_from_sockptr calls using a fixed size without validating/bounding\
  \ with optlen\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
