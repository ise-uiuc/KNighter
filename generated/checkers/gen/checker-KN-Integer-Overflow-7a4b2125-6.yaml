_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 7a4b21250bf79eef26543d35bd390448646c536b
commit_type: Integer-Overflow
index: 6
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Track symbols that are results of roundup_pow_of_two()\n\
  REGISTER_SET_WITH_PROGRAMSTATE(RoundupSyms, SymbolRef)\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PostCall, check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"API Misuse\"\
  , \"Integer Overflow/UB\")) {}\n\n      void checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n      void checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const;\n\n   private:\n      bool isRoundupPow2CallExpr(const\
  \ Expr *E, CheckerContext &C) const;\n      bool isZero(const Expr *E, CheckerContext\
  \ &C) const;\n      void reportUnsafeZeroCheck(const Stmt *S, CheckerContext &C)\
  \ const;\n};\n\nbool SAGenTestChecker::isRoundupPow2CallExpr(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E) return false;\n  // Look downwards for a CallExpr and check\
  \ its callee name.\n  if (const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(E))\
  \ {\n    return ExprHasName(CE, \"roundup_pow_of_two\", C);\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isZero(const Expr *E, CheckerContext &C) const {\n \
  \ if (!E) return false;\n  llvm::APSInt V;\n  if (EvaluateExprToInt(V, E, C)) {\n\
  \    return V == 0;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::reportUnsafeZeroCheck(const\
  \ Stmt *S, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Do not zero-check roundup_pow_of_two() result; overflow is\
  \ UB on 32-bit. Pre-check arg (> 1UL << 31) before calling.\",\n      N);\n  if\
  \ (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\
  \nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n\
  \    return;\n\n  // Identify roundup_pow_of_two() using the source text of the\
  \ origin expr.\n  if (!ExprHasName(OriginExpr, \"roundup_pow_of_two\", C))\n   \
  \ return;\n\n  SVal Ret = Call.getReturnValue();\n  SymbolRef Sym = Ret.getAsSymbol();\n\
  \  if (!Sym)\n    return;\n\n  ProgramStateRef State = C.getState();\n  State =\
  \ State->add<RoundupSyms>(Sym);\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE) {\n   \
  \ C.addTransition(State);\n    return;\n  }\n\n  CondE = CondE->IgnoreParenImpCasts();\n\
  \n  auto CheckExprForRoundupResult = [&](const Expr *E) -> bool {\n    if (!E) return\
  \ false;\n    // Check if the expression evaluates to a tracked roundup_pow_of_two\
  \ symbol\n    SVal SV = State->getSVal(E, C.getLocationContext());\n    if (SymbolRef\
  \ Sym = SV.getAsSymbol()) {\n      if (State->contains<RoundupSyms>(Sym))\n    \
  \    return true;\n    }\n    // Or if the expression directly calls roundup_pow_of_two()\n\
  \    if (isRoundupPow2CallExpr(E, C))\n      return true;\n\n    return false;\n\
  \  };\n\n  bool ShouldReport = false;\n\n  // Pattern 1: if (!X)\n  if (const auto\
  \ *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if (UO->getOpcode() == UO_LNot) {\n\
  \      const Expr *X = UO->getSubExpr()->IgnoreParenImpCasts();\n      if (CheckExprForRoundupResult(X))\n\
  \        ShouldReport = true;\n    }\n  }\n  // Pattern 2: if (X == 0) or if (0\
  \ == X)\n  else if (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    if\
  \ (BO->getOpcode() == BO_EQ) {\n      const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n      bool LIsZero\
  \ = isZero(L, C);\n      bool RIsZero = isZero(R, C);\n\n      if (LIsZero && !RIsZero)\
  \ {\n        if (CheckExprForRoundupResult(R))\n          ShouldReport = true;\n\
  \      } else if (RIsZero && !LIsZero) {\n        if (CheckExprForRoundupResult(L))\n\
  \          ShouldReport = true;\n      }\n    }\n  }\n\n  if (ShouldReport) {\n\
  \    reportUnsafeZeroCheck(Condition, C);\n  }\n\n  C.addTransition(State);\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects zero-check of roundup_pow_of_two() results (UB on 32-bit); suggest\
  \ pre-validating input\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbpf: Fix stackmap overflow check on 32-bit arches\n\
  \nThe stackmap code relies on roundup_pow_of_two() to compute the number\nof hash\
  \ buckets, and contains an overflow check by checking if the\nresulting value is\
  \ 0. However, on 32-bit arches, the roundup code itself\ncan overflow by doing a\
  \ 32-bit left-shift of an unsigned long value,\nwhich is undefined behaviour, so\
  \ it is not guaranteed to truncate\nneatly. This was triggered by syzbot on the\
  \ DEVMAP_HASH type, which\ncontains the same check, copied from the hashtab code.\n\
  \nThe commit in the fixes tag actually attempted to fix this, but the fix\ndid not\
  \ account for the UB, so the fix only works on CPUs where an\noverflow does result\
  \ in a neat truncation to zero, which is not\nguaranteed. Checking the value before\
  \ rounding does not have this\nproblem.\n\nFixes: 6183f4d3a0a2 (\"bpf: Check for\
  \ integer overflow when using roundup_pow_of_two()\")\nSigned-off-by: Toke H\xF8\
  iland-J\xF8rgensen <toke@redhat.com>\nReviewed-by: Bui Quang Minh <minhquangbui99@gmail.com>\n\
  Message-ID: <20240307120340.99577-4-toke@redhat.com>\nSigned-off-by: Alexei Starovoitov\
  \ <ast@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: stack_map_alloc in kernel/bpf/stackmap.c\n\
  static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n{\n\tu32 value_size\
  \ = attr->value_size;\n\tstruct bpf_stack_map *smap;\n\tu64 cost, n_buckets;\n\t\
  int err;\n\n\tif (attr->map_flags & ~STACK_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size\
  \ != 4 ||\n\t    value_size < 8 || value_size % 8)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\tBUILD_BUG_ON(sizeof(struct bpf_stack_build_id) % sizeof(u64));\n\tif (attr->map_flags\
  \ & BPF_F_STACK_BUILD_ID) {\n\t\tif (value_size % sizeof(struct bpf_stack_build_id)\
  \ ||\n\t\t    value_size / sizeof(struct bpf_stack_build_id)\n\t\t    > sysctl_perf_event_max_stack)\n\
  \t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n\
  \t\treturn ERR_PTR(-EINVAL);\n\n\t/* hash table size must be power of 2 */\n\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n\tif (!n_buckets)\n\t\treturn ERR_PTR(-E2BIG);\n\
  \n\tcost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);\n\tsmap\
  \ = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\tif (!smap)\n\t\t\
  return ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&smap->map, attr);\n\tsmap->n_buckets\
  \ = n_buckets;\n\n\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\t\
  if (err)\n\t\tgoto free_smap;\n\n\terr = prealloc_elems_and_freelist(smap);\n\t\
  if (err)\n\t\tgoto put_buffers;\n\n\treturn &smap->map;\n\nput_buffers:\n\tput_callchain_buffers();\n\
  free_smap:\n\tbpf_map_area_free(smap);\n\treturn ERR_PTR(err);\n}\n```\n\n## Bug\
  \ Fix Patch\n\n```diff\ndiff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c\n\
  index dff7ba539701..c99f8e5234ac 100644\n--- a/kernel/bpf/stackmap.c\n+++ b/kernel/bpf/stackmap.c\n\
  @@ -91,11 +91,14 @@ static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n\
  \ \t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n \t\treturn ERR_PTR(-EINVAL);\n\
  \ \n-\t/* hash table size must be power of 2 */\n-\tn_buckets = roundup_pow_of_two(attr->max_entries);\n\
  -\tif (!n_buckets)\n+\t/* hash table size must be power of 2; roundup_pow_of_two()\
  \ can overflow\n+\t * into UB on 32-bit arches, so check that first\n+\t */\n+\t\
  if (attr->max_entries > 1UL << 31)\n \t\treturn ERR_PTR(-E2BIG);\n \n+\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n+\n \tcost = n_buckets * sizeof(struct\
  \ stack_map_bucket *) + sizeof(*smap);\n \tsmap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\
  \ \tif (!smap)\n```\n"
pattern: "## Bug Pattern\n\nRelying on roundup_pow_of_two() to detect overflow by\
  \ checking for a zero result when computing a power-of-two size on 32-bit architectures:\n\
  \nn_buckets = roundup_pow_of_two(max_entries);\nif (!n_buckets) // attempt to detect\
  \ overflow\n    return -E2BIG;\n\nOn 32-bit, roundup_pow_of_two() can perform an\
  \ overflowing left shift (UB) for inputs > 2^31, so the result is not reliably zero.\
  \ The correct pattern is to pre-validate the input (e.g., max_entries > 1UL << 31)\
  \ before calling roundup_pow_of_two() to avoid undefined behavior."
plan: "Plan to detect unsafe zero-check of roundup_pow_of_two() results (32-bit UB)\n\
  \n1. Program state\n- REGISTER_SET_WITH_PROGRAMSTATE(RoundupSyms, SymbolRef)\n \
  \ - Stores the symbolic return values produced by calls to roundup_pow_of_two().\n\
  \  - No alias maps are needed; the symbol flows with the value and will be read\
  \ back at the use site.\n\n2. Callbacks and their roles\n- checkPostCall\n  - Goal:\
  \ Record the symbolic result of roundup_pow_of_two().\n  - Steps:\n    1. Identify\
  \ function by name:\n       - If Call.getCalleeIdentifier() exists and its name\
  \ equals \"roundup_pow_of_two\", proceed.\n    2. Get the return value:\n      \
  \ - SVal Ret = Call.getReturnValue(); if it\u2019s a DefinedSVal and has a SymbolRef\
  \ (Ret.getAsSymbol()), add it to RoundupSyms.\n    3. Update state with State->add<RoundupSyms>(Sym)\
  \ and C.addTransition(State).\n  - Notes:\n    - This works both when the call\u2019\
  s result is assigned to a variable and when it\u2019s used directly in conditions;\
  \ the return value symbol will be propagated by the analyzer.\n\n- checkBranchCondition\n\
  \  - Goal: Detect zero-checks on roundup_pow_of_two() results, which imply relying\
  \ on overflow turning into zero.\n  - Patterns to detect:\n    1. Unary logical-not:\n\
  \       - if (!X)\n    2. Explicit comparison against zero:\n       - if (X == 0)\
  \ or if (0 == X)\n  - Steps:\n    1. Normalize the condition expression: const Expr\
  \ *CondE = dyn_cast<Expr>(Condition)->IgnoreParenImpCasts().\n    2. Handle logical-not:\n\
  \       - If CondE is a UnaryOperator with opcode UO_LNot, let X = SubExpr->IgnoreParenImpCasts().\n\
  \       - Obtain SVal SV = C.getSVal(X). If SV.getAsSymbol() exists and is in RoundupSyms,\
  \ report a bug.\n       - If there is no symbol match, also try to detect direct\
  \ call: if X (or a child) is a CallExpr whose callee is named \"roundup_pow_of_two\"\
  , report a bug.\n    3. Handle equality to zero:\n       - If CondE is a BinaryOperator\
  \ with opcode BO_EQ (we focus on == 0 checks; != 0 is not the problematic overflow-as-zero\
  \ check):\n         - Let L = LHS->IgnoreParenImpCasts(), R = RHS->IgnoreParenImpCasts().\n\
  \         - Evaluate either side to an integer using EvaluateExprToInt. If one side\
  \ is constant zero:\n           - For the non-zero side N, obtain SVal NSV = C.getSVal(N).\
  \ If NSV.getAsSymbol() is in RoundupSyms, report a bug.\n           - If symbol\
  \ not found, also check if N (or one of its children) is a CallExpr to \"roundup_pow_of_two\"\
  \ and report if so.\n    4. Emitting the report:\n       - Generate a non-fatal\
  \ error node with C.generateNonFatalErrorNode().\n       - If node is null, return.\n\
  \       - Create a PathSensitiveBugReport with a short message, e.g.:\n        \
  \ - \"Do not zero-check roundup_pow_of_two() result; overflow is UB on 32-bit. Pre-check\
  \ arg (> 1UL << 31) before calling.\"\n       - Attach the condition\u2019s source\
  \ range to the report and emit.\n  - Notes:\n    - We intentionally do not require\
  \ proving the argument range or architecture; this is a pattern-based diagnostic\
  \ aligned with the kernel fix.\n    - We only warn for BO_EQ-to-zero or logical-not.\
  \ These are the canonical \u201Coverflow -> zero\u201D checks used in the buggy\
  \ pattern.\n\n3. Optional helper logic inside checkBranchCondition\n- Detecting\
  \ direct calls in the condition:\n  - Use findSpecificTypeInChildren<CallExpr>(Expr)\
  \ to find a CallExpr under the relevant sub-expression.\n  - If found, verify the\
  \ callee name equals \"roundup_pow_of_two\".\n- Checking constants:\n  - Use EvaluateExprToInt(EvalRes,\
  \ Expr, C) to robustly detect literal zero across casts/macros.\n\n4. What we do\
  \ not track (to keep it simple)\n- No alias maps: the symbolic value from the call\
  \ naturally flows into variables and through assignments; reading those variables\
  \ yields the same symbol.\n- No attempt to suppress warnings if a correct pre-check\
  \ (arg > 1UL << 31) is present; keeping the checker simple avoids complex control-flow\
  \ mining and reduces brittleness.\n\n5. Summary of minimal implementation steps\n\
  - Define RoundupSyms as a program state set of SymbolRef.\n- In checkPostCall:\n\
  \  - If callee name is \"roundup_pow_of_two\", grab return SymbolRef and add to\
  \ RoundupSyms.\n- In checkBranchCondition:\n  - If condition is (!X) or (X == 0)\
  \ or (0 == X):\n    - Check whether X\u2019s symbol is in RoundupSyms.\n    - Or\
  \ whether X directly calls \"roundup_pow_of_two\".\n    - If yes, report with a\
  \ short message."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Track symbols that are results of roundup_pow_of_two()\n\
  REGISTER_SET_WITH_PROGRAMSTATE(RoundupSyms, SymbolRef)\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PostCall, check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"API Misuse\"\
  , \"Integer Overflow/UB\")) {}\n\n      void checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n      void checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const;\n\n   private:\n      bool isRoundupPow2CallExpr(const\
  \ Expr *E, CheckerContext &C) const;\n      bool isZero(const Expr *E, CheckerContext\
  \ &C) const;\n      void reportUnsafeZeroCheck(const Stmt *S, CheckerContext &C)\
  \ const;\n};\n\nbool SAGenTestChecker::isRoundupPow2CallExpr(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E) return false;\n  // Look downwards for a CallExpr and check\
  \ its callee name.\n  if (const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(E))\
  \ {\n    return ExprHasName(CE, \"roundup_pow_of_two\", C);\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isZero(const Expr *E, CheckerContext &C) const {\n \
  \ if (!E) return false;\n  llvm::APSInt V;\n  if (EvaluateExprToInt(V, E, C)) {\n\
  \    return V == 0;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::reportUnsafeZeroCheck(const\
  \ Stmt *S, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Do not zero-check roundup_pow_of_two() result; overflow is\
  \ UB on 32-bit. Pre-check arg (> 1UL << 31) before calling.\",\n      N);\n  if\
  \ (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\
  \nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n\
  \    return;\n\n  // Identify roundup_pow_of_two() using the source text of the\
  \ origin expr.\n  if (!ExprHasName(OriginExpr, \"roundup_pow_of_two\", C))\n   \
  \ return;\n\n  SVal Ret = Call.getReturnValue();\n  SymbolRef Sym = Ret.getAsSymbol();\n\
  \  if (!Sym)\n    return;\n\n  ProgramStateRef State = C.getState();\n  State =\
  \ State->add<RoundupSyms>(Sym);\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE) {\n   \
  \ C.addTransition(State);\n    return;\n  }\n\n  CondE = CondE->IgnoreParenImpCasts();\n\
  \n  auto CheckExprForRoundupResult = [&](const Expr *E) -> bool {\n    if (!E) return\
  \ false;\n    // Check if the expression evaluates to a tracked roundup_pow_of_two\
  \ symbol\n    SVal SV = State->getSVal(E, C.getLocationContext());\n    if (SymbolRef\
  \ Sym = SV.getAsSymbol()) {\n      if (State->contains<RoundupSyms>(Sym))\n    \
  \    return true;\n    }\n    // Or if the expression directly calls roundup_pow_of_two()\n\
  \    if (isRoundupPow2CallExpr(E, C))\n      return true;\n\n    return false;\n\
  \  };\n\n  bool ShouldReport = false;\n\n  // Pattern 1: if (!X)\n  if (const auto\
  \ *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if (UO->getOpcode() == UO_LNot) {\n\
  \      const Expr *X = UO->getSubExpr()->IgnoreParenImpCasts();\n      if (CheckExprForRoundupResult(X))\n\
  \        ShouldReport = true;\n    }\n  }\n  // Pattern 2: if (X == 0) or if (0\
  \ == X)\n  else if (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    if\
  \ (BO->getOpcode() == BO_EQ) {\n      const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n      bool LIsZero\
  \ = isZero(L, C);\n      bool RIsZero = isZero(R, C);\n\n      if (LIsZero && !RIsZero)\
  \ {\n        if (CheckExprForRoundupResult(R))\n          ShouldReport = true;\n\
  \      } else if (RIsZero && !LIsZero) {\n        if (CheckExprForRoundupResult(L))\n\
  \          ShouldReport = true;\n      }\n    }\n  }\n\n  if (ShouldReport) {\n\
  \    reportUnsafeZeroCheck(Condition, C);\n  }\n\n  C.addTransition(State);\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects zero-check of roundup_pow_of_two() results (UB on 32-bit); suggest\
  \ pre-validating input\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
