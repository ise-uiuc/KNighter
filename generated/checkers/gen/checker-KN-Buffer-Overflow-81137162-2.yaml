_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 81137162bfaa7278785b24c1fd2e9e74f082e8e4
commit_type: Buffer-Overflow
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states are required.\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker() :\
  \ BT(new BugType(this, \"Buffer Overflow\", \"API Misuse\")) {}\n\n  void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  static\
  \ bool isStrcpyLike(const CallEvent &Call, CheckerContext &C);\n  static bool getConstArrayBound(const\
  \ Expr *E, llvm::APInt &Bound, const ASTContext &ACtx);\n  static bool getStringLiteralLen(const\
  \ Expr *E, llvm::APInt &LenOut);\n  void report(const CallEvent &Call, CheckerContext\
  \ &C, bool Definite,\n              uint64_t DstSize) const;\n};\n\n// Determine\
  \ if a call is to strcpy or its builtin variant.\nbool SAGenTestChecker::isStrcpyLike(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Prefer text-based matching as advised.\n\
  \  if (ExprHasName(Origin, \"strcpy\", C))\n    return true;\n  if (ExprHasName(Origin,\
  \ \"__builtin_strcpy\", C))\n    return true;\n\n  // Fallback to identifier check\
  \ (exact names only).\n  if (const IdentifierInfo *ID = Call.getCalleeIdentifier())\
  \ {\n    StringRef N = ID->getName();\n    if (N == \"strcpy\" || N == \"__builtin_strcpy\"\
  )\n      return true;\n  }\n  return false;\n}\n\n// Try to get a compile-time constant\
  \ array bound from an expression\nbool SAGenTestChecker::getConstArrayBound(const\
  \ Expr *E, llvm::APInt &Bound,\n                                          const\
  \ ASTContext &ACtx) {\n  if (!E)\n    return false;\n\n  const Expr *PE = E->IgnoreParenImpCasts();\n\
  \n  QualType QT;\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(PE)) {\n    if (const\
  \ auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n      QT = VD->getType();\n  }\
  \ else if (const auto *ME = dyn_cast<MemberExpr>(PE)) {\n    if (const auto *FD\
  \ = dyn_cast<FieldDecl>(ME->getMemberDecl()))\n      QT = FD->getType();\n  } else\
  \ if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(PE)) {\n    // Handle cases\
  \ like dest[0], take the base expression type.\n    const Expr *Base = ASE->getBase()->IgnoreParenImpCasts();\n\
  \    if (const auto *BDRE = dyn_cast<DeclRefExpr>(Base)) {\n      if (const auto\
  \ *VD = dyn_cast<VarDecl>(BDRE->getDecl()))\n        QT = VD->getType();\n    }\
  \ else if (const auto *BME = dyn_cast<MemberExpr>(Base)) {\n      if (const auto\
  \ *FD = dyn_cast<FieldDecl>(BME->getMemberDecl()))\n        QT = FD->getType();\n\
  \    }\n  } else if (const auto *UO = dyn_cast<UnaryOperator>(PE)) {\n    // Handle\
  \ &arr[0] or similar. Try to peel further.\n    if (UO->getOpcode() == UO_AddrOf\
  \ || UO->getOpcode() == UO_Deref) {\n      return getConstArrayBound(UO->getSubExpr(),\
  \ Bound, ACtx);\n    }\n  }\n\n  if (QT.isNull())\n    return false;\n\n  QT = QT.getCanonicalType();\n\
  \  if (const auto *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr())) {\n    Bound\
  \ = CAT->getSize();\n    return true;\n  }\n  return false;\n}\n\n// Get string\
  \ literal length (without the terminating null).\nbool SAGenTestChecker::getStringLiteralLen(const\
  \ Expr *E, llvm::APInt &LenOut) {\n  return getStringSize(LenOut, E);\n}\n\nvoid\
  \ SAGenTestChecker::report(const CallEvent &Call, CheckerContext &C,\n         \
  \                     bool Definite, uint64_t DstSize) const {\n  ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  llvm::SmallString<128>\
  \ Msg;\n  if (Definite) {\n    Msg = \"strcpy overflows fixed-size buffer\";\n \
  \ } else {\n    Msg = \"strcpy into fixed-size buffer may overflow; use strscpy(...,\
  \ sizeof(dest))\";\n  }\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg.c_str(), N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  if (!isStrcpyLike(Call, C))\n    return;\n\n  if (Call.getNumArgs()\
  \ < 2)\n    return;\n\n  const Expr *DstE = Call.getArgExpr(0);\n  const Expr *SrcE\
  \ = Call.getArgExpr(1);\n  if (!DstE || !SrcE)\n    return;\n\n  const ASTContext\
  \ &ACtx = C.getASTContext();\n  llvm::APInt DstBound;\n  if (!getConstArrayBound(DstE,\
  \ DstBound, ACtx)) {\n    // Only warn when destination is a compile-time fixed-size\
  \ array.\n    return;\n  }\n\n  // If source is a string literal, we can determine\
  \ definiteness.\n  llvm::APInt SrcLen;\n  if (getStringLiteralLen(SrcE, SrcLen))\
  \ {\n    uint64_t Needs = SrcLen.getZExtValue() + 1; // include terminating null\n\
  \    uint64_t DstSz = DstBound.getZExtValue();\n    if (Needs > DstSz) {\n     \
  \ report(Call, C, /*Definite=*/true, DstSz);\n    }\n    // else: definitely fits,\
  \ no warning.\n    return;\n  }\n\n  // If source is a constant array, compare capacities\
  \ as a heuristic.\n  llvm::APInt SrcBound;\n  if (getConstArrayBound(SrcE, SrcBound,\
  \ ACtx)) {\n    uint64_t SrcCap = SrcBound.getZExtValue();\n    uint64_t DstSz =\
  \ DstBound.getZExtValue();\n    if (SrcCap > DstSz) {\n      report(Call, C, /*Definite=*/false,\
  \ DstSz);\n    }\n    // Else: source capacity <= dest, likely safe.\n    return;\n\
  \  }\n\n  // Unknown source length; strcpy is unbounded -> potential overflow.\n\
  \  report(Call, C, /*Definite=*/false, DstBound.getZExtValue());\n}\n\n} // end\
  \ anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unsafe strcpy into fixed-size buffers; suggest strscpy(..., sizeof(dest))\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: hci_core: Fix possible buffer overflow\n\
  \nstruct hci_dev_info has a fixed size name[8] field so in the event that\nhdev->name\
  \ is bigger than that strcpy would attempt to write past its\nsize, so this fixes\
  \ this problem by switching to use strscpy.\n\nFixes: dcda165706b9 (\"Bluetooth:\
  \ hci_core: Fix build warnings\")\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\n\
  \n## Buggy Code\n\n```c\n// Function: hci_get_dev_info in net/bluetooth/hci_core.c\n\
  int hci_get_dev_info(void __user *arg)\n{\n\tstruct hci_dev *hdev;\n\tstruct hci_dev_info\
  \ di;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (copy_from_user(&di, arg,\
  \ sizeof(di)))\n\t\treturn -EFAULT;\n\n\thdev = hci_dev_get(di.dev_id);\n\tif (!hdev)\n\
  \t\treturn -ENODEV;\n\n\t/* When the auto-off is configured it means the transport\n\
  \t * is running, but in that case still indicate that the\n\t * device is actually\
  \ down.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_AUTO_OFF))\n\t\tflags = hdev->flags\
  \ & ~BIT(HCI_UP);\n\telse\n\t\tflags = hdev->flags;\n\n\tstrcpy(di.name, hdev->name);\n\
  \tdi.bdaddr   = hdev->bdaddr;\n\tdi.type     = (hdev->bus & 0x0f) | ((hdev->dev_type\
  \ & 0x03) << 4);\n\tdi.flags    = flags;\n\tdi.pkt_type = hdev->pkt_type;\n\tif\
  \ (lmp_bredr_capable(hdev)) {\n\t\tdi.acl_mtu  = hdev->acl_mtu;\n\t\tdi.acl_pkts\
  \ = hdev->acl_pkts;\n\t\tdi.sco_mtu  = hdev->sco_mtu;\n\t\tdi.sco_pkts = hdev->sco_pkts;\n\
  \t} else {\n\t\tdi.acl_mtu  = hdev->le_mtu;\n\t\tdi.acl_pkts = hdev->le_pkts;\n\t\
  \tdi.sco_mtu  = 0;\n\t\tdi.sco_pkts = 0;\n\t}\n\tdi.link_policy = hdev->link_policy;\n\
  \tdi.link_mode   = hdev->link_mode;\n\n\tmemcpy(&di.stat, &hdev->stat, sizeof(di.stat));\n\
  \tmemcpy(&di.features, &hdev->features, sizeof(di.features));\n\n\tif (copy_to_user(arg,\
  \ &di, sizeof(di)))\n\t\terr = -EFAULT;\n\n\thci_dev_put(hdev);\n\n\treturn err;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c\n\
  index 6ca4c0df9f9c..230d2bbb933b 100644\n--- a/net/bluetooth/hci_core.c\n+++ b/net/bluetooth/hci_core.c\n\
  @@ -908,7 +908,7 @@ int hci_get_dev_info(void __user *arg)\n \telse\n \t\tflags\
  \ = hdev->flags;\n \n-\tstrcpy(di.name, hdev->name);\n+\tstrscpy(di.name, hdev->name,\
  \ sizeof(di.name));\n \tdi.bdaddr   = hdev->bdaddr;\n \tdi.type     = (hdev->bus\
  \ & 0x0f) | ((hdev->dev_type & 0x03) << 4);\n \tdi.flags    = flags;\n```\n"
pattern: '## Bug Pattern


  Using an unbounded string copy (strcpy) to copy a potentially longer source string
  into a fixed-size destination buffer inside a struct, leading to buffer overflow.
  For example:


  char dest[8];

  strcpy(dest, src);  // src length may exceed sizeof(dest)


  In the patch: copying hdev->name into di.name (size 8) with strcpy, without length
  checking.'
plan: "Plan\n\n1. Program state\n- No custom program state is required. This checker\
  \ is a syntactic/semantic call-site check for unsafe string copies. We will not\
  \ model flows or aliases.\n\n2. Helper logic (inside the checker)\n- getConstArrayBound(const\
  \ Expr *E): Given an expression E (destination or source), try to recover a compile-time\
  \ constant array bound.\n  - Use E->IgnoreParenImpCasts() to strip array-to-pointer\
  \ decay and other casts.\n  - If the underlying expression is a DeclRefExpr or a\
  \ MemberExpr, read its QualType.\n  - If the QualType is a ConstantArrayType, extract\
  \ the size via cast<ConstantArrayType>(QT.getTypePtr())->getSize().\n  - Return\
  \ true on success (and set an APInt out-param), false otherwise.\n- getStringLiteralLen(const\
  \ Expr *E): Use the provided getStringSize to retrieve the length of a string literal\
  \ argument. Note that for overflow with strcpy, check len + 1 > destSize to account\
  \ for the terminating null.\n- getFunctionName(const CallEvent &Call): Extract the\
  \ callee IdentifierInfo and return its name for simple string comparison.\n- isStrcpyLike(const\
  \ CallEvent &Call): Return true if the callee is one of:\n  - \"strcpy\"\n  - \"\
  __builtin_strcpy\"\n  Note: Do NOT warn on \"strscpy\", \"strlcpy\", or bounded\
  \ copy functions.\n\n3. Callback selection and implementation\n\n3.1. checkPreCall\
  \ (main detection)\n- Goal: Detect calls to strcpy where the destination is a fixed-size\
  \ buffer (compile-time known bound) and the copy is unbounded.\n- Steps:\n  1) Recognize\
  \ the target function:\n     - If !isStrcpyLike(Call), return.\n     - Ensure the\
  \ call has at least 2 arguments.\n  2) Extract arguments:\n     - const Expr *Dst\
  \ = Call.getArgExpr(0);\n     - const Expr *Src = Call.getArgExpr(1);\n  3) Derive\
  \ destination bound:\n     - APInt DstSize;\n     - Try getConstArrayBound(Dst).\
  \ If this fails, return without warning (we only warn when we know the destination\
  \ is a fixed-size array).\n  4) Try to reason about source size:\n     - APInt SrcStrLen;\n\
  \     - bool SrcIsStringLiteral = getStringLiteralLen(SrcStrLen, Src).\n     - If\
  \ SrcIsStringLiteral:\n       - Compute Needs = SrcStrLen.getLimitedValue() + 1.\n\
  \       - If Needs > DstSize.getLimitedValue(), report a definite buffer overflow.\n\
  \       - Else (Needs <= DstSize): considered safe; return.\n     - Else (not a\
  \ string literal):\n       - Try to get a constant array bound for the source:\n\
  \         - APInt SrcArrBound;\n         - If getConstArrayBound(Src) succeeds and\
  \ Src is a char-array:\n           - The array\u2019s total bound is an upper bound\
  \ on content including the null terminator if initialized from a literal.\n    \
  \       - If SrcArrBound.getLimitedValue() > DstSize.getLimitedValue(), report potential\
  \ overflow (cannot prove content length, but capacity exceeds destination).\n  \
  \         - Else return (likely safe in practice).\n       - Otherwise (unknown\
  \ source length):\n         - Report potential overflow because strcpy is unbounded\
  \ and the destination has a fixed, small bound.\n  5) Reporting:\n     - Use generateNonFatalErrorNode\
  \ to create a node. If null, return.\n     - Create a PathSensitiveBugReport (short\
  \ message):\n       - Definite case: \"strcpy overflows fixed-size buffer\"\n  \
  \     - Potential case: \"strcpy into fixed-size buffer may overflow; use strscpy(...,\
  \ sizeof(dest))\"\n     - Add source range of the call or the destination argument\
  \ to the report for highlighting.\n     - Optionally include a note describing the\
  \ destination size (e.g., \"destination buffer size is 8\").\n     - Emit with C.emitReport.\n\
  \n3.2. Optional suppression (simple and conservative)\n- To avoid some false positives,\
  \ perform a very simple guard check just before reporting:\n  - If the immediate\
  \ surrounding if-condition compares strlen(Src) against a constant or sizeof(dest),\
  \ we can skip the warning when the check ensures source length < DstSize.\n  - Implementation\
  \ (optional, only if you want to be slightly conservative):\n    - Use findSpecificTypeInParents<IfStmt>(CallExpr)\
  \ via the provided upward utility (findSpecificTypeInParents) to locate an enclosing\
  \ IfStmt whose condition contains strlen(Src) and a bound comparable to DstSize.\n\
  \    - This is optional; if complexity is undesired, skip this suppression to keep\
  \ the checker simple.\n\n4. What we warn on\n- Only when destination has a compile-time\
  \ bound (constant array) and the function is strcpy (or builtin variant).\n- Definite\
  \ overflow if source is a string literal with len + 1 > dest size.\n- Potential\
  \ overflow if:\n  - Source length is unknown, or\n  - Source is a constant array\
  \ with capacity > dest size.\n\n5. What we do not track\n- No pointer aliasing or\
  \ path-sensitive null checks required.\n- No custom program state maps; no checkBind,\
  \ checkLocation, etc.\n- No post-call modeling is necessary.\n\n6. Notes aligning\
  \ to the provided patch\n- The kernel patch replaces strcpy(di.name, hdev->name)\
  \ with strscpy(di.name, hdev->name, sizeof(di.name)).\n- Our checker will flag exactly\
  \ this pattern because:\n  - dest (di.name) is a fixed-size array (e.g., 8).\n \
  \ - source length is unknown (hdev->name can be longer).\n  - We will report: \"\
  strcpy into fixed-size buffer may overflow; use strscpy(..., sizeof(dest))\"."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states are required.\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker() :\
  \ BT(new BugType(this, \"Buffer Overflow\", \"API Misuse\")) {}\n\n  void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  static\
  \ bool isStrcpyLike(const CallEvent &Call, CheckerContext &C);\n  static bool getConstArrayBound(const\
  \ Expr *E, llvm::APInt &Bound, const ASTContext &ACtx);\n  static bool getStringLiteralLen(const\
  \ Expr *E, llvm::APInt &LenOut);\n  void report(const CallEvent &Call, CheckerContext\
  \ &C, bool Definite,\n              uint64_t DstSize) const;\n};\n\n// Determine\
  \ if a call is to strcpy or its builtin variant.\nbool SAGenTestChecker::isStrcpyLike(const\
  \ CallEvent &Call, CheckerContext &C) {\n  (void)C;\n\n  // Prefer identifier-based\
  \ matching.\n  if (const IdentifierInfo *ID = Call.getCalleeIdentifier()) {\n  \
  \  StringRef N = ID->getName();\n    if (N == \"strcpy\" || N == \"__builtin_strcpy\"\
  )\n      return true;\n  }\n\n  // Fallback: try to get the direct callee's identifier.\n\
  \  if (const Decl *D = Call.getDecl()) {\n    if (const auto *FD = dyn_cast<FunctionDecl>(D))\
  \ {\n      if (const IdentifierInfo *ID = FD->getIdentifier()) {\n        StringRef\
  \ N = ID->getName();\n        if (N == \"strcpy\" || N == \"__builtin_strcpy\")\n\
  \          return true;\n      }\n    }\n  }\n  return false;\n}\n\n// Try to get\
  \ a compile-time constant array bound from an expression\nbool SAGenTestChecker::getConstArrayBound(const\
  \ Expr *E, llvm::APInt &Bound,\n                                          const\
  \ ASTContext &ACtx) {\n  if (!E)\n    return false;\n\n  const Expr *PE = E->IgnoreParenImpCasts();\n\
  \n  QualType QT;\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(PE)) {\n    if (const\
  \ auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n      QT = VD->getType();\n  }\
  \ else if (const auto *ME = dyn_cast<MemberExpr>(PE)) {\n    if (const auto *FD\
  \ = dyn_cast<FieldDecl>(ME->getMemberDecl()))\n      QT = FD->getType();\n  } else\
  \ if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(PE)) {\n    // Handle cases\
  \ like dest[0], take the base expression type.\n    const Expr *Base = ASE->getBase()->IgnoreParenImpCasts();\n\
  \    if (const auto *BDRE = dyn_cast<DeclRefExpr>(Base)) {\n      if (const auto\
  \ *VD = dyn_cast<VarDecl>(BDRE->getDecl()))\n        QT = VD->getType();\n    }\
  \ else if (const auto *BME = dyn_cast<MemberExpr>(Base)) {\n      if (const auto\
  \ *FD = dyn_cast<FieldDecl>(BME->getMemberDecl()))\n        QT = FD->getType();\n\
  \    }\n  } else if (const auto *UO = dyn_cast<UnaryOperator>(PE)) {\n    // Handle\
  \ &arr[0] or similar. Try to peel further.\n    if (UO->getOpcode() == UO_AddrOf\
  \ || UO->getOpcode() == UO_Deref) {\n      return getConstArrayBound(UO->getSubExpr(),\
  \ Bound, ACtx);\n    }\n  }\n\n  if (QT.isNull())\n    return false;\n\n  QT = QT.getCanonicalType();\n\
  \  if (const auto *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr())) {\n    Bound\
  \ = CAT->getSize();\n    return true;\n  }\n  return false;\n}\n\n// Get string\
  \ literal length (without the terminating null).\nbool SAGenTestChecker::getStringLiteralLen(const\
  \ Expr *E, llvm::APInt &LenOut) {\n  if (!E)\n    return false;\n  const Expr *PE\
  \ = E->IgnoreParenImpCasts();\n  if (const auto *SL = dyn_cast<StringLiteral>(PE))\
  \ {\n    // StringLiteral::getLength() does not include the terminating null.\n\
  \    LenOut = llvm::APInt(64, SL->getLength());\n    return true;\n  }\n  return\
  \ false;\n}\n\nvoid SAGenTestChecker::report(const CallEvent &Call, CheckerContext\
  \ &C,\n                              bool Definite, uint64_t DstSize) const {\n\
  \  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n\
  \  llvm::SmallString<128> Msg;\n  if (Definite) {\n    Msg = \"strcpy overflows\
  \ fixed-size buffer\";\n  } else {\n    Msg = \"strcpy into fixed-size buffer may\
  \ overflow; use strscpy(..., sizeof(dest))\";\n  }\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg.c_str(), N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  if (!isStrcpyLike(Call, C))\n    return;\n\n  if (Call.getNumArgs()\
  \ < 2)\n    return;\n\n  const Expr *DstE = Call.getArgExpr(0);\n  const Expr *SrcE\
  \ = Call.getArgExpr(1);\n  if (!DstE || !SrcE)\n    return;\n\n  const ASTContext\
  \ &ACtx = C.getASTContext();\n  llvm::APInt DstBound;\n  if (!getConstArrayBound(DstE,\
  \ DstBound, ACtx)) {\n    // Only warn when destination is a compile-time fixed-size\
  \ array.\n    return;\n  }\n\n  // If source is a string literal, we can determine\
  \ definiteness.\n  llvm::APInt SrcLen;\n  if (getStringLiteralLen(SrcE, SrcLen))\
  \ {\n    uint64_t Needs = SrcLen.getZExtValue() + 1; // include terminating null\n\
  \    uint64_t DstSz = DstBound.getZExtValue();\n    if (Needs > DstSz) {\n     \
  \ report(Call, C, /*Definite=*/true, DstSz);\n    }\n    // else: definitely fits,\
  \ no warning.\n    return;\n  }\n\n  // If source is a constant array, compare capacities\
  \ as a heuristic.\n  llvm::APInt SrcBound;\n  if (getConstArrayBound(SrcE, SrcBound,\
  \ ACtx)) {\n    uint64_t SrcCap = SrcBound.getZExtValue();\n    uint64_t DstSz =\
  \ DstBound.getZExtValue();\n    if (SrcCap > DstSz) {\n      report(Call, C, /*Definite=*/false,\
  \ DstSz);\n    }\n    // Else: source capacity <= dest, likely safe.\n    return;\n\
  \  }\n\n  // Unknown source length; strcpy is unbounded -> potential overflow.\n\
  \  report(Call, C, /*Definite=*/false, DstBound.getZExtValue());\n}\n\n} // end\
  \ anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unsafe strcpy into fixed-size buffers; suggest strscpy(..., sizeof(dest))\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
