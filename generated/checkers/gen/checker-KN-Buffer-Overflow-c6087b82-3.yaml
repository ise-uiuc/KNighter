_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: c6087b82a9146826564a55c5ca0164cac40348f5
commit_type: Buffer-Overflow
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/Expr.h\"\
  \n#include \"clang/AST/Type.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Program state customizations\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrToArrayMap,\
  \ const MemRegion*, const MemRegion*)\nREGISTER_MAP_WITH_PROGRAMSTATE(BoundedLenMap,\
  \ const MemRegion*, const MemRegion*)\n\nnamespace {\n\nclass SAGenTestChecker :\
  \ public Checker<check::PreCall, check::Bind> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"copy_from_user\
  \ length not capped\", \"Buffer Overflow\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      static bool isCharType(QualType T);\n      static bool isCharArray(const\
  \ VarDecl *VD);\n      static bool getArraySizeFromVarDecl(const VarDecl *VD, llvm::APInt\
  \ &Size);\n      bool getArrayInfoFromExpr(const Expr *E, CheckerContext &C,\n \
  \                               const VarDecl *&ArrayVD,\n                     \
  \           const MemRegion *&ArrayReg,\n                                llvm::APInt\
  \ &ArraySize) const;\n      bool lenExprUsesSizeofArray(const Expr *LenE, const\
  \ VarDecl *ArrayVD) const;\n};\n\nstatic bool isAssignmentStmtForRegion(const DeclStmt\
  \ *DS, const MemRegion *LHSReg, const LocationContext *LCtx) {\n  if (!DS || !LHSReg)\
  \ return false;\n  for (const Decl *D : DS->decls()) {\n    if (const auto *VD =\
  \ dyn_cast<VarDecl>(D)) {\n      const MemRegion *VR = LCtx->getAnalysisDeclContext()->getStorageRegionForDecl(VD,\
  \ LCtx);\n      if (!VR) continue;\n      VR = VR->getBaseRegion();\n      if (VR\
  \ == LHSReg) return true;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isCharType(QualType\
  \ T) {\n  T = T.getCanonicalType();\n  if (const auto *BT = T->getAs<BuiltinType>())\
  \ {\n    switch (BT->getKind()) {\n    case BuiltinType::Char_U:\n    case BuiltinType::Char_S:\n\
  \    case BuiltinType::SChar:\n    case BuiltinType::UChar:\n      return true;\n\
  \    default:\n      return false;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isCharArray(const\
  \ VarDecl *VD) {\n  if (!VD) return false;\n  QualType QT = VD->getType();\n  const\
  \ auto *ArrTy = dyn_cast<ConstantArrayType>(QT.getTypePtr());\n  if (!ArrTy) return\
  \ false;\n  return isCharType(ArrTy->getElementType());\n}\n\nbool SAGenTestChecker::getArraySizeFromVarDecl(const\
  \ VarDecl *VD, llvm::APInt &Size) {\n  if (!VD) return false;\n  if (const auto\
  \ *ArrTy = dyn_cast<ConstantArrayType>(VD->getType().getTypePtr())) {\n    Size\
  \ = ArrTy->getSize();\n    return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getArrayInfoFromExpr(const\
  \ Expr *E, CheckerContext &C,\n                                            const\
  \ VarDecl *&ArrayVD,\n                                            const MemRegion\
  \ *&ArrayReg,\n                                            llvm::APInt &ArraySize)\
  \ const {\n  ArrayVD = nullptr;\n  ArrayReg = nullptr;\n\n  if (!E) return false;\n\
  \n  // Direct array reference in expression\n  if (const auto *DRE = findSpecificTypeInChildren<DeclRefExpr>(E))\
  \ {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n      if (isCharArray(VD))\
  \ {\n        const MemRegion *MR = getMemRegionFromExpr(DRE, C);\n        if (!MR)\
  \ return false;\n        MR = MR->getBaseRegion();\n        llvm::APInt ASz;\n \
  \       if (!getArraySizeFromVarDecl(VD, ASz))\n          return false;\n      \
  \  ArrayVD = VD;\n        ArrayReg = MR;\n        ArraySize = ASz;\n        return\
  \ true;\n      }\n    }\n  }\n\n  // Fallback: pointer that aliases an array\n \
  \ if (const MemRegion *DestMR = getMemRegionFromExpr(E, C)) {\n    DestMR = DestMR->getBaseRegion();\n\
  \    ProgramStateRef State = C.getState();\n    if (const MemRegion *AliasedArray\
  \ = State->get<PtrToArrayMap>(DestMR)) {\n      const MemRegion *Base = AliasedArray->getBaseRegion();\n\
  \      if (const auto *VR = dyn_cast<VarRegion>(Base)) {\n        const VarDecl\
  \ *VD = VR->getDecl();\n        if (isCharArray(VD)) {\n          llvm::APInt ASz;\n\
  \          if (!getArraySizeFromVarDecl(VD, ASz))\n            return false;\n \
  \         ArrayVD = VD;\n          ArrayReg = Base;\n          ArraySize = ASz;\n\
  \          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n\
  bool SAGenTestChecker::lenExprUsesSizeofArray(const Expr *LenE, const VarDecl *ArrayVD)\
  \ const {\n  if (!LenE || !ArrayVD)\n    return false;\n  const auto *UETT = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(LenE);\n\
  \  if (!UETT)\n    return false;\n  if (UETT->getKind() != UETT_SizeOf)\n    return\
  \ false;\n\n  if (!UETT->isArgumentType()) {\n    const Expr *ArgE = UETT->getArgumentExpr();\n\
  \    if (!ArgE) return false;\n    if (const auto *ADRE = findSpecificTypeInChildren<DeclRefExpr>(ArgE))\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(ADRE->getDecl())) {\n        return\
  \ VD == ArrayVD;\n      }\n    }\n  }\n  // If it's a type argument, we don't try\
  \ to match (uncommon for this pattern).\n  return false;\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (LHSReg)\n\
  \    LHSReg = LHSReg->getBaseRegion();\n\n  const Expr *RHSExpr = nullptr;\n\n \
  \ if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S)) {\n    if (BO->isAssignmentOp())\n\
  \      RHSExpr = BO->getRHS();\n  } else if (const auto *DS = dyn_cast_or_null<DeclStmt>(S))\
  \ {\n    // Find the initializer that corresponds to this binding's LHS region.\n\
  \    if (LHSReg && isAssignmentStmtForRegion(DS, LHSReg, C.getLocationContext()))\
  \ {\n      for (const Decl *D : DS->decls()) {\n        if (const auto *VD = dyn_cast<VarDecl>(D))\
  \ {\n          if (VD->hasInit()) {\n            RHSExpr = VD->getInit();\n    \
  \        break;\n          }\n        }\n      }\n    }\n  }\n\n  if (RHSExpr &&\
  \ LHSReg) {\n    // Goal A: Pointer-to-array alias tracking.\n    if (const auto\
  \ *DRE = findSpecificTypeInChildren<DeclRefExpr>(RHSExpr)) {\n      if (const auto\
  \ *ArrVD = dyn_cast<VarDecl>(DRE->getDecl())) {\n        if (isCharArray(ArrVD))\
  \ {\n          const MemRegion *ArrReg = getMemRegionFromExpr(DRE, C);\n       \
  \   if (ArrReg) {\n            ArrReg = ArrReg->getBaseRegion();\n            State\
  \ = State->set<PtrToArrayMap>(LHSReg, ArrReg);\n          }\n        }\n      }\n\
  \    }\n\n    // Goal B: Bounded length variable tracking via min(..., sizeof(array)-1).\n\
  \    if (ExprHasName(RHSExpr, \"min\", C) || ExprHasName(RHSExpr, \"min_t\", C))\
  \ {\n      const auto *UETT = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(RHSExpr);\n\
  \      if (UETT && UETT->getKind() == UETT_SizeOf && !UETT->isArgumentType()) {\n\
  \        const Expr *ArgE = UETT->getArgumentExpr();\n        if (const auto *ADRE\
  \ = findSpecificTypeInChildren<DeclRefExpr>(ArgE)) {\n          if (const auto *AVD\
  \ = dyn_cast<VarDecl>(ADRE->getDecl())) {\n            if (isCharArray(AVD)) {\n\
  \              const MemRegion *ArrayReg = getMemRegionFromExpr(ADRE, C);\n    \
  \          if (ArrayReg) {\n                ArrayReg = ArrayReg->getBaseRegion();\n\
  \                State = State->set<BoundedLenMap>(ArrayReg, LHSReg);\n        \
  \      }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (State\
  \ != C.getState())\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE || !ExprHasName(OE, \"copy_from_user\", C))\n    return;\n\n  if (Call.getNumArgs()\
  \ < 3)\n    return;\n\n  const Expr *DstE = Call.getArgExpr(0);\n  const Expr *LenE\
  \ = Call.getArgExpr(2);\n  if (!DstE || !LenE)\n    return;\n\n  const VarDecl *ArrayVD\
  \ = nullptr;\n  const MemRegion *ArrayReg = nullptr;\n  llvm::APInt ArraySize(32,\
  \ 0);\n\n  // Determine if destination is a fixed-size char array or pointer alias\
  \ to it.\n  if (!getArrayInfoFromExpr(DstE, C, ArrayVD, ArrayReg, ArraySize))\n\
  \    return; // Can't determine a fixed-size destination array.\n\n  // If length\
  \ is a constant, compare it with array size.\n  llvm::APSInt LenVal;\n  if (EvaluateExprToInt(LenVal,\
  \ LenE, C)) {\n    uint64_t LenU = LenVal.getLimitedValue();\n    uint64_t ArrU\
  \ = ArraySize.getLimitedValue();\n    if (LenU > ArrU) {\n      ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n      if (!N) return;\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"copy_from_user length not capped to destination buffer size\"\
  , N);\n      R->addRange(OE->getSourceRange());\n      C.emitReport(std::move(R));\n\
  \    }\n    return; // Constant and <= size: considered safe.\n  }\n\n  // Check\
  \ if LenE is a bounded length variable previously mapped for this array.\n  ProgramStateRef\
  \ State = C.getState();\n  const MemRegion *LenMR = getMemRegionFromExpr(LenE, C);\n\
  \  if (LenMR) {\n    LenMR = LenMR->getBaseRegion();\n    const MemRegion *MappedLen\
  \ = State->get<BoundedLenMap>(ArrayReg);\n    if (MappedLen && MappedLen == LenMR)\
  \ {\n      // Safe: using a bounded length variable for this array.\n      return;\n\
  \    }\n  }\n\n  // Check inline sizeof(array) presence in length expression.\n\
  \  if (lenExprUsesSizeofArray(LenE, ArrayVD)) {\n    // Safe: length expression\
  \ references sizeof(the same array).\n    return;\n  }\n\n  // Not provably bounded\
  \ -> report.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\
  \  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"copy_from_user\
  \ length not capped to destination buffer size\", N);\n  R->addRange(OE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects copy_from_user with unbounded\
  \ length for fixed-size buffers\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nscsi: lpfc: Prevent lpfc_debugfs_lockstat_write()\
  \ buffer overflow\n\nA static code analysis tool flagged the possibility of buffer\
  \ overflow when\nusing copy_from_user() for a debugfs entry.\n\nCurrently, it is\
  \ possible that copy_from_user() copies more bytes than what\nwould fit in the mybuf\
  \ char array.  Add a min() restriction check between\nsizeof(mybuf) - 1 and nbytes\
  \ passed from the userspace buffer to protect\nagainst buffer overflow.\n\nLink:\
  \ https://lore.kernel.org/r/20230301231626.9621-2-justintee8345@gmail.com\nSigned-off-by:\
  \ Justin Tee <justin.tee@broadcom.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>\n\
  \n## Buggy Code\n\n```c\n// Function: lpfc_debugfs_lockstat_write in drivers/scsi/lpfc/lpfc_debugfs.c\n\
  static ssize_t\nlpfc_debugfs_lockstat_write(struct file *file, const char __user\
  \ *buf,\n\t\t\t    size_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug =\
  \ file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\
  \tstruct lpfc_sli4_hdw_queue *qp;\n\tchar mybuf[64];\n\tchar *pbuf;\n\tint i;\n\n\
  \tmemset(mybuf, 0, sizeof(mybuf));\n\n\tif (copy_from_user(mybuf, buf, nbytes))\n\
  \t\treturn -EFAULT;\n\tpbuf = &mybuf[0];\n\n\tif ((strncmp(pbuf, \"reset\", strlen(\"\
  reset\")) == 0) ||\n\t    (strncmp(pbuf, \"zero\", strlen(\"zero\")) == 0)) {\n\t\
  \tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\t\tqp = &phba->sli4_hba.hdwq[i];\n\
  \t\t\tqp->lock_conflict.alloc_xri_get = 0;\n\t\t\tqp->lock_conflict.alloc_xri_put\
  \ = 0;\n\t\t\tqp->lock_conflict.free_xri = 0;\n\t\t\tqp->lock_conflict.wq_access\
  \ = 0;\n\t\t\tqp->lock_conflict.alloc_pvt_pool = 0;\n\t\t\tqp->lock_conflict.mv_from_pvt_pool\
  \ = 0;\n\t\t\tqp->lock_conflict.mv_to_pub_pool = 0;\n\t\t\tqp->lock_conflict.mv_to_pvt_pool\
  \ = 0;\n\t\t\tqp->lock_conflict.free_pvt_pool = 0;\n\t\t\tqp->lock_conflict.free_pub_pool\
  \ = 0;\n\t\t\tqp->lock_conflict.wq_access = 0;\n\t\t}\n\t}\n\treturn nbytes;\n}\n\
  ```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/scsi/lpfc/lpfc_debugfs.c\
  \ b/drivers/scsi/lpfc/lpfc_debugfs.c\nindex f5252e45a48a..3e365e5e194a 100644\n\
  --- a/drivers/scsi/lpfc/lpfc_debugfs.c\n+++ b/drivers/scsi/lpfc/lpfc_debugfs.c\n\
  @@ -2157,10 +2157,13 @@ lpfc_debugfs_lockstat_write(struct file *file, const char\
  \ __user *buf,\n \tchar mybuf[64];\n \tchar *pbuf;\n \tint i;\n+\tsize_t bsize;\n\
  \ \n \tmemset(mybuf, 0, sizeof(mybuf));\n \n-\tif (copy_from_user(mybuf, buf, nbytes))\n\
  +\tbsize = min(nbytes, (sizeof(mybuf) - 1));\n+\n+\tif (copy_from_user(mybuf, buf,\
  \ bsize))\n \t\treturn -EFAULT;\n \tpbuf = &mybuf[0];\n \n@@ -2181,7 +2184,7 @@\
  \ lpfc_debugfs_lockstat_write(struct file *file, const char __user *buf,\n \t\t\t\
  qp->lock_conflict.wq_access = 0;\n \t\t}\n \t}\n-\treturn nbytes;\n+\treturn bsize;\n\
  \ }\n #endif\n \n```\n"
pattern: "## Bug Pattern\n\nCopying a user-provided length into a fixed-size kernel\
  \ buffer without bounding the copy to the buffer size, i.e., using copy_from_user(buf,\
  \ user, nbytes) where nbytes can exceed sizeof(buf). This occurs in debugfs write\
  \ handlers that parse string commands into a small stack buffer and do not cap nbytes\
  \ (and leave no room for a terminating NUL), leading to potential stack buffer overflow.\n\
  \nExample pattern:\nchar buf[64];\n/* nbytes is user-controlled; no size cap ->\
  \ overflow risk */\nif (copy_from_user(buf, user_ptr, nbytes))\n    return -EFAULT;\n\
  /* then treat buf as a string (e.g., strncmp) without guaranteed NUL */"
plan: "1) Program state customization\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(PtrToArrayMap,\
  \ const MemRegion*, const MemRegion*)\n  - Maps a pointer variable\u2019s region\
  \ (e.g., pbuf) to the MemRegion of the underlying fixed-size array (e.g., mybuf).\
  \ This lets us recover the actual destination array when copy_from_user() is called\
  \ with a pointer alias.\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(BoundedLenMap, const\
  \ MemRegion*, const MemRegion*)\n  - Maps an array\u2019s MemRegion to a length\
  \ variable\u2019s MemRegion (e.g., bsize) that is known to be bounded by sizeof(array)\
  \ (ideally via min(..., sizeof(array) - 1)). This suppresses false positives when\
  \ the code computes a bounded length first and then passes that bounded variable\
  \ to copy_from_user().\n\n\n2) Callback selection and how to implement them\n\n\
  - checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const\n  - Goal\
  \ A: Track pointer-to-array aliases (PtrToArrayMap).\n    - If S is an assignment\
  \ or init (BinaryOperator \u2018=\u2019 or DeclStmt with initializer), analyze RHS.\n\
  \    - Use findSpecificTypeInChildren<DeclRefExpr>(RHSExpr) to find a DeclRefExpr.\n\
  \    - If the DeclRefExpr refers to a VarDecl whose type is ConstantArrayType (i.e.,\
  \ a fixed-size array), then:\n      - Get the array MemRegion with getMemRegionFromExpr\
  \ on that DeclRefExpr.\n      - Get the LHS MemRegion (pointer variable) from Loc.getAsRegion().\n\
  \      - If both exist and the array element type is a character type (char/signed\
  \ char/unsigned char), record PtrToArrayMap[LHSRegion] = ArrayRegion in the state.\n\
  \        - Heuristic for character type: check the ConstantArrayType\u2019s element\
  \ type to be Char/SChar/UChar.\n\n  - Goal B: Track \u201Cbounded length\u201D variables\
  \ (BoundedLenMap).\n    - For the same assignment/init, inspect RHS to see if it\
  \ looks like a min(...) involving sizeof(the same array).\n      - Detect presence\
  \ of sizeof(array) in RHS:\n        - Use findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(RHSExpr)\
  \ and see if any is UETT_SizeOf, and its argument is a DeclRefExpr to a ConstantArrayType\
  \ VarDecl (this is the target array).\n      - Reduce false positives by also checking\
  \ if ExprHasName(RHSExpr, \"min\") or ExprHasName(RHSExpr, \"min_t\") (kernel min\
  \ macros). If both \u201Csizeof(array)\u201D and \u201Cmin/min_t\u201D are found\
  \ in RHS, assume RHS computes a bounded length for that array.\n      - If matched:\n\
  \        - Get LHS MemRegion from Loc.getAsRegion() (the length variable, e.g.,\
  \ bsize).\n        - Get the array MemRegion with getMemRegionFromExpr on the DeclRefExpr\
  \ found in the sizeof() argument.\n        - Record BoundedLenMap[ArrayRegion] =\
  \ LHSRegion.\n\n- checkPreCall(const CallEvent &Call, CheckerContext &C) const\n\
  \  - Identify calls to copy_from_user:\n    - If Call.getCalleeIdentifier() name\
  \ equals \"copy_from_user\", proceed.\n  - Extract and analyze arguments:\n    -\
  \ Arg0 (destination), Arg1 (user src), Arg2 (length).\n  - Determine the fixed-size\
  \ array for Arg0:\n    - First try to find a DeclRefExpr to an array in Arg0 with\
  \ findSpecificTypeInChildren<DeclRefExpr>(Arg0). If found and the VarDecl type is\
  \ ConstantArrayType with character element type:\n      - Use getArraySizeFromExpr(ArraySize,\
  \ DeclRefExpr) to retrieve the size.\n      - Also get the array MemRegion via getMemRegionFromExpr(DeclRefExpr,\
  \ C).\n    - If no array DRE is found, try pointer-to-array alias:\n      - Get\
  \ Arg0 MemRegion via getMemRegionFromExpr(Arg0, C). If it maps in PtrToArrayMap\
  \ to an ArrayRegion, use that ArrayRegion.\n      - From that array\u2019s DeclRefExpr\
  \ (child of the defining statement if available) or directly from the VarDecl type,\
  \ retrieve the ConstantArrayType size (use getArraySizeFromExpr if you can still\
  \ obtain a DeclRefExpr; otherwise use the VarDecl\u2019s ConstantArrayType).\n \
  \   - If we cannot determine a fixed-size array for the destination, bail (no report).\n\
  \n  - Decide whether Arg2 (length) is safely bounded:\n    - Case 1: Constant length\n\
  \      - Try EvaluateExprToInt(Val, Arg2, C).\n      - If constant and Val <= ArraySize,\
  \ consider safe; if Val > ArraySize, report bug.\n    - Case 2: Bounded length variable\n\
  \      - Get Arg2 MemRegion via getMemRegionFromExpr(Arg2, C). If it exists and\
  \ equals BoundedLenMap[ArrayRegion], consider safe.\n    - Case 3: Inline sizeof(array)\
  \ bound\n      - If Arg2 contains a sizeof() referencing the same discovered array\
  \ (findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(Arg2) + check DeclRefExpr\
  \ to the same array), consider safe.\n    - Otherwise: length is not provably bounded\
  \ -> report bug.\n\n  - Reporting:\n    - Create a non-fatal error node (generateNonFatalErrorNode)\
  \ and emit a PathSensitiveBugReport with a short message, e.g.:\n      - \"copy_from_user\
  \ length not capped to destination buffer size\"\n    - Optionally add a note on\
  \ the destination buffer name and size to the report path.\n\n- Optional helper\
  \ logic (private utility methods inside the checker)\n  - isCharArray(const VarDecl\
  \ *VD):\n    - Returns true if VD->getType() is ConstantArrayType with element type\
  \ char/signed char/unsigned char.\n  - getArrayInfoFromExpr(const Expr *E, CheckerContext\
  \ &C, const VarDecl *&ArrayVD, const MemRegion *&ArrayReg, llvm::APInt &ArraySize):\n\
  \    - Tries to extract the underlying array from E (direct or via PtrToArrayMap),\
  \ its VarDecl, MemRegion, and constant size using getArraySizeFromExpr. Uses findSpecificTypeInChildren<DeclRefExpr>(E)\
  \ and getMemRegionFromExpr, plus PtrToArrayMap lookup in fallback.\n  - lenExprUsesSizeofArray(const\
  \ Expr *Len, const VarDecl *ArrayVD):\n    - Scans for UnaryExprOrTypeTraitExpr\
  \ of kind sizeof, and checks if any argument refers to ArrayVD.\n  - sameArrayVar(const\
  \ VarDecl *A, const VarDecl *B):\n    - Compare VarDecl pointers.\n\nNotes and heuristics\n\
  \n- This checker is path-sensitive enough without tracking function signatures;\
  \ focusing on copy_from_user() with destination as a local fixed-size char array\
  \ significantly reduces false positives while catching the intended kernel pattern.\n\
  - The BoundedLenMap requires both sizeof(array) and \u201Cmin/min_t\u201D text in\
  \ RHS when learning a bounded length variable, to avoid incorrectly assuming safety\
  \ for arbitrary expressions that mention sizeof(array).\n- Alias tracking via PtrToArrayMap\
  \ covers common \"char mybuf[64]; char *pbuf = &mybuf[0]; copy_from_user(pbuf, ...)\"\
  \ patterns.\n- You do not need to implement additional callbacks (BranchCondition,\
  \ Location, etc.) for this checker.\n- Keep the bug message short and clear as required."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/Expr.h\"\
  \n#include \"clang/AST/Type.h\"\n#include <memory>\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// Program state customizations\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrToArrayMap,\
  \ const MemRegion*, const MemRegion*)\nREGISTER_MAP_WITH_PROGRAMSTATE(BoundedLenMap,\
  \ const MemRegion*, const MemRegion*)\n\nnamespace {\n\nclass SAGenTestChecker :\
  \ public Checker<check::PreCall, check::Bind> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"copy_from_user\
  \ length not capped\", \"Buffer Overflow\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      static bool isCharType(QualType T);\n      static bool isCharArray(const\
  \ VarDecl *VD);\n      static bool getArraySizeFromVarDecl(const VarDecl *VD, llvm::APInt\
  \ &Size);\n      bool getArrayInfoFromExpr(const Expr *E, CheckerContext &C,\n \
  \                               const VarDecl *&ArrayVD,\n                     \
  \           const MemRegion *&ArrayReg,\n                                llvm::APInt\
  \ &ArraySize) const;\n      bool lenExprUsesSizeofArray(const Expr *LenE, const\
  \ VarDecl *ArrayVD) const;\n};\n\nstatic bool isAssignmentStmtForRegion(const DeclStmt\
  \ *DS, const MemRegion *LHSReg,\n                                      const LocationContext\
  \ *LCtx, const CheckerContext &C) {\n  if (!DS || !LHSReg) return false;\n  MemRegionManager\
  \ &MRMgr = C.getState()->getStateManager().getRegionManager();\n  for (const Decl\
  \ *D : DS->decls()) {\n    if (const auto *VD = dyn_cast<VarDecl>(D)) {\n      const\
  \ MemRegion *VR = MRMgr.getVarRegion(VD, LCtx);\n      if (!VR) continue;\n    \
  \  VR = VR->getBaseRegion();\n      if (VR == LHSReg) return true;\n    }\n  }\n\
  \  return false;\n}\n\nbool SAGenTestChecker::isCharType(QualType T) {\n  T = T.getCanonicalType();\n\
  \  if (const auto *BT = T->getAs<BuiltinType>()) {\n    switch (BT->getKind()) {\n\
  \    case BuiltinType::Char_U:\n    case BuiltinType::Char_S:\n    case BuiltinType::SChar:\n\
  \    case BuiltinType::UChar:\n      return true;\n    default:\n      return false;\n\
  \    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isCharArray(const VarDecl\
  \ *VD) {\n  if (!VD) return false;\n  QualType QT = VD->getType();\n  const auto\
  \ *ArrTy = dyn_cast<ConstantArrayType>(QT.getTypePtr());\n  if (!ArrTy) return false;\n\
  \  return isCharType(ArrTy->getElementType());\n}\n\nbool SAGenTestChecker::getArraySizeFromVarDecl(const\
  \ VarDecl *VD, llvm::APInt &Size) {\n  if (!VD) return false;\n  if (const auto\
  \ *ArrTy = dyn_cast<ConstantArrayType>(VD->getType().getTypePtr())) {\n    Size\
  \ = ArrTy->getSize();\n    return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getArrayInfoFromExpr(const\
  \ Expr *E, CheckerContext &C,\n                                            const\
  \ VarDecl *&ArrayVD,\n                                            const MemRegion\
  \ *&ArrayReg,\n                                            llvm::APInt &ArraySize)\
  \ const {\n  ArrayVD = nullptr;\n  ArrayReg = nullptr;\n\n  if (!E) return false;\n\
  \n  // Direct array reference in expression\n  if (const auto *DRE = findSpecificTypeInChildren<DeclRefExpr>(E))\
  \ {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n      if (isCharArray(VD))\
  \ {\n        const MemRegion *MR = getMemRegionFromExpr(DRE, C);\n        if (!MR)\
  \ return false;\n        MR = MR->getBaseRegion();\n        llvm::APInt ASz;\n \
  \       if (!getArraySizeFromVarDecl(VD, ASz))\n          return false;\n      \
  \  ArrayVD = VD;\n        ArrayReg = MR;\n        ArraySize = ASz;\n        return\
  \ true;\n      }\n    }\n  }\n\n  // Fallback: pointer that aliases an array\n \
  \ if (const MemRegion *DestMR = getMemRegionFromExpr(E, C)) {\n    DestMR = DestMR->getBaseRegion();\n\
  \    ProgramStateRef State = C.getState();\n    if (const MemRegion * const *AliasedArray\
  \ = State->get<PtrToArrayMap>(DestMR)) {\n      const MemRegion *Base = (*AliasedArray)->getBaseRegion();\n\
  \      if (const auto *VR = dyn_cast<VarRegion>(Base)) {\n        const VarDecl\
  \ *VD = VR->getDecl();\n        if (isCharArray(VD)) {\n          llvm::APInt ASz;\n\
  \          if (!getArraySizeFromVarDecl(VD, ASz))\n            return false;\n \
  \         ArrayVD = VD;\n          ArrayReg = Base;\n          ArraySize = ASz;\n\
  \          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n\
  bool SAGenTestChecker::lenExprUsesSizeofArray(const Expr *LenE, const VarDecl *ArrayVD)\
  \ const {\n  if (!LenE || !ArrayVD)\n    return false;\n  const auto *UETT = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(LenE);\n\
  \  if (!UETT)\n    return false;\n  if (UETT->getKind() != UETT_SizeOf)\n    return\
  \ false;\n\n  if (!UETT->isArgumentType()) {\n    const Expr *ArgE = UETT->getArgumentExpr();\n\
  \    if (!ArgE) return false;\n    if (const auto *ADRE = findSpecificTypeInChildren<DeclRefExpr>(ArgE))\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(ADRE->getDecl())) {\n        return\
  \ VD == ArrayVD;\n      }\n    }\n  }\n  // If it's a type argument, we don't try\
  \ to match (uncommon for this pattern).\n  return false;\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (LHSReg)\n\
  \    LHSReg = LHSReg->getBaseRegion();\n\n  const Expr *RHSExpr = nullptr;\n\n \
  \ if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S)) {\n    if (BO->isAssignmentOp())\n\
  \      RHSExpr = BO->getRHS();\n  } else if (const auto *DS = dyn_cast_or_null<DeclStmt>(S))\
  \ {\n    // Find the initializer that corresponds to this binding's LHS region.\n\
  \    if (LHSReg && isAssignmentStmtForRegion(DS, LHSReg, C.getLocationContext(),\
  \ C)) {\n      for (const Decl *D : DS->decls()) {\n        if (const auto *VD =\
  \ dyn_cast<VarDecl>(D)) {\n          if (VD->hasInit()) {\n            RHSExpr =\
  \ VD->getInit();\n            break;\n          }\n        }\n      }\n    }\n \
  \ }\n\n  if (RHSExpr && LHSReg) {\n    // Goal A: Pointer-to-array alias tracking.\n\
  \    if (const auto *DRE = findSpecificTypeInChildren<DeclRefExpr>(RHSExpr)) {\n\
  \      if (const auto *ArrVD = dyn_cast<VarDecl>(DRE->getDecl())) {\n        if\
  \ (isCharArray(ArrVD)) {\n          const MemRegion *ArrReg = getMemRegionFromExpr(DRE,\
  \ C);\n          if (ArrReg) {\n            ArrReg = ArrReg->getBaseRegion();\n\
  \            State = State->set<PtrToArrayMap>(LHSReg, ArrReg);\n          }\n \
  \       }\n      }\n    }\n\n    // Goal B: Bounded length variable tracking via\
  \ min(..., sizeof(array)-1).\n    if (ExprHasName(RHSExpr, \"min\", C) || ExprHasName(RHSExpr,\
  \ \"min_t\", C)) {\n      const auto *UETT = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(RHSExpr);\n\
  \      if (UETT && UETT->getKind() == UETT_SizeOf && !UETT->isArgumentType()) {\n\
  \        const Expr *ArgE = UETT->getArgumentExpr();\n        if (const auto *ADRE\
  \ = findSpecificTypeInChildren<DeclRefExpr>(ArgE)) {\n          if (const auto *AVD\
  \ = dyn_cast<VarDecl>(ADRE->getDecl())) {\n            if (isCharArray(AVD)) {\n\
  \              const MemRegion *ArrayReg = getMemRegionFromExpr(ADRE, C);\n    \
  \          if (ArrayReg) {\n                ArrayReg = ArrayReg->getBaseRegion();\n\
  \                State = State->set<BoundedLenMap>(ArrayReg, LHSReg);\n        \
  \      }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (State\
  \ != C.getState())\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE || !ExprHasName(OE, \"copy_from_user\", C))\n    return;\n\n  if (Call.getNumArgs()\
  \ < 3)\n    return;\n\n  const Expr *DstE = Call.getArgExpr(0);\n  const Expr *LenE\
  \ = Call.getArgExpr(2);\n  if (!DstE || !LenE)\n    return;\n\n  const VarDecl *ArrayVD\
  \ = nullptr;\n  const MemRegion *ArrayReg = nullptr;\n  llvm::APInt ArraySize(32,\
  \ 0);\n\n  // Determine if destination is a fixed-size char array or pointer alias\
  \ to it.\n  if (!getArrayInfoFromExpr(DstE, C, ArrayVD, ArrayReg, ArraySize))\n\
  \    return; // Can't determine a fixed-size destination array.\n\n  // If length\
  \ is a constant, compare it with array size.\n  llvm::APSInt LenVal;\n  if (EvaluateExprToInt(LenVal,\
  \ LenE, C)) {\n    uint64_t LenU = LenVal.getLimitedValue();\n    uint64_t ArrU\
  \ = ArraySize.getLimitedValue();\n    if (LenU > ArrU) {\n      ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n      if (!N) return;\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"copy_from_user length not capped to destination buffer size\"\
  , N);\n      R->addRange(OE->getSourceRange());\n      C.emitReport(std::move(R));\n\
  \    }\n    return; // Constant and <= size: considered safe.\n  }\n\n  // Check\
  \ if LenE is a bounded length variable previously mapped for this array.\n  ProgramStateRef\
  \ State = C.getState();\n  const MemRegion *LenMR = getMemRegionFromExpr(LenE, C);\n\
  \  if (LenMR) {\n    LenMR = LenMR->getBaseRegion();\n    const MemRegion * const\
  \ *MappedLen = State->get<BoundedLenMap>(ArrayReg);\n    if (MappedLen && *MappedLen\
  \ == LenMR) {\n      // Safe: using a bounded length variable for this array.\n\
  \      return;\n    }\n  }\n\n  // Check inline sizeof(array) presence in length\
  \ expression.\n  if (lenExprUsesSizeofArray(LenE, ArrayVD)) {\n    // Safe: length\
  \ expression references sizeof(the same array).\n    return;\n  }\n\n  // Not provably\
  \ bounded -> report.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\
  \ return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"copy_from_user\
  \ length not capped to destination buffer size\", N);\n  R->addRange(OE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects copy_from_user with unbounded\
  \ length for fixed-size buffers\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
