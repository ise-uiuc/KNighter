_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: b58b1b883b9b702e25204dbe2b221eecc8ecd159
commit_type: Buffer-Overflow
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/Stmt.h\"\
  \n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/AST/Decl.h\"\n#include \"llvm/ADT/APSInt.h\"\
  \n#include <utility>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// Map a temporary variable (e.g., \"shorten\") to the iov_iter MemRegion\
  \ used to compute it.\nREGISTER_MAP_WITH_PROGRAMSTATE(ShortenToIterRegion, const\
  \ VarDecl*, const MemRegion*)\n\nnamespace {\n\n// Helper: is IntegerLiteral zero\n\
  static bool isIntegerLiteralZero(const Expr *E) {\n  if (!E) return false;\n  E\
  \ = E->IgnoreParenImpCasts();\n  if (const auto *IL = dyn_cast<IntegerLiteral>(E))\n\
  \    return IL->getValue() == 0;\n  return false;\n}\n\n// Helper: does expression\
  \ look like round-up/align operation (by name)\nstatic bool isRoundUpLikeExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return false;\n  return ExprHasName(E,\
  \ \"round_up\", C) || ExprHasName(E, \"ALIGN\", C) ||\n         ExprHasName(E, \"\
  roundup\", C);\n}\n\n// Helper: find a CallExpr to iov_iter_count(...) inside E\
  \ and extract the iter MemRegion base.\nstatic bool extractIterRegionFromIovIterCount(const\
  \ Expr *E,\n                                              CheckerContext &C,\n \
  \                                             const MemRegion *&OutIterBase) {\n\
  \  OutIterBase = nullptr;\n  if (!E) return false;\n\n  const CallExpr *Call = nullptr;\n\
  \  // If E itself is a call, prefer that; else search in children.\n  if (const\
  \ auto *CE = dyn_cast<CallExpr>(E->IgnoreParenImpCasts()))\n    Call = CE;\n  else\n\
  \    Call = findSpecificTypeInChildren<CallExpr>(E);\n\n  if (!Call) return false;\n\
  \  // Robust name check by source text\n  if (!ExprHasName(Call, \"iov_iter_count\"\
  , C))\n    return false;\n\n  if (Call->getNumArgs() < 1) return false;\n  const\
  \ Expr *Arg0 = Call->getArg(0);\n  if (!Arg0) return false;\n\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(Arg0, C);\n  if (!MR) return false;\n  MR = MR->getBaseRegion();\n\
  \  if (!MR) return false;\n\n  OutIterBase = MR;\n  return true;\n}\n\n// Helper:\
  \ check whether RHS is an inline pattern \"iov_iter_count(iter) - round_up(...)\"\
  \n// and that the iter base equals IterBase.\nstatic bool isInlineShortenSubPattern(const\
  \ Expr *RHS, CheckerContext &C,\n                                      const MemRegion\
  \ *IterBase) {\n  if (!RHS || !IterBase) return false;\n  const auto *BO = dyn_cast<BinaryOperator>(RHS->IgnoreParenImpCasts());\n\
  \  if (!BO || BO->getOpcode() != BO_Sub) return false;\n\n  const Expr *LHS = BO->getLHS();\n\
  \  const Expr *R = BO->getRHS();\n  if (!LHS || !R) return false;\n\n  const MemRegion\
  \ *FoundIterBase = nullptr;\n  if (!extractIterRegionFromIovIterCount(LHS, C, FoundIterBase))\n\
  \    return false;\n  if (FoundIterBase != IterBase)\n    return false;\n\n  //\
  \ RHS of subtraction should be round-up-like\n  if (!isRoundUpLikeExpr(R, C))\n\
  \    return false;\n\n  return true;\n}\n\n// Helper: If E is a DeclRefExpr to a\
  \ VarDecl recorded as a shorten-like temp,\n// and its iter-region equals IterBase.\
  \ Optionally return the VarDecl via OutVD.\nstatic bool isRecordedShortenDeclRefForIter(const\
  \ Expr *E, CheckerContext &C,\n                                            const\
  \ MemRegion *IterBase,\n                                            const VarDecl\
  \ *&OutVD) {\n  OutVD = nullptr;\n  if (!E || !IterBase) return false;\n\n  const\
  \ auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenImpCasts());\n  if (!DRE) return\
  \ false;\n\n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD) return\
  \ false;\n\n  ProgramStateRef State = C.getState();\n  const MemRegion *Recorded\
  \ = State->get<ShortenToIterRegion>(VD);\n  if (!Recorded) return false;\n\n  if\
  \ (Recorded->getBaseRegion() == IterBase) {\n    OutVD = VD;\n    return true;\n\
  \  }\n  return false;\n}\n\n// Helper: get iter base MemRegion from MemberExpr that\
  \ accesses \".count\".\nstatic const MemRegion *getIterBaseFromCountMember(const\
  \ Expr *LHS, CheckerContext &C) {\n  if (!LHS) return nullptr;\n  const auto *ME\
  \ = dyn_cast<MemberExpr>(LHS->IgnoreParenImpCasts());\n  if (!ME) return nullptr;\n\
  \n  const ValueDecl *VD = ME->getMemberDecl();\n  if (!VD) return nullptr;\n\n \
  \ if (VD->getName() != \"count\")\n    return nullptr;\n\n  const Expr *BaseE =\
  \ ME->getBase();\n  if (!BaseE) return nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(BaseE,\
  \ C);\n  if (!MR) return nullptr;\n\n  MR = MR->getBaseRegion();\n  return MR;\n\
  }\n\n// Helper: is expression a MemberExpr \".count\" for the given iter base?\n\
  static bool isCountMemberForIterBase(const Expr *E, CheckerContext &C,\n       \
  \                              const MemRegion *IterBase) {\n  const MemRegion *MR\
  \ = getIterBaseFromCountMember(E, C);\n  return MR && MR == IterBase;\n}\n\n// Helper:\
  \ does Cond look like \"ShortenVD >= iter->count\" (or >) where iter base matches?\n\
  static bool isClampConditionForShorten(const Expr *Cond, CheckerContext &C,\n  \
  \                                     const VarDecl *ShortenVD,\n              \
  \                         const MemRegion *IterBase) {\n  if (!Cond || !ShortenVD\
  \ || !IterBase) return false;\n  Cond = Cond->IgnoreParenImpCasts();\n\n  const\
  \ auto *BO = dyn_cast<BinaryOperator>(Cond);\n  if (!BO) return false;\n  BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n  if (!(Op == BO_GE || Op == BO_GT))\n    return false;\n\
  \n  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS =\
  \ BO->getRHS()->IgnoreParenImpCasts();\n\n  auto IsShorten = [&](const Expr *E)\
  \ -> bool {\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(E))\n      return DRE->getDecl()\
  \ == ShortenVD;\n    return false;\n  };\n\n  // Two orders: shorten >= iter->count\
  \ OR iter->count <= shorten (normalized as above)\n  if (IsShorten(LHS) && isCountMemberForIterBase(RHS,\
  \ C, IterBase))\n    return true;\n  if (IsShorten(RHS) && isCountMemberForIterBase(LHS,\
  \ C, IterBase))\n    return true;\n\n  return false;\n}\n\n// Helper: recursively\
  \ search in S for an assignment \"ShortenVD = 0;\"\nstatic bool containsAssignZeroToVar(const\
  \ Stmt *S, const VarDecl *ShortenVD) {\n  if (!S || !ShortenVD) return false;\n\n\
  \  if (const auto *BO = dyn_cast<BinaryOperator>(S)) {\n    if (BO->getOpcode()\
  \ == BO_Assign) {\n      const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n      const auto *LDRE\
  \ = dyn_cast<DeclRefExpr>(L);\n      if (LDRE && LDRE->getDecl() == ShortenVD &&\
  \ isIntegerLiteralZero(R))\n        return true;\n    }\n  }\n\n  for (const Stmt\
  \ *Child : S->children()) {\n    if (Child && containsAssignZeroToVar(Child, ShortenVD))\n\
  \      return true;\n  }\n  return false;\n}\n\n// Helper: Look within the same\
  \ enclosing CompoundStmt for a nearby guard:\n// if (shorten >= iter->count) shorten\
  \ = 0;\nstatic bool hasClampGuardNear(const Stmt *Anchor,\n                    \
  \          const VarDecl *ShortenVD,\n                              const MemRegion\
  \ *IterBase,\n                              CheckerContext &C) {\n  if (!Anchor\
  \ || !ShortenVD || !IterBase) return false;\n\n  const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(Anchor,\
  \ C);\n  if (!CS) return false;\n\n  // Find the index of the statement that contains\
  \ Anchor\n  unsigned Idx = 0;\n  int AnchorIdx = -1;\n\n  for (const Stmt *S : CS->body())\
  \ {\n    bool Found = false;\n\n    // Try to see if this statement contains the\
  \ anchor\n    if (isa<CompoundAssignOperator>(Anchor)) {\n      const auto *CAO\
  \ = cast<CompoundAssignOperator>(Anchor);\n      const auto *X = findSpecificTypeInChildren<CompoundAssignOperator>(S);\n\
  \      if (X == CAO)\n        Found = true;\n    } else if (isa<BinaryOperator>(Anchor))\
  \ {\n      const auto *BOA = cast<BinaryOperator>(Anchor);\n      const auto *X\
  \ = findSpecificTypeInChildren<BinaryOperator>(S);\n      if (X == BOA)\n      \
  \  Found = true;\n    }\n\n    if (Found) {\n      AnchorIdx = static_cast<int>(Idx);\n\
  \      break;\n    }\n    ++Idx;\n  }\n\n  if (AnchorIdx < 0)\n    return false;\n\
  \n  // Look back up to 4 statements\n  int Start = std::max(0, AnchorIdx - 4);\n\
  \  for (int I = AnchorIdx - 1; I >= Start; --I) {\n    const Stmt *Prev = CS->body()[I];\n\
  \    if (!Prev) continue;\n\n    const auto *IfS = dyn_cast<IfStmt>(Prev);\n   \
  \ if (!IfS) continue;\n\n    const Expr *Cond = IfS->getCond();\n    if (!Cond)\
  \ continue;\n\n    if (!isClampConditionForShorten(Cond, C, ShortenVD, IterBase))\n\
  \      continue;\n\n    const Stmt *Then = IfS->getThen();\n    if (!Then) continue;\n\
  \n    if (containsAssignZeroToVar(Then, ShortenVD))\n      return true;\n  }\n\n\
  \  return false;\n}\n\nclass SAGenTestChecker\n  : public Checker<\n      check::PostStmt<DeclStmt>,\n\
  \      check::PostStmt<CompoundAssignOperator>,\n      check::PostStmt<BinaryOperator>\n\
  \    > {\n\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"iov_iter count underflow\", \"Arithmetic\")) {}\n\n \
  \     void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;\n      void\
  \ checkPostStmt(const CompoundAssignOperator *CAO, CheckerContext &C) const;\n \
  \     void checkPostStmt(const BinaryOperator *BO, CheckerContext &C) const;\n\n\
  \   private:\n      void recordShortenIfMatch(const VarDecl *VD, const Expr *Init,\
  \ CheckerContext &C) const;\n      void recordShortenOnAssignIfMatch(const BinaryOperator\
  \ *BO, CheckerContext &C) const;\n\n      void maybeReportOnSubAssign(const CompoundAssignOperator\
  \ *CAO, CheckerContext &C) const;\n      void maybeReportOnAssignCountSub(const\
  \ BinaryOperator *BO, CheckerContext &C) const;\n\n      void reportIssue(const\
  \ Stmt *S, CheckerContext &C) const {\n        ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \        if (!N) return;\n        auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \            *BT, \"Subtracting a rounded-up length from iov_iter->count may underflow;\
  \ clamp before subtracting\", N);\n        if (S)\n          R->addRange(S->getSourceRange());\n\
  \        C.emitReport(std::move(R));\n      }\n};\n\nvoid SAGenTestChecker::recordShortenIfMatch(const\
  \ VarDecl *VD, const Expr *Init, CheckerContext &C) const {\n  if (!VD || !Init)\
  \ return;\n\n  const auto *BO = dyn_cast<BinaryOperator>(Init->IgnoreParenImpCasts());\n\
  \  if (!BO || BO->getOpcode() != BO_Sub) return;\n\n  const Expr *LHS = BO->getLHS();\n\
  \  const Expr *RHS = BO->getRHS();\n  if (!LHS || !RHS) return;\n\n  const MemRegion\
  \ *IterBase = nullptr;\n  if (!extractIterRegionFromIovIterCount(LHS, C, IterBase))\n\
  \    return;\n\n  if (!isRoundUpLikeExpr(RHS, C))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  if (!IterBase) return;\n  IterBase = IterBase->getBaseRegion();\n\
  \  if (!IterBase) return;\n\n  State = State->set<ShortenToIterRegion>(VD, IterBase);\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPostStmt(const DeclStmt\
  \ *DS, CheckerContext &C) const {\n  if (!DS) return;\n  for (const Decl *D : DS->decls())\
  \ {\n    const auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD) continue;\n    if\
  \ (!VD->hasInit()) continue;\n\n    const Expr *Init = VD->getInit();\n    recordShortenIfMatch(VD,\
  \ Init, C);\n  }\n}\n\n// Handle: iter->count -= shorten; or iter->count -= (iov_iter_count(iter)\
  \ - round_up(...))\nvoid SAGenTestChecker::maybeReportOnSubAssign(const CompoundAssignOperator\
  \ *CAO, CheckerContext &C) const {\n  if (!CAO) return;\n  if (CAO->getOpcode()\
  \ != BO_SubAssign)\n    return;\n\n  const Expr *LHS = CAO->getLHS();\n  const Expr\
  \ *RHS = CAO->getRHS();\n  if (!LHS || !RHS) return;\n\n  const MemRegion *IterBase\
  \ = getIterBaseFromCountMember(LHS, C);\n  if (!IterBase) return;\n\n  // Variant\
  \ 1: RHS is a recorded shorten variable for this iter\n  const VarDecl *ShortenVD\
  \ = nullptr;\n  bool Matches = isRecordedShortenDeclRefForIter(RHS, C, IterBase,\
  \ ShortenVD);\n\n  // Variant 2: RHS is inline \"iov_iter_count(iter) - round_up(...)\"\
  \n  if (!Matches)\n    Matches = isInlineShortenSubPattern(RHS, C, IterBase);\n\n\
  \  if (!Matches)\n    return;\n\n  // If we have a recorded variable, try to find\
  \ a guard nearby: if (shorten >= iter->count) shorten = 0;\n  if (ShortenVD && hasClampGuardNear(CAO,\
  \ ShortenVD, IterBase, C))\n    return;\n\n  reportIssue(CAO, C);\n}\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ CompoundAssignOperator *CAO, CheckerContext &C) const {\n  maybeReportOnSubAssign(CAO,\
  \ C);\n}\n\n// Record: shorten = iov_iter_count(iter) - round_up(...);\n// Or detect:\
  \ iter->count = iter->count - shorten/inline\nvoid SAGenTestChecker::checkPostStmt(const\
  \ BinaryOperator *BO, CheckerContext &C) const {\n  if (!BO) return;\n\n  if (BO->getOpcode()\
  \ == BO_Assign) {\n    const Expr *LHS = BO->getLHS();\n    const Expr *RHS = BO->getRHS();\n\
  \    if (!LHS || !RHS) return;\n\n    // Case A: LHS is a variable being assigned\
  \ a shorten-like computation\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS->IgnoreParenImpCasts()))\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n        recordShortenOnAssignIfMatch(BO,\
  \ C);\n      }\n    }\n\n    // Case B: LHS is iter->count receiving \"iter->count\
  \ - shorten/inline\"\n    maybeReportOnAssignCountSub(BO, C);\n  }\n}\n\nvoid SAGenTestChecker::recordShortenOnAssignIfMatch(const\
  \ BinaryOperator *BO, CheckerContext &C) const {\n  if (!BO || BO->getOpcode() !=\
  \ BO_Assign) return;\n  const auto *DRE = dyn_cast<DeclRefExpr>(BO->getLHS()->IgnoreParenImpCasts());\n\
  \  if (!DRE) return;\n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if\
  \ (!VD) return;\n\n  const Expr *RHS = BO->getRHS();\n  recordShortenIfMatch(VD,\
  \ RHS, C);\n}\n\n// Detect: iter->count = iter->count - shorten; or iter->count\
  \ = iter->count - (iov_iter_count(iter) - round_up(...))\nvoid SAGenTestChecker::maybeReportOnAssignCountSub(const\
  \ BinaryOperator *BO, CheckerContext &C) const {\n  if (!BO || BO->getOpcode() !=\
  \ BO_Assign) return;\n\n  const Expr *LHS = BO->getLHS();\n  const MemRegion *IterBase\
  \ = getIterBaseFromCountMember(LHS, C);\n  if (!IterBase) return;\n\n  const Expr\
  \ *RHS = BO->getRHS();\n  if (!RHS) return;\n\n  const auto *Sub = dyn_cast<BinaryOperator>(RHS->IgnoreParenImpCasts());\n\
  \  if (!Sub || Sub->getOpcode() != BO_Sub) return;\n\n  const Expr *SubLHS = Sub->getLHS();\n\
  \  const Expr *SubRHS = Sub->getRHS();\n  if (!SubLHS || !SubRHS) return;\n\n  //\
  \ Require that the first operand is the same iter->count\n  if (!isCountMemberForIterBase(SubLHS,\
  \ C, IterBase))\n    return;\n\n  // Second operand: either recorded var or inline\
  \ pattern\n  const VarDecl *ShortenVD = nullptr;\n  bool Matches = isRecordedShortenDeclRefForIter(SubRHS,\
  \ C, IterBase, ShortenVD);\n  if (!Matches)\n    Matches = isInlineShortenSubPattern(SubRHS,\
  \ C, IterBase);\n\n  if (!Matches)\n    return;\n\n  if (ShortenVD && hasClampGuardNear(BO,\
  \ ShortenVD, IterBase, C))\n    return;\n\n  reportIssue(BO, C);\n}\n\n} // end\
  \ anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects possible iov_iter->count underflow when subtracting a rounded-up\
  \ length\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbcachefs: fix iov_iter count underflow on sub-block\
  \ dio read\n\nbch2_direct_IO_read() checks the request offset and size for sector\n\
  alignment and then falls through to a couple calculations to shrink\nthe size of\
  \ the request based on the inode size. The problem is that\nthese checks round up\
  \ to the fs block size, which runs the risk of\nunderflowing iter->count if the\
  \ block size happens to be large\nenough. This is triggered by fstest generic/361\
  \ with a 4k block\nsize, which subsequently leads to a crash. To avoid this crash,\n\
  check that the shorten length doesn't exceed the overall length of\nthe iter.\n\n\
  Fixes:\nSigned-off-by: Brian Foster <bfoster@redhat.com>\nReviewed-by: Su Yue <glass.su@suse.com>\n\
  Signed-off-by: Kent Overstreet <kent.overstreet@linux.dev>\n\n## Buggy Code\n\n\
  ```c\n// Function: bch2_direct_IO_read in fs/bcachefs/fs-io-direct.c\nstatic int\
  \ bch2_direct_IO_read(struct kiocb *req, struct iov_iter *iter)\n{\n\tstruct file\
  \ *file = req->ki_filp;\n\tstruct bch_inode_info *inode = file_bch_inode(file);\n\
  \tstruct bch_fs *c = inode->v.i_sb->s_fs_info;\n\tstruct bch_io_opts opts;\n\tstruct\
  \ dio_read *dio;\n\tstruct bio *bio;\n\tloff_t offset = req->ki_pos;\n\tbool sync\
  \ = is_sync_kiocb(req);\n\tsize_t shorten;\n\tssize_t ret;\n\n\tbch2_inode_opts_get(&opts,\
  \ c, &inode->ei_inode);\n\n\t/* bios must be 512 byte aligned: */\n\tif ((offset|iter->count)\
  \ & (SECTOR_SIZE - 1))\n\t\treturn -EINVAL;\n\n\tret = min_t(loff_t, iter->count,\n\
  \t\t    max_t(loff_t, 0, i_size_read(&inode->v) - offset));\n\n\tif (!ret)\n\t\t\
  return ret;\n\n\tshorten = iov_iter_count(iter) - round_up(ret, block_bytes(c));\n\
  \titer->count -= shorten;\n\n\tbio = bio_alloc_bioset(NULL,\n\t\t\t       bio_iov_vecs_to_alloc(iter,\
  \ BIO_MAX_VECS),\n\t\t\t       REQ_OP_READ,\n\t\t\t       GFP_KERNEL,\n\t\t\t  \
  \     &c->dio_read_bioset);\n\n\tbio->bi_end_io = bch2_direct_IO_read_endio;\n\n\
  \tdio = container_of(bio, struct dio_read, rbio.bio);\n\tclosure_init(&dio->cl,\
  \ NULL);\n\n\t/*\n\t * this is a _really_ horrible hack just to avoid an atomic\
  \ sub at the\n\t * end:\n\t */\n\tif (!sync) {\n\t\tset_closure_fn(&dio->cl, bch2_dio_read_complete,\
  \ NULL);\n\t\tatomic_set(&dio->cl.remaining,\n\t\t\t   CLOSURE_REMAINING_INITIALIZER\
  \ -\n\t\t\t   CLOSURE_RUNNING +\n\t\t\t   CLOSURE_DESTRUCTOR);\n\t} else {\n\t\t\
  atomic_set(&dio->cl.remaining,\n\t\t\t   CLOSURE_REMAINING_INITIALIZER + 1);\n\t\
  \tdio->cl.closure_get_happened = true;\n\t}\n\n\tdio->req\t= req;\n\tdio->ret\t\
  = ret;\n\t/*\n\t * This is one of the sketchier things I've encountered: we have\
  \ to skip\n\t * the dirtying of requests that are internal from the kernel (i.e.\
  \ from\n\t * loopback), because we'll deadlock on page_lock.\n\t */\n\tdio->should_dirty\
  \ = iter_is_iovec(iter);\n\n\tgoto start;\n\twhile (iter->count) {\n\t\tbio = bio_alloc_bioset(NULL,\n\
  \t\t\t\t       bio_iov_vecs_to_alloc(iter, BIO_MAX_VECS),\n\t\t\t\t       REQ_OP_READ,\n\
  \t\t\t\t       GFP_KERNEL,\n\t\t\t\t       &c->bio_read);\n\t\tbio->bi_end_io\t\t\
  = bch2_direct_IO_read_split_endio;\nstart:\n\t\tbio->bi_opf\t\t= REQ_OP_READ|REQ_SYNC;\n\
  \t\tbio->bi_iter.bi_sector\t= offset >> 9;\n\t\tbio->bi_private\t\t= dio;\n\n\t\t\
  ret = bio_iov_iter_get_pages(bio, iter);\n\t\tif (ret < 0) {\n\t\t\t/* XXX: fault\
  \ inject this path */\n\t\t\tbio->bi_status = BLK_STS_RESOURCE;\n\t\t\tbio_endio(bio);\n\
  \t\t\tbreak;\n\t\t}\n\n\t\toffset += bio->bi_iter.bi_size;\n\n\t\tif (dio->should_dirty)\n\
  \t\t\tbio_set_pages_dirty(bio);\n\n\t\tif (iter->count)\n\t\t\tclosure_get(&dio->cl);\n\
  \n\t\tbch2_read(c, rbio_init(bio, opts), inode_inum(inode));\n\t}\n\n\titer->count\
  \ += shorten;\n\n\tif (sync) {\n\t\tclosure_sync(&dio->cl);\n\t\tclosure_debug_destroy(&dio->cl);\n\
  \t\tret = dio->ret;\n\t\tbio_check_or_release(&dio->rbio.bio, dio->should_dirty);\n\
  \t\treturn ret;\n\t} else {\n\t\treturn -EIOCBQUEUED;\n\t}\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/fs/bcachefs/fs-io-direct.c b/fs/bcachefs/fs-io-direct.c\n\
  index e3b219e19e10..33cb6da3a5ad 100644\n--- a/fs/bcachefs/fs-io-direct.c\n+++ b/fs/bcachefs/fs-io-direct.c\n\
  @@ -88,6 +88,8 @@ static int bch2_direct_IO_read(struct kiocb *req, struct iov_iter\
  \ *iter)\n \t\treturn ret;\n \n \tshorten = iov_iter_count(iter) - round_up(ret,\
  \ block_bytes(c));\n+\tif (shorten >= iter->count)\n+\t\tshorten = 0;\n \titer->count\
  \ -= shorten;\n \n \tbio = bio_alloc_bioset(NULL,\n```\n"
pattern: "## Bug Pattern\n\nSubtracting from an iov_iter\u2019s byte count using a\
  \ value computed with a rounded-up (block-aligned) length without first ensuring\
  \ the subtraction is non-negative, causing unsigned underflow. Concretely:\n\n-\
  \ Compute a \u201Cshorten\u201D amount as: shorten = iov_iter_count(iter) - round_up(valid_len,\
  \ block_size)\n- Then do: iter->count -= shorten;\n\nIf round_up(valid_len, block_size)\
  \ > iov_iter_count(iter), shorten wraps (size_t) and iter->count underflows, corrupting\
  \ the request size. The fix is to clamp or check: if (shorten >= iter->count) shorten\
  \ = 0 (or otherwise ensure the subtraction cannot exceed iter->count)."
plan: "1) Program state\n- Necessary: Yes, to remember \u201Cshorten-like\u201D temporaries.\n\
  - REGISTER_MAP_WITH_PROGRAMSTATE(ShortenToIterRegion, const VarDecl*, const MemRegion*)\n\
  \  - Records a VarDecl that stores iov_iter_count(iter) - round_up(...) and the\
  \ MemRegion of the iov_iter argument it used.\n- No other state (aliases/taints)\
  \ is needed.\n\n2) Callbacks and implementation steps\n\nStep A \u2014 Recognize\
  \ \u201Cshorten-like\u201D temporaries (checkPostStmt(DeclStmt))\n- For each VarDecl\
  \ with an initializer:\n  - Strip implicit casts from the initializer and dyn_cast\
  \ to BinaryOperator.\n  - Require BinaryOperator::Opcode == BO_Sub.\n  - Verify\
  \ the left side contains a call to iov_iter_count(\u2026):\n    - Find a CallExpr\
  \ within the LHS using findSpecificTypeInChildren<CallExpr>(LHS).\n    - Check callee\
  \ name is \"iov_iter_count\".\n    - Extract the first argument Arg0 (the iov_iter\
  \ expression).\n  - Verify the right side looks like a round-up/align:\n    - Use\
  \ ExprHasName(RHS, \"round_up(\", C) || ExprHasName(RHS, \"ALIGN(\", C) || ExprHasName(RHS,\
  \ \"roundup(\", C).\n    - This handles macro-based round-up patterns.\n  - If both\
  \ hold:\n    - Resolve the MemRegion of Arg0 via getMemRegionFromExpr(Arg0, C).\n\
  \    - Insert (VarDecl*, IterRegion) into ShortenToIterRegion.\n- Notes:\n  - This\
  \ is content-agnostic about the name \u201Cshorten\u201D; any VarDecl that matches\
  \ the subtraction pattern is recorded.\n  - We only record when the order is explicitly\
  \ iov_iter_count(...) - round_up(...). That matches the buggy code.\n\nStep B \u2014\
  \ Detect dangerous subtraction in-place (CompoundAssign) (checkPostStmt(CompoundAssignOperator))\n\
  - Trigger only if operator is BO_SubAssign (\u201C-=\u201D).\n- Confirm LHS is a\
  \ MemberExpr that accesses a field named \"count\":\n  - dyn_cast<MemberExpr>(LHS->IgnoreImpCasts())\
  \ and check member name \"count\".\n  - Get base expression BaseE = ME->getBase()->IgnoreImpCasts().\n\
  \  - Get base region IterRegionLHS = getMemRegionFromExpr(BaseE, C).\n- Two detection\
  \ variants for RHS:\n  1) RHS is a DeclRefExpr to a recorded VarDecl V:\n     -\
  \ Look up V in ShortenToIterRegion; get IterRegionShorten.\n     - Require IterRegionShorten\
  \ == IterRegionLHS; else bail.\n     - If matched, this is the exact subtract pattern.\n\
  \  2) RHS is a BinaryOperator BO_Sub \u201Ciov_iter_count(iter) - round_up(...)\u201D\
  \ inline:\n     - Re-check the same pattern as in Step A but on RHS:\n       - Left\
  \ side contains iov_iter_count; extract Arg0; get its MemRegion IterRegionArg0.\n\
  \       - Right side contains round_up-like macro.\n       - Require IterRegionArg0\
  \ == IterRegionLHS.\n- Guard suppression:\n  - Before reporting, try to find a simple,\
  \ local clamp that prevents underflow.\n  - Obtain the closest enclosing CompoundStmt\
  \ with findSpecificTypeInParents<CompoundStmt>(CAO, C).\n  - Iterate the CompoundStmt\u2019\
  s body in order, find the statement that contains this CompoundAssignOperator (use\
  \ findSpecificTypeInChildren<CompoundAssignOperator>(Stmt) == CAO).\n  - Look backwards\
  \ over a small window (e.g., up to the previous 4 statements) for an IfStmt with:\n\
  \    - Condition comparing the same entities we just matched:\n      - Either \u201C\
  shorten_var >= iter->count\u201D (if RHS was a DeclRefExpr) or a condition that\
  \ contains both the variable name and \u201Ccount\u201D:\n        - Prefer precise:\
  \ dyn_cast<BinaryOperator>(Cond) with op GE/GT and one side DeclRef(var) and the\
  \ other side a MemberExpr to the same IterRegion base with member \"count\".\n \
  \       - As a fallback, ExprHasName(Cond, V->getName(), C) && ExprHasName(Cond,\
  \ \"count\", C).\n    - Then-branch assigns the variable to zero:\n      - Search\
  \ inside the then-body for a BinaryOperator with op Assign whose LHS is DeclRef(var)\
  \ and RHS is integer literal 0.\n  - If such a guard is found, do not warn; otherwise,\
  \ emit a report.\n\nStep C \u2014 Detect dangerous subtraction via explicit assignment\
  \ (checkPostStmt(BinaryOperator))\n- Trigger when opcode is BO_Assign (\u201C=\u201D\
  ).\n- LHS must be MemberExpr field \"count\" with base region IterRegionLHS (same\
  \ as above).\n- RHS must be BO_Sub:\n  - One side must be the same \u201Citer->count\u201D\
  \ MemberExpr (same base region and \"count\").\n  - The other side must match either:\n\
  \    1) DeclRefExpr to a recorded VarDecl V whose IterRegion matches IterRegionLHS\
  \ (via ShortenToIterRegion).\n    2) Inline \u201Ciov_iter_count(iter) - round_up(...)\u201D\
  \ with IterRegionArg0 == IterRegionLHS (same test as Step B).\n- Run the same guard\
  \ suppression search as in Step B using the closest CompoundStmt and previous statements.\n\
  - Report if unguarded.\n\nStep D \u2014 Reporting\n- Create a BugType once, e.g.,\
  \ \"iov_iter count underflow\".\n- Message: \"Subtracting a rounded-up length from\
  \ iov_iter->count may underflow; clamp or guard before subtracting.\"\n- Emit at\
  \ the CompoundAssignOperator or BinaryOperator location using generateNonFatalErrorNode\
  \ and PathSensitiveBugReport.\n\n3) Heuristics and notes\n- The checker is intentionally\
  \ narrow:\n  - It keys on the concomitant presence of iov_iter_count(...) and a\
  \ round-up-like macro in the subtraction that is being subtracted from iter->count.\n\
  \  - It matches both split form (temporary variable) and inline form.\n- Guard detection\
  \ is local and simple:\n  - Looks only a few statements back within the same compound\
  \ statement for \u201Cif (var >= iter->count) var = 0;\u201D pattern.\n  - If no\
  \ such clamp is found, it warns.\n- Utility functions used:\n  - findSpecificTypeInParents\
  \ to find the enclosing CompoundStmt.\n  - findSpecificTypeInChildren to match sub-expressions\
  \ inside statements.\n  - ExprHasName to robustly detect macro-like names in source\
  \ text (\u201Cround_up(\u201D, \u201CALIGN(\u201D).\n  - getMemRegionFromExpr to\
  \ ensure the LHS iter base and the iov_iter_count argument refer to the same region.\n\
  \n4) Chosen callbacks summary\n- checkPostStmt(DeclStmt): Record \u201Cshorten-like\u201D\
  \ temporaries in ShortenToIterRegion.\n- checkPostStmt(CompoundAssignOperator):\
  \ Detect \u201Citer->count -= shorten\u201D or inline \u201Citer->count -= (iov_iter_count\
  \ - round_up)\u201D and report if unguarded.\n- checkPostStmt(BinaryOperator): Detect\
  \ \u201Citer->count = iter->count - shorten/inline\u201D and report if unguarded.\n\
  \n5) Minimal false-positive handling\n- Only warn when:\n  - LHS is precisely iter->count\
  \ and\n  - RHS is precisely derived from iov_iter_count(iter) minus a round-up-like\
  \ term and\n  - No nearby clamp \u201Cif (shorten >= iter->count) shorten = 0;\u201D\
  \ is visible."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/Stmt.h\"\
  \n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/AST/Decl.h\"\n#include \"llvm/ADT/APSInt.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n#include <utility>\n#include <algorithm>\n\
  #include <memory>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// Map a temporary variable (e.g., \"shorten\") to the iov_iter MemRegion\
  \ used to compute it.\nREGISTER_MAP_WITH_PROGRAMSTATE(ShortenToIterRegion, const\
  \ VarDecl*, const MemRegion*)\n\nnamespace {\n\n// Helper: is IntegerLiteral zero\n\
  static bool isIntegerLiteralZero(const Expr *E) {\n  if (!E) return false;\n  E\
  \ = E->IgnoreParenImpCasts();\n  if (const auto *IL = dyn_cast<IntegerLiteral>(E))\n\
  \    return IL->getValue() == 0;\n  return false;\n}\n\n// Helper: does expression\
  \ look like round-up/align operation (by name)\nstatic bool isRoundUpLikeExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return false;\n  return ExprHasName(E,\
  \ \"round_up\", C) || ExprHasName(E, \"ALIGN\", C) ||\n         ExprHasName(E, \"\
  roundup\", C);\n}\n\n// Helper: find a CallExpr to iov_iter_count(...) inside E\
  \ and extract the iter MemRegion base.\nstatic bool extractIterRegionFromIovIterCount(const\
  \ Expr *E,\n                                              CheckerContext &C,\n \
  \                                             const MemRegion *&OutIterBase) {\n\
  \  OutIterBase = nullptr;\n  if (!E) return false;\n\n  const CallExpr *Call = nullptr;\n\
  \  // If E itself is a call, prefer that; else search in children.\n  if (const\
  \ auto *CE = dyn_cast<CallExpr>(E->IgnoreParenImpCasts()))\n    Call = CE;\n  else\n\
  \    Call = findSpecificTypeInChildren<CallExpr>(E);\n\n  if (!Call) return false;\n\
  \  // Robust name check by source text\n  if (!ExprHasName(Call, \"iov_iter_count\"\
  , C))\n    return false;\n\n  if (Call->getNumArgs() < 1) return false;\n  const\
  \ Expr *Arg0 = Call->getArg(0);\n  if (!Arg0) return false;\n\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(Arg0, C);\n  if (!MR) return false;\n  MR = MR->getBaseRegion();\n\
  \  if (!MR) return false;\n\n  OutIterBase = MR;\n  return true;\n}\n\n// Helper:\
  \ check whether RHS is an inline pattern \"iov_iter_count(iter) - round_up(...)\"\
  \n// and that the iter base equals IterBase.\nstatic bool isInlineShortenSubPattern(const\
  \ Expr *RHS, CheckerContext &C,\n                                      const MemRegion\
  \ *IterBase) {\n  if (!RHS || !IterBase) return false;\n  const auto *BO = dyn_cast<BinaryOperator>(RHS->IgnoreParenImpCasts());\n\
  \  if (!BO || BO->getOpcode() != BO_Sub) return false;\n\n  const Expr *LHS = BO->getLHS();\n\
  \  const Expr *R = BO->getRHS();\n  if (!LHS || !R) return false;\n\n  const MemRegion\
  \ *FoundIterBase = nullptr;\n  if (!extractIterRegionFromIovIterCount(LHS, C, FoundIterBase))\n\
  \    return false;\n  if (FoundIterBase != IterBase)\n    return false;\n\n  //\
  \ RHS of subtraction should be round-up-like\n  if (!isRoundUpLikeExpr(R, C))\n\
  \    return false;\n\n  return true;\n}\n\n// Helper: If E is a DeclRefExpr to a\
  \ VarDecl recorded as a shorten-like temp,\n// and its iter-region equals IterBase.\
  \ Optionally return the VarDecl via OutVD.\nstatic bool isRecordedShortenDeclRefForIter(const\
  \ Expr *E, CheckerContext &C,\n                                            const\
  \ MemRegion *IterBase,\n                                            const VarDecl\
  \ *&OutVD) {\n  OutVD = nullptr;\n  if (!E || !IterBase) return false;\n\n  const\
  \ auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenImpCasts());\n  if (!DRE) return\
  \ false;\n\n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD) return\
  \ false;\n\n  ProgramStateRef State = C.getState();\n  const MemRegion *const *Recorded\
  \ = State->get<ShortenToIterRegion>(VD);\n  if (!Recorded) return false;\n\n  if\
  \ ((*Recorded)->getBaseRegion() == IterBase) {\n    OutVD = VD;\n    return true;\n\
  \  }\n  return false;\n}\n\n// Helper: get iter base MemRegion from MemberExpr that\
  \ accesses \".count\".\nstatic const MemRegion *getIterBaseFromCountMember(const\
  \ Expr *LHS, CheckerContext &C) {\n  if (!LHS) return nullptr;\n  const auto *ME\
  \ = dyn_cast<MemberExpr>(LHS->IgnoreParenImpCasts());\n  if (!ME) return nullptr;\n\
  \n  const ValueDecl *VD = ME->getMemberDecl();\n  if (!VD) return nullptr;\n\n \
  \ if (VD->getName() != \"count\")\n    return nullptr;\n\n  const Expr *BaseE =\
  \ ME->getBase();\n  if (!BaseE) return nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(BaseE,\
  \ C);\n  if (!MR) return nullptr;\n\n  MR = MR->getBaseRegion();\n  return MR;\n\
  }\n\n// Helper: is expression a MemberExpr \".count\" for the given iter base?\n\
  static bool isCountMemberForIterBase(const Expr *E, CheckerContext &C,\n       \
  \                              const MemRegion *IterBase) {\n  const MemRegion *MR\
  \ = getIterBaseFromCountMember(E, C);\n  return MR && MR == IterBase;\n}\n\n// Helper:\
  \ does Cond look like \"ShortenVD >= iter->count\" (or >) where iter base matches?\n\
  static bool isClampConditionForShorten(const Expr *Cond, CheckerContext &C,\n  \
  \                                     const VarDecl *ShortenVD,\n              \
  \                         const MemRegion *IterBase) {\n  if (!Cond || !ShortenVD\
  \ || !IterBase) return false;\n  Cond = Cond->IgnoreParenImpCasts();\n\n  const\
  \ auto *BO = dyn_cast<BinaryOperator>(Cond);\n  if (!BO) return false;\n  BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n  if (!(Op == BO_GE || Op == BO_GT))\n    return false;\n\
  \n  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS =\
  \ BO->getRHS()->IgnoreParenImpCasts();\n\n  auto IsShorten = [&](const Expr *E)\
  \ -> bool {\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(E))\n      return DRE->getDecl()\
  \ == ShortenVD;\n    return false;\n  };\n\n  // Two orders: shorten >= iter->count\
  \ OR iter->count <= shorten (normalized as above)\n  if (IsShorten(LHS) && isCountMemberForIterBase(RHS,\
  \ C, IterBase))\n    return true;\n  if (IsShorten(RHS) && isCountMemberForIterBase(LHS,\
  \ C, IterBase))\n    return true;\n\n  return false;\n}\n\n// Helper: recursively\
  \ search in S for an assignment \"ShortenVD = 0;\"\nstatic bool containsAssignZeroToVar(const\
  \ Stmt *S, const VarDecl *ShortenVD) {\n  if (!S || !ShortenVD) return false;\n\n\
  \  if (const auto *BO = dyn_cast<BinaryOperator>(S)) {\n    if (BO->getOpcode()\
  \ == BO_Assign) {\n      const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n      const auto *LDRE\
  \ = dyn_cast<DeclRefExpr>(L);\n      if (LDRE && LDRE->getDecl() == ShortenVD &&\
  \ isIntegerLiteralZero(R))\n        return true;\n    }\n  }\n\n  for (const Stmt\
  \ *Child : S->children()) {\n    if (Child && containsAssignZeroToVar(Child, ShortenVD))\n\
  \      return true;\n  }\n  return false;\n}\n\n// Helper: Look within the same\
  \ enclosing CompoundStmt for a nearby guard:\n// if (shorten >= iter->count) shorten\
  \ = 0;\nstatic bool hasClampGuardNear(const Stmt *Anchor,\n                    \
  \          const VarDecl *ShortenVD,\n                              const MemRegion\
  \ *IterBase,\n                              CheckerContext &C) {\n  if (!Anchor\
  \ || !ShortenVD || !IterBase) return false;\n\n  const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(Anchor,\
  \ C);\n  if (!CS) return false;\n\n  // Materialize body into an indexable container.\n\
  \  llvm::SmallVector<const Stmt *, 16> Body;\n  for (const Stmt *S : CS->body())\n\
  \    Body.push_back(S);\n\n  // Find the index of the statement that contains Anchor\n\
  \  unsigned Idx = 0;\n  int AnchorIdx = -1;\n\n  for (const Stmt *S : Body) {\n\
  \    bool Found = false;\n\n    // Try to see if this statement contains the anchor\n\
  \    if (isa<CompoundAssignOperator>(Anchor)) {\n      const auto *CAO = cast<CompoundAssignOperator>(Anchor);\n\
  \      const auto *X = findSpecificTypeInChildren<CompoundAssignOperator>(S);\n\
  \      if (X == CAO)\n        Found = true;\n    } else if (isa<BinaryOperator>(Anchor))\
  \ {\n      const auto *BOA = cast<BinaryOperator>(Anchor);\n      const auto *X\
  \ = findSpecificTypeInChildren<BinaryOperator>(S);\n      if (X == BOA)\n      \
  \  Found = true;\n    }\n\n    if (Found) {\n      AnchorIdx = static_cast<int>(Idx);\n\
  \      break;\n    }\n    ++Idx;\n  }\n\n  if (AnchorIdx < 0)\n    return false;\n\
  \n  // Look back up to 4 statements\n  int Start = std::max(0, AnchorIdx - 4);\n\
  \  for (int I = AnchorIdx - 1; I >= Start; --I) {\n    const Stmt *Prev = Body[I];\n\
  \    if (!Prev) continue;\n\n    const auto *IfS = dyn_cast<IfStmt>(Prev);\n   \
  \ if (!IfS) continue;\n\n    const Expr *Cond = IfS->getCond();\n    if (!Cond)\
  \ continue;\n\n    if (!isClampConditionForShorten(Cond, C, ShortenVD, IterBase))\n\
  \      continue;\n\n    const Stmt *Then = IfS->getThen();\n    if (!Then) continue;\n\
  \n    if (containsAssignZeroToVar(Then, ShortenVD))\n      return true;\n  }\n\n\
  \  return false;\n}\n\nclass SAGenTestChecker\n  : public Checker<\n      check::PostStmt<DeclStmt>,\n\
  \      check::PostStmt<CompoundAssignOperator>,\n      check::PostStmt<BinaryOperator>\n\
  \    > {\n\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"iov_iter count underflow\", \"Arithmetic\")) {}\n\n \
  \     void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;\n      void\
  \ checkPostStmt(const CompoundAssignOperator *CAO, CheckerContext &C) const;\n \
  \     void checkPostStmt(const BinaryOperator *BO, CheckerContext &C) const;\n\n\
  \   private:\n      void recordShortenIfMatch(const VarDecl *VD, const Expr *Init,\
  \ CheckerContext &C) const;\n      void recordShortenOnAssignIfMatch(const BinaryOperator\
  \ *BO, CheckerContext &C) const;\n\n      void maybeReportOnSubAssign(const CompoundAssignOperator\
  \ *CAO, CheckerContext &C) const;\n      void maybeReportOnAssignCountSub(const\
  \ BinaryOperator *BO, CheckerContext &C) const;\n\n      void reportIssue(const\
  \ Stmt *S, CheckerContext &C) const {\n        ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \        if (!N) return;\n        auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \            *BT, \"Subtracting a rounded-up length from iov_iter->count may underflow;\
  \ clamp before subtracting\", N);\n        if (S)\n          R->addRange(S->getSourceRange());\n\
  \        C.emitReport(std::move(R));\n      }\n};\n\nvoid SAGenTestChecker::recordShortenIfMatch(const\
  \ VarDecl *VD, const Expr *Init, CheckerContext &C) const {\n  if (!VD || !Init)\
  \ return;\n\n  const auto *BO = dyn_cast<BinaryOperator>(Init->IgnoreParenImpCasts());\n\
  \  if (!BO || BO->getOpcode() != BO_Sub) return;\n\n  const Expr *LHS = BO->getLHS();\n\
  \  const Expr *RHS = BO->getRHS();\n  if (!LHS || !RHS) return;\n\n  const MemRegion\
  \ *IterBase = nullptr;\n  if (!extractIterRegionFromIovIterCount(LHS, C, IterBase))\n\
  \    return;\n\n  if (!isRoundUpLikeExpr(RHS, C))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  if (!IterBase) return;\n  IterBase = IterBase->getBaseRegion();\n\
  \  if (!IterBase) return;\n\n  State = State->set<ShortenToIterRegion>(VD, IterBase);\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPostStmt(const DeclStmt\
  \ *DS, CheckerContext &C) const {\n  if (!DS) return;\n  for (const Decl *D : DS->decls())\
  \ {\n    const auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD) continue;\n    if\
  \ (!VD->hasInit()) continue;\n\n    const Expr *Init = VD->getInit();\n    recordShortenIfMatch(VD,\
  \ Init, C);\n  }\n}\n\n// Handle: iter->count -= shorten; or iter->count -= (iov_iter_count(iter)\
  \ - round_up(...))\nvoid SAGenTestChecker::maybeReportOnSubAssign(const CompoundAssignOperator\
  \ *CAO, CheckerContext &C) const {\n  if (!CAO) return;\n  if (CAO->getOpcode()\
  \ != BO_SubAssign)\n    return;\n\n  const Expr *LHS = CAO->getLHS();\n  const Expr\
  \ *RHS = CAO->getRHS();\n  if (!LHS || !RHS) return;\n\n  const MemRegion *IterBase\
  \ = getIterBaseFromCountMember(LHS, C);\n  if (!IterBase) return;\n\n  // Variant\
  \ 1: RHS is a recorded shorten variable for this iter\n  const VarDecl *ShortenVD\
  \ = nullptr;\n  bool Matches = isRecordedShortenDeclRefForIter(RHS, C, IterBase,\
  \ ShortenVD);\n\n  // Variant 2: RHS is inline \"iov_iter_count(iter) - round_up(...)\"\
  \n  if (!Matches)\n    Matches = isInlineShortenSubPattern(RHS, C, IterBase);\n\n\
  \  if (!Matches)\n    return;\n\n  // If we have a recorded variable, try to find\
  \ a guard nearby: if (shorten >= iter->count) shorten = 0;\n  if (ShortenVD && hasClampGuardNear(CAO,\
  \ ShortenVD, IterBase, C))\n    return;\n\n  reportIssue(CAO, C);\n}\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ CompoundAssignOperator *CAO, CheckerContext &C) const {\n  maybeReportOnSubAssign(CAO,\
  \ C);\n}\n\n// Record: shorten = iov_iter_count(iter) - round_up(...);\n// Or detect:\
  \ iter->count = iter->count - shorten/inline\nvoid SAGenTestChecker::checkPostStmt(const\
  \ BinaryOperator *BO, CheckerContext &C) const {\n  if (!BO) return;\n\n  if (BO->getOpcode()\
  \ == BO_Assign) {\n    const Expr *LHS = BO->getLHS();\n    const Expr *RHS = BO->getRHS();\n\
  \    if (!LHS || !RHS) return;\n\n    // Case A: LHS is a variable being assigned\
  \ a shorten-like computation\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS->IgnoreParenImpCasts()))\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n        (void)VD;\
  \ // Silence unused warning; logic is in recordShortenOnAssignIfMatch\n        recordShortenOnAssignIfMatch(BO,\
  \ C);\n      }\n    }\n\n    // Case B: LHS is iter->count receiving \"iter->count\
  \ - shorten/inline\"\n    maybeReportOnAssignCountSub(BO, C);\n  }\n}\n\nvoid SAGenTestChecker::recordShortenOnAssignIfMatch(const\
  \ BinaryOperator *BO, CheckerContext &C) const {\n  if (!BO || BO->getOpcode() !=\
  \ BO_Assign) return;\n  const auto *DRE = dyn_cast<DeclRefExpr>(BO->getLHS()->IgnoreParenImpCasts());\n\
  \  if (!DRE) return;\n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if\
  \ (!VD) return;\n\n  const Expr *RHS = BO->getRHS();\n  recordShortenIfMatch(VD,\
  \ RHS, C);\n}\n\n// Detect: iter->count = iter->count - shorten; or iter->count\
  \ = iter->count - (iov_iter_count(iter) - round_up(...))\nvoid SAGenTestChecker::maybeReportOnAssignCountSub(const\
  \ BinaryOperator *BO, CheckerContext &C) const {\n  if (!BO || BO->getOpcode() !=\
  \ BO_Assign) return;\n\n  const Expr *LHS = BO->getLHS();\n  const MemRegion *IterBase\
  \ = getIterBaseFromCountMember(LHS, C);\n  if (!IterBase) return;\n\n  const Expr\
  \ *RHS = BO->getRHS();\n  if (!RHS) return;\n\n  const auto *Sub = dyn_cast<BinaryOperator>(RHS->IgnoreParenImpCasts());\n\
  \  if (!Sub || Sub->getOpcode() != BO_Sub) return;\n\n  const Expr *SubLHS = Sub->getLHS();\n\
  \  const Expr *SubRHS = Sub->getRHS();\n  if (!SubLHS || !SubRHS) return;\n\n  //\
  \ Require that the first operand is the same iter->count\n  if (!isCountMemberForIterBase(SubLHS,\
  \ C, IterBase))\n    return;\n\n  // Second operand: either recorded var or inline\
  \ pattern\n  const VarDecl *ShortenVD = nullptr;\n  bool Matches = isRecordedShortenDeclRefForIter(SubRHS,\
  \ C, IterBase, ShortenVD);\n  if (!Matches)\n    Matches = isInlineShortenSubPattern(SubRHS,\
  \ C, IterBase);\n\n  if (!Matches)\n    return;\n\n  if (ShortenVD && hasClampGuardNear(BO,\
  \ ShortenVD, IterBase, C))\n    return;\n\n  reportIssue(BO, C);\n}\n\n} // end\
  \ anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects possible iov_iter->count underflow when subtracting a rounded-up\
  \ length\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
