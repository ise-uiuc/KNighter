_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 7a4b21250bf79eef26543d35bd390448646c536b
commit_type: Integer-Overflow
index: 8
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Map: track variables\
  \ that currently hold the result of roundup_pow_of_two(arg0).\n// Key: base MemRegion\
  \ of the LHS variable. Value: pointer to the 0th argument Expr.\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion*, const Expr*)\n\nnamespace {\nclass SAGenTestChecker\n  : public\
  \ Checker<\n        check::Bind,\n        check::BranchCondition> {\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this,\n         \
  \              \"Unreliable overflow check after roundup_pow_of_two\",\n       \
  \                \"Correctness\")) {}\n\n  void checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const;\n  void checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  static bool isZeroInteger(const\
  \ Expr *E, CheckerContext &C);\n  void report(const Stmt *S, CheckerContext &C)\
  \ const;\n  static const MemRegion *getBaseReg(const MemRegion *MR) {\n    return\
  \ MR ? MR->getBaseRegion() : nullptr;\n  }\n};\n\n// Check if expression evaluates\
  \ to the integer constant 0.\nbool SAGenTestChecker::isZeroInteger(const Expr *E,\
  \ CheckerContext &C) {\n  if (!E)\n    return false;\n  llvm::APSInt Res;\n  if\
  \ (!EvaluateExprToInt(Res, E, C))\n    return false;\n  return Res == 0;\n}\n\n\
  void SAGenTestChecker::report(const Stmt *S, CheckerContext &C) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"roundup_pow_of_two() overflow check via zero is unreliable\
  \ (UB on 32-bit); pre-validate the input before calling\",\n      N);\n  if (S)\n\
  \    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n// Track\
  \ assignments from roundup_pow_of_two(...) to a variable, and clear mapping on other\
  \ assignments.\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal /*Val*/, const Stmt\
  \ *S, CheckerContext &C) const {\n  const MemRegion *LHSReg = Loc.getAsRegion();\n\
  \  if (!LHSReg)\n    return;\n  LHSReg = getBaseReg(LHSReg);\n  if (!LHSReg)\n \
  \   return;\n\n  ProgramStateRef State = C.getState();\n\n  // Try to find a call\
  \ expression in this store statement.\n  const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(S);\n\
  \  if (CE && ExprHasName(CE, \"roundup_pow_of_two\", C)) {\n    // Record that LHSReg\
  \ holds the result of roundup_pow_of_two with this argument.\n    if (CE->getNumArgs()\
  \ >= 1) {\n      const Expr *Arg0 = CE->getArg(0);\n      State = State->set<RoundupResMap>(LHSReg,\
  \ Arg0);\n      C.addTransition(State);\n      return;\n    }\n  }\n\n  // Otherwise,\
  \ this assignment overrides previous mapping; remove if present.\n  if (State->contains<RoundupResMap>(LHSReg))\
  \ {\n    State = State->remove<RoundupResMap>(LHSReg);\n    C.addTransition(State);\n\
  \  }\n}\n\n// Detect branch conditions that test the result of roundup_pow_of_two()\
  \ for zero:\n// 1) Directly: if (!roundup_pow_of_two(x)) or if (roundup_pow_of_two(x)\
  \ == 0)\n// 2) Indirectly via a variable previously assigned from roundup_pow_of_two:\
  \ if (!var) or if (var == 0)\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE) {\n   \
  \ C.addTransition(State);\n    return;\n  }\n  CondE = CondE->IgnoreParenImpCasts();\n\
  \n  // Case 1a: if (!roundup_pow_of_two(...))\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *Sub = UO->getSubExpr();\n\
  \      // Direct-in-condition roundup_pow_of_two(...)\n      if (const CallExpr\
  \ *CallIn = findSpecificTypeInChildren<CallExpr>(Sub)) {\n        if (ExprHasName(CallIn,\
  \ \"roundup_pow_of_two\", C)) {\n          report(Condition, C);\n          return;\n\
  \        }\n      }\n      // Variable-based: if (!var)\n      const DeclRefExpr\
  \ *DRE = findSpecificTypeInChildren<DeclRefExpr>(Sub);\n      if (DRE) {\n     \
  \   const MemRegion *MR = getMemRegionFromExpr(DRE, C);\n        MR = getBaseReg(MR);\n\
  \        if (MR) {\n          const Expr *const *ArgPtr = State->get<RoundupResMap>(MR);\n\
  \          if (ArgPtr) {\n            report(Condition, C);\n            return;\n\
  \          }\n        }\n      }\n    }\n  }\n\n  // Case 1b and 2b: Binary compare\
  \ with zero: if (roundup_pow_of_two(...) == 0) or if (var == 0) or if (0 == var)\n\
  \  if (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    if (BO->getOpcode()\
  \ == BO_EQ) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  \
  \    const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n      // Direct call\
  \ on either side compared to 0\n      const CallExpr *CallLHS = dyn_cast<CallExpr>(LHS);\n\
  \      const CallExpr *CallRHS = dyn_cast<CallExpr>(RHS);\n\n      if (CallLHS &&\
  \ ExprHasName(CallLHS, \"roundup_pow_of_two\", C) && isZeroInteger(RHS, C)) {\n\
  \        report(Condition, C);\n        return;\n      }\n      if (CallRHS && ExprHasName(CallRHS,\
  \ \"roundup_pow_of_two\", C) && isZeroInteger(LHS, C)) {\n        report(Condition,\
  \ C);\n        return;\n      }\n\n      // Variable-based: var == 0 or 0 == var,\
  \ where var is previously recorded.\n      auto CheckVarZero = [&](const Expr *VarExpr,\
  \ const Expr *OtherExpr) -> bool {\n        const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(VarExpr);\n\
  \        if (!DRE)\n          return false;\n        const MemRegion *MR = getMemRegionFromExpr(DRE,\
  \ C);\n        MR = getBaseReg(MR);\n        if (!MR)\n          return false;\n\
  \        if (!State->contains<RoundupResMap>(MR))\n          return false;\n   \
  \     return isZeroInteger(OtherExpr, C);\n      };\n\n      if (CheckVarZero(LHS,\
  \ RHS) || CheckVarZero(RHS, LHS)) {\n        report(Condition, C);\n        return;\n\
  \      }\n    }\n  }\n\n  C.addTransition(State);\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects unreliable zero-check overflow\
  \ pattern after roundup_pow_of_two()\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbpf: Fix stackmap overflow check on 32-bit arches\n\
  \nThe stackmap code relies on roundup_pow_of_two() to compute the number\nof hash\
  \ buckets, and contains an overflow check by checking if the\nresulting value is\
  \ 0. However, on 32-bit arches, the roundup code itself\ncan overflow by doing a\
  \ 32-bit left-shift of an unsigned long value,\nwhich is undefined behaviour, so\
  \ it is not guaranteed to truncate\nneatly. This was triggered by syzbot on the\
  \ DEVMAP_HASH type, which\ncontains the same check, copied from the hashtab code.\n\
  \nThe commit in the fixes tag actually attempted to fix this, but the fix\ndid not\
  \ account for the UB, so the fix only works on CPUs where an\noverflow does result\
  \ in a neat truncation to zero, which is not\nguaranteed. Checking the value before\
  \ rounding does not have this\nproblem.\n\nFixes: 6183f4d3a0a2 (\"bpf: Check for\
  \ integer overflow when using roundup_pow_of_two()\")\nSigned-off-by: Toke H\xF8\
  iland-J\xF8rgensen <toke@redhat.com>\nReviewed-by: Bui Quang Minh <minhquangbui99@gmail.com>\n\
  Message-ID: <20240307120340.99577-4-toke@redhat.com>\nSigned-off-by: Alexei Starovoitov\
  \ <ast@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: stack_map_alloc in kernel/bpf/stackmap.c\n\
  static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n{\n\tu32 value_size\
  \ = attr->value_size;\n\tstruct bpf_stack_map *smap;\n\tu64 cost, n_buckets;\n\t\
  int err;\n\n\tif (attr->map_flags & ~STACK_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size\
  \ != 4 ||\n\t    value_size < 8 || value_size % 8)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\tBUILD_BUG_ON(sizeof(struct bpf_stack_build_id) % sizeof(u64));\n\tif (attr->map_flags\
  \ & BPF_F_STACK_BUILD_ID) {\n\t\tif (value_size % sizeof(struct bpf_stack_build_id)\
  \ ||\n\t\t    value_size / sizeof(struct bpf_stack_build_id)\n\t\t    > sysctl_perf_event_max_stack)\n\
  \t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n\
  \t\treturn ERR_PTR(-EINVAL);\n\n\t/* hash table size must be power of 2 */\n\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n\tif (!n_buckets)\n\t\treturn ERR_PTR(-E2BIG);\n\
  \n\tcost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);\n\tsmap\
  \ = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\tif (!smap)\n\t\t\
  return ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&smap->map, attr);\n\tsmap->n_buckets\
  \ = n_buckets;\n\n\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\t\
  if (err)\n\t\tgoto free_smap;\n\n\terr = prealloc_elems_and_freelist(smap);\n\t\
  if (err)\n\t\tgoto put_buffers;\n\n\treturn &smap->map;\n\nput_buffers:\n\tput_callchain_buffers();\n\
  free_smap:\n\tbpf_map_area_free(smap);\n\treturn ERR_PTR(err);\n}\n```\n\n## Bug\
  \ Fix Patch\n\n```diff\ndiff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c\n\
  index dff7ba539701..c99f8e5234ac 100644\n--- a/kernel/bpf/stackmap.c\n+++ b/kernel/bpf/stackmap.c\n\
  @@ -91,11 +91,14 @@ static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n\
  \ \t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n \t\treturn ERR_PTR(-EINVAL);\n\
  \ \n-\t/* hash table size must be power of 2 */\n-\tn_buckets = roundup_pow_of_two(attr->max_entries);\n\
  -\tif (!n_buckets)\n+\t/* hash table size must be power of 2; roundup_pow_of_two()\
  \ can overflow\n+\t * into UB on 32-bit arches, so check that first\n+\t */\n+\t\
  if (attr->max_entries > 1UL << 31)\n \t\treturn ERR_PTR(-E2BIG);\n \n+\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n+\n \tcost = n_buckets * sizeof(struct\
  \ stack_map_bucket *) + sizeof(*smap);\n \tsmap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\
  \ \tif (!smap)\n```\n"
pattern: '## Bug Pattern


  Relying on roundup_pow_of_two() to signal overflow by checking if its result is
  0, when the input can exceed the largest representable power-of-two on 32-bit systems.
  On 32-bit arches, roundup_pow_of_two() (often implemented via 1UL << order) can
  perform a left shift by BITS_PER_LONG bits, which is undefined behavior. Thus, the
  post-call zero check is unreliable. The correct pattern is to pre-validate the input
  (e.g., x > 1UL << (BITS_PER_LONG - 1)) before calling roundup_pow_of_two().'
plan: "Plan\n\n1) Program state\n- Register one map to remember variables that currently\
  \ hold the result of roundup_pow_of_two():\n  REGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion*, const Expr*)\n  where the key is the MemRegion of the LHS variable\
  \ and the value is the argument expression passed to roundup_pow_of_two(). The value\
  \ is optional for reporting/context; we only need to know \u201Cthis var came from\
  \ roundup_pow_of_two()\u201D.\n\n- No alias tracking and no other traits/maps (keep\
  \ it simple). If the variable is reassigned later with a non-roundup value, we remove\
  \ it from the map.\n\n2) Callbacks and how to implement them\n\nA) checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C)\n- Goal:\n  - Detect when a variable\
  \ is assigned (or initialized) from roundup_pow_of_two(...)\n  - Record that LHS\
  \ region in RoundupResMap.\n  - Drop the record when the variable gets any other\
  \ value later.\n\n- Steps:\n  1. Retrieve the destination region:\n     - If Loc.getAsRegion()\
  \ is null, return.\n     - Let LHSReg = Loc.getAsRegion().\n\n  2. Identify whether\
  \ the bound value at this statement comes from a call to roundup_pow_of_two:\n \
  \    - Use findSpecificTypeInChildren<CallExpr>(S) to locate a call expression involved\
  \ in this bind.\n     - If found, verify it is roundup_pow_of_two using ExprHasName(CallExprNode,\
  \ \"roundup_pow_of_two\", C).\n       - If true: extract the 0th argument expression:\
  \ Arg0 = CallExprNode->getArg(0).\n         - Update state: State = State->set<RoundupResMap>(LHSReg,\
  \ Arg0).\n         - C.addTransition(State).\n         - Return.\n     - If no such\
  \ call is found (or the call is not roundup_pow_of_two):\n       - If LHSReg exists\
  \ in RoundupResMap, remove it:\n         State = State->remove<RoundupResMap>(LHSReg),\
  \ then C.addTransition(State).\n\n- Rationale:\n  - This catches both declarations\
  \ like \u201Cu64 nb = roundup_pow_of_two(x);\u201D and assignments \u201Cnb = roundup_pow_of_two(x);\u201D\
  .\n  - On any subsequent non-roundup assignment to the same var, we clear the tag\
  \ to avoid stale info.\n\nB) checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C)\n- Goal:\n  - Report when code detects overflow by checking the result of\
  \ roundup_pow_of_two() for zero.\n  - Two patterns to catch:\n    1) Direct-in-condition\
  \ calls: if (!roundup_pow_of_two(x)) or if (roundup_pow_of_two(x) == 0)\n    2)\
  \ Zero-check on a variable that was previously recorded as the roundup result: if\
  \ (!var) or if (var == 0) or if (0 == var)\n\n- Steps:\n  1) Direct-in-condition\
  \ detection:\n     - Find any CallExpr inside Condition via findSpecificTypeInChildren<CallExpr>(Condition).\n\
  \     - If present and ExprHasName(CallExprNode, \"roundup_pow_of_two\", C) is true:\n\
  \       - Determine if the condition is a zero-test:\n         - Cases to accept:\n\
  \           - UnaryOperator UO_LNot whose subexpr is (maybe via implicit casts)\
  \ the same call.\n           - BinaryOperator with op == and one side the call,\
  \ the other side an integer 0 (use EvaluateExprToInt on the non-call side to confirm\
  \ constant 0).\n         - If matched, report (see Reporting below). Return.\n\n\
  \  2) Variable-based detection:\n     - Find a DeclRefExpr inside Condition: const\
  \ DeclRefExpr *DRE = findSpecificTypeInChildren<DeclRefExpr>(Condition).\n     -\
  \ If no DRE, return.\n     - Get the region for it: const MemRegion *Reg = getMemRegionFromExpr(DRE,\
  \ C).\n     - Lookup in RoundupResMap: if not present, return.\n\n     - Confirm\
  \ it is a zero-test on this var:\n       - Pattern A: UnaryOperator UO_LNot on that\
  \ var (allow embedded implicit casts).\n       - Pattern B: BinaryOperator:\n  \
  \       - op == with one side the var (via DRE/its cast), and the other side a literal\
  \ 0 (EvaluateExprToInt and check zero).\n         - Also accept 0 == var (commutative).\n\
  \       - (Keep it simple; skip other ops like <= for now to reduce false positives.)\n\
  \n     - If matched, report (see Reporting below). Return.\n\n- Notes:\n  - Use\
  \ EvaluateExprToInt helper to verify the other side is the literal 0 reliably through\
  \ casts/macros.\n  - This approach is robust even when roundup_pow_of_two is a macro,\
  \ thanks to ExprHasName.\n\nC) Optional: checkEndFunction / checkRegionChanges\n\
  - Not required. The state is path-sensitive and cleared per-path naturally. We only\
  \ manage RoundupResMap through checkBind.\n\n3) Reporting\n- When a match is found\
  \ in checkBranchCondition:\n  - Create a non-fatal error node: if (!N) N = C.generateNonFatalErrorNode();\n\
  \  - Prepare a short message:\n    - \u201CDo not detect overflow via !roundup_pow_of_two();\
  \ pre-validate the input first (UB on 32-bit).\u201D\n  - Use std::make_unique<PathSensitiveBugReport>(BugType,\
  \ Msg, N); add the Condition source range as the primary range.\n  - Emit with C.emitReport(...).\n\
  \n4) Heuristics and limits (to keep it simple and reduce noise)\n- Only trigger\
  \ on:\n  - Direct \u2018!\u2019 or \u2018== 0\u2019 checks.\n  - Either directly\
  \ on the call in the condition, or on a variable known to hold the roundup result\
  \ (from checkBind).\n- Do not attempt alias tracking for integers.\n- Do not attempt\
  \ to verify existence of a prior \u201Cpre-check\u201D guard; the zero-check pattern\
  \ is considered suspicious on its own because it is unreliable across 32-bit arches.\n\
  - Do not rely on target bit-width; the checker flags the anti-pattern independent\
  \ of compilation target.\n\n5) Utilities used\n- findSpecificTypeInChildren<T> to\
  \ find CallExpr and DeclRefExpr inside both the bind statement and the branch condition.\n\
  - ExprHasName(E, \"roundup_pow_of_two\", C) to robustly recognize the macro/function\
  \ name in source text.\n- getMemRegionFromExpr to map a DeclRefExpr to its region\
  \ key for RoundupResMap.\n- EvaluateExprToInt to confirm integer-constant zero in\
  \ comparisons.\n\n6) Summary of control flow\n- Assignment/Init from roundup_pow_of_two\
  \ => mark LHS region in RoundupResMap.\n- Any other assignment to that var => unmark.\n\
  - Branch condition:\n  - If it directly tests roundup_pow_of_two(...) for zero =>\
  \ warn.\n  - Else if it tests a var currently marked as roundup result for zero\
  \ => warn.\n\nReport message (short):\n- \u201Croundup_pow_of_two() overflow check\
  \ via zero is unreliable (UB on 32-bit); pre-validate the input before calling.\u201D"
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Map: track variables\
  \ that currently hold the result of roundup_pow_of_two(arg0).\n// Key: base MemRegion\
  \ of the LHS variable. Value: pointer to the 0th argument Expr.\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion*, const Expr*)\n\nnamespace {\nclass SAGenTestChecker\n  : public\
  \ Checker<\n        check::Bind,\n        check::BranchCondition> {\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this,\n         \
  \              \"Unreliable overflow check after roundup_pow_of_two\",\n       \
  \                \"Correctness\")) {}\n\n  void checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const;\n  void checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  static bool isZeroInteger(const\
  \ Expr *E, CheckerContext &C);\n  void report(const Stmt *S, CheckerContext &C)\
  \ const;\n  static const MemRegion *getBaseReg(const MemRegion *MR) {\n    return\
  \ MR ? MR->getBaseRegion() : nullptr;\n  }\n};\n\n// Check if expression evaluates\
  \ to the integer constant 0.\nbool SAGenTestChecker::isZeroInteger(const Expr *E,\
  \ CheckerContext &C) {\n  if (!E)\n    return false;\n  llvm::APSInt Res;\n  if\
  \ (!EvaluateExprToInt(Res, E, C))\n    return false;\n  return Res == 0;\n}\n\n\
  void SAGenTestChecker::report(const Stmt *S, CheckerContext &C) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"roundup_pow_of_two() overflow check via zero is unreliable\
  \ (UB on 32-bit); pre-validate the input before calling\",\n      N);\n  if (S)\n\
  \    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n// Track\
  \ assignments from roundup_pow_of_two(...) to a variable, and clear mapping on other\
  \ assignments.\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal /*Val*/, const Stmt\
  \ *S, CheckerContext &C) const {\n  const MemRegion *LHSReg = Loc.getAsRegion();\n\
  \  if (!LHSReg)\n    return;\n  LHSReg = getBaseReg(LHSReg);\n  if (!LHSReg)\n \
  \   return;\n\n  ProgramStateRef State = C.getState();\n\n  // Try to find a call\
  \ expression in this store statement.\n  const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(S);\n\
  \  if (CE && ExprHasName(CE, \"roundup_pow_of_two\", C)) {\n    // Record that LHSReg\
  \ holds the result of roundup_pow_of_two with this argument.\n    if (CE->getNumArgs()\
  \ >= 1) {\n      const Expr *Arg0 = CE->getArg(0);\n      State = State->set<RoundupResMap>(LHSReg,\
  \ Arg0);\n      C.addTransition(State);\n      return;\n    }\n  }\n\n  // Otherwise,\
  \ this assignment overrides previous mapping; remove if present.\n  if (State->contains<RoundupResMap>(LHSReg))\
  \ {\n    State = State->remove<RoundupResMap>(LHSReg);\n    C.addTransition(State);\n\
  \  }\n}\n\n// Detect branch conditions that test the result of roundup_pow_of_two()\
  \ for zero:\n// 1) Directly: if (!roundup_pow_of_two(x)) or if (roundup_pow_of_two(x)\
  \ == 0)\n// 2) Indirectly via a variable previously assigned from roundup_pow_of_two:\
  \ if (!var) or if (var == 0)\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE) {\n   \
  \ C.addTransition(State);\n    return;\n  }\n  CondE = CondE->IgnoreParenImpCasts();\n\
  \n  // Case 1a: if (!roundup_pow_of_two(...))\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *Sub = UO->getSubExpr();\n\
  \      // Direct-in-condition roundup_pow_of_two(...)\n      if (const CallExpr\
  \ *CallIn = findSpecificTypeInChildren<CallExpr>(Sub)) {\n        if (ExprHasName(CallIn,\
  \ \"roundup_pow_of_two\", C)) {\n          report(Condition, C);\n          return;\n\
  \        }\n      }\n      // Variable-based: if (!var)\n      const DeclRefExpr\
  \ *DRE = findSpecificTypeInChildren<DeclRefExpr>(Sub);\n      if (DRE) {\n     \
  \   const MemRegion *MR = getMemRegionFromExpr(DRE, C);\n        MR = getBaseReg(MR);\n\
  \        if (MR) {\n          const Expr *const *ArgPtr = State->get<RoundupResMap>(MR);\n\
  \          if (ArgPtr) {\n            report(Condition, C);\n            return;\n\
  \          }\n        }\n      }\n    }\n  }\n\n  // Case 1b and 2b: Binary compare\
  \ with zero: if (roundup_pow_of_two(...) == 0) or if (var == 0) or if (0 == var)\n\
  \  if (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    if (BO->getOpcode()\
  \ == BO_EQ) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  \
  \    const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n      // Direct call\
  \ on either side compared to 0\n      const CallExpr *CallLHS = dyn_cast<CallExpr>(LHS);\n\
  \      const CallExpr *CallRHS = dyn_cast<CallExpr>(RHS);\n\n      if (CallLHS &&\
  \ ExprHasName(CallLHS, \"roundup_pow_of_two\", C) && isZeroInteger(RHS, C)) {\n\
  \        report(Condition, C);\n        return;\n      }\n      if (CallRHS && ExprHasName(CallRHS,\
  \ \"roundup_pow_of_two\", C) && isZeroInteger(LHS, C)) {\n        report(Condition,\
  \ C);\n        return;\n      }\n\n      // Variable-based: var == 0 or 0 == var,\
  \ where var is previously recorded.\n      auto CheckVarZero = [&](const Expr *VarExpr,\
  \ const Expr *OtherExpr) -> bool {\n        const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(VarExpr);\n\
  \        if (!DRE)\n          return false;\n        const MemRegion *MR = getMemRegionFromExpr(DRE,\
  \ C);\n        MR = getBaseReg(MR);\n        if (!MR)\n          return false;\n\
  \        if (!State->contains<RoundupResMap>(MR))\n          return false;\n   \
  \     return isZeroInteger(OtherExpr, C);\n      };\n\n      if (CheckVarZero(LHS,\
  \ RHS) || CheckVarZero(RHS, LHS)) {\n        report(Condition, C);\n        return;\n\
  \      }\n    }\n  }\n\n  C.addTransition(State);\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects unreliable zero-check overflow\
  \ pattern after roundup_pow_of_two()\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
