_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 2e29b9971ac54dec88baa58856a230ec2f2a2dff
commit_type: Null-Pointer-Dereference
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/APSInt.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::BranchCondition> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  public:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Mismatched NULL check\
  \ after allocation\",\n                       \"Logic error\")) {}\n\n  void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\nprivate:\n  // Helper recognizers\n\
  \  bool isAllocatorCall(const CallExpr *CE, CheckerContext &C) const;\n\n  bool\
  \ isNullCheckTrueBranch(const Expr *Cond, const Expr *&CheckedPtrExpr,\n       \
  \                      CheckerContext &C) const;\n\n  bool getAssignedLHSFromStmt(const\
  \ Stmt *S, const Expr *&LHSExprOut,\n                              const CallExpr\
  \ *&AllocCallOut,\n                              CheckerContext &C) const;\n\n \
  \ bool regionEqual(const Expr *A, const Expr *B, CheckerContext &C) const;\n\n \
  \ bool thenBranchReturnsENOMEM(const IfStmt *IfS, CheckerContext &C) const;\n};\n\
  \n// Recognize allocator calls by name.\nbool SAGenTestChecker::isAllocatorCall(const\
  \ CallExpr *CE,\n                                       CheckerContext &C) const\
  \ {\n  if (!CE)\n    return false;\n\n  static const char *AllocNames[] = {\n  \
  \    \"kzalloc\",       \"kmalloc\",       \"kcalloc\",     \"kmalloc_array\",\n\
  \      \"kcalloc_array\", \"kzalloc_node\",  \"devm_kzalloc\",\"devm_kmalloc\",\n\
  \      \"devm_kcalloc\",\n  };\n\n  const Expr *CalleeE = CE->getCallee();\n  for\
  \ (const char *Name : AllocNames) {\n    if (CalleeE && ExprHasName(CalleeE, Name,\
  \ C))\n      return true;\n  }\n\n  // Fallback to direct callee identifier if available.\n\
  \  if (const FunctionDecl *FD = CE->getDirectCallee()) {\n    StringRef N = FD->getName();\n\
  \    for (const char *Name : AllocNames) {\n      if (N.equals(Name))\n        return\
  \ true;\n    }\n  }\n\n  return false;\n}\n\n// Determine if the condition's true\
  \ branch corresponds to a NULL check.\n// Extract the pointer expression being checked\
  \ for NULL.\nbool SAGenTestChecker::isNullCheckTrueBranch(const Expr *Cond,\n  \
  \                                           const Expr *&CheckedPtrExpr,\n     \
  \                                        CheckerContext &C) const {\n  if (!Cond)\n\
  \    return false;\n\n  const ASTContext &ACtx = C.getASTContext();\n  Cond = Cond->IgnoreParenImpCasts();\n\
  \n  // if (!E)  ==> true branch when E is NULL\n  if (const auto *UO = dyn_cast<UnaryOperator>(Cond))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      CheckedPtrExpr = UO->getSubExpr()->IgnoreParenImpCasts();\n\
  \      return true;\n    }\n    return false;\n  }\n\n  // if (E1 == E2) where the\
  \ other side is 0 or NULL\n  if (const auto *BO = dyn_cast<BinaryOperator>(Cond))\
  \ {\n    if (BO->getOpcode() != BO_EQ)\n      return false;\n\n    const Expr *LHS\
  \ = BO->getLHS()->IgnoreParenImpCasts();\n    const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \n    auto IsNullish = [&](const Expr *E) -> bool {\n      if (!E)\n        return\
  \ false;\n      // Prefer Clang's check for null pointer constants.\n      if (E->isNullPointerConstant(ACtx,\
  \ Expr::NPC_ValueDependentIsNull))\n        return true;\n\n      // Try integer\
  \ evaluation for literal 0\n      llvm::APSInt Val;\n      if (EvaluateExprToInt(Val,\
  \ E, C))\n        return Val == 0;\n\n      // Check textual \"NULL\"\n      if\
  \ (ExprHasName(E, \"NULL\", C))\n        return true;\n\n      return false;\n \
  \   };\n\n    bool LIsNull = IsNullish(LHS);\n    bool RIsNull = IsNullish(RHS);\n\
  \n    if (LIsNull ^ RIsNull) {\n      CheckedPtrExpr = LIsNull ? RHS : LHS;\n  \
  \    return true;\n    }\n  }\n\n  return false;\n}\n\n// From a statement, extract\
  \ \"LHS = allocator_call(...)\" or \"T LHS = allocator_call(...);\"\nbool SAGenTestChecker::getAssignedLHSFromStmt(const\
  \ Stmt *S,\n                                              const Expr *&LHSExprOut,\n\
  \                                              const CallExpr *&AllocCallOut,\n\
  \                                              CheckerContext &C) const {\n  LHSExprOut\
  \ = nullptr;\n  AllocCallOut = nullptr;\n\n  if (!S)\n    return false;\n\n  //\
  \ Case 1: assignment statement\n  if (const auto *BO = dyn_cast<BinaryOperator>(S))\
  \ {\n    if (BO->getOpcode() == BO_Assign) {\n      const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \      if (const auto *CE = dyn_cast<CallExpr>(RHS)) {\n        if (isAllocatorCall(CE,\
  \ C)) {\n          LHSExprOut = BO->getLHS()->IgnoreParenImpCasts();\n         \
  \ AllocCallOut = CE;\n          return true;\n        }\n      }\n    }\n  }\n\n\
  \  // Case 2: declaration with initializer\n  if (const auto *DS = dyn_cast<DeclStmt>(S))\
  \ {\n    for (auto It = DS->decl_begin(); It != DS->decl_end(); ++It) {\n      if\
  \ (const auto *VD = dyn_cast<VarDecl>(*It)) {\n        const Expr *Init = VD->getInit();\n\
  \        if (!Init)\n          continue;\n        Init = Init->IgnoreParenImpCasts();\n\
  \        if (const auto *CE = dyn_cast<CallExpr>(Init)) {\n          if (isAllocatorCall(CE,\
  \ C)) {\n            // Create a DeclRefExpr for VD to use in region comparison\n\
  \            ASTContext &Ctx = C.getASTContext();\n            // Use a minimal\
  \ constructor for DeclRefExpr\n            LHSExprOut = DeclRefExpr::Create(\n \
  \               Ctx, NestedNameSpecifierLoc(), SourceLocation(), VD,\n         \
  \       /*RefersToEnclosingVariableOrCapture*/ false, VD->getLocation(),\n     \
  \           VD->getType(), VK_LValue);\n            AllocCallOut = CE;\n       \
  \     return true;\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n\
  }\n\n// Compare whether two expressions refer to the same base memory region.\n\
  bool SAGenTestChecker::regionEqual(const Expr *A, const Expr *B,\n             \
  \                      CheckerContext &C) const {\n  if (!A || !B)\n    return false;\n\
  \n  const MemRegion *RA = getMemRegionFromExpr(A, C);\n  const MemRegion *RB = getMemRegionFromExpr(B,\
  \ C);\n  if (!RA || !RB)\n    return false;\n\n  RA = RA->getBaseRegion();\n  RB\
  \ = RB->getBaseRegion();\n  if (!RA || !RB)\n    return false;\n\n  return RA ==\
  \ RB;\n}\n\n// Check if the then-branch of the if-stmt contains a return that returns\
  \ ENOMEM.\nbool SAGenTestChecker::thenBranchReturnsENOMEM(const IfStmt *IfS,\n \
  \                                              CheckerContext &C) const {\n  if\
  \ (!IfS)\n    return false;\n\n  const Stmt *ThenS = IfS->getThen();\n  if (!ThenS)\n\
  \    return false;\n\n  const ReturnStmt *RS = findSpecificTypeInChildren<ReturnStmt>(ThenS);\n\
  \  if (!RS)\n    return false;\n\n  const Expr *RetE = RS->getRetValue();\n  if\
  \ (!RetE)\n    return false;\n\n  // Accept either ENOMEM or -ENOMEM textually.\n\
  \  if (ExprHasName(RetE, \"ENOMEM\", C))\n    return true;\n\n  return false;\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\n      \
  \                                      CheckerContext &C) const {\n  if (!Condition)\n\
  \    return;\n\n  // Find the containing IfStmt.\n  const IfStmt *IfS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IfS)\n    return;\n\n  // Ensure we are analyzing this If's condition\
  \ (avoid nested conditions confusion).\n  const Expr *IfCond = dyn_cast<Expr>(IfS->getCond());\n\
  \  if (!IfCond)\n    return;\n\n  const Expr *CheckedPtrExpr = nullptr;\n  if (!isNullCheckTrueBranch(IfCond,\
  \ CheckedPtrExpr, C))\n    return;\n\n  // Only consider cases where the true-branch\
  \ returns ENOMEM (to reduce false positives).\n  if (!thenBranchReturnsENOMEM(IfS,\
  \ C))\n    return;\n\n  // Find the immediate previous statement in the same compound\
  \ statement.\n  const CompoundStmt *ParentCS = findSpecificTypeInParents<CompoundStmt>(IfS,\
  \ C);\n  if (!ParentCS)\n    return;\n\n  const Stmt *Prev = nullptr;\n  const Stmt\
  \ *Target = IfS;\n  for (const Stmt *Child : ParentCS->body()) {\n    if (Child\
  \ == Target)\n      break;\n    Prev = Child;\n  }\n\n  if (!Prev)\n    return;\n\
  \n  // Extract LHS assigned by allocator call from the previous statement.\n  const\
  \ Expr *LHSExpr = nullptr;\n  const CallExpr *AllocCall = nullptr;\n  if (!getAssignedLHSFromStmt(Prev,\
  \ LHSExpr, AllocCall, C))\n    return;\n\n  // If the checked expression is the\
  \ same region as allocated LHS, it's fine.\n  if (regionEqual(CheckedPtrExpr, LHSExpr,\
  \ C))\n    return;\n\n  // Otherwise, report: allocated into X but checked Y.\n\
  \  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n\
  \  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Mismatched NULL\
  \ check after allocation\", N);\n\n  // Highlight the allocation target and the\
  \ checked expression.\n  if (AllocCall)\n    R->addRange(AllocCall->getSourceRange());\n\
  \  if (LHSExpr)\n    R->addRange(LHSExpr->getSourceRange());\n  if (CheckedPtrExpr)\n\
  \    R->addRange(CheckedPtrExpr->getSourceRange());\n\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects checking a different pointer than the one just allocated (missed\
  \ NULL check).\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\narm64/sme: Fix NULL check after kzalloc\n\nFix following\
  \ coccicheck error:\n./arch/arm64/kernel/process.c:322:2-23: alloc with no test,\
  \ possible model on line 326\n\nHere should be dst->thread.sve_state.\n\nFixes:\
  \ 8bd7f91c03d8 (\"arm64/sme: Implement traps and syscall handling for SME\")\nSigned-off-by:\
  \ Wan Jiabing <wanjiabing@vivo.com>\nReviwed-by: Mark Brown <broonie@kernel.org>\n\
  Link: https://lore.kernel.org/r/20220426113054.630983-1-wanjiabing@vivo.com\nSigned-off-by:\
  \ Catalin Marinas <catalin.marinas@arm.com>\n\n## Buggy Code\n\n```c\n// Function:\
  \ arch_dup_task_struct in arch/arm64/kernel/process.c\nint arch_dup_task_struct(struct\
  \ task_struct *dst, struct task_struct *src)\n{\n\tif (current->mm)\n\t\tfpsimd_preserve_current_state();\n\
  \t*dst = *src;\n\n\t/* We rely on the above assignment to initialize dst's thread_flags:\
  \ */\n\tBUILD_BUG_ON(!IS_ENABLED(CONFIG_THREAD_INFO_IN_TASK));\n\n\t/*\n\t * Detach\
  \ src's sve_state (if any) from dst so that it does not\n\t * get erroneously used\
  \ or freed prematurely.  dst's copies\n\t * will be allocated on demand later on\
  \ if dst uses SVE.\n\t * For consistency, also clear TIF_SVE here: this could be\
  \ done\n\t * later in copy_process(), but to avoid tripping up future\n\t * maintainers\
  \ it is best not to leave TIF flags and buffers in\n\t * an inconsistent state,\
  \ even temporarily.\n\t */\n\tdst->thread.sve_state = NULL;\n\tclear_tsk_thread_flag(dst,\
  \ TIF_SVE);\n\n\t/*\n\t * In the unlikely event that we create a new thread with\
  \ ZA\n\t * enabled we should retain the ZA state so duplicate it here.\n\t * This\
  \ may be shortly freed if we exec() or if CLONE_SETTLS\n\t * but it's simpler to\
  \ do it here. To avoid confusing the rest\n\t * of the code ensure that we have\
  \ a sve_state allocated\n\t * whenever za_state is allocated.\n\t */\n\tif (thread_za_enabled(&src->thread))\
  \ {\n\t\tdst->thread.sve_state = kzalloc(sve_state_size(src),\n\t\t\t\t\t\tGFP_KERNEL);\n\
  \t\tif (!dst->thread.za_state)\n\t\t\treturn -ENOMEM;\n\t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n\t\t\t\t\t       za_state_size(src),\n\t\t\t\t\
  \t       GFP_KERNEL);\n\t\tif (!dst->thread.za_state) {\n\t\t\tkfree(dst->thread.sve_state);\n\
  \t\t\tdst->thread.sve_state = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\
  \tdst->thread.za_state = NULL;\n\t\tclear_tsk_thread_flag(dst, TIF_SME);\n\t}\n\n\
  \t/* clear any pending asynchronous tag fault raised by the parent */\n\tclear_tsk_thread_flag(dst,\
  \ TIF_MTE_ASYNC_FAULT);\n\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c\nindex 99c293513817..9734c9fb1a32\
  \ 100644\n--- a/arch/arm64/kernel/process.c\n+++ b/arch/arm64/kernel/process.c\n\
  @@ -321,7 +321,7 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct\
  \ *src)\n \tif (thread_za_enabled(&src->thread)) {\n \t\tdst->thread.sve_state =\
  \ kzalloc(sve_state_size(src),\n \t\t\t\t\t\tGFP_KERNEL);\n-\t\tif (!dst->thread.za_state)\n\
  +\t\tif (!dst->thread.sve_state)\n \t\t\treturn -ENOMEM;\n \t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n \t\t\t\t\t       za_state_size(src),\n```\n"
pattern: "## Bug Pattern\n\nAfter allocating memory into one pointer/field, the code\
  \ checks a different pointer/field for NULL. This mis-validated allocation causes\
  \ allocation failures to go unnoticed (or incorrect early returns), leading to invariant\
  \ violations or NULL dereferences later.\n\nExample:\np = kzalloc(size, GFP_KERNEL);\n\
  if (!q)  // BUG: should check p, not q\n    return -ENOMEM;"
plan: "Plan\n\n1. Program state\n- No custom program state is required. We can detect\
  \ this bug pattern purely from the local AST structure around an if condition.\n\
  \n2. Target callbacks\n- Use only checkBranchCondition.\n\n3. Helper recognizers\n\
  - isAllocatorCall(const CallExpr* CE):\n  - Return true if callee name is one of:\n\
  \    - kzalloc, kmalloc, kcalloc, kmalloc_array, kcalloc_array, kzalloc_node\n \
  \   - devm_kzalloc, devm_kmalloc, devm_kcalloc (optional but recommended)\n  - Get\
  \ callee name via CE->getDirectCallee() or callee identifier and compare strings.\n\
  - isNullCheckTrueBranch(const Expr* Cond, const Expr*& CheckedPtrExpr, CheckerContext&\
  \ C):\n  - Extracts the pointer being tested for null and indicates that the true-branch\
  \ corresponds to \u201Cpointer is null.\u201D\n  - Accepted forms:\n    - UnaryOperator\
  \ \u2018!\u2019: if (!E) => true when E is null. Set CheckedPtrExpr = E.\n    -\
  \ BinaryOperator \u2018==\u2019: if (E1 == E2) or (E2 == E1) where other side is\
  \ 0 or NULL (use EvaluateExprToInt for 0 and ExprHasName for \u201CNULL\u201D).\
  \ Set CheckedPtrExpr to the pointer side.\n  - Reject/return false for:\n    - \u2018\
  !=\u2019 comparisons\n    - Plain \u201Cif (p)\u201D or other non-nullness tests\n\
  - getAssignedLHSFromStmt(const Stmt* S, const Expr*& LHSExprOut, const CallExpr*&\
  \ AllocCallOut):\n  - Handle two immediate-previous-statement cases:\n    - BinaryOperator\
  \ assignment:\n      - S is BinaryOperator with opcode BO_Assign.\n      - RHS is\
  \ CallExpr and isAllocatorCall(RHS) true.\n      - Set LHSExprOut = LHS, AllocCallOut\
  \ = RHS.\n    - DeclStmt with init:\n      - S is DeclStmt, get first VarDecl VD\
  \ with initializer.\n      - Init is CallExpr and isAllocatorCall(Init) true.\n\
  \      - LHSExprOut = a synthesized DeclRefExpr to VD (or just use the VD in region\
  \ comparison).\n      - AllocCallOut = the initializer CallExpr.\n  - Return true\
  \ only if an allocator call is found on RHS/init.\n- regionEqual(const Expr* A,\
  \ const Expr* B, CheckerContext& C):\n  - Use getMemRegionFromExpr(A, C) and getMemRegionFromExpr(B,\
  \ C).\n  - Return true if both regions are non-null and equal.\n- thenBranchReturnsENOMEM(const\
  \ IfStmt* IfS, CheckerContext& C):\n  - Locate ReturnStmt inside IfS->getThen()\
  \ using findSpecificTypeInChildren<ReturnStmt>.\n  - If no ReturnStmt, return false.\n\
  \  - If Return has an expression, check:\n    - ExprHasName(ReturnExpr, \"ENOMEM\"\
  , C) is true.\n  - If true, return true; else return false.\n\n4. Core detection\
  \ logic (checkBranchCondition)\n- Input: const Stmt* Condition\n- Steps:\n  1) Ascend\
  \ to the containing IfStmt using findSpecificTypeInParents<IfStmt>(Condition, C).\
  \ If not found, return.\n  2) Ensure the IfStmt\u2019s true-branch corresponds to\
  \ a null check:\n     - Call isNullCheckTrueBranch(IfS->getCond(), CheckedPtrExpr,\
  \ C). If false, return.\n  3) Ensure the true branch returns -ENOMEM (reduces false\
  \ positives):\n     - If not thenBranchReturnsENOMEM(IfS, C), return.\n  4) Find\
  \ the immediate previous statement in the same CompoundStmt:\n     - Ascend to the\
  \ parent CompoundStmt of the IfStmt using findSpecificTypeInParents<CompoundStmt>(IfS,\
  \ C).\n     - Iterate its body to locate the IfStmt and get the preceding Stmt (prev).\n\
  \     - If no previous statement or parent not found, return.\n  5) From the previous\
  \ statement, extract an allocator assignment:\n     - Use getAssignedLHSFromStmt(prev,\
  \ LHSExpr, AllocCall).\n     - If no allocator assignment found, return.\n  6) Compare\
  \ the expressions:\n     - If regionEqual(CheckedPtrExpr, LHSExpr, C) is true, it\u2019\
  s a correct null check; do nothing.\n     - Otherwise, report a bug: the code checked\
  \ a different pointer than the one just allocated.\n- Reporting:\n  - Create a non-fatal\
  \ error node via C.generateNonFatalErrorNode().\n  - Create a PathSensitiveBugReport\
  \ with a short message like:\n    - \u201CMismatched NULL check: allocated into\
  \ X but checked Y\u201D\n  - Optionally highlight both the LHSExpr (allocation target)\
  \ and CheckedPtrExpr (checked expression) source ranges if available.\n\n5. Notes\
  \ and simplifications\n- This checker focuses on the immediate pattern:\n  - An\
  \ allocator assignment in the statement immediately preceding an if.\n  - The if\
  \ condition\u2019s true branch tests for \u201Cis NULL\u201D and returns -ENOMEM.\n\
  - This narrow window keeps the checker simple and effective for the target bug pattern\
  \ with low false positives.\n- If getMemRegionFromExpr fails for either expression,\
  \ do not attempt text-based comparison (to avoid false positives); simply skip."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/APSInt.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n#include <memory>\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Mismatched\
  \ NULL check after allocation\",\n                       \"Logic error\")) {}\n\n\
  \  void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\n\
  private:\n  // Helper recognizers\n  bool isAllocatorCall(const CallExpr *CE, CheckerContext\
  \ &C) const;\n\n  bool isNullCheckTrueBranch(const Expr *Cond, const Expr *&CheckedPtrExpr,\n\
  \                             CheckerContext &C) const;\n\n  bool getAssignedLHSFromStmt(const\
  \ Stmt *S, const Expr *&LHSExprOut,\n                              const CallExpr\
  \ *&AllocCallOut,\n                              CheckerContext &C) const;\n\n \
  \ bool regionEqual(const Expr *A, const Expr *B, CheckerContext &C) const;\n\n \
  \ bool thenBranchReturnsENOMEM(const IfStmt *IfS, CheckerContext &C) const;\n};\n\
  \n// Recognize allocator calls by name.\nbool SAGenTestChecker::isAllocatorCall(const\
  \ CallExpr *CE,\n                                       CheckerContext &C) const\
  \ {\n  if (!CE)\n    return false;\n\n  static const char *AllocNames[] = {\n  \
  \    \"kzalloc\",       \"kmalloc\",       \"kcalloc\",     \"kmalloc_array\",\n\
  \      \"kcalloc_array\", \"kzalloc_node\",  \"devm_kzalloc\",\"devm_kmalloc\",\n\
  \      \"devm_kcalloc\",\n  };\n\n  const Expr *CalleeE = CE->getCallee();\n  for\
  \ (const char *Name : AllocNames) {\n    if (CalleeE && ExprHasName(CalleeE, Name,\
  \ C))\n      return true;\n  }\n\n  // Fallback to direct callee identifier if available.\n\
  \  if (const FunctionDecl *FD = CE->getDirectCallee()) {\n    StringRef N = FD->getName();\n\
  \    for (const char *Name : AllocNames) {\n      if (N.equals(Name))\n        return\
  \ true;\n    }\n  }\n\n  return false;\n}\n\n// Determine if the condition's true\
  \ branch corresponds to a NULL check.\n// Extract the pointer expression being checked\
  \ for NULL.\nbool SAGenTestChecker::isNullCheckTrueBranch(const Expr *Cond,\n  \
  \                                           const Expr *&CheckedPtrExpr,\n     \
  \                                        CheckerContext &C) const {\n  if (!Cond)\n\
  \    return false;\n\n  ASTContext &ACtx = C.getASTContext();\n  Cond = Cond->IgnoreParenImpCasts();\n\
  \n  // if (!E)  ==> true branch when E is NULL\n  if (const auto *UO = dyn_cast<UnaryOperator>(Cond))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      CheckedPtrExpr = UO->getSubExpr()->IgnoreParenImpCasts();\n\
  \      return true;\n    }\n    return false;\n  }\n\n  // if (E1 == E2) where the\
  \ other side is 0 or NULL\n  if (const auto *BO = dyn_cast<BinaryOperator>(Cond))\
  \ {\n    if (BO->getOpcode() != BO_EQ)\n      return false;\n\n    const Expr *LHS\
  \ = BO->getLHS()->IgnoreParenImpCasts();\n    const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \n    auto IsNullish = [&](const Expr *E) -> bool {\n      if (!E)\n        return\
  \ false;\n      // Prefer Clang's check for null pointer constants.\n      if (E->isNullPointerConstant(ACtx,\
  \ Expr::NPC_ValueDependentIsNull))\n        return true;\n\n      // Try integer\
  \ evaluation for literal 0\n      llvm::APSInt Val;\n      if (EvaluateExprToInt(Val,\
  \ E, C))\n        return Val == 0;\n\n      // Check textual \"NULL\"\n      if\
  \ (ExprHasName(E, \"NULL\", C))\n        return true;\n\n      return false;\n \
  \   };\n\n    bool LIsNull = IsNullish(LHS);\n    bool RIsNull = IsNullish(RHS);\n\
  \n    if (LIsNull ^ RIsNull) {\n      CheckedPtrExpr = LIsNull ? RHS : LHS;\n  \
  \    return true;\n    }\n  }\n\n  return false;\n}\n\n// From a statement, extract\
  \ \"LHS = allocator_call(...)\" or \"T LHS = allocator_call(...);\"\nbool SAGenTestChecker::getAssignedLHSFromStmt(const\
  \ Stmt *S,\n                                              const Expr *&LHSExprOut,\n\
  \                                              const CallExpr *&AllocCallOut,\n\
  \                                              CheckerContext &C) const {\n  LHSExprOut\
  \ = nullptr;\n  AllocCallOut = nullptr;\n\n  if (!S)\n    return false;\n\n  //\
  \ Case 1: assignment statement\n  if (const auto *BO = dyn_cast<BinaryOperator>(S))\
  \ {\n    if (BO->getOpcode() == BO_Assign) {\n      const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \      if (const auto *CE = dyn_cast<CallExpr>(RHS)) {\n        if (isAllocatorCall(CE,\
  \ C)) {\n          LHSExprOut = BO->getLHS()->IgnoreParenImpCasts();\n         \
  \ AllocCallOut = CE;\n          return true;\n        }\n      }\n    }\n  }\n\n\
  \  // Case 2: declaration with initializer\n  if (const auto *DS = dyn_cast<DeclStmt>(S))\
  \ {\n    for (auto It = DS->decl_begin(); It != DS->decl_end(); ++It) {\n      if\
  \ (const auto *VD = dyn_cast<VarDecl>(*It)) {\n        const Expr *Init = VD->getInit();\n\
  \        if (!Init)\n          continue;\n        Init = Init->IgnoreParenImpCasts();\n\
  \        if (const auto *CE = dyn_cast<CallExpr>(Init)) {\n          if (isAllocatorCall(CE,\
  \ C)) {\n            // Create a DeclRefExpr for VD to use in region comparison\n\
  \            ASTContext &Ctx = C.getASTContext();\n            auto *NonConstVD\
  \ = const_cast<VarDecl *>(VD);\n            // Use a minimal constructor for DeclRefExpr\n\
  \            LHSExprOut = DeclRefExpr::Create(\n                Ctx, NestedNameSpecifierLoc(),\
  \ SourceLocation(), NonConstVD,\n                /*RefersToEnclosingVariableOrCapture*/\
  \ false, VD->getLocation(),\n                VD->getType(), VK_LValue);\n      \
  \      AllocCallOut = CE;\n            return true;\n          }\n        }\n  \
  \    }\n    }\n  }\n\n  return false;\n}\n\n// Compare whether two expressions refer\
  \ to the same base memory region.\nbool SAGenTestChecker::regionEqual(const Expr\
  \ *A, const Expr *B,\n                                   CheckerContext &C) const\
  \ {\n  if (!A || !B)\n    return false;\n\n  const MemRegion *RA = getMemRegionFromExpr(A,\
  \ C);\n  const MemRegion *RB = getMemRegionFromExpr(B, C);\n  if (!RA || !RB)\n\
  \    return false;\n\n  RA = RA->getBaseRegion();\n  RB = RB->getBaseRegion();\n\
  \  if (!RA || !RB)\n    return false;\n\n  return RA == RB;\n}\n\n// Check if the\
  \ then-branch of the if-stmt contains a return that returns ENOMEM.\nbool SAGenTestChecker::thenBranchReturnsENOMEM(const\
  \ IfStmt *IfS,\n                                               CheckerContext &C)\
  \ const {\n  if (!IfS)\n    return false;\n\n  const Stmt *ThenS = IfS->getThen();\n\
  \  if (!ThenS)\n    return false;\n\n  const ReturnStmt *RS = findSpecificTypeInChildren<ReturnStmt>(ThenS);\n\
  \  if (!RS)\n    return false;\n\n  const Expr *RetE = RS->getRetValue();\n  if\
  \ (!RetE)\n    return false;\n\n  // Accept either ENOMEM or -ENOMEM textually.\n\
  \  if (ExprHasName(RetE, \"ENOMEM\", C))\n    return true;\n\n  return false;\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\n      \
  \                                      CheckerContext &C) const {\n  if (!Condition)\n\
  \    return;\n\n  // Find the containing IfStmt.\n  const IfStmt *IfS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IfS)\n    return;\n\n  // Ensure we are analyzing this If's condition\
  \ (avoid nested conditions confusion).\n  const Expr *IfCond = dyn_cast<Expr>(IfS->getCond());\n\
  \  if (!IfCond)\n    return;\n\n  const Expr *CheckedPtrExpr = nullptr;\n  if (!isNullCheckTrueBranch(IfCond,\
  \ CheckedPtrExpr, C))\n    return;\n\n  // Only consider cases where the true-branch\
  \ returns ENOMEM (to reduce false positives).\n  if (!thenBranchReturnsENOMEM(IfS,\
  \ C))\n    return;\n\n  // Find the immediate previous statement in the same compound\
  \ statement.\n  const CompoundStmt *ParentCS = findSpecificTypeInParents<CompoundStmt>(IfS,\
  \ C);\n  if (!ParentCS)\n    return;\n\n  const Stmt *Prev = nullptr;\n  const Stmt\
  \ *Target = IfS;\n  for (const Stmt *Child : ParentCS->body()) {\n    if (Child\
  \ == Target)\n      break;\n    Prev = Child;\n  }\n\n  if (!Prev)\n    return;\n\
  \n  // Extract LHS assigned by allocator call from the previous statement.\n  const\
  \ Expr *LHSExpr = nullptr;\n  const CallExpr *AllocCall = nullptr;\n  if (!getAssignedLHSFromStmt(Prev,\
  \ LHSExpr, AllocCall, C))\n    return;\n\n  // If the checked expression is the\
  \ same region as allocated LHS, it's fine.\n  if (regionEqual(CheckedPtrExpr, LHSExpr,\
  \ C))\n    return;\n\n  // Otherwise, report: allocated into X but checked Y.\n\
  \  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n\
  \  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Mismatched NULL\
  \ check after allocation\", N);\n\n  // Highlight the allocation target and the\
  \ checked expression.\n  if (AllocCall)\n    R->addRange(AllocCall->getSourceRange());\n\
  \  if (LHSExpr)\n    R->addRange(LHSExpr->getSourceRange());\n  if (CheckedPtrExpr)\n\
  \    R->addRange(CheckedPtrExpr->getSourceRange());\n\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects checking a different pointer than the one just allocated (missed\
  \ NULL check).\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
