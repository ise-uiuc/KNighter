_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: a97de7bff13b1cc825c1b1344eaed8d6c2d3e695
commit_type: Misuse
index: 4
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"\
  llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/APInt.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// Program state: track per-path learned\
  \ lower bounds for 'optlen' parameters.\nREGISTER_MAP_WITH_PROGRAMSTATE(OptlenLBMap,\
  \ const ParmVarDecl*, uint64_t)\n\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<\n    check::BranchCondition,\n    check::PreCall\n> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unchecked\
  \ optlen in setsockopt copy\", \"API Misuse\")) {}\n\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n      void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n   private:\n      // Helpers\n      static\
  \ const ParmVarDecl *getOptlenParm(const FunctionDecl *FD);\n      static ProgramStateRef\
  \ setLB(ProgramStateRef S, const ParmVarDecl *P, uint64_t NewLB);\n      static\
  \ bool tryEvalToConst(const Expr *E, uint64_t &Out, CheckerContext &C);\n\n    \
  \  // Core logic to update LB for true/false branches\n      void processOptlenCompareBranch(const\
  \ Expr *CondE,\n                                      const ParmVarDecl *OptlenParm,\n\
  \                                      CheckerContext &C) const;\n};\n\n// Return\
  \ the 'optlen' ParmVarDecl* if exists in the current function, else nullptr.\nconst\
  \ ParmVarDecl *SAGenTestChecker::getOptlenParm(const FunctionDecl *FD) {\n  if (!FD)\n\
  \    return nullptr;\n  for (const ParmVarDecl *P : FD->parameters()) {\n    if\
  \ (P && P->getName() == \"optlen\")\n      return P;\n  }\n  return nullptr;\n}\n\
  \n// Update the lower bound for an 'optlen' parameter to max(old, NewLB).\nProgramStateRef\
  \ SAGenTestChecker::setLB(ProgramStateRef S, const ParmVarDecl *P, uint64_t NewLB)\
  \ {\n  if (!S || !P)\n    return S;\n  if (const uint64_t *Old = S->get<OptlenLBMap>(P))\
  \ {\n    uint64_t M = (*Old > NewLB) ? *Old : NewLB;\n    if (M != *Old)\n     \
  \ return S->set<OptlenLBMap>(P, M);\n    return S;\n  }\n  return S->set<OptlenLBMap>(P,\
  \ NewLB);\n}\n\n// Evaluate expression to constant uint64_t if possible.\nbool SAGenTestChecker::tryEvalToConst(const\
  \ Expr *E, uint64_t &Out, CheckerContext &C) {\n  if (!E)\n    return false;\n \
  \ llvm::APSInt Res;\n  if (EvaluateExprToInt(Res, E, C)) {\n    Out = Res.getZExtValue();\n\
  \    return true;\n  }\n  return false;\n}\n\n// Analyze condition and create two\
  \ transitions with updated LB when possible.\nvoid SAGenTestChecker::processOptlenCompareBranch(const\
  \ Expr *CondE,\n                                                  const ParmVarDecl\
  \ *OptlenParm,\n                                                  CheckerContext\
  \ &C) const {\n  if (!CondE || !OptlenParm)\n    return;\n\n  const auto *BO = dyn_cast<BinaryOperator>(CondE->IgnoreParenCasts());\n\
  \  if (!BO)\n    return;\n\n  BinaryOperator::Opcode Op = BO->getOpcode();\n  //\
  \ Only consider comparison/equality ops.\n  bool IsCompare =\n      Op == BO_LT\
  \ || Op == BO_LE || Op == BO_GT || Op == BO_GE || Op == BO_EQ;\n  if (!IsCompare)\n\
  \    return;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n  const Expr\
  \ *RHS = BO->getRHS()->IgnoreParenCasts();\n\n  // Identify where optlen is.\n \
  \ const DeclRefExpr *LHSd = dyn_cast<DeclRefExpr>(LHS);\n  const DeclRefExpr *RHSd\
  \ = dyn_cast<DeclRefExpr>(RHS);\n\n  bool LHSIsOptlen = false, RHSIsOptlen = false;\n\
  \  if (LHSd) {\n    if (const auto *PD = dyn_cast<ParmVarDecl>(LHSd->getDecl()))\n\
  \      LHSIsOptlen = (PD == OptlenParm);\n  }\n  if (RHSd) {\n    if (const auto\
  \ *PD = dyn_cast<ParmVarDecl>(RHSd->getDecl()))\n      RHSIsOptlen = (PD == OptlenParm);\n\
  \  }\n  if (!LHSIsOptlen && !RHSIsOptlen)\n    return;\n\n  // Evaluate the non-optlen\
  \ side to a constant.\n  uint64_t K = 0;\n  const Expr *Other = LHSIsOptlen ? RHS\
  \ : (RHSIsOptlen ? LHS : nullptr);\n  if (!Other)\n    return;\n  if (!tryEvalToConst(Other,\
  \ K, C))\n    return;\n\n  ProgramStateRef State = C.getState();\n  SVal CondV =\
  \ State->getSVal(CondE, C.getLocationContext());\n  Optional<DefinedOrUnknownSVal>\
  \ DV = CondV.getAs<DefinedOrUnknownSVal>();\n  if (!DV)\n    return;\n\n  ProgramStateRef\
  \ StTrue, StFalse;\n  std::tie(StTrue, StFalse) = State->assume(*DV);\n\n  // For\
  \ each branch, compute LB updates based on the form of comparison.\n  auto updateForBranch\
  \ = [&](ProgramStateRef SIn, bool IsTrue) -> ProgramStateRef {\n    if (!SIn)\n\
  \      return nullptr;\n\n    // Helper lambda to set LB.\n    auto set = [&](uint64_t\
  \ LB) -> ProgramStateRef {\n      return setLB(SIn, OptlenParm, LB);\n    };\n\n\
  \    switch (Op) {\n      case BO_LT:\n        if (LHSIsOptlen) {\n          //\
  \ optlen < K\n          // True: no LB. False: optlen >= K -> LB=K\n          return\
  \ IsTrue ? SIn : set(K);\n        } else {\n          // K < optlen\n          //\
  \ True: optlen > K -> LB=K+1; False: no LB\n          return IsTrue ? set(K + 1)\
  \ : SIn;\n        }\n      case BO_LE:\n        if (LHSIsOptlen) {\n          //\
  \ optlen <= K\n          // True: no LB; False: optlen > K -> LB=K+1\n         \
  \ return IsTrue ? SIn : set(K + 1);\n        } else {\n          // K <= optlen\n\
  \          // True: optlen >= K -> LB=K; False: no LB\n          return IsTrue ?\
  \ set(K) : SIn;\n        }\n      case BO_GT:\n        if (LHSIsOptlen) {\n    \
  \      // optlen > K\n          // True: LB=K+1; False: no LB\n          return\
  \ IsTrue ? set(K + 1) : SIn;\n        } else {\n          // K > optlen\n      \
  \    // True: no LB; False: optlen >= K -> LB=K\n          return IsTrue ? SIn :\
  \ set(K);\n        }\n      case BO_GE:\n        if (LHSIsOptlen) {\n          //\
  \ optlen >= K\n          // True: LB=K; False: no LB\n          return IsTrue ?\
  \ set(K) : SIn;\n        } else {\n          // K >= optlen\n          // True:\
  \ no LB; False: optlen > K -> LB=K+1\n          return IsTrue ? SIn : set(K + 1);\n\
  \        }\n      case BO_EQ:\n        // optlen == K OR K == optlen\n        //\
  \ True: LB=K; False: no LB\n        return IsTrue ? set(K) : SIn;\n      default:\n\
  \        break;\n    }\n    return SIn;\n  };\n\n  ProgramStateRef NT = updateForBranch(StTrue,\
  \ /*IsTrue=*/true);\n  ProgramStateRef NF = updateForBranch(StFalse, /*IsTrue=*/false);\n\
  \n  // Add transitions for the branches we refined. If neither updated, keep original.\n\
  \  bool Added = false;\n  if (NT && NT != StTrue) { C.addTransition(NT); Added =\
  \ true; }\n  if (NF && NF != StFalse) { C.addTransition(NF); Added = true; }\n \
  \ if (!Added) {\n    // No refinement possible; continue with current state.\n \
  \   C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  const auto *CondE = dyn_cast<Expr>(Condition);\n\
  \  if (!CondE) {\n    C.addTransition(C.getState());\n    return;\n  }\n\n  const\
  \ auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());\n\
  \  const ParmVarDecl *OptlenParm = getOptlenParm(FD);\n  if (!OptlenParm) {\n  \
  \  C.addTransition(C.getState());\n    return;\n  }\n\n  processOptlenCompareBranch(CondE,\
  \ OptlenParm, C);\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  // Restrict to functions likely to be setsockopt\
  \ handlers.\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());\n\
  \  if (!FD)\n    return;\n  if (!FD->getName().contains(\"setsockopt\"))\n    return;\n\
  \n  const Expr *OE = Call.getOriginExpr();\n  if (!OE)\n    return;\n\n  // Safe\
  \ helper: bt_copy_from_sockptr checks optlen internally.\n  if (ExprHasName(OE,\
  \ \"bt_copy_from_sockptr\", C))\n    return;\n\n  bool IsCopy = false;\n  bool IsOffset\
  \ = false;\n\n  if (ExprHasName(OE, \"copy_from_sockptr_offset\", C)) {\n    IsCopy\
  \ = true;\n    IsOffset = true;\n  } else if (ExprHasName(OE, \"copy_from_sockptr\"\
  , C)) {\n    IsCopy = true;\n    IsOffset = false;\n  }\n\n  if (!IsCopy)\n    return;\n\
  \n  // Confirm the source argument is optval (arg index 1).\n  if (Call.getNumArgs()\
  \ < (IsOffset ? 4u : 3u))\n    return;\n\n  const Expr *SrcArgE = Call.getArgExpr(1);\n\
  \  if (!SrcArgE || !ExprHasName(SrcArgE, \"optval\", C))\n    return;\n\n  // Size\
  \ argument index differs for offset variant.\n  unsigned SizeIdx = IsOffset ? 3u\
  \ : 2u;\n  const Expr *SizeE = Call.getArgExpr(SizeIdx);\n  if (!SizeE)\n    return;\n\
  \n  uint64_t CopySize = 0;\n  if (!tryEvalToConst(SizeE, CopySize, C))\n    return;\
  \ // Only consider fixed-sized copies.\n\n  const ParmVarDecl *OptlenParm = getOptlenParm(FD);\n\
  \  if (!OptlenParm)\n    return;\n\n  ProgramStateRef State = C.getState();\n  uint64_t\
  \ LB = 0;\n  if (const uint64_t *KnownLB = State->get<OptlenLBMap>(OptlenParm))\n\
  \    LB = *KnownLB;\n\n  if (LB < CopySize) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"copy_from_sockptr with fixed size without checking optlen\", N);\n\
  \    R->addRange(Call.getSourceRange());\n    C.emitReport(std::move(R));\n  }\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect blindly copying fixed size from sockptr without validating optlen\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: RFCOMM: Fix not validating setsockopt user\
  \ input\n\nsyzbot reported rfcomm_sock_setsockopt_old() is copying data without\n\
  checking user input length.\n\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset\n\
  include/linux/sockptr.h:49 [inline]\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr\n\
  include/linux/sockptr.h:55 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt_old\n\
  net/bluetooth/rfcomm/sock.c:632 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt+0x893/0xa70\n\
  net/bluetooth/rfcomm/sock.c:673\nRead of size 4 at addr ffff8880209a8bc3 by task\
  \ syz-executor632/5064\n\nFixes: 9f2c8a03fbb3 (\"Bluetooth: Replace RFCOMM link\
  \ mode with security level\")\nFixes: bb23c0ab8246 (\"Bluetooth: Add support for\
  \ deferring RFCOMM connection setup\")\nReported-by: syzbot <syzkaller@googlegroups.com>\n\
  Signed-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Luiz Augusto von\
  \ Dentz <luiz.von.dentz@intel.com>\n\n## Buggy Code\n\n```c\n// Function: rfcomm_sock_setsockopt\
  \ in net/bluetooth/rfcomm/sock.c\nstatic int rfcomm_sock_setsockopt(struct socket\
  \ *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\
  \tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint err = 0;\n\tsize_t\
  \ len;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\
  \treturn rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level\
  \ != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname)\
  \ {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\
  \t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned\
  \ int, sizeof(sec), optlen);\n\t\tif (copy_from_sockptr(&sec, optval, len)) {\n\t\
  \t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level > BT_SECURITY_HIGH)\
  \ {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\trfcomm_pi(sk)->sec_level =\
  \ sec.level;\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND\
  \ && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\
  \t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\
  \t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\
  \t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\n\t\tbreak;\n\
  \n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\t\
  return err;\n}\n```\n\n```c\n// Function: rfcomm_sock_setsockopt_old in net/bluetooth/rfcomm/sock.c\n\
  static int rfcomm_sock_setsockopt_old(struct socket *sock, int optname,\n\t\tsockptr_t\
  \ optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\
  \tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname)\
  \ {\n\tcase RFCOMM_LM:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\
  \t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_FIPS) {\n\t\
  \t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_AUTH)\n\t\t\t\
  rfcomm_pi(sk)->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & RFCOMM_LM_ENCRYPT)\n\t\
  \t\trfcomm_pi(sk)->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & RFCOMM_LM_SECURE)\n\
  \t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_HIGH;\n\n\t\trfcomm_pi(sk)->role_switch\
  \ = (opt & RFCOMM_LM_MASTER);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\
  \t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\
  \n```diff\ndiff --git a/net/bluetooth/rfcomm/sock.c b/net/bluetooth/rfcomm/sock.c\n\
  index b54e8a530f55..29aa07e9db9d 100644\n--- a/net/bluetooth/rfcomm/sock.c\n+++\
  \ b/net/bluetooth/rfcomm/sock.c\n@@ -629,7 +629,7 @@ static int rfcomm_sock_setsockopt_old(struct\
  \ socket *sock, int optname,\n \n \tswitch (optname) {\n \tcase RFCOMM_LM:\n-\t\t\
  if (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n+\t\tif (bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen)) {\n \t\t\terr = -EFAULT;\n \t\t\tbreak;\n \t\t}\n\
  @@ -664,7 +664,6 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level,\
  \ int optname,\n \tstruct sock *sk = sock->sk;\n \tstruct bt_security sec;\n \t\
  int err = 0;\n-\tsize_t len;\n \tu32 opt;\n \n \tBT_DBG(\"sk %p\", sk);\n@@ -686,11\
  \ +685,9 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level, int\
  \ optname,\n \n \t\tsec.level = BT_SECURITY_LOW;\n \n-\t\tlen = min_t(unsigned int,\
  \ sizeof(sec), optlen);\n-\t\tif (copy_from_sockptr(&sec, optval, len)) {\n-\t\t\
  \terr = -EFAULT;\n+\t\terr = bt_copy_from_sockptr(&sec, sizeof(sec), optval, optlen);\n\
  +\t\tif (err)\n \t\t\tbreak;\n-\t\t}\n \n \t\tif (sec.level > BT_SECURITY_HIGH)\
  \ {\n \t\t\terr = -EINVAL;\n@@ -706,10 +703,9 @@ static int rfcomm_sock_setsockopt(struct\
  \ socket *sock, int level, int optname,\n \t\t\tbreak;\n \t\t}\n \n-\t\tif (copy_from_sockptr(&opt,\
  \ optval, sizeof(u32))) {\n-\t\t\terr = -EFAULT;\n+\t\terr = bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen);\n+\t\tif (err)\n \t\t\tbreak;\n-\t\t}\n \n \t\t\
  if (opt)\n \t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n```\n"
pattern: "## Bug Pattern\n\nBlindly copying a fixed-sized object from a sockptr in\
  \ a setsockopt handler without validating the user-provided optlen.\n\nTypical faulty\
  \ pattern:\n```\nint err;\nu32 opt;\n...\n/* No check that optlen >= sizeof(opt)\
  \ */\nif (copy_from_sockptr(&opt, optval, sizeof(opt)))\n    return -EFAULT;\n```\n\
  \nSafer pattern:\n```\nint err;\nu32 opt;\n...\nif (optlen < sizeof(opt))\n    return\
  \ -EINVAL;\nif (copy_from_sockptr(&opt, optval, sizeof(opt)))\n    return -EFAULT;\n\
  ```\nor use a helper that enforces length checking:\n```\nif (bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen))\n    return -EFAULT;\n```\n\nRoot cause: not validating\
  \ optlen before copying causes slab-out-of-bounds reads when the kernel-side buffer\
  \ backing sockptr is only optlen bytes long."
plan: "1) Program state\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(OptlenLBMap, const ParmVarDecl*,\
  \ uint64_t)\n  - Per-path lower-bound knowledge: for a given function parameter\
  \ \u201Coptlen\u201D, record the greatest lower bound (in bytes) that has been validated\
  \ along the current path. We only need a single lower bound number per \u201Coptlen\u201D\
  \ parm; update it to the max of the existing bound and the newly learned bound.\n\
  \nNo other custom state is necessary.\n\n\n2) Callbacks and how to implement\n\n\
  A) evalAssume(State, CondSVal, Assumption)\n- Goal: Learn \u201Coptlen >= sizeof(X)\u201D\
  \ style facts from branch conditions.\n- Steps:\n  1) Retrieve the Stmt* for Cond\
  \ from the current node if available or use a helper to map SVal back to Stmt when\
  \ possible (CheckerContext usually provides the branch condition Stmt via checkBranchCondition;\
  \ however, evalAssume gives us Cond as SVal, which is fine for constraint but not\
  \ to parse structure. Implement the learning in checkBranchCondition instead to\
  \ reliably parse the AST of the condition. If you prefer evalAssume, ensure you\
  \ can access the original Stmt. For simplicity and robustness, do this learning\
  \ in checkBranchCondition).\n  2) Return unchanged State (we won\u2019t implement\
  \ learning here; see B).\n\nB) checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C)\n- Goal: Parse if-conditions to capture validations like \u201Cif (optlen\
  \ < sizeof(X)) \u2026 else \u2026\u201D or \u201Cif (optlen >= sizeof(X)) \u2026\
  \u201D.\n- Steps:\n  1) If Condition is not a BinaryOperator, return.\n  2) Extract\
  \ LHS and RHS.\n  3) Identify if either LHS or RHS is a DeclRefExpr whose decl name\
  \ is exactly \u201Coptlen\u201D.\n     - Use dyn_cast<DeclRefExpr> and DRE->getDecl()->getNameAsString()\
  \ == \"optlen\".\n     - If not found, return.\n     - Record the ParmVarDecl* for\
  \ that \u201Coptlen\u201D (cast the Decl to ParmVarDecl).\n  4) For the side that\
  \ is not \u201Coptlen\u201D, try to evaluate it to a constant byte size:\n     -\
  \ Accept UnaryExprOrTypeTraitExpr (sizeof) and any constant expression.\n     -\
  \ Use EvaluateExprToInt(APSInt, Expr, C). If fails, return (we only handle constant\
  \ size).\n     - Let SizeConst = EvalRes.getZExtValue().\n  5) Based on Operator\
  \ and branch direction:\n     - We need to know which branch we are analyzing. For\
  \ branch conditions, the engine explores both; our callback is pre-visit. Instead\
  \ of branching here, we will record knowledge in both successors using C.assume;\
  \ However, for simplicity and stability: do nothing here and rely on the analyzer\u2019\
  s splitting; We will re-derive lower-bound knowledge in checkPreCall by querying\
  \ the path constraints. Since we don\u2019t have direct min/max queries provided,\
  \ implement the learning here using both successor nodes:\n       - Generate two\
  \ assumptions using C.assume() on the condition SVal:\n         - TrueState: Assumption\
  \ that Condition is true.\n         - FalseState: Assumption that Condition is false.\n\
  \       - For each non-null successor state:\n         - Determine if that assumption\
  \ implies optlen >= SizeConst:\n            \u2022 If op is \u201Coptlen < K\u201D\
  : FalseState implies optlen >= K. On FalseState: set OptlenLBMap[Parm] = max(old,\
  \ K).\n            \u2022 If op is \u201Coptlen <= K\u201D: FalseState implies optlen\
  \ > K (>= K+1). Set LB to K (conservative) or K+1; either is fine since we compare\
  \ to sizeof(X). Use K to keep it simple.\n            \u2022 If op is \u201Coptlen\
  \ >= K\u201D: TrueState implies LB >= K.\n            \u2022 If op is \u201Coptlen\
  \ > K\u201D: TrueState implies LB >= K (conservative).\n            \u2022 If op\
  \ is \u201Coptlen == K\u201D: TrueState implies LB >= K.\n            \u2022 If\
  \ condition is reversed (K < optlen, K <= optlen, etc.), flip the logic accordingly\
  \ and apply the same mapping.\n       - For each successor where we updated LB,\
  \ call C.addTransition(NewState).\n     - If we cannot split (rare), skip updating.\n\
  \  Note: This keeps the knowledge path-sensitive by producing both transitions with\
  \ updated state.\n\nC) checkPreCall(const CallEvent &Call, CheckerContext &C)\n\
  - Goal: Detect dangerous copies and report if \u201Coptlen\u201D wasn\u2019t validated\
  \ for the fixed size being copied.\n- Steps:\n  1) Restrict to setsockopt handlers\
  \ to reduce false positives:\n     - Retrieve the current function: if const FunctionDecl\
  \ *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl()) and FD->getNameAsString().contains(\"\
  setsockopt\") is false, return.\n  2) Identify unsafe copy helpers:\n     - Get\
  \ callee name via Call.getCalleeIdentifier()->getName().\n     - If name == \"bt_copy_from_sockptr\"\
  : safe, return.\n     - If name == \"copy_from_sockptr\":\n         \u2022 arg indices:\
  \ dst=0, src=1, size=2.\n     - If name == \"copy_from_sockptr_offset\":\n     \
  \    \u2022 arg indices: dst=0, src=1, offset=2, size=3.\n     - Else return.\n\
  \  3) Check the second argument (src) contains \u201Coptval\u201D:\n     - Use ExprHasName(Call.getArgExpr(srcIndex),\
  \ \"optval\", C). If false, return.\n  4) Check the size argument is a fixed constant\
  \ \u201Csizeof(...)\u201D:\n     - Try EvaluateExprToInt on the size argument. If\
  \ it fails, return (we only flag fixed-sized copies).\n     - Let CopySize = evaluated\
  \ constant.\n  5) Find the \u201Coptlen\u201D parameter in the current function:\n\
  \     - Iterate FD->parameters() and find ParmVarDecl* where getNameAsString() ==\
  \ \"optlen\".\n     - If not found, return.\n  6) Query our learned lower bound:\n\
  \     - State = C.getState().\n     - Get LB = OptlenLBMap[Parm]. If no entry, treat\
  \ as 0.\n  7) If LB < CopySize, report a bug:\n     - Create ExplodedNode *N = C.generateNonFatalErrorNode().\n\
  \     - If N is null, return.\n     - Emit PathSensitiveBugReport:\n       \u2022\
  \ BugType: \u201CUnchecked optlen in setsockopt copy\u201D.\n       \u2022 Message:\
  \ \u201Ccopy_from_sockptr with fixed size without checking optlen\u201D.\n     \
  \  \u2022 Location: the CallExpression of copy_from_sockptr (Call.getSourceRange()).\n\
  \     - Otherwise, do nothing (the path is safe because validation enforces optlen\
  \ >= CopySize).\n\nD) Optional: checkBeginFunction(CheckerContext &C)\n- Not strictly\
  \ required. Program state maps are initially empty per path. No initialization needed.\n\
  \nE) Other callbacks\n- checkPostCall, checkBind, checkLocation, checkEndFunction,\
  \ checkEndAnalysis: not necessary for this checker\u2019s simplest implementation.\n\
  \n\n3) Heuristics and notes\n\n- Validation we recognize:\n  - if (optlen < sizeof(X))\
  \ return ...; then later copy sizeof(X) is safe on the false branch; our checkBranchCondition\
  \ logic records LB on the false successor.\n  - if (optlen >= sizeof(X)) { copy\
  \ sizeof(X); } is safe on the true branch; LB is recorded on the true successor.\n\
  \  - if (optlen == sizeof(X)) also safe on true branch.\n- We conservatively skip:\n\
  \  - Non-constant sizes, including \u201Clen = min_t(..., sizeof(X), optlen)\u201D\
  \ followed by copy_from_sockptr(..., len). This is not the \u201Cfixed-sized copy\u201D\
  \ pattern; we don\u2019t warn to keep the checker simple and precise.\n- We only\
  \ consider sources whose expression text contains \u201Coptval\u201D to match setsockopt\
  \ signature and avoid false positives with other sockptr sources.\n- We treat bt_copy_from_sockptr\
  \ as safe and do not warn on it.\n\n\n4) Utility helpers to include\n\n- A small\
  \ helper to extract CopySize:\n  - bool tryEvalToConst(const Expr *E, uint64_t &Out,\
  \ CheckerContext &C)\n    \u2022 use EvaluateExprToInt; on success set Out = EvalRes.getZExtValue().\n\
  \n- A helper to get the optlen ParmVarDecl* from the current FD:\n  - const ParmVarDecl*\
  \ getOptlenParm(const FunctionDecl *FD)\n    \u2022 iterate parameters and match\
  \ name \u201Coptlen\u201D.\n\n- A helper to update LB in OptlenLBMap:\n  - ProgramStateRef\
  \ setLB(ProgramStateRef S, const ParmVarDecl *P, uint64_t NewLB)\n    \u2022 retrieves\
  \ old, stores max(old, NewLB).\n\n\n5) Reporting\n\n- Use generateNonFatalErrorNode\
  \ and std::make_unique<PathSensitiveBugReport>.\n- Message: \u201Ccopy_from_sockptr\
  \ with fixed size without checking optlen\u201D.\n- Keep it short and clear as requested."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"\
  llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/APInt.h\"\n#include <optional>\n#include\
  \ <tuple>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\
  \n// Program state: track per-path learned lower bounds for 'optlen' parameters.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(OptlenLBMap, const ParmVarDecl*, uint64_t)\n\nnamespace\
  \ {\n\nclass SAGenTestChecker : public Checker<\n    check::BranchCondition,\n \
  \   check::PreCall\n> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n\
  \      SAGenTestChecker() : BT(new BugType(this, \"Unchecked optlen in setsockopt\
  \ copy\", \"API Misuse\")) {}\n\n      void checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const;\n      void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\n   private:\n      // Helpers\n      static const ParmVarDecl *getOptlenParm(const\
  \ FunctionDecl *FD);\n      static ProgramStateRef setLB(ProgramStateRef S, const\
  \ ParmVarDecl *P, uint64_t NewLB);\n      static bool tryEvalToConst(const Expr\
  \ *E, uint64_t &Out, CheckerContext &C);\n\n      // Core logic to update LB for\
  \ true/false branches\n      void processOptlenCompareBranch(const Expr *CondE,\n\
  \                                      const ParmVarDecl *OptlenParm,\n        \
  \                              CheckerContext &C) const;\n};\n\n// Return the 'optlen'\
  \ ParmVarDecl* if exists in the current function, else nullptr.\nconst ParmVarDecl\
  \ *SAGenTestChecker::getOptlenParm(const FunctionDecl *FD) {\n  if (!FD)\n    return\
  \ nullptr;\n  for (const ParmVarDecl *P : FD->parameters()) {\n    if (P && P->getName()\
  \ == \"optlen\")\n      return P;\n  }\n  return nullptr;\n}\n\n// Update the lower\
  \ bound for an 'optlen' parameter to max(old, NewLB).\nProgramStateRef SAGenTestChecker::setLB(ProgramStateRef\
  \ S, const ParmVarDecl *P, uint64_t NewLB) {\n  if (!S || !P)\n    return S;\n \
  \ if (const uint64_t *Old = S->get<OptlenLBMap>(P)) {\n    uint64_t M = (*Old >\
  \ NewLB) ? *Old : NewLB;\n    if (M != *Old)\n      return S->set<OptlenLBMap>(P,\
  \ M);\n    return S;\n  }\n  return S->set<OptlenLBMap>(P, NewLB);\n}\n\n// Evaluate\
  \ expression to constant uint64_t if possible.\nbool SAGenTestChecker::tryEvalToConst(const\
  \ Expr *E, uint64_t &Out, CheckerContext &C) {\n  if (!E)\n    return false;\n \
  \ llvm::APSInt Res;\n  if (EvaluateExprToInt(Res, E, C)) {\n    Out = Res.getZExtValue();\n\
  \    return true;\n  }\n  return false;\n}\n\n// Analyze condition and create two\
  \ transitions with updated LB when possible.\nvoid SAGenTestChecker::processOptlenCompareBranch(const\
  \ Expr *CondE,\n                                                  const ParmVarDecl\
  \ *OptlenParm,\n                                                  CheckerContext\
  \ &C) const {\n  if (!CondE || !OptlenParm)\n    return;\n\n  const auto *BO = dyn_cast<BinaryOperator>(CondE->IgnoreParenCasts());\n\
  \  if (!BO)\n    return;\n\n  BinaryOperator::Opcode Op = BO->getOpcode();\n  //\
  \ Only consider comparison/equality ops.\n  bool IsCompare =\n      Op == BO_LT\
  \ || Op == BO_LE || Op == BO_GT || Op == BO_GE || Op == BO_EQ;\n  if (!IsCompare)\n\
  \    return;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n  const Expr\
  \ *RHS = BO->getRHS()->IgnoreParenCasts();\n\n  // Identify where optlen is.\n \
  \ const DeclRefExpr *LHSd = dyn_cast<DeclRefExpr>(LHS);\n  const DeclRefExpr *RHSd\
  \ = dyn_cast<DeclRefExpr>(RHS);\n\n  bool LHSIsOptlen = false, RHSIsOptlen = false;\n\
  \  if (LHSd) {\n    if (const auto *PD = dyn_cast<ParmVarDecl>(LHSd->getDecl()))\n\
  \      LHSIsOptlen = (PD == OptlenParm);\n  }\n  if (RHSd) {\n    if (const auto\
  \ *PD = dyn_cast<ParmVarDecl>(RHSd->getDecl()))\n      RHSIsOptlen = (PD == OptlenParm);\n\
  \  }\n  if (!LHSIsOptlen && !RHSIsOptlen)\n    return;\n\n  // Evaluate the non-optlen\
  \ side to a constant.\n  uint64_t K = 0;\n  const Expr *Other = LHSIsOptlen ? RHS\
  \ : (RHSIsOptlen ? LHS : nullptr);\n  if (!Other)\n    return;\n  if (!tryEvalToConst(Other,\
  \ K, C))\n    return;\n\n  ProgramStateRef State = C.getState();\n  SVal CondV =\
  \ State->getSVal(CondE, C.getLocationContext());\n  std::optional<DefinedOrUnknownSVal>\
  \ DV = CondV.getAs<DefinedOrUnknownSVal>();\n  if (!DV)\n    return;\n\n  ProgramStateRef\
  \ StTrue, StFalse;\n  std::tie(StTrue, StFalse) = State->assume(*DV);\n\n  // For\
  \ each branch, compute LB updates based on the form of comparison.\n  auto updateForBranch\
  \ = [&](ProgramStateRef SIn, bool IsTrue) -> ProgramStateRef {\n    if (!SIn)\n\
  \      return nullptr;\n\n    // Helper lambda to set LB.\n    auto set = [&](uint64_t\
  \ LB) -> ProgramStateRef {\n      return setLB(SIn, OptlenParm, LB);\n    };\n\n\
  \    switch (Op) {\n      case BO_LT:\n        if (LHSIsOptlen) {\n          //\
  \ optlen < K\n          // True: no LB. False: optlen >= K -> LB=K\n          return\
  \ IsTrue ? SIn : set(K);\n        } else {\n          // K < optlen\n          //\
  \ True: optlen > K -> LB=K+1; False: no LB\n          return IsTrue ? set(K + 1)\
  \ : SIn;\n        }\n      case BO_LE:\n        if (LHSIsOptlen) {\n          //\
  \ optlen <= K\n          // True: no LB; False: optlen > K -> LB=K+1\n         \
  \ return IsTrue ? SIn : set(K + 1);\n        } else {\n          // K <= optlen\n\
  \          // True: optlen >= K -> LB=K; False: no LB\n          return IsTrue ?\
  \ set(K) : SIn;\n        }\n      case BO_GT:\n        if (LHSIsOptlen) {\n    \
  \      // optlen > K\n          // True: LB=K+1; False: no LB\n          return\
  \ IsTrue ? set(K + 1) : SIn;\n        } else {\n          // K > optlen\n      \
  \    // True: no LB; False: optlen >= K -> LB=K\n          return IsTrue ? SIn :\
  \ set(K);\n        }\n      case BO_GE:\n        if (LHSIsOptlen) {\n          //\
  \ optlen >= K\n          // True: LB=K; False: no LB\n          return IsTrue ?\
  \ set(K) : SIn;\n        } else {\n          // K >= optlen\n          // True:\
  \ no LB; False: optlen > K -> LB=K+1\n          return IsTrue ? SIn : set(K + 1);\n\
  \        }\n      case BO_EQ:\n        // optlen == K OR K == optlen\n        //\
  \ True: LB=K; False: no LB\n        return IsTrue ? set(K) : SIn;\n      default:\n\
  \        break;\n    }\n    return SIn;\n  };\n\n  ProgramStateRef NT = updateForBranch(StTrue,\
  \ /*IsTrue=*/true);\n  ProgramStateRef NF = updateForBranch(StFalse, /*IsTrue=*/false);\n\
  \n  // Add transitions for the branches we refined. If neither updated, keep original.\n\
  \  bool Added = false;\n  if (NT && NT != StTrue) { C.addTransition(NT); Added =\
  \ true; }\n  if (NF && NF != StFalse) { C.addTransition(NF); Added = true; }\n \
  \ if (!Added) {\n    // No refinement possible; continue with current state.\n \
  \   C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  const auto *CondE = dyn_cast<Expr>(Condition);\n\
  \  if (!CondE) {\n    C.addTransition(C.getState());\n    return;\n  }\n\n  const\
  \ auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());\n\
  \  const ParmVarDecl *OptlenParm = getOptlenParm(FD);\n  if (!OptlenParm) {\n  \
  \  C.addTransition(C.getState());\n    return;\n  }\n\n  processOptlenCompareBranch(CondE,\
  \ OptlenParm, C);\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  // Restrict to functions likely to be setsockopt\
  \ handlers.\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());\n\
  \  if (!FD)\n    return;\n  if (!FD->getName().contains(\"setsockopt\"))\n    return;\n\
  \n  const Expr *OE = Call.getOriginExpr();\n  if (!OE)\n    return;\n\n  // Safe\
  \ helper: bt_copy_from_sockptr checks optlen internally.\n  if (ExprHasName(OE,\
  \ \"bt_copy_from_sockptr\", C))\n    return;\n\n  bool IsCopy = false;\n  bool IsOffset\
  \ = false;\n\n  if (ExprHasName(OE, \"copy_from_sockptr_offset\", C)) {\n    IsCopy\
  \ = true;\n    IsOffset = true;\n  } else if (ExprHasName(OE, \"copy_from_sockptr\"\
  , C)) {\n    IsCopy = true;\n    IsOffset = false;\n  }\n\n  if (!IsCopy)\n    return;\n\
  \n  // Confirm the source argument is optval (arg index 1).\n  if (Call.getNumArgs()\
  \ < (IsOffset ? 4u : 3u))\n    return;\n\n  const Expr *SrcArgE = Call.getArgExpr(1);\n\
  \  if (!SrcArgE || !ExprHasName(SrcArgE, \"optval\", C))\n    return;\n\n  // Size\
  \ argument index differs for offset variant.\n  unsigned SizeIdx = IsOffset ? 3u\
  \ : 2u;\n  const Expr *SizeE = Call.getArgExpr(SizeIdx);\n  if (!SizeE)\n    return;\n\
  \n  uint64_t CopySize = 0;\n  if (!tryEvalToConst(SizeE, CopySize, C))\n    return;\
  \ // Only consider fixed-sized copies.\n\n  const ParmVarDecl *OptlenParm = getOptlenParm(FD);\n\
  \  if (!OptlenParm)\n    return;\n\n  ProgramStateRef State = C.getState();\n  uint64_t\
  \ LB = 0;\n  if (const uint64_t *KnownLB = State->get<OptlenLBMap>(OptlenParm))\n\
  \    LB = *KnownLB;\n\n  if (LB < CopySize) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"copy_from_sockptr with fixed size without checking optlen\", N);\n\
  \    R->addRange(Call.getSourceRange());\n    C.emitReport(std::move(R));\n  }\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect blindly copying fixed size from sockptr without validating optlen\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
