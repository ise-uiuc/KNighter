_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: ef307bc6ef04e8c1ea843231db58e3afaafa9fa6
commit_type: Concurrency
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"llvm/ADT/ImmutableSet.h\"\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n//====================== Program state ======================\n\
  \nusing LockSet = llvm::ImmutableSet<const MemRegion *>;\nusing ObjSet  = llvm::ImmutableSet<const\
  \ MemRegion *>;\n\nREGISTER_TRAIT_WITH_PROGRAMSTATE(HeldLocks, LockSet)\nREGISTER_MAP_WITH_PROGRAMSTATE(LockToObjSetMap,\
  \ const MemRegion*, ObjSet)\nREGISTER_TRAIT_WITH_PROGRAMSTATE(LastUnlockedLock,\
  \ const MemRegion*)\n\n//====================== Helpers ============================\n\
  \nstatic bool isOneOf(StringRef S, std::initializer_list<StringRef> Names) {\n \
  \ for (auto &N : Names)\n    if (S == N) return true;\n  return false;\n}\n\nstatic\
  \ bool isLockAcquire(const CallEvent &Call, CheckerContext &C) {\n  if (const IdentifierInfo\
  \ *ID = Call.getCalleeIdentifier()) {\n    StringRef Name = ID->getName();\n   \
  \ return isOneOf(Name, {\"spin_lock\", \"spin_lock_irqsave\", \"spin_lock_bh\",\
  \ \"spin_lock_irq\"});\n  }\n  // Fallback to textual check\n  const Expr *E = Call.getOriginExpr();\n\
  \  if (!E) return false;\n  return ExprHasName(E, \"spin_lock_irqsave\", C) ||\n\
  \         ExprHasName(E, \"spin_lock_irq\", C) ||\n         ExprHasName(E, \"spin_lock_bh\"\
  , C) ||\n         ExprHasName(E, \"spin_lock\", C);\n}\n\nstatic bool isLockRelease(const\
  \ CallEvent &Call, CheckerContext &C) {\n  if (const IdentifierInfo *ID = Call.getCalleeIdentifier())\
  \ {\n    StringRef Name = ID->getName();\n    return isOneOf(Name, {\"spin_unlock\"\
  , \"spin_unlock_irqrestore\", \"spin_unlock_bh\", \"spin_unlock_irq\"});\n  }\n\
  \  const Expr *E = Call.getOriginExpr();\n  if (!E) return false;\n  return ExprHasName(E,\
  \ \"spin_unlock_irqrestore\", C) ||\n         ExprHasName(E, \"spin_unlock_irq\"\
  , C) ||\n         ExprHasName(E, \"spin_unlock_bh\", C) ||\n         ExprHasName(E,\
  \ \"spin_unlock\", C);\n}\n\nstatic const MemRegion *getLockRegionFromCall(const\
  \ CallEvent &Call, CheckerContext &C) {\n  if (Call.getNumArgs() < 1)\n    return\
  \ nullptr;\n  const Expr *Arg0 = Call.getArgExpr(0);\n  if (!Arg0)\n    return nullptr;\n\
  \  const MemRegion *R = getMemRegionFromExpr(Arg0, C);\n  if (!R)\n    return nullptr;\n\
  \  return R->getBaseRegion();\n}\n\nstatic ProgramStateRef addHeldLock(ProgramStateRef\
  \ State, const MemRegion *Lock, CheckerContext &C) {\n  if (!Lock) return State;\n\
  \  LockSet Cur = State->get<HeldLocks>();\n  LockSet::Factory &F = State->get_context<LockSet>();\n\
  \  Cur = F.add(Cur, Lock);\n  State = State->set<HeldLocks>(Cur);\n  // When we\
  \ start holding a lock again, the \"just unlocked\" window is over.\n  State = State->set<LastUnlockedLock>(nullptr);\n\
  \  return State;\n}\n\nstatic ProgramStateRef removeHeldLock(ProgramStateRef State,\
  \ const MemRegion *Lock) {\n  if (!Lock) return State;\n  LockSet Cur = State->get<HeldLocks>();\n\
  \  LockSet::Factory &F = State->get_context<LockSet>();\n  Cur = F.remove(Cur, Lock);\n\
  \  State = State->set<HeldLocks>(Cur);\n  return State;\n}\n\nstatic bool objSetContains(const\
  \ ObjSet &S, const MemRegion *R) {\n  for (auto It = S.begin(); It != S.end(); ++It)\
  \ {\n    if (*It == R)\n      return true;\n  }\n  return false;\n}\n\n// Record\
  \ that \"ObjR\" is used while holding each lock in HeldLocks.\nstatic ProgramStateRef\
  \ recordObjUseUnderHeldLocks(ProgramStateRef State,\n                          \
  \                        const Expr *ArgE,\n                                   \
  \               CheckerContext &C) {\n  if (!ArgE)\n    return State;\n  LockSet\
  \ Locks = State->get<HeldLocks>();\n  if (Locks.isEmpty())\n    return State;\n\n\
  \  const MemRegion *ObjR = nullptr;\n\n  // If it's a member access, prefer to use\
  \ the base object's region.\n  if (const auto *ME = dyn_cast<MemberExpr>(ArgE->IgnoreParenCasts()))\
  \ {\n    const Expr *BaseE = ME->getBase();\n    ObjR = getMemRegionFromExpr(BaseE,\
  \ C);\n  } else {\n    ObjR = getMemRegionFromExpr(ArgE, C);\n  }\n\n  if (!ObjR)\n\
  \    return State;\n  ObjR = ObjR->getBaseRegion();\n  if (!ObjR)\n    return State;\n\
  \n  ObjSet::Factory &OF = State->get_context<ObjSet>();\n  for (auto LI = Locks.begin();\
  \ LI != Locks.end(); ++LI) {\n    const MemRegion *LockR = *LI;\n    if (!LockR)\
  \ continue;\n    const ObjSet *CurPtr = State->get<LockToObjSetMap>(LockR);\n  \
  \  ObjSet Cur = CurPtr ? *CurPtr : OF.getEmptySet();\n    if (!objSetContains(Cur,\
  \ ObjR)) {\n      Cur = OF.add(Cur, ObjR);\n      State = State->set<LockToObjSetMap>(LockR,\
  \ Cur);\n    }\n  }\n  return State;\n}\n\nstatic bool isZeroSVal(SVal V) {\n  if\
  \ (auto CI = V.getAs<nonloc::ConcreteInt>())\n    return CI->getValue() == 0;\n\
  \  if (auto LCI = V.getAs<loc::ConcreteInt>())\n    return LCI->getValue() == 0;\n\
  \  return false;\n}\n\nstatic bool isPointerFieldAssignmentToNull(const Stmt *S,\
  \ SVal Loc, SVal Val,\n                                           CheckerContext\
  \ &C,\n                                           const BinaryOperator *&OutBO,\n\
  \                                           const MemberExpr *&OutME) {\n  OutBO\
  \ = nullptr;\n  OutME = nullptr;\n\n  const auto *BO = dyn_cast_or_null<BinaryOperator>(S);\n\
  \  if (!BO || !BO->isAssignmentOp())\n    return false;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \  const auto *ME = dyn_cast<MemberExpr>(LHS);\n  if (!ME)\n    return false;\n\n\
  \  // We focus on pointer field like obj->field.\n  if (!ME->isArrow())\n    return\
  \ false;\n\n  QualType FieldTy = ME->getType();\n  if (FieldTy.isNull() || !FieldTy->isPointerType())\n\
  \    return false;\n\n  bool IsNull = isZeroSVal(Val);\n  if (!IsNull) {\n    //\
  \ Try evaluate RHS constant int == 0\n    llvm::APSInt IntV;\n    if (EvaluateExprToInt(IntV,\
  \ BO->getRHS(), C))\n      IsNull = (IntV == 0);\n  }\n  if (!IsNull)\n    return\
  \ false;\n\n  OutBO = BO;\n  OutME = ME;\n  return true;\n}\n\nstatic const MemRegion\
  \ *getBaseObjectRegionFromLHS(const BinaryOperator *BO,\n                      \
  \                             CheckerContext &C) {\n  if (!BO) return nullptr;\n\
  \  const auto *ME = dyn_cast<MemberExpr>(BO->getLHS()->IgnoreParenCasts());\n  if\
  \ (!ME) return nullptr;\n  const Expr *BaseE = ME->getBase();\n  if (!BaseE) return\
  \ nullptr;\n  const MemRegion *R = getMemRegionFromExpr(BaseE, C);\n  if (!R) return\
  \ nullptr;\n  return R->getBaseRegion();\n}\n\n//====================== Checker\
  \ ============================\n\nnamespace {\n\nclass SAGenTestChecker\n  : public\
  \ Checker<check::BeginFunction,\n                   check::PreCall,\n          \
  \         check::PostCall,\n                   check::Location,\n              \
  \     check::Bind> {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\
  \ : BT(new BugType(this, \"Pointer field NULLed after unlock\", \"Concurrency\"\
  )) {}\n\n  void checkBeginFunction(CheckerContext &C) const;\n  void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  void checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S, CheckerContext &C) const;\n  void checkBind(SVal Loc, SVal Val,\
  \ const Stmt *S, CheckerContext &C) const;\n\nprivate:\n  void reportIssue(const\
  \ BinaryOperator *BO, CheckerContext &C) const;\n};\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  // Initialize/clear\
  \ per-function state.\n  State = State->set<HeldLocks>(State->get_context<LockSet>().getEmptySet());\n\
  \  State = State->set<LastUnlockedLock>(nullptr);\n\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n\n  // If this is a non-unlock\
  \ call and we have a pending \"just unlocked\" mark, clear it.\n  if (State->get<LastUnlockedLock>()\
  \ && !isLockRelease(Call, C) && !isLockAcquire(Call, C)) {\n    State = State->set<LastUnlockedLock>(nullptr);\n\
  \  }\n\n  // Handle lock acquire\n  if (isLockAcquire(Call, C)) {\n    if (const\
  \ MemRegion *LockR = getLockRegionFromCall(Call, C)) {\n      State = addHeldLock(State,\
  \ LockR, C);\n    }\n    C.addTransition(State);\n    return;\n  }\n\n  // While\
  \ locks are held, record any object/pointer arguments used inside the critical section.\n\
  \  if (!State->get<HeldLocks>().isEmpty()) {\n    for (unsigned i = 0; i < Call.getNumArgs();\
  \ ++i) {\n      const Expr *ArgE = Call.getArgExpr(i);\n      State = recordObjUseUnderHeldLocks(State,\
  \ ArgE, C);\n    }\n    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Handle lock release\n  if (isLockRelease(Call, C)) {\n    const MemRegion\
  \ *LockR = getLockRegionFromCall(Call, C);\n    State = removeHeldLock(State, LockR);\n\
  \    // Mark the last unlocked lock to detect the immediate next assignment.\n \
  \   State = State->set<LastUnlockedLock>(LockR);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // Any other call after unlock clears the \"just unlocked\"\
  \ mark to keep window small.\n  if (State->get<LastUnlockedLock>()) {\n    State\
  \ = State->set<LastUnlockedLock>(nullptr);\n    C.addTransition(State);\n  }\n}\n\
  \nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  if (State->get<HeldLocks>().isEmpty())\n\
  \    return;\n\n  // When under a lock, if the location is part of a MemberExpr,\
  \ record the base object.\n  const MemberExpr *ME = findSpecificTypeInParents<MemberExpr>(S,\
  \ C);\n  if (!ME)\n    return;\n\n  const Expr *BaseE = ME->getBase();\n  if (!BaseE)\n\
  \    return;\n\n  State = recordObjUseUnderHeldLocks(State, BaseE, C);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *JustUnlocked\
  \ = State->get<LastUnlockedLock>();\n  // We only care about the immediate next\
  \ assignment after an unlock, and only when no lock is held.\n  if (JustUnlocked\
  \ && State->get<HeldLocks>().isEmpty()) {\n    const BinaryOperator *BO = nullptr;\n\
  \    const MemberExpr *ME = nullptr;\n\n    if (isPointerFieldAssignmentToNull(S,\
  \ Loc, Val, C, BO, ME)) {\n      // Determine the \"object\" whose field is being\
  \ NULLed.\n      const MemRegion *ObjR = getBaseObjectRegionFromLHS(BO, C);\n  \
  \    if (ObjR) {\n        // Check if this object was used under the same lock earlier\
  \ in this path.\n        const ObjSet *UsedObjsPtr = State->get<LockToObjSetMap>(JustUnlocked);\n\
  \        if (UsedObjsPtr && objSetContains(*UsedObjsPtr, ObjR)) {\n          reportIssue(BO,\
  \ C);\n        }\n      }\n    }\n  }\n\n  // Regardless, clear the \"just unlocked\"\
  \ marker after the first bind we see.\n  if (JustUnlocked) {\n    State = State->set<LastUnlockedLock>(nullptr);\n\
  \    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::reportIssue(const\
  \ BinaryOperator *BO, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Pointer field set to NULL after unlocking; may race with readers under\
  \ the lock\", N);\n  if (BO)\n    R->addRange(BO->getLHS()->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects setting lock-protected pointer\
  \ fields to NULL immediately after unlocking\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nusb: dwc2: fix possible NULL pointer dereference caused\
  \ by driver concurrency\n\nIn _dwc2_hcd_urb_enqueue(), \"urb->hcpriv = NULL\" is\
  \ executed without\nholding the lock \"hsotg->lock\". In _dwc2_hcd_urb_dequeue():\n\
  \n    spin_lock_irqsave(&hsotg->lock, flags);\n    ...\n\tif (!urb->hcpriv) {\n\t\
  \tdev_dbg(hsotg->dev, \"## urb->hcpriv is NULL ##\\n\");\n\t\tgoto out;\n\t}\n \
  \   rc = dwc2_hcd_urb_dequeue(hsotg, urb->hcpriv); // Use urb->hcpriv\n    ...\n\
  out:\n    spin_unlock_irqrestore(&hsotg->lock, flags);\n\nWhen _dwc2_hcd_urb_enqueue()\
  \ and _dwc2_hcd_urb_dequeue() are\nconcurrently executed, the NULL check of \"urb->hcpriv\"\
  \ can be executed\nbefore \"urb->hcpriv = NULL\". After urb->hcpriv is NULL, it\
  \ can be used\nin the function call to dwc2_hcd_urb_dequeue(), which can cause a\
  \ NULL\npointer dereference.\n\nThis possible bug is found by an experimental static\
  \ analysis tool\ndeveloped by myself. This tool analyzes the locking APIs to extract\n\
  function pairs that can be concurrently executed, and then analyzes the\ninstructions\
  \ in the paired functions to identify possible concurrency\nbugs including data\
  \ races and atomicity violations. The above possible\nbug is reported, when my tool\
  \ analyzes the source code of Linux 6.5.\n\nTo fix this possible bug, \"urb->hcpriv\
  \ = NULL\" should be executed with\nholding the lock \"hsotg->lock\". After using\
  \ this patch, my tool never\nreports the possible bug, with the kernelconfiguration\
  \ allyesconfig for\nx86_64. Because I have no associated hardware, I cannot test\
  \ the patch\nin runtime testing, and just verify it according to the code logic.\n\
  \nFixes: 33ad261aa62b (\"usb: dwc2: host: spinlock urb_enqueue\")\nSigned-off-by:\
  \ Jia-Ju Bai <baijiaju@buaa.edu.cn>\nLink: https://lore.kernel.org/r/20230926024404.832096-1-baijiaju@buaa.edu.cn\n\
  Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n\n## Buggy Code\n\
  \n```c\n// Function: _dwc2_hcd_urb_enqueue in drivers/usb/dwc2/hcd.c\nstatic int\
  \ _dwc2_hcd_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\t gfp_t mem_flags)\n\
  {\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tstruct usb_host_endpoint\
  \ *ep = urb->ep;\n\tstruct dwc2_hcd_urb *dwc2_urb;\n\tint i;\n\tint retval;\n\t\
  int alloc_bandwidth = 0;\n\tu8 ep_type = 0;\n\tu32 tflags = 0;\n\tvoid *buf;\n\t\
  unsigned long flags;\n\tstruct dwc2_qh *qh;\n\tbool qh_allocated = false;\n\tstruct\
  \ dwc2_qtd *qtd;\n\tstruct dwc2_gregs_backup *gr;\n\n\tgr = &hsotg->gr_backup;\n\
  \n\tif (dbg_urb(urb)) {\n\t\tdev_vdbg(hsotg->dev, \"DWC OTG HCD URB Enqueue\\n\"\
  );\n\t\tdwc2_dump_urb_info(hcd, urb, \"urb_enqueue\");\n\t}\n\n\tif (hsotg->hibernated)\
  \ {\n\t\tif (gr->gotgctl & GOTGCTL_CURMODE_HOST)\n\t\t\tretval = dwc2_exit_hibernation(hsotg,\
  \ 0, 0, 1);\n\t\telse\n\t\t\tretval = dwc2_exit_hibernation(hsotg, 0, 0, 0);\n\n\
  \t\tif (retval)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit hibernation failed.\\\
  n\");\n\t}\n\n\tif (hsotg->in_ppd) {\n\t\tretval = dwc2_exit_partial_power_down(hsotg,\
  \ 0, true);\n\t\tif (retval)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit partial_power_down\
  \ failed\\n\");\n\t}\n\n\tif (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_NONE\
  \ &&\n\t    hsotg->bus_suspended) {\n\t\tif (dwc2_is_device_mode(hsotg))\n\t\t\t\
  dwc2_gadget_exit_clock_gating(hsotg, 0);\n\t\telse\n\t\t\tdwc2_host_exit_clock_gating(hsotg,\
  \ 0);\n\t}\n\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tif (usb_pipetype(urb->pipe) ==\
  \ PIPE_ISOCHRONOUS ||\n\t    usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {\n\t\t\
  spin_lock_irqsave(&hsotg->lock, flags);\n\t\tif (!dwc2_hcd_is_bandwidth_allocated(hsotg,\
  \ ep))\n\t\t\talloc_bandwidth = 1;\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\
  \t}\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_CONTROL:\n\t\tep_type =\
  \ USB_ENDPOINT_XFER_CONTROL;\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\t\tep_type\
  \ = USB_ENDPOINT_XFER_ISOC;\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tep_type = USB_ENDPOINT_XFER_BULK;\n\
  \t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tep_type = USB_ENDPOINT_XFER_INT;\n\t\tbreak;\n\
  \t}\n\n\tdwc2_urb = dwc2_hcd_urb_alloc(hsotg, urb->number_of_packets,\n\t\t\t\t\
  \      mem_flags);\n\tif (!dwc2_urb)\n\t\treturn -ENOMEM;\n\n\tdwc2_hcd_urb_set_pipeinfo(hsotg,\
  \ dwc2_urb, usb_pipedevice(urb->pipe),\n\t\t\t\t  usb_pipeendpoint(urb->pipe), ep_type,\n\
  \t\t\t\t  usb_pipein(urb->pipe),\n\t\t\t\t  usb_endpoint_maxp(&ep->desc),\n\t\t\t\
  \t  usb_endpoint_maxp_mult(&ep->desc));\n\n\tbuf = urb->transfer_buffer;\n\n\tif\
  \ (hcd_uses_dma(hcd)) {\n\t\tif (!buf && (urb->transfer_dma & 3)) {\n\t\t\tdev_err(hsotg->dev,\n\
  \t\t\t\t\"%s: unaligned transfer with no transfer_buffer\",\n\t\t\t\t__func__);\n\
  \t\t\tretval = -EINVAL;\n\t\t\tgoto fail0;\n\t\t}\n\t}\n\n\tif (!(urb->transfer_flags\
  \ & URB_NO_INTERRUPT))\n\t\ttflags |= URB_GIVEBACK_ASAP;\n\tif (urb->transfer_flags\
  \ & URB_ZERO_PACKET)\n\t\ttflags |= URB_SEND_ZERO_PACKET;\n\n\tdwc2_urb->priv =\
  \ urb;\n\tdwc2_urb->buf = buf;\n\tdwc2_urb->dma = urb->transfer_dma;\n\tdwc2_urb->length\
  \ = urb->transfer_buffer_length;\n\tdwc2_urb->setup_packet = urb->setup_packet;\n\
  \tdwc2_urb->setup_dma = urb->setup_dma;\n\tdwc2_urb->flags = tflags;\n\tdwc2_urb->interval\
  \ = urb->interval;\n\tdwc2_urb->status = -EINPROGRESS;\n\n\tfor (i = 0; i < urb->number_of_packets;\
  \ ++i)\n\t\tdwc2_hcd_urb_set_iso_desc_params(dwc2_urb, i,\n\t\t\t\t\t\t urb->iso_frame_desc[i].offset,\n\
  \t\t\t\t\t\t urb->iso_frame_desc[i].length);\n\n\turb->hcpriv = dwc2_urb;\n\tqh\
  \ = (struct dwc2_qh *)ep->hcpriv;\n\t/* Create QH for the endpoint if it doesn't\
  \ exist */\n\tif (!qh) {\n\t\tqh = dwc2_hcd_qh_create(hsotg, dwc2_urb, mem_flags);\n\
  \t\tif (!qh) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail0;\n\t\t}\n\t\tep->hcpriv\
  \ = qh;\n\t\tqh_allocated = true;\n\t}\n\n\tqtd = kzalloc(sizeof(*qtd), mem_flags);\n\
  \tif (!qtd) {\n\t\tretval = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tspin_lock_irqsave(&hsotg->lock,\
  \ flags);\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval)\n\t\tgoto\
  \ fail2;\n\n\tretval = dwc2_hcd_urb_enqueue(hsotg, dwc2_urb, qh, qtd);\n\tif (retval)\n\
  \t\tgoto fail3;\n\n\tif (alloc_bandwidth) {\n\t\tdwc2_allocate_bus_bandwidth(hcd,\n\
  \t\t\t\tdwc2_hcd_get_ep_bandwidth(hsotg, ep),\n\t\t\t\turb);\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock,\
  \ flags);\n\n\treturn 0;\n\nfail3:\n\tdwc2_urb->priv = NULL;\n\tusb_hcd_unlink_urb_from_ep(hcd,\
  \ urb);\n\tif (qh_allocated && qh->channel && qh->channel->qh == qh)\n\t\tqh->channel->qh\
  \ = NULL;\nfail2:\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\turb->hcpriv\
  \ = NULL;\n\tkfree(qtd);\nfail1:\n\tif (qh_allocated) {\n\t\tstruct dwc2_qtd *qtd2,\
  \ *qtd2_tmp;\n\n\t\tep->hcpriv = NULL;\n\t\tdwc2_hcd_qh_unlink(hsotg, qh);\n\t\t\
  /* Free each QTD in the QH's QTD list */\n\t\tlist_for_each_entry_safe(qtd2, qtd2_tmp,\
  \ &qh->qtd_list,\n\t\t\t\t\t qtd_list_entry)\n\t\t\tdwc2_hcd_qtd_unlink_and_free(hsotg,\
  \ qtd2, qh);\n\t\tdwc2_hcd_qh_free(hsotg, qh);\n\t}\nfail0:\n\tkfree(dwc2_urb);\n\
  \n\treturn retval;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/usb/dwc2/hcd.c\
  \ b/drivers/usb/dwc2/hcd.c\nindex 657f1f659ffa..35c7a4df8e71 100644\n--- a/drivers/usb/dwc2/hcd.c\n\
  +++ b/drivers/usb/dwc2/hcd.c\n@@ -4769,8 +4769,8 @@ static int _dwc2_hcd_urb_enqueue(struct\
  \ usb_hcd *hcd, struct urb *urb,\n \tif (qh_allocated && qh->channel && qh->channel->qh\
  \ == qh)\n \t\tqh->channel->qh = NULL;\n fail2:\n-\tspin_unlock_irqrestore(&hsotg->lock,\
  \ flags);\n \turb->hcpriv = NULL;\n+\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\
  \ \tkfree(qtd);\n fail1:\n \tif (qh_allocated) {\n```\n"
pattern: "## Bug Pattern\n\nUpdating a shared, lock-protected pointer (e.g., urb->hcpriv)\
  \ outside of its protecting lock, while other code checks and then uses that pointer\
  \ under the lock.\n\n- Writer (buggy): releases hsotg->lock and then sets urb->hcpriv\
  \ = NULL.\n- Reader: under hsotg->lock does:\n  if (!urb->hcpriv) goto out;\n  use(urb->hcpriv);\n\
  \nThis inconsistent locking allows a concurrent NULL assignment to race between\
  \ the check and the use, causing a NULL pointer dereference. The fix is to perform\
  \ the pointer update (setting to NULL) while still holding the same lock that guards\
  \ reads/uses of the pointer."
plan: "Plan\n\n1) Program state\n\n- REGISTER_TRAIT_WITH_PROGRAMSTATE(HeldLocks, LockSet)\n\
  \  - ImmutableSet<const MemRegion*> representing the currently held locks.\n  -\
  \ We identify a lock by the MemRegion of the first argument passed to spin_lock/spin_unlock\
  \ (typically the FieldRegion of X->lock or the VarRegion of a lock variable).\n\n\
  - REGISTER_MAP_WITH_PROGRAMSTATE(LockToObjSetMap, const MemRegion*, ImmutableSet<const\
  \ MemRegion*>)\n  - Map from a lock MemRegion L to the set of \u201Cobject\u201D\
  \ regions used while holding L.\n  - An \u201Cobject\u201D is the base MemRegion\
  \ of an expression like obj->field or a pointer variable (e.g., urb) passed as an\
  \ argument within the critical section protected by L.\n\n- REGISTER_TRAIT_WITH_PROGRAMSTATE(LastUnlockedLock,\
  \ const MemRegion*)\n  - Stores the lock MemRegion of the most recent spin_unlock*\
  \ call.\n  - Cleared as soon as we process the next statement of interest (e.g.,\
  \ any bind or non-unlock call), so \u201Cimmediately-after-unlock\u201D is enforced\
  \ and FPs are reduced.\n\n2) Helpers\n\n- isLockAcquire(const CallEvent&): true\
  \ if callee is one of:\n  - \"spin_lock\", \"spin_lock_irqsave\", \"spin_lock_bh\"\
  , \"spin_lock_irq\"\n- isLockRelease(const CallEvent&): true if callee is one of:\n\
  \  - \"spin_unlock\", \"spin_unlock_irqrestore\", \"spin_unlock_bh\", \"spin_unlock_irq\"\
  \n- getLockRegionFromCall(const CallEvent&, CheckerContext&): MemRegion*\n  - Returns\
  \ the region for the first argument of the lock function using getMemRegionFromExpr(Call.getArgExpr(0),\
  \ C). This becomes the key in HeldLocks/LockToObjSetMap.\n- recordObjUseUnderHeldLocks(const\
  \ Expr *ArgE, CheckerContext &C):\n  - If HeldLocks is non-empty, attempt to obtain\
  \ a base \u201Cobject\u201D MemRegion:\n    - If ArgE is MemberExpr or DeclRefExpr\
  \ (possibly with casts), get region with getMemRegionFromExpr(ArgE, C).\n    - If\
  \ ArgE is a MemberExpr of the form Base->Field, use Base\u2019s region as the \u201C\
  object\u201D region.\n  - For every held lock L in HeldLocks, add the object region\
  \ into LockToObjSetMap[L].\n- isPointerFieldAssignmentToNull(const Stmt *S, SVal\
  \ Loc, SVal Val, CheckerContext &C):\n  - Ensure S is a BinaryOperator assignment\
  \ with LHS a MemberExpr using \u201C->\u201D.\n  - Confirm LHS type is a pointer\
  \ type.\n  - Confirm RHS is NULL/0:\n    - Prefer checking Val as an SVal (null\
  \ location or zero integer), or\n    - Use EvaluateExprToInt on RHS and check zero.\n\
  - getBaseObjectRegionFromLHS(const BinaryOperator *BO, CheckerContext &C):\n  -\
  \ BO->getLHS() must be a MemberExpr ME; return getMemRegionFromExpr(ME->getBase(),\
  \ C).\n\n3) Callbacks and logic\n\nA) checkPreCall\n- Detect lock acquires:\n  -\
  \ If isLockAcquire(Call), get L = getLockRegionFromCall(Call, C) and add L to HeldLocks.\n\
  \  - Clear LastUnlockedLock if set (we only want the assignment immediately after\
  \ unlock).\n- While any lock is held, record object uses through arguments:\n  -\
  \ For each argument ArgE of any call (not just locks) when HeldLocks is non-empty,\
  \ call recordObjUseUnderHeldLocks(ArgE, C).\n  - This will capture cases like usb_hcd_link_urb_to_ep(hcd,\
  \ urb) under lock; it will register urb\u2019s MemRegion as being used under the\
  \ currently held locks.\n\nB) checkPostCall\n- Detect lock releases:\n  - If isLockRelease(Call),\
  \ get L = getLockRegionFromCall(Call, C).\n  - Remove L from HeldLocks (if present).\n\
  \  - Set LastUnlockedLock to L (this marks the unlock that the next statement belongs\
  \ to).\n- Otherwise, if LastUnlockedLock is set and this is a non-unlock call, clear\
  \ LastUnlockedLock to keep the \u201Cimmediately-after-unlock\u201D window small.\n\
  \nC) checkLocation\n- When HeldLocks is non-empty, we also record object usage on\
  \ memory accesses:\n  - Try to get a MemberExpr ancestor from S via findSpecificTypeInParents<MemberExpr>(S,\
  \ C).\n  - If found and it has a base expression BaseE, record BaseE\u2019s region\
  \ into LockToObjSetMap for every lock currently in HeldLocks.\n  - This complements\
  \ checkPreCall (so we catch both passing urb under lock as an argument and accessing\
  \ urb->field under lock).\n\nD) checkBind\n- Detect the core pattern:\n  - If LastUnlockedLock\
  \ is set (L_unlocked != nullptr) and HeldLocks is empty:\n    - Verify this bind\
  \ is a pointer field assignment to NULL using isPointerFieldAssignmentToNull(S,\
  \ Loc, Val, C).\n    - If yes:\n      - Obtain the base object region ObjR = getBaseObjectRegionFromLHS(BO,\
  \ C).\n      - Fetch the set S_objs = LockToObjSetMap[L_unlocked]. If ObjR is in\
  \ S_objs:\n        - Report bug: setting a shared pointer field of an object (previously\
  \ used under lock L_unlocked) immediately after releasing that lock.\n  - Regardless\
  \ of detection, clear LastUnlockedLock here (we only allow the immediate next assignment\
  \ to be considered).\n- Note: If the assignment occurs while any lock is still held\
  \ (HeldLocks non-empty), do nothing (this is the fixed/correct behavior).\n\nE)\
  \ checkBeginFunction / checkEndFunction\n- Optionally clear all state at function\
  \ entry; not strictly necessary as ProgramState is path-sensitive, but you may reset\
  \ LastUnlockedLock to nullptr in checkBeginFunction for clarity.\n\n4) Bug report\n\
  \n- When condition in checkBind triggers:\n  - Node: generateNonFatalErrorNode(State).\n\
  \  - Message: \u201CPointer field set to NULL after unlocking; may race with readers\
  \ under the lock\u201D\n  - Use PathSensitiveBugReport and attach ranges on the\
  \ assignment LHS.\n  - Optionally add notes:\n    - At the unlock call site (store\
  \ source range from the unlock Call and add as a note).\n    - At any recorded object\
  \ use under the lock (if you stored one representative program point), but this\
  \ is optional; keep it simple.\n\n5) Filters to reduce false positives\n\n- Only\
  \ trigger when:\n  - The LHS is a pointer-typed field (MemberExpr with isArrow(),\
  \ pointer type).\n  - RHS is definitely NULL/0.\n  - LastUnlockedLock is set and\
  \ there are no held locks.\n  - The same base object region was used under that\
  \ lock earlier on this path (exists in LockToObjSetMap[LastUnlockedLock]).\n- Clear\
  \ LastUnlockedLock on any non-unlock call and after any bind event to ensure we\
  \ focus on the immediate-after-unlock assignment pattern.\n\n6) Utility functions\
  \ usage\n\n- getMemRegionFromExpr: used to obtain regions for lock arguments and\
  \ base object expressions.\n- findSpecificTypeInParents: used in checkLocation to\
  \ recover MemberExpr when we see memory accesses.\n- EvaluateExprToInt: used in\
  \ isPointerFieldAssignmentToNull to confirm RHS is zero when needed.\n- ExprHasName:\
  \ optional to check specific lock names if needed, but prefer CallEvent.getCalleeIdentifier().\n\
  \n7) Summary of callback roles\n\n- checkPreCall: track lock acquisitions, record\
  \ object usage under held locks, clear LastUnlockedLock on other calls.\n- checkPostCall:\
  \ track lock releases and set LastUnlockedLock.\n- checkLocation: record object\
  \ usage under held locks when accessing members.\n- checkBind: detect \u201Cunlock\
  \ then set obj->ptr = NULL\u201D for an object previously used under that lock and\
  \ report.\n- checkBeginFunction: initialize LastUnlockedLock to null (optional)."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"llvm/ADT/ImmutableSet.h\"\n#include <memory>\n#include <initializer_list>\n\
  \nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//======================\
  \ Program state ======================\n\nusing LockSet = llvm::ImmutableSet<const\
  \ MemRegion *>;\nusing ObjSet  = llvm::ImmutableSet<const MemRegion *>;\n\nREGISTER_TRAIT_WITH_PROGRAMSTATE(HeldLocks,\
  \ LockSet)\nREGISTER_MAP_WITH_PROGRAMSTATE(LockToObjSetMap, const MemRegion*, ObjSet)\n\
  REGISTER_TRAIT_WITH_PROGRAMSTATE(LastUnlockedLock, const MemRegion*)\nREGISTER_TRAIT_WITH_PROGRAMSTATE(ObjSetTrait,\
  \ ObjSet)\n\n//====================== Helpers ============================\n\nstatic\
  \ bool isOneOf(StringRef S, std::initializer_list<StringRef> Names) {\n  for (auto\
  \ &N : Names)\n    if (S == N) return true;\n  return false;\n}\n\nstatic bool isLockAcquire(const\
  \ CallEvent &Call, CheckerContext &C) {\n  if (const IdentifierInfo *ID = Call.getCalleeIdentifier())\
  \ {\n    StringRef Name = ID->getName();\n    return isOneOf(Name, {\"spin_lock\"\
  , \"spin_lock_irqsave\", \"spin_lock_bh\", \"spin_lock_irq\"});\n  }\n  // Fallback\
  \ to textual check\n  const Expr *E = Call.getOriginExpr();\n  if (!E) return false;\n\
  \  return ExprHasName(E, \"spin_lock_irqsave\", C) ||\n         ExprHasName(E, \"\
  spin_lock_irq\", C) ||\n         ExprHasName(E, \"spin_lock_bh\", C) ||\n      \
  \   ExprHasName(E, \"spin_lock\", C);\n}\n\nstatic bool isLockRelease(const CallEvent\
  \ &Call, CheckerContext &C) {\n  if (const IdentifierInfo *ID = Call.getCalleeIdentifier())\
  \ {\n    StringRef Name = ID->getName();\n    return isOneOf(Name, {\"spin_unlock\"\
  , \"spin_unlock_irqrestore\", \"spin_unlock_bh\", \"spin_unlock_irq\"});\n  }\n\
  \  const Expr *E = Call.getOriginExpr();\n  if (!E) return false;\n  return ExprHasName(E,\
  \ \"spin_unlock_irqrestore\", C) ||\n         ExprHasName(E, \"spin_unlock_irq\"\
  , C) ||\n         ExprHasName(E, \"spin_unlock_bh\", C) ||\n         ExprHasName(E,\
  \ \"spin_unlock\", C);\n}\n\nstatic const MemRegion *getLockRegionFromCall(const\
  \ CallEvent &Call, CheckerContext &C) {\n  if (Call.getNumArgs() < 1)\n    return\
  \ nullptr;\n  const Expr *Arg0 = Call.getArgExpr(0);\n  if (!Arg0)\n    return nullptr;\n\
  \  const MemRegion *R = getMemRegionFromExpr(Arg0, C);\n  if (!R)\n    return nullptr;\n\
  \  return R->getBaseRegion();\n}\n\nstatic ProgramStateRef addHeldLock(ProgramStateRef\
  \ State, const MemRegion *Lock, CheckerContext &C) {\n  if (!Lock) return State;\n\
  \  LockSet Cur = State->get<HeldLocks>();\n  LockSet::Factory &F = State->get_context<HeldLocks>();\n\
  \  Cur = F.add(Cur, Lock);\n  State = State->set<HeldLocks>(Cur);\n  // When we\
  \ start holding a lock again, the \"just unlocked\" window is over.\n  State = State->set<LastUnlockedLock>(nullptr);\n\
  \  return State;\n}\n\nstatic ProgramStateRef removeHeldLock(ProgramStateRef State,\
  \ const MemRegion *Lock) {\n  if (!Lock) return State;\n  LockSet Cur = State->get<HeldLocks>();\n\
  \  LockSet::Factory &F = State->get_context<HeldLocks>();\n  Cur = F.remove(Cur,\
  \ Lock);\n  State = State->set<HeldLocks>(Cur);\n  return State;\n}\n\nstatic bool\
  \ objSetContains(const ObjSet &S, const MemRegion *R) {\n  for (auto It = S.begin();\
  \ It != S.end(); ++It) {\n    if (*It == R)\n      return true;\n  }\n  return false;\n\
  }\n\n// Record that \"ObjR\" is used while holding each lock in HeldLocks.\nstatic\
  \ ProgramStateRef recordObjUseUnderHeldLocks(ProgramStateRef State,\n          \
  \                                        const Expr *ArgE,\n                   \
  \                               CheckerContext &C) {\n  if (!ArgE)\n    return State;\n\
  \  LockSet Locks = State->get<HeldLocks>();\n  if (Locks.isEmpty())\n    return\
  \ State;\n\n  const MemRegion *ObjR = nullptr;\n\n  // If it's a member access,\
  \ prefer to use the base object's region.\n  if (const auto *ME = dyn_cast<MemberExpr>(ArgE->IgnoreParenCasts()))\
  \ {\n    const Expr *BaseE = ME->getBase();\n    ObjR = getMemRegionFromExpr(BaseE,\
  \ C);\n  } else {\n    ObjR = getMemRegionFromExpr(ArgE, C);\n  }\n\n  if (!ObjR)\n\
  \    return State;\n  ObjR = ObjR->getBaseRegion();\n  if (!ObjR)\n    return State;\n\
  \n  ObjSet::Factory &OF = State->get_context<ObjSetTrait>();\n  for (auto LI = Locks.begin();\
  \ LI != Locks.end(); ++LI) {\n    const MemRegion *LockR = *LI;\n    if (!LockR)\
  \ continue;\n    const ObjSet *CurPtr = State->get<LockToObjSetMap>(LockR);\n  \
  \  ObjSet Cur = CurPtr ? *CurPtr : OF.getEmptySet();\n    if (!objSetContains(Cur,\
  \ ObjR)) {\n      Cur = OF.add(Cur, ObjR);\n      State = State->set<LockToObjSetMap>(LockR,\
  \ Cur);\n    }\n  }\n  return State;\n}\n\nstatic bool isZeroSVal(SVal V) {\n  if\
  \ (auto CI = V.getAs<nonloc::ConcreteInt>())\n    return CI->getValue() == 0;\n\
  \  if (auto LCI = V.getAs<loc::ConcreteInt>())\n    return LCI->getValue() == 0;\n\
  \  return false;\n}\n\nstatic bool isPointerFieldAssignmentToNull(const Stmt *S,\
  \ SVal Loc, SVal Val,\n                                           CheckerContext\
  \ &C,\n                                           const BinaryOperator *&OutBO,\n\
  \                                           const MemberExpr *&OutME) {\n  OutBO\
  \ = nullptr;\n  OutME = nullptr;\n\n  const auto *BO = dyn_cast_or_null<BinaryOperator>(S);\n\
  \  if (!BO || !BO->isAssignmentOp())\n    return false;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \  const auto *ME = dyn_cast<MemberExpr>(LHS);\n  if (!ME)\n    return false;\n\n\
  \  // We focus on pointer field like obj->field.\n  if (!ME->isArrow())\n    return\
  \ false;\n\n  QualType FieldTy = ME->getType();\n  if (FieldTy.isNull() || !FieldTy->isPointerType())\n\
  \    return false;\n\n  bool IsNull = isZeroSVal(Val);\n  if (!IsNull) {\n    //\
  \ Try evaluate RHS constant int == 0\n    llvm::APSInt IntV;\n    if (EvaluateExprToInt(IntV,\
  \ BO->getRHS(), C))\n      IsNull = (IntV == 0);\n  }\n  if (!IsNull)\n    return\
  \ false;\n\n  OutBO = BO;\n  OutME = ME;\n  return true;\n}\n\nstatic const MemRegion\
  \ *getBaseObjectRegionFromLHS(const BinaryOperator *BO,\n                      \
  \                             CheckerContext &C) {\n  if (!BO) return nullptr;\n\
  \  const auto *ME = dyn_cast<MemberExpr>(BO->getLHS()->IgnoreParenCasts());\n  if\
  \ (!ME) return nullptr;\n  const Expr *BaseE = ME->getBase();\n  if (!BaseE) return\
  \ nullptr;\n  const MemRegion *R = getMemRegionFromExpr(BaseE, C);\n  if (!R) return\
  \ nullptr;\n  return R->getBaseRegion();\n}\n\n//====================== Checker\
  \ ============================\n\nnamespace {\n\nclass SAGenTestChecker\n  : public\
  \ Checker<check::BeginFunction,\n                   check::PreCall,\n          \
  \         check::PostCall,\n                   check::Location,\n              \
  \     check::Bind> {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\
  \ : BT(new BugType(this, \"Pointer field NULLed after unlock\", \"Concurrency\"\
  )) {}\n\n  void checkBeginFunction(CheckerContext &C) const;\n  void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  void checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S, CheckerContext &C) const;\n  void checkBind(SVal Loc, SVal Val,\
  \ const Stmt *S, CheckerContext &C) const;\n\nprivate:\n  void reportIssue(const\
  \ BinaryOperator *BO, CheckerContext &C) const;\n};\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  // Initialize/clear\
  \ per-function state.\n  State = State->set<HeldLocks>(State->get_context<HeldLocks>().getEmptySet());\n\
  \  State = State->set<LastUnlockedLock>(nullptr);\n\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n\n  // If this is a non-unlock\
  \ call and we have a pending \"just unlocked\" mark, clear it.\n  if (State->get<LastUnlockedLock>()\
  \ && !isLockRelease(Call, C) && !isLockAcquire(Call, C)) {\n    State = State->set<LastUnlockedLock>(nullptr);\n\
  \  }\n\n  // Handle lock acquire\n  if (isLockAcquire(Call, C)) {\n    if (const\
  \ MemRegion *LockR = getLockRegionFromCall(Call, C)) {\n      State = addHeldLock(State,\
  \ LockR, C);\n    }\n    C.addTransition(State);\n    return;\n  }\n\n  // While\
  \ locks are held, record any object/pointer arguments used inside the critical section.\n\
  \  if (!State->get<HeldLocks>().isEmpty()) {\n    for (unsigned i = 0; i < Call.getNumArgs();\
  \ ++i) {\n      const Expr *ArgE = Call.getArgExpr(i);\n      State = recordObjUseUnderHeldLocks(State,\
  \ ArgE, C);\n    }\n    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Handle lock release\n  if (isLockRelease(Call, C)) {\n    const MemRegion\
  \ *LockR = getLockRegionFromCall(Call, C);\n    State = removeHeldLock(State, LockR);\n\
  \    // Mark the last unlocked lock to detect the immediate next assignment.\n \
  \   State = State->set<LastUnlockedLock>(LockR);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // Any other call after unlock clears the \"just unlocked\"\
  \ mark to keep window small.\n  if (State->get<LastUnlockedLock>()) {\n    State\
  \ = State->set<LastUnlockedLock>(nullptr);\n    C.addTransition(State);\n  }\n}\n\
  \nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  if (State->get<HeldLocks>().isEmpty())\n\
  \    return;\n\n  // When under a lock, if the location is part of a MemberExpr,\
  \ record the base object.\n  const MemberExpr *ME = findSpecificTypeInParents<MemberExpr>(S,\
  \ C);\n  if (!ME)\n    return;\n\n  const Expr *BaseE = ME->getBase();\n  if (!BaseE)\n\
  \    return;\n\n  State = recordObjUseUnderHeldLocks(State, BaseE, C);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *JustUnlocked\
  \ = State->get<LastUnlockedLock>();\n  // We only care about the immediate next\
  \ assignment after an unlock, and only when no lock is held.\n  if (JustUnlocked\
  \ && State->get<HeldLocks>().isEmpty()) {\n    const BinaryOperator *BO = nullptr;\n\
  \    const MemberExpr *ME = nullptr;\n\n    if (isPointerFieldAssignmentToNull(S,\
  \ Loc, Val, C, BO, ME)) {\n      // Determine the \"object\" whose field is being\
  \ NULLed.\n      const MemRegion *ObjR = getBaseObjectRegionFromLHS(BO, C);\n  \
  \    if (ObjR) {\n        // Check if this object was used under the same lock earlier\
  \ in this path.\n        const ObjSet *UsedObjsPtr = State->get<LockToObjSetMap>(JustUnlocked);\n\
  \        if (UsedObjsPtr && objSetContains(*UsedObjsPtr, ObjR)) {\n          reportIssue(BO,\
  \ C);\n        }\n      }\n    }\n  }\n\n  // Regardless, clear the \"just unlocked\"\
  \ marker after the first bind we see.\n  if (JustUnlocked) {\n    State = State->set<LastUnlockedLock>(nullptr);\n\
  \    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::reportIssue(const\
  \ BinaryOperator *BO, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Pointer field set to NULL after unlocking; may race with readers under\
  \ the lock\", N);\n  if (BO)\n    R->addRange(BO->getLHS()->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects setting lock-protected pointer\
  \ fields to NULL immediately after unlocking\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
