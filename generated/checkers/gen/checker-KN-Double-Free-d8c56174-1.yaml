_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: d8c561741ef83980114b3f7f95ffac54600f3f16
commit_type: Double-Free
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n//====================\
  \ Program State Customization ====================//\n\n// Map return symbol of\
  \ hws_send_ring_create_sq() to the SQ object region.\nREGISTER_MAP_WITH_PROGRAMSTATE(CreateRetSymMap,\
  \ SymbolRef, const MemRegion*)\n// Map return symbol of hws_send_ring_set_sq_rdy()\
  \ to the SQ object region.\nREGISTER_MAP_WITH_PROGRAMSTATE(SetRdyRetSymMap, SymbolRef,\
  \ const MemRegion*)\n// Track the state of each SQ object region: 1=Created, 2=SetRdyFailedPendingDestroy\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(SQStateMap, const MemRegion*, unsigned)\n\nnamespace\
  \ {\n\nstatic const unsigned SQ_CREATED = 1;\nstatic const unsigned SQ_SET_RDY_FAILED\
  \ = 2;\n\nclass SAGenTestChecker\n    : public Checker<\n          check::PostCall,\n\
  \          check::PreCall,\n          eval::Assume> {\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Mismatched\
  \ cleanup after partial init\",\n                       \"Resource Management\"\
  )) {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n  ProgramStateRef\
  \ evalAssume(ProgramStateRef State, SVal Cond,\n                             bool\
  \ Assumption) const;\n\nprivate:\n  // Classification helpers\n  bool isCreateCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  bool isSetReadyCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  bool isCloseCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  bool isDestroyCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \n  // Extractors for SQ region\n  const MemRegion *getSQRegionFromCreate(const\
  \ CallEvent &Call,\n                                         CheckerContext &C)\
  \ const;\n  const MemRegion *getSQRegionFromSetRdy(const CallEvent &Call,\n    \
  \                                     CheckerContext &C) const;\n  const MemRegion\
  \ *getSQRegionFromClose(const CallEvent &Call,\n                               \
  \         CheckerContext &C) const;\n  const MemRegion *getSQRegionFromDestroy(const\
  \ CallEvent &Call,\n                                          CheckerContext &C)\
  \ const;\n\n  // Utility\n  const MemRegion *getBaseRegionFromExpr(const Expr *E,\n\
  \                                         CheckerContext &C) const;\n\n  void reportMismatchedClose(const\
  \ CallEvent &Call, CheckerContext &C) const;\n};\n\n//==================== Helper\
  \ Implementations ====================//\n\nbool SAGenTestChecker::isCreateCall(const\
  \ CallEvent &Call,\n                                    CheckerContext &C) const\
  \ {\n  const Expr *E = Call.getOriginExpr();\n  return E && ExprHasName(E, \"hws_send_ring_create_sq\"\
  , C);\n}\n\nbool SAGenTestChecker::isSetReadyCall(const CallEvent &Call,\n     \
  \                                 CheckerContext &C) const {\n  const Expr *E =\
  \ Call.getOriginExpr();\n  return E && ExprHasName(E, \"hws_send_ring_set_sq_rdy\"\
  , C);\n}\n\nbool SAGenTestChecker::isCloseCall(const CallEvent &Call,\n        \
  \                           CheckerContext &C) const {\n  const Expr *E = Call.getOriginExpr();\n\
  \  return E && ExprHasName(E, \"hws_send_ring_close_sq\", C);\n}\n\nbool SAGenTestChecker::isDestroyCall(const\
  \ CallEvent &Call,\n                                     CheckerContext &C) const\
  \ {\n  const Expr *E = Call.getOriginExpr();\n  if (!E)\n    return false;\n  return\
  \ ExprHasName(E, \"mlx5_core_destroy_sq\", C) ||\n         ExprHasName(E, \"hws_send_ring_destroy_sq\"\
  , C);\n}\n\nconst MemRegion *SAGenTestChecker::getBaseRegionFromExpr(const Expr\
  \ *E,\n                                                         CheckerContext &C)\
  \ const {\n  if (!E)\n    return nullptr;\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR)\n    return nullptr;\n  MR = MR->getBaseRegion();\n  return MR;\n\
  }\n\nconst MemRegion *SAGenTestChecker::getSQRegionFromCreate(const CallEvent &Call,\n\
  \                                                         CheckerContext &C) const\
  \ {\n  // hws_send_ring_create_sq(..., sq, ...)\n  // Index 4 is 'sq' (0-based).\n\
  \  if (Call.getNumArgs() <= 4)\n    return nullptr;\n  const Expr *Arg = Call.getArgExpr(4);\n\
  \  return getBaseRegionFromExpr(Arg, C);\n}\n\nconst MemRegion *SAGenTestChecker::getSQRegionFromSetRdy(const\
  \ CallEvent &Call,\n                                                         CheckerContext\
  \ &C) const {\n  // hws_send_ring_set_sq_rdy(mdev, sq->sqn)\n  if (Call.getNumArgs()\
  \ <= 1)\n    return nullptr;\n  const Expr *Arg = Call.getArgExpr(1);\n  const MemberExpr\
  \ *ME = findSpecificTypeInChildren<MemberExpr>(Arg);\n  if (!ME)\n    return nullptr;\n\
  \n  // Ensure the member is 'sqn'\n  const ValueDecl *VD = ME->getMemberDecl();\n\
  \  if (!VD)\n    return nullptr;\n  if (!VD->getName().equals(\"sqn\"))\n    return\
  \ nullptr;\n\n  const Expr *Base = ME->getBase();\n  return getBaseRegionFromExpr(Base,\
  \ C);\n}\n\nconst MemRegion *SAGenTestChecker::getSQRegionFromClose(const CallEvent\
  \ &Call,\n                                                        CheckerContext\
  \ &C) const {\n  // hws_send_ring_close_sq(sq)\n  if (Call.getNumArgs() < 1)\n \
  \   return nullptr;\n  const Expr *Arg = Call.getArgExpr(0);\n  return getBaseRegionFromExpr(Arg,\
  \ C);\n}\n\nconst MemRegion *SAGenTestChecker::getSQRegionFromDestroy(const CallEvent\
  \ &Call,\n                                                          CheckerContext\
  \ &C) const {\n  const Expr *E = Call.getOriginExpr();\n  if (!E)\n    return nullptr;\n\
  \n  // hws_send_ring_destroy_sq(mdev, sq)\n  if (ExprHasName(E, \"hws_send_ring_destroy_sq\"\
  , C)) {\n    if (Call.getNumArgs() <= 1)\n      return nullptr;\n    const Expr\
  \ *Arg = Call.getArgExpr(1);\n    return getBaseRegionFromExpr(Arg, C);\n  }\n\n\
  \  // mlx5_core_destroy_sq(mdev, sq->sqn)\n  if (ExprHasName(E, \"mlx5_core_destroy_sq\"\
  , C)) {\n    if (Call.getNumArgs() <= 1)\n      return nullptr;\n    const Expr\
  \ *Arg = Call.getArgExpr(1);\n    const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(Arg);\n\
  \    if (!ME)\n      return nullptr;\n\n    const ValueDecl *VD = ME->getMemberDecl();\n\
  \    if (!VD || !VD->getName().equals(\"sqn\"))\n      return nullptr;\n\n    const\
  \ Expr *Base = ME->getBase();\n    return getBaseRegionFromExpr(Base, C);\n  }\n\
  \n  return nullptr;\n}\n\n//==================== Core Logic ====================//\n\
  \nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\n                \
  \                     CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  if (isCreateCall(Call, C)) {\n    const MemRegion *SQReg = getSQRegionFromCreate(Call,\
  \ C);\n    if (!SQReg)\n      return;\n\n    SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\n\
  \    if (!RetSym)\n      return;\n\n    State = State->set<CreateRetSymMap>(RetSym,\
  \ SQReg);\n    C.addTransition(State);\n    return;\n  }\n\n  if (isSetReadyCall(Call,\
  \ C)) {\n    const MemRegion *SQReg = getSQRegionFromSetRdy(Call, C);\n    if (!SQReg)\n\
  \      return;\n\n    SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\n\
  \    if (!RetSym)\n      return;\n\n    State = State->set<SetRdyRetSymMap>(RetSym,\
  \ SQReg);\n    C.addTransition(State);\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call,\n                                    CheckerContext &C) const\
  \ {\n  ProgramStateRef State = C.getState();\n\n  if (isCloseCall(Call, C)) {\n\
  \    const MemRegion *R = getSQRegionFromClose(Call, C);\n    if (!R)\n      return;\n\
  \n    const unsigned *St = State->get<SQStateMap>(R);\n    if (St && *St == SQ_SET_RDY_FAILED)\
  \ {\n      reportMismatchedClose(Call, C);\n    }\n    return;\n  }\n\n  if (isDestroyCall(Call,\
  \ C)) {\n    const MemRegion *R = getSQRegionFromDestroy(Call, C);\n    if (!R)\n\
  \      return;\n\n    // Correct undo path, clear state for this SQ.\n    State\
  \ = State->remove<SQStateMap>(R);\n    C.addTransition(State);\n    return;\n  }\n\
  }\n\nProgramStateRef SAGenTestChecker::evalAssume(ProgramStateRef State, SVal Cond,\n\
  \                                             bool Assumption) const {\n  SymbolRef\
  \ S = Cond.getAsSymbol();\n  if (!S)\n    return State;\n\n  // Handle create_sq\
  \ return symbol: success iff Assumption == false for \"if (err)\".\n  if (const\
  \ MemRegion *R = State->get<CreateRetSymMap>(S)) {\n    State = State->remove<CreateRetSymMap>(S);\n\
  \    if (!Assumption) { // err == 0 -> created\n      State = State->set<SQStateMap>(R,\
  \ SQ_CREATED);\n    }\n    return State;\n  }\n\n  // Handle set_sq_rdy return symbol:\
  \ failure iff Assumption == true for \"if (err)\".\n  if (const MemRegion *R = State->get<SetRdyRetSymMap>(S))\
  \ {\n    State = State->remove<SetRdyRetSymMap>(S);\n    if (Assumption) { // err\
  \ != 0 -> set_rdy failed\n      // To reduce false positives, prefer upgrading only\
  \ if was created.\n      if (const unsigned *St = State->get<SQStateMap>(R)) {\n\
  \        if (*St == SQ_CREATED) {\n          State = State->set<SQStateMap>(R, SQ_SET_RDY_FAILED);\n\
  \        }\n      }\n    }\n    return State;\n  }\n\n  return State;\n}\n\nvoid\
  \ SAGenTestChecker::reportMismatchedClose(const CallEvent &Call,\n             \
  \                                CheckerContext &C) const {\n  ExplodedNode *N =\
  \ C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Use destroy after set_sq_rdy() failure; close() here may double\
  \ free.\",\n      N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects mismatched close vs destroy after set_sq_rdy failure in mlx5\
  \ SQ setup\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/mlx5: HWS, fixed double-free in error flow of\
  \ creating SQ\n\nWhen SQ creation fails, call the appropriate mlx5_core destroy\
  \ function.\n\nThis fixes the following smatch warnings:\n  divers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c:739\n\
  \    hws_send_ring_open_sq() warn: 'sq->dep_wqe' double freed\n    hws_send_ring_open_sq()\
  \ warn: 'sq->wq_ctrl.buf.frags' double freed\n    hws_send_ring_open_sq() warn:\
  \ 'sq->wr_priv' double freed\n\nFixes: 2ca62599aa0b (\"net/mlx5: HWS, added send\
  \ engine and context handling\")\nReported-by: Dan Carpenter <dan.carpenter@linaro.org>\n\
  Closes: https://lore.kernel.org/all/e4ebc227-4b25-49bf-9e4c-14b7ea5c6a07@stanley.mountain/\n\
  Signed-off-by: Yevgeny Kliteynik <kliteyn@nvidia.com>\nSigned-off-by: Saeed Mahameed\
  \ <saeedm@nvidia.com>\n\n## Buggy Code\n\n```c\n// Function: hws_send_ring_create_sq\
  \ in drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\nstatic\
  \ int hws_send_ring_create_sq(struct mlx5_core_dev *mdev, u32 pdn,\n\t\t\t\t   void\
  \ *sqc_data,\n\t\t\t\t   struct mlx5hws_send_engine *queue,\n\t\t\t\t   struct mlx5hws_send_ring_sq\
  \ *sq,\n\t\t\t\t   struct mlx5hws_send_ring_cq *cq)\n{\n\tvoid *in, *sqc, *wq;\n\
  \tint inlen, err;\n\tu8 ts_format;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_sq_in) +\n\
  \t\tsizeof(u64) * sq->wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\
  \tif (!in)\n\t\treturn -ENOMEM;\n\n\tsqc = MLX5_ADDR_OF(create_sq_in, in, ctx);\n\
  \twq = MLX5_ADDR_OF(sqc, sqc, wq);\n\n\tmemcpy(sqc, sqc_data, MLX5_ST_SZ_BYTES(sqc));\n\
  \tMLX5_SET(sqc, sqc, cqn, cq->mcq.cqn);\n\n\tMLX5_SET(sqc, sqc, state, MLX5_SQC_STATE_RST);\n\
  \tMLX5_SET(sqc, sqc, flush_in_error_en, 1);\n\n\tts_format = mlx5_is_real_time_sq(mdev)\
  \ ? MLX5_TIMESTAMP_FORMAT_REAL_TIME :\n\t\t\t\t\t\t MLX5_TIMESTAMP_FORMAT_FREE_RUNNING;\n\
  \tMLX5_SET(sqc, sqc, ts_format, ts_format);\n\n\tMLX5_SET(wq, wq, wq_type, MLX5_WQ_TYPE_CYCLIC);\n\
  \tMLX5_SET(wq, wq, uar_page, mdev->mlx5e_res.hw_objs.bfreg.index);\n\tMLX5_SET(wq,\
  \ wq, log_wq_pg_sz, sq->wq_ctrl.buf.page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(wq,\
  \ wq, dbr_addr, sq->wq_ctrl.db.dma);\n\n\tmlx5_fill_page_frag_array(&sq->wq_ctrl.buf,\n\
  \t\t\t\t  (__be64 *)MLX5_ADDR_OF(wq, wq, pas));\n\n\terr = mlx5_core_create_sq(mdev,\
  \ in, inlen, &sq->sqn);\n\n\tkvfree(in);\n\n\treturn err;\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\
  \ b/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\nindex a1adbb48735c..0c7989184c30\
  \ 100644\n--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\n\
  +++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\n@@ -653,6\
  \ +653,12 @@ static int hws_send_ring_create_sq(struct mlx5_core_dev *mdev, u32\
  \ pdn,\n \treturn err;\n }\n \n+static void hws_send_ring_destroy_sq(struct mlx5_core_dev\
  \ *mdev,\n+\t\t\t\t     struct mlx5hws_send_ring_sq *sq)\n+{\n+\tmlx5_core_destroy_sq(mdev,\
  \ sq->sqn);\n+}\n+\n static int hws_send_ring_set_sq_rdy(struct mlx5_core_dev *mdev,\
  \ u32 sqn)\n {\n \tvoid *in, *sqc;\n@@ -696,7 +702,7 @@ static int hws_send_ring_create_sq_rdy(struct\
  \ mlx5_core_dev *mdev, u32 pdn,\n \n \terr = hws_send_ring_set_sq_rdy(mdev, sq->sqn);\n\
  \ \tif (err)\n-\t\thws_send_ring_close_sq(sq);\n+\t\thws_send_ring_destroy_sq(mdev,\
  \ sq);\n \n \treturn err;\n }\n```\n"
pattern: "## Bug Pattern\n\nUsing a full \u201Cclose\u201D/finalizer routine in a\
  \ partial-initialization error path instead of the exact destroy/undo pair for the\
  \ last successful step. Specifically, after successfully calling mlx5_core_create_sq()\
  \ but failing the subsequent set-to-ready step, the code called hws_send_ring_close_sq()\
  \ (which frees software-owned resources that will be freed again later), rather\
  \ than the matching rollback mlx5_core_destroy_sq(). This mismatch in teardown (close\
  \ vs destroy) on intermediate failure leads to double-free of SQ-owned buffers/priv\
  \ data."
plan: "Plan\n\n1) Program state customizations\n- REGISTER_MAP_WITH_PROGRAMSTATE(CreateRetSymMap,\
  \ SymbolRef, const MemRegion*)\n  - Maps the return symbol of hws_send_ring_create_sq()\
  \ to the SQ object region (struct mlx5hws_send_ring_sq *) passed to the call. Used\
  \ to learn on which branch the create succeeded.\n- REGISTER_MAP_WITH_PROGRAMSTATE(SetRdyRetSymMap,\
  \ SymbolRef, const MemRegion*)\n  - Maps the return symbol of hws_send_ring_set_sq_rdy()\
  \ to the SQ object region, derived from the sq->sqn argument. Used to recognize\
  \ the error branch after the set-to-ready step.\n- REGISTER_MAP_WITH_PROGRAMSTATE(SQStateMap,\
  \ const MemRegion*, unsigned)\n  - Tracks a simple state machine for the SQ object\
  \ region.\n  - Values:\n    - 1 = Created (mlx5_core_create_sq() step succeeded\
  \ for this sq)\n    - 2 = SetRdyFailedPendingDestroy (set-to-ready failed; we expect\
  \ the exact destroy/undo, not a full close)\n\n2) Helper classification and extractors\n\
  - bool isCreateCall(const CallEvent &Call)\n  - Return true if callee name is \"\
  hws_send_ring_create_sq\".\n- bool isSetReadyCall(const CallEvent &Call)\n  - Return\
  \ true if callee name is \"hws_send_ring_set_sq_rdy\".\n- bool isCloseCall(const\
  \ CallEvent &Call)\n  - Return true if callee name is \"hws_send_ring_close_sq\"\
  .\n- bool isDestroyCall(const CallEvent &Call)\n  - Return true if callee name is\
  \ \"mlx5_core_destroy_sq\" or \"hws_send_ring_destroy_sq\".\n- const MemRegion *getSQRegionFromCreate(const\
  \ CallEvent &Call, CheckerContext &C)\n  - For hws_send_ring_create_sq, the 'sq'\
  \ parameter index is 4 (0-based).\n  - Get Call.getArgExpr(4) and use getMemRegionFromExpr()\
  \ to obtain the base region.\n- const MemRegion *getSQRegionFromSetRdy(const CallEvent\
  \ &Call, CheckerContext &C)\n  - For hws_send_ring_set_sq_rdy, the second argument\
  \ (index 1) is sqn.\n  - Obtain Call.getArgExpr(1). Use findSpecificTypeInChildren<MemberExpr>(ArgExpr)\
  \ to find a MemberExpr. If found and the member name is \"sqn\", extract its base\
  \ expression and call getMemRegionFromExpr(BaseExpr) to get the SQ base region.\
  \ If this fails, return nullptr (do nothing for this call).\n- const MemRegion *getSQRegionFromClose(const\
  \ CallEvent &Call, CheckerContext &C)\n  - For hws_send_ring_close_sq, 'sq' is the\
  \ first parameter (index 0). Use getMemRegionFromExpr().\n- const MemRegion *getSQRegionFromDestroy(const\
  \ CallEvent &Call, CheckerContext &C)\n  - For hws_send_ring_destroy_sq, 'sq' is\
  \ at index 1. Use getMemRegionFromExpr().\n  - For mlx5_core_destroy_sq, 'sqn' is\
  \ at index 1; mirror getSQRegionFromSetRdy: find a MemberExpr named \"sqn\" and\
  \ take its base region.\n\n3) Callbacks and detailed logic\n\n- checkPostCall (const\
  \ CallEvent &Call, CheckerContext &C) const\n  - If isCreateCall(Call):\n    - Extract\
  \ SQ region via getSQRegionFromCreate().\n    - Get return value symbol: if SymbolRef\
  \ RetSym = Call.getReturnValue().getAsSymbol() is non-null, record State = State.set<CreateRetSymMap>(RetSym,\
  \ SQRegion).\n  - If isSetReadyCall(Call):\n    - Extract SQ region via getSQRegionFromSetRdy().\n\
  \    - If SymbolRef RetSym is available, record State = State.set<SetRdyRetSymMap>(RetSym,\
  \ SQRegion).\n\n- evalAssume (ProgramStateRef State, SVal Cond, bool Assumption)\
  \ const\n  - Extract the symbol from Cond (e.g., if Cond is a SymbolVal or wraps\
  \ one). If no symbol, return State unchanged.\n  - If the symbol S is in CreateRetSymMap:\n\
  \    - Success path is when the condition evaluates to false for \u201Cif (err)\u201D\
  \ patterns, i.e., Assumption == false means err == 0.\n    - On Assumption == false:\n\
  \      - Get the SQ region R from the map.\n      - Set SQStateMap[R] = 1 (Created).\n\
  \    - Remove S from CreateRetSymMap in both branches.\n  - If the symbol S is in\
  \ SetRdyRetSymMap:\n    - Error path is when \u201Cif (err)\u201D condition evaluates\
  \ to true, i.e., Assumption == true means err != 0.\n    - On Assumption == true:\n\
  \      - Get SQ region R; update SQStateMap[R] = 2 (SetRdyFailedPendingDestroy).\
  \ Optionally require that R already has state Created before upgrading, to reduce\
  \ false positives.\n    - Remove S from SetRdyRetSymMap in both branches.\n\n- checkPreCall\
  \ (const CallEvent &Call, CheckerContext &C) const\n  - If isCloseCall(Call):\n\
  \    - Extract R = getSQRegionFromClose(Call, C). If null, return.\n    - Fetch\
  \ st = SQStateMap[R].\n    - If st == 2 (SetRdyFailedPendingDestroy):\n      - This\
  \ is the bug: a full \u201Cclose\u201D is used on the error path after only create\
  \ succeeded and set-to-ready failed; we expect a destroy/undo instead.\n      -\
  \ Emit a bug report:\n        - Create a non-fatal error node. If null, return.\n\
  \        - Short message: \"Use destroy after set_sq_rdy() failure; close() here\
  \ may double free.\"\n  - If isDestroyCall(Call):\n    - Extract R = getSQRegionFromDestroy(Call,\
  \ C). If non-null:\n      - Clear/erase R from SQStateMap (we are doing the correct\
  \ undo; no warning here).\n\n- checkEndFunction (const ReturnStmt *RS, CheckerContext\
  \ &C) const\n  - Best-effort cleanup: clear all maps for the current function context\
  \ (optional; the engine also discards state when leaving the function).\n\n4) Notes\
  \ on precision and false positives\n- The checker is narrowly focused on the specific\
  \ pair:\n  - create: hws_send_ring_create_sq\n  - set-to-ready: hws_send_ring_set_sq_rdy\n\
  \  - expected destroy: mlx5_core_destroy_sq or hws_send_ring_destroy_sq\n  - harmful\
  \ close: hws_send_ring_close_sq\n- We only warn when:\n  - We are on the error branch\
  \ of set-to-ready (captured by evalAssume with SetRdyRetSymMap + Assumption == true),\
  \ and\n  - The SQ region is known to be in Created state, and\n  - A close() is\
  \ called with that same SQ region.\n- SQ region extraction for set-to-ready/destroy\
  \ via MemberExpr \"sqn\" is done using findSpecificTypeInChildren and getMemRegionFromExpr,\
  \ avoiding complex alias analysis.\n\n5) Utility functions usage\n- getMemRegionFromExpr\
  \ to obtain MemRegion for pointer parameters.\n- findSpecificTypeInChildren<MemberExpr>\
  \ to locate the sq->sqn member use in set-to-ready/destroy calls and retrieve its\
  \ base region.\n- ExprHasName can be used as a fallback assert/check to ensure the\
  \ member name is \"sqn\" if useful for robustness.\n\n6) Reporting\n- Use a single\
  \ BugType cached in the checker: \"Mismatched cleanup after partial init\".\n- Report\
  \ creation:\n  - auto N = C.generateNonFatalErrorNode();\n  - auto R = std::make_unique<PathSensitiveBugReport>(BugType,\
  \ \"Use destroy after set_sq_rdy() failure; close() here may double free.\", N);\n\
  \  - C.emitReport(std::move(R))."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/Lex/Lexer.h\"\n#include <memory>\n\
  \nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//====================\
  \ Program State Customization ====================//\n\n// Map return symbol of\
  \ hws_send_ring_create_sq() to the SQ object region.\nREGISTER_MAP_WITH_PROGRAMSTATE(CreateRetSymMap,\
  \ SymbolRef, const MemRegion*)\n// Map return symbol of hws_send_ring_set_sq_rdy()\
  \ to the SQ object region.\nREGISTER_MAP_WITH_PROGRAMSTATE(SetRdyRetSymMap, SymbolRef,\
  \ const MemRegion*)\n// Track the state of each SQ object region: 1=Created, 2=SetRdyFailedPendingDestroy\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(SQStateMap, const MemRegion*, unsigned)\n\nnamespace\
  \ {\n\nstatic const unsigned SQ_CREATED = 1;\nstatic const unsigned SQ_SET_RDY_FAILED\
  \ = 2;\n\nclass SAGenTestChecker\n    : public Checker<\n          check::PostCall,\n\
  \          check::PreCall,\n          eval::Assume> {\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Mismatched\
  \ cleanup after partial init\",\n                       \"Resource Management\"\
  )) {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n  ProgramStateRef\
  \ evalAssume(ProgramStateRef State, SVal Cond,\n                             bool\
  \ Assumption) const;\n\nprivate:\n  // Classification helpers\n  bool isCreateCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  bool isSetReadyCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  bool isCloseCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  bool isDestroyCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \n  // Extractors for SQ region\n  const MemRegion *getSQRegionFromCreate(const\
  \ CallEvent &Call,\n                                         CheckerContext &C)\
  \ const;\n  const MemRegion *getSQRegionFromSetRdy(const CallEvent &Call,\n    \
  \                                     CheckerContext &C) const;\n  const MemRegion\
  \ *getSQRegionFromClose(const CallEvent &Call,\n                               \
  \         CheckerContext &C) const;\n  const MemRegion *getSQRegionFromDestroy(const\
  \ CallEvent &Call,\n                                          CheckerContext &C)\
  \ const;\n\n  // Utility\n  const MemRegion *getBaseRegionFromExpr(const Expr *E,\n\
  \                                         CheckerContext &C) const;\n\n  void reportMismatchedClose(const\
  \ CallEvent &Call, CheckerContext &C) const;\n};\n\n//==================== Helper\
  \ Implementations ====================//\n\nbool SAGenTestChecker::isCreateCall(const\
  \ CallEvent &Call,\n                                    CheckerContext &C) const\
  \ {\n  const Expr *E = Call.getOriginExpr();\n  return E && ExprHasName(E, \"hws_send_ring_create_sq\"\
  , C);\n}\n\nbool SAGenTestChecker::isSetReadyCall(const CallEvent &Call,\n     \
  \                                 CheckerContext &C) const {\n  const Expr *E =\
  \ Call.getOriginExpr();\n  return E && ExprHasName(E, \"hws_send_ring_set_sq_rdy\"\
  , C);\n}\n\nbool SAGenTestChecker::isCloseCall(const CallEvent &Call,\n        \
  \                           CheckerContext &C) const {\n  const Expr *E = Call.getOriginExpr();\n\
  \  return E && ExprHasName(E, \"hws_send_ring_close_sq\", C);\n}\n\nbool SAGenTestChecker::isDestroyCall(const\
  \ CallEvent &Call,\n                                     CheckerContext &C) const\
  \ {\n  const Expr *E = Call.getOriginExpr();\n  if (!E)\n    return false;\n  return\
  \ ExprHasName(E, \"mlx5_core_destroy_sq\", C) ||\n         ExprHasName(E, \"hws_send_ring_destroy_sq\"\
  , C);\n}\n\nconst MemRegion *SAGenTestChecker::getBaseRegionFromExpr(const Expr\
  \ *E,\n                                                         CheckerContext &C)\
  \ const {\n  if (!E)\n    return nullptr;\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR)\n    return nullptr;\n  MR = MR->getBaseRegion();\n  return MR;\n\
  }\n\nconst MemRegion *SAGenTestChecker::getSQRegionFromCreate(const CallEvent &Call,\n\
  \                                                         CheckerContext &C) const\
  \ {\n  // hws_send_ring_create_sq(..., sq, ...)\n  // Index 4 is 'sq' (0-based).\n\
  \  if (Call.getNumArgs() <= 4)\n    return nullptr;\n  const Expr *Arg = Call.getArgExpr(4);\n\
  \  return getBaseRegionFromExpr(Arg, C);\n}\n\nconst MemRegion *SAGenTestChecker::getSQRegionFromSetRdy(const\
  \ CallEvent &Call,\n                                                         CheckerContext\
  \ &C) const {\n  // hws_send_ring_set_sq_rdy(mdev, sq->sqn)\n  if (Call.getNumArgs()\
  \ <= 1)\n    return nullptr;\n  const Expr *Arg = Call.getArgExpr(1);\n  const MemberExpr\
  \ *ME = findSpecificTypeInChildren<MemberExpr>(Arg);\n  if (!ME)\n    return nullptr;\n\
  \n  // Ensure the member is 'sqn'\n  const ValueDecl *VD = ME->getMemberDecl();\n\
  \  if (!VD)\n    return nullptr;\n  if (!VD->getName().equals(\"sqn\"))\n    return\
  \ nullptr;\n\n  const Expr *Base = ME->getBase();\n  return getBaseRegionFromExpr(Base,\
  \ C);\n}\n\nconst MemRegion *SAGenTestChecker::getSQRegionFromClose(const CallEvent\
  \ &Call,\n                                                        CheckerContext\
  \ &C) const {\n  // hws_send_ring_close_sq(sq)\n  if (Call.getNumArgs() < 1)\n \
  \   return nullptr;\n  const Expr *Arg = Call.getArgExpr(0);\n  return getBaseRegionFromExpr(Arg,\
  \ C);\n}\n\nconst MemRegion *SAGenTestChecker::getSQRegionFromDestroy(const CallEvent\
  \ &Call,\n                                                          CheckerContext\
  \ &C) const {\n  const Expr *E = Call.getOriginExpr();\n  if (!E)\n    return nullptr;\n\
  \n  // hws_send_ring_destroy_sq(mdev, sq)\n  if (ExprHasName(E, \"hws_send_ring_destroy_sq\"\
  , C)) {\n    if (Call.getNumArgs() <= 1)\n      return nullptr;\n    const Expr\
  \ *Arg = Call.getArgExpr(1);\n    return getBaseRegionFromExpr(Arg, C);\n  }\n\n\
  \  // mlx5_core_destroy_sq(mdev, sq->sqn)\n  if (ExprHasName(E, \"mlx5_core_destroy_sq\"\
  , C)) {\n    if (Call.getNumArgs() <= 1)\n      return nullptr;\n    const Expr\
  \ *Arg = Call.getArgExpr(1);\n    const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(Arg);\n\
  \    if (!ME)\n      return nullptr;\n\n    const ValueDecl *VD = ME->getMemberDecl();\n\
  \    if (!VD || !VD->getName().equals(\"sqn\"))\n      return nullptr;\n\n    const\
  \ Expr *Base = ME->getBase();\n    return getBaseRegionFromExpr(Base, C);\n  }\n\
  \n  return nullptr;\n}\n\n//==================== Core Logic ====================//\n\
  \nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\n                \
  \                     CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  if (isCreateCall(Call, C)) {\n    const MemRegion *SQReg = getSQRegionFromCreate(Call,\
  \ C);\n    if (!SQReg)\n      return;\n\n    SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\n\
  \    if (!RetSym)\n      return;\n\n    State = State->set<CreateRetSymMap>(RetSym,\
  \ SQReg);\n    C.addTransition(State);\n    return;\n  }\n\n  if (isSetReadyCall(Call,\
  \ C)) {\n    const MemRegion *SQReg = getSQRegionFromSetRdy(Call, C);\n    if (!SQReg)\n\
  \      return;\n\n    SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\n\
  \    if (!RetSym)\n      return;\n\n    State = State->set<SetRdyRetSymMap>(RetSym,\
  \ SQReg);\n    C.addTransition(State);\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call,\n                                    CheckerContext &C) const\
  \ {\n  ProgramStateRef State = C.getState();\n\n  if (isCloseCall(Call, C)) {\n\
  \    const MemRegion *R = getSQRegionFromClose(Call, C);\n    if (!R)\n      return;\n\
  \n    const unsigned *St = State->get<SQStateMap>(R);\n    if (St && *St == SQ_SET_RDY_FAILED)\
  \ {\n      reportMismatchedClose(Call, C);\n    }\n    return;\n  }\n\n  if (isDestroyCall(Call,\
  \ C)) {\n    const MemRegion *R = getSQRegionFromDestroy(Call, C);\n    if (!R)\n\
  \      return;\n\n    // Correct undo path, clear state for this SQ.\n    State\
  \ = State->remove<SQStateMap>(R);\n    C.addTransition(State);\n    return;\n  }\n\
  }\n\nProgramStateRef SAGenTestChecker::evalAssume(ProgramStateRef State, SVal Cond,\n\
  \                                             bool Assumption) const {\n  SymbolRef\
  \ S = Cond.getAsSymbol();\n  if (!S)\n    return State;\n\n  // Handle create_sq\
  \ return symbol: success iff Assumption == false for \"if (err)\".\n  if (const\
  \ MemRegion *const *RPtr = State->get<CreateRetSymMap>(S)) {\n    const MemRegion\
  \ *R = *RPtr;\n    State = State->remove<CreateRetSymMap>(S);\n    if (!Assumption)\
  \ { // err == 0 -> created\n      State = State->set<SQStateMap>(R, SQ_CREATED);\n\
  \    }\n    return State;\n  }\n\n  // Handle set_sq_rdy return symbol: failure\
  \ iff Assumption == true for \"if (err)\".\n  if (const MemRegion *const *RPtr =\
  \ State->get<SetRdyRetSymMap>(S)) {\n    const MemRegion *R = *RPtr;\n    State\
  \ = State->remove<SetRdyRetSymMap>(S);\n    if (Assumption) { // err != 0 -> set_rdy\
  \ failed\n      // To reduce false positives, prefer upgrading only if was created.\n\
  \      if (const unsigned *St = State->get<SQStateMap>(R)) {\n        if (*St ==\
  \ SQ_CREATED) {\n          State = State->set<SQStateMap>(R, SQ_SET_RDY_FAILED);\n\
  \        }\n      }\n    }\n    return State;\n  }\n\n  return State;\n}\n\nvoid\
  \ SAGenTestChecker::reportMismatchedClose(const CallEvent &Call,\n             \
  \                                CheckerContext &C) const {\n  ExplodedNode *N =\
  \ C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Use destroy after set_sq_rdy() failure; close() here may double\
  \ free.\",\n      N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects mismatched close vs destroy after set_sq_rdy failure in mlx5\
  \ SQ setup\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
