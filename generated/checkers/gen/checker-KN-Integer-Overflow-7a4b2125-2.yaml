_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 7a4b21250bf79eef26543d35bd390448646c536b
commit_type: Integer-Overflow
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Basic/SourceManager.h\"\n\nusing\
  \ namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n// Track LHS\
  \ regions that currently hold the result of roundup_pow_of_two(arg).\n// Map key:\
  \ the base MemRegion of the variable holding the result.\n// Map value: the original\
  \ argument Expr* (as a tag/context; not dereferenced).\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResultMap,\
  \ const MemRegion*, const Expr*)\n\nnamespace {\nclass SAGenTestChecker\n  : public\
  \ Checker<\n        check::Bind,\n        check::BranchCondition> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"Unsafe overflow check of roundup_pow_of_two()\", \"Undefined Behavior\"\
  )) {}\n\n      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const;\n      void checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const;\n\n   private:\n      bool isRoundupPow2Call(const CallExpr *CE, CheckerContext\
  \ &C) const;\n      void reportIssue(const Stmt *Trigger, CheckerContext &C) const;\n\
  };\n} // end anonymous namespace\n\nbool SAGenTestChecker::isRoundupPow2Call(const\
  \ CallExpr *CE, CheckerContext &C) const {\n  if (!CE)\n    return false;\n  const\
  \ Expr *Origin = CE;\n  return ExprHasName(Origin, \"roundup_pow_of_two\", C);\n\
  }\n\nvoid SAGenTestChecker::reportIssue(const Stmt *Trigger, CheckerContext &C)\
  \ const {\n  // Optional gating: only warn when unsigned long is 32-bit or smaller.\n\
  \  unsigned ULBits = C.getASTContext().getTypeSize(C.getASTContext().UnsignedLongTy);\n\
  \  if (ULBits > 32)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"roundup_pow_of_two() result checked for zero; check the input\
  \ before calling (avoid UB on 32-bit).\",\n      N);\n  if (Trigger)\n    R->addRange(Trigger->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc,\
  \ SVal Val, const Stmt *S, CheckerContext &C) const {\n  const MemRegion *LHSReg\
  \ = Loc.getAsRegion();\n  if (!LHSReg)\n    return;\n  LHSReg = LHSReg->getBaseRegion();\n\
  \  if (!LHSReg)\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  //\
  \ Try to find a CallExpr within the statement causing the bind.\n  const CallExpr\
  \ *CE = findSpecificTypeInChildren<CallExpr>(S);\n  if (!CE || !isRoundupPow2Call(CE,\
  \ C)) {\n    // Overwritten with a non-roundup value; clear any previous mark.\n\
  \    State = State->remove<RoundupResultMap>(LHSReg);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // Mark the region as holding a roundup_pow_of_two result.\n\
  \  const Expr *ArgE = (CE->getNumArgs() > 0) ? CE->getArg(0) : nullptr;\n  State\
  \ = State->set<RoundupResultMap>(LHSReg, ArgE);\n  C.addTransition(State);\n}\n\n\
  void SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE)\n    return;\n\n  // Identify zero-check patterns.\n  const Expr\
  \ *RegionExpr = nullptr;     // The expression we will try to resolve to a MemRegion\
  \ (do NOT strip casts before calling getMemRegionFromExpr).\n  const Expr *AnalyzeExpr\
  \ = nullptr;    // A normalized form for analysis (we can strip parens/casts here).\n\
  \n  const Expr *CondNoImp = CondE->IgnoreParenImpCasts();\n  if (const auto *UO\
  \ = dyn_cast<UnaryOperator>(CondNoImp)) {\n    if (UO->getOpcode() == UO_LNot) {\n\
  \      RegionExpr = UO->getSubExpr(); // keep original for region extraction\n \
  \     AnalyzeExpr = UO->getSubExpr()->IgnoreParenImpCasts();\n    }\n  } else if\
  \ (const auto *BO = dyn_cast<BinaryOperator>(CondNoImp)) {\n    if (BO->getOpcode()\
  \ == BO_EQ) {\n      const Expr *LHSOrig = BO->getLHS();\n      const Expr *RHSOrig\
  \ = BO->getRHS();\n      const Expr *LHS = LHSOrig->IgnoreParenImpCasts();\n   \
  \   const Expr *RHS = RHSOrig->IgnoreParenImpCasts();\n\n      llvm::APSInt EvalRes;\n\
  \      bool LHSIsZero = EvaluateExprToInt(EvalRes, LHS, C) && EvalRes.isZero();\n\
  \      bool RHSIsZero = EvaluateExprToInt(EvalRes, RHS, C) && EvalRes.isZero();\n\
  \n      if (LHSIsZero ^ RHSIsZero) {\n        // Choose the non-zero side as the\
  \ expression under check.\n        if (LHSIsZero) {\n          RegionExpr = RHSOrig;\
  \                 // use original for region\n          AnalyzeExpr = RHS;     \
  \               // use normalized for analysis\n        } else {\n          RegionExpr\
  \ = LHSOrig;\n          AnalyzeExpr = LHS;\n        }\n      }\n    }\n  } else\
  \ {\n    // Not a zero-check; ignore.\n    return;\n  }\n\n  if (!RegionExpr ||\
  \ !AnalyzeExpr)\n    return;\n\n  // Case 1: Direct call in the condition.\n  if\
  \ (const CallExpr *InnerCE = findSpecificTypeInChildren<CallExpr>(AnalyzeExpr))\
  \ {\n    if (isRoundupPow2Call(InnerCE, C)) {\n      reportIssue(Condition, C);\n\
  \      return;\n    }\n  }\n\n  // Case 2: Variable holds a roundup_pow_of_two result.\n\
  \  const MemRegion *MR = getMemRegionFromExpr(RegionExpr, C);\n  if (!MR)\n    return;\n\
  \  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\n  if (const Expr *const*\
  \ Tagged = State->get<RoundupResultMap>(MR)) {\n    (void)Tagged; // We don't need\
  \ to use the argument, only the tag presence.\n    reportIssue(Condition, C);\n\
  \  }\n}\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n\
  \  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\",\n\
  \      \"Detects unsafe overflow checks of roundup_pow_of_two() by comparing result\
  \ to zero\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbpf: Fix stackmap overflow check on 32-bit arches\n\
  \nThe stackmap code relies on roundup_pow_of_two() to compute the number\nof hash\
  \ buckets, and contains an overflow check by checking if the\nresulting value is\
  \ 0. However, on 32-bit arches, the roundup code itself\ncan overflow by doing a\
  \ 32-bit left-shift of an unsigned long value,\nwhich is undefined behaviour, so\
  \ it is not guaranteed to truncate\nneatly. This was triggered by syzbot on the\
  \ DEVMAP_HASH type, which\ncontains the same check, copied from the hashtab code.\n\
  \nThe commit in the fixes tag actually attempted to fix this, but the fix\ndid not\
  \ account for the UB, so the fix only works on CPUs where an\noverflow does result\
  \ in a neat truncation to zero, which is not\nguaranteed. Checking the value before\
  \ rounding does not have this\nproblem.\n\nFixes: 6183f4d3a0a2 (\"bpf: Check for\
  \ integer overflow when using roundup_pow_of_two()\")\nSigned-off-by: Toke H\xF8\
  iland-J\xF8rgensen <toke@redhat.com>\nReviewed-by: Bui Quang Minh <minhquangbui99@gmail.com>\n\
  Message-ID: <20240307120340.99577-4-toke@redhat.com>\nSigned-off-by: Alexei Starovoitov\
  \ <ast@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: stack_map_alloc in kernel/bpf/stackmap.c\n\
  static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n{\n\tu32 value_size\
  \ = attr->value_size;\n\tstruct bpf_stack_map *smap;\n\tu64 cost, n_buckets;\n\t\
  int err;\n\n\tif (attr->map_flags & ~STACK_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size\
  \ != 4 ||\n\t    value_size < 8 || value_size % 8)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\tBUILD_BUG_ON(sizeof(struct bpf_stack_build_id) % sizeof(u64));\n\tif (attr->map_flags\
  \ & BPF_F_STACK_BUILD_ID) {\n\t\tif (value_size % sizeof(struct bpf_stack_build_id)\
  \ ||\n\t\t    value_size / sizeof(struct bpf_stack_build_id)\n\t\t    > sysctl_perf_event_max_stack)\n\
  \t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n\
  \t\treturn ERR_PTR(-EINVAL);\n\n\t/* hash table size must be power of 2 */\n\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n\tif (!n_buckets)\n\t\treturn ERR_PTR(-E2BIG);\n\
  \n\tcost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);\n\tsmap\
  \ = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\tif (!smap)\n\t\t\
  return ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&smap->map, attr);\n\tsmap->n_buckets\
  \ = n_buckets;\n\n\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\t\
  if (err)\n\t\tgoto free_smap;\n\n\terr = prealloc_elems_and_freelist(smap);\n\t\
  if (err)\n\t\tgoto put_buffers;\n\n\treturn &smap->map;\n\nput_buffers:\n\tput_callchain_buffers();\n\
  free_smap:\n\tbpf_map_area_free(smap);\n\treturn ERR_PTR(err);\n}\n```\n\n## Bug\
  \ Fix Patch\n\n```diff\ndiff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c\n\
  index dff7ba539701..c99f8e5234ac 100644\n--- a/kernel/bpf/stackmap.c\n+++ b/kernel/bpf/stackmap.c\n\
  @@ -91,11 +91,14 @@ static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n\
  \ \t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n \t\treturn ERR_PTR(-EINVAL);\n\
  \ \n-\t/* hash table size must be power of 2 */\n-\tn_buckets = roundup_pow_of_two(attr->max_entries);\n\
  -\tif (!n_buckets)\n+\t/* hash table size must be power of 2; roundup_pow_of_two()\
  \ can overflow\n+\t * into UB on 32-bit arches, so check that first\n+\t */\n+\t\
  if (attr->max_entries > 1UL << 31)\n \t\treturn ERR_PTR(-E2BIG);\n \n+\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n+\n \tcost = n_buckets * sizeof(struct\
  \ stack_map_bucket *) + sizeof(*smap);\n \tsmap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\
  \ \tif (!smap)\n```\n"
pattern: '## Bug Pattern


  Relying on roundup_pow_of_two(x) for overflow detection by checking if the result
  is zero, instead of validating x beforehand. On 32-bit architectures, roundup_pow_of_two()
  can perform a left shift by the word size (e.g., 1UL << 32) when x is too large,
  which is undefined behavior. Thus, the overflow check must be done before calling
  roundup_pow_of_two() (e.g., reject x > 1UL << 31) rather than checking the rounded
  result.'
plan: "Plan\n\n1. Program State\n- Register one per-path map to remember variables\
  \ that hold results of roundup_pow_of_two():\n  - REGISTER_MAP_WITH_PROGRAMSTATE(RoundupResultMap,\
  \ const MemRegion*, const Expr*)\n  - Key: the MemRegion of the LHS variable.\n\
  \  - Value: the argument expression (Expr*) passed to roundup_pow_of_two() when\
  \ this variable was assigned. We only need this as a tag and optional context; storing\
  \ the pointer is fine.\n\n2. Callback Selection and Implementation\n\n2.1 checkBind\
  \ (capture assignments/initializations from roundup_pow_of_two)\n- Goal: When a\
  \ variable is bound to the result of roundup_pow_of_two(arg), record that the variable\
  \ holds a rounded value.\n- Steps:\n  - If Loc.getAsRegion() is null, return.\n\
  \  - From the statement S of this bind, search for a CallExpr in its children using\
  \ findSpecificTypeInChildren<CallExpr>(S).\n  - If no call found, or callee name\
  \ is not exactly \"roundup_pow_of_two\", then:\n    - Remove this region from RoundupResultMap\
  \ (the variable is being overwritten with a non-rounded value).\n    - Return.\n\
  \  - If the call is to \"roundup_pow_of_two\":\n    - Get the first argument expression\
  \ ArgE = Call->getArg(0).\n    - Insert/update RoundupResultMap[Region] = ArgE.\n\
  - Notes:\n  - This handles both simple assignments and initializations (initializers\
  \ also go through binding).\n  - If multiple declarators exist in one DeclStmt,\
  \ checkBind will be invoked per binding.\n\n2.2 checkBranchCondition (detect \u201C\
  zero checks\u201D of the rounded result)\n- Goal: Warn when code checks the result\
  \ of roundup_pow_of_two for zero (either directly or via a variable), which is the\
  \ overflow check pattern that is unsafe on 32-bit arches.\n- Steps:\n  - Let Cond\
  \ = Condition expression.\n  - Canonicalize the predicate E being tested for zero:\n\
  \    - If Cond is a UnaryOperator with opcode UO_LNot, then E = Cond->getSubExpr()->IgnoreParenImpCasts()\
  \ and treat it as (E == 0).\n    - Else if Cond is a BinaryOperator with opcode\
  \ BO_EQ:\n      - Identify if one side is integer constant 0 (use EvaluateExprToInt\
  \ to check) and set E to the other side (IgnoreParenImpCasts()).\n    - Otherwise,\
  \ return (we only warn on explicit or negated zero checks).\n  - Now classify E:\n\
  \    1) Direct call case:\n       - If E is (or contains) a CallExpr to roundup_pow_of_two\
  \ (use findSpecificTypeInChildren<CallExpr>(E)):\n         - If callee name == \"\
  roundup_pow_of_two\", this is the target pattern. Report a bug.\n    2) Variable\
  \ case:\n       - If E is a DeclRefExpr/MemberExpr/etc.:\n         - Resolve its\
  \ MemRegion via getMemRegionFromExpr(E, C).\n         - If Region is in RoundupResultMap,\
  \ then this variable is a roundup_pow_of_two result. Report a bug.\n  - Reporting:\n\
  \    - Generate a non-fatal error node and emit a PathSensitiveBugReport with a\
  \ short message like:\n      \"Do not check roundup_pow_of_two(x) result for zero;\
  \ validate x before calling (e.g., x > 1UL << 31).\"\n- Optional gating (if you\
  \ want to reduce noise):\n  - You may limit the report to platforms where unsigned\
  \ long is 32-bit:\n    - unsigned ULBits = C.getASTContext().getTypeSize(C.getASTContext().UnsignedLongTy);\n\
  \    - Only emit if ULBits <= 32.\n  - Otherwise, always emit since the pattern\
  \ is fragile across 32-bit arches.\n\n2.3 Optional: checkPostStmt(const DeclStmt*)\n\
  - This is not strictly necessary since checkBind will handle initializations, but\
  \ if desired for robustness:\n  - For each VarDecl with initializer:\n    - If the\
  \ initializer is a CallExpr to roundup_pow_of_two(), map the Var\u2019s region into\
  \ RoundupResultMap with the call argument.\n  - This duplicates what checkBind already\
  \ does; keep it out to stay simple.\n\n3. Additional Details and Heuristics\n- Callee\
  \ name matching:\n  - Use CallEvent/CallExpr callee identifier and compare string\
  \ with \"roundup_pow_of_two\".\n- Zero check detection:\n  - Prefer explicit patterns:\n\
  \    - if (!expr)            -> treat as expr == 0\n    - if (expr == 0)\n  - Ignore\
  \ other comparisons (expr != 0, expr > 0, etc.) to avoid false positives; the bug\
  \ pattern relies on using zero to detect overflow.\n- Map maintenance:\n  - In checkBind,\
  \ if the LHS region is re-assigned from any non-roundup_pow_of_two source, remove\
  \ it from the map.\n- No alias tracking:\n  - To keep it simple, do not track pointer/value\
  \ aliases. This is acceptable because the kernel idiom is usually a direct assignment\
  \ to a named variable that is then tested. If you want to extend later, you could\
  \ add alias maps, but not required here.\n\n4. Bug Type and Messages\n- Create a\
  \ BugType once (e.g., in the checker constructor) named:\n  - \"Unsafe overflow\
  \ check of roundup_pow_of_two()\"\n- Report message (short and clear):\n  - \"roundup_pow_of_two()\
  \ result checked for zero; check the input before calling (avoid UB on 32-bit).\"\
  \n\nThis minimal plan reliably flags the targeted bug pattern:\n- It recognizes\
  \ both direct-in-condition calls and variable-based checks.\n- It stays simple with\
  \ one program-state map and two callbacks."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Basic/SourceManager.h\"\n\nusing\
  \ namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n// Track LHS\
  \ regions that currently hold the result of roundup_pow_of_two(arg).\n// Map key:\
  \ the base MemRegion of the variable holding the result.\n// Map value: the original\
  \ argument Expr* (as a tag/context; not dereferenced).\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResultMap,\
  \ const MemRegion*, const Expr*)\n\nnamespace {\nclass SAGenTestChecker\n  : public\
  \ Checker<\n        check::Bind,\n        check::BranchCondition> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"Unsafe overflow check of roundup_pow_of_two()\", \"Undefined Behavior\"\
  )) {}\n\n      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const;\n      void checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const;\n\n   private:\n      bool isRoundupPow2Call(const CallExpr *CE, CheckerContext\
  \ &C) const;\n      void reportIssue(const Stmt *Trigger, CheckerContext &C) const;\n\
  };\n} // end anonymous namespace\n\nbool SAGenTestChecker::isRoundupPow2Call(const\
  \ CallExpr *CE, CheckerContext &C) const {\n  if (!CE)\n    return false;\n  const\
  \ Expr *Origin = CE;\n  return ExprHasName(Origin, \"roundup_pow_of_two\", C);\n\
  }\n\nvoid SAGenTestChecker::reportIssue(const Stmt *Trigger, CheckerContext &C)\
  \ const {\n  // Optional gating: only warn when unsigned long is 32-bit or smaller.\n\
  \  unsigned ULBits = C.getASTContext().getTypeSize(C.getASTContext().UnsignedLongTy);\n\
  \  if (ULBits > 32)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"roundup_pow_of_two() result checked for zero; check the input\
  \ before calling (avoid UB on 32-bit).\",\n      N);\n  if (Trigger)\n    R->addRange(Trigger->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc,\
  \ SVal Val, const Stmt *S, CheckerContext &C) const {\n  const MemRegion *LHSReg\
  \ = Loc.getAsRegion();\n  if (!LHSReg)\n    return;\n  LHSReg = LHSReg->getBaseRegion();\n\
  \  if (!LHSReg)\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  //\
  \ Try to find a CallExpr within the statement causing the bind.\n  const CallExpr\
  \ *CE = findSpecificTypeInChildren<CallExpr>(S);\n  if (!CE || !isRoundupPow2Call(CE,\
  \ C)) {\n    // Overwritten with a non-roundup value; clear any previous mark.\n\
  \    State = State->remove<RoundupResultMap>(LHSReg);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // Mark the region as holding a roundup_pow_of_two result.\n\
  \  const Expr *ArgE = (CE->getNumArgs() > 0) ? CE->getArg(0) : nullptr;\n  State\
  \ = State->set<RoundupResultMap>(LHSReg, ArgE);\n  C.addTransition(State);\n}\n\n\
  void SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE)\n    return;\n\n  // Identify zero-check patterns.\n  const Expr\
  \ *RegionExpr = nullptr;     // The expression we will try to resolve to a MemRegion\
  \ (do NOT strip casts before calling getMemRegionFromExpr).\n  const Expr *AnalyzeExpr\
  \ = nullptr;    // A normalized form for analysis (we can strip parens/casts here).\n\
  \n  const Expr *CondNoImp = CondE->IgnoreParenImpCasts();\n  if (const auto *UO\
  \ = dyn_cast<UnaryOperator>(CondNoImp)) {\n    if (UO->getOpcode() == UO_LNot) {\n\
  \      RegionExpr = UO->getSubExpr(); // keep original for region extraction\n \
  \     AnalyzeExpr = UO->getSubExpr()->IgnoreParenImpCasts();\n    }\n  } else if\
  \ (const auto *BO = dyn_cast<BinaryOperator>(CondNoImp)) {\n    if (BO->getOpcode()\
  \ == BO_EQ) {\n      const Expr *LHSOrig = BO->getLHS();\n      const Expr *RHSOrig\
  \ = BO->getRHS();\n      const Expr *LHS = LHSOrig->IgnoreParenImpCasts();\n   \
  \   const Expr *RHS = RHSOrig->IgnoreParenImpCasts();\n\n      llvm::APSInt EvalRes;\n\
  \      bool LHSIsZero = EvaluateExprToInt(EvalRes, LHS, C) && EvalRes.isZero();\n\
  \      bool RHSIsZero = EvaluateExprToInt(EvalRes, RHS, C) && EvalRes.isZero();\n\
  \n      if (LHSIsZero ^ RHSIsZero) {\n        // Choose the non-zero side as the\
  \ expression under check.\n        if (LHSIsZero) {\n          RegionExpr = RHSOrig;\
  \                 // use original for region\n          AnalyzeExpr = RHS;     \
  \               // use normalized for analysis\n        } else {\n          RegionExpr\
  \ = LHSOrig;\n          AnalyzeExpr = LHS;\n        }\n      }\n    }\n  } else\
  \ {\n    // Not a zero-check; ignore.\n    return;\n  }\n\n  if (!RegionExpr ||\
  \ !AnalyzeExpr)\n    return;\n\n  // Case 1: Direct call in the condition.\n  if\
  \ (const CallExpr *InnerCE = findSpecificTypeInChildren<CallExpr>(AnalyzeExpr))\
  \ {\n    if (isRoundupPow2Call(InnerCE, C)) {\n      reportIssue(Condition, C);\n\
  \      return;\n    }\n  }\n\n  // Case 2: Variable holds a roundup_pow_of_two result.\n\
  \  const MemRegion *MR = getMemRegionFromExpr(RegionExpr, C);\n  if (!MR)\n    return;\n\
  \  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\n  if (const Expr *const*\
  \ Tagged = State->get<RoundupResultMap>(MR)) {\n    (void)Tagged; // We don't need\
  \ to use the argument, only the tag presence.\n    reportIssue(Condition, C);\n\
  \  }\n}\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n\
  \  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\",\n\
  \      \"Detects unsafe overflow checks of roundup_pow_of_two() by comparing result\
  \ to zero\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
