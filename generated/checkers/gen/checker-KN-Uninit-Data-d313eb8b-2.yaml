_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: d313eb8b77557a6d5855f42d2234bd592c7b50dd
commit_type: Uninit-Data
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Type.h\"\n#include \"\
  clang/AST/Decl.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/RecordLayout.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(StructZeroedMap,\
  \ const MemRegion*, bool)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<\n\
  \    check::PostStmt<DeclStmt>,\n    check::PostCall,\n    check::PreCall> {\n \
  \  mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Struct copy exposes uninitialized padding\", \"Security\"\
  )) {}\n\n      void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;\n\
  \      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n   \
  \   void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\
  \n      const VarRegion *getBaseVarRegion(const Expr *E, CheckerContext &C) const;\n\
  \      bool isLocalRecordVar(const VarRegion *VR, CheckerContext &C) const;\n  \
  \    bool isZeroIntegralExpr(const Expr *E, CheckerContext &C) const;\n      bool\
  \ isSizeOfVarOrType(const Expr *LenExpr, const VarRegion *VR, CheckerContext &C)\
  \ const;\n      bool recordHasPadding(QualType QT, ASTContext &ACtx) const;\n  \
  \    ProgramStateRef markZeroed(ProgramStateRef State, const VarRegion *VR) const;\n\
  \      bool wasZeroed(ProgramStateRef State, const VarRegion *VR) const;\n     \
  \ uint64_t getTypeSizeInBytes(QualType QT, ASTContext &ACtx) const;\n\n      bool\
  \ isCallNamed(const CallEvent &Call, StringRef Name, CheckerContext &C) const;\n\
  \      bool matchCopyToUserLike(const CallEvent &Call, CheckerContext &C,\n    \
  \                           unsigned &SrcIdx, unsigned &LenIdx) const;\n\n     \
  \ void tryMarkZeroedByMemset(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void tryReportCopyOutStructPadding(const CallEvent &Call, CheckerContext\
  \ &C) const;\n};\n\n/* Helper implementations */\n\nconst VarRegion *SAGenTestChecker::getBaseVarRegion(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E) return nullptr;\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C);\n  if (!MR) return nullptr;\n  MR = MR->getBaseRegion();\n\
  \  return dyn_cast<VarRegion>(MR);\n}\n\nbool SAGenTestChecker::isLocalRecordVar(const\
  \ VarRegion *VR, CheckerContext &C) const {\n  if (!VR)\n    return false;\n  if\
  \ (!VR->getValueType().isNull() && !VR->getValueType()->isRecordType())\n    return\
  \ false;\n  const MemSpaceRegion *MS = VR->getMemorySpace();\n  if (!MS)\n    return\
  \ false;\n  return isa<StackLocalsSpaceRegion>(MS);\n}\n\nbool SAGenTestChecker::isZeroIntegralExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E) return false;\n  llvm::APSInt Res;\n\
  \  if (!EvaluateExprToInt(Res, E, C))\n    return false;\n  return Res == 0;\n}\n\
  \nuint64_t SAGenTestChecker::getTypeSizeInBytes(QualType QT, ASTContext &ACtx) const\
  \ {\n  if (QT.isNull()) return 0;\n  return ACtx.getTypeSizeInChars(QT).getQuantity();\n\
  }\n\nbool SAGenTestChecker::isSizeOfVarOrType(const Expr *LenExpr, const VarRegion\
  \ *VR, CheckerContext &C) const {\n  if (!LenExpr || !VR) return false;\n  const\
  \ Expr *E = LenExpr->IgnoreParenCasts();\n  if (const auto *UETT = dyn_cast<UnaryExprOrTypeTraitExpr>(E))\
  \ {\n    if (UETT->getKind() != UETT_SizeOf)\n      return false;\n    if (UETT->isArgumentType())\
  \ {\n      QualType ArgTy = UETT->getArgumentType().getCanonicalType();\n      QualType\
  \ VarTy = VR->getValueType().getCanonicalType();\n      if (ArgTy.isNull() || VarTy.isNull())\n\
  \        return false;\n      return ArgTy == VarTy;\n    } else {\n      const\
  \ Expr *AE = UETT->getArgumentExpr();\n      if (!AE) return false;\n      AE =\
  \ AE->IgnoreParenImpCasts();\n      if (const auto *DRE = dyn_cast<DeclRefExpr>(AE))\
  \ {\n        const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n        if (VD\
  \ && VD == VR->getDecl())\n          return true;\n      }\n    }\n  }\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::recordHasPadding(QualType QT, ASTContext &ACtx)\
  \ const {\n  if (QT.isNull())\n    return false;\n  const RecordType *RT = QT->getAs<RecordType>();\n\
  \  if (!RT)\n    return false;\n\n  const RecordDecl *RD = RT->getDecl();\n  if\
  \ (!RD)\n    return false;\n  RD = RD->getDefinition();\n  if (!RD)\n    return\
  \ false; // Be conservative: if no definition, don't report.\n\n  const ASTRecordLayout\
  \ &Layout = ACtx.getASTRecordLayout(RD);\n  uint64_t prevEnd = 0;\n  unsigned idx\
  \ = 0;\n\n  for (const FieldDecl *FD : RD->fields()) {\n    uint64_t off = Layout.getFieldOffset(idx);\
  \ // in bits\n    if (off > prevEnd)\n      return true; // gap before this field\n\
  \    uint64_t fsize = 0;\n    if (FD->isBitField()) {\n      fsize = FD->getBitWidthValue(ACtx);\n\
  \    } else {\n      fsize = ACtx.getTypeSize(FD->getType());\n    }\n    prevEnd\
  \ = off + fsize;\n    ++idx;\n  }\n\n  uint64_t totalBits = ACtx.toBits(Layout.getSize());\n\
  \  if (totalBits > prevEnd)\n    return true; // tail padding\n\n  return false;\n\
  }\n\nProgramStateRef SAGenTestChecker::markZeroed(ProgramStateRef State, const VarRegion\
  \ *VR) const {\n  if (!State || !VR) return State;\n  return State->set<StructZeroedMap>(VR,\
  \ true);\n}\n\nbool SAGenTestChecker::wasZeroed(ProgramStateRef State, const VarRegion\
  \ *VR) const {\n  if (!State || !VR) return false;\n  if (const bool *B = State->get<StructZeroedMap>(VR))\n\
  \    return *B;\n  return false;\n}\n\nbool SAGenTestChecker::isCallNamed(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) const {\n  const Expr *OE\
  \ = Call.getOriginExpr();\n  if (!OE) return false;\n  return ExprHasName(OE, Name,\
  \ C);\n}\n\nbool SAGenTestChecker::matchCopyToUserLike(const CallEvent &Call, CheckerContext\
  \ &C,\n                                           unsigned &SrcIdx, unsigned &LenIdx)\
  \ const {\n  // Check more specific names first to avoid substring confusion.\n\
  \  if (isCallNamed(Call, \"nla_put_64bit\", C)) {\n    SrcIdx = 3; LenIdx = 2; return\
  \ true;\n  }\n  if (isCallNamed(Call, \"nla_put_nohdr\", C)) {\n    SrcIdx = 2;\
  \ LenIdx = 1; return true;\n  }\n  if (isCallNamed(Call, \"nla_put\", C)) {\n  \
  \  SrcIdx = 3; LenIdx = 2; return true;\n  }\n  if (isCallNamed(Call, \"copy_to_user\"\
  , C)) {\n    SrcIdx = 1; LenIdx = 2; return true;\n  }\n  // Add more if needed.\n\
  \  return false;\n}\n\nvoid SAGenTestChecker::tryMarkZeroedByMemset(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n \
  \ const Expr *OE = Call.getOriginExpr();\n  if (!OE)\n    return;\n\n  bool IsMemset\
  \ = isCallNamed(Call, \"memset\", C) || isCallNamed(Call, \"__builtin_memset\",\
  \ C);\n  bool IsBzero  = isCallNamed(Call, \"bzero\", C);\n  if (!IsMemset && !IsBzero)\n\
  \    return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n  const MemRegion *DstMR\
  \ = Call.getArgSVal(0).getAsRegion();\n  if (!DstMR)\n    return;\n  DstMR = DstMR->getBaseRegion();\n\
  \  const VarRegion *VR = dyn_cast<VarRegion>(DstMR);\n  if (!VR)\n    return;\n\
  \  if (!isLocalRecordVar(VR, C))\n    return;\n\n  // memset(ptr, 0, len) OR bzero(ptr,\
  \ len)\n  bool ZeroVal = true;\n  const Expr *LenExpr = nullptr;\n\n  if (IsMemset)\
  \ {\n    if (Call.getNumArgs() < 3)\n      return;\n    const Expr *ValExpr = Call.getArgExpr(1);\n\
  \    if (!isZeroIntegralExpr(ValExpr, C))\n      ZeroVal = false;\n    LenExpr =\
  \ Call.getArgExpr(2);\n  } else {\n    // bzero(ptr, len)\n    LenExpr = Call.getArgExpr(1);\n\
  \  }\n\n  if (!ZeroVal || !LenExpr)\n    return;\n\n  bool FullSize = false;\n \
  \ if (isSizeOfVarOrType(LenExpr, VR, C)) {\n    FullSize = true;\n  } else {\n \
  \   llvm::APSInt Res;\n    if (EvaluateExprToInt(Res, LenExpr, C)) {\n      uint64_t\
  \ Len = Res.getZExtValue();\n      uint64_t TySize = getTypeSizeInBytes(VR->getValueType(),\
  \ C.getASTContext());\n      if (TySize == Len)\n        FullSize = true;\n    }\n\
  \  }\n\n  if (!FullSize)\n    return;\n\n  State = markZeroed(State, VR);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::tryReportCopyOutStructPadding(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  unsigned SrcIdx = 0, LenIdx = 0;\n  if (!matchCopyToUserLike(Call,\
  \ C, SrcIdx, LenIdx))\n    return;\n\n  if (Call.getNumArgs() <= std::max(SrcIdx,\
  \ LenIdx))\n    return;\n\n  // Source pointer region\n  const MemRegion *SrcMR\
  \ = Call.getArgSVal(SrcIdx).getAsRegion();\n  if (!SrcMR)\n    return;\n  SrcMR\
  \ = SrcMR->getBaseRegion();\n  const VarRegion *VR = dyn_cast<VarRegion>(SrcMR);\n\
  \  if (!VR)\n    return;\n  if (!isLocalRecordVar(VR, C))\n    return;\n\n  // Check\
  \ if length == sizeof(var or type)\n  const Expr *LenExpr = Call.getArgExpr(LenIdx);\n\
  \  bool FullCopy = false;\n  if (isSizeOfVarOrType(LenExpr, VR, C)) {\n    FullCopy\
  \ = true;\n  } else {\n    llvm::APSInt Res;\n    if (EvaluateExprToInt(Res, LenExpr,\
  \ C)) {\n      uint64_t Len = Res.getZExtValue();\n      uint64_t TySize = getTypeSizeInBytes(VR->getValueType(),\
  \ C.getASTContext());\n      if (TySize == Len)\n        FullCopy = true;\n    }\n\
  \  }\n  if (!FullCopy)\n    return;\n\n  // Check struct has padding\n  if (!recordHasPadding(VR->getValueType(),\
  \ C.getASTContext()))\n    return;\n\n  // If not zeroed, report\n  ProgramStateRef\
  \ State = C.getState();\n  if (!wasZeroed(State, VR)) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Struct with padding copied without full initialization\", N);\n\
  \    R->addRange(Call.getSourceRange());\n    if (const Expr *SrcE = Call.getArgExpr(SrcIdx))\n\
  \      R->addRange(SrcE->getSourceRange());\n    if (LenExpr)\n      R->addRange(LenExpr->getSourceRange());\n\
  \    C.emitReport(std::move(R));\n  }\n}\n\n/* Checker callbacks */\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  SValBuilder &SVB = C.getSValBuilder();\n  MemRegionManager &MRMgr = SVB.getRegionManager();\n\
  \n  for (const Decl *D : DS->decls()) {\n    const auto *VD = dyn_cast<VarDecl>(D);\n\
  \    if (!VD)\n      continue;\n    if (!VD->hasLocalStorage())\n      continue;\n\
  \n    QualType QT = VD->getType();\n    if (QT.isNull() || !QT->isRecordType())\n\
  \      continue;\n\n    if (!VD->hasInit())\n      continue;\n\n    const Expr *Init\
  \ = VD->getInit();\n    if (!Init)\n      continue;\n\n    const InitListExpr *ILE\
  \ = dyn_cast<InitListExpr>(Init->IgnoreParenCasts());\n    if (!ILE)\n      continue;\n\
  \n    // Only accept \"{0}\" pattern as \"fully zeroed\".\n    bool ZeroInit = false;\n\
  \    if (ILE->getNumInits() == 1) {\n      const Expr *E0 = ILE->getInit(0);\n \
  \     if (isZeroIntegralExpr(E0, C))\n        ZeroInit = true;\n    }\n\n    if\
  \ (!ZeroInit)\n      continue;\n\n    const VarRegion *VR = MRMgr.getVarRegion(VD,\
  \ C.getLocationContext());\n    if (!VR)\n      continue;\n    if (!isLocalRecordVar(VR,\
  \ C))\n      continue;\n\n    State = markZeroed(State, VR);\n  }\n\n  if (State\
  \ != C.getState())\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // Detect memset/bzero that fully\
  \ zero a local struct\n  tryMarkZeroedByMemset(Call, C);\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // Detect copying a whole local\
  \ struct (with padding) to user space or netlink.\n  tryReportCopyOutStructPadding(Call,\
  \ C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects copying a stack struct with padding to user without zeroing the\
  \ struct\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/sched: act_skbmod: prevent kernel-infoleak\n\n\
  syzbot found that tcf_skbmod_dump() was copying four bytes\nfrom kernel stack to\
  \ user space [1].\n\nThe issue here is that 'struct tc_skbmod' has a four bytes\
  \ hole.\n\nWe need to clear the structure before filling fields.\n\n[1]\nBUG: KMSAN:\
  \ kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in copy_to_user_iter lib/iov_iter.c:24 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_and_advance2 include/linux/iov_iter.h:245\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in iterate_and_advance include/linux/iov_iter.h:271\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n  copy_to_user_iter\
  \ lib/iov_iter.c:24 [inline]\n  iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \  iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\n  iterate_and_advance\
  \ include/linux/iov_iter.h:271 [inline]\n  _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  copy_to_iter include/linux/uio.h:196 [inline]\n  simple_copy_to_iter net/core/datagram.c:532\
  \ [inline]\n  __skb_datagram_iter+0x185/0x1000 net/core/datagram.c:420\n  skb_copy_datagram_iter+0x5c/0x200\
  \ net/core/datagram.c:546\n  skb_copy_datagram_msg include/linux/skbuff.h:4050 [inline]\n\
  \  netlink_recvmsg+0x432/0x1610 net/netlink/af_netlink.c:1962\n  sock_recvmsg_nosec\
  \ net/socket.c:1046 [inline]\n  sock_recvmsg+0x2c4/0x340 net/socket.c:1068\n  __sys_recvfrom+0x35a/0x5f0\
  \ net/socket.c:2242\n  __do_sys_recvfrom net/socket.c:2260 [inline]\n  __se_sys_recvfrom\
  \ net/socket.c:2256 [inline]\n  __x64_sys_recvfrom+0x126/0x1d0 net/socket.c:2256\n\
  \ do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nUninit\
  \ was stored to memory at:\n  pskb_expand_head+0x30f/0x19d0 net/core/skbuff.c:2253\n\
  \  netlink_trim+0x2c2/0x330 net/netlink/af_netlink.c:1317\n  netlink_unicast+0x9f/0x1260\
  \ net/netlink/af_netlink.c:1351\n  nlmsg_unicast include/net/netlink.h:1144 [inline]\n\
  \  nlmsg_notify+0x21d/0x2f0 net/netlink/af_netlink.c:2610\n  rtnetlink_send+0x73/0x90\
  \ net/core/rtnetlink.c:741\n  rtnetlink_maybe_send include/linux/rtnetlink.h:17\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2048 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x146e/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nUninit was stored to memory at:\n  __nla_put lib/nlattr.c:1041 [inline]\n  nla_put+0x1c6/0x230\
  \ lib/nlattr.c:1099\n  tcf_skbmod_dump+0x23f/0xc20 net/sched/act_skbmod.c:256\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n  tcf_action_dump+0x1fd/0x460 net/sched/act_api.c:1251\n\
  \  tca_get_fill+0x519/0x7a0 net/sched/act_api.c:1628\n  tcf_add_notify_msg net/sched/act_api.c:2023\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2042 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x1365/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nLocal variable opt created at:\n  tcf_skbmod_dump+0x9d/0xc20 net/sched/act_skbmod.c:244\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n\nBytes 188-191 of 248 are uninitialized\nMemory access\
  \ of size 248 starts at ffff888117697680\nData copied to user address 00007ffe56d855f0\n\
  \nFixes: 86da71b57383 (\"net_sched: Introduce skbmod action\")\nSigned-off-by: Eric\
  \ Dumazet <edumazet@google.com>\nAcked-by: Jamal Hadi Salim <jhs@mojatatu.com>\n\
  Link: https://lore.kernel.org/r/20240403130908.93421-1-edumazet@google.com\nSigned-off-by:\
  \ Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: tcf_skbmod_dump\
  \ in net/sched/act_skbmod.c\nstatic int tcf_skbmod_dump(struct sk_buff *skb, struct\
  \ tc_action *a,\n\t\t\t   int bind, int ref)\n{\n\tstruct tcf_skbmod *d = to_skbmod(a);\n\
  \tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_skbmod_params  *p;\n\t\
  struct tc_skbmod opt = {\n\t\t.index   = d->tcf_index,\n\t\t.refcnt  = refcount_read(&d->tcf_refcnt)\
  \ - ref,\n\t\t.bindcnt = atomic_read(&d->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t\
  \ t;\n\n\tspin_lock_bh(&d->tcf_lock);\n\topt.action = d->tcf_action;\n\tp = rcu_dereference_protected(d->skbmod_p,\n\
  \t\t\t\t      lockdep_is_held(&d->tcf_lock));\n\topt.flags  = p->flags;\n\tif (nla_put(skb,\
  \ TCA_SKBMOD_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_DMAC) &&\n\t    nla_put(skb, TCA_SKBMOD_DMAC, ETH_ALEN, p->eth_dst))\n\
  \t\tgoto nla_put_failure;\n\tif ((p->flags & SKBMOD_F_SMAC) &&\n\t    nla_put(skb,\
  \ TCA_SKBMOD_SMAC, ETH_ALEN, p->eth_src))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_ETYPE) &&\n\t    nla_put_u16(skb, TCA_SKBMOD_ETYPE, ntohs(p->eth_type)))\n\
  \t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &d->tcf_tm);\n\tif (nla_put_64bit(skb,\
  \ TCA_SKBMOD_TM, sizeof(t), &t, TCA_SKBMOD_PAD))\n\t\tgoto nla_put_failure;\n\n\t\
  spin_unlock_bh(&d->tcf_lock);\n\treturn skb->len;\nnla_put_failure:\n\tspin_unlock_bh(&d->tcf_lock);\n\
  \tnlmsg_trim(skb, b);\n\treturn -1;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff\
  \ --git a/net/sched/act_skbmod.c b/net/sched/act_skbmod.c\nindex 39945b139c48..cd0accaf844a\
  \ 100644\n--- a/net/sched/act_skbmod.c\n+++ b/net/sched/act_skbmod.c\n@@ -241,13\
  \ +241,13 @@ static int tcf_skbmod_dump(struct sk_buff *skb, struct tc_action *a,\n\
  \ \tstruct tcf_skbmod *d = to_skbmod(a);\n \tunsigned char *b = skb_tail_pointer(skb);\n\
  \ \tstruct tcf_skbmod_params  *p;\n-\tstruct tc_skbmod opt = {\n-\t\t.index   =\
  \ d->tcf_index,\n-\t\t.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n-\t\t.bindcnt\
  \ = atomic_read(&d->tcf_bindcnt) - bind,\n-\t};\n+\tstruct tc_skbmod opt;\n \tstruct\
  \ tcf_t t;\n \n+\tmemset(&opt, 0, sizeof(opt));\n+\topt.index   = d->tcf_index;\n\
  +\topt.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n+\topt.bindcnt = atomic_read(&d->tcf_bindcnt)\
  \ - bind;\n \tspin_lock_bh(&d->tcf_lock);\n \topt.action = d->tcf_action;\n \tp\
  \ = rcu_dereference_protected(d->skbmod_p,\n```\n"
pattern: '## Bug Pattern


  Copying a stack-allocated struct to user space with sizeof(struct) after only partially
  initializing its fields, leaving alignment padding/holes uninitialized. Specifically:

  - A struct with padding (e.g., tc_skbmod) is created on the stack.

  - Only selected fields are set via designated initializers or assignments.

  - The entire struct (including padding) is exported with nla_put/copy_to_user, leaking
  uninitialized stack bytes.


  Fix: fully initialize the struct (e.g., memset(&s, 0, sizeof(s)) or struct S s =
  {0};) before copying it to user space.'
plan: "Plan\n\n1. Program state\n- REGISTER_MAP_WITH_PROGRAMSTATE(StructZeroedMap,\
  \ const MemRegion*, bool)\n  - Key: base MemRegion of a stack-allocated struct object.\n\
  \  - Value: true means \u201Call bytes of the struct were explicitly zeroed since\
  \ declaration\u201D (safe to copy in full); absent or false means \u201Cnot proven\
  \ fully zeroed\u201D (potentially leaking padding).\n\n2. Helper predicates/utilities\
  \ to implement\n- getBaseVarRegion(const Expr *E, CheckerContext &C) -> const VarRegion*\n\
  \  - Use getMemRegionFromExpr(E, C).\n  - Call region->getBaseRegion(); then dyn_cast<VarRegion>.\n\
  - isLocalRecordVar(const VarRegion *VR) -> bool\n  - Check VR is in StackLocalsSpaceRegion\
  \ and its VarDecl has a RecordType.\n- isZeroIntegralExpr(const Expr *E, CheckerContext\
  \ &C) -> bool\n  - Use EvaluateExprToInt; return true when value == 0 and evaluation\
  \ succeeds.\n- isSizeOfVarOrType(const Expr *LenExpr, const VarRegion *VR, CheckerContext\
  \ &C) -> bool\n  - If LenExpr is a UnaryExprOrTypeTraitExpr of kind SizeOf:\n  \
  \  - If it has an argument-expression, check that it is a DeclRefExpr to the same\
  \ VarDecl as VR.\n    - If it is a type operand, check that the type is the same\
  \ as VR->getValueType().\n- recordHasPadding(QualType QT, ASTContext &ACtx) -> bool\n\
  \  - Use ACtx.getASTRecordLayout(QT->getAs<RecordType>()->getDecl()).\n  - Iterate\
  \ fields: if there is any non-zero byte gap between (prev field end) and (next field\
  \ start), or if total size in bytes > sum of field sizes plus tail padding is non-zero,\
  \ return true.\n- markZeroed(State, const VarRegion *VR) -> ProgramStateRef\n  -\
  \ Insert (VR, true) into StructZeroedMap.\n- wasZeroed(State, const VarRegion *VR)\
  \ -> Optional<bool>\n  - Lookup VR in StructZeroedMap; treat missing as false.\n\
  \n3. Recognize \u201Czeroing\u201D patterns that make a struct safe\nA. Zeroing\
  \ at declaration (checkPostStmt on DeclStmt)\n- For each VarDecl in DeclStmt:\n\
  \  - If it has local storage and record type, and has an initializer:\n    - If\
  \ initializer is an InitListExpr whose elements are all integer/char literals equal\
  \ to 0 (e.g., \u201C= {0}\u201D):\n      - Get VarRegion for the VarDecl and markZeroed.\n\
  \    - Otherwise, do nothing (designated initializers with runtime values are NOT\
  \ safe).\n  - Note: Do not set any entry when there is no initializer.\n\nB. memset\
  \ zero over full sizeof(struct) (checkPostCall on CallEvent)\n- Detect libc/kernel\
  \ memset-like calls: function name \u201Cmemset\u201D (and optionally \u201C__builtin_memset\u201D\
  ).\n- Extract:\n  - dest = arg0; val = arg1; len = arg2.\n- If isZeroIntegralExpr(val)\
  \ and getBaseVarRegion(dest) is a local record VarRegion VR:\n  - If isSizeOfVarOrType(len,\
  \ VR, C):\n    - markZeroed(VR).\n  - Else, if we can evaluate len to an APSInt\
  \ and it equals the full size of VR\u2019s type (query via ASTContext.getTypeSizeInChars),\
  \ also markZeroed.\n\n4. Detect unsafe copy to user space of the entire struct (checkPreCall\
  \ on CallEvent)\n- Maintain a small table of \u201Ccopy-to-user-like\u201D functions\
  \ and their src/len parameter indices:\n  - nla_put: src index = 3, len index =\
  \ 2\n  - nla_put_64bit: src = 3, len = 2\n  - nla_put_nohdr: src = 2, len = 1\n\
  \  - copy_to_user: src = 1, len = 2\n  - copy_to_user_iter: src = 1, len = 2 (approximate;\
  \ skip if signature mismatch)\n- For the matched call:\n  - Let SrcExpr and LenExpr\
  \ be the arguments according to the signature.\n  - Obtain VarRegion VR = getBaseVarRegion(SrcExpr,\
  \ C); require isLocalRecordVar(VR).\n  - Check the copy size represents \u201Centire\
  \ struct\u201D:\n    - If isSizeOfVarOrType(LenExpr, VR, C) is true, proceed; else,\
  \ try to evaluate LenExpr to integer and compare to sizeof(VR->getValueType()) using\
  \ ASTContext.getTypeSizeInChars; if equal, proceed; otherwise, bail (no warning).\n\
  \  - Check if the struct type likely contains padding:\n    - If recordHasPadding(VR->getValueType(),\
  \ C.getASTContext()) is false, bail (suppress to avoid noise).\n  - Check zeroed\
  \ state:\n    - If wasZeroed(State, VR) is not true, report a bug.\n\n5. Reporting\n\
  - On detection in checkPreCall (above):\n  - Create a non-fatal error node with\
  \ C.generateNonFatalErrorNode().\n  - Message: \u201CStruct with padding copied\
  \ to user without full initialization\u201D\n  - Use std::make_unique<PathSensitiveBugReport>(...)\
  \ and C.emitReport(...).\n  - Optionally add notes:\n    - Point range at the src\
  \ expression (&var) and len expression (sizeof(var/type)).\n\n6. Optional refinements\
  \ to reduce false positives\n- Ignore copies when source is not an address-of a\
  \ variable (e.g., raw pointer arithmetic or field address); only proceed when getBaseVarRegion\
  \ succeeds.\n- Reset map entries when region goes out of scope (not strictly necessary:\
  \ analysis is intra-procedural and the region will not be reused outside the function).\n\
  - Accept other zeroing patterns:\n  - bzero(&var, sizeof(var)): treat like memset\
  \ with value 0.\n- Be conservative with initializer detection:\n  - Only treat \u201C\
  = {0}\u201D (all-zero constant) as safe.\n  - Do not treat \u201C= { .f = expr,\
  \ ... }\u201D as safe even if some constants are zero (padding may remain).\n\n\
  7. Callbacks summary and concrete actions\n- checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C)\n  - For each local VarDecl of RecordType with an Init:\n    - If init is\
  \ \u201Call zeros\u201D InitListExpr: get VarRegion, markZeroed.\n- checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C)\n  - If callee is memset/bzero:\n    - If\
  \ value is 0 and dest is &local struct and len equals sizeof(that struct): markZeroed.\n\
  - checkPreCall(const CallEvent &Call, CheckerContext &C)\n  - If callee is one of\
  \ {nla_put, nla_put_64bit, nla_put_nohdr, copy_to_user, copy_to_user_iter}:\n  \
  \  - Extract src and len arg indices, resolve VarRegion for src; ensure local record\
  \ var.\n    - Ensure len represents copying exactly sizeof(struct).\n    - Ensure\
  \ the struct type has padding (recordHasPadding).\n    - If not marked zeroed: emit\
  \ report.\n\n8. Use of provided Utility Functions\n- getMemRegionFromExpr for region\
  \ extraction (then take base VarRegion).\n- EvaluateExprToInt for value == 0 and\
  \ for evaluating len when not sizeof-expression.\n- ExprHasName can be used as a\
  \ fallback (e.g., detecting text \u201Csizeof(\u201D in len) if AST forms are unusual,\
  \ but prefer AST checks.\n- findSpecificTypeInChildren can help find UnaryExprOrTypeTraitExpr\
  \ under the length argument when needed."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Type.h\"\n#include \"\
  clang/AST/Decl.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/RecordLayout.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(StructZeroedMap,\
  \ const MemRegion*, bool)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<\n\
  \    check::PostStmt<DeclStmt>,\n    check::PostCall,\n    check::PreCall> {\n \
  \  mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Struct copy exposes uninitialized padding\", \"Security\"\
  )) {}\n\n      void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;\n\
  \      void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n   \
  \   void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\
  \n      const VarRegion *getBaseVarRegion(const Expr *E, CheckerContext &C) const;\n\
  \      bool isLocalRecordVar(const VarRegion *VR, CheckerContext &C) const;\n  \
  \    bool isZeroIntegralExpr(const Expr *E, CheckerContext &C) const;\n      bool\
  \ isSizeOfVarOrType(const Expr *LenExpr, const VarRegion *VR, CheckerContext &C)\
  \ const;\n      bool recordHasPadding(QualType QT, ASTContext &ACtx) const;\n  \
  \    ProgramStateRef markZeroed(ProgramStateRef State, const VarRegion *VR) const;\n\
  \      bool wasZeroed(ProgramStateRef State, const VarRegion *VR) const;\n     \
  \ uint64_t getTypeSizeInBytes(QualType QT, ASTContext &ACtx) const;\n\n      bool\
  \ isCallNamed(const CallEvent &Call, StringRef Name, CheckerContext &C) const;\n\
  \      bool matchCopyToUserLike(const CallEvent &Call, CheckerContext &C,\n    \
  \                           unsigned &SrcIdx, unsigned &LenIdx) const;\n\n     \
  \ void tryMarkZeroedByMemset(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void tryReportCopyOutStructPadding(const CallEvent &Call, CheckerContext\
  \ &C) const;\n};\n\n/* Helper implementations */\n\nconst VarRegion *SAGenTestChecker::getBaseVarRegion(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E) return nullptr;\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C);\n  if (!MR) return nullptr;\n  MR = MR->getBaseRegion();\n\
  \  return dyn_cast<VarRegion>(MR);\n}\n\nbool SAGenTestChecker::isLocalRecordVar(const\
  \ VarRegion *VR, CheckerContext &C) const {\n  if (!VR)\n    return false;\n  if\
  \ (!VR->getValueType().isNull() && !VR->getValueType()->isRecordType())\n    return\
  \ false;\n  const MemSpaceRegion *MS = VR->getMemorySpace();\n  if (!MS)\n    return\
  \ false;\n  return isa<StackLocalsSpaceRegion>(MS);\n}\n\nbool SAGenTestChecker::isZeroIntegralExpr(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E) return false;\n  llvm::APSInt Res;\n\
  \  if (!EvaluateExprToInt(Res, E, C))\n    return false;\n  return Res == 0;\n}\n\
  \nuint64_t SAGenTestChecker::getTypeSizeInBytes(QualType QT, ASTContext &ACtx) const\
  \ {\n  if (QT.isNull()) return 0;\n  return ACtx.getTypeSizeInChars(QT).getQuantity();\n\
  }\n\nbool SAGenTestChecker::isSizeOfVarOrType(const Expr *LenExpr, const VarRegion\
  \ *VR, CheckerContext &C) const {\n  if (!LenExpr || !VR) return false;\n  const\
  \ Expr *E = LenExpr->IgnoreParenCasts();\n  if (const auto *UETT = dyn_cast<UnaryExprOrTypeTraitExpr>(E))\
  \ {\n    if (UETT->getKind() != UETT_SizeOf)\n      return false;\n    if (UETT->isArgumentType())\
  \ {\n      QualType ArgTy = UETT->getArgumentType().getCanonicalType();\n      QualType\
  \ VarTy = VR->getValueType().getCanonicalType();\n      if (ArgTy.isNull() || VarTy.isNull())\n\
  \        return false;\n      return ArgTy == VarTy;\n    } else {\n      const\
  \ Expr *AE = UETT->getArgumentExpr();\n      if (!AE) return false;\n      AE =\
  \ AE->IgnoreParenImpCasts();\n      if (const auto *DRE = dyn_cast<DeclRefExpr>(AE))\
  \ {\n        const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n        if (VD\
  \ && VD == VR->getDecl())\n          return true;\n      }\n    }\n  }\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::recordHasPadding(QualType QT, ASTContext &ACtx)\
  \ const {\n  if (QT.isNull())\n    return false;\n  const RecordType *RT = QT->getAs<RecordType>();\n\
  \  if (!RT)\n    return false;\n\n  const RecordDecl *RD = RT->getDecl();\n  if\
  \ (!RD)\n    return false;\n  RD = RD->getDefinition();\n  if (!RD)\n    return\
  \ false; // Be conservative: if no definition, don't report.\n\n  const ASTRecordLayout\
  \ &Layout = ACtx.getASTRecordLayout(RD);\n  uint64_t prevEnd = 0;\n  unsigned idx\
  \ = 0;\n\n  for (const FieldDecl *FD : RD->fields()) {\n    uint64_t off = Layout.getFieldOffset(idx);\
  \ // in bits\n    if (off > prevEnd)\n      return true; // gap before this field\n\
  \    uint64_t fsize = 0;\n    if (FD->isBitField()) {\n      fsize = FD->getBitWidthValue(ACtx);\n\
  \    } else {\n      fsize = ACtx.getTypeSize(FD->getType());\n    }\n    prevEnd\
  \ = off + fsize;\n    ++idx;\n  }\n\n  uint64_t totalBits = ACtx.toBits(Layout.getSize());\n\
  \  if (totalBits > prevEnd)\n    return true; // tail padding\n\n  return false;\n\
  }\n\nProgramStateRef SAGenTestChecker::markZeroed(ProgramStateRef State, const VarRegion\
  \ *VR) const {\n  if (!State || !VR) return State;\n  return State->set<StructZeroedMap>(VR,\
  \ true);\n}\n\nbool SAGenTestChecker::wasZeroed(ProgramStateRef State, const VarRegion\
  \ *VR) const {\n  if (!State || !VR) return false;\n  if (const bool *B = State->get<StructZeroedMap>(VR))\n\
  \    return *B;\n  return false;\n}\n\nbool SAGenTestChecker::isCallNamed(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) const {\n  const Expr *OE\
  \ = Call.getOriginExpr();\n  if (!OE) return false;\n  return ExprHasName(OE, Name,\
  \ C);\n}\n\nbool SAGenTestChecker::matchCopyToUserLike(const CallEvent &Call, CheckerContext\
  \ &C,\n                                           unsigned &SrcIdx, unsigned &LenIdx)\
  \ const {\n  // Check more specific names first to avoid substring confusion.\n\
  \  if (isCallNamed(Call, \"nla_put_64bit\", C)) {\n    SrcIdx = 3; LenIdx = 2; return\
  \ true;\n  }\n  if (isCallNamed(Call, \"nla_put_nohdr\", C)) {\n    SrcIdx = 2;\
  \ LenIdx = 1; return true;\n  }\n  if (isCallNamed(Call, \"nla_put\", C)) {\n  \
  \  SrcIdx = 3; LenIdx = 2; return true;\n  }\n  if (isCallNamed(Call, \"copy_to_user\"\
  , C)) {\n    SrcIdx = 1; LenIdx = 2; return true;\n  }\n  // Add more if needed.\n\
  \  return false;\n}\n\nvoid SAGenTestChecker::tryMarkZeroedByMemset(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n \
  \ const Expr *OE = Call.getOriginExpr();\n  if (!OE)\n    return;\n\n  bool IsMemset\
  \ = isCallNamed(Call, \"memset\", C) || isCallNamed(Call, \"__builtin_memset\",\
  \ C);\n  bool IsBzero  = isCallNamed(Call, \"bzero\", C);\n  if (!IsMemset && !IsBzero)\n\
  \    return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n  const MemRegion *DstMR\
  \ = Call.getArgSVal(0).getAsRegion();\n  if (!DstMR)\n    return;\n  DstMR = DstMR->getBaseRegion();\n\
  \  const VarRegion *VR = dyn_cast<VarRegion>(DstMR);\n  if (!VR)\n    return;\n\
  \  if (!isLocalRecordVar(VR, C))\n    return;\n\n  // memset(ptr, 0, len) OR bzero(ptr,\
  \ len)\n  bool ZeroVal = true;\n  const Expr *LenExpr = nullptr;\n\n  if (IsMemset)\
  \ {\n    if (Call.getNumArgs() < 3)\n      return;\n    const Expr *ValExpr = Call.getArgExpr(1);\n\
  \    if (!isZeroIntegralExpr(ValExpr, C))\n      ZeroVal = false;\n    LenExpr =\
  \ Call.getArgExpr(2);\n  } else {\n    // bzero(ptr, len)\n    LenExpr = Call.getArgExpr(1);\n\
  \  }\n\n  if (!ZeroVal || !LenExpr)\n    return;\n\n  bool FullSize = false;\n \
  \ if (isSizeOfVarOrType(LenExpr, VR, C)) {\n    FullSize = true;\n  } else {\n \
  \   llvm::APSInt Res;\n    if (EvaluateExprToInt(Res, LenExpr, C)) {\n      uint64_t\
  \ Len = Res.getZExtValue();\n      uint64_t TySize = getTypeSizeInBytes(VR->getValueType(),\
  \ C.getASTContext());\n      if (TySize == Len)\n        FullSize = true;\n    }\n\
  \  }\n\n  if (!FullSize)\n    return;\n\n  State = markZeroed(State, VR);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::tryReportCopyOutStructPadding(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  unsigned SrcIdx = 0, LenIdx = 0;\n  if (!matchCopyToUserLike(Call,\
  \ C, SrcIdx, LenIdx))\n    return;\n\n  if (Call.getNumArgs() <= std::max(SrcIdx,\
  \ LenIdx))\n    return;\n\n  // Source pointer region\n  const MemRegion *SrcMR\
  \ = Call.getArgSVal(SrcIdx).getAsRegion();\n  if (!SrcMR)\n    return;\n  SrcMR\
  \ = SrcMR->getBaseRegion();\n  const VarRegion *VR = dyn_cast<VarRegion>(SrcMR);\n\
  \  if (!VR)\n    return;\n  if (!isLocalRecordVar(VR, C))\n    return;\n\n  // Check\
  \ if length == sizeof(var or type)\n  const Expr *LenExpr = Call.getArgExpr(LenIdx);\n\
  \  bool FullCopy = false;\n  if (isSizeOfVarOrType(LenExpr, VR, C)) {\n    FullCopy\
  \ = true;\n  } else {\n    llvm::APSInt Res;\n    if (EvaluateExprToInt(Res, LenExpr,\
  \ C)) {\n      uint64_t Len = Res.getZExtValue();\n      uint64_t TySize = getTypeSizeInBytes(VR->getValueType(),\
  \ C.getASTContext());\n      if (TySize == Len)\n        FullCopy = true;\n    }\n\
  \  }\n  if (!FullCopy)\n    return;\n\n  // Check struct has padding\n  if (!recordHasPadding(VR->getValueType(),\
  \ C.getASTContext()))\n    return;\n\n  // If not zeroed, report\n  ProgramStateRef\
  \ State = C.getState();\n  if (!wasZeroed(State, VR)) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Struct with padding copied without full initialization\", N);\n\
  \    R->addRange(Call.getSourceRange());\n    if (const Expr *SrcE = Call.getArgExpr(SrcIdx))\n\
  \      R->addRange(SrcE->getSourceRange());\n    if (LenExpr)\n      R->addRange(LenExpr->getSourceRange());\n\
  \    C.emitReport(std::move(R));\n  }\n}\n\n/* Checker callbacks */\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  SValBuilder &SVB = C.getSValBuilder();\n  MemRegionManager &MRMgr = SVB.getRegionManager();\n\
  \n  for (const Decl *D : DS->decls()) {\n    const auto *VD = dyn_cast<VarDecl>(D);\n\
  \    if (!VD)\n      continue;\n    if (!VD->hasLocalStorage())\n      continue;\n\
  \n    QualType QT = VD->getType();\n    if (QT.isNull() || !QT->isRecordType())\n\
  \      continue;\n\n    if (!VD->hasInit())\n      continue;\n\n    const Expr *Init\
  \ = VD->getInit();\n    if (!Init)\n      continue;\n\n    const InitListExpr *ILE\
  \ = dyn_cast<InitListExpr>(Init->IgnoreParenCasts());\n    if (!ILE)\n      continue;\n\
  \n    // Only accept \"{0}\" pattern as \"fully zeroed\".\n    bool ZeroInit = false;\n\
  \    if (ILE->getNumInits() == 1) {\n      const Expr *E0 = ILE->getInit(0);\n \
  \     if (isZeroIntegralExpr(E0, C))\n        ZeroInit = true;\n    }\n\n    if\
  \ (!ZeroInit)\n      continue;\n\n    const VarRegion *VR = MRMgr.getVarRegion(VD,\
  \ C.getLocationContext());\n    if (!VR)\n      continue;\n    if (!isLocalRecordVar(VR,\
  \ C))\n      continue;\n\n    State = markZeroed(State, VR);\n  }\n\n  if (State\
  \ != C.getState())\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // Detect memset/bzero that fully\
  \ zero a local struct\n  tryMarkZeroedByMemset(Call, C);\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  // Detect copying a whole local\
  \ struct (with padding) to user space or netlink.\n  tryReportCopyOutStructPadding(Call,\
  \ C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects copying a stack struct with padding to user without zeroing the\
  \ struct\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
