_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 81137162bfaa7278785b24c1fd2e9e74f082e8e4
commit_type: Buffer-Overflow
index: 6
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Type.h\"\n#include \"llvm/ADT/APInt.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// No custom program state required.\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new\
  \ BugType(this, \"Unbounded strcpy into fixed-size buffer\",\n                 \
  \      \"Buffer overflow\")) {}\n\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\nprivate:\n  static bool isStrcpyLike(const CallEvent &Call, CheckerContext\
  \ &C);\n  static bool getFixedArrayBoundFromArg(const Expr *Arg, CheckerContext\
  \ &C,\n                                        llvm::APInt &Bound, QualType &ElemTy);\n\
  \  static bool getExactStringLiteralLength(const Expr *Arg, CheckerContext &C,\n\
  \                                          llvm::APInt &Len);\n  static bool isCharLike(QualType\
  \ T);\n};\n\nbool SAGenTestChecker::isStrcpyLike(const CallEvent &Call,\n      \
  \                              CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  if (!ExprHasName(Origin, \"strcpy\", C))\n\
  \    return false;\n\n  // Prefer exact identifier match when available.\n  if (const\
  \ IdentifierInfo *ID = Call.getCalleeIdentifier()) {\n    if (ID->getName() != \"\
  strcpy\")\n      return false;\n  }\n  return true;\n}\n\nbool SAGenTestChecker::isCharLike(QualType\
  \ T) {\n  T = T.getCanonicalType();\n  if (const auto *BTy = dyn_cast<BuiltinType>(T.getTypePtr()))\
  \ {\n    switch (BTy->getKind()) {\n    case BuiltinType::Char_S:\n    case BuiltinType::Char_U:\n\
  \    case BuiltinType::SChar:\n    case BuiltinType::UChar:\n      return true;\n\
  \    default:\n      return false;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getFixedArrayBoundFromArg(const\
  \ Expr *Arg,\n                                                 CheckerContext &C,\n\
  \                                                 llvm::APInt &Bound,\n        \
  \                                         QualType &ElemTy) {\n  if (!Arg)\n   \
  \ return false;\n\n  const Expr *E = Arg->IgnoreParens();\n\n  // We expect an ArrayToPointerDecay\
  \ when passing arrays to functions.\n  if (const auto *ICE = dyn_cast<ImplicitCastExpr>(E))\
  \ {\n    if (ICE->getCastKind() == CK_ArrayToPointerDecay) {\n      const Expr *Sub\
  \ = ICE->getSubExpr();\n      if (!Sub)\n        return false;\n      QualType QT\
  \ = Sub->getType();\n      if (const ConstantArrayType *CAT =\n              C.getASTContext().getAsConstantArrayType(QT))\
  \ {\n        Bound = CAT->getSize();\n        ElemTy = CAT->getElementType();\n\
  \        return true;\n      }\n    }\n  }\n\n  // Fallback: directly check if the\
  \ (possibly already-decayed) expr has array type.\n  E = E->IgnoreParenImpCasts();\n\
  \  QualType QT = E->getType();\n  if (const ConstantArrayType *CAT =\n         \
  \ C.getASTContext().getAsConstantArrayType(QT)) {\n    Bound = CAT->getSize();\n\
  \    ElemTy = CAT->getElementType();\n    return true;\n  }\n\n  return false;\n\
  }\n\nbool SAGenTestChecker::getExactStringLiteralLength(const Expr *Arg,\n     \
  \                                              CheckerContext &C,\n            \
  \                                       llvm::APInt &Len) {\n  // Utility returns\
  \ length excluding the terminating NUL.\n  return getStringSize(Len, Arg);\n}\n\n\
  void SAGenTestChecker::checkPreCall(const CallEvent &Call,\n                   \
  \                 CheckerContext &C) const {\n  if (!isStrcpyLike(Call, C))\n  \
  \  return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n  const Expr *Dst = Call.getArgExpr(0);\n\
  \  const Expr *Src = Call.getArgExpr(1);\n  if (!Dst || !Src)\n    return;\n\n \
  \ // Resolve destination fixed-size bound and its element type.\n  llvm::APInt DstBound;\
  \ // number of elements\n  QualType ElemTy;\n  if (!getFixedArrayBoundFromArg(Dst,\
  \ C, DstBound, ElemTy))\n    return;\n\n  // Only warn for char-like arrays (strcpy\
  \ semantics).\n  if (!isCharLike(ElemTy))\n    return;\n\n  // If source is a string\
  \ literal, we can be precise: need Len+1 bytes incl. NUL.\n  llvm::APInt SrcLen;\n\
  \  if (getExactStringLiteralLength(Src, C, SrcLen)) {\n    // Required elements\
  \ (bytes) = SrcLen + 1 (for NUL).\n    llvm::APInt Required = SrcLen + 1;\n    if\
  \ (Required.ugt(DstBound)) {\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \      if (!N)\n        return;\n\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"strcpy overflows fixed-size buffer; use strscpy(dst, src, \"\n\
  \               \"sizeof(dst))\",\n          N);\n      R->addRange(Dst->getSourceRange());\n\
  \      C.emitReport(std::move(R));\n    }\n    return; // Literal fits -> no warning.\n\
  \  }\n\n  // Non-literal source: strcpy is unbounded, destination is fixed-size.\n\
  \  {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n    if (!N)\n      return;\n\
  \n    auto R = std::make_unique<PathSensitiveBugReport>(\n        *BT, \"Unbounded\
  \ strcpy into fixed-size buffer may overflow; use \"\n             \"strscpy(dst,\
  \ src, sizeof(dst))\",\n        N);\n    R->addRange(Dst->getSourceRange());\n \
  \   C.emitReport(std::move(R));\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects unbounded strcpy into fixed-size\
  \ buffers and suggests strscpy\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: hci_core: Fix possible buffer overflow\n\
  \nstruct hci_dev_info has a fixed size name[8] field so in the event that\nhdev->name\
  \ is bigger than that strcpy would attempt to write past its\nsize, so this fixes\
  \ this problem by switching to use strscpy.\n\nFixes: dcda165706b9 (\"Bluetooth:\
  \ hci_core: Fix build warnings\")\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\n\
  \n## Buggy Code\n\n```c\n// Function: hci_get_dev_info in net/bluetooth/hci_core.c\n\
  int hci_get_dev_info(void __user *arg)\n{\n\tstruct hci_dev *hdev;\n\tstruct hci_dev_info\
  \ di;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (copy_from_user(&di, arg,\
  \ sizeof(di)))\n\t\treturn -EFAULT;\n\n\thdev = hci_dev_get(di.dev_id);\n\tif (!hdev)\n\
  \t\treturn -ENODEV;\n\n\t/* When the auto-off is configured it means the transport\n\
  \t * is running, but in that case still indicate that the\n\t * device is actually\
  \ down.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_AUTO_OFF))\n\t\tflags = hdev->flags\
  \ & ~BIT(HCI_UP);\n\telse\n\t\tflags = hdev->flags;\n\n\tstrcpy(di.name, hdev->name);\n\
  \tdi.bdaddr   = hdev->bdaddr;\n\tdi.type     = (hdev->bus & 0x0f) | ((hdev->dev_type\
  \ & 0x03) << 4);\n\tdi.flags    = flags;\n\tdi.pkt_type = hdev->pkt_type;\n\tif\
  \ (lmp_bredr_capable(hdev)) {\n\t\tdi.acl_mtu  = hdev->acl_mtu;\n\t\tdi.acl_pkts\
  \ = hdev->acl_pkts;\n\t\tdi.sco_mtu  = hdev->sco_mtu;\n\t\tdi.sco_pkts = hdev->sco_pkts;\n\
  \t} else {\n\t\tdi.acl_mtu  = hdev->le_mtu;\n\t\tdi.acl_pkts = hdev->le_pkts;\n\t\
  \tdi.sco_mtu  = 0;\n\t\tdi.sco_pkts = 0;\n\t}\n\tdi.link_policy = hdev->link_policy;\n\
  \tdi.link_mode   = hdev->link_mode;\n\n\tmemcpy(&di.stat, &hdev->stat, sizeof(di.stat));\n\
  \tmemcpy(&di.features, &hdev->features, sizeof(di.features));\n\n\tif (copy_to_user(arg,\
  \ &di, sizeof(di)))\n\t\terr = -EFAULT;\n\n\thci_dev_put(hdev);\n\n\treturn err;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c\n\
  index 6ca4c0df9f9c..230d2bbb933b 100644\n--- a/net/bluetooth/hci_core.c\n+++ b/net/bluetooth/hci_core.c\n\
  @@ -908,7 +908,7 @@ int hci_get_dev_info(void __user *arg)\n \telse\n \t\tflags\
  \ = hdev->flags;\n \n-\tstrcpy(di.name, hdev->name);\n+\tstrscpy(di.name, hdev->name,\
  \ sizeof(di.name));\n \tdi.bdaddr   = hdev->bdaddr;\n \tdi.type     = (hdev->bus\
  \ & 0x0f) | ((hdev->dev_type & 0x03) << 4);\n \tdi.flags    = flags;\n```\n"
pattern: "## Bug Pattern\n\nUsing an unbounded string copy (strcpy) into a fixed-size\
  \ buffer where the source string can exceed the destination\u2019s capacity, e.g.:\n\
  \nchar dst[8];\nstrcpy(dst, src);  // src may be longer than 7 chars + NUL -> overflow\n\
  \nIn this case, copying hdev->name into di.name[8] without a length limit can overflow.\
  \ The fix uses strscpy(dst, src, sizeof(dst)) to bound the copy."
plan: "Plan\n\n1) Program state\n- No custom program state is required. The checker\
  \ is a call-site inspection for unsafe API usage with locally derivable facts (array\
  \ bound and literal length).\n\n2) Callbacks\n- Use only checkPreCall to inspect\
  \ calls to strcpy and decide whether the destination is a fixed-size array and the\
  \ copy is unbounded/too large.\n\n3) Helper routines\n- isStrcpyLike(const CallEvent\
  \ &Call):\n  - Return true if Call.getCalleeIdentifier() exists and its name equals\
  \ \"strcpy\".\n  - Do not match strlcpy/strscpy/etc.\n\n- getFixedArrayBoundFromArg(const\
  \ Expr *Arg, CheckerContext &C, llvm::APInt &Bound):\n  - Goal: Given the destination\
  \ argument expression, recover the underlying fixed-size array bound, if any.\n\
  \  - Steps:\n    - Let E = Arg->IgnoreParenImpCasts().\n    - If Arg is an ImplicitCastExpr\
  \ with CK_ArrayToPointerDecay, let A = ICE->getSubExpr()->IgnoreParenImpCasts().\n\
  \    - Inspect A->getType(). If it is a ConstantArrayType (CAT), set Bound = CAT->getSize()\
  \ and return true.\n    - This handles:\n      - DeclRefExpr where the variable\
  \ is a fixed-size array (char buf[8]).\n      - MemberExpr (e.g., di.name) where\
  \ the field type is a ConstantArrayType (char name[8]).\n    - Otherwise return\
  \ false (no known fixed bound).\n\n- getExactStringLiteralLength(const Expr *Arg,\
  \ CheckerContext &C, llvm::APInt &Len):\n  - Use provided getStringSize(StringSize,\
  \ Arg) utility.\n  - Note: StringLiteral::getLength() returns the number of characters\
  \ excluding the terminating NUL. For strcpy, the required bytes are Len + 1.\n\n\
  4) checkPreCall implementation\n- Recognize target call:\n  - If not isStrcpyLike(Call),\
  \ return.\n- Extract arguments:\n  - const Expr *Dst = Call.getArgExpr(0), *Src\
  \ = Call.getArgExpr(1).\n- Determine destination fixed-size bound:\n  - llvm::APInt\
  \ DstBound;\n  - If getFixedArrayBoundFromArg(Dst, C, DstBound) is false, return\
  \ (we only warn when we know the destination is a fixed-size array).\n- Determine\
  \ source size characteristics:\n  - Case A: String literal:\n    - llvm::APInt SrcLen;\n\
  \    - If getExactStringLiteralLength(Src, C, SrcLen) is true:\n      - Required\
  \ = SrcLen + 1 (to account for NUL).\n      - If Required.ugt(DstBound):\n     \
  \   - Report bug: \"strcpy overflows fixed-size buffer\".\n        - Include a note\
  \ suggesting: \"Use strscpy(dst, src, sizeof(dst)).\"\n      - Else (Required <=\
  \ DstBound): treat as safe; do nothing.\n  - Case B: Non-literal source (unknown\
  \ or variable length):\n    - Since strcpy is unbounded and destination is a known\
  \ fixed-size array, report a potential overflow.\n    - Message: \"Unbounded strcpy\
  \ into fixed-size buffer may overflow.\"\n    - Add a note: \"Use strscpy(dst, src,\
  \ sizeof(dst)).\"\n- Bug reporting:\n  - Create a BugType once (e.g., \u201CPossible\
  \ buffer overflow (strcpy into fixed-size buffer)\u201D).\n  - Create an error node\
  \ via generateNonFatalErrorNode().\n  - Report using std::make_unique<PathSensitiveBugReport>.\n\
  \  - Highlight the destination argument source range.\n\n5) Scope of detection and\
  \ false positives handling\n- Only warn when the destination is conclusively a fixed-size\
  \ array (ConstantArrayType) to minimize false positives.\n- If the source is a string\
  \ literal and fits (including NUL), do not warn.\n- If the source is not a literal\
  \ (cannot prove upper bound), warn because strcpy provides no bound and may overflow\
  \ a fixed-size destination.\n- No additional branch-condition inspection is needed\
  \ for this pattern (keep the checker simple as requested).\n\n6) Notes on utility\
  \ usage and AST details\n- Use getStringSize for literal length extraction.\n- For\
  \ array bound extraction, rely on identifying CK_ArrayToPointerDecay on the destination\
  \ argument and reading the ConstantArrayType from the decayed subexpression\u2019\
  s type. This works for both DeclRefExpr (local arrays) and MemberExpr (struct fields\
  \ like di.name[8]).\n- No alias or pointer state tracking is necessary, as we only\
  \ decide based on the callsite\u2019s destination type and source expression kind.\n\
  \n7) Summary of minimal implementation steps\n- No REGISTER_* program state.\n-\
  \ Implement isStrcpyLike, getFixedArrayBoundFromArg, getExactStringLiteralLength\
  \ helpers.\n- Hook checkPreCall:\n  - If call is strcpy:\n    - If destination is\
  \ a fixed array:\n      - If source is a string literal and length+1 > sizeof(dest):\
  \ report.\n      - Else if source is not a string literal: report (potential overflow).\n\
  - Keep report messages short and suggest strscpy(dst, src, sizeof(dst))."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Type.h\"\n#include \"llvm/ADT/APInt.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// No custom program state required.\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new\
  \ BugType(this, \"Unbounded strcpy into fixed-size buffer\",\n                 \
  \      \"Buffer overflow\")) {}\n\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\nprivate:\n  static bool isStrcpyLike(const CallEvent &Call, CheckerContext\
  \ &C);\n  static bool getFixedArrayBoundFromArg(const Expr *Arg, CheckerContext\
  \ &C,\n                                        llvm::APInt &Bound, QualType &ElemTy);\n\
  \  static bool getExactStringLiteralLength(const Expr *Arg, CheckerContext &C,\n\
  \                                          llvm::APInt &Len);\n  static bool isCharLike(QualType\
  \ T);\n};\n\nbool SAGenTestChecker::isStrcpyLike(const CallEvent &Call,\n      \
  \                              CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  if (!ExprHasName(Origin, \"strcpy\", C))\n\
  \    return false;\n\n  // Prefer exact identifier match when available.\n  if (const\
  \ IdentifierInfo *ID = Call.getCalleeIdentifier()) {\n    if (ID->getName() != \"\
  strcpy\")\n      return false;\n  }\n  return true;\n}\n\nbool SAGenTestChecker::isCharLike(QualType\
  \ T) {\n  T = T.getCanonicalType();\n  if (const auto *BTy = dyn_cast<BuiltinType>(T.getTypePtr()))\
  \ {\n    switch (BTy->getKind()) {\n    case BuiltinType::Char_S:\n    case BuiltinType::Char_U:\n\
  \    case BuiltinType::SChar:\n    case BuiltinType::UChar:\n      return true;\n\
  \    default:\n      return false;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getFixedArrayBoundFromArg(const\
  \ Expr *Arg,\n                                                 CheckerContext &C,\n\
  \                                                 llvm::APInt &Bound,\n        \
  \                                         QualType &ElemTy) {\n  if (!Arg)\n   \
  \ return false;\n\n  const Expr *E = Arg->IgnoreParens();\n\n  // We expect an ArrayToPointerDecay\
  \ when passing arrays to functions.\n  if (const auto *ICE = dyn_cast<ImplicitCastExpr>(E))\
  \ {\n    if (ICE->getCastKind() == CK_ArrayToPointerDecay) {\n      const Expr *Sub\
  \ = ICE->getSubExpr();\n      if (!Sub)\n        return false;\n      QualType QT\
  \ = Sub->getType();\n      if (const ConstantArrayType *CAT =\n              C.getASTContext().getAsConstantArrayType(QT))\
  \ {\n        Bound = CAT->getSize();\n        ElemTy = CAT->getElementType();\n\
  \        return true;\n      }\n    }\n  }\n\n  // Fallback: directly check if the\
  \ (possibly already-decayed) expr has array type.\n  E = E->IgnoreParenImpCasts();\n\
  \  QualType QT = E->getType();\n  if (const ConstantArrayType *CAT =\n         \
  \ C.getASTContext().getAsConstantArrayType(QT)) {\n    Bound = CAT->getSize();\n\
  \    ElemTy = CAT->getElementType();\n    return true;\n  }\n\n  return false;\n\
  }\n\nbool SAGenTestChecker::getExactStringLiteralLength(const Expr *Arg,\n     \
  \                                              CheckerContext &C,\n            \
  \                                       llvm::APInt &Len) {\n  // Utility returns\
  \ length excluding the terminating NUL.\n  return getStringSize(Len, Arg);\n}\n\n\
  void SAGenTestChecker::checkPreCall(const CallEvent &Call,\n                   \
  \                 CheckerContext &C) const {\n  if (!isStrcpyLike(Call, C))\n  \
  \  return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n  const Expr *Dst = Call.getArgExpr(0);\n\
  \  const Expr *Src = Call.getArgExpr(1);\n  if (!Dst || !Src)\n    return;\n\n \
  \ // Resolve destination fixed-size bound and its element type.\n  llvm::APInt DstBound;\
  \ // number of elements\n  QualType ElemTy;\n  if (!getFixedArrayBoundFromArg(Dst,\
  \ C, DstBound, ElemTy))\n    return;\n\n  // Only warn for char-like arrays (strcpy\
  \ semantics).\n  if (!isCharLike(ElemTy))\n    return;\n\n  // If source is a string\
  \ literal, we can be precise: need Len+1 bytes incl. NUL.\n  llvm::APInt SrcLen;\n\
  \  if (getExactStringLiteralLength(Src, C, SrcLen)) {\n    // Required elements\
  \ (bytes) = SrcLen + 1 (for NUL).\n    llvm::APInt Required = SrcLen + 1;\n    if\
  \ (Required.ugt(DstBound)) {\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \      if (!N)\n        return;\n\n      auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \          *BT, \"strcpy overflows fixed-size buffer; use strscpy(dst, src, \"\n\
  \               \"sizeof(dst))\",\n          N);\n      R->addRange(Dst->getSourceRange());\n\
  \      C.emitReport(std::move(R));\n    }\n    return; // Literal fits -> no warning.\n\
  \  }\n\n  // Non-literal source: strcpy is unbounded, destination is fixed-size.\n\
  \  {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n    if (!N)\n      return;\n\
  \n    auto R = std::make_unique<PathSensitiveBugReport>(\n        *BT, \"Unbounded\
  \ strcpy into fixed-size buffer may overflow; use \"\n             \"strscpy(dst,\
  \ src, sizeof(dst))\",\n        N);\n    R->addRange(Dst->getSourceRange());\n \
  \   C.emitReport(std::move(R));\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects unbounded strcpy into fixed-size\
  \ buffers and suggests strscpy\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
