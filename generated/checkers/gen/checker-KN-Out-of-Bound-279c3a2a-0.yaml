_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 279c3a2a5eb2c1054fbe38e5c33be08584229047
commit_type: Out-of-Bound
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"clang/Basic/SourceManager.h\"\n#include \"llvm/ADT/APInt.h\"\n#include\
  \ \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/Support/Casting.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states are necessary.\n\nnamespace {\n\n/* The checker callbacks\
  \ are to be decided. */\nclass SAGenTestChecker : public Checker<check::ASTCodeBody>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Off-by-one bounds check\", \"Logic error\")) {}\n\n \
  \     void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter &BR)\
  \ const;\n\n   private:\n\n      // Find a strict upper bound comparison inside\
  \ Cond of the form:\n      //   idx > MAX   or   MAX < idx\n      // Returns true\
  \ and fills OutIdxVar, OutBound, OutOp if found.\n      bool findStrictUpperBound(const\
  \ Expr *Cond,\n                                const VarDecl *&OutIdxVar,\n    \
  \                            llvm::APSInt &OutBound,\n                         \
  \       const BinaryOperator *&OutOp,\n                                ASTContext\
  \ &AC) const;\n\n      // Analyze a single IfStmt:\n      //  - must have early\
  \ return in then-branch\n      //  - must contain strict upper bound check on an\
  \ index\n      //  - later array subscript with same index into array of size ==\
  \ bound\n      void analyzeIfStmt(const IfStmt *IfS,\n                         const\
  \ Stmt *FuncBody,\n                         ASTContext &AC,\n                  \
  \       AnalysisManager &Mgr,\n                         BugReporter &BR) const;\n\
  \n      // Recursively visit all IfStmts in function body.\n      void visitIfs(const\
  \ Stmt *S,\n                    const Stmt *FuncBody,\n                    ASTContext\
  \ &AC,\n                    AnalysisManager &Mgr,\n                    BugReporter\
  \ &BR) const;\n\n      // Extract constant array size from base expression of an\
  \ array access.\n      bool getArraySizeFromBaseExpr(const Expr *BaseE, llvm::APInt\
  \ &ArraySize) const;\n\n      // Check whether expression E refers to the same variable\
  \ Var (DeclRefExpr).\n      bool isExprRefToVar(const Expr *E, const VarDecl *Var)\
  \ const;\n};\n\nbool SAGenTestChecker::isExprRefToVar(const Expr *E, const VarDecl\
  \ *Var) const {\n  if (!E || !Var) return false;\n  const Expr *IE = E->IgnoreParenImpCasts();\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(IE)) {\n    if (const auto *VD =\
  \ dyn_cast<VarDecl>(DRE->getDecl()))\n      return VD == Var;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::getArraySizeFromBaseExpr(const Expr *BaseE, llvm::APInt\
  \ &ArraySize) const {\n  if (!BaseE) return false;\n  const Expr *BE = BaseE->IgnoreParenImpCasts();\n\
  \n  // Case 1: DeclRefExpr to a VarDecl with constant array type\n  if (const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(BE)) {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n      QualType QT = VD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr()))\
  \ {\n        ArraySize = CAT->getSize();\n        return true;\n      }\n    }\n\
  \  }\n\n  // Case 2: MemberExpr to a FieldDecl with constant array type (e.g., adc->thresholds[...])\n\
  \  if (const auto *ME = dyn_cast<MemberExpr>(BE)) {\n    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl()))\
  \ {\n      QualType FT = FD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(FT.getTypePtr()))\
  \ {\n        ArraySize = CAT->getSize();\n        return true;\n      }\n    }\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::findStrictUpperBound(const\
  \ Expr *Cond,\n                                            const VarDecl *&OutIdxVar,\n\
  \                                            llvm::APSInt &OutBound,\n         \
  \                                   const BinaryOperator *&OutOp,\n            \
  \                                ASTContext &AC) const {\n  if (!Cond) return false;\n\
  \  const Expr *E = Cond->IgnoreParenImpCasts();\n\n  if (const auto *BO = dyn_cast<BinaryOperator>(E))\
  \ {\n    // Direct match: idx > MAX\n    if (BO->getOpcode() == BO_GT) {\n     \
  \ const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n      const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n\
  \n      if (const auto *LDRE = dyn_cast<DeclRefExpr>(L)) {\n        if (const auto\
  \ *VD = dyn_cast<VarDecl>(LDRE->getDecl())) {\n          Expr::EvalResult ER;\n\
  \          if (R->EvaluateAsInt(ER, AC)) {\n            OutIdxVar = VD;\n      \
  \      OutBound = ER.Val.getInt();\n            OutOp = BO;\n            return\
  \ true;\n          }\n        }\n      }\n    }\n\n    // Direct match: MAX < idx\n\
  \    if (BO->getOpcode() == BO_LT) {\n      const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n\n      Expr::EvalResult\
  \ ER;\n      if (L->EvaluateAsInt(ER, AC)) {\n        if (const auto *RDRE = dyn_cast<DeclRefExpr>(R))\
  \ {\n          if (const auto *VD = dyn_cast<VarDecl>(RDRE->getDecl())) {\n    \
  \        OutIdxVar = VD;\n            OutBound = ER.Val.getInt();\n            OutOp\
  \ = BO;\n            return true;\n          }\n        }\n      }\n    }\n\n  \
  \  // Otherwise, recurse into both sides (handles logical ops like ||, &&, etc.)\n\
  \    if (findStrictUpperBound(BO->getLHS(), OutIdxVar, OutBound, OutOp, AC))\n \
  \     return true;\n    if (findStrictUpperBound(BO->getRHS(), OutIdxVar, OutBound,\
  \ OutOp, AC))\n      return true;\n\n    return false;\n  }\n\n  // Generic recursion\
  \ over children for other expression kinds.\n  for (const Stmt *Child : E->children())\
  \ {\n    if (const auto *CE = dyn_cast_or_null<Expr>(Child)) {\n      if (findStrictUpperBound(CE,\
  \ OutIdxVar, OutBound, OutOp, AC))\n        return true;\n    }\n  }\n\n  return\
  \ false;\n}\n\nvoid SAGenTestChecker::analyzeIfStmt(const IfStmt *IfS,\n       \
  \                              const Stmt *FuncBody,\n                         \
  \            ASTContext &AC,\n                                     AnalysisManager\
  \ &Mgr,\n                                     BugReporter &BR) const {\n  if (!IfS\
  \ || !FuncBody) return;\n\n  // Heuristic: require early return in the 'then' branch\n\
  \  const Stmt *ThenS = IfS->getThen();\n  if (!ThenS)\n    return;\n\n  // Use the\
  \ provided utility to find ReturnStmt in 'then'\n  const ReturnStmt *RetInThen =\
  \ findSpecificTypeInChildren<ReturnStmt>(ThenS);\n  if (!RetInThen)\n    return;\n\
  \n  // Find the strict upper bound in the condition\n  const VarDecl *IdxVar = nullptr;\n\
  \  llvm::APSInt Bound;\n  const BinaryOperator *OpNode = nullptr;\n\n  const Expr\
  \ *Cond = IfS->getCond();\n  if (!Cond)\n    return;\n\n  if (!findStrictUpperBound(Cond,\
  \ IdxVar, Bound, OpNode, AC))\n    return;\n\n  // After the IfStmt, look for array\
  \ subscripts A[IdxVar]\n  const SourceManager &SM = Mgr.getSourceManager();\n  SourceLocation\
  \ IfLoc = SM.getFileLoc(IfS->getIfLoc());\n\n  // Traverse function body and search\
  \ for ArraySubscriptExpr after IfLoc\n  bool Reported = false;\n\n  std::function<void(const\
  \ Stmt *)> Walker = [&](const Stmt *S) {\n    if (!S || Reported) return;\n\n  \
  \  // Check for array subscript\n    if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(S))\
  \ {\n      SourceLocation ASELoc = SM.getFileLoc(ASE->getExprLoc());\n      if (SM.isBeforeInTranslationUnit(IfLoc,\
  \ ASELoc)) {\n        // Index should reference the same variable\n        const\
  \ Expr *IdxE = ASE->getIdx();\n        if (isExprRefToVar(IdxE, IdxVar)) {\n   \
  \       // Determine array size from base expression\n          llvm::APInt ArrSize;\n\
  \          if (getArraySizeFromBaseExpr(ASE->getBase(), ArrSize)) {\n          \
  \  // Compare ArrSize with Bound\n            uint64_t ArrVal = ArrSize.getLimitedValue(UINT64_MAX);\n\
  \            uint64_t BoundVal = Bound.isSigned()\n                            \
  \        ? static_cast<uint64_t>(static_cast<int64_t>(Bound.getSExtValue()))\n \
  \                                   : Bound.getZExtValue();\n\n            if (ArrVal\
  \ == BoundVal) {\n              // Off-by-one: using '>' or '<' allows idx == MAX;\
  \ should use '>=' or '<=' respectively.\n              SourceLocation Loc = OpNode\
  \ ? OpNode->getOperatorLoc() : IfS->getIfLoc();\n              auto R = std::make_unique<BasicBugReport>(\n\
  \                  *BT,\n                  \"Off-by-one bound check: '>' allows\
  \ index == bound; use '>='\",\n                  PathDiagnosticLocation(Loc, BR.getSourceManager()));\n\
  \              R->addRange(OpNode ? OpNode->getSourceRange() : IfS->getSourceRange());\n\
  \              BR.emitReport(std::move(R));\n              Reported = true;\n  \
  \            return;\n            }\n          }\n        }\n      }\n    }\n\n\
  \    for (const Stmt *Child : S->children())\n      Walker(Child);\n  };\n\n  Walker(FuncBody);\n\
  }\n\nvoid SAGenTestChecker::visitIfs(const Stmt *S,\n                          \
  \      const Stmt *FuncBody,\n                                ASTContext &AC,\n\
  \                                AnalysisManager &Mgr,\n                       \
  \         BugReporter &BR) const {\n  if (!S) return;\n\n  if (const auto *IfS =\
  \ dyn_cast<IfStmt>(S))\n    analyzeIfStmt(IfS, FuncBody, AC, Mgr, BR);\n\n  for\
  \ (const Stmt *Child : S->children())\n    visitIfs(Child, FuncBody, AC, Mgr, BR);\n\
  }\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager &Mgr,\
  \ BugReporter &BR) const {\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!FD)\n    return;\n\n  const Stmt *Body = FD->getBody();\n  if (!Body)\n\
  \    return;\n\n  ASTContext &AC = Mgr.getASTContext();\n  visitIfs(Body, Body,\
  \ AC, Mgr, BR);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects off-by-one array index checks that use '>' instead of '>=' when\
  \ guarding array accesses\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\niio: adc: palmas: fix off by one bugs\n\nValid values\
  \ for \"adc_chan\" are zero to (PALMAS_ADC_CH_MAX - 1).\nSmatch detects some buffer\
  \ overflows caused by this:\ndrivers/iio/adc/palmas_gpadc.c:721 palmas_gpadc_read_event_value()\
  \ error: buffer overflow 'adc->thresholds' 16 <= 16\ndrivers/iio/adc/palmas_gpadc.c:758\
  \ palmas_gpadc_write_event_value() error: buffer overflow 'adc->thresholds' 16 <=\
  \ 16\n\nThe effect of this bug in other functions is more complicated but\nobviously\
  \ we should fix all of them.\n\nFixes: a99544c6c883 (\"iio: adc: palmas: add support\
  \ for iio threshold events\")\nSigned-off-by: Dan Carpenter <dan.carpenter@linaro.org>\n\
  Link: https://lore.kernel.org/r/14fee94a-7db7-4371-b7d6-e94d86b9561e@kili.mountain\n\
  Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>\n\n## Buggy Code\n\
  \n```c\n// Function: palmas_gpadc_read_event_value in drivers/iio/adc/palmas_gpadc.c\n\
  static int palmas_gpadc_read_event_value(struct iio_dev *indio_dev,\n\t\t\t\t\t\
  \ const struct iio_chan_spec *chan,\n\t\t\t\t\t enum iio_event_type type,\n\t\t\t\
  \t\t enum iio_event_direction dir,\n\t\t\t\t\t enum iio_event_info info,\n\t\t\t\
  \t\t int *val, int *val2)\n{\n\tstruct palmas_gpadc *adc = iio_priv(indio_dev);\n\
  \tint adc_chan = chan->channel;\n\tint ret;\n\n\tif (adc_chan > PALMAS_ADC_CH_MAX\
  \ || type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&adc->lock);\n\
  \n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\t\t*val = (dir == IIO_EV_DIR_RISING)\
  \ ?\n\t\t\tadc->thresholds[adc_chan].high :\n\t\t\tadc->thresholds[adc_chan].low;\n\
  \t\tret = IIO_VAL_INT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\
  \t}\n\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n```\n\n```c\n// Function:\
  \ palmas_gpadc_write_event_value in drivers/iio/adc/palmas_gpadc.c\nstatic int palmas_gpadc_write_event_value(struct\
  \ iio_dev *indio_dev,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t\
  \  enum iio_event_type type,\n\t\t\t\t\t  enum iio_event_direction dir,\n\t\t\t\t\
  \t  enum iio_event_info info,\n\t\t\t\t\t  int val, int val2)\n{\n\tstruct palmas_gpadc\
  \ *adc = iio_priv(indio_dev);\n\tint adc_chan = chan->channel;\n\tint old;\n\tint\
  \ ret;\n\n\tif (adc_chan > PALMAS_ADC_CH_MAX || type != IIO_EV_TYPE_THRESH)\n\t\t\
  return -EINVAL;\n\n\tmutex_lock(&adc->lock);\n\tswitch (info) {\n\tcase IIO_EV_INFO_VALUE:\n\
  \t\tif (val < 0 || val > 0xFFF) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\
  \t\t}\n\t\tif (dir == IIO_EV_DIR_RISING) {\n\t\t\told = adc->thresholds[adc_chan].high;\n\
  \t\t\tadc->thresholds[adc_chan].high = val;\n\t\t} else {\n\t\t\told = adc->thresholds[adc_chan].low;\n\
  \t\t\tadc->thresholds[adc_chan].low = val;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\t\
  default:\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (val != old && palmas_gpadc_get_event(adc,\
  \ adc_chan, dir))\n\t\tret = palmas_gpadc_reconfigure_event_channels(adc);\n\nout_unlock:\n\
  \tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n```\n\n```c\n// Function: palmas_gpadc_read_event_config\
  \ in drivers/iio/adc/palmas_gpadc.c\nstatic int palmas_gpadc_read_event_config(struct\
  \ iio_dev *indio_dev,\n\t\t\t\t\t  const struct iio_chan_spec *chan,\n\t\t\t\t\t\
  \  enum iio_event_type type,\n\t\t\t\t\t  enum iio_event_direction dir)\n{\n\tstruct\
  \ palmas_gpadc *adc = iio_priv(indio_dev);\n\tint adc_chan = chan->channel;\n\t\
  int ret = 0;\n\n\tif (adc_chan > PALMAS_ADC_CH_MAX || type != IIO_EV_TYPE_THRESH)\n\
  \t\treturn -EINVAL;\n\n\tmutex_lock(&adc->lock);\n\n\tif (palmas_gpadc_get_event(adc,\
  \ adc_chan, dir))\n\t\tret = 1;\n\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n\
  }\n```\n\n```c\n// Function: palmas_gpadc_read_raw in drivers/iio/adc/palmas_gpadc.c\n\
  static int palmas_gpadc_read_raw(struct iio_dev *indio_dev,\n\tstruct iio_chan_spec\
  \ const *chan, int *val, int *val2, long mask)\n{\n\tstruct  palmas_gpadc *adc =\
  \ iio_priv(indio_dev);\n\tint adc_chan = chan->channel;\n\tint ret = 0;\n\n\tif\
  \ (adc_chan > PALMAS_ADC_CH_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&adc->lock);\n\
  \n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\tcase IIO_CHAN_INFO_PROCESSED:\n\
  \t\tret = palmas_gpadc_read_prepare(adc, adc_chan);\n\t\tif (ret < 0)\n\t\t\tgoto\
  \ out;\n\n\t\tret = palmas_gpadc_start_conversion(adc, adc_chan);\n\t\tif (ret <\
  \ 0) {\n\t\t\tdev_err(adc->dev,\n\t\t\t\"ADC start conversion failed\\n\");\n\t\t\
  \tgoto out;\n\t\t}\n\n\t\tif (mask == IIO_CHAN_INFO_PROCESSED)\n\t\t\tret = palmas_gpadc_get_calibrated_code(\n\
  \t\t\t\t\t\t\tadc, adc_chan, ret);\n\n\t\t*val = ret;\n\n\t\tret = IIO_VAL_INT;\n\
  \t\tgoto out;\n\t}\n\n\tmutex_unlock(&adc->lock);\n\treturn ret;\n\nout:\n\tpalmas_gpadc_read_done(adc,\
  \ adc_chan);\n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n```\n\n```c\n// Function:\
  \ palmas_gpadc_write_event_config in drivers/iio/adc/palmas_gpadc.c\nstatic int\
  \ palmas_gpadc_write_event_config(struct iio_dev *indio_dev,\n\t\t\t\t\t   const\
  \ struct iio_chan_spec *chan,\n\t\t\t\t\t   enum iio_event_type type,\n\t\t\t\t\t\
  \   enum iio_event_direction dir,\n\t\t\t\t\t   int state)\n{\n\tstruct palmas_gpadc\
  \ *adc = iio_priv(indio_dev);\n\tint adc_chan = chan->channel;\n\tint ret;\n\n\t\
  if (adc_chan > PALMAS_ADC_CH_MAX || type != IIO_EV_TYPE_THRESH)\n\t\treturn -EINVAL;\n\
  \n\tmutex_lock(&adc->lock);\n\n\tif (state)\n\t\tret = palmas_gpadc_enable_event_config(adc,\
  \ chan, dir);\n\telse\n\t\tret = palmas_gpadc_disable_event_config(adc, chan, dir);\n\
  \n\tmutex_unlock(&adc->lock);\n\n\treturn ret;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/iio/adc/palmas_gpadc.c b/drivers/iio/adc/palmas_gpadc.c\nindex\
  \ c1c439215aeb..7dfc9c927a23 100644\n--- a/drivers/iio/adc/palmas_gpadc.c\n+++ b/drivers/iio/adc/palmas_gpadc.c\n\
  @@ -547,7 +547,7 @@ static int palmas_gpadc_read_raw(struct iio_dev *indio_dev,\n\
  \ \tint adc_chan = chan->channel;\n \tint ret = 0;\n \n-\tif (adc_chan > PALMAS_ADC_CH_MAX)\n\
  +\tif (adc_chan >= PALMAS_ADC_CH_MAX)\n \t\treturn -EINVAL;\n \n \tmutex_lock(&adc->lock);\n\
  @@ -595,7 +595,7 @@ static int palmas_gpadc_read_event_config(struct iio_dev *indio_dev,\n\
  \ \tint adc_chan = chan->channel;\n \tint ret = 0;\n \n-\tif (adc_chan > PALMAS_ADC_CH_MAX\
  \ || type != IIO_EV_TYPE_THRESH)\n+\tif (adc_chan >= PALMAS_ADC_CH_MAX || type !=\
  \ IIO_EV_TYPE_THRESH)\n \t\treturn -EINVAL;\n \n \tmutex_lock(&adc->lock);\n@@ -684,7\
  \ +684,7 @@ static int palmas_gpadc_write_event_config(struct iio_dev *indio_dev,\n\
  \ \tint adc_chan = chan->channel;\n \tint ret;\n \n-\tif (adc_chan > PALMAS_ADC_CH_MAX\
  \ || type != IIO_EV_TYPE_THRESH)\n+\tif (adc_chan >= PALMAS_ADC_CH_MAX || type !=\
  \ IIO_EV_TYPE_THRESH)\n \t\treturn -EINVAL;\n \n \tmutex_lock(&adc->lock);\n@@ -710,7\
  \ +710,7 @@ static int palmas_gpadc_read_event_value(struct iio_dev *indio_dev,\n\
  \ \tint adc_chan = chan->channel;\n \tint ret;\n \n-\tif (adc_chan > PALMAS_ADC_CH_MAX\
  \ || type != IIO_EV_TYPE_THRESH)\n+\tif (adc_chan >= PALMAS_ADC_CH_MAX || type !=\
  \ IIO_EV_TYPE_THRESH)\n \t\treturn -EINVAL;\n \n \tmutex_lock(&adc->lock);\n@@ -744,7\
  \ +744,7 @@ static int palmas_gpadc_write_event_value(struct iio_dev *indio_dev,\n\
  \ \tint old;\n \tint ret;\n \n-\tif (adc_chan > PALMAS_ADC_CH_MAX || type != IIO_EV_TYPE_THRESH)\n\
  +\tif (adc_chan >= PALMAS_ADC_CH_MAX || type != IIO_EV_TYPE_THRESH)\n \t\treturn\
  \ -EINVAL;\n \n \tmutex_lock(&adc->lock);\n```\n"
pattern: "## Bug Pattern\n\nOff-by-one bounds check on an array index: using \u201C\
  > MAX\u201D instead of \u201C>= MAX\u201D when MAX denotes the count/size (valid\
  \ indices are 0..MAX-1). This allows index == MAX to pass validation and be used\
  \ to index arrays (e.g., thresholds[MAX]), causing out-of-bounds access.\n\nWrong:\n\
  if (idx > MAX)\n    return -EINVAL;\n\nRight:\nif (idx >= MAX)\n    return -EINVAL;"
plan: "Plan\n\n1) Program state\n- No custom program states are necessary. We can\
  \ detect this as a purely syntactic/semantic (AST-level) pattern within a single\
  \ function body.\n\n2) Callbacks to use\n- checkASTCodeBody(const Decl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR)\n  Reason: The pattern is a local, flow-light condition\
  \ in a function (an off-by-one guard \u201C> MAX\u201D guarding later array indexing).\
  \ We can match it directly by walking the AST of the function body, avoiding path-sensitive\
  \ state.\n\n3) Overall detection strategy (within checkASTCodeBody)\n- For each\
  \ function body (D has a statement body), traverse the AST and:\n  a) Find IfStmts\
  \ whose condition contains a \u201Cstrict upper bound\u201D integer comparison on\
  \ an index variable (idx > MAX or MAX < idx).\n  b) Ensure the \u201Cthen\u201D\
  \ branch contains a ReturnStmt (typical early-return guard). This greatly reduces\
  \ false positives (it matches the common \u201Cvalidate then return -EINVAL\u201D\
  \ idiom).\n  c) Extract the compared index variable and the bound constant value\
  \ (MAX).\n  d) After this IfStmt (in source order), find any array subscript expressions\
  \ A[idx]. For each:\n     - Identify the array\u2019s compile-time size (when possible).\n\
  \     - If the array size equals MAX (the same bound used in the guard), report:\
  \ the check \u201C> MAX\u201D incorrectly allows idx == MAX.\n  e) Emit a single\
  \ report per found pattern.\n\n4) Detailed implementation steps\n\nStep 4.1: Traverse\
  \ the function body\n- In checkASTCodeBody, get the body stmt (cast the Decl to\
  \ FunctionDecl/ObjCMethodDecl/etc., and get the body).\n- Perform a recursive AST\
  \ walk over the body. For each IfStmt, apply the steps below.\n\nStep 4.2: Identify\
  \ a \u201Cstrict upper bound\u201D guard in the If condition\n- Extract the condition\
  \ Stmt* Cond = If->getCond().\n- Within Cond, search for BinaryOperator nodes that\
  \ are strict comparisons where the relational operator is:\n  - BO_GT (idx > MAX)\
  \ or BO_LT (MAX < idx)\n- Conditions are often compound (e.g., idx > MAX || type\
  \ != X). Handle this by recursively scanning all children of Cond; when you encounter\
  \ a BinaryOperator with \u2018||\u2019/\u2018&&\u2019, keep diving until you find\
  \ a BO_GT/BO_LT.\n- When you find a BO_GT/BO_LT, try to identify sides:\n  - Case\
  \ 1: LHS is the index variable; RHS is the bound.\n  - Case 2: LHS is the bound;\
  \ RHS is the index variable (for <).\n- Index expression constraints:\n  - Prefer\
  \ a DeclRefExpr to a VarDecl (e.g., \u201Cint adc_chan\u201D), and record VarDecl*\
  \ IdxVar. Ignore more complex expressions to keep the checker simple and precise.\n\
  - Bound expression constraints:\n  - Try to evaluate it to an integer using EvaluateExprToInt(APSInt\
  \ &Out, const Expr *E, CheckerContext &C).\n  - If evaluation fails, skip this candidate\
  \ (we only warn when the bound is a known constant).\n- If multiple BO_GT/BO_LT\
  \ candidates exist in the same If condition, you can handle any that match the pattern\
  \ (typically there\u2019s just one for the index).\n\nStep 4.3: Ensure it is an\
  \ early-return guard\n- Inspect the IfStmt\u2019s then-branch (If->getThen()) and\
  \ check if it contains any ReturnStmt using findSpecificTypeInChildren<ReturnStmt>(Then).\n\
  - If there is no ReturnStmt in the then-branch, skip this If (reduces false positives).\n\
  \nStep 4.4: Find array subscripts later that use the same index variable\n- From\
  \ the function body, collect ArraySubscriptExpr nodes whose index expression is\
  \ the same IdxVar (DeclRefExpr to the same VarDecl).\n- For each such ArraySubscriptExpr\
  \ ASE:\n  - Ensure the ASE occurs after the IfStmt in source order:\n    - Use SourceManager::isBeforeInTranslationUnit(IfLoc,\
  \ ASELoc) to enforce \u201Cguard first, use later\u201D.\n  - Determine the array\
  \ base and its compile-time size:\n    - Let BaseE = ASE->getBase()->IgnoreParenImpCasts().\n\
  \    - If BaseE is a DeclRefExpr referring to a VarDecl of constant array type,\
  \ use the provided helper getArraySizeFromExpr(ArraySize, BaseE). If it returns\
  \ true, we got the array size.\n    - Else if BaseE is a MemberExpr (e.g., adc->thresholds),\
  \ retrieve the FieldDecl* FD = cast<FieldDecl>(ME->getMemberDecl()), then get its\
  \ type QualType FT = FD->getType(); if FT is ConstantArrayType, obtain its size\
  \ via cast<ConstantArrayType>(FT.getTypePtr())->getSize().\n    - If neither yields\
  \ a constant array size, skip this ASE (we only warn on known sizes).\n  - Compare\
  \ the array size (APInt) and the bound (APSInt). Normalize bit-width/sign and compare\
  \ numerically. If equal, this is the precise \u201Coff-by-one\u201D case we want.\n\
  \nStep 4.5: Report the bug\n- Once a matching ASE is found, emit one report per\
  \ IfStmt (avoid duplicates for multiple uses).\n- Preferred report location: the\
  \ comparison operator inside the If condition (the BO_GT/BO_LT node). If unavailable,\
  \ use If->getIfLoc().\n- Message (short and clear):\n  - \u201COff-by-one bound\
  \ check: \u2018> MAX\u2019 allows idx == MAX; use \u2018>= MAX\u2019.\u201D\n- Use\
  \ a BasicBugReport with a custom BugType or a PathSensitiveBugReport is fine, but\
  \ BasicBugReport is sufficient in checkASTCodeBody.\n\n5) Heuristics and corner\
  \ cases\n- Logical-OR conditions: It is common to see \u201Cif (idx > MAX || other_check)\
  \ return -EINVAL;\u201D. Only the strict upper bound part matters; accept this form.\n\
  - Reversed comparison: Support both idx > MAX and MAX < idx. Do not flag non-strict\
  \ or unrelated comparisons.\n- Multiple arrays: If multiple arrays indexed by the\
  \ same idx exist, warn as soon as you find one whose size equals MAX. Do not spam\
  \ multiple reports per If; one is enough.\n- Reduce false positives: Require an\
  \ early return inside the then-branch. Also require both bound and array size to\
  \ be compile-time constants and equal.\n\n6) Utility functions to use\n- EvaluateExprToInt\
  \ for extracting the integer value of \u201CMAX\u201D from the condition.\n- findSpecificTypeInChildren<ReturnStmt>\
  \ to verify early-return guard.\n- getArraySizeFromExpr for DeclRefExpr base arrays.\n\
  - For MemberExpr bases, inspect the FieldDecl\u2019s type and check for ConstantArrayType.\n\
  - ExprHasName can be used optionally to further reduce noise (e.g., if you want\
  \ to check that the base array or idx name matches a pattern), but is not required.\n\
  \n7) Optional extension (not necessary for the simplest working checker)\n- Support\
  \ check::BranchCondition in addition to checkASTCodeBody:\n  - Detect the strict\
  \ upper bound guard in checkBranchCondition, store a lightweight \u201Ccandidate\u201D\
  \ tuple (IdxVarDecl*, BoundValue, IfStmtLoc) in a function-scoped vector (no ProgramState).\n\
  \  - Still do the array subscript scan and reporting in checkASTCodeBody using the\
  \ collected candidates.\n- This can improve modularity but is not required for correctness.\n\
  \nThis plan yields a simple, robust checker that flags the precise bug pattern:\
  \ guarding an index with \u201C> MAX\u201D (strict) and later indexing arrays sized\
  \ exactly MAX, which allows idx == MAX to slip through and cause out-of-bounds access."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"clang/Basic/SourceManager.h\"\n#include \"llvm/ADT/APInt.h\"\n#include\
  \ \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/Support/Casting.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states are necessary.\n\nnamespace {\n\n/* The checker callbacks\
  \ are to be decided. */\nclass SAGenTestChecker : public Checker<check::ASTCodeBody>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Off-by-one bounds check\", \"Logic error\")) {}\n\n \
  \     void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter &BR)\
  \ const;\n\n   private:\n\n      // Find a strict upper bound comparison inside\
  \ Cond of the form:\n      //   idx > MAX   or   MAX < idx\n      // Returns true\
  \ and fills OutIdxVar, OutBound, OutOp if found.\n      bool findStrictUpperBound(const\
  \ Expr *Cond,\n                                const VarDecl *&OutIdxVar,\n    \
  \                            llvm::APSInt &OutBound,\n                         \
  \       const BinaryOperator *&OutOp,\n                                ASTContext\
  \ &AC) const;\n\n      // Analyze a single IfStmt:\n      //  - must have early\
  \ return in then-branch\n      //  - must contain strict upper bound check on an\
  \ index\n      //  - later array subscript with same index into array of size ==\
  \ bound\n      void analyzeIfStmt(const IfStmt *IfS,\n                         const\
  \ Stmt *FuncBody,\n                         ASTContext &AC,\n                  \
  \       AnalysisManager &Mgr,\n                         BugReporter &BR) const;\n\
  \n      // Recursively visit all IfStmts in function body.\n      void visitIfs(const\
  \ Stmt *S,\n                    const Stmt *FuncBody,\n                    ASTContext\
  \ &AC,\n                    AnalysisManager &Mgr,\n                    BugReporter\
  \ &BR) const;\n\n      // Extract constant array size from base expression of an\
  \ array access.\n      bool getArraySizeFromBaseExpr(const Expr *BaseE, llvm::APInt\
  \ &ArraySize) const;\n\n      // Check whether expression E refers to the same variable\
  \ Var (DeclRefExpr).\n      bool isExprRefToVar(const Expr *E, const VarDecl *Var)\
  \ const;\n};\n\nbool SAGenTestChecker::isExprRefToVar(const Expr *E, const VarDecl\
  \ *Var) const {\n  if (!E || !Var) return false;\n  const Expr *IE = E->IgnoreParenImpCasts();\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(IE)) {\n    if (const auto *VD =\
  \ dyn_cast<VarDecl>(DRE->getDecl()))\n      return VD == Var;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::getArraySizeFromBaseExpr(const Expr *BaseE, llvm::APInt\
  \ &ArraySize) const {\n  if (!BaseE) return false;\n  const Expr *BE = BaseE->IgnoreParenImpCasts();\n\
  \n  // Case 1: DeclRefExpr to a VarDecl with constant array type\n  if (const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(BE)) {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n      QualType QT = VD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr()))\
  \ {\n        ArraySize = CAT->getSize();\n        return true;\n      }\n    }\n\
  \  }\n\n  // Case 2: MemberExpr to a FieldDecl with constant array type (e.g., adc->thresholds[...])\n\
  \  if (const auto *ME = dyn_cast<MemberExpr>(BE)) {\n    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl()))\
  \ {\n      QualType FT = FD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(FT.getTypePtr()))\
  \ {\n        ArraySize = CAT->getSize();\n        return true;\n      }\n    }\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::findStrictUpperBound(const\
  \ Expr *Cond,\n                                            const VarDecl *&OutIdxVar,\n\
  \                                            llvm::APSInt &OutBound,\n         \
  \                                   const BinaryOperator *&OutOp,\n            \
  \                                ASTContext &AC) const {\n  if (!Cond) return false;\n\
  \  const Expr *E = Cond->IgnoreParenImpCasts();\n\n  if (const auto *BO = dyn_cast<BinaryOperator>(E))\
  \ {\n    // Direct match: idx > MAX\n    if (BO->getOpcode() == BO_GT) {\n     \
  \ const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n      const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n\
  \n      if (const auto *LDRE = dyn_cast<DeclRefExpr>(L)) {\n        if (const auto\
  \ *VD = dyn_cast<VarDecl>(LDRE->getDecl())) {\n          Expr::EvalResult ER;\n\
  \          if (R->EvaluateAsInt(ER, AC)) {\n            OutIdxVar = VD;\n      \
  \      OutBound = ER.Val.getInt();\n            OutOp = BO;\n            return\
  \ true;\n          }\n        }\n      }\n    }\n\n    // Direct match: MAX < idx\n\
  \    if (BO->getOpcode() == BO_LT) {\n      const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n\n      Expr::EvalResult\
  \ ER;\n      if (L->EvaluateAsInt(ER, AC)) {\n        if (const auto *RDRE = dyn_cast<DeclRefExpr>(R))\
  \ {\n          if (const auto *VD = dyn_cast<VarDecl>(RDRE->getDecl())) {\n    \
  \        OutIdxVar = VD;\n            OutBound = ER.Val.getInt();\n            OutOp\
  \ = BO;\n            return true;\n          }\n        }\n      }\n    }\n\n  \
  \  // Otherwise, recurse into both sides (handles logical ops like ||, &&, etc.)\n\
  \    if (findStrictUpperBound(BO->getLHS(), OutIdxVar, OutBound, OutOp, AC))\n \
  \     return true;\n    if (findStrictUpperBound(BO->getRHS(), OutIdxVar, OutBound,\
  \ OutOp, AC))\n      return true;\n\n    return false;\n  }\n\n  // Generic recursion\
  \ over children for other expression kinds.\n  for (const Stmt *Child : E->children())\
  \ {\n    if (const auto *CE = dyn_cast_or_null<Expr>(Child)) {\n      if (findStrictUpperBound(CE,\
  \ OutIdxVar, OutBound, OutOp, AC))\n        return true;\n    }\n  }\n\n  return\
  \ false;\n}\n\nvoid SAGenTestChecker::analyzeIfStmt(const IfStmt *IfS,\n       \
  \                              const Stmt *FuncBody,\n                         \
  \            ASTContext &AC,\n                                     AnalysisManager\
  \ &Mgr,\n                                     BugReporter &BR) const {\n  if (!IfS\
  \ || !FuncBody) return;\n\n  // Heuristic: require early return in the 'then' branch\n\
  \  const Stmt *ThenS = IfS->getThen();\n  if (!ThenS)\n    return;\n\n  // Use the\
  \ provided utility to find ReturnStmt in 'then'\n  const ReturnStmt *RetInThen =\
  \ findSpecificTypeInChildren<ReturnStmt>(ThenS);\n  if (!RetInThen)\n    return;\n\
  \n  // Find the strict upper bound in the condition\n  const VarDecl *IdxVar = nullptr;\n\
  \  llvm::APSInt Bound;\n  const BinaryOperator *OpNode = nullptr;\n\n  const Expr\
  \ *Cond = IfS->getCond();\n  if (!Cond)\n    return;\n\n  if (!findStrictUpperBound(Cond,\
  \ IdxVar, Bound, OpNode, AC))\n    return;\n\n  // After the IfStmt, look for array\
  \ subscripts A[IdxVar]\n  const SourceManager &SM = Mgr.getSourceManager();\n  SourceLocation\
  \ IfLoc = SM.getFileLoc(IfS->getIfLoc());\n\n  // Traverse function body and search\
  \ for ArraySubscriptExpr after IfLoc\n  bool Reported = false;\n\n  std::function<void(const\
  \ Stmt *)> Walker = [&](const Stmt *S) {\n    if (!S || Reported) return;\n\n  \
  \  // Check for array subscript\n    if (const auto *ASE = dyn_cast<ArraySubscriptExpr>(S))\
  \ {\n      SourceLocation ASELoc = SM.getFileLoc(ASE->getExprLoc());\n      if (SM.isBeforeInTranslationUnit(IfLoc,\
  \ ASELoc)) {\n        // Index should reference the same variable\n        const\
  \ Expr *IdxE = ASE->getIdx();\n        if (isExprRefToVar(IdxE, IdxVar)) {\n   \
  \       // Determine array size from base expression\n          llvm::APInt ArrSize;\n\
  \          if (getArraySizeFromBaseExpr(ASE->getBase(), ArrSize)) {\n          \
  \  // Compare ArrSize with Bound\n            uint64_t ArrVal = ArrSize.getLimitedValue(UINT64_MAX);\n\
  \            uint64_t BoundVal = Bound.isSigned()\n                            \
  \        ? static_cast<uint64_t>(static_cast<int64_t>(Bound.getSExtValue()))\n \
  \                                   : Bound.getZExtValue();\n\n            if (ArrVal\
  \ == BoundVal) {\n              // Off-by-one: using '>' or '<' allows idx == MAX;\
  \ should use '>=' or '<=' respectively.\n              SourceLocation Loc = OpNode\
  \ ? OpNode->getOperatorLoc() : IfS->getIfLoc();\n              auto R = std::make_unique<BasicBugReport>(\n\
  \                  *BT,\n                  \"Off-by-one bound check: '>' allows\
  \ index == bound; use '>='\",\n                  PathDiagnosticLocation(Loc, BR.getSourceManager()));\n\
  \              R->addRange(OpNode ? OpNode->getSourceRange() : IfS->getSourceRange());\n\
  \              BR.emitReport(std::move(R));\n              Reported = true;\n  \
  \            return;\n            }\n          }\n        }\n      }\n    }\n\n\
  \    for (const Stmt *Child : S->children())\n      Walker(Child);\n  };\n\n  Walker(FuncBody);\n\
  }\n\nvoid SAGenTestChecker::visitIfs(const Stmt *S,\n                          \
  \      const Stmt *FuncBody,\n                                ASTContext &AC,\n\
  \                                AnalysisManager &Mgr,\n                       \
  \         BugReporter &BR) const {\n  if (!S) return;\n\n  if (const auto *IfS =\
  \ dyn_cast<IfStmt>(S))\n    analyzeIfStmt(IfS, FuncBody, AC, Mgr, BR);\n\n  for\
  \ (const Stmt *Child : S->children())\n    visitIfs(Child, FuncBody, AC, Mgr, BR);\n\
  }\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager &Mgr,\
  \ BugReporter &BR) const {\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!FD)\n    return;\n\n  const Stmt *Body = FD->getBody();\n  if (!Body)\n\
  \    return;\n\n  ASTContext &AC = Mgr.getASTContext();\n  visitIfs(Body, Body,\
  \ AC, Mgr, BR);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects off-by-one array index checks that use '>' instead of '>=' when\
  \ guarding array accesses\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
