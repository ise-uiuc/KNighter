_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 1f886a7bfb3faf4c1021e73f045538008ce7634e
commit_type: Null-Pointer-Dereference
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include \"llvm/ADT/SmallPtrSet.h\"\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// Program state customizations\nREGISTER_SET_WITH_PROGRAMSTATE(DevmMaybeNullSyms,\
  \ SymbolRef)\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrStatusMap, const MemRegion*, bool)\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*, const MemRegion*)\n\
  \nnamespace {\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\
  \ : public Checker<check::PostCall,\n                                        check::Bind,\n\
  \                                        check::BranchCondition,\n             \
  \                           check::Location> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Possible\
  \ NULL dereference (devm_kzalloc result)\", \"Memory error\")) {}\n\n      void\
  \ checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n      void checkLocation(SVal Loc,\
  \ bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\n   private:\n\n     \
  \ // Self-defined helpers\n      bool isDevmKzalloc(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\n      const MemRegion *canonical(const MemRegion *R, ProgramStateRef\
  \ State) const;\n\n      ProgramStateRef markUnchecked(ProgramStateRef State, const\
  \ MemRegion *R) const;\n      ProgramStateRef markChecked(ProgramStateRef State,\
  \ const MemRegion *R) const;\n\n      bool isCheckedOrAliasedChecked(ProgramStateRef\
  \ State, const MemRegion *R) const;\n      bool isExplicitlyUnchecked(ProgramStateRef\
  \ State, const MemRegion *R) const;\n\n      // Try to extract the pointer expression\
  \ being checked in a condition.\n      const Expr *getCheckedPtrExprFromCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n      void reportDerefWithoutCheck(const\
  \ Stmt *S, CheckerContext &C) const;\n};\n\n// Helper: match devm_kzalloc by callee\
  \ name using source text\nbool SAGenTestChecker::isDevmKzalloc(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n  if\
  \ (!Origin)\n    return false;\n  return ExprHasName(Origin, \"devm_kzalloc\", C);\n\
  }\n\nconst MemRegion *SAGenTestChecker::canonical(const MemRegion *R, ProgramStateRef\
  \ State) const {\n  if (!R)\n    return nullptr;\n  const MemRegion *Cur = R->getBaseRegion();\n\
  \  llvm::SmallPtrSet<const MemRegion*, 8> Visited;\n  while (Cur) {\n    if (!Visited.insert(Cur).second)\n\
  \      break; // cycle protection\n    const MemRegion *Next = State->get<PtrAliasMap>(Cur);\n\
  \    if (!Next)\n      break;\n    Cur = Next->getBaseRegion();\n  }\n  return Cur\
  \ ? Cur->getBaseRegion() : nullptr;\n}\n\nProgramStateRef SAGenTestChecker::markUnchecked(ProgramStateRef\
  \ State, const MemRegion *R) const {\n  if (!R)\n    return State;\n  const MemRegion\
  \ *Base = R->getBaseRegion();\n  const MemRegion *Root = canonical(Base, State);\n\
  \  if (!Root)\n    Root = Base;\n  State = State->set<PtrStatusMap>(Base, false);\n\
  \  State = State->set<PtrStatusMap>(Root, false);\n  return State;\n}\n\nProgramStateRef\
  \ SAGenTestChecker::markChecked(ProgramStateRef State, const MemRegion *R) const\
  \ {\n  if (!R)\n    return State;\n  const MemRegion *Base = R->getBaseRegion();\n\
  \  const MemRegion *Root = canonical(Base, State);\n  if (!Root)\n    Root = Base;\n\
  \  State = State->set<PtrStatusMap>(Base, true);\n  State = State->set<PtrStatusMap>(Root,\
  \ true);\n  return State;\n}\n\nbool SAGenTestChecker::isCheckedOrAliasedChecked(ProgramStateRef\
  \ State, const MemRegion *R) const {\n  if (!R)\n    return false;\n  const MemRegion\
  \ *Base = R->getBaseRegion();\n  const bool *CheckedBase = State->get<PtrStatusMap>(Base);\n\
  \  if (CheckedBase && *CheckedBase)\n    return true;\n  const MemRegion *Root =\
  \ canonical(Base, State);\n  if (Root) {\n    const bool *CheckedRoot = State->get<PtrStatusMap>(Root);\n\
  \    if (CheckedRoot && *CheckedRoot)\n      return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isExplicitlyUnchecked(ProgramStateRef State, const MemRegion\
  \ *R) const {\n  if (!R)\n    return false;\n  const MemRegion *Base = R->getBaseRegion();\n\
  \  const bool *CheckedBase = State->get<PtrStatusMap>(Base);\n  if (CheckedBase\
  \ && !*CheckedBase)\n    return true;\n  const MemRegion *Root = canonical(Base,\
  \ State);\n  if (Root) {\n    const bool *CheckedRoot = State->get<PtrStatusMap>(Root);\n\
  \    if (CheckedRoot && !*CheckedRoot)\n      return true;\n  }\n  return false;\n\
  }\n\nconst Expr *SAGenTestChecker::getCheckedPtrExprFromCondition(const Stmt *Condition,\
  \ CheckerContext &C) const {\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE)\n    return nullptr;\n\n  // Pattern 1: if (!ptr)\n  if (const auto\
  \ *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if (UO->getOpcode() == UO_LNot) {\n\
  \      return UO->getSubExpr(); // do not strip implicit casts per guideline\n \
  \   }\n  }\n\n  // Pattern 2: if (ptr == NULL) or if (ptr != NULL)\n  if (const\
  \ auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    BinaryOperator::Opcode Op =\
  \ BO->getOpcode();\n    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr *LHS\
  \ = BO->getLHS();\n      const Expr *RHS = BO->getRHS();\n      bool LHSIsNull =\
  \ LHS->isNullPointerConstant(C.getASTContext(),\n                              \
  \                    Expr::NPC_ValueDependentIsNull);\n      bool RHSIsNull = RHS->isNullPointerConstant(C.getASTContext(),\n\
  \                                                  Expr::NPC_ValueDependentIsNull);\n\
  \      if (LHSIsNull && !RHSIsNull)\n        return RHS;\n      if (RHSIsNull &&\
  \ !LHSIsNull)\n        return LHS;\n    }\n  }\n\n  // Pattern 3: if (ptr)\n  //\
  \ Treat the whole condition as pointer expression.\n  return CondE;\n}\n\nvoid SAGenTestChecker::reportDerefWithoutCheck(const\
  \ Stmt *S, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Dereference of devm_kzalloc() result without NULL check\", N);\n \
  \ if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// PostCall: remember devm_kzalloc return symbol as maybe-null\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isDevmKzalloc(Call, C))\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  SVal Ret = Call.getReturnValue();\n\
  \  if (SymbolRef Sym = Ret.getAsSymbol()) {\n    State = State->add<DevmMaybeNullSyms>(Sym);\n\
  \    C.addTransition(State);\n  }\n}\n\n// Bind: mark LHS as unchecked when bound\
  \ from devm_kzalloc return,\n// and track pointer aliasing.\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\n\
  \    return;\n  LHSReg = LHSReg->getBaseRegion();\n  if (!LHSReg)\n    return;\n\
  \n  // Case 1: Binding devm_kzalloc's return symbol to a region => mark unchecked\n\
  \  if (SymbolRef Sym = Val.getAsSymbol()) {\n    if (State->contains<DevmMaybeNullSyms>(Sym))\
  \ {\n      State = markUnchecked(State, LHSReg);\n      State = State->remove<DevmMaybeNullSyms>(Sym);\n\
  \      C.addTransition(State);\n      return;\n    }\n  }\n\n  // Case 2: Track\
  \ aliases when assigning one pointer region to another.\n  if (const MemRegion *RHSReg\
  \ = Val.getAsRegion()) {\n    RHSReg = RHSReg->getBaseRegion();\n    if (RHSReg)\
  \ {\n      const MemRegion *Root = canonical(RHSReg, State);\n      if (!Root)\n\
  \        Root = RHSReg;\n      // Map both sides to the same canonical root to avoid\
  \ cycles and\n      // allow checks to propagate.\n      State = State->set<PtrAliasMap>(LHSReg,\
  \ Root);\n      State = State->set<PtrAliasMap>(RHSReg, Root);\n      C.addTransition(State);\n\
  \    }\n  }\n}\n\n// BranchCondition: mark pointers as checked when we see a NULL-check\n\
  void SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  const Expr *CheckedExpr\
  \ = getCheckedPtrExprFromCondition(Condition, C);\n  if (!CheckedExpr) {\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  const MemRegion *MR = getMemRegionFromExpr(CheckedExpr, C);\n\
  \  if (MR) {\n    MR = MR->getBaseRegion();\n    if (MR) {\n      State = markChecked(State,\
  \ MR);\n      C.addTransition(State);\n      return;\n    }\n  }\n\n  C.addTransition(State);\n\
  }\n\n// Location: detect actual dereference via '->' or '*' and warn if unchecked.\n\
  void SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const Expr *BaseExpr\
  \ = nullptr;\n\n  // Try to find MemberExpr with '->'\n  const MemberExpr *ME =\
  \ dyn_cast_or_null<MemberExpr>(S);\n  if (!ME)\n    ME = findSpecificTypeInParents<MemberExpr>(S,\
  \ C);\n  if (ME && ME->isArrow()) {\n    BaseExpr = ME->getBase();\n  } else {\n\
  \    // Try to find UnaryOperator '*'\n    const UnaryOperator *UO = dyn_cast_or_null<UnaryOperator>(S);\n\
  \    if (!UO)\n      UO = findSpecificTypeInParents<UnaryOperator>(S, C);\n    if\
  \ (UO && UO->getOpcode() == UO_Deref) {\n      BaseExpr = UO->getSubExpr();\n  \
  \  }\n  }\n\n  if (!BaseExpr)\n    return;\n\n  // First, if base is a symbol returned\
  \ by devm_kzalloc and still not stored, warn.\n  SVal BaseVal = State->getSVal(BaseExpr,\
  \ C.getLocationContext());\n  if (SymbolRef Sym = BaseVal.getAsSymbol()) {\n   \
  \ if (State->contains<DevmMaybeNullSyms>(Sym)) {\n      reportDerefWithoutCheck(S,\
  \ C);\n      return;\n    }\n  }\n\n  const MemRegion *MR = getMemRegionFromExpr(BaseExpr,\
  \ C);\n  if (!MR)\n    return;\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  if (isCheckedOrAliasedChecked(State, MR))\n    return;\n\n  if (isExplicitlyUnchecked(State,\
  \ MR)) {\n    reportDerefWithoutCheck(S, C);\n    return;\n  }\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects dereference of devm_kzalloc result without NULL check\",\n  \
  \    \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n \
  \   CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nspi: mchp-pci1xxx: Fix a possible null pointer dereference\
  \ in pci1xxx_spi_probe\n\nIn function pci1xxxx_spi_probe, there is a potential null\
  \ pointer that\nmay be caused by a failed memory allocation by the function devm_kzalloc.\n\
  Hence, a null pointer check needs to be added to prevent null pointer\ndereferencing\
  \ later in the code.\n\nTo fix this issue, spi_bus->spi_int[iter] should be checked.\
  \ The memory\nallocated by devm_kzalloc will be automatically released, so just\
  \ directly\nreturn -ENOMEM without worrying about memory leaks.\n\nFixes: 1cc0cbea7167\
  \ (\"spi: microchip: pci1xxxx: Add driver for SPI controller of PCI1XXXX PCIe switch\"\
  )\nSigned-off-by: Huai-Yuan Liu <qq810974084@gmail.com>\nLink: https://msgid.link/r/20240403014221.969801-1-qq810974084@gmail.com\n\
  Signed-off-by: Mark Brown <broonie@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ pci1xxxx_spi_probe in drivers/spi/spi-pci1xxxx.c\nstatic int pci1xxxx_spi_probe(struct\
  \ pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tu8 hw_inst_cnt, iter, start,\
  \ only_sec_inst;\n\tstruct pci1xxxx_spi_internal *spi_sub_ptr;\n\tstruct device\
  \ *dev = &pdev->dev;\n\tstruct pci1xxxx_spi *spi_bus;\n\tstruct spi_controller *spi_host;\n\
  \tu32 regval;\n\tint ret;\n\n\thw_inst_cnt = ent->driver_data & 0x0f;\n\tstart =\
  \ (ent->driver_data & 0xf0) >> 4;\n\tif (start == 1)\n\t\tonly_sec_inst = 1;\n\t\
  else\n\t\tonly_sec_inst = 0;\n\n\tspi_bus = devm_kzalloc(&pdev->dev,\n\t\t\t   \
  \    struct_size(spi_bus, spi_int, hw_inst_cnt),\n\t\t\t       GFP_KERNEL);\n\t\
  if (!spi_bus)\n\t\treturn -ENOMEM;\n\n\tspi_bus->dev = pdev;\n\tspi_bus->total_hw_instances\
  \ = hw_inst_cnt;\n\tpci_set_master(pdev);\n\n\tfor (iter = 0; iter < hw_inst_cnt;\
  \ iter++) {\n\t\tspi_bus->spi_int[iter] = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t\t\
  \      sizeof(struct pci1xxxx_spi_internal),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\
  \tspi_sub_ptr = spi_bus->spi_int[iter];\n\t\tspi_sub_ptr->spi_host = devm_spi_alloc_host(dev,\
  \ sizeof(struct spi_controller));\n\t\tif (!spi_sub_ptr->spi_host)\n\t\t\treturn\
  \ -ENOMEM;\n\n\t\tspi_sub_ptr->parent = spi_bus;\n\t\tspi_sub_ptr->spi_xfer_in_progress\
  \ = false;\n\n\t\tif (!iter) {\n\t\t\tret = pcim_enable_device(pdev);\n\t\t\tif\
  \ (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tret = pci_request_regions(pdev, DRV_NAME);\n\
  \t\t\tif (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tspi_bus->reg_base = pcim_iomap(pdev,\
  \ 0, pci_resource_len(pdev, 0));\n\t\t\tif (!spi_bus->reg_base) {\n\t\t\t\tret =\
  \ -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret = pci_alloc_irq_vectors(pdev,\
  \ hw_inst_cnt, hw_inst_cnt,\n\t\t\t\t\t\t    PCI_IRQ_ALL_TYPES);\n\t\t\tif (ret\
  \ < 0) {\n\t\t\t\tdev_err(&pdev->dev, \"Error allocating MSI vectors\\n\");\n\t\t\
  \t\tgoto error;\n\t\t\t}\n\n\t\t\tinit_completion(&spi_sub_ptr->spi_xfer_done);\n\
  \t\t\t/* Initialize Interrupts - SPI_INT */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ +\n\t\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\t\
  regval &= ~SPI_INTR;\n\t\t\twritel(regval, spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\
  \t\t\tspi_sub_ptr->irq = pci_irq_vector(pdev, 0);\n\n\t\t\tret = devm_request_irq(&pdev->dev,\
  \ spi_sub_ptr->irq,\n\t\t\t\t\t       pci1xxxx_spi_isr, PCI1XXXX_IRQ_FLAGS,\n\t\t\
  \t\t\t       pci_name(pdev), spi_sub_ptr);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev,\
  \ \"Unable to request irq : %d\",\n\t\t\t\t\tspi_sub_ptr->irq);\n\t\t\t\tret = -ENODEV;\n\
  \t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret = pci1xxxx_spi_dma_init(spi_bus, spi_sub_ptr->irq);\n\
  \t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\tgoto error;\n\n\t\t\t/* This register\
  \ is only applicable for 1st instance */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ + SPI_PCI_CTRL_REG_OFFSET(0));\n\t\t\tif (!only_sec_inst)\n\t\t\t\tregval |= (BIT(4));\n\
  \t\t\telse\n\t\t\t\tregval &= ~(BIT(4));\n\n\t\t\twritel(regval, spi_bus->reg_base\
  \ + SPI_PCI_CTRL_REG_OFFSET(0));\n\t\t}\n\n\t\tspi_sub_ptr->hw_inst = start++;\n\
  \n\t\tif (iter == 1) {\n\t\t\tinit_completion(&spi_sub_ptr->spi_xfer_done);\n\t\t\
  \t/* Initialize Interrupts - SPI_INT */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\t\
  regval &= ~SPI_INTR;\n\t\t\twritel(regval, spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\
  \t\t\tspi_sub_ptr->irq = pci_irq_vector(pdev, iter);\n\t\t\tret = devm_request_irq(&pdev->dev,\
  \ spi_sub_ptr->irq,\n\t\t\t\t\t       pci1xxxx_spi_isr, PCI1XXXX_IRQ_FLAGS,\n\t\t\
  \t\t\t       pci_name(pdev), spi_sub_ptr);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev,\
  \ \"Unable to request irq : %d\",\n\t\t\t\t\tspi_sub_ptr->irq);\n\t\t\t\tret = -ENODEV;\n\
  \t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tspi_host = spi_sub_ptr->spi_host;\n\t\
  \tspi_host->num_chipselect = SPI_CHIP_SEL_COUNT;\n\t\tspi_host->mode_bits = SPI_MODE_0\
  \ | SPI_MODE_3 | SPI_RX_DUAL |\n\t\t\t\t      SPI_TX_DUAL | SPI_LOOP;\n\t\tspi_host->can_dma\
  \ = pci1xxxx_spi_can_dma;\n\t\tspi_host->transfer_one = pci1xxxx_spi_transfer_one;\n\
  \n\t\tspi_host->set_cs = pci1xxxx_spi_set_cs;\n\t\tspi_host->bits_per_word_mask\
  \ = SPI_BPW_MASK(8);\n\t\tspi_host->max_speed_hz = PCI1XXXX_SPI_MAX_CLOCK_HZ;\n\t\
  \tspi_host->min_speed_hz = PCI1XXXX_SPI_MIN_CLOCK_HZ;\n\t\tspi_host->flags = SPI_CONTROLLER_MUST_TX;\n\
  \t\tspi_controller_set_devdata(spi_host, spi_sub_ptr);\n\t\tret = devm_spi_register_controller(dev,\
  \ spi_host);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\tpci_set_drvdata(pdev, spi_bus);\n\
  \n\treturn 0;\n\nerror:\n\tpci_release_regions(pdev);\n\treturn ret;\n}\n```\n\n\
  ## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/spi/spi-pci1xxxx.c b/drivers/spi/spi-pci1xxxx.c\n\
  index 969965d7bc98..cc18d320370f 100644\n--- a/drivers/spi/spi-pci1xxxx.c\n+++ b/drivers/spi/spi-pci1xxxx.c\n\
  @@ -725,6 +725,8 @@ static int pci1xxxx_spi_probe(struct pci_dev *pdev, const struct\
  \ pci_device_id *\n \t\tspi_bus->spi_int[iter] = devm_kzalloc(&pdev->dev,\n \t\t\
  \t\t\t\t      sizeof(struct pci1xxxx_spi_internal),\n \t\t\t\t\t\t      GFP_KERNEL);\n\
  +\t\tif (!spi_bus->spi_int[iter])\n+\t\t\treturn -ENOMEM;\n \t\tspi_sub_ptr = spi_bus->spi_int[iter];\n\
  \ \t\tspi_sub_ptr->spi_host = devm_spi_alloc_host(dev, sizeof(struct spi_controller));\n\
  \ \t\tif (!spi_sub_ptr->spi_host)\n```\n"
pattern: '## Bug Pattern


  Dereferencing the result of devm_kzalloc() without checking for NULL. In a probe/init
  loop, a per-instance structure is allocated and immediately used via an alias, leading
  to a potential NULL pointer dereference if the allocation fails.


  Example pattern:

  - ptr_array[i] = devm_kzalloc(dev, sizeof(*ptr_array[i]), GFP_KERNEL);

  - ptr = ptr_array[i];

  - ptr->field = ...;  // BUG: ptr may be NULL


  Correct pattern requires:

  - Check if ptr_array[i] (or ptr) is NULL before any dereference, and return an error
  (e.g., -ENOMEM) on failure.'
plan: "Plan to detect \u201Cdereference of devm_kzalloc() result without NULL check\u201D\
  \n\n1) Program State Customization\n- REGISTER_SET_WITH_PROGRAMSTATE(DevmMaybeNullSyms,\
  \ SymbolRef)\n  - Tracks return symbols of devm_kzalloc calls that may be NULL.\n\
  - REGISTER_MAP_WITH_PROGRAMSTATE(PtrStatusMap, const MemRegion*, bool)\n  - Tracks\
  \ whether a pointer (by MemRegion) has been NULL-checked.\n  - false: requires NULL\
  \ check (unchecked); true: already checked.\n- REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap,\
  \ const MemRegion*, const MemRegion*)\n  - Tracks pointer aliases, e.g., p2 = p1\
  \ and p = arr[i].\n  - Maps LHS region to the canonical RHS region.\n\nHelper utilities\
  \ (internal to the checker):\n- bool isDevmKzalloc(const CallEvent &Call)\n  - Matches\
  \ callee name exactly to \"devm_kzalloc\".\n- const MemRegion *canonical(const MemRegion\
  \ *R, ProgramStateRef State)\n  - Follows PtrAliasMap (R -> \u2026 -> root) until\
  \ unmapped, returns root.\n- void markUnchecked(ProgramStateRef State, const MemRegion\
  \ *R)\n  - Set PtrStatusMap[R] = false (unchecked).\n- void markChecked(ProgramStateRef\
  \ State, const MemRegion *R)\n  - Set PtrStatusMap[R] = true (checked).\n- bool\
  \ isCheckedOrAliasedChecked(ProgramStateRef State, const MemRegion *R)\n  - Returns\
  \ true if PtrStatusMap[R] == true OR PtrStatusMap[canonical(R)] == true.\n- bool\
  \ isExplicitlyUnchecked(ProgramStateRef State, const MemRegion *R)\n  - Returns\
  \ true if PtrStatusMap[R] == false OR PtrStatusMap[canonical(R)] == false.\n\n2)\
  \ Callback Choices and Detailed Steps\n\nA) checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C)\n- Goal: Capture return values of devm_kzalloc as \u201Cmaybe\
  \ NULL\u201D.\n- Steps:\n  - If !isDevmKzalloc(Call), return.\n  - Get return SVal:\
  \ SVal Ret = Call.getReturnValue();\n  - If Ret has a SymbolRef (Ret.getAsSymbol()),\
  \ insert it into DevmMaybeNullSyms.\n  - Do not immediately mark any region; propagation\
  \ to a concrete region happens in checkBind when this symbol is bound to a location.\n\
  \nB) checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C)\n- Goal: (1)\
  \ Mark recipients of devm_kzalloc return as unchecked; (2) Track pointer aliases.\n\
  - Steps:\n  - Get LHS region from Loc (Loc.castAs<loc::MemRegionVal>().getRegion()).\n\
  \  - If Val contains a symbol and that symbol is in DevmMaybeNullSyms:\n    - Mark\
  \ LHS region as unchecked: markUnchecked(State, LHSRegion).\n    - Optionally erase\
  \ the symbol from DevmMaybeNullSyms to avoid unbounded growth (not required for\
  \ correctness).\n  - Else, if this is a pointer-to-pointer binding (RHS has a MemRegion):\n\
  \    - Extract RHS region with Val.getAsRegion().\n    - If both LHS and RHS are\
  \ pointer-typed, record alias:\n      - PtrAliasMap[LHSRegion] = canonical(RHSRegion).\n\
  \    - Do not alter PtrStatusMap here (status propagates via canonical lookup).\n\
  \  - Special: For bindings to array elements or struct fields (e.g., arr[i] = devm_kzalloc(...)),\
  \ LHSRegion will be an ElementRegion/FieldRegion; markUnchecked on that region as\
  \ above.\n\nC) checkBranchCondition(const Stmt *Condition, CheckerContext &C)\n\
  - Goal: Mark pointers as \u201Cchecked\u201D when a NULL check is performed.\n-\
  \ Recognize these patterns and extract the checked expression E:\n  - if (ptr) or\
  \ if (!ptr): handle ImplicitCastExpr of pointer or UnaryOperator (!).\n  - if (ptr\
  \ == NULL) or if (ptr != NULL): BinaryOperator with EQ/NE where one side is a null\
  \ literal.\n- Steps:\n  - From Condition AST, locate the pointer expression E being\
  \ tested.\n    - For UnaryOperator(!), use getSubExpr().\n    - For BinaryOperator(==/!=),\
  \ identify the non-null side as E.\n    - For a plain pointer-as-condition, E =\
  \ Condition expr.\n  - Get MemRegion* R via getMemRegionFromExpr(E, C).\n  - If\
  \ R is non-null, markChecked(State, R).\n    - We do not need to differentiate then/else\
  \ branches; the existence of a check is sufficient for this checker\u2019s purpose.\n\
  \  - No need to walk aliases here; deref check will consult both R and canonical(R).\n\
  \nD) checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C)\n- Goal:\
  \ Report dereferences of unchecked devm_kzalloc results through either direct dereference\
  \ (*) or pointer-to-struct access (->).\n- Identify deref base:\n  - If S is a MemberExpr\
  \ with isArrow() == true:\n    - Base expression E = MemberExpr->getBase();\n  -\
  \ Else if S is a UnaryOperator with opcode UO_Deref (\u2018*\u2019):\n    - Base\
  \ expression E = UnaryOperator->getSubExpr();\n  - Otherwise, return (not a pointer\
  \ deref site we care about).\n- Steps:\n  - Get MemRegion* Rexpr = getMemRegionFromExpr(E,\
  \ C).\n  - If Rexpr is null, return.\n  - Compute Rcanon = canonical(Rexpr, State).\n\
  \  - Decide:\n    - If isCheckedOrAliasedChecked(State, Rexpr) => OK, return.\n\
  \    - Else if isExplicitlyUnchecked(State, Rexpr) => this is a deref of a devm_kzalloc\
  \ result without a prior NULL check; report a bug.\n      - Create a non-fatal error\
  \ node and emit a PathSensitiveBugReport:\n        - Short message: \"Dereference\
  \ of devm_kzalloc() result without NULL check\".\n      - Optionally markChecked(State,\
  \ Rexpr) after reporting to avoid duplicate reports on subsequent derefs of the\
  \ same pointer.\n\nE) Optional: checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C)\n- Not mandatory for this pattern.\n- If you also want to catch deref through\
  \ known-dereferencing APIs, use functionKnownToDeref(Call, Params), then for each\
  \ dereferenced parameter:\n  - Extract the MemRegion for the argument expression.\n\
  \  - Apply the same logic as in checkLocation (isCheckedOrAliasedChecked / isExplicitlyUnchecked)\
  \ and report if needed.\n\n3) Key Matching/Extraction Details\n- Function matching:\n\
  \  - isDevmKzalloc uses Call.getCalleeIdentifier()->getName() == \"devm_kzalloc\"\
  .\n- Pointer region extraction:\n  - Use getMemRegionFromExpr(E, C) consistently\
  \ to obtain the MemRegion for the pointer variable/expression being tested or dereferenced.\n\
  - Alias resolution:\n  - canonical(R): follow PtrAliasMap until an unmapped region\
  \ is found.\n  - At deref time, consult both R and canonical(R) in PtrStatusMap:\n\
  \    - Consider checked if either is true.\n    - Consider unchecked if either is\
  \ false (and at least one entry exists), then warn.\n\n4) Reporting\n- BugType:\
  \ \"Possible NULL dereference (devm_kzalloc result)\".\n- Message: \"Dereference\
  \ of devm_kzalloc() result without NULL check\".\n- Emit with generateNonFatalErrorNode\
  \ and PathSensitiveBugReport.\n- Point to the dereference expression (S).\n\n5)\
  \ Notes to match the target patch\n- The bug occurs when:\n  - arr[i] = devm_kzalloc(...);\
  \  // PtrStatusMap[ElementRegion(arr[i])] = false\n  - tmp = arr[i];           \
  \     // PtrAliasMap[tmp] = ElementRegion(arr[i])\n  - tmp->field = ...;       \
  \     // checkLocation sees MemberExpr \u2018->\u2019, base tmp:\n             \
  \                    // consult PtrStatusMap[tmp] or canonical(tmp)=arr[i].\n  \
  \                               // No prior check on arr[i] or tmp => report.\n\
  - If the code performs if (!arr[i]) return -ENOMEM; before deref:\n  - checkBranchCondition\
  \ marks arr[i] as checked; deref is then allowed, and no report is emitted."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include \"llvm/ADT/SmallPtrSet.h\"\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// Program state customizations\nREGISTER_SET_WITH_PROGRAMSTATE(DevmMaybeNullSyms,\
  \ SymbolRef)\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrStatusMap, const MemRegion*, bool)\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*, const MemRegion*)\n\
  \nnamespace {\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\
  \ : public Checker<check::PostCall,\n                                        check::Bind,\n\
  \                                        check::BranchCondition,\n             \
  \                           check::Location> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Possible\
  \ NULL dereference (devm_kzalloc result)\", \"Memory error\")) {}\n\n      void\
  \ checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n      void checkLocation(SVal Loc,\
  \ bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\n   private:\n\n     \
  \ // Self-defined helpers\n      bool isDevmKzalloc(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\n      const MemRegion *canonical(const MemRegion *R, ProgramStateRef\
  \ State) const;\n\n      ProgramStateRef markUnchecked(ProgramStateRef State, const\
  \ MemRegion *R) const;\n      ProgramStateRef markChecked(ProgramStateRef State,\
  \ const MemRegion *R) const;\n\n      bool isCheckedOrAliasedChecked(ProgramStateRef\
  \ State, const MemRegion *R) const;\n      bool isExplicitlyUnchecked(ProgramStateRef\
  \ State, const MemRegion *R) const;\n\n      // Try to extract the pointer expression\
  \ being checked in a condition.\n      const Expr *getCheckedPtrExprFromCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n      void reportDerefWithoutCheck(const\
  \ Stmt *S, CheckerContext &C) const;\n};\n\n// Helper: match devm_kzalloc by callee\
  \ name using source text\nbool SAGenTestChecker::isDevmKzalloc(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n  if\
  \ (!Origin)\n    return false;\n  return ExprHasName(Origin, \"devm_kzalloc\", C);\n\
  }\n\nconst MemRegion *SAGenTestChecker::canonical(const MemRegion *R, ProgramStateRef\
  \ State) const {\n  if (!R)\n    return nullptr;\n  const MemRegion *Cur = R->getBaseRegion();\n\
  \  llvm::SmallPtrSet<const MemRegion*, 8> Visited;\n  while (Cur) {\n    if (!Visited.insert(Cur).second)\n\
  \      break; // cycle protection\n    const MemRegion *Next = nullptr;\n    if\
  \ (const MemRegion *const *NextPtr = State->get<PtrAliasMap>(Cur))\n      Next =\
  \ *NextPtr;\n    if (!Next)\n      break;\n    Cur = Next->getBaseRegion();\n  }\n\
  \  return Cur ? Cur->getBaseRegion() : nullptr;\n}\n\nProgramStateRef SAGenTestChecker::markUnchecked(ProgramStateRef\
  \ State, const MemRegion *R) const {\n  if (!R)\n    return State;\n  const MemRegion\
  \ *Base = R->getBaseRegion();\n  const MemRegion *Root = canonical(Base, State);\n\
  \  if (!Root)\n    Root = Base;\n  State = State->set<PtrStatusMap>(Base, false);\n\
  \  State = State->set<PtrStatusMap>(Root, false);\n  return State;\n}\n\nProgramStateRef\
  \ SAGenTestChecker::markChecked(ProgramStateRef State, const MemRegion *R) const\
  \ {\n  if (!R)\n    return State;\n  const MemRegion *Base = R->getBaseRegion();\n\
  \  const MemRegion *Root = canonical(Base, State);\n  if (!Root)\n    Root = Base;\n\
  \  State = State->set<PtrStatusMap>(Base, true);\n  State = State->set<PtrStatusMap>(Root,\
  \ true);\n  return State;\n}\n\nbool SAGenTestChecker::isCheckedOrAliasedChecked(ProgramStateRef\
  \ State, const MemRegion *R) const {\n  if (!R)\n    return false;\n  const MemRegion\
  \ *Base = R->getBaseRegion();\n  const bool *CheckedBase = State->get<PtrStatusMap>(Base);\n\
  \  if (CheckedBase && *CheckedBase)\n    return true;\n  const MemRegion *Root =\
  \ canonical(Base, State);\n  if (Root) {\n    const bool *CheckedRoot = State->get<PtrStatusMap>(Root);\n\
  \    if (CheckedRoot && *CheckedRoot)\n      return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isExplicitlyUnchecked(ProgramStateRef State, const MemRegion\
  \ *R) const {\n  if (!R)\n    return false;\n  const MemRegion *Base = R->getBaseRegion();\n\
  \  const bool *CheckedBase = State->get<PtrStatusMap>(Base);\n  if (CheckedBase\
  \ && !*CheckedBase)\n    return true;\n  const MemRegion *Root = canonical(Base,\
  \ State);\n  if (Root) {\n    const bool *CheckedRoot = State->get<PtrStatusMap>(Root);\n\
  \    if (CheckedRoot && !*CheckedRoot)\n      return true;\n  }\n  return false;\n\
  }\n\nconst Expr *SAGenTestChecker::getCheckedPtrExprFromCondition(const Stmt *Condition,\
  \ CheckerContext &C) const {\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE)\n    return nullptr;\n\n  // Pattern 1: if (!ptr)\n  if (const auto\
  \ *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if (UO->getOpcode() == UO_LNot) {\n\
  \      return UO->getSubExpr(); // do not strip implicit casts per guideline\n \
  \   }\n  }\n\n  // Pattern 2: if (ptr == NULL) or if (ptr != NULL)\n  if (const\
  \ auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    BinaryOperator::Opcode Op =\
  \ BO->getOpcode();\n    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr *LHS\
  \ = BO->getLHS();\n      const Expr *RHS = BO->getRHS();\n      bool LHSIsNull =\
  \ LHS->isNullPointerConstant(C.getASTContext(),\n                              \
  \                    Expr::NPC_ValueDependentIsNull);\n      bool RHSIsNull = RHS->isNullPointerConstant(C.getASTContext(),\n\
  \                                                  Expr::NPC_ValueDependentIsNull);\n\
  \      if (LHSIsNull && !RHSIsNull)\n        return RHS;\n      if (RHSIsNull &&\
  \ !LHSIsNull)\n        return LHS;\n    }\n  }\n\n  // Pattern 3: if (ptr)\n  //\
  \ Treat the whole condition as pointer expression.\n  return CondE;\n}\n\nvoid SAGenTestChecker::reportDerefWithoutCheck(const\
  \ Stmt *S, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Dereference of devm_kzalloc() result without NULL check\", N);\n \
  \ if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// PostCall: remember devm_kzalloc return symbol as maybe-null\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isDevmKzalloc(Call, C))\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  SVal Ret = Call.getReturnValue();\n\
  \  if (SymbolRef Sym = Ret.getAsSymbol()) {\n    State = State->add<DevmMaybeNullSyms>(Sym);\n\
  \    C.addTransition(State);\n  }\n}\n\n// Bind: mark LHS as unchecked when bound\
  \ from devm_kzalloc return,\n// and track pointer aliasing.\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\n\
  \    return;\n  LHSReg = LHSReg->getBaseRegion();\n  if (!LHSReg)\n    return;\n\
  \n  // Case 1: Binding devm_kzalloc's return symbol to a region => mark unchecked\n\
  \  if (SymbolRef Sym = Val.getAsSymbol()) {\n    if (State->contains<DevmMaybeNullSyms>(Sym))\
  \ {\n      State = markUnchecked(State, LHSReg);\n      State = State->remove<DevmMaybeNullSyms>(Sym);\n\
  \      C.addTransition(State);\n      return;\n    }\n  }\n\n  // Case 2: Track\
  \ aliases when assigning one pointer region to another.\n  if (const MemRegion *RHSReg\
  \ = Val.getAsRegion()) {\n    RHSReg = RHSReg->getBaseRegion();\n    if (RHSReg)\
  \ {\n      const MemRegion *Root = canonical(RHSReg, State);\n      if (!Root)\n\
  \        Root = RHSReg;\n      // Map both sides to the same canonical root to avoid\
  \ cycles and\n      // allow checks to propagate.\n      State = State->set<PtrAliasMap>(LHSReg,\
  \ Root);\n      State = State->set<PtrAliasMap>(RHSReg, Root);\n      C.addTransition(State);\n\
  \    }\n  }\n}\n\n// BranchCondition: mark pointers as checked when we see a NULL-check\n\
  void SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  const Expr *CheckedExpr\
  \ = getCheckedPtrExprFromCondition(Condition, C);\n  if (!CheckedExpr) {\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  const MemRegion *MR = getMemRegionFromExpr(CheckedExpr, C);\n\
  \  if (MR) {\n    MR = MR->getBaseRegion();\n    if (MR) {\n      State = markChecked(State,\
  \ MR);\n      C.addTransition(State);\n      return;\n    }\n  }\n\n  C.addTransition(State);\n\
  }\n\n// Location: detect actual dereference via '->' or '*' and warn if unchecked.\n\
  void SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const Expr *BaseExpr\
  \ = nullptr;\n\n  // Try to find MemberExpr with '->'\n  const MemberExpr *ME =\
  \ dyn_cast_or_null<MemberExpr>(S);\n  if (!ME)\n    ME = findSpecificTypeInParents<MemberExpr>(S,\
  \ C);\n  if (ME && ME->isArrow()) {\n    BaseExpr = ME->getBase();\n  } else {\n\
  \    // Try to find UnaryOperator '*'\n    const UnaryOperator *UO = dyn_cast_or_null<UnaryOperator>(S);\n\
  \    if (!UO)\n      UO = findSpecificTypeInParents<UnaryOperator>(S, C);\n    if\
  \ (UO && UO->getOpcode() == UO_Deref) {\n      BaseExpr = UO->getSubExpr();\n  \
  \  }\n  }\n\n  if (!BaseExpr)\n    return;\n\n  // First, if base is a symbol returned\
  \ by devm_kzalloc and still not stored, warn.\n  SVal BaseVal = State->getSVal(BaseExpr,\
  \ C.getLocationContext());\n  if (SymbolRef Sym = BaseVal.getAsSymbol()) {\n   \
  \ if (State->contains<DevmMaybeNullSyms>(Sym)) {\n      reportDerefWithoutCheck(S,\
  \ C);\n      return;\n    }\n  }\n\n  const MemRegion *MR = getMemRegionFromExpr(BaseExpr,\
  \ C);\n  if (!MR)\n    return;\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  if (isCheckedOrAliasedChecked(State, MR))\n    return;\n\n  if (isExplicitlyUnchecked(State,\
  \ MR)) {\n    reportDerefWithoutCheck(S, C);\n    return;\n  }\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects dereference of devm_kzalloc result without NULL check\",\n  \
  \    \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n \
  \   CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
