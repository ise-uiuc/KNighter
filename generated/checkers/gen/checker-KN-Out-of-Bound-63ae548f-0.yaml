_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 63ae548f1054a0b71678d0349c7dc9628ddd42ca
commit_type: Out-of-Bound
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/Type.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(IdxTFCheckedMap, SymbolRef,\
  \ bool)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PreStmt<ArraySubscriptExpr>,\n\
  \        check::BranchCondition> {\n\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Out-of-bounds LUT\
  \ access\", \"Array bounds\")) {}\n\n      void checkPreStmt(const ArraySubscriptExpr\
  \ *ASE, CheckerContext &C) const;\n      void checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const;\n\n   private:\n\n      // Helpers\n      static bool\
  \ isTFPtsArrayAccess(const ArraySubscriptExpr *ASE, CheckerContext &C);\n      static\
  \ bool getArrayCapacityFromBase(const ArraySubscriptExpr *ASE, llvm::APInt &SizeOut);\n\
  \      static bool getIndexSymbol(const Expr *IdxE, CheckerContext &C,\n       \
  \                          SymbolRef &SymOut, llvm::APSInt &ConstValOut, bool &IsConst);\n\
  \      static bool hasAncestorIfCheckingTFPoints(const Stmt *S, StringRef IndexName,\
  \ CheckerContext &C);\n      void reportAtASE(const ArraySubscriptExpr *ASE, CheckerContext\
  \ &C, StringRef Msg) const;\n};\n\nbool SAGenTestChecker::isTFPtsArrayAccess(const\
  \ ArraySubscriptExpr *ASE, CheckerContext &C) {\n  if (!ASE)\n    return false;\n\
  \n  const Expr *Base = ASE->getBase();\n  if (!Base)\n    return false;\n\n  //\
  \ Heuristic textual check to match: output_tf->tf_pts.{red,green,blue}\n  if (!ExprHasName(Base,\
  \ \"tf_pts\", C))\n    return false;\n\n  if (ExprHasName(Base, \"red\", C) || ExprHasName(Base,\
  \ \"green\", C) || ExprHasName(Base, \"blue\", C))\n    return true;\n\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::getArrayCapacityFromBase(const ArraySubscriptExpr\
  \ *ASE, llvm::APInt &SizeOut) {\n  if (!ASE)\n    return false;\n\n  const Expr\
  \ *Base = ASE->getBase();\n  if (!Base)\n    return false;\n\n  const Expr *B =\
  \ Base->IgnoreParenCasts();\n\n  if (const auto *ME = dyn_cast<MemberExpr>(B)) {\n\
  \    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n      QualType\
  \ Ty = FD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(Ty.getTypePtr()))\
  \ {\n        SizeOut = CAT->getSize();\n        return true;\n      }\n    }\n \
  \ }\n\n  // Fallback: if the base is a DeclRefExpr of an array\n  if (getArraySizeFromExpr(SizeOut,\
  \ B))\n    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::getIndexSymbol(const\
  \ Expr *IdxE, CheckerContext &C,\n                                      SymbolRef\
  \ &SymOut, llvm::APSInt &ConstValOut, bool &IsConst) {\n  if (!IdxE)\n    return\
  \ false;\n\n  // Check constant index\n  if (EvaluateExprToInt(ConstValOut, IdxE,\
  \ C)) {\n    IsConst = true;\n    return true;\n  }\n\n  // Otherwise, extract symbolic\
  \ index\n  ProgramStateRef State = C.getState();\n  SVal V = State->getSVal(IdxE,\
  \ C.getLocationContext());\n  if (SymbolRef S = V.getAsSymbol()) {\n    SymOut =\
  \ S;\n    IsConst = false;\n    return true;\n  }\n\n  return false;\n}\n\nbool\
  \ SAGenTestChecker::hasAncestorIfCheckingTFPoints(const Stmt *S, StringRef IndexName,\
  \ CheckerContext &C) {\n  if (!S)\n    return false;\n\n  const IfStmt *IS = findSpecificTypeInParents<IfStmt>(S,\
  \ C);\n  if (!IS)\n    return false;\n\n  const Expr *Cond = IS->getCond();\n  if\
  \ (!Cond)\n    return false;\n\n  if (ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\"\
  , C) && ExprHasName(Cond, IndexName, C))\n    return true;\n\n  return false;\n\
  }\n\nvoid SAGenTestChecker::reportAtASE(const ArraySubscriptExpr *ASE, CheckerContext\
  \ &C, StringRef Msg) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  R->addRange(ASE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const Expr *CondE =\
  \ dyn_cast_or_null<Expr>(Condition);\n  if (!CondE) {\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  CondE = CondE->IgnoreParenCasts();\n\n  // Only consider\
  \ comparisons that mention TRANSFER_FUNC_POINTS.\n  if (!ExprHasName(CondE, \"TRANSFER_FUNC_POINTS\"\
  , C)) {\n    C.addTransition(State);\n    return;\n  }\n\n  if (const auto *BO =\
  \ dyn_cast<BinaryOperator>(CondE)) {\n    if (BO->isComparisonOp()) {\n      const\
  \ Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n      const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\
  \n      const Expr *IdxExpr = nullptr;\n      if (ExprHasName(LHS, \"TRANSFER_FUNC_POINTS\"\
  , C) && !ExprHasName(RHS, \"TRANSFER_FUNC_POINTS\", C)) {\n        IdxExpr = RHS;\n\
  \      } else if (ExprHasName(RHS, \"TRANSFER_FUNC_POINTS\", C) && !ExprHasName(LHS,\
  \ \"TRANSFER_FUNC_POINTS\", C)) {\n        IdxExpr = LHS;\n      }\n\n      if (IdxExpr)\
  \ {\n        SymbolRef Sym{};\n        llvm::APSInt Dummy;\n        bool IsConst\
  \ = false;\n        if (getIndexSymbol(IdxExpr, C, Sym, Dummy, IsConst) && !IsConst\
  \ && Sym) {\n          State = State->set<IdxTFCheckedMap>(Sym, true);\n       \
  \   C.addTransition(State);\n          return;\n        }\n      }\n    }\n  }\n\
  \n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPreStmt(const ArraySubscriptExpr\
  \ *ASE, CheckerContext &C) const {\n  if (!ASE)\n    return;\n\n  if (!isTFPtsArrayAccess(ASE,\
  \ C))\n    return;\n\n  llvm::APInt ArrSize;\n  if (!getArrayCapacityFromBase(ASE,\
  \ ArrSize))\n    return; // Cannot determine capacity, be conservative and skip\n\
  \n  const Expr *IdxE = ASE->getIdx();\n  if (!IdxE)\n    return;\n\n  IdxE = IdxE->IgnoreParenCasts();\n\
  \n  // Case 1: constant index\n  llvm::APSInt CVal;\n  SymbolRef Sym{};\n  bool\
  \ IsConst = false;\n  if (!getIndexSymbol(IdxE, C, Sym, CVal, IsConst))\n    return;\n\
  \n  if (IsConst) {\n    bool Neg = CVal.isSigned() && CVal.isNegative();\n    uint64_t\
  \ IdxVal = CVal.getLimitedValue(UINT64_MAX);\n    uint64_t Cap = ArrSize.getLimitedValue(UINT64_MAX);\n\
  \    if (Neg || IdxVal >= Cap) {\n      reportAtASE(ASE, C, \"Index out of bounds\
  \ on LUT access\");\n    }\n    return;\n  }\n\n  // Case 2: symbolic index\n  ProgramStateRef\
  \ State = C.getState();\n  if (!Sym)\n    return;\n\n  // If we have seen a guard\
  \ against TRANSFER_FUNC_POINTS, suppress\n  if (const bool *Checked = State->get<IdxTFCheckedMap>(Sym))\
  \ {\n    if (*Checked)\n      return;\n  }\n\n  // Heuristic: if there's an enclosing\
  \ if that mentions both the index and TRANSFER_FUNC_POINTS, suppress\n  StringRef\
  \ IndexName;\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(IdxE)) {\n    if (const\
  \ auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n      IndexName = VD->getName();\n\
  \    }\n  }\n  if (!IndexName.empty() && hasAncestorIfCheckingTFPoints(ASE, IndexName,\
  \ C))\n    return;\n\n  // Try to infer an upper bound\n  const llvm::APSInt *Max\
  \ = inferSymbolMaxVal(Sym, C);\n  if (Max) {\n    uint64_t MaxV = Max->getLimitedValue(UINT64_MAX);\n\
  \    uint64_t Cap = ArrSize.getLimitedValue(UINT64_MAX);\n    if (MaxV >= Cap) {\n\
  \      reportAtASE(ASE, C, \"Possible OOB: index may exceed TRANSFER_FUNC_POINTS\"\
  );\n      return;\n    }\n    // If MaxV < Cap, likely safe; do not warn.\n    return;\n\
  \  }\n\n  // If no guard seen and no bound known, report missing validation\n  reportAtASE(ASE,\
  \ C, \"Possible OOB: index not validated against TRANSFER_FUNC_POINTS\");\n}\n\n\
  } // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects missing TRANSFER_FUNC_POINTS bound checks for output_tf->tf_pts\
  \ LUT accesses\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Fix potential index out of bounds\
  \ in color transformation function\n\nFixes index out of bounds issue in the color\
  \ transformation function.\nThe issue could occur when the index 'i' exceeds the\
  \ number of transfer\nfunction points (TRANSFER_FUNC_POINTS).\n\nThe fix adds a\
  \ check to ensure 'i' is within bounds before accessing the\ntransfer function points.\
  \ If 'i' is out of bounds, an error message is\nlogged and the function returns\
  \ false to indicate an error.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:405\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.red'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:406\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.green'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:407\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.blue'\
  \ 1025 <= s32max\n\nFixes: b629596072e5 (\"drm/amd/display: Build unity lut for\
  \ shaper\")\nCc: Vitaly Prosyak <vitaly.prosyak@amd.com>\nCc: Charlene Liu <Charlene.Liu@amd.com>\n\
  Cc: Harry Wentland <harry.wentland@amd.com>\nCc: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>\n\
  Cc: Roman Li <roman.li@amd.com>\nCc: Aurabindo Pillai <aurabindo.pillai@amd.com>\n\
  Cc: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Srinivasan Shanmugam <srinivasan.shanmugam@amd.com>\n\
  Reviewed-by: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Alex Deucher <alexander.deucher@amd.com>\n\
  \n## Buggy Code\n\n```c\n// Function: cm_helper_translate_curve_to_hw_format in\
  \ drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nbool cm_helper_translate_curve_to_hw_format(struct\
  \ dc_context *ctx,\n\t\t\t\tconst struct dc_transfer_func *output_tf,\n\t\t\t\t\
  struct pwl_params *lut_params, bool fixpoint)\n{\n\tstruct curve_points3 *corner_points;\n\
  \tstruct pwl_result_data *rgb_resulted;\n\tstruct pwl_result_data *rgb;\n\tstruct\
  \ pwl_result_data *rgb_plus_1;\n\tstruct pwl_result_data *rgb_minus_1;\n\n\tint32_t\
  \ region_start, region_end;\n\tint32_t i;\n\tuint32_t j, k, seg_distr[MAX_REGIONS_NUMBER],\
  \ increment, start_index, hw_points;\n\n\tif (output_tf == NULL || lut_params ==\
  \ NULL || output_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\tcorner_points\
  \ = lut_params->corner_points;\n\trgb_resulted = lut_params->rgb_resulted;\n\thw_points\
  \ = 0;\n\n\tmemset(lut_params, 0, sizeof(struct pwl_params));\n\tmemset(seg_distr,\
  \ 0, sizeof(seg_distr));\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ || output_tf->tf\
  \ == TRANSFER_FUNCTION_GAMMA22) {\n\t\t/* 32 segments\n\t\t * segments are from\
  \ 2^-25 to 2^7\n\t\t */\n\t\tfor (i = 0; i < NUMBER_REGIONS ; i++)\n\t\t\tseg_distr[i]\
  \ = 3;\n\n\t\tregion_start = -MAX_LOW_POINT;\n\t\tregion_end   = NUMBER_REGIONS\
  \ - MAX_LOW_POINT;\n\t} else {\n\t\t/* 11 segments\n\t\t * segment is from 2^-10\
  \ to 2^1\n\t\t * There are less than 256 points, for optimization\n\t\t */\n\t\t\
  seg_distr[0] = 3;\n\t\tseg_distr[1] = 4;\n\t\tseg_distr[2] = 4;\n\t\tseg_distr[3]\
  \ = 4;\n\t\tseg_distr[4] = 4;\n\t\tseg_distr[5] = 4;\n\t\tseg_distr[6] = 4;\n\t\t\
  seg_distr[7] = 4;\n\t\tseg_distr[8] = 4;\n\t\tseg_distr[9] = 4;\n\t\tseg_distr[10]\
  \ = 1;\n\n\t\tregion_start = -10;\n\t\tregion_end = 1;\n\t}\n\n\tfor (i = region_end\
  \ - region_start; i < MAX_REGIONS_NUMBER ; i++)\n\t\tseg_distr[i] = -1;\n\n\tfor\
  \ (k = 0; k < MAX_REGIONS_NUMBER; k++) {\n\t\tif (seg_distr[k] != -1)\n\t\t\thw_points\
  \ += (1 << seg_distr[k]);\n\t}\n\n\tj = 0;\n\tfor (k = 0; k < (region_end - region_start);\
  \ k++) {\n\t\tincrement = NUMBER_SW_SEGMENTS / (1 << seg_distr[k]);\n\t\tstart_index\
  \ = (region_start + k + MAX_LOW_POINT) *\n\t\t\t\tNUMBER_SW_SEGMENTS;\n\t\tfor (i\
  \ = start_index; i < start_index + NUMBER_SW_SEGMENTS;\n\t\t\t\ti += increment)\
  \ {\n\t\t\tif (j == hw_points - 1)\n\t\t\t\tbreak;\n\t\t\trgb_resulted[j].red =\
  \ output_tf->tf_pts.red[i];\n\t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n\
  \t\t\trgb_resulted[j].blue = output_tf->tf_pts.blue[i];\n\t\t\tj++;\n\t\t}\n\t}\n\
  \n\t/* last point */\n\tstart_index = (region_end + MAX_LOW_POINT) * NUMBER_SW_SEGMENTS;\n\
  \trgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];\n\trgb_resulted[hw_points\
  \ - 1].green = output_tf->tf_pts.green[start_index];\n\trgb_resulted[hw_points -\
  \ 1].blue = output_tf->tf_pts.blue[start_index];\n\n\trgb_resulted[hw_points].red\
  \ = rgb_resulted[hw_points - 1].red;\n\trgb_resulted[hw_points].green = rgb_resulted[hw_points\
  \ - 1].green;\n\trgb_resulted[hw_points].blue = rgb_resulted[hw_points - 1].blue;\n\
  \n\t// All 3 color channels have same x\n\tcorner_points[0].red.x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\
  \t\t\t\t\t     dc_fixpt_from_int(region_start));\n\tcorner_points[0].green.x = corner_points[0].red.x;\n\
  \tcorner_points[0].blue.x = corner_points[0].red.x;\n\n\tcorner_points[1].red.x\
  \ = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_end));\n\
  \tcorner_points[1].green.x = corner_points[1].red.x;\n\tcorner_points[1].blue.x\
  \ = corner_points[1].red.x;\n\n\tcorner_points[0].red.y = rgb_resulted[0].red;\n\
  \tcorner_points[0].green.y = rgb_resulted[0].green;\n\tcorner_points[0].blue.y =\
  \ rgb_resulted[0].blue;\n\n\tcorner_points[0].red.slope = dc_fixpt_div(corner_points[0].red.y,\n\
  \t\t\tcorner_points[0].red.x);\n\tcorner_points[0].green.slope = dc_fixpt_div(corner_points[0].green.y,\n\
  \t\t\tcorner_points[0].green.x);\n\tcorner_points[0].blue.slope = dc_fixpt_div(corner_points[0].blue.y,\n\
  \t\t\tcorner_points[0].blue.x);\n\n\t/* see comment above, m_arrPoints[1].y should\
  \ be the Y value for the\n\t * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints\
  \ - 1)\n\t */\n\tcorner_points[1].red.y = rgb_resulted[hw_points - 1].red;\n\tcorner_points[1].green.y\
  \ = rgb_resulted[hw_points - 1].green;\n\tcorner_points[1].blue.y = rgb_resulted[hw_points\
  \ - 1].blue;\n\tcorner_points[1].red.slope = dc_fixpt_zero;\n\tcorner_points[1].green.slope\
  \ = dc_fixpt_zero;\n\tcorner_points[1].blue.slope = dc_fixpt_zero;\n\n\tif (output_tf->tf\
  \ == TRANSFER_FUNCTION_PQ) {\n\t\t/* for PQ, we want to have a straight line from\
  \ last HW X point,\n\t\t * and the slope to be such that we hit 1.0 at 10000 nits.\n\
  \t\t */\n\t\tconst struct fixed31_32 end_value =\n\t\t\t\tdc_fixpt_from_int(125);\n\
  \n\t\tcorner_points[1].red.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].red.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].red.x));\n\
  \t\tcorner_points[1].green.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].green.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].green.x));\n\
  \t\tcorner_points[1].blue.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].blue.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].blue.x));\n\
  \t}\n\n\tlut_params->hw_points_num = hw_points;\n\n\tk = 0;\n\tfor (i = 1; i < MAX_REGIONS_NUMBER;\
  \ i++) {\n\t\tif (seg_distr[k] != -1) {\n\t\t\tlut_params->arr_curve_points[k].segments_num\
  \ =\n\t\t\t\t\tseg_distr[k];\n\t\t\tlut_params->arr_curve_points[i].offset =\n\t\
  \t\t\t\tlut_params->arr_curve_points[k].offset + (1 << seg_distr[k]);\n\t\t}\n\t\
  \tk++;\n\t}\n\n\tif (seg_distr[k] != -1)\n\t\tlut_params->arr_curve_points[k].segments_num\
  \ = seg_distr[k];\n\n\trgb = rgb_resulted;\n\trgb_plus_1 = rgb_resulted + 1;\n\t\
  rgb_minus_1 = rgb;\n\n\ti = 1;\n\twhile (i != hw_points + 1) {\n\n\t\tif (i >= hw_points\
  \ - 1) {\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->red, rgb->red))\n\t\t\t\trgb_plus_1->red\
  \ = dc_fixpt_add(rgb->red, rgb_minus_1->delta_red);\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->green,\
  \ rgb->green))\n\t\t\t\trgb_plus_1->green = dc_fixpt_add(rgb->green, rgb_minus_1->delta_green);\n\
  \t\t\tif (dc_fixpt_lt(rgb_plus_1->blue, rgb->blue))\n\t\t\t\trgb_plus_1->blue =\
  \ dc_fixpt_add(rgb->blue, rgb_minus_1->delta_blue);\n\t\t}\n\n\t\trgb->delta_red\
  \   = dc_fixpt_sub(rgb_plus_1->red,   rgb->red);\n\t\trgb->delta_green = dc_fixpt_sub(rgb_plus_1->green,\
  \ rgb->green);\n\t\trgb->delta_blue  = dc_fixpt_sub(rgb_plus_1->blue,  rgb->blue);\n\
  \n\n\t\tif (fixpoint == true) {\n\t\t\tuint32_t red_clamp = dc_fixpt_clamp_u0d14(rgb->delta_red);\n\
  \t\t\tuint32_t green_clamp = dc_fixpt_clamp_u0d14(rgb->delta_green);\n\t\t\tuint32_t\
  \ blue_clamp = dc_fixpt_clamp_u0d14(rgb->delta_blue);\n\n\t\t\tif (red_clamp >>\
  \ 10 || green_clamp >> 10 || blue_clamp >> 10)\n\t\t\t\tDC_LOG_WARNING(\"Losing\
  \ delta precision while programming shaper LUT.\");\n\n\t\t\trgb->delta_red_reg\
  \   = red_clamp & 0x3ff;\n\t\t\trgb->delta_green_reg = green_clamp & 0x3ff;\n\t\t\
  \trgb->delta_blue_reg  = blue_clamp & 0x3ff;\n\t\t\trgb->red_reg         = dc_fixpt_clamp_u0d14(rgb->red);\n\
  \t\t\trgb->green_reg       = dc_fixpt_clamp_u0d14(rgb->green);\n\t\t\trgb->blue_reg\
  \        = dc_fixpt_clamp_u0d14(rgb->blue);\n\t\t}\n\n\t\t++rgb_plus_1;\n\t\trgb_minus_1\
  \ = rgb;\n\t\t++rgb;\n\t\t++i;\n\t}\n\tcm_helper_convert_to_custom_float(rgb_resulted,\n\
  \t\t\t\t\t\tlut_params->corner_points,\n\t\t\t\t\t\thw_points, fixpoint);\n\n\t\
  return true;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\
  \ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nindex b7e57aa27361..b0d192c6e63e\
  \ 100644\n--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n\
  @@ -402,6 +402,11 @@ bool cm_helper_translate_curve_to_hw_format(struct dc_context\
  \ *ctx,\n \t\t\t\ti += increment) {\n \t\t\tif (j == hw_points - 1)\n \t\t\t\tbreak;\n\
  +\t\t\tif (i >= TRANSFER_FUNC_POINTS) {\n+\t\t\t\tDC_LOG_ERROR(\"Index out of bounds:\
  \ i=%d, TRANSFER_FUNC_POINTS=%d\\n\",\n+\t\t\t\t\t     i, TRANSFER_FUNC_POINTS);\n\
  +\t\t\t\treturn false;\n+\t\t\t}\n \t\t\trgb_resulted[j].red = output_tf->tf_pts.red[i];\n\
  \ \t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n \t\t\trgb_resulted[j].blue\
  \ = output_tf->tf_pts.blue[i];\n```\n"
pattern: "## Bug Pattern\n\nIndexing a fixed-size LUT array with a computed index\
  \ that is not validated against the array\u2019s capacity. Specifically, using an\
  \ index i derived from region/segment calculations to access output_tf->tf_pts.{red,\
  \ green, blue}[i] without ensuring 0 <= i < TRANSFER_FUNC_POINTS, allowing out-of-bounds\
  \ reads when i reaches or exceeds TRANSFER_FUNC_POINTS."
plan: "Plan\n\n1. Program state customization\n- REGISTER_MAP_WITH_PROGRAMSTATE(IdxTFCheckedMap,\
  \ SymbolRef, bool)\n  - Tracks whether an integer index symbol has been path-checked\
  \ against TRANSFER_FUNC_POINTS (true = checked).\n- Rationale: We only need to remember\
  \ \u201Cthis index has been compared to TRANSFER_FUNC_POINTS\u201D to suppress warnings\
  \ when a proper guard exists. No alias map is needed since we only track scalar\
  \ index symbols.\n\n2. Helper detections/utilities\n- isTFPtsArrayAccess(const ArraySubscriptExpr\
  \ *ASE, CheckerContext &C)\n  - Return true if the subscripted base syntactically\
  \ refers to the LUT arrays in the pattern (output_tf->tf_pts.red/green/blue). Implement\
  \ by:\n    - Getting the base expression B = ASE->getBase()->IgnoreImpCasts().\n\
  \    - Use ExprHasName(B, \"tf_pts\") to filter, and additionally optionally check\
  \ channel names: ExprHasName(B, \"red\") || \"green\" || \"blue\". If any of these\
  \ hit, consider it a target array access.\n- getArrayCapacityFromBase(const ArraySubscriptExpr\
  \ *ASE, llvm::APInt &SizeOut)\n  - Retrieve the constant element count of the array\
  \ being indexed:\n    - Get the underlying declaration for the member (if base is\
  \ a MemberExpr, ME->getMemberDecl()) and fetch its QualType.\n    - If that QualType\
  \ is a ConstantArrayType, extract size into SizeOut.\n    - Fallback: If the base\
  \ can be a DeclRefExpr of array (rare here), use the provided getArraySizeFromExpr.\n\
  \  - If the size is not found (e.g., pointer or unknown), return false and skip\
  \ capacity-based checks.\n- getIndexSymbol(const Expr *IdxE, CheckerContext &C,\
  \ SymbolRef &SymOut, llvm::APSInt &ConstValOut, bool &IsConst)\n  - From State->getSVal(IdxE,\
  \ LC), try:\n    - If EvaluateExprToInt(ConstValOut, IdxE, C) returns true => IsConst\
  \ = true.\n    - Else try to extract SymbolRef from the SVal (nonloc::SymbolVal\
  \ or via getAsSymbol()) into SymOut and set IsConst = false.\n- hasAncestorIfCheckingTFPoints(const\
  \ Stmt *S, StringRef IndexName, CheckerContext &C)\n  - Walk up parents using findSpecificTypeInParents<IfStmt>(...),\
  \ and if found, check the condition:\n    - If ExprHasName(IfStmt->getCond(), \"\
  TRANSFER_FUNC_POINTS\") AND ExprHasName(IfStmt->getCond(), IndexName), return true.\n\
  \  - This is a heuristic fallback to suppress warnings when there is any visible\
  \ guard using TRANSFER_FUNC_POINTS for the same index variable.\n\n3. checkBranchCondition\
  \ (syntactic guard tracking)\n- Goal: Opportunistically mark indexes as \u201Cchecked\u201D\
  \ when we see a condition that mentions TRANSFER_FUNC_POINTS on either side.\n-\
  \ Steps:\n  - Inspect the branch condition Stmt. If it is a BinaryOperator comparison\
  \ (BO->isComparisonOp()) and ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\"):\n    -\
  \ Identify the other side expression that represents the index (the side that does\
  \ not contain \u201CTRANSFER_FUNC_POINTS\u201D).\n    - Extract the symbol for that\
  \ side via getIndexSymbol(...). If a SymbolRef is found, update:\n      - State\
  \ = State->set<IdxTFCheckedMap>(Sym, true);\n      - Ctx.addTransition(State);\n\
  \  - Handle common forms: i < TRANSFER_FUNC_POINTS, i <= TRANSFER_FUNC_POINTS -\
  \ 1, TRANSFER_FUNC_POINTS > i, TRANSFER_FUNC_POINTS - 1 >= i. Use ExprHasName to\
  \ identify which side holds the macro; if the other side is a DeclRefExpr or an\
  \ arithmetic expression around the index variable, still try to extract its Sym\
  \ via State->getSVal.\n- Note: We do not branch-split here; we conservatively mark\
  \ \u201Cchecked\u201D upon sight of an appropriate comparison to avoid false positives.\n\
  \n4. checkPreStmt(const ArraySubscriptExpr *ASE)\n- Goal: Detect accesses to output_tf->tf_pts.{red,green,blue}[idx]\
  \ where idx is not validated against array capacity (TRANSFER_FUNC_POINTS).\n- Steps:\n\
  \  1) Filter: if !isTFPtsArrayAccess(ASE, C), return.\n  2) Capacity: llvm::APInt\
  \ ArrSize; if !getArrayCapacityFromBase(ASE, ArrSize), return (we only act when\
  \ capacity is known and constant).\n  3) Index analysis:\n     - Let IdxE = ASE->getIdx()->IgnoreImpCasts().\n\
  \     - Try constant: llvm::APSInt CVal; if EvaluateExprToInt(CVal, IdxE, C) and\
  \ (CVal.isNegative() || CVal.uge(ArrSize)):\n       - Report: \u201CIndex out of\
  \ bounds for LUT.\u201D\n       - Create a node via generateNonFatalErrorNode and\
  \ emit a PathSensitiveBugReport.\n       - Return.\n     - Else, try symbol: SymbolRef\
  \ Sym; extract via getIndexSymbol. If not available, return (not analyzable).\n\
  \  4) Guarded-by-check suppression:\n     - If State->get<IdxTFCheckedMap>(Sym)\
  \ is true, return (protected by a TRANSFER_FUNC_POINTS comparison on this path).\n\
  \     - Otherwise, try a heuristic context check: obtain the index variable name\
  \ (if the index expr is DeclRefExpr, use getDecl()->getName()), and if hasAncestorIfCheckingTFPoints(ASE,\
  \ IndexName, C) is true, return.\n  5) Numeric upper bound inference (optional strengthening):\n\
  \     - const llvm::APSInt *Max = inferSymbolMaxVal(Sym, C);\n     - If Max is non-null\
  \ and Max->uge(ArrSize):\n       - Report: \u201CIndex may exceed TRANSFER_FUNC_POINTS.\u201D\
  \n       - Return.\n  6) Final pattern warning (missing guard):\n     - If we reached\
  \ here, we are accessing the LUT without an observed guard i < TRANSFER_FUNC_POINTS\
  \ and without a provable safe bound.\n     - Report: \u201CMissing \u2018i < TRANSFER_FUNC_POINTS\u2019\
  \ check before LUT access.\u201D\n\n- Reporting:\n  - Use std::make_unique<PathSensitiveBugReport>\
  \ with a concise message:\n    - For definite OOB: \u201CIndex out of bounds on\
  \ LUT access.\u201D\n    - For potential OOB / missing check: \u201CPossible OOB:\
  \ index not validated against TRANSFER_FUNC_POINTS.\u201D\n  - Use the ArraySubscriptExpr\
  \ as the report location (ASE->getExprLoc()).\n\n5. Other callbacks\n- None required\
  \ for this checker. We do not need checkBind, checkLocation, checkPreCall, or checkPostCall.\n\
  - No need to clean state in checkEndFunction; the map is path-local and naturally\
  \ dropped at function end.\n\n6. Notes on conservatism and false positives control\n\
  - We:\n  - Restrict to array bases that syntactically mention tf_pts (and optionally\
  \ channel names).\n  - Require a known constant array capacity (from the field type)\
  \ to proceed.\n  - Suppress when either:\n    - We saw any comparison against TRANSFER_FUNC_POINTS\
  \ for this symbol (via checkBranchCondition), or\n    - There is an enclosing IfStmt\
  \ whose condition mentions both the index and TRANSFER_FUNC_POINTS (heuristic),\
  \ or\n    - Analyzer can bound the symbol\u2019s maximum below the array capacity\
  \ (by not hitting Max >= Size).\n- This keeps the checker focused on the target\
  \ patch pattern and avoids spamming unrelated code."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/Type.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(IdxTFCheckedMap, SymbolRef,\
  \ bool)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PreStmt<ArraySubscriptExpr>,\n\
  \        check::BranchCondition> {\n\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Out-of-bounds LUT\
  \ access\", \"Array bounds\")) {}\n\n      void checkPreStmt(const ArraySubscriptExpr\
  \ *ASE, CheckerContext &C) const;\n      void checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const;\n\n   private:\n\n      // Helpers\n      static bool\
  \ isTFPtsArrayAccess(const ArraySubscriptExpr *ASE, CheckerContext &C);\n      static\
  \ bool getArrayCapacityFromBase(const ArraySubscriptExpr *ASE, llvm::APInt &SizeOut);\n\
  \      static bool getIndexSymbol(const Expr *IdxE, CheckerContext &C,\n       \
  \                          SymbolRef &SymOut, llvm::APSInt &ConstValOut, bool &IsConst);\n\
  \      static bool hasAncestorIfCheckingTFPoints(const Stmt *S, StringRef IndexName,\
  \ CheckerContext &C);\n      void reportAtASE(const ArraySubscriptExpr *ASE, CheckerContext\
  \ &C, StringRef Msg) const;\n};\n\nbool SAGenTestChecker::isTFPtsArrayAccess(const\
  \ ArraySubscriptExpr *ASE, CheckerContext &C) {\n  if (!ASE)\n    return false;\n\
  \n  const Expr *Base = ASE->getBase();\n  if (!Base)\n    return false;\n\n  //\
  \ Heuristic textual check to match: output_tf->tf_pts.{red,green,blue}\n  if (!ExprHasName(Base,\
  \ \"tf_pts\", C))\n    return false;\n\n  if (ExprHasName(Base, \"red\", C) || ExprHasName(Base,\
  \ \"green\", C) || ExprHasName(Base, \"blue\", C))\n    return true;\n\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::getArrayCapacityFromBase(const ArraySubscriptExpr\
  \ *ASE, llvm::APInt &SizeOut) {\n  if (!ASE)\n    return false;\n\n  const Expr\
  \ *Base = ASE->getBase();\n  if (!Base)\n    return false;\n\n  const Expr *B =\
  \ Base->IgnoreParenCasts();\n\n  if (const auto *ME = dyn_cast<MemberExpr>(B)) {\n\
  \    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n      QualType\
  \ Ty = FD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(Ty.getTypePtr()))\
  \ {\n        SizeOut = CAT->getSize();\n        return true;\n      }\n    }\n \
  \ }\n\n  // Fallback: if the base is a DeclRefExpr of an array\n  if (getArraySizeFromExpr(SizeOut,\
  \ B))\n    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::getIndexSymbol(const\
  \ Expr *IdxE, CheckerContext &C,\n                                      SymbolRef\
  \ &SymOut, llvm::APSInt &ConstValOut, bool &IsConst) {\n  if (!IdxE)\n    return\
  \ false;\n\n  // Check constant index\n  if (EvaluateExprToInt(ConstValOut, IdxE,\
  \ C)) {\n    IsConst = true;\n    return true;\n  }\n\n  // Otherwise, extract symbolic\
  \ index\n  ProgramStateRef State = C.getState();\n  SVal V = State->getSVal(IdxE,\
  \ C.getLocationContext());\n  if (SymbolRef S = V.getAsSymbol()) {\n    SymOut =\
  \ S;\n    IsConst = false;\n    return true;\n  }\n\n  return false;\n}\n\nbool\
  \ SAGenTestChecker::hasAncestorIfCheckingTFPoints(const Stmt *S, StringRef IndexName,\
  \ CheckerContext &C) {\n  if (!S)\n    return false;\n\n  const IfStmt *IS = findSpecificTypeInParents<IfStmt>(S,\
  \ C);\n  if (!IS)\n    return false;\n\n  const Expr *Cond = IS->getCond();\n  if\
  \ (!Cond)\n    return false;\n\n  if (ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\"\
  , C) && ExprHasName(Cond, IndexName, C))\n    return true;\n\n  return false;\n\
  }\n\nvoid SAGenTestChecker::reportAtASE(const ArraySubscriptExpr *ASE, CheckerContext\
  \ &C, StringRef Msg) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  R->addRange(ASE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const Expr *CondE =\
  \ dyn_cast_or_null<Expr>(Condition);\n  if (!CondE) {\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  CondE = CondE->IgnoreParenCasts();\n\n  // Only consider\
  \ comparisons that mention TRANSFER_FUNC_POINTS.\n  if (!ExprHasName(CondE, \"TRANSFER_FUNC_POINTS\"\
  , C)) {\n    C.addTransition(State);\n    return;\n  }\n\n  if (const auto *BO =\
  \ dyn_cast<BinaryOperator>(CondE)) {\n    if (BO->isComparisonOp()) {\n      const\
  \ Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n      const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\
  \n      const Expr *IdxExpr = nullptr;\n      if (ExprHasName(LHS, \"TRANSFER_FUNC_POINTS\"\
  , C) && !ExprHasName(RHS, \"TRANSFER_FUNC_POINTS\", C)) {\n        IdxExpr = RHS;\n\
  \      } else if (ExprHasName(RHS, \"TRANSFER_FUNC_POINTS\", C) && !ExprHasName(LHS,\
  \ \"TRANSFER_FUNC_POINTS\", C)) {\n        IdxExpr = LHS;\n      }\n\n      if (IdxExpr)\
  \ {\n        SymbolRef Sym{};\n        llvm::APSInt Dummy;\n        bool IsConst\
  \ = false;\n        if (getIndexSymbol(IdxExpr, C, Sym, Dummy, IsConst) && !IsConst\
  \ && Sym) {\n          State = State->set<IdxTFCheckedMap>(Sym, true);\n       \
  \   C.addTransition(State);\n          return;\n        }\n      }\n    }\n  }\n\
  \n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPreStmt(const ArraySubscriptExpr\
  \ *ASE, CheckerContext &C) const {\n  if (!ASE)\n    return;\n\n  if (!isTFPtsArrayAccess(ASE,\
  \ C))\n    return;\n\n  llvm::APInt ArrSize;\n  if (!getArrayCapacityFromBase(ASE,\
  \ ArrSize))\n    return; // Cannot determine capacity, be conservative and skip\n\
  \n  const Expr *IdxE = ASE->getIdx();\n  if (!IdxE)\n    return;\n\n  IdxE = IdxE->IgnoreParenCasts();\n\
  \n  // Case 1: constant index\n  llvm::APSInt CVal;\n  SymbolRef Sym{};\n  bool\
  \ IsConst = false;\n  if (!getIndexSymbol(IdxE, C, Sym, CVal, IsConst))\n    return;\n\
  \n  if (IsConst) {\n    bool Neg = CVal.isSigned() && CVal.isNegative();\n    uint64_t\
  \ IdxVal = CVal.getLimitedValue(UINT64_MAX);\n    uint64_t Cap = ArrSize.getLimitedValue(UINT64_MAX);\n\
  \    if (Neg || IdxVal >= Cap) {\n      reportAtASE(ASE, C, \"Index out of bounds\
  \ on LUT access\");\n    }\n    return;\n  }\n\n  // Case 2: symbolic index\n  ProgramStateRef\
  \ State = C.getState();\n  if (!Sym)\n    return;\n\n  // If we have seen a guard\
  \ against TRANSFER_FUNC_POINTS, suppress\n  if (const bool *Checked = State->get<IdxTFCheckedMap>(Sym))\
  \ {\n    if (*Checked)\n      return;\n  }\n\n  // Heuristic: if there's an enclosing\
  \ if that mentions both the index and TRANSFER_FUNC_POINTS, suppress\n  StringRef\
  \ IndexName;\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(IdxE)) {\n    if (const\
  \ auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n      IndexName = VD->getName();\n\
  \    }\n  }\n  if (!IndexName.empty() && hasAncestorIfCheckingTFPoints(ASE, IndexName,\
  \ C))\n    return;\n\n  // Try to infer an upper bound\n  const llvm::APSInt *Max\
  \ = inferSymbolMaxVal(Sym, C);\n  if (Max) {\n    uint64_t MaxV = Max->getLimitedValue(UINT64_MAX);\n\
  \    uint64_t Cap = ArrSize.getLimitedValue(UINT64_MAX);\n    if (MaxV >= Cap) {\n\
  \      reportAtASE(ASE, C, \"Possible OOB: index may exceed TRANSFER_FUNC_POINTS\"\
  );\n      return;\n    }\n    // If MaxV < Cap, likely safe; do not warn.\n    return;\n\
  \  }\n\n  // If no guard seen and no bound known, report missing validation\n  reportAtASE(ASE,\
  \ C, \"Possible OOB: index not validated against TRANSFER_FUNC_POINTS\");\n}\n\n\
  } // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects missing TRANSFER_FUNC_POINTS bound checks for output_tf->tf_pts\
  \ LUT accesses\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
