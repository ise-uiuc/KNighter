_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 90ca6956d3834db4060f87700e2fcbb699c4e4fd
commit_type: Uninit-Data
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Attr.h\"\n#include \"llvm/ADT/ImmutableMap.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program state: Track\
  \ auto-cleanup pointer locals (kfree) and whether initialized.\nREGISTER_MAP_WITH_PROGRAMSTATE(TrackedAutoCleanup,\
  \ const VarDecl *, bool)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<\n\
  \                             check::PostStmt<DeclStmt>,\n                     \
  \        check::Bind,\n                             check::PostCall,\n         \
  \                    check::PreStmt<ReturnStmt>,\n                             check::EndFunction>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Auto-cleanup pointer may be freed uninitialized\", \"\
  Memory Management\")) {}\n\n      void checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C) const;\n      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const;\n      void checkPostCall(const CallEvent &Call, CheckerContext &C)\
  \ const;\n      void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;\n\
  \      void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;\n\n\
  \   private:\n      static bool hasKfreeCleanup(const VarDecl *VD);\n      void\
  \ reportUninitializedAtExit(const Stmt *Trigger, CheckerContext &C) const;\n};\n\
  \nstatic PathDiagnosticLocation getDeclLoc(const VarDecl *VD, CheckerContext &C)\
  \ {\n  return PathDiagnosticLocation::createBegin(VD, C.getSourceManager());\n}\n\
  \nbool SAGenTestChecker::hasKfreeCleanup(const VarDecl *VD) {\n  if (!VD)\n    return\
  \ false;\n  const CleanupAttr *CA = VD->getAttr<CleanupAttr>();\n  if (!CA)\n  \
  \  return false;\n\n  if (const FunctionDecl *FD = CA->getFunctionDecl()) {\n  \
  \  if (const IdentifierInfo *II = FD->getIdentifier()) {\n      return II->getName().equals(\"\
  kfree\");\n    }\n  }\n  // If we cannot resolve the function decl, be conservative\
  \ and do not track.\n  return false;\n}\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  for (const Decl *D : DS->decls()) {\n    const auto *VD = dyn_cast<VarDecl>(D);\n\
  \    if (!VD)\n      continue;\n\n    // Only track automatic local pointers with\
  \ cleanup(kfree) and no initializer.\n    if (!VD->hasLocalStorage())\n      continue;\n\
  \n    if (VD->getStorageDuration() != SD_Automatic)\n      continue;\n\n    QualType\
  \ QT = VD->getType();\n    if (QT.isNull() || !QT->isPointerType())\n      continue;\n\
  \n    if (!hasKfreeCleanup(VD))\n      continue;\n\n    // If it has an initializer\
  \ (even non-NULL), treat as initialized; skip tracking.\n    if (VD->hasInit())\n\
  \      continue;\n\n    // Start tracking as \"not initialized\" (false).\n    State\
  \ = State->set<TrackedAutoCleanup>(VD, false);\n  }\n\n  if (State != C.getState())\n\
  \    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  const MemRegion *MR = Loc.getAsRegion();\n  if (!MR)\n    return;\n\n  if (const\
  \ auto *VR = dyn_cast<VarRegion>(MR->getBaseRegion())) {\n    const VarDecl *VD\
  \ = VR->getDecl();\n    if (!VD)\n      return;\n\n    const bool *Tracked = State->get<TrackedAutoCleanup>(VD);\n\
  \    if (Tracked) {\n      // Any assignment counts as initialization.\n      State\
  \ = State->set<TrackedAutoCleanup>(VD, true);\n      C.addTransition(State);\n \
  \   }\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  // If an argument is\
  \ &var where var is tracked, conservatively treat it as initialized.\n  for (unsigned\
  \ i = 0, e = Call.getNumArgs(); i < e; ++i) {\n    const Expr *ArgE = Call.getArgExpr(i);\n\
  \    if (!ArgE)\n      continue;\n\n    const Expr *E = ArgE->IgnoreParenCasts();\n\
  \    const UnaryOperator *UO = dyn_cast<UnaryOperator>(E);\n    if (!UO || UO->getOpcode()\
  \ != UO_AddrOf)\n      continue;\n\n    const Expr *Sub = UO->getSubExpr();\n  \
  \  if (!Sub)\n      continue;\n    Sub = Sub->IgnoreParenCasts();\n\n    if (const\
  \ auto *DRE = dyn_cast<DeclRefExpr>(Sub)) {\n      const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n\
  \      if (!VD)\n        continue;\n\n      const bool *Tracked = State->get<TrackedAutoCleanup>(VD);\n\
  \      if (Tracked && *Tracked == false) {\n        State = State->set<TrackedAutoCleanup>(VD,\
  \ true);\n      }\n    }\n  }\n\n  if (State != C.getState())\n    C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::reportUninitializedAtExit(const Stmt *Trigger, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  auto Map = State->get<TrackedAutoCleanup>();\n\
  \n  for (auto I = Map.begin(), E = Map.end(); I != E; ++I) {\n    const VarDecl\
  \ *VD = I->first;\n    bool Inited = I->second;\n    if (!Inited) {\n      ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n      if (!N)\n        continue;\n\n    \
  \  auto R = std::make_unique<PathSensitiveBugReport>(\n          *BT, \"Auto-cleanup\
  \ pointer may be freed uninitialized; initialize to NULL\", N);\n\n      if (Trigger)\n\
  \        R->addRange(Trigger->getSourceRange());\n\n      R->addNote(\"Declared\
  \ here without initializer\", getDeclLoc(VD, C));\n      C.emitReport(std::move(R));\n\
  \    }\n  }\n}\n\nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt *RS, CheckerContext\
  \ &C) const {\n  // On any return, if there is an uninitialized tracked auto-cleanup\
  \ ptr, report.\n  reportUninitializedAtExit(RS, C);\n}\n\nvoid SAGenTestChecker::checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C) const {\n  // Catch fallthrough to end of function\
  \ (no explicit return).\n  reportUninitializedAtExit(RS, C);\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects auto-cleanup (kfree) pointers not initialized to NULL before\
  \ early exit\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nice: Fix freeing uninitialized pointers\n\nAutomatically\
  \ cleaned up pointers need to be initialized before exiting\ntheir scope.  In this\
  \ case, they need to be initialized to NULL before\nany return statement.\n\nFixes:\
  \ 90f821d72e11 (\"ice: avoid unnecessary devm_ usage\")\nSigned-off-by: Dan Carpenter\
  \ <dan.carpenter@linaro.org>\nReviewed-by: Jiri Pirko <jiri@nvidia.com>\nReviewed-by:\
  \ Simon Horman <horms@kernel.org>\nSigned-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>\n\
  \n## Buggy Code\n\n```c\n// Function: ice_loopback_test in drivers/net/ethernet/intel/ice/ice_ethtool.c\n\
  static u64 ice_loopback_test(struct net_device *netdev)\n{\n\tstruct ice_netdev_priv\
  \ *np = netdev_priv(netdev);\n\tstruct ice_vsi *orig_vsi = np->vsi, *test_vsi;\n\
  \tstruct ice_pf *pf = orig_vsi->back;\n\tu8 broadcast[ETH_ALEN], ret = 0;\n\tint\
  \ num_frames, valid_frames;\n\tstruct ice_tx_ring *tx_ring;\n\tstruct ice_rx_ring\
  \ *rx_ring;\n\tu8 *tx_frame __free(kfree);\n\tint i;\n\n\tnetdev_info(netdev, \"\
  loopback test\\n\");\n\n\ttest_vsi = ice_lb_vsi_setup(pf, pf->hw.port_info);\n\t\
  if (!test_vsi) {\n\t\tnetdev_err(netdev, \"Failed to create a VSI for the loopback\
  \ test\\n\");\n\t\treturn 1;\n\t}\n\n\ttest_vsi->netdev = netdev;\n\ttx_ring = test_vsi->tx_rings[0];\n\
  \trx_ring = test_vsi->rx_rings[0];\n\n\tif (ice_lbtest_prepare_rings(test_vsi))\
  \ {\n\t\tret = 2;\n\t\tgoto lbtest_vsi_close;\n\t}\n\n\tif (ice_alloc_rx_bufs(rx_ring,\
  \ rx_ring->count)) {\n\t\tret = 3;\n\t\tgoto lbtest_rings_dis;\n\t}\n\n\t/* Enable\
  \ MAC loopback in firmware */\n\tif (ice_aq_set_mac_loopback(&pf->hw, true, NULL))\
  \ {\n\t\tret = 4;\n\t\tgoto lbtest_mac_dis;\n\t}\n\n\t/* Test VSI needs to receive\
  \ broadcast packets */\n\teth_broadcast_addr(broadcast);\n\tif (ice_fltr_add_mac(test_vsi,\
  \ broadcast, ICE_FWD_TO_VSI)) {\n\t\tret = 5;\n\t\tgoto lbtest_mac_dis;\n\t}\n\n\
  \tif (ice_lbtest_create_frame(pf, &tx_frame, ICE_LB_FRAME_SIZE)) {\n\t\tret = 7;\n\
  \t\tgoto remove_mac_filters;\n\t}\n\n\tnum_frames = min_t(int, tx_ring->count, 32);\n\
  \tfor (i = 0; i < num_frames; i++) {\n\t\tif (ice_diag_send(tx_ring, tx_frame, ICE_LB_FRAME_SIZE))\
  \ {\n\t\t\tret = 8;\n\t\t\tgoto remove_mac_filters;\n\t\t}\n\t}\n\n\tvalid_frames\
  \ = ice_lbtest_receive_frames(rx_ring);\n\tif (!valid_frames)\n\t\tret = 9;\n\t\
  else if (valid_frames != num_frames)\n\t\tret = 10;\n\nremove_mac_filters:\n\tif\
  \ (ice_fltr_remove_mac(test_vsi, broadcast, ICE_FWD_TO_VSI))\n\t\tnetdev_err(netdev,\
  \ \"Could not remove MAC filter for the test VSI\\n\");\nlbtest_mac_dis:\n\t/* Disable\
  \ MAC loopback after the test is completed. */\n\tif (ice_aq_set_mac_loopback(&pf->hw,\
  \ false, NULL))\n\t\tnetdev_err(netdev, \"Could not disable MAC loopback\\n\");\n\
  lbtest_rings_dis:\n\tif (ice_lbtest_disable_rings(test_vsi))\n\t\tnetdev_err(netdev,\
  \ \"Could not disable test rings\\n\");\nlbtest_vsi_close:\n\ttest_vsi->netdev =\
  \ NULL;\n\tif (ice_vsi_release(test_vsi))\n\t\tnetdev_err(netdev, \"Failed to remove\
  \ the test VSI\\n\");\n\n\treturn ret;\n}\n```\n\n```c\n// Function: ice_set_fc\
  \ in drivers/net/ethernet/intel/ice/ice_common.c\nint\nice_set_fc(struct ice_port_info\
  \ *pi, u8 *aq_failures, bool ena_auto_link_update)\n{\n\tstruct ice_aqc_get_phy_caps_data\
  \ *pcaps __free(kfree);\n\tstruct ice_aqc_set_phy_cfg_data cfg = { 0 };\n\tstruct\
  \ ice_hw *hw;\n\tint status;\n\n\tif (!pi || !aq_failures)\n\t\treturn -EINVAL;\n\
  \n\t*aq_failures = 0;\n\thw = pi->hw;\n\n\tpcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);\n\
  \tif (!pcaps)\n\t\treturn -ENOMEM;\n\n\t/* Get the current PHY config */\n\tstatus\
  \ = ice_aq_get_phy_caps(pi, false, ICE_AQC_REPORT_ACTIVE_CFG,\n\t\t\t\t     pcaps,\
  \ NULL);\n\tif (status) {\n\t\t*aq_failures = ICE_SET_FC_AQ_FAIL_GET;\n\t\tgoto\
  \ out;\n\t}\n\n\tice_copy_phy_caps_to_cfg(pi, pcaps, &cfg);\n\n\t/* Configure the\
  \ set PHY data */\n\tstatus = ice_cfg_phy_fc(pi, &cfg, pi->fc.req_mode);\n\tif (status)\n\
  \t\tgoto out;\n\n\t/* If the capabilities have changed, then set the new config\
  \ */\n\tif (cfg.caps != pcaps->caps) {\n\t\tint retry_count, retry_max = 10;\n\n\
  \t\t/* Auto restart link so settings take effect */\n\t\tif (ena_auto_link_update)\n\
  \t\t\tcfg.caps |= ICE_AQ_PHY_ENA_AUTO_LINK_UPDT;\n\n\t\tstatus = ice_aq_set_phy_cfg(hw,\
  \ pi, &cfg, NULL);\n\t\tif (status) {\n\t\t\t*aq_failures = ICE_SET_FC_AQ_FAIL_SET;\n\
  \t\t\tgoto out;\n\t\t}\n\n\t\t/* Update the link info\n\t\t * It sometimes takes\
  \ a really long time for link to\n\t\t * come back from the atomic reset. Thus,\
  \ we wait a\n\t\t * little bit.\n\t\t */\n\t\tfor (retry_count = 0; retry_count\
  \ < retry_max; retry_count++) {\n\t\t\tstatus = ice_update_link_info(pi);\n\n\t\t\
  \tif (!status)\n\t\t\t\tbreak;\n\n\t\t\tmdelay(100);\n\t\t}\n\n\t\tif (status)\n\
  \t\t\t*aq_failures = ICE_SET_FC_AQ_FAIL_UPDATE;\n\t}\n\nout:\n\treturn status;\n\
  }\n```\n\n```c\n// Function: ice_init_hw in drivers/net/ethernet/intel/ice/ice_common.c\n\
  int ice_init_hw(struct ice_hw *hw)\n{\n\tstruct ice_aqc_get_phy_caps_data *pcaps\
  \ __free(kfree);\n\tvoid *mac_buf __free(kfree);\n\tu16 mac_buf_len;\n\tint status;\n\
  \n\t/* Set MAC type based on DeviceID */\n\tstatus = ice_set_mac_type(hw);\n\tif\
  \ (status)\n\t\treturn status;\n\n\thw->pf_id = FIELD_GET(PF_FUNC_RID_FUNC_NUM_M,\
  \ rd32(hw, PF_FUNC_RID));\n\n\tstatus = ice_reset(hw, ICE_RESET_PFR);\n\tif (status)\n\
  \t\treturn status;\n\n\tice_get_itr_intrl_gran(hw);\n\n\tstatus = ice_create_all_ctrlq(hw);\n\
  \tif (status)\n\t\tgoto err_unroll_cqinit;\n\n\tstatus = ice_fwlog_init(hw);\n\t\
  if (status)\n\t\tice_debug(hw, ICE_DBG_FW_LOG, \"Error initializing FW logging:\
  \ %d\\n\",\n\t\t\t  status);\n\n\tstatus = ice_clear_pf_cfg(hw);\n\tif (status)\n\
  \t\tgoto err_unroll_cqinit;\n\n\t/* Set bit to enable Flow Director filters */\n\
  \twr32(hw, PFQF_FD_ENA, PFQF_FD_ENA_FD_ENA_M);\n\tINIT_LIST_HEAD(&hw->fdir_list_head);\n\
  \n\tice_clear_pxe_mode(hw);\n\n\tstatus = ice_init_nvm(hw);\n\tif (status)\n\t\t\
  goto err_unroll_cqinit;\n\n\tstatus = ice_get_caps(hw);\n\tif (status)\n\t\tgoto\
  \ err_unroll_cqinit;\n\n\tif (!hw->port_info)\n\t\thw->port_info = devm_kzalloc(ice_hw_to_dev(hw),\n\
  \t\t\t\t\t     sizeof(*hw->port_info),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!hw->port_info)\
  \ {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_unroll_cqinit;\n\t}\n\n\t/* set the back\
  \ pointer to HW */\n\thw->port_info->hw = hw;\n\n\t/* Initialize port_info struct\
  \ with switch configuration data */\n\tstatus = ice_get_initial_sw_cfg(hw);\n\t\
  if (status)\n\t\tgoto err_unroll_alloc;\n\n\thw->evb_veb = true;\n\n\t/* init xarray\
  \ for identifying scheduling nodes uniquely */\n\txa_init_flags(&hw->port_info->sched_node_ids,\
  \ XA_FLAGS_ALLOC);\n\n\t/* Query the allocated resources for Tx scheduler */\n\t\
  status = ice_sched_query_res_alloc(hw);\n\tif (status) {\n\t\tice_debug(hw, ICE_DBG_SCHED,\
  \ \"Failed to get scheduler allocated resources\\n\");\n\t\tgoto err_unroll_alloc;\n\
  \t}\n\tice_sched_get_psm_clk_freq(hw);\n\n\t/* Initialize port_info struct with\
  \ scheduler data */\n\tstatus = ice_sched_init_port(hw->port_info);\n\tif (status)\n\
  \t\tgoto err_unroll_sched;\n\n\tpcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);\n\t\
  if (!pcaps) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_unroll_sched;\n\t}\n\n\t/* Initialize\
  \ port_info struct with PHY capabilities */\n\tstatus = ice_aq_get_phy_caps(hw->port_info,\
  \ false,\n\t\t\t\t     ICE_AQC_REPORT_TOPO_CAP_MEDIA, pcaps,\n\t\t\t\t     NULL);\n\
  \tif (status)\n\t\tdev_warn(ice_hw_to_dev(hw), \"Get PHY capabilities failed status\
  \ = %d, continuing anyway\\n\",\n\t\t\t status);\n\n\t/* Initialize port_info struct\
  \ with link information */\n\tstatus = ice_aq_get_link_info(hw->port_info, false,\
  \ NULL, NULL);\n\tif (status)\n\t\tgoto err_unroll_sched;\n\n\t/* need a valid SW\
  \ entry point to build a Tx tree */\n\tif (!hw->sw_entry_point_layer) {\n\t\tice_debug(hw,\
  \ ICE_DBG_SCHED, \"invalid sw entry point\\n\");\n\t\tstatus = -EIO;\n\t\tgoto err_unroll_sched;\n\
  \t}\n\tINIT_LIST_HEAD(&hw->agg_list);\n\t/* Initialize max burst size */\n\tif (!hw->max_burst_size)\n\
  \t\tice_cfg_rl_burst_size(hw, ICE_SCHED_DFLT_BURST_SIZE);\n\n\tstatus = ice_init_fltr_mgmt_struct(hw);\n\
  \tif (status)\n\t\tgoto err_unroll_sched;\n\n\t/* Get MAC information */\n\t/* A\
  \ single port can report up to two (LAN and WoL) addresses */\n\tmac_buf = kcalloc(2,\
  \ sizeof(struct ice_aqc_manage_mac_read_resp),\n\t\t\t  GFP_KERNEL);\n\tif (!mac_buf)\
  \ {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_unroll_fltr_mgmt_struct;\n\t}\n\n\tmac_buf_len\
  \ = 2 * sizeof(struct ice_aqc_manage_mac_read_resp);\n\tstatus = ice_aq_manage_mac_read(hw,\
  \ mac_buf, mac_buf_len, NULL);\n\n\tif (status)\n\t\tgoto err_unroll_fltr_mgmt_struct;\n\
  \t/* enable jumbo frame support at MAC level */\n\tstatus = ice_aq_set_mac_cfg(hw,\
  \ ICE_AQ_SET_MAC_FRAME_SIZE_MAX, NULL);\n\tif (status)\n\t\tgoto err_unroll_fltr_mgmt_struct;\n\
  \t/* Obtain counter base index which would be used by flow director */\n\tstatus\
  \ = ice_alloc_fd_res_cntr(hw, &hw->fd_ctr_base);\n\tif (status)\n\t\tgoto err_unroll_fltr_mgmt_struct;\n\
  \tstatus = ice_init_hw_tbls(hw);\n\tif (status)\n\t\tgoto err_unroll_fltr_mgmt_struct;\n\
  \tmutex_init(&hw->tnl_lock);\n\treturn 0;\n\nerr_unroll_fltr_mgmt_struct:\n\tice_cleanup_fltr_mgmt_struct(hw);\n\
  err_unroll_sched:\n\tice_sched_cleanup_all(hw);\nerr_unroll_alloc:\n\tdevm_kfree(ice_hw_to_dev(hw),\
  \ hw->port_info);\nerr_unroll_cqinit:\n\tice_destroy_all_ctrlq(hw);\n\treturn status;\n\
  }\n```\n\n```c\n// Function: ice_update_link_info in drivers/net/ethernet/intel/ice/ice_common.c\n\
  int ice_update_link_info(struct ice_port_info *pi)\n{\n\tstruct ice_link_status\
  \ *li;\n\tint status;\n\n\tif (!pi)\n\t\treturn -EINVAL;\n\n\tli = &pi->phy.link_info;\n\
  \n\tstatus = ice_aq_get_link_info(pi, true, NULL, NULL);\n\tif (status)\n\t\treturn\
  \ status;\n\n\tif (li->link_info & ICE_AQ_MEDIA_AVAILABLE) {\n\t\tstruct ice_aqc_get_phy_caps_data\
  \ *pcaps __free(kfree);\n\n\t\tpcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);\n\t\t\
  if (!pcaps)\n\t\t\treturn -ENOMEM;\n\n\t\tstatus = ice_aq_get_phy_caps(pi, false,\
  \ ICE_AQC_REPORT_TOPO_CAP_MEDIA,\n\t\t\t\t\t     pcaps, NULL);\n\t}\n\n\treturn\
  \ status;\n}\n```\n\n```c\n// Function: ice_cfg_phy_fec in drivers/net/ethernet/intel/ice/ice_common.c\n\
  int\nice_cfg_phy_fec(struct ice_port_info *pi, struct ice_aqc_set_phy_cfg_data *cfg,\n\
  \t\tenum ice_fec_mode fec)\n{\n\tstruct ice_aqc_get_phy_caps_data *pcaps __free(kfree);\n\
  \tstruct ice_hw *hw;\n\tint status;\n\n\tif (!pi || !cfg)\n\t\treturn -EINVAL;\n\
  \n\thw = pi->hw;\n\n\tpcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);\n\tif (!pcaps)\n\
  \t\treturn -ENOMEM;\n\n\tstatus = ice_aq_get_phy_caps(pi, false,\n\t\t\t\t     (ice_fw_supports_report_dflt_cfg(hw)\
  \ ?\n\t\t\t\t      ICE_AQC_REPORT_DFLT_CFG :\n\t\t\t\t      ICE_AQC_REPORT_TOPO_CAP_MEDIA),\
  \ pcaps, NULL);\n\tif (status)\n\t\tgoto out;\n\n\tcfg->caps |= pcaps->caps & ICE_AQC_PHY_EN_AUTO_FEC;\n\
  \tcfg->link_fec_opt = pcaps->link_fec_options;\n\n\tswitch (fec) {\n\tcase ICE_FEC_BASER:\n\
  \t\t/* Clear RS bits, and AND BASE-R ability\n\t\t * bits and OR request bits.\n\
  \t\t */\n\t\tcfg->link_fec_opt &= ICE_AQC_PHY_FEC_10G_KR_40G_KR4_EN |\n\t\t\tICE_AQC_PHY_FEC_25G_KR_CLAUSE74_EN;\n\
  \t\tcfg->link_fec_opt |= ICE_AQC_PHY_FEC_10G_KR_40G_KR4_REQ |\n\t\t\tICE_AQC_PHY_FEC_25G_KR_REQ;\n\
  \t\tbreak;\n\tcase ICE_FEC_RS:\n\t\t/* Clear BASE-R bits, and AND RS ability\n\t\
  \t * bits and OR request bits.\n\t\t */\n\t\tcfg->link_fec_opt &= ICE_AQC_PHY_FEC_25G_RS_CLAUSE91_EN;\n\
  \t\tcfg->link_fec_opt |= ICE_AQC_PHY_FEC_25G_RS_528_REQ |\n\t\t\tICE_AQC_PHY_FEC_25G_RS_544_REQ;\n\
  \t\tbreak;\n\tcase ICE_FEC_NONE:\n\t\t/* Clear all FEC option bits. */\n\t\tcfg->link_fec_opt\
  \ &= ~ICE_AQC_PHY_FEC_MASK;\n\t\tbreak;\n\tcase ICE_FEC_AUTO:\n\t\t/* AND auto FEC\
  \ bit, and all caps bits. */\n\t\tcfg->caps &= ICE_AQC_PHY_CAPS_MASK;\n\t\tcfg->link_fec_opt\
  \ |= pcaps->link_fec_options;\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\
  \tbreak;\n\t}\n\n\tif (fec == ICE_FEC_AUTO && ice_fw_supports_link_override(hw)\
  \ &&\n\t    !ice_fw_supports_report_dflt_cfg(hw)) {\n\t\tstruct ice_link_default_override_tlv\
  \ tlv = { 0 };\n\n\t\tstatus = ice_get_link_default_override(&tlv, pi);\n\t\tif\
  \ (status)\n\t\t\tgoto out;\n\n\t\tif (!(tlv.options & ICE_LINK_OVERRIDE_STRICT_MODE)\
  \ &&\n\t\t    (tlv.options & ICE_LINK_OVERRIDE_EN))\n\t\t\tcfg->link_fec_opt = tlv.fec_options;\n\
  \t}\n\nout:\n\treturn status;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git\
  \ a/drivers/net/ethernet/intel/ice/ice_common.c b/drivers/net/ethernet/intel/ice/ice_common.c\n\
  index db4b2844e1f7..d9f6cc71d900 100644\n--- a/drivers/net/ethernet/intel/ice/ice_common.c\n\
  +++ b/drivers/net/ethernet/intel/ice/ice_common.c\n@@ -1002,8 +1002,8 @@ static\
  \ void ice_get_itr_intrl_gran(struct ice_hw *hw)\n  */\n int ice_init_hw(struct\
  \ ice_hw *hw)\n {\n-\tstruct ice_aqc_get_phy_caps_data *pcaps __free(kfree);\n-\t\
  void *mac_buf __free(kfree);\n+\tstruct ice_aqc_get_phy_caps_data *pcaps __free(kfree)\
  \ = NULL;\n+\tvoid *mac_buf __free(kfree) = NULL;\n \tu16 mac_buf_len;\n \tint status;\n\
  \ \n@@ -3272,7 +3272,7 @@ int ice_update_link_info(struct ice_port_info *pi)\n \t\
  \treturn status;\n \n \tif (li->link_info & ICE_AQ_MEDIA_AVAILABLE) {\n-\t\tstruct\
  \ ice_aqc_get_phy_caps_data *pcaps __free(kfree);\n+\t\tstruct ice_aqc_get_phy_caps_data\
  \ *pcaps __free(kfree) = NULL;\n \n \t\tpcaps = kzalloc(sizeof(*pcaps), GFP_KERNEL);\n\
  \ \t\tif (!pcaps)\n@@ -3420,7 +3420,7 @@ ice_cfg_phy_fc(struct ice_port_info *pi,\
  \ struct ice_aqc_set_phy_cfg_data *cfg,\n int\n ice_set_fc(struct ice_port_info\
  \ *pi, u8 *aq_failures, bool ena_auto_link_update)\n {\n-\tstruct ice_aqc_get_phy_caps_data\
  \ *pcaps __free(kfree);\n+\tstruct ice_aqc_get_phy_caps_data *pcaps __free(kfree)\
  \ = NULL;\n \tstruct ice_aqc_set_phy_cfg_data cfg = { 0 };\n \tstruct ice_hw *hw;\n\
  \ \tint status;\n@@ -3561,7 +3561,7 @@ int\n ice_cfg_phy_fec(struct ice_port_info\
  \ *pi, struct ice_aqc_set_phy_cfg_data *cfg,\n \t\tenum ice_fec_mode fec)\n {\n\
  -\tstruct ice_aqc_get_phy_caps_data *pcaps __free(kfree);\n+\tstruct ice_aqc_get_phy_caps_data\
  \ *pcaps __free(kfree) = NULL;\n \tstruct ice_hw *hw;\n \tint status;\n \ndiff --git\
  \ a/drivers/net/ethernet/intel/ice/ice_ethtool.c b/drivers/net/ethernet/intel/ice/ice_ethtool.c\n\
  index 255a9c8151b4..78b833b3e1d7 100644\n--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c\n\
  +++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c\n@@ -941,11 +941,11 @@ static\
  \ u64 ice_loopback_test(struct net_device *netdev)\n \tstruct ice_netdev_priv *np\
  \ = netdev_priv(netdev);\n \tstruct ice_vsi *orig_vsi = np->vsi, *test_vsi;\n \t\
  struct ice_pf *pf = orig_vsi->back;\n+\tu8 *tx_frame __free(kfree) = NULL;\n \t\
  u8 broadcast[ETH_ALEN], ret = 0;\n \tint num_frames, valid_frames;\n \tstruct ice_tx_ring\
  \ *tx_ring;\n \tstruct ice_rx_ring *rx_ring;\n-\tu8 *tx_frame __free(kfree);\n \t\
  int i;\n \n \tnetdev_info(netdev, \"loopback test\\n\");\n```\n"
pattern: "## Bug Pattern\n\nUsing auto-cleanup pointers (e.g., `type *p __free(kfree);`)\
  \ without initializing them to NULL, while having early returns/gotos before the\
  \ pointer is assigned. On scope exit, the cleanup will call `kfree()` on an uninitialized\
  \ (garbage) pointer.\n\nExample:\ntype *p __free(kfree);\nif (err)\n    return -EINVAL;\
  \  // triggers kfree(p) on uninitialized p\n\nFix: Initialize all `__free(kfree)`\
  \ pointers to NULL at declaration:\ntype *p __free(kfree) = NULL;"
plan: "Plan\n\n1. Program state\n- REGISTER_MAP_WITH_PROGRAMSTATE(TrackedAutoCleanup,\
  \ const VarDecl *, bool)\n  - Key: the VarDecl of a local pointer declared with\
  \ an auto-cleanup attribute using kfree.\n  - Value: initialization flag. false\
  \ = not initialized yet; true = has been assigned a value in this path.\n- No alias\
  \ tracking is needed. We only care if the pointer variable itself got a value before\
  \ any return/fallthrough.\n\n2. Callback functions and implementation details\n\n\
  - checkPostStmt(const DeclStmt *DS, CheckerContext &C)\n  - Goal: Start tracking\
  \ variables that match the bug pattern at the point of declaration.\n  - Steps:\n\
  \    1. Iterate all declarations in DS; only process VarDecl.\n    2. Filter:\n\
  \       - Local automatic storage (VD->hasLocalStorage()) and not static.\n    \
  \   - Pointer type (VD->getType()->isPointerType()).\n       - Has CleanupAttr (VD->hasAttr<CleanupAttr>()).\n\
  \       - The cleanup function is kfree (from CleanupAttr::getFunctionDecl()->getName()\
  \ == \"kfree\"). If getFunctionDecl is unavailable, fallback to obtaining the name\
  \ text via source (optional).\n    3. If the variable has an initializer:\n    \
  \   - If it is any initializer (including non-NULL), consider it initialized and\
  \ do not track it. The bug pattern specifically concerns uninitialized pointers.\n\
  \    4. If the variable has no initializer:\n       - Insert into TrackedAutoCleanup\
  \ with value false (uninitialized).\n    5. Do not emit any warning here; just start\
  \ tracking.\n\n- checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C)\n\
  \  - Goal: Mark tracked variables as initialized when they are assigned.\n  - Steps:\n\
  \    1. If Loc.getAsRegion() is a VarRegion, get the VarDecl* (VR->getDecl()).\n\
  \    2. Look up this VarDecl in TrackedAutoCleanup. If present, set its value to\
  \ true (initialized) in the state for the current path.\n  - Rationale: Covers assignments\
  \ like p = kzalloc(...), p = foo, p = NULL, etc.\n\n- checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C)\n  - Goal: Handle indirect initialization via out-parameters\
  \ where the address of the variable is passed (e.g., func(&p)).\n  - Steps:\n  \
  \  1. Iterate arguments of the call. For each argument:\n       - If it is a UnaryOperator\
  \ with opcode UO_AddrOf and its sub-expression is a DeclRefExpr referring to a VarDecl\
  \ VD.\n       - If VD is tracked in TrackedAutoCleanup, conservatively mark it initialized\
  \ (set to true).\n    2. Rationale: In the kernel, out-parameter initialization\
  \ patterns are common (e.g., foo(&p)). We assume such calls can initialize the pointer\
  \ and avoid false positives after such calls.\n\n- checkPreStmt(const ReturnStmt\
  \ *RS, CheckerContext &C)\n  - Goal: Report when returning from a function while\
  \ some tracked auto-cleanup pointers remain uninitialized.\n  - Steps:\n    1. Retrieve\
  \ current TrackedAutoCleanup map from the state.\n    2. For each entry with value\
  \ false (still uninitialized), emit a bug report at this ReturnStmt.\n       - Message:\
  \ \"Auto-cleanup pointer may be freed uninitialized; initialize to NULL.\"\n   \
  \    - Attach a note to the VarDecl declaration location to show where it was declared\
  \ without initialization.\n    3. Use generateNonFatalErrorNode and PathSensitiveBugReport.\n\
  \n- checkEndFunction(const ReturnStmt *RS, CheckerContext &C)\n  - Goal: Catch fallthrough\
  \ to end-of-function without an explicit return (the cleanup still triggers).\n\
  \  - Steps:\n    1. Same as checkPreStmt(ReturnStmt): if any tracked variable is\
  \ still uninitialized at end of function on this path, report.\n    2. Use the function\
  \ end location as the report location, and add a note pointing to the declaration.\n\
  \n3. Additional considerations\n- Function/attribute detection:\n  - Use VD->hasAttr<CleanupAttr>()\
  \ and then CleanupAttr::getFunctionDecl()->getIdentifier()->getName() to compare\
  \ to \"kfree\".\n  - Limit matching to \"kfree\" to keep the checker precise for\
  \ this bug pattern.\n- Null-initialization detection:\n  - We do not need to special-case\
  \ NULL: any initializer means the variable is initialized. We only track variables\
  \ declared without any initializer. This aligns with the pattern \u201Ctype *p __free(kfree);\u201D\
  \ that must be initialized to NULL but isn\u2019t.\n- Scope/paths:\n  - This is\
  \ path-sensitive: if, along a given path, the variable has not been assigned before\
  \ a return/end, we warn on that path only.\n- Reporting:\n  - One report per offending\
  \ variable per return/end-site. Keep the message short and precise as requested.\n\
  - Not needed:\n  - BranchCondition, evalAssume, evalCall, checkLocation, checkRegionChanges,\
  \ and alias maps are unnecessary for this pattern and would complicate the checker\
  \ without benefit."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Attr.h\"\n#include \"llvm/ADT/ImmutableMap.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program state: Track\
  \ auto-cleanup pointer locals (kfree) and whether initialized.\nREGISTER_MAP_WITH_PROGRAMSTATE(TrackedAutoCleanup,\
  \ const VarDecl *, bool)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<\n\
  \                             check::PostStmt<DeclStmt>,\n                     \
  \        check::Bind,\n                             check::PostCall,\n         \
  \                    check::PreStmt<ReturnStmt>,\n                             check::EndFunction>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Auto-cleanup pointer may be freed uninitialized\", \"\
  Memory Management\")) {}\n\n      void checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C) const;\n      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const;\n      void checkPostCall(const CallEvent &Call, CheckerContext &C)\
  \ const;\n      void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;\n\
  \      void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;\n\n\
  \   private:\n      static bool hasKfreeCleanup(const VarDecl *VD);\n      void\
  \ reportUninitializedAtExit(const Stmt *Trigger, CheckerContext &C) const;\n};\n\
  \nstatic PathDiagnosticLocation getDeclLoc(const VarDecl *VD, CheckerContext &C)\
  \ {\n  return PathDiagnosticLocation::createBegin(VD, C.getSourceManager());\n}\n\
  \nbool SAGenTestChecker::hasKfreeCleanup(const VarDecl *VD) {\n  if (!VD)\n    return\
  \ false;\n  const CleanupAttr *CA = VD->getAttr<CleanupAttr>();\n  if (!CA)\n  \
  \  return false;\n\n  if (const FunctionDecl *FD = CA->getFunctionDecl()) {\n  \
  \  if (const IdentifierInfo *II = FD->getIdentifier()) {\n      return II->getName().equals(\"\
  kfree\");\n    }\n  }\n  // If we cannot resolve the function decl, be conservative\
  \ and do not track.\n  return false;\n}\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  for (const Decl *D : DS->decls()) {\n    const auto *VD = dyn_cast<VarDecl>(D);\n\
  \    if (!VD)\n      continue;\n\n    // Only track automatic local pointers with\
  \ cleanup(kfree) and no initializer.\n    if (!VD->hasLocalStorage())\n      continue;\n\
  \n    if (VD->getStorageDuration() != SD_Automatic)\n      continue;\n\n    QualType\
  \ QT = VD->getType();\n    if (QT.isNull() || !QT->isPointerType())\n      continue;\n\
  \n    if (!hasKfreeCleanup(VD))\n      continue;\n\n    // If it has an initializer\
  \ (even non-NULL), treat as initialized; skip tracking.\n    if (VD->hasInit())\n\
  \      continue;\n\n    // Start tracking as \"not initialized\" (false).\n    State\
  \ = State->set<TrackedAutoCleanup>(VD, false);\n  }\n\n  if (State != C.getState())\n\
  \    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  const MemRegion *MR = Loc.getAsRegion();\n  if (!MR)\n    return;\n\n  if (const\
  \ auto *VR = dyn_cast<VarRegion>(MR->getBaseRegion())) {\n    const VarDecl *VD\
  \ = VR->getDecl();\n    if (!VD)\n      return;\n\n    const bool *Tracked = State->get<TrackedAutoCleanup>(VD);\n\
  \    if (Tracked) {\n      // Any assignment counts as initialization.\n      State\
  \ = State->set<TrackedAutoCleanup>(VD, true);\n      C.addTransition(State);\n \
  \   }\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  // If an argument is\
  \ &var where var is tracked, conservatively treat it as initialized.\n  for (unsigned\
  \ i = 0, e = Call.getNumArgs(); i < e; ++i) {\n    const Expr *ArgE = Call.getArgExpr(i);\n\
  \    if (!ArgE)\n      continue;\n\n    const Expr *E = ArgE->IgnoreParenCasts();\n\
  \    const UnaryOperator *UO = dyn_cast<UnaryOperator>(E);\n    if (!UO || UO->getOpcode()\
  \ != UO_AddrOf)\n      continue;\n\n    const Expr *Sub = UO->getSubExpr();\n  \
  \  if (!Sub)\n      continue;\n    Sub = Sub->IgnoreParenCasts();\n\n    if (const\
  \ auto *DRE = dyn_cast<DeclRefExpr>(Sub)) {\n      const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n\
  \      if (!VD)\n        continue;\n\n      const bool *Tracked = State->get<TrackedAutoCleanup>(VD);\n\
  \      if (Tracked && *Tracked == false) {\n        State = State->set<TrackedAutoCleanup>(VD,\
  \ true);\n      }\n    }\n  }\n\n  if (State != C.getState())\n    C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::reportUninitializedAtExit(const Stmt *Trigger, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  auto Map = State->get<TrackedAutoCleanup>();\n\
  \n  for (auto I = Map.begin(), E = Map.end(); I != E; ++I) {\n    const VarDecl\
  \ *VD = I->first;\n    bool Inited = I->second;\n    if (!Inited) {\n      ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n      if (!N)\n        continue;\n\n    \
  \  auto R = std::make_unique<PathSensitiveBugReport>(\n          *BT, \"Auto-cleanup\
  \ pointer may be freed uninitialized; initialize to NULL\", N);\n\n      if (Trigger)\n\
  \        R->addRange(Trigger->getSourceRange());\n\n      R->addNote(\"Declared\
  \ here without initializer\", getDeclLoc(VD, C));\n      C.emitReport(std::move(R));\n\
  \    }\n  }\n}\n\nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt *RS, CheckerContext\
  \ &C) const {\n  // On any return, if there is an uninitialized tracked auto-cleanup\
  \ ptr, report.\n  reportUninitializedAtExit(RS, C);\n}\n\nvoid SAGenTestChecker::checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C) const {\n  // Catch fallthrough to end of function\
  \ (no explicit return).\n  reportUninitializedAtExit(RS, C);\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects auto-cleanup (kfree) pointers not initialized to NULL before\
  \ early exit\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 2
tp_score: 0
