_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 97cba232549b9fe7e491fb60a69cf93075015f29
commit_type: Buffer-Overflow
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/ParentMapContext.h\"\n#include \"clang/AST/Type.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states are required for this checker.\n\nnamespace {\n/* The\
  \ checker callbacks are to be decided. */\nclass SAGenTestChecker : public Checker<check::ASTCodeBody>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Off-by-one array access\", \"Array bounds\")) {}\n\n\
  \      void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter &BR)\
  \ const;\n\n   private:\n\n      // Helper predicates and analyzers\n      static\
  \ const VarDecl *getCanonicalVarDecl(const VarDecl *V) {\n        return V ? V->getCanonicalDecl()\
  \ : nullptr;\n      }\n\n      static bool isIntLiteralOne(const Expr *E) {\n  \
  \      if (!E) return false;\n        E = E->IgnoreParenImpCasts();\n        if\
  \ (const auto *IL = dyn_cast<IntegerLiteral>(E)) {\n          return IL->getValue()\
  \ == 1;\n        }\n        return false;\n      }\n\n      static bool isRefToVar(const\
  \ Expr *E, const VarDecl *V) {\n        if (!E || !V) return false;\n        E =\
  \ E->IgnoreParenImpCasts();\n        if (const auto *DRE = dyn_cast<DeclRefExpr>(E))\
  \ {\n          if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n       \
  \     return VD->getCanonicalDecl() == getCanonicalVarDecl(V);\n        }\n    \
  \    return false;\n      }\n\n      static bool isVarPlusOne(const Expr *E, const\
  \ VarDecl *V) {\n        if (!E || !V) return false;\n        E = E->IgnoreParenImpCasts();\n\
  \        const auto *BO = dyn_cast<BinaryOperator>(E);\n        if (!BO) return\
  \ false;\n        if (BO->getOpcode() != BO_Add) return false;\n        const Expr\
  \ *L = BO->getLHS();\n        const Expr *R = BO->getRHS();\n        if ((isRefToVar(L,\
  \ V) && isIntLiteralOne(R)) ||\n            (isIntLiteralOne(L) && isRefToVar(R,\
  \ V)))\n          return true;\n        return false;\n      }\n\n      static bool\
  \ isMinusOneAdjustedExpr(const Expr *E) {\n        if (!E) return false;\n     \
  \   E = E->IgnoreParenImpCasts();\n        const auto *BO = dyn_cast<BinaryOperator>(E);\n\
  \        if (!BO) return false;\n        if (BO->getOpcode() != BO_Sub) return false;\n\
  \        return isIntLiteralOne(BO->getRHS());\n      }\n\n      static const VarDecl\
  \ *getInductionVarFromInit(const Stmt *Init) {\n        if (!Init) return nullptr;\n\
  \n        if (const auto *DS = dyn_cast<DeclStmt>(Init)) {\n          if (!DS->isSingleDecl())\
  \ return nullptr;\n          const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());\n\
  \          if (!VD) return nullptr;\n          if (!VD->getType()->isIntegerType())\
  \ return nullptr;\n          return getCanonicalVarDecl(VD);\n        }\n\n    \
  \    if (const auto *BO = dyn_cast<BinaryOperator>(Init)) {\n          if (BO->getOpcode()\
  \ != BO_Assign) return nullptr;\n          const Expr *LHS = BO->getLHS();\n   \
  \       const auto *DRE = dyn_cast<DeclRefExpr>(LHS->IgnoreParenImpCasts());\n \
  \         if (!DRE) return nullptr;\n          const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n\
  \          if (!VD) return nullptr;\n          if (!VD->getType()->isIntegerType())\
  \ return nullptr;\n          return getCanonicalVarDecl(VD);\n        }\n\n    \
  \    return nullptr;\n      }\n\n      static bool isUnitStepIncrement(const Expr\
  \ *Inc, const VarDecl *V) {\n        if (!Inc || !V) return false;\n        Inc\
  \ = Inc->IgnoreParenImpCasts();\n\n        if (const auto *UO = dyn_cast<UnaryOperator>(Inc))\
  \ {\n          if (UO->isIncrementOp() && isRefToVar(UO->getSubExpr(), V))\n   \
  \         return true;\n        }\n\n        if (const auto *CAO = dyn_cast<CompoundAssignOperator>(Inc))\
  \ {\n          if (CAO->getOpcode() == BO_AddAssign && isRefToVar(CAO->getLHS(),\
  \ V) &&\n              isIntLiteralOne(CAO->getRHS()))\n            return true;\n\
  \        }\n\n        if (const auto *BO = dyn_cast<BinaryOperator>(Inc)) {\n  \
  \        if (BO->getOpcode() == BO_Assign && isRefToVar(BO->getLHS(), V)) {\n  \
  \          const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n            if\
  \ (const auto *BO2 = dyn_cast<BinaryOperator>(RHS)) {\n              if (BO2->getOpcode()\
  \ == BO_Add) {\n                const Expr *L = BO2->getLHS();\n               \
  \ const Expr *R = BO2->getRHS();\n                if ((isRefToVar(L, V) && isIntLiteralOne(R))\
  \ ||\n                    (isRefToVar(R, V) && isIntLiteralOne(L)))\n          \
  \        return true;\n              }\n            }\n          }\n        }\n\n\
  \        return false;\n      }\n\n      static bool analyzeLoopCondition(const\
  \ Expr *Cond, const VarDecl *V,\n                                       bool &IsStrictUpper,\
  \ bool &IsMinusOneAdjusted) {\n        IsStrictUpper = false;\n        IsMinusOneAdjusted\
  \ = false;\n\n        if (!Cond || !V) return false;\n        const auto *BO = dyn_cast<BinaryOperator>(Cond->IgnoreParenImpCasts());\n\
  \        if (!BO) return false;\n\n        const Expr *L = BO->getLHS();\n     \
  \   const Expr *R = BO->getRHS();\n\n        switch (BO->getOpcode()) {\n      \
  \  case BO_LT:\n          if (isRefToVar(L, V)) {\n            IsStrictUpper = true;\n\
  \            if (isMinusOneAdjustedExpr(R))\n              IsMinusOneAdjusted =\
  \ true;\n            return true;\n          }\n          break;\n        case BO_GT:\n\
  \          if (isRefToVar(R, V)) {\n            IsStrictUpper = true;\n        \
  \    if (isMinusOneAdjustedExpr(L))\n              IsMinusOneAdjusted = true;\n\
  \            return true;\n          }\n          break;\n        case BO_LE:\n\
  \          if (isRefToVar(L, V) && isMinusOneAdjustedExpr(R)) {\n            IsStrictUpper\
  \ = false;\n            IsMinusOneAdjusted = true;\n            return true;\n \
  \         }\n          break;\n        case BO_GE:\n          if (isRefToVar(R,\
  \ V) && isMinusOneAdjustedExpr(L)) {\n            IsStrictUpper = false;\n     \
  \       IsMinusOneAdjusted = true;\n            return true;\n          }\n    \
  \      break;\n        default:\n          break;\n        }\n        return false;\n\
  \      }\n\n      static bool guardInCondition(const Expr *Cond, const VarDecl *V)\
  \ {\n        if (!Cond || !V) return false;\n        const Expr *C = Cond->IgnoreParenImpCasts();\n\
  \n        if (const auto *BO = dyn_cast<BinaryOperator>(C)) {\n          // Handle\
  \ logical-AND by searching either side for a valid guard.\n          if (BO->getOpcode()\
  \ == BO_LAnd) {\n            return guardInCondition(BO->getLHS(), V) || guardInCondition(BO->getRHS(),\
  \ V);\n          }\n\n          const Expr *L = BO->getLHS();\n          const Expr\
  \ *R = BO->getRHS();\n          // i + 1 < X or i + 1 <= X\n          if ((BO->getOpcode()\
  \ == BO_LT || BO->getOpcode() == BO_LE) &&\n              (isVarPlusOne(L, V)))\
  \ {\n            return true;\n          }\n          // i < X - 1 or i <= X - 1\n\
  \          if ((BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE) &&\n     \
  \         isRefToVar(L, V) && isMinusOneAdjustedExpr(R)) {\n            return true;\n\
  \          }\n        }\n        return false;\n      }\n\n      static bool hasLocalGuardForASE(ASTContext\
  \ &Ctx, const ArraySubscriptExpr *ASE,\n                                      const\
  \ ForStmt *FS, const VarDecl *V) {\n        if (!ASE || !FS || !V) return false;\n\
  \n        llvm::SmallVector<DynTypedNode, 8> Worklist;\n        llvm::SmallPtrSet<const\
  \ void *, 32> Visited;\n\n        Worklist.push_back(DynTypedNode::create<const\
  \ Stmt>(*ASE));\n\n        while (!Worklist.empty()) {\n          DynTypedNode Node\
  \ = Worklist.pop_back_val();\n          auto Parents = Ctx.getParents(Node);\n \
  \         for (const auto &P : Parents) {\n            const Stmt *PS = P.get<Stmt>();\n\
  \            if (!PS) continue;\n\n            if (Visited.contains(PS))\n     \
  \         continue;\n            Visited.insert(PS);\n\n            if (const auto\
  \ *IFS = dyn_cast<IfStmt>(PS)) {\n              const Expr *Cond = IFS->getCond();\n\
  \              if (guardInCondition(Cond, V))\n                return true;\n  \
  \          }\n\n            if (PS == FS)\n              continue; // Reached the\
  \ loop boundary on this path.\n\n            Worklist.push_back(P);\n          }\n\
  \        }\n\n        return false;\n      }\n\n      void analyzeForStmt(const\
  \ ForStmt *FS, ASTContext &Ctx, BugReporter &BR) const {\n        if (!FS) return;\n\
  \n        const VarDecl *IVar = getInductionVarFromInit(FS->getInit());\n      \
  \  if (!IVar) return;\n\n        bool IsStrictUpper = false;\n        bool IsMinusOneAdjusted\
  \ = false;\n        const Expr *Cond = FS->getCond();\n        if (!Cond) return;\n\
  \        if (!analyzeLoopCondition(Cond, IVar, IsStrictUpper, IsMinusOneAdjusted))\n\
  \          return;\n\n        // Skip loops that already use (bound - 1).\n    \
  \    if (IsMinusOneAdjusted) return;\n\n        // We only flag loops with strict\
  \ upper bounds like i < N or N > i.\n        if (!IsStrictUpper) return;\n\n   \
  \     // Ensure unit-step increment on i.\n        if (!isUnitStepIncrement(FS->getInc(),\
  \ IVar))\n          return;\n\n        // Traverse the loop body and find a[i +\
  \ 1]\n        struct BodyVisitor : public RecursiveASTVisitor<BodyVisitor> {\n \
  \         const SAGenTestChecker *Checker;\n          const ForStmt *FS;\n     \
  \     const VarDecl *IVar;\n          ASTContext &Ctx;\n          BugReporter &BR;\n\
  \          const BugType &BT;\n\n          BodyVisitor(const SAGenTestChecker *Checker,\
  \ const ForStmt *FS,\n                      const VarDecl *IVar, ASTContext &Ctx,\n\
  \                      BugReporter &BR, const BugType &BT)\n              : Checker(Checker),\
  \ FS(FS), IVar(IVar), Ctx(Ctx), BR(BR), BT(BT) {}\n\n          bool VisitArraySubscriptExpr(ArraySubscriptExpr\
  \ *ASE) {\n            if (!ASE) return true;\n            const Expr *Idx = ASE->getIdx()->IgnoreParenImpCasts();\n\
  \            // Only consider indices of the form i + 1 or 1 + i.\n            if\
  \ (!Checker->isVarPlusOne(Idx, IVar))\n              return true;\n\n          \
  \  // Check for a local guard like \"if (i + 1 < X)\" or \"if (i < X - 1)\".\n \
  \           if (Checker->hasLocalGuardForASE(Ctx, ASE, FS, IVar))\n            \
  \  return true;\n\n            // Report the potential off-by-one.\n           \
  \ PathDiagnosticLocation ELoc =\n                PathDiagnosticLocation::createBegin(ASE,\
  \ BR.getSourceManager(), nullptr);\n\n            auto R = std::make_unique<BasicBugReport>(\n\
  \                BT,\n                \"Possible off-by-one: loop uses i < bound\
  \ but also accesses a[i + 1]\",\n                ELoc);\n            R->addRange(ASE->getSourceRange());\n\
  \n            // Optionally, highlight the loop condition too.\n            if (const\
  \ Expr *Cond = FS->getCond()) {\n              R->addRange(Cond->getSourceRange());\n\
  \            }\n\n            BR.emitReport(std::move(R));\n            return true;\n\
  \          }\n        };\n\n        BodyVisitor V(this, FS, IVar, Ctx, BR, *BT);\n\
  \        if (const Stmt *Body = FS->getBody())\n          V.TraverseStmt(const_cast<Stmt\
  \ *>(Body));\n      }\n};\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl\
  \ *D, AnalysisManager &Mgr, BugReporter &BR) const {\n  if (!D) return;\n  const\
  \ Stmt *Body = D->getBody();\n  if (!Body) return;\n\n  // Visit all ForStmt nodes\
  \ and analyze them.\n  struct TopVisitor : public RecursiveASTVisitor<TopVisitor>\
  \ {\n    const SAGenTestChecker *Checker;\n    ASTContext &Ctx;\n    BugReporter\
  \ &BR;\n\n    TopVisitor(const SAGenTestChecker *Checker, ASTContext &Ctx, BugReporter\
  \ &BR)\n        : Checker(Checker), Ctx(Ctx), BR(BR) {}\n\n    bool VisitForStmt(ForStmt\
  \ *FS) {\n      Checker->analyzeForStmt(FS, Ctx, BR);\n      return true;\n    }\n\
  \  };\n\n  TopVisitor TV(this, Mgr.getASTContext(), BR);\n  TV.TraverseStmt(const_cast<Stmt\
  \ *>(Body));\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects off-by-one array access in loops (i < N with a[i + 1])\",\n \
  \     \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Fix buffer overflow in 'get_host_router_total_dp_tunnel_bw()'\n\
  \nThe error message buffer overflow 'dc->links' 12 <= 12 suggests that the\ncode\
  \ is trying to access an element of the dc->links array that is\nbeyond its bounds.\
  \ In C, arrays are zero-indexed, so an array with 12\nelements has valid indices\
  \ from 0 to 11. Trying to access dc->links[12]\nwould be an attempt to access the\
  \ 13th element of a 12-element array,\nwhich is a buffer overflow.\n\nTo fix this,\
  \ ensure that the loop does not go beyond the last valid\nindex when accessing dc->links[i\
  \ + 1] by subtracting 1 from the loop\ncondition.\n\nThis would ensure that i +\
  \ 1 is always a valid index in the array.\n\nFixes the below:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/link/protocols/link_dp_dpia_bw.c:208\
  \ get_host_router_total_dp_tunnel_bw() error: buffer overflow 'dc->links' 12 <=\
  \ 12\n\nFixes: 59f1622a5f05 (\"drm/amd/display: Add dpia display mode validation\
  \ logic\")\nCc: PeiChen Huang <peichen.huang@amd.com>\nCc: Aric Cyr <aric.cyr@amd.com>\n\
  Cc: Rodrigo Siqueira <rodrigo.siqueira@amd.com>\nCc: Aurabindo Pillai <aurabindo.pillai@amd.com>\n\
  Cc: Meenakshikumar Somasundaram <meenakshikumar.somasundaram@amd.com>\nSigned-off-by:\
  \ Srinivasan Shanmugam <srinivasan.shanmugam@amd.com>\nReviewed-by: Tom Chung <chiahsuan.chung@amd.com>\n\
  Signed-off-by: Alex Deucher <alexander.deucher@amd.com>\n\n## Buggy Code\n\n```c\n\
  // Function: get_host_router_total_dp_tunnel_bw in drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_dpia_bw.c\n\
  static int get_host_router_total_dp_tunnel_bw(const struct dc *dc, uint8_t hr_index)\n\
  {\n\tuint8_t lowest_dpia_index = get_lowest_dpia_index(dc->links[0]);\n\tuint8_t\
  \ hr_index_temp = 0;\n\tstruct dc_link *link_dpia_primary, *link_dpia_secondary;\n\
  \tint total_bw = 0;\n\n\tfor (uint8_t i = 0; i < MAX_PIPES * 2; ++i) {\n\n\t\tif\
  \ (!dc->links[i] || dc->links[i]->ep_type != DISPLAY_ENDPOINT_USB4_DPIA)\n\t\t\t\
  continue;\n\n\t\thr_index_temp = (dc->links[i]->link_index - lowest_dpia_index)\
  \ / 2;\n\n\t\tif (hr_index_temp == hr_index) {\n\t\t\tlink_dpia_primary = dc->links[i];\n\
  \t\t\tlink_dpia_secondary = dc->links[i + 1];\n\n\t\t\t/**\n\t\t\t * If BW allocation\
  \ enabled on both DPIAs, then\n\t\t\t * HR BW = Estimated(dpia_primary) + Allocated(dpia_secondary)\n\
  \t\t\t * otherwise HR BW = Estimated(bw alloc enabled dpia)\n\t\t\t */\n\t\t\tif\
  \ ((link_dpia_primary->hpd_status &&\n\t\t\t\tlink_dpia_primary->dpia_bw_alloc_config.bw_alloc_enabled)\
  \ &&\n\t\t\t\t(link_dpia_secondary->hpd_status &&\n\t\t\t\tlink_dpia_secondary->dpia_bw_alloc_config.bw_alloc_enabled))\
  \ {\n\t\t\t\t\ttotal_bw += link_dpia_primary->dpia_bw_alloc_config.estimated_bw\
  \ +\n\t\t\t\t\t\tlink_dpia_secondary->dpia_bw_alloc_config.allocated_bw;\n\t\t\t\
  } else if (link_dpia_primary->hpd_status &&\n\t\t\t\t\tlink_dpia_primary->dpia_bw_alloc_config.bw_alloc_enabled)\
  \ {\n\t\t\t\ttotal_bw = link_dpia_primary->dpia_bw_alloc_config.estimated_bw;\n\t\
  \t\t} else if (link_dpia_secondary->hpd_status &&\n\t\t\t\tlink_dpia_secondary->dpia_bw_alloc_config.bw_alloc_enabled)\
  \ {\n\t\t\t\ttotal_bw += link_dpia_secondary->dpia_bw_alloc_config.estimated_bw;\n\
  \t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn total_bw;\n}\n```\n\n## Bug Fix Patch\n\
  \n```diff\ndiff --git a/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_dpia_bw.c\
  \ b/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_dpia_bw.c\nindex dd0d2b206462..5491b707cec8\
  \ 100644\n--- a/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_dpia_bw.c\n\
  +++ b/drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_dpia_bw.c\n@@ -196,7\
  \ +196,7 @@ static int get_host_router_total_dp_tunnel_bw(const struct dc *dc, uint8_t\
  \ hr_in\n \tstruct dc_link *link_dpia_primary, *link_dpia_secondary;\n \tint total_bw\
  \ = 0;\n \n-\tfor (uint8_t i = 0; i < MAX_PIPES * 2; ++i) {\n+\tfor (uint8_t i =\
  \ 0; i < (MAX_PIPES * 2) - 1; ++i) {\n \n \t\tif (!dc->links[i] || dc->links[i]->ep_type\
  \ != DISPLAY_ENDPOINT_USB4_DPIA)\n \t\t\tcontinue;\n```\n"
pattern: "## Bug Pattern\n\nOff-by-one array access caused by iterating to the last\
  \ valid index while also accessing the next element:\n\nfor (i = 0; i < N; i++)\
  \ {\n    use(a[i]);\n    use(a[i + 1]); // out-of-bounds when i == N - 1\n}\n\n\
  Root cause: a loop uses condition i < N, but the body reads a[i + 1] without ensuring\
  \ i + 1 < N. The fix is to bound the loop to i < N - 1 (or guard the a[i + 1] access)."
plan: "1) Program state\n- Do not introduce any custom program state. This checker\
  \ can be implemented as a purely AST-pattern detector; no inter-path reasoning or\
  \ alias tracking is required.\n\n2) Callbacks and high-level flow\n- Use checkASTCodeBody\
  \ to scan function bodies and detect the target pattern in loop constructs.\n- No\
  \ other callbacks are necessary.\n\n3) Loop and induction variable identification\
  \ (in checkASTCodeBody)\n- Traverse the body\u2019s AST and focus on ForStmt nodes\
  \ (optionally extend to WhileStmt later; start with ForStmt to keep it simple).\n\
  - For each ForStmt FS:\n  - Extract the induction variable i:\n    - From FS->getInit():\n\
  \      - DeclStmt: single VarDecl with integer type, record the VarDecl* IVar (initializer\
  \ can be ignored).\n      - Or BinaryOperator \u2018=\u2019: LHS should be DeclRefExpr\
  \ to a variable; record that variable as IVar.\n  - Extract the loop condition Cond:\n\
  \    - Must be a BinaryOperator with one of the following:\n      - i < Bound\n\
  \      - Bound > i\n      - i <= BoundMinusOne (safe bound; skip)\n      - BoundMinusOne\
  \ >= i (safe bound; skip)\n    - Normalize to determine:\n      - IsStrictUpperBound:\
  \ true if it is strictly i < Bound or Bound > i.\n      - IsMinusOneAdjusted: true\
  \ if the non-strict case uses \u201C- 1\u201D (i <= Bound - 1 or Bound - 1 >= i).\
  \ If IsMinusOneAdjusted, skip reporting for this loop, as it already enforces i+1\
  \ < Bound.\n    - For strict cases (IsStrictUpperBound == true), further check that\
  \ the RHS/LHS is not an explicit \u201C... - 1\u201D to avoid false positives when\
  \ the author already used (Bound - 1) explicitly:\n      - If the Bound side is\
  \ a BinaryOperator \u2018-\u2019 with RHS IntegerLiteral(1), treat as IsMinusOneAdjusted\
  \ and skip.\n  - Extract the increment Inc:\n    - Prefer simple forms: i++, ++i,\
  \ i += 1, or i = i + 1. If increment does not affect i or is not a unit-step increment,\
  \ skip the loop to reduce false positives.\n\n4) Finding suspicious array accesses\
  \ a[i + 1]\n- Within the loop body FS->getBody(), recursively visit ArraySubscriptExpr\
  \ (ASE) nodes.\n- For each ASE:\n  - Let Idx = ASE->getIdx()->IgnoreParenImpCasts().\n\
  \  - Check if Idx is exactly i + 1 (or 1 + i):\n    - BinaryOperator \u2018+\u2019\
  \ with operands (DeclRefExpr to IVar, IntegerLiteral(1)) or (IntegerLiteral(1),\
  \ DeclRefExpr to IVar).\n    - Ignore all other offsets or complex expressions to\
  \ keep checker simple and precise.\n- If an a[i + 1] access is found and the loop\u2019\
  s IsStrictUpperBound is true (from step 3), this is a candidate for off-by-one risk.\n\
  \n5) Guard detection to reduce false positives\n- Before reporting for an ASE, try\
  \ to detect a local guard:\n  - Walk up the AST from ASE using findSpecificTypeInParents\
  \ to find the nearest enclosing IfStmt that is inside the same loop body (stop when\
  \ reaching the ForStmt).\n  - Inspect the IfStmt\u2019s condition:\n    - If the\
  \ condition is of the form:\n      - i + 1 < X (i.e., BinaryOperator \u2018<\u2019\
  \ or \u2018<=\u2019 where LHS is i + 1), or\n      - i < X - 1 (LHS i; RHS BinaryOperator\
  \ \u2018-\u2019 with IntegerLiteral(1)),\n      then treat as guarded and do not\
  \ report.\n  - Implementation details:\n    - For i + 1 < X: condition is BinaryOperator\
  \ with opcode LT or LE, whose LHS is BinaryOperator \u2018+\u2019 (i, 1) or (1,\
  \ i).\n    - For i < X - 1: condition is BinaryOperator with opcode LT or LE, whose\
  \ LHS is i, and RHS is BinaryOperator \u2018-\u2019 with IntegerLiteral(1).\n  -\
  \ Optionally, as a fallback in tricky conditions, use ExprHasName on the If condition\
  \ to look for \u201Ci + 1\u201D when AST-matching fails, but prefer AST-based checks\
  \ first.\n\n6) Reporting\n- When a[i + 1] is found, IsStrictUpperBound is true,\
  \ and no local guard is detected:\n  - Create a non-fatal error node with C.generateNonFatalErrorNode().\n\
  \  - Emit a PathSensitiveBugReport with a short message, e.g.:\n    - \u201CPossible\
  \ off-by-one: loop uses i < bound but also accesses a[i + 1].\u201D\n  - Attach\
  \ the primary location to the ArraySubscriptExpr \u2018[i + 1]\u2019.\n  - Optionally\
  \ add a note at the ForStmt condition source location to highlight the i < Bound\
  \ condition.\n\n7) Notes and heuristics\n- Keep matching conservative:\n  - Only\
  \ flag exact i + 1 accesses to avoid noise.\n  - Only flag loops where the upper\
  \ bound is a strict inequality without explicit \u201C- 1\u201D.\n  - Require unit-step\
  \ increment on i.\n- Array base expression type is not required to be a fixed-size\
  \ array; we only care about the logical off-by-one pattern. Do not try to compute\
  \ array length; the pattern is unsafe regardless of the exact size if the loop condition\
  \ does not account for the +1 access.\n- Utility functions used:\n  - findSpecificTypeInParents:\
  \ to find enclosing IfStmt for guard detection.\n  - findSpecificTypeInChildren:\
  \ can be used if you choose a simpler body-scan approach, but a small recursive\
  \ visitor over the loop body is straightforward.\n  - ExprHasName: optional fallback\
  \ guard detection when AST pattern fails.\n\n8) Minimal implementation outline per\
  \ ForStmt\n- Extract IVar, Cond, Inc; determine IsStrictUpperBound and IsMinusOneAdjusted.\n\
  - If IsStrictUpperBound and not IsMinusOneAdjusted:\n  - Scan body for ASE with\
  \ index i + 1.\n  - For each such ASE, check guard via nearest IfStmt as described.\n\
  \  - If unguarded, report."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/ParentMapContext.h\"\n#include \"clang/AST/Type.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states are required for this checker.\n\nnamespace {\n/* The\
  \ checker callbacks are to be decided. */\nclass SAGenTestChecker : public Checker<check::ASTCodeBody>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Off-by-one array access\", \"Array bounds\")) {}\n\n\
  \      void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter &BR)\
  \ const;\n\n   private:\n\n      // Helper predicates and analyzers\n      static\
  \ const VarDecl *getCanonicalVarDecl(const VarDecl *V) {\n        return V ? V->getCanonicalDecl()\
  \ : nullptr;\n      }\n\n      static bool isIntLiteralOne(const Expr *E) {\n  \
  \      if (!E) return false;\n        E = E->IgnoreParenImpCasts();\n        if\
  \ (const auto *IL = dyn_cast<IntegerLiteral>(E)) {\n          return IL->getValue()\
  \ == 1;\n        }\n        return false;\n      }\n\n      static bool isRefToVar(const\
  \ Expr *E, const VarDecl *V) {\n        if (!E || !V) return false;\n        E =\
  \ E->IgnoreParenImpCasts();\n        if (const auto *DRE = dyn_cast<DeclRefExpr>(E))\
  \ {\n          if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n       \
  \     return VD->getCanonicalDecl() == getCanonicalVarDecl(V);\n        }\n    \
  \    return false;\n      }\n\n      static bool isVarPlusOne(const Expr *E, const\
  \ VarDecl *V) {\n        if (!E || !V) return false;\n        E = E->IgnoreParenImpCasts();\n\
  \        const auto *BO = dyn_cast<BinaryOperator>(E);\n        if (!BO) return\
  \ false;\n        if (BO->getOpcode() != BO_Add) return false;\n        const Expr\
  \ *L = BO->getLHS();\n        const Expr *R = BO->getRHS();\n        if ((isRefToVar(L,\
  \ V) && isIntLiteralOne(R)) ||\n            (isIntLiteralOne(L) && isRefToVar(R,\
  \ V)))\n          return true;\n        return false;\n      }\n\n      static bool\
  \ isMinusOneAdjustedExpr(const Expr *E) {\n        if (!E) return false;\n     \
  \   E = E->IgnoreParenImpCasts();\n        const auto *BO = dyn_cast<BinaryOperator>(E);\n\
  \        if (!BO) return false;\n        if (BO->getOpcode() != BO_Sub) return false;\n\
  \        return isIntLiteralOne(BO->getRHS());\n      }\n\n      static const VarDecl\
  \ *getInductionVarFromInit(const Stmt *Init) {\n        if (!Init) return nullptr;\n\
  \n        if (const auto *DS = dyn_cast<DeclStmt>(Init)) {\n          if (!DS->isSingleDecl())\
  \ return nullptr;\n          const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());\n\
  \          if (!VD) return nullptr;\n          if (!VD->getType()->isIntegerType())\
  \ return nullptr;\n          return getCanonicalVarDecl(VD);\n        }\n\n    \
  \    if (const auto *BO = dyn_cast<BinaryOperator>(Init)) {\n          if (BO->getOpcode()\
  \ != BO_Assign) return nullptr;\n          const Expr *LHS = BO->getLHS();\n   \
  \       const auto *DRE = dyn_cast<DeclRefExpr>(LHS->IgnoreParenImpCasts());\n \
  \         if (!DRE) return nullptr;\n          const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n\
  \          if (!VD) return nullptr;\n          if (!VD->getType()->isIntegerType())\
  \ return nullptr;\n          return getCanonicalVarDecl(VD);\n        }\n\n    \
  \    return nullptr;\n      }\n\n      static bool isUnitStepIncrement(const Expr\
  \ *Inc, const VarDecl *V) {\n        if (!Inc || !V) return false;\n        Inc\
  \ = Inc->IgnoreParenImpCasts();\n\n        if (const auto *UO = dyn_cast<UnaryOperator>(Inc))\
  \ {\n          if (UO->isIncrementOp() && isRefToVar(UO->getSubExpr(), V))\n   \
  \         return true;\n        }\n\n        if (const auto *CAO = dyn_cast<CompoundAssignOperator>(Inc))\
  \ {\n          if (CAO->getOpcode() == BO_AddAssign && isRefToVar(CAO->getLHS(),\
  \ V) &&\n              isIntLiteralOne(CAO->getRHS()))\n            return true;\n\
  \        }\n\n        if (const auto *BO = dyn_cast<BinaryOperator>(Inc)) {\n  \
  \        if (BO->getOpcode() == BO_Assign && isRefToVar(BO->getLHS(), V)) {\n  \
  \          const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n            if\
  \ (const auto *BO2 = dyn_cast<BinaryOperator>(RHS)) {\n              if (BO2->getOpcode()\
  \ == BO_Add) {\n                const Expr *L = BO2->getLHS();\n               \
  \ const Expr *R = BO2->getRHS();\n                if ((isRefToVar(L, V) && isIntLiteralOne(R))\
  \ ||\n                    (isRefToVar(R, V) && isIntLiteralOne(L)))\n          \
  \        return true;\n              }\n            }\n          }\n        }\n\n\
  \        return false;\n      }\n\n      static bool analyzeLoopCondition(const\
  \ Expr *Cond, const VarDecl *V,\n                                       bool &IsStrictUpper,\
  \ bool &IsMinusOneAdjusted) {\n        IsStrictUpper = false;\n        IsMinusOneAdjusted\
  \ = false;\n\n        if (!Cond || !V) return false;\n        const auto *BO = dyn_cast<BinaryOperator>(Cond->IgnoreParenImpCasts());\n\
  \        if (!BO) return false;\n\n        const Expr *L = BO->getLHS();\n     \
  \   const Expr *R = BO->getRHS();\n\n        switch (BO->getOpcode()) {\n      \
  \  case BO_LT:\n          if (isRefToVar(L, V)) {\n            IsStrictUpper = true;\n\
  \            if (isMinusOneAdjustedExpr(R))\n              IsMinusOneAdjusted =\
  \ true;\n            return true;\n          }\n          break;\n        case BO_GT:\n\
  \          if (isRefToVar(R, V)) {\n            IsStrictUpper = true;\n        \
  \    if (isMinusOneAdjustedExpr(L))\n              IsMinusOneAdjusted = true;\n\
  \            return true;\n          }\n          break;\n        case BO_LE:\n\
  \          if (isRefToVar(L, V) && isMinusOneAdjustedExpr(R)) {\n            IsStrictUpper\
  \ = false;\n            IsMinusOneAdjusted = true;\n            return true;\n \
  \         }\n          break;\n        case BO_GE:\n          if (isRefToVar(R,\
  \ V) && isMinusOneAdjustedExpr(L)) {\n            IsStrictUpper = false;\n     \
  \       IsMinusOneAdjusted = true;\n            return true;\n          }\n    \
  \      break;\n        default:\n          break;\n        }\n        return false;\n\
  \      }\n\n      static bool guardInCondition(const Expr *Cond, const VarDecl *V)\
  \ {\n        if (!Cond || !V) return false;\n        const Expr *C = Cond->IgnoreParenImpCasts();\n\
  \n        if (const auto *BO = dyn_cast<BinaryOperator>(C)) {\n          // Handle\
  \ logical-AND by searching either side for a valid guard.\n          if (BO->getOpcode()\
  \ == BO_LAnd) {\n            return guardInCondition(BO->getLHS(), V) || guardInCondition(BO->getRHS(),\
  \ V);\n          }\n\n          const Expr *L = BO->getLHS();\n          const Expr\
  \ *R = BO->getRHS();\n          // i + 1 < X or i + 1 <= X\n          if ((BO->getOpcode()\
  \ == BO_LT || BO->getOpcode() == BO_LE) &&\n              (isVarPlusOne(L, V)))\
  \ {\n            return true;\n          }\n          // i < X - 1 or i <= X - 1\n\
  \          if ((BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE) &&\n     \
  \         isRefToVar(L, V) && isMinusOneAdjustedExpr(R)) {\n            return true;\n\
  \          }\n        }\n        return false;\n      }\n\n      static bool hasLocalGuardForASE(ASTContext\
  \ &Ctx, const ArraySubscriptExpr *ASE,\n                                      const\
  \ ForStmt *FS, const VarDecl *V) {\n        if (!ASE || !FS || !V) return false;\n\
  \n        llvm::SmallVector<DynTypedNode, 8> Worklist;\n        llvm::SmallPtrSet<const\
  \ void *, 32> Visited;\n\n        Worklist.push_back(DynTypedNode::create<const\
  \ Stmt>(*ASE));\n\n        while (!Worklist.empty()) {\n          DynTypedNode Node\
  \ = Worklist.pop_back_val();\n          auto Parents = Ctx.getParents(Node);\n \
  \         for (const auto &P : Parents) {\n            const Stmt *PS = P.get<Stmt>();\n\
  \            if (!PS) continue;\n\n            if (Visited.contains(PS))\n     \
  \         continue;\n            Visited.insert(PS);\n\n            if (const auto\
  \ *IFS = dyn_cast<IfStmt>(PS)) {\n              const Expr *Cond = IFS->getCond();\n\
  \              if (guardInCondition(Cond, V))\n                return true;\n  \
  \          }\n\n            if (PS == FS)\n              continue; // Reached the\
  \ loop boundary on this path.\n\n            Worklist.push_back(P);\n          }\n\
  \        }\n\n        return false;\n      }\n\n      void analyzeForStmt(const\
  \ ForStmt *FS, ASTContext &Ctx, BugReporter &BR) const {\n        if (!FS) return;\n\
  \n        const VarDecl *IVar = getInductionVarFromInit(FS->getInit());\n      \
  \  if (!IVar) return;\n\n        bool IsStrictUpper = false;\n        bool IsMinusOneAdjusted\
  \ = false;\n        const Expr *Cond = FS->getCond();\n        if (!Cond) return;\n\
  \        if (!analyzeLoopCondition(Cond, IVar, IsStrictUpper, IsMinusOneAdjusted))\n\
  \          return;\n\n        // Skip loops that already use (bound - 1).\n    \
  \    if (IsMinusOneAdjusted) return;\n\n        // We only flag loops with strict\
  \ upper bounds like i < N or N > i.\n        if (!IsStrictUpper) return;\n\n   \
  \     // Ensure unit-step increment on i.\n        if (!isUnitStepIncrement(FS->getInc(),\
  \ IVar))\n          return;\n\n        // Traverse the loop body and find a[i +\
  \ 1]\n        struct BodyVisitor : public RecursiveASTVisitor<BodyVisitor> {\n \
  \         const SAGenTestChecker *Checker;\n          const ForStmt *FS;\n     \
  \     const VarDecl *IVar;\n          ASTContext &Ctx;\n          BugReporter &BR;\n\
  \          const BugType &BT;\n\n          BodyVisitor(const SAGenTestChecker *Checker,\
  \ const ForStmt *FS,\n                      const VarDecl *IVar, ASTContext &Ctx,\n\
  \                      BugReporter &BR, const BugType &BT)\n              : Checker(Checker),\
  \ FS(FS), IVar(IVar), Ctx(Ctx), BR(BR), BT(BT) {}\n\n          bool VisitArraySubscriptExpr(ArraySubscriptExpr\
  \ *ASE) {\n            if (!ASE) return true;\n            const Expr *Idx = ASE->getIdx()->IgnoreParenImpCasts();\n\
  \            // Only consider indices of the form i + 1 or 1 + i.\n            if\
  \ (!Checker->isVarPlusOne(Idx, IVar))\n              return true;\n\n          \
  \  // Check for a local guard like \"if (i + 1 < X)\" or \"if (i < X - 1)\".\n \
  \           if (Checker->hasLocalGuardForASE(Ctx, ASE, FS, IVar))\n            \
  \  return true;\n\n            // Report the potential off-by-one.\n           \
  \ PathDiagnosticLocation ELoc =\n                PathDiagnosticLocation::createBegin(ASE,\
  \ BR.getSourceManager(), nullptr);\n\n            auto R = std::make_unique<BasicBugReport>(\n\
  \                BT,\n                \"Possible off-by-one: loop uses i < bound\
  \ but also accesses a[i + 1]\",\n                ELoc);\n            R->addRange(ASE->getSourceRange());\n\
  \n            // Optionally, highlight the loop condition too.\n            if (const\
  \ Expr *Cond = FS->getCond()) {\n              R->addRange(Cond->getSourceRange());\n\
  \            }\n\n            BR.emitReport(std::move(R));\n            return true;\n\
  \          }\n        };\n\n        BodyVisitor V(this, FS, IVar, Ctx, BR, *BT);\n\
  \        if (const Stmt *Body = FS->getBody())\n          V.TraverseStmt(const_cast<Stmt\
  \ *>(Body));\n      }\n};\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl\
  \ *D, AnalysisManager &Mgr, BugReporter &BR) const {\n  if (!D) return;\n  const\
  \ Stmt *Body = D->getBody();\n  if (!Body) return;\n\n  // Visit all ForStmt nodes\
  \ and analyze them.\n  struct TopVisitor : public RecursiveASTVisitor<TopVisitor>\
  \ {\n    const SAGenTestChecker *Checker;\n    ASTContext &Ctx;\n    BugReporter\
  \ &BR;\n\n    TopVisitor(const SAGenTestChecker *Checker, ASTContext &Ctx, BugReporter\
  \ &BR)\n        : Checker(Checker), Ctx(Ctx), BR(BR) {}\n\n    bool VisitForStmt(ForStmt\
  \ *FS) {\n      Checker->analyzeForStmt(FS, Ctx, BR);\n      return true;\n    }\n\
  \  };\n\n  TopVisitor TV(this, Mgr.getASTContext(), BR);\n  TV.TraverseStmt(const_cast<Stmt\
  \ *>(Body));\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects off-by-one array access in loops (i < N with a[i + 1])\",\n \
  \     \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
