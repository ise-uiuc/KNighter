_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: a97de7bff13b1cc825c1b1344eaed8d6c2d3e695
commit_type: Misuse
index: 6
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states needed.\n\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n\
  \      SAGenTestChecker() : BT(new BugType(this, \"Unsafe copy_from_sockptr read\"\
  , \"API Misuse\")) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\n   private:\n      // Helper: find the optval and optlen (or len)\
  \ parameters in the current function.\n      void findOptParams(const FunctionDecl\
  \ *FD,\n                         const ParmVarDecl *&OptvalParam,\n            \
  \             const ParmVarDecl *&LenParam) const;\n\n      // Helper: does expression\
  \ E syntactically use LenParam (directly or via a local var init)?\n      bool usesLenParam(const\
  \ Expr *E, const ParmVarDecl *LenParam, CheckerContext &C) const;\n\n      // Helper:\
  \ is the callee name matching a given string (using source text)?\n      bool isCallee(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isCallee(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) const {\n  const Expr *Origin\
  \ = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n  return ExprHasName(Origin,\
  \ Name, C);\n}\n\nvoid SAGenTestChecker::findOptParams(const FunctionDecl *FD,\n\
  \                                     const ParmVarDecl *&OptvalParam,\n       \
  \                              const ParmVarDecl *&LenParam) const {\n  OptvalParam\
  \ = nullptr;\n  LenParam = nullptr;\n  if (!FD)\n    return;\n\n  for (const ParmVarDecl\
  \ *P : FD->parameters()) {\n    if (!P)\n      continue;\n    StringRef PName =\
  \ P->getName();\n    if (PName == \"optval\")\n      OptvalParam = P;\n  }\n\n \
  \ for (const ParmVarDecl *P : FD->parameters()) {\n    if (!P)\n      continue;\n\
  \    StringRef PName = P->getName();\n    if (PName == \"optlen\") {\n      LenParam\
  \ = P;\n      break;\n    }\n  }\n\n  // Fallback: try a parameter named exactly\
  \ \"len\" of integer type\n  if (!LenParam) {\n    for (const ParmVarDecl *P : FD->parameters())\
  \ {\n      if (!P)\n        continue;\n      if (P->getName() == \"len\" && P->getType()->isIntegerType())\
  \ {\n        LenParam = P;\n        break;\n      }\n    }\n  }\n}\n\nbool SAGenTestChecker::usesLenParam(const\
  \ Expr *E, const ParmVarDecl *LenParam, CheckerContext &C) const {\n  if (!E ||\
  \ !LenParam)\n    return false;\n\n  // Direct textual occurrence of the length\
  \ parameter in the expression.\n  if (ExprHasName(E, LenParam->getName(), C))\n\
  \    return true;\n\n  // If the expression is a reference to a local variable,\
  \ check its initializer text for LenParam.\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenImpCasts()))\
  \ {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n      if (VD->hasInit())\
  \ {\n        const Expr *Init = VD->getInit();\n        if (Init && ExprHasName(Init,\
  \ LenParam->getName(), C))\n          return true;\n      }\n    }\n  }\n\n  return\
  \ false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  // Only consider copy_from_sockptr/copy_from_sockptr_offset. Skip\
  \ the safe wrapper bt_copy_from_sockptr.\n  if (isCallee(Call, \"bt_copy_from_sockptr\"\
  , C))\n    return;\n\n  bool IsCFSP = false;\n  bool IsCFSP_Off = false;\n  unsigned\
  \ LenIndex = 0;\n  unsigned SrcIndex = 1; // For both APIs, the source sockptr is\
  \ arg1.\n\n  if (isCallee(Call, \"copy_from_sockptr_offset\", C)) {\n    IsCFSP_Off\
  \ = true;\n    if (Call.getNumArgs() < 4)\n      return;\n    LenIndex = 3;\n  }\
  \ else if (isCallee(Call, \"copy_from_sockptr\", C)) {\n    IsCFSP = true;\n   \
  \ if (Call.getNumArgs() < 3)\n      return;\n    LenIndex = 2;\n  } else {\n   \
  \ return;\n  }\n\n  // Obtain the enclosing function and find parameters optval\
  \ and optlen/len.\n  const LocationContext *LCtx = C.getLocationContext();\n  const\
  \ FunctionDecl *FD = nullptr;\n  if (LCtx && LCtx->getDecl())\n    FD = dyn_cast<FunctionDecl>(LCtx->getDecl());\n\
  \  if (!FD)\n    return;\n\n  const ParmVarDecl *OptvalParam = nullptr;\n  const\
  \ ParmVarDecl *LenParam = nullptr;\n  findOptParams(FD, OptvalParam, LenParam);\n\
  \n  // We only target setsockopt-like handlers that have 'optval'. If not present,\
  \ do nothing.\n  if (!OptvalParam)\n    return;\n  // If we don't have an optlen\
  \ (or len) param available, we won't warn.\n  if (!LenParam)\n    return;\n\n  //\
  \ Ensure the source argument corresponds to the function's 'optval' parameter.\n\
  \  const Expr *SrcExpr = Call.getArgExpr(SrcIndex);\n  if (!SrcExpr)\n    return;\n\
  \  if (!ExprHasName(SrcExpr, OptvalParam->getName(), C))\n    return;\n\n  // If\
  \ the length argument uses or derives from optlen/len, consider safe.\n  const Expr\
  \ *LenExpr = Call.getArgExpr(LenIndex);\n  if (!LenExpr)\n    return;\n\n  if (usesLenParam(LenExpr,\
  \ LenParam, C))\n    return;\n\n  // Ensure the length is a fixed-size constant\
  \ (e.g. sizeof(u32), sizeof(struct), literal).\n  llvm::APSInt EvalRes;\n  if (!EvaluateExprToInt(EvalRes,\
  \ LenExpr, C))\n    return;\n\n  // Length must be positive to consider it a meaningful\
  \ read.\n  if (EvalRes.isSigned() ? EvalRes.isNonPositive() : EvalRes == 0)\n  \
  \  return;\n\n  // Report: fixed-size read from optval without validating/using\
  \ optlen.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"copy_from_sockptr\
  \ reads fixed size from optval without validating optlen\", N);\n  R->addRange(LenExpr->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects fixed-size copy_from_sockptr\
  \ reads from optval without validating optlen\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: RFCOMM: Fix not validating setsockopt user\
  \ input\n\nsyzbot reported rfcomm_sock_setsockopt_old() is copying data without\n\
  checking user input length.\n\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset\n\
  include/linux/sockptr.h:49 [inline]\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr\n\
  include/linux/sockptr.h:55 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt_old\n\
  net/bluetooth/rfcomm/sock.c:632 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt+0x893/0xa70\n\
  net/bluetooth/rfcomm/sock.c:673\nRead of size 4 at addr ffff8880209a8bc3 by task\
  \ syz-executor632/5064\n\nFixes: 9f2c8a03fbb3 (\"Bluetooth: Replace RFCOMM link\
  \ mode with security level\")\nFixes: bb23c0ab8246 (\"Bluetooth: Add support for\
  \ deferring RFCOMM connection setup\")\nReported-by: syzbot <syzkaller@googlegroups.com>\n\
  Signed-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Luiz Augusto von\
  \ Dentz <luiz.von.dentz@intel.com>\n\n## Buggy Code\n\n```c\n// Function: rfcomm_sock_setsockopt\
  \ in net/bluetooth/rfcomm/sock.c\nstatic int rfcomm_sock_setsockopt(struct socket\
  \ *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\
  \tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint err = 0;\n\tsize_t\
  \ len;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\
  \treturn rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level\
  \ != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname)\
  \ {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\
  \t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned\
  \ int, sizeof(sec), optlen);\n\t\tif (copy_from_sockptr(&sec, optval, len)) {\n\t\
  \t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level > BT_SECURITY_HIGH)\
  \ {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\trfcomm_pi(sk)->sec_level =\
  \ sec.level;\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND\
  \ && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\
  \t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\
  \t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\
  \t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\n\t\tbreak;\n\
  \n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\t\
  return err;\n}\n```\n\n```c\n// Function: rfcomm_sock_setsockopt_old in net/bluetooth/rfcomm/sock.c\n\
  static int rfcomm_sock_setsockopt_old(struct socket *sock, int optname,\n\t\tsockptr_t\
  \ optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\
  \tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname)\
  \ {\n\tcase RFCOMM_LM:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\
  \t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_FIPS) {\n\t\
  \t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_AUTH)\n\t\t\t\
  rfcomm_pi(sk)->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & RFCOMM_LM_ENCRYPT)\n\t\
  \t\trfcomm_pi(sk)->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & RFCOMM_LM_SECURE)\n\
  \t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_HIGH;\n\n\t\trfcomm_pi(sk)->role_switch\
  \ = (opt & RFCOMM_LM_MASTER);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\
  \t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\
  \n```diff\ndiff --git a/net/bluetooth/rfcomm/sock.c b/net/bluetooth/rfcomm/sock.c\n\
  index b54e8a530f55..29aa07e9db9d 100644\n--- a/net/bluetooth/rfcomm/sock.c\n+++\
  \ b/net/bluetooth/rfcomm/sock.c\n@@ -629,7 +629,7 @@ static int rfcomm_sock_setsockopt_old(struct\
  \ socket *sock, int optname,\n \n \tswitch (optname) {\n \tcase RFCOMM_LM:\n-\t\t\
  if (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n+\t\tif (bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen)) {\n \t\t\terr = -EFAULT;\n \t\t\tbreak;\n \t\t}\n\
  @@ -664,7 +664,6 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level,\
  \ int optname,\n \tstruct sock *sk = sock->sk;\n \tstruct bt_security sec;\n \t\
  int err = 0;\n-\tsize_t len;\n \tu32 opt;\n \n \tBT_DBG(\"sk %p\", sk);\n@@ -686,11\
  \ +685,9 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level, int\
  \ optname,\n \n \t\tsec.level = BT_SECURITY_LOW;\n \n-\t\tlen = min_t(unsigned int,\
  \ sizeof(sec), optlen);\n-\t\tif (copy_from_sockptr(&sec, optval, len)) {\n-\t\t\
  \terr = -EFAULT;\n+\t\terr = bt_copy_from_sockptr(&sec, sizeof(sec), optval, optlen);\n\
  +\t\tif (err)\n \t\t\tbreak;\n-\t\t}\n \n \t\tif (sec.level > BT_SECURITY_HIGH)\
  \ {\n \t\t\terr = -EINVAL;\n@@ -706,10 +703,9 @@ static int rfcomm_sock_setsockopt(struct\
  \ socket *sock, int level, int optname,\n \t\t\tbreak;\n \t\t}\n \n-\t\tif (copy_from_sockptr(&opt,\
  \ optval, sizeof(u32))) {\n-\t\t\terr = -EFAULT;\n+\t\terr = bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen);\n+\t\tif (err)\n \t\t\tbreak;\n-\t\t}\n \n \t\t\
  if (opt)\n \t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n```\n"
pattern: "## Bug Pattern\n\nReading a fixed-size integer/struct from setsockopt\u2019\
  s optval with:\ncopy_from_sockptr(&obj, optval, sizeof(obj))\nwithout first validating\
  \ that optlen is at least sizeof(obj) (or without clamping to optlen and zero-initializing\
  \ the remainder). This allows slab/out-of-bounds reads when optlen is smaller than\
  \ expected (notably for KERNEL_SOCKPTR sources), and can also leave partially initialized\
  \ structs."
plan: "Plan to detect unsafe copy_from_sockptr usage without validating optlen\n\n\
  1) Program state\n- No custom program state is required. This checker is purely\
  \ syntactic/semantic at the call site.\n\n2) Callbacks and detailed implementation\n\
  \nA) checkPreCall \u2014 detect the unsafe pattern at the call site\n- Goal: Flag\
  \ calls that read a fixed-size object from setsockopt\u2019s optval using copy_from_sockptr/copy_from_sockptr_offset\
  \ without using/validating the function\u2019s optlen parameter.\n- Steps:\n  1.\
  \ Identify target APIs:\n     - If callee name is \"copy_from_sockptr\" or \"copy_from_sockptr_offset\"\
  , continue. Otherwise return.\n     - Explicitly do nothing for \"bt_copy_from_sockptr\"\
  \ (this is the safe API).\n  2. Collect the current function\u2019s optval/optlen\
  \ parameters:\n     - Get the enclosing function: const FunctionDecl *FD = C.getLocationContext()->getDecl()->getAsFunction();\n\
  \     - Iterate FD->parameters():\n       - Find a parameter named \"optval\" (ParmVarDecl*)\
  \ \u2014 this is the sockptr_t argument. If absent, return (we only target setsockopt-like\
  \ handlers).\n       - Find a parameter named \"optlen\" (ParmVarDecl*). If missing,\
  \ optionally fallback to a parameter named exactly \"len\" of an integer type. If\
  \ still missing, return.\n  3. Read call arguments and determine the length index:\n\
  \     - For copy_from_sockptr: length index = 2 (third arg). The source sockptr\
  \ index = 1 (second arg).\n     - For copy_from_sockptr_offset: length index = 3\
  \ (fourth arg). The source sockptr index = 1 (second arg).\n  4. Verify the source\
  \ uses the optval parameter:\n     - Let srcArg = Call.getArgExpr(SrcIndex).\n \
  \    - If not ExprHasName(srcArg, OptvalParam->getNameAsString(), C), return (we\
  \ only warn when reading from the function\u2019s optval).\n  5. Check whether the\
  \ length argument ties to optlen:\n     - Let lenArg = Call.getArgExpr(LenIndex).\n\
  \     - Define a small helper in the checker:\n       - bool usesLenParam(const\
  \ Expr *E, const ParmVarDecl *LenParam, CheckerContext &C):\n         - If ExprHasName(E,\
  \ LenParam->getNameAsString(), C) return true.\n         - Else if E is a DeclRefExpr\
  \ to a local VarDecl V:\n           - If V->hasInit() and V->getInit() is not null,\
  \ and ExprHasName(V->getInit(), LenParam->getNameAsString(), C) return true.\n \
  \        - Return false otherwise.\n     - If usesLenParam(lenArg, LenParam, C)\
  \ is true, consider it safe and return.\n  6. Ensure it\u2019s a fixed-size copy\
  \ (to avoid false positives):\n     - Try to evaluate lenArg as an integer constant\
  \ using EvaluateExprToInt.\n     - If EvaluateExprToInt succeeds (e.g., sizeof(u32),\
  \ sizeof(obj), literal), then it\u2019s fixed-size.\n     - If it fails, return\
  \ (we only flag when length is clearly a fixed size and does not use/derive from\
  \ optlen).\n  7. Report the bug:\n     - Create a NonFatalErrorNode and emit a PathSensitiveBugReport\
  \ with a short message:\n       - \"copy_from_sockptr reads fixed size from optval\
  \ without validating optlen\"\n     - Highlight lenArg (the length expression) in\
  \ the report.\n\nB) Helper logic (local to the checker)\n- Function to find the\
  \ optval/optlen parameters in the current function:\n  - Iterate FD->parameters():\n\
  \    - Record OptvalParam if param->getNameAsString() == \"optval\".\n    - Record\
  \ LenParam if param->getNameAsString() == \"optlen\".\n  - If OptvalParam is null,\
  \ do not warn (not a setsockopt-like function).\n  - If LenParam is null, optionally\
  \ try a best-effort fallback:\n    - If any integer parameter is named exactly \"\
  len\", set LenParam to it.\n- usesLenParam helper as defined above, using ExprHasName\
  \ and VarDecl initializer check.\n\nC) Other callbacks\n- Not necessary. Do not\
  \ use checkBind, checkPostStmt, or checkBranchCondition. The analysis is localized\
  \ to the callsite and enclosing function signature for simplicity and low false\
  \ positives.\n\n3) Notes to reduce false positives\n- Only warn when:\n  - The source\
  \ argument syntactically references the function\u2019s optval parameter.\n  - The\
  \ length argument is a compile-time constant (e.g., sizeof(T), literal), and\n \
  \ - The length argument does not directly reference optlen, nor a local variable\
  \ whose initializer references optlen.\n- Do not warn for bt_copy_from_sockptr (safe\
  \ pattern).\n- This precisely matches the buggy pattern from the patch (e.g., copy_from_sockptr(&opt,\
  \ optval, sizeof(u32)) inside a function that has (optval, optlen)).\n\n4) Utility\
  \ functions used\n- ExprHasName to detect references to parameter names in expressions\
  \ and initializers.\n- EvaluateExprToInt to confirm the length is a fixed-size constant."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states needed.\n\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n\
  \      SAGenTestChecker() : BT(new BugType(this, \"Unsafe copy_from_sockptr read\"\
  , \"API Misuse\")) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\n   private:\n      // Helper: find the optval and optlen (or len)\
  \ parameters in the current function.\n      void findOptParams(const FunctionDecl\
  \ *FD,\n                         const ParmVarDecl *&OptvalParam,\n            \
  \             const ParmVarDecl *&LenParam) const;\n\n      // Helper: does expression\
  \ E syntactically use LenParam (directly or via a local var init)?\n      bool usesLenParam(const\
  \ Expr *E, const ParmVarDecl *LenParam, CheckerContext &C) const;\n\n      // Helper:\
  \ is the callee name matching a given string (using source text)?\n      bool isCallee(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isCallee(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) const {\n  const Expr *Origin\
  \ = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n  return ExprHasName(Origin,\
  \ Name, C);\n}\n\nvoid SAGenTestChecker::findOptParams(const FunctionDecl *FD,\n\
  \                                     const ParmVarDecl *&OptvalParam,\n       \
  \                              const ParmVarDecl *&LenParam) const {\n  OptvalParam\
  \ = nullptr;\n  LenParam = nullptr;\n  if (!FD)\n    return;\n\n  for (const ParmVarDecl\
  \ *P : FD->parameters()) {\n    if (!P)\n      continue;\n    StringRef PName =\
  \ P->getName();\n    if (PName == \"optval\")\n      OptvalParam = P;\n  }\n\n \
  \ for (const ParmVarDecl *P : FD->parameters()) {\n    if (!P)\n      continue;\n\
  \    StringRef PName = P->getName();\n    if (PName == \"optlen\") {\n      LenParam\
  \ = P;\n      break;\n    }\n  }\n\n  // Fallback: try a parameter named exactly\
  \ \"len\" of integer type\n  if (!LenParam) {\n    for (const ParmVarDecl *P : FD->parameters())\
  \ {\n      if (!P)\n        continue;\n      if (P->getName() == \"len\" && P->getType()->isIntegerType())\
  \ {\n        LenParam = P;\n        break;\n      }\n    }\n  }\n}\n\nbool SAGenTestChecker::usesLenParam(const\
  \ Expr *E, const ParmVarDecl *LenParam, CheckerContext &C) const {\n  if (!E ||\
  \ !LenParam)\n    return false;\n\n  // Direct textual occurrence of the length\
  \ parameter in the expression.\n  if (ExprHasName(E, LenParam->getName(), C))\n\
  \    return true;\n\n  // If the expression is a reference to a local variable,\
  \ check its initializer text for LenParam.\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenImpCasts()))\
  \ {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n      if (VD->hasInit())\
  \ {\n        const Expr *Init = VD->getInit();\n        if (Init && ExprHasName(Init,\
  \ LenParam->getName(), C))\n          return true;\n      }\n    }\n  }\n\n  return\
  \ false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  // Only consider copy_from_sockptr/copy_from_sockptr_offset. Skip\
  \ the safe wrapper bt_copy_from_sockptr.\n  if (isCallee(Call, \"bt_copy_from_sockptr\"\
  , C))\n    return;\n\n  bool IsCFSP = false;\n  bool IsCFSP_Off = false;\n  unsigned\
  \ LenIndex = 0;\n  unsigned SrcIndex = 1; // For both APIs, the source sockptr is\
  \ arg1.\n\n  if (isCallee(Call, \"copy_from_sockptr_offset\", C)) {\n    IsCFSP_Off\
  \ = true;\n    if (Call.getNumArgs() < 4)\n      return;\n    LenIndex = 3;\n  }\
  \ else if (isCallee(Call, \"copy_from_sockptr\", C)) {\n    IsCFSP = true;\n   \
  \ if (Call.getNumArgs() < 3)\n      return;\n    LenIndex = 2;\n  } else {\n   \
  \ return;\n  }\n\n  // Obtain the enclosing function and find parameters optval\
  \ and optlen/len.\n  const LocationContext *LCtx = C.getLocationContext();\n  const\
  \ FunctionDecl *FD = nullptr;\n  if (LCtx && LCtx->getDecl())\n    FD = dyn_cast<FunctionDecl>(LCtx->getDecl());\n\
  \  if (!FD)\n    return;\n\n  const ParmVarDecl *OptvalParam = nullptr;\n  const\
  \ ParmVarDecl *LenParam = nullptr;\n  findOptParams(FD, OptvalParam, LenParam);\n\
  \n  // We only target setsockopt-like handlers that have 'optval'. If not present,\
  \ do nothing.\n  if (!OptvalParam)\n    return;\n  // If we don't have an optlen\
  \ (or len) param available, we won't warn.\n  if (!LenParam)\n    return;\n\n  //\
  \ Ensure the source argument corresponds to the function's 'optval' parameter.\n\
  \  const Expr *SrcExpr = Call.getArgExpr(SrcIndex);\n  if (!SrcExpr)\n    return;\n\
  \  if (!ExprHasName(SrcExpr, OptvalParam->getName(), C))\n    return;\n\n  // If\
  \ the length argument uses or derives from optlen/len, consider safe.\n  const Expr\
  \ *LenExpr = Call.getArgExpr(LenIndex);\n  if (!LenExpr)\n    return;\n\n  if (usesLenParam(LenExpr,\
  \ LenParam, C))\n    return;\n\n  // Ensure the length is a fixed-size constant\
  \ (e.g. sizeof(u32), sizeof(struct), literal).\n  llvm::APSInt EvalRes;\n  if (!EvaluateExprToInt(EvalRes,\
  \ LenExpr, C))\n    return;\n\n  // Length must be positive to consider it a meaningful\
  \ read.\n  if (EvalRes.isSigned() ? EvalRes.isNonPositive() : EvalRes == 0)\n  \
  \  return;\n\n  // Report: fixed-size read from optval without validating/using\
  \ optlen.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"copy_from_sockptr\
  \ reads fixed size from optval without validating optlen\", N);\n  R->addRange(LenExpr->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects fixed-size copy_from_sockptr\
  \ reads from optval without validating optlen\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
