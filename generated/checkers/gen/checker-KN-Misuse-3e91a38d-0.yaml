_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3e91a38de1dce97b385d732a5f444264ea8fbd92
commit_type: Misuse
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include\
  \ \"clang/Basic/LangOptions.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program state needed.\n\nnamespace {\n\n\
  class SAGenTestChecker : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Use memdup_array_user\
  \ for array copy\", \"API Misuse\")) {}\n\n      void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n   private:\n\n      bool isMulWithSizeof(const\
  \ Expr *E, CheckerContext &C) const;\n      bool looksLikeMulWithSizeofTextual(const\
  \ Expr *E, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isMulWithSizeof(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n\n  const Expr\
  \ *NormE = E->IgnoreParenImpCasts();\n  const auto *BO = dyn_cast<BinaryOperator>(NormE);\n\
  \  if (!BO)\n    return false;\n\n  if (BO->getOpcode() != BO_Mul)\n    return false;\n\
  \n  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS =\
  \ BO->getRHS()->IgnoreParenImpCasts();\n\n  auto IsSizeof = [](const Expr *Op) ->\
  \ bool {\n    if (!Op) return false;\n    if (const auto *U = dyn_cast<UnaryExprOrTypeTraitExpr>(Op))\
  \ {\n      return U->getKind() == UETT_SizeOf;\n    }\n    return false;\n  };\n\
  \n  return IsSizeof(LHS) || IsSizeof(RHS);\n}\n\nbool SAGenTestChecker::looksLikeMulWithSizeofTextual(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n\n  const SourceManager\
  \ &SM = C.getSourceManager();\n  const LangOptions &LangOpts = C.getLangOpts();\n\
  \  CharSourceRange Range = CharSourceRange::getTokenRange(E->getSourceRange());\n\
  \n  StringRef Text = Lexer::getSourceText(Range, SM, LangOpts);\n  if (Text.empty())\n\
  \    return false;\n\n  // Heuristic: both \"sizeof\" and \"*\" appear in the expression\
  \ text.\n  return Text.contains(\"sizeof\") && Text.contains('*');\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return;\n\n  // Verify this is a call to memdup_user using\
  \ source text matcher for robustness.\n  if (!ExprHasName(OriginExpr, \"memdup_user\"\
  , C))\n    return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n  const Expr\
  \ *SizeArg = Call.getArgExpr(1);\n  if (!SizeArg)\n    return;\n\n  // Detect \"\
  count * sizeof(elem)\" style usage.\n  bool Match = isMulWithSizeof(SizeArg, C)\
  \ || looksLikeMulWithSizeofTextual(SizeArg, C);\n  if (!Match)\n    return;\n\n\
  \  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n\
  \  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n      \"Use memdup_array_user(ptr,\
  \ count, elem_size) instead of memdup_user(ptr, count * elem_size); multiplication\
  \ may overflow.\",\n      N);\n  R->addRange(SizeArg->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects memdup_user used with count * sizeof(...) and suggests memdup_array_user\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nfbdev: viafb: use new array-copying-wrapper\n\nviafbdev.c\
  \ utilizes memdup_user() to copy an array from userspace.\n\nThere is a new wrapper,\
  \ specifically designed for copying arrays. Use\nthis one instead.\n\nSuggested-by:\
  \ Dave Airlie <airlied@redhat.com>\nSigned-off-by: Philipp Stanner <pstanner@redhat.com>\n\
  Signed-off-by: Helge Deller <deller@gmx.de>\n\n## Buggy Code\n\n```c\n// Function:\
  \ viafb_ioctl in drivers/video/fbdev/via/viafbdev.c\nstatic int viafb_ioctl(struct\
  \ fb_info *info, u_int cmd, u_long arg)\n{\n\tunion {\n\t\tstruct viafb_ioctl_mode\
  \ viamode;\n\t\tstruct viafb_ioctl_samm viasamm;\n\t\tstruct viafb_driver_version\
  \ driver_version;\n\t\tstruct fb_var_screeninfo sec_var;\n\t\tstruct _panel_size_pos_info\
  \ panel_pos_size_para;\n\t\tstruct viafb_ioctl_setting viafb_setting;\n\t\tstruct\
  \ device_t active_dev;\n\t} u;\n\tu32 state_info = 0;\n\tu32 *viafb_gamma_table;\n\
  \tchar driver_name[] = \"viafb\";\n\n\tu32 __user *argp = (u32 __user *) arg;\n\t\
  u32 gpu32;\n\n\tDEBUG_MSG(KERN_INFO \"viafb_ioctl: 0x%X !!\\n\", cmd);\n\tprintk(KERN_WARNING\
  \ \"viafb_ioctl: Please avoid this interface as it is unstable and might change\
  \ or vanish at any time!\\n\");\n\tmemset(&u, 0, sizeof(u));\n\n\tswitch (cmd) {\n\
  \tcase VIAFB_GET_CHIP_INFO:\n\t\tif (copy_to_user(argp, viaparinfo->chip_info,\n\
  \t\t\t\tsizeof(struct chip_information)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t\
  case VIAFB_GET_INFO_SIZE:\n\t\treturn put_user((u32)sizeof(struct viafb_ioctl_info),\
  \ argp);\n\tcase VIAFB_GET_INFO:\n\t\treturn viafb_ioctl_get_viafb_info(arg);\n\t\
  case VIAFB_HOTPLUG:\n\t\treturn put_user(viafb_ioctl_hotplug(info->var.xres,\n\t\
  \t\t\t\t      info->var.yres,\n\t\t\t\t\t      info->var.bits_per_pixel), argp);\n\
  \tcase VIAFB_SET_HOTPLUG_FLAG:\n\t\tif (copy_from_user(&gpu32, argp, sizeof(gpu32)))\n\
  \t\t\treturn -EFAULT;\n\t\tviafb_hotplug = (gpu32) ? 1 : 0;\n\t\tbreak;\n\tcase\
  \ VIAFB_GET_RESOLUTION:\n\t\tu.viamode.xres = (u32) viafb_hotplug_Xres;\n\t\tu.viamode.yres\
  \ = (u32) viafb_hotplug_Yres;\n\t\tu.viamode.refresh = (u32) viafb_hotplug_refresh;\n\
  \t\tu.viamode.bpp = (u32) viafb_hotplug_bpp;\n\t\tif (viafb_SAMM_ON == 1) {\n\t\t\
  \tu.viamode.xres_sec = viafb_second_xres;\n\t\t\tu.viamode.yres_sec = viafb_second_yres;\n\
  \t\t\tu.viamode.virtual_xres_sec = viafb_dual_fb ? viafbinfo1->var.xres_virtual\
  \ : viafbinfo->var.xres_virtual;\n\t\t\tu.viamode.virtual_yres_sec = viafb_dual_fb\
  \ ? viafbinfo1->var.yres_virtual : viafbinfo->var.yres_virtual;\n\t\t\tu.viamode.refresh_sec\
  \ = viafb_refresh1;\n\t\t\tu.viamode.bpp_sec = viafb_bpp1;\n\t\t} else {\n\t\t\t\
  u.viamode.xres_sec = 0;\n\t\t\tu.viamode.yres_sec = 0;\n\t\t\tu.viamode.virtual_xres_sec\
  \ = 0;\n\t\t\tu.viamode.virtual_yres_sec = 0;\n\t\t\tu.viamode.refresh_sec = 0;\n\
  \t\t\tu.viamode.bpp_sec = 0;\n\t\t}\n\t\tif (copy_to_user(argp, &u.viamode, sizeof(u.viamode)))\n\
  \t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase VIAFB_GET_SAMM_INFO:\n\t\tu.viasamm.samm_status\
  \ = viafb_SAMM_ON;\n\n\t\tif (viafb_SAMM_ON == 1) {\n\t\t\tif (viafb_dual_fb) {\n\
  \t\t\t\tu.viasamm.size_prim = viaparinfo->fbmem_free;\n\t\t\t\tu.viasamm.size_sec\
  \ = viaparinfo1->fbmem_free;\n\t\t\t} else {\n\t\t\t\tif (viafb_second_size) {\n\
  \t\t\t\t\tu.viasamm.size_prim =\n\t\t\t\t\t    viaparinfo->fbmem_free -\n\t\t\t\t\
  \t    viafb_second_size * 1024 * 1024;\n\t\t\t\t\tu.viasamm.size_sec =\n\t\t\t\t\
  \t    viafb_second_size * 1024 * 1024;\n\t\t\t\t} else {\n\t\t\t\t\tu.viasamm.size_prim\
  \ =\n\t\t\t\t\t    viaparinfo->fbmem_free >> 1;\n\t\t\t\t\tu.viasamm.size_sec =\n\
  \t\t\t\t\t    (viaparinfo->fbmem_free >> 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tu.viasamm.mem_base\
  \ = viaparinfo->fbmem;\n\t\t\tu.viasamm.offset_sec = viafb_second_offset;\n\t\t\
  } else {\n\t\t\tu.viasamm.size_prim =\n\t\t\t    viaparinfo->memsize - viaparinfo->fbmem_used;\n\
  \t\t\tu.viasamm.size_sec = 0;\n\t\t\tu.viasamm.mem_base = viaparinfo->fbmem;\n\t\
  \t\tu.viasamm.offset_sec = 0;\n\t\t}\n\n\t\tif (copy_to_user(argp, &u.viasamm, sizeof(u.viasamm)))\n\
  \t\t\treturn -EFAULT;\n\n\t\tbreak;\n\tcase VIAFB_TURN_ON_OUTPUT_DEVICE:\n\t\tif\
  \ (copy_from_user(&gpu32, argp, sizeof(gpu32)))\n\t\t\treturn -EFAULT;\n\t\tif (gpu32\
  \ & CRT_Device)\n\t\t\tvia_set_state(VIA_CRT, VIA_STATE_ON);\n\t\tif (gpu32 & DVI_Device)\n\
  \t\t\tviafb_dvi_enable();\n\t\tif (gpu32 & LCD_Device)\n\t\t\tviafb_lcd_enable();\n\
  \t\tbreak;\n\tcase VIAFB_TURN_OFF_OUTPUT_DEVICE:\n\t\tif (copy_from_user(&gpu32,\
  \ argp, sizeof(gpu32)))\n\t\t\treturn -EFAULT;\n\t\tif (gpu32 & CRT_Device)\n\t\t\
  \tvia_set_state(VIA_CRT, VIA_STATE_OFF);\n\t\tif (gpu32 & DVI_Device)\n\t\t\tviafb_dvi_disable();\n\
  \t\tif (gpu32 & LCD_Device)\n\t\t\tviafb_lcd_disable();\n\t\tbreak;\n\tcase VIAFB_GET_DEVICE:\n\
  \t\tu.active_dev.crt = viafb_CRT_ON;\n\t\tu.active_dev.dvi = viafb_DVI_ON;\n\t\t\
  u.active_dev.lcd = viafb_LCD_ON;\n\t\tu.active_dev.samm = viafb_SAMM_ON;\n\t\tu.active_dev.primary_dev\
  \ = viafb_primary_dev;\n\n\t\tu.active_dev.lcd_dsp_cent = viafb_lcd_dsp_method;\n\
  \t\tu.active_dev.lcd_panel_id = viafb_lcd_panel_id;\n\t\tu.active_dev.lcd_mode =\
  \ viafb_lcd_mode;\n\n\t\tu.active_dev.xres = viafb_hotplug_Xres;\n\t\tu.active_dev.yres\
  \ = viafb_hotplug_Yres;\n\n\t\tu.active_dev.xres1 = viafb_second_xres;\n\t\tu.active_dev.yres1\
  \ = viafb_second_yres;\n\n\t\tu.active_dev.bpp = viafb_bpp;\n\t\tu.active_dev.bpp1\
  \ = viafb_bpp1;\n\t\tu.active_dev.refresh = viafb_refresh;\n\t\tu.active_dev.refresh1\
  \ = viafb_refresh1;\n\n\t\tu.active_dev.epia_dvi = viafb_platform_epia_dvi;\n\t\t\
  u.active_dev.lcd_dual_edge = viafb_device_lcd_dualedge;\n\t\tu.active_dev.bus_width\
  \ = viafb_bus_width;\n\n\t\tif (copy_to_user(argp, &u.active_dev, sizeof(u.active_dev)))\n\
  \t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase VIAFB_GET_DRIVER_VERSION:\n\t\tu.driver_version.iMajorNum\
  \ = VERSION_MAJOR;\n\t\tu.driver_version.iKernelNum = VERSION_KERNEL;\n\t\tu.driver_version.iOSNum\
  \ = VERSION_OS;\n\t\tu.driver_version.iMinorNum = VERSION_MINOR;\n\n\t\tif (copy_to_user(argp,\
  \ &u.driver_version,\n\t\t\tsizeof(u.driver_version)))\n\t\t\treturn -EFAULT;\n\n\
  \t\tbreak;\n\n\tcase VIAFB_GET_DEVICE_INFO:\n\n\t\tretrieve_device_setting(&u.viafb_setting);\n\
  \n\t\tif (copy_to_user(argp, &u.viafb_setting,\n\t\t\t\t sizeof(u.viafb_setting)))\n\
  \t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\tcase VIAFB_GET_DEVICE_SUPPORT:\n\t\tviafb_get_device_support_state(&state_info);\n\
  \t\tif (put_user(state_info, argp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase\
  \ VIAFB_GET_DEVICE_CONNECT:\n\t\tviafb_get_device_connect_state(&state_info);\n\t\
  \tif (put_user(state_info, argp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase VIAFB_GET_PANEL_SUPPORT_EXPAND:\n\
  \t\tstate_info =\n\t\t    viafb_lcd_get_support_expand_state(info->var.xres,\n\t\
  \t\t\t\t\t info->var.yres);\n\t\tif (put_user(state_info, argp))\n\t\t\treturn -EFAULT;\n\
  \t\tbreak;\n\n\tcase VIAFB_GET_DRIVER_NAME:\n\t\tif (copy_to_user(argp, driver_name,\
  \ sizeof(driver_name)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase VIAFB_SET_GAMMA_LUT:\n\
  \t\tviafb_gamma_table = memdup_user(argp, 256 * sizeof(u32));\n\t\tif (IS_ERR(viafb_gamma_table))\n\
  \t\t\treturn PTR_ERR(viafb_gamma_table);\n\t\tviafb_set_gamma_table(viafb_bpp, viafb_gamma_table);\n\
  \t\tkfree(viafb_gamma_table);\n\t\tbreak;\n\n\tcase VIAFB_GET_GAMMA_LUT:\n\t\tviafb_gamma_table\
  \ = kmalloc_array(256, sizeof(u32),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!viafb_gamma_table)\n\
  \t\t\treturn -ENOMEM;\n\t\tviafb_get_gamma_table(viafb_gamma_table);\n\t\tif (copy_to_user(argp,\
  \ viafb_gamma_table,\n\t\t\t256 * sizeof(u32))) {\n\t\t\tkfree(viafb_gamma_table);\n\
  \t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree(viafb_gamma_table);\n\t\tbreak;\n\n\tcase\
  \ VIAFB_GET_GAMMA_SUPPORT_STATE:\n\t\tviafb_get_gamma_support_state(viafb_bpp, &state_info);\n\
  \t\tif (put_user(state_info, argp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase VIAFB_SYNC_SURFACE:\n\
  \t\tDEBUG_MSG(KERN_INFO \"lobo VIAFB_SYNC_SURFACE\\n\");\n\t\tbreak;\n\tcase VIAFB_GET_DRIVER_CAPS:\n\
  \t\tbreak;\n\n\tcase VIAFB_GET_PANEL_MAX_SIZE:\n\t\tif (copy_from_user(&u.panel_pos_size_para,\
  \ argp,\n\t\t\t\t   sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\t\
  u.panel_pos_size_para.x = u.panel_pos_size_para.y = 0;\n\t\tif (copy_to_user(argp,\
  \ &u.panel_pos_size_para,\n\t\t     sizeof(u.panel_pos_size_para)))\n\t\t\treturn\
  \ -EFAULT;\n\t\tbreak;\n\tcase VIAFB_GET_PANEL_MAX_POSITION:\n\t\tif (copy_from_user(&u.panel_pos_size_para,\
  \ argp,\n\t\t\t\t   sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\t\
  u.panel_pos_size_para.x = u.panel_pos_size_para.y = 0;\n\t\tif (copy_to_user(argp,\
  \ &u.panel_pos_size_para,\n\t\t\t\t sizeof(u.panel_pos_size_para)))\n\t\t\treturn\
  \ -EFAULT;\n\t\tbreak;\n\n\tcase VIAFB_GET_PANEL_POSITION:\n\t\tif (copy_from_user(&u.panel_pos_size_para,\
  \ argp,\n\t\t\t\t   sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\t\
  u.panel_pos_size_para.x = u.panel_pos_size_para.y = 0;\n\t\tif (copy_to_user(argp,\
  \ &u.panel_pos_size_para,\n\t\t\t\t sizeof(u.panel_pos_size_para)))\n\t\t\treturn\
  \ -EFAULT;\n\t\tbreak;\n\tcase VIAFB_GET_PANEL_SIZE:\n\t\tif (copy_from_user(&u.panel_pos_size_para,\
  \ argp,\n\t\t\t\t   sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\t\
  u.panel_pos_size_para.x = u.panel_pos_size_para.y = 0;\n\t\tif (copy_to_user(argp,\
  \ &u.panel_pos_size_para,\n\t\t\t\t sizeof(u.panel_pos_size_para)))\n\t\t\treturn\
  \ -EFAULT;\n\t\tbreak;\n\n\tcase VIAFB_SET_PANEL_POSITION:\n\t\tif (copy_from_user(&u.panel_pos_size_para,\
  \ argp,\n\t\t\t\t   sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\t\
  break;\n\tcase VIAFB_SET_PANEL_SIZE:\n\t\tif (copy_from_user(&u.panel_pos_size_para,\
  \ argp,\n\t\t\t\t   sizeof(u.panel_pos_size_para)))\n\t\t\treturn -EFAULT;\n\t\t\
  break;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n```\n\n## Bug\
  \ Fix Patch\n\n```diff\ndiff --git a/drivers/video/fbdev/via/viafbdev.c b/drivers/video/fbdev/via/viafbdev.c\n\
  index 58868f8880d6..a52b1ba43a48 100644\n--- a/drivers/video/fbdev/via/viafbdev.c\n\
  +++ b/drivers/video/fbdev/via/viafbdev.c\n@@ -574,7 +574,7 @@ static int viafb_ioctl(struct\
  \ fb_info *info, u_int cmd, u_long arg)\n \t\tbreak;\n \n \tcase VIAFB_SET_GAMMA_LUT:\n\
  -\t\tviafb_gamma_table = memdup_user(argp, 256 * sizeof(u32));\n+\t\tviafb_gamma_table\
  \ = memdup_array_user(argp, 256, sizeof(u32));\n \t\tif (IS_ERR(viafb_gamma_table))\n\
  \ \t\t\treturn PTR_ERR(viafb_gamma_table);\n \t\tviafb_set_gamma_table(viafb_bpp,\
  \ viafb_gamma_table);\n```\n"
pattern: '## Bug Pattern


  Using memdup_user() to copy an array from user space with a size computed as count
  * element_size, instead of using memdup_array_user(count, element_size). This misses
  overflow checking on the multiplication, risking integer overflow and undersized
  allocation.


  Bad:

  - buf = memdup_user(user_ptr, n * sizeof(*buf));


  Good:

  - buf = memdup_array_user(user_ptr, n, sizeof(*buf));'
plan: "1) Program state\n- No custom program state is needed. This checker is a pure\
  \ API misuse pattern match on a single call site.\n\n2) Callback selection and implementation\n\
  \n- checkPreCall (the only callback needed)\n  - Goal: Detect calls to memdup_user()\
  \ where the size argument is a multiplication of a count and an element size (typically\
  \ sizeof(...)), and suggest using memdup_array_user() instead.\n  - Steps:\n   \
  \ 1. Identify memdup_user:\n       - If Call.getCalleeIdentifier() is null, return.\n\
  \       - If Call.getCalleeIdentifier()->getName() != \"memdup_user\", return.\n\
  \       - Ensure there are at least 2 arguments.\n    2. Obtain and normalize the\
  \ size argument:\n       - const Expr *SizeArg = Call.getArgExpr(1)->IgnoreParenImpCasts().\n\
  \    3. Match \u201Ccount * elem_size\u201D:\n       - Primary pattern:\n      \
  \   - If SizeArg is a BinaryOperator with opcode BO_Mul:\n           - Let LHS =\
  \ BO->getLHS()->IgnoreParenImpCasts()\n           - Let RHS = BO->getRHS()->IgnoreParenImpCasts()\n\
  \           - Check if either LHS or RHS is a sizeof expression:\n             -\
  \ dyn_cast<UnaryExprOrTypeTraitExpr>(Op) and Op->getKind() == UETT_SizeOf\n    \
  \         - If either side is sizeof(...), we have a match.\n       - Fallback heuristic\
  \ (for robustness if the compiler constant-folded the expression or it\u2019s an\
  \ unusual form):\n         - If the above check doesn\u2019t match, use ExprHasName(SizeArg,\
  \ \"sizeof\", C) to look for \u201Csizeof\u201D in the source text of the size expression.\
  \ If present together with a '*' token in the textual range, consider it a match.\n\
  \           - You can grab the text via the provided utility ExprHasName and also\
  \ do a lightweight string search for '*' inside the same CharSourceRange using Lexer::getSourceText\
  \ (similar to ExprHasName\u2019s logic).\n    4. Report:\n       - If matched, create\
  \ a non-fatal error node via generateNonFatalErrorNode().\n       - Create a PathSensitiveBugReport\
  \ (or BasicBugReport if preferred) with a short message:\n         - \"Use memdup_array_user(ptr,\
  \ count, elem_size) instead of memdup_user(ptr, count * elem_size); multiplication\
  \ may overflow.\"\n       - Highlight the size expression range (the second argument)\
  \ in the report.\n       - emit the report.\n\n3) Helper functions (internal to\
  \ the checker)\n- bool isMulWithSizeof(const Expr *E, CheckerContext &C):\n  - Returns\
  \ true if E is a BinaryOperator \u2018*\u2019 and one operand is a UnaryExprOrTypeTraitExpr\
  \ of kind UETT_SizeOf.\n- bool looksLikeMulWithSizeofTextual(const Expr *E, CheckerContext\
  \ &C):\n  - Uses ExprHasName(E, \"sizeof\", C) and a raw source-text \u201C*\u201D\
  \ search within the expression\u2019s CharSourceRange as a fallback when AST node\
  \ patterns don\u2019t directly match (e.g., because of casts/parentheses/macros).\n\
  \n4) Notes to keep it simple and precise\n- Do not attempt dataflow or alias tracking.\n\
  - Do not try to detect and suppress warnings when manual overflow checks exist nearby;\
  \ keep the checker simple as requested.\n- Only trigger for memdup_user. Do not\
  \ flag memdup_array_user or other allocation APIs.\n- Consider both operand orders\
  \ (sizeof(...) * count and count * sizeof(...)).\n- Use IgnoreParenImpCasts when\
  \ inspecting operands to avoid noise.\n- Prefer checkPreCall: no need to model return\
  \ values or state."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include\
  \ \"clang/Basic/LangOptions.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program state needed.\n\nnamespace {\n\n\
  class SAGenTestChecker : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Use memdup_array_user\
  \ for array copy\", \"API Misuse\")) {}\n\n      void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n   private:\n\n      bool isMulWithSizeof(const\
  \ Expr *E, CheckerContext &C) const;\n      bool looksLikeMulWithSizeofTextual(const\
  \ Expr *E, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isMulWithSizeof(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n\n  const Expr\
  \ *NormE = E->IgnoreParenImpCasts();\n  const auto *BO = dyn_cast<BinaryOperator>(NormE);\n\
  \  if (!BO)\n    return false;\n\n  if (BO->getOpcode() != BO_Mul)\n    return false;\n\
  \n  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS =\
  \ BO->getRHS()->IgnoreParenImpCasts();\n\n  auto IsSizeof = [](const Expr *Op) ->\
  \ bool {\n    if (!Op) return false;\n    if (const auto *U = dyn_cast<UnaryExprOrTypeTraitExpr>(Op))\
  \ {\n      return U->getKind() == UETT_SizeOf;\n    }\n    return false;\n  };\n\
  \n  return IsSizeof(LHS) || IsSizeof(RHS);\n}\n\nbool SAGenTestChecker::looksLikeMulWithSizeofTextual(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n\n  const SourceManager\
  \ &SM = C.getSourceManager();\n  const LangOptions &LangOpts = C.getLangOpts();\n\
  \  CharSourceRange Range = CharSourceRange::getTokenRange(E->getSourceRange());\n\
  \n  StringRef Text = Lexer::getSourceText(Range, SM, LangOpts);\n  if (Text.empty())\n\
  \    return false;\n\n  // Heuristic: both \"sizeof\" and \"*\" appear in the expression\
  \ text.\n  return Text.contains(\"sizeof\") && Text.contains('*');\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return;\n\n  // Verify this is a call to memdup_user using\
  \ source text matcher for robustness.\n  if (!ExprHasName(OriginExpr, \"memdup_user\"\
  , C))\n    return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n  const Expr\
  \ *SizeArg = Call.getArgExpr(1);\n  if (!SizeArg)\n    return;\n\n  // Detect \"\
  count * sizeof(elem)\" style usage.\n  bool Match = isMulWithSizeof(SizeArg, C)\
  \ || looksLikeMulWithSizeofTextual(SizeArg, C);\n  if (!Match)\n    return;\n\n\
  \  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n\
  \  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n      \"Use memdup_array_user(ptr,\
  \ count, elem_size) instead of memdup_user(ptr, count * elem_size); multiplication\
  \ may overflow.\",\n      N);\n  R->addRange(SizeArg->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects memdup_user used with count * sizeof(...) and suggests memdup_array_user\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
