_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 4575962aeed63aca975756852ab0c550164f849f
commit_type: Double-Free
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/SmallVector.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_SET_WITH_PROGRAMSTATE(DevmAllocSyms,\
  \ SymbolRef)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PostCall,\
  \ check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n   \
  \   SAGenTestChecker()\n          : BT(new BugType(this, \"Double free of devm-managed\
  \ pointer\", \"Memory Management\")) {}\n\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      void checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n\n   private:\n      static bool isDevmAllocator(const\
  \ CallEvent &Call, CheckerContext &C);\n      static bool functionKnownToFree(const\
  \ CallEvent &Call,\n                                      llvm::SmallVectorImpl<unsigned>\
  \ &FreedParams,\n                                      CheckerContext &C);\n   \
  \   static SymbolRef getPtrSymbolFromSVal(SVal V);\n      void reportManualFreeOfDevm(const\
  \ CallEvent &Call, const Expr *ArgE, CheckerContext &C) const;\n};\n\nstatic bool\
  \ isNameOneOf(const Expr *E, CheckerContext &C,\n                        std::initializer_list<const\
  \ char*> Names) {\n  if (!E) return false;\n  for (const char *N : Names) {\n  \
  \  if (ExprHasName(E, N, C))\n      return true;\n  }\n  return false;\n}\n\nbool\
  \ SAGenTestChecker::isDevmAllocator(const CallEvent &Call, CheckerContext &C) {\n\
  \  const Expr *OE = Call.getOriginExpr();\n  return isNameOneOf(OE, C, {\n    \"\
  devm_kcalloc\",\n    \"devm_kmalloc\",\n    \"devm_kmalloc_array\",\n    \"devm_kzalloc\"\
  ,\n    \"devm_kcalloc_node\",\n    \"devm_kmalloc_node\",\n    \"devm_kasprintf\"\
  \n  });\n}\n\nbool SAGenTestChecker::functionKnownToFree(const CallEvent &Call,\n\
  \                                           llvm::SmallVectorImpl<unsigned> &FreedParams,\n\
  \                                           CheckerContext &C) {\n  const Expr *OE\
  \ = Call.getOriginExpr();\n  if (!OE)\n    return false;\n\n  if (ExprHasName(OE,\
  \ \"kfree\", C) ||\n      ExprHasName(OE, \"kvfree\", C) ||\n      ExprHasName(OE,\
  \ \"vfree\", C)) {\n    FreedParams.push_back(0);\n    return true;\n  }\n\n  if\
  \ (ExprHasName(OE, \"pinctrl_utils_free_map\", C)) {\n    // pinctrl_utils_free_map(pctldev,\
  \ map, nmaps)\n    FreedParams.push_back(1);\n    return true;\n  }\n\n  return\
  \ false;\n}\n\nSymbolRef SAGenTestChecker::getPtrSymbolFromSVal(SVal V) {\n  if\
  \ (SymbolRef S = V.getAsSymbol())\n    return S;\n\n  if (const MemRegion *MR =\
  \ V.getAsRegion()) {\n    MR = MR->getBaseRegion();\n    if (const auto *SR = dyn_cast<SymbolicRegion>(MR))\n\
  \      return SR->getSymbol();\n  }\n  return nullptr;\n}\n\nvoid SAGenTestChecker::reportManualFreeOfDevm(const\
  \ CallEvent &Call, const Expr *ArgE,\n                                         \
  \     CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Manual free of devm_* allocated pointer (double free)\", N);\n  if\
  \ (ArgE)\n    R->addRange(ArgE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  if (!isDevmAllocator(Call, C))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n\n  SVal Ret = Call.getReturnValue();\n  SymbolRef Sym\
  \ = getPtrSymbolFromSVal(Ret);\n  if (!Sym)\n    return;\n\n  if (!State->contains<DevmAllocSyms>(Sym))\
  \ {\n    State = State->add<DevmAllocSyms>(Sym);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  llvm::SmallVector<unsigned, 4> FreedParams;\n  if (!functionKnownToFree(Call,\
  \ FreedParams, C))\n    return;\n\n  ProgramStateRef State = C.getState();\n\n \
  \ for (unsigned Idx : FreedParams) {\n    if (Idx >= Call.getNumArgs())\n      continue;\n\
  \n    const Expr *ArgE = Call.getArgExpr(Idx);\n    SVal ArgV = Call.getArgSVal(Idx);\n\
  \n    // Skip definite NULL frees if trivially known; conservatively continue otherwise.\n\
  \    if (ArgV.isZeroConstant())\n      continue;\n\n    SymbolRef Sym = getPtrSymbolFromSVal(ArgV);\n\
  \    if (!Sym)\n      continue;\n\n    if (State->contains<DevmAllocSyms>(Sym))\
  \ {\n      reportManualFreeOfDevm(Call, ArgE, C);\n      // One report per call\
  \ site is enough.\n      return;\n    }\n  }\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect manual free of devm_* allocated\
  \ pointers (double free)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\npinctrl: sophgo: fix double free in cv1800_pctrl_dt_node_to_map()\n\
  \n'map' is allocated using devm_* which takes care of freeing the allocated\ndata,\
  \ but in error paths there is a call to pinctrl_utils_free_map()\nwhich also does\
  \ kfree(map) which leads to a double free.\n\nUse kcalloc() instead of devm_kcalloc()\
  \ as freeing is manually handled.\n\nFixes: a29d8e93e710 (\"pinctrl: sophgo: add\
  \ support for CV1800B SoC\")\nSigned-off-by: Harshit Mogalapalli <harshit.m.mogalapalli@oracle.com>\n\
  Link: https://lore.kernel.org/20241010111830.3474719-1-harshit.m.mogalapalli@oracle.com\n\
  Signed-off-by: Linus Walleij <linus.walleij@linaro.org>\n\n## Buggy Code\n\n```c\n\
  // Function: cv1800_pctrl_dt_node_to_map in drivers/pinctrl/sophgo/pinctrl-cv18xx.c\n\
  static int cv1800_pctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t  \
  \     struct device_node *np,\n\t\t\t\t       struct pinctrl_map **maps,\n\t\t\t\
  \t       unsigned int *num_maps)\n{\n\tstruct cv1800_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\
  \tstruct device *dev = pctrl->dev;\n\tstruct device_node *child;\n\tstruct pinctrl_map\
  \ *map;\n\tconst char **grpnames;\n\tconst char *grpname;\n\tint ngroups = 0;\n\t\
  int nmaps = 0;\n\tint ret;\n\n\tfor_each_available_child_of_node(np, child)\n\t\t\
  ngroups += 1;\n\n\tgrpnames = devm_kcalloc(dev, ngroups, sizeof(*grpnames), GFP_KERNEL);\n\
  \tif (!grpnames)\n\t\treturn -ENOMEM;\n\n\tmap = devm_kcalloc(dev, ngroups * 2,\
  \ sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tngroups = 0;\n\
  \tmutex_lock(&pctrl->mutex);\n\tfor_each_available_child_of_node(np, child) {\n\t\
  \tint npins = of_property_count_u32_elems(child, \"pinmux\");\n\t\tunsigned int\
  \ *pins;\n\t\tstruct cv1800_pin_mux_config *pinmuxs;\n\t\tu32 config, power;\n\t\
  \tint i;\n\n\t\tif (npins < 1) {\n\t\t\tdev_err(dev, \"invalid pinctrl group %pOFn.%pOFn\\\
  n\",\n\t\t\t\tnp, child);\n\t\t\tret = -EINVAL;\n\t\t\tgoto dt_failed;\n\t\t}\n\n\
  \t\tgrpname = devm_kasprintf(dev, GFP_KERNEL, \"%pOFn.%pOFn\",\n\t\t\t\t\t np, child);\n\
  \t\tif (!grpname) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto dt_failed;\n\t\t}\n\n\t\t\
  grpnames[ngroups++] = grpname;\n\n\t\tpins = devm_kcalloc(dev, npins, sizeof(*pins),\
  \ GFP_KERNEL);\n\t\tif (!pins) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto dt_failed;\n\t\
  \t}\n\n\t\tpinmuxs = devm_kcalloc(dev, npins, sizeof(*pinmuxs), GFP_KERNEL);\n\t\
  \tif (!pinmuxs) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto dt_failed;\n\t\t}\n\n\t\tfor\
  \ (i = 0; i < npins; i++) {\n\t\t\tret = of_property_read_u32_index(child, \"pinmux\"\
  ,\n\t\t\t\t\t\t\t i, &config);\n\t\t\tif (ret)\n\t\t\t\tgoto dt_failed;\n\n\t\t\t\
  pins[i] = cv1800_dt_get_pin(config);\n\t\t\tpinmuxs[i].config = config;\n\t\t\t\
  pinmuxs[i].pin = cv1800_get_pin(pctrl, pins[i]);\n\n\t\t\tif (!pinmuxs[i].pin) {\n\
  \t\t\t\tdev_err(dev, \"failed to get pin %d\\n\", pins[i]);\n\t\t\t\tret = -ENODEV;\n\
  \t\t\t\tgoto dt_failed;\n\t\t\t}\n\n\t\t\tret = cv1800_verify_pinmux_config(&pinmuxs[i]);\n\
  \t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"group %s pin %d is invalid\\n\",\n\t\t\t\
  \t\tgrpname, i);\n\t\t\t\tgoto dt_failed;\n\t\t\t}\n\t\t}\n\n\t\tret = cv1800_verify_pin_group(pinmuxs,\
  \ npins);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"group %s is invalid\\n\", grpname);\n\
  \t\t\tgoto dt_failed;\n\t\t}\n\n\t\tret = of_property_read_u32(child, \"power-source\"\
  , &power);\n\t\tif (ret)\n\t\t\tgoto dt_failed;\n\n\t\tif (!(power == PIN_POWER_STATE_3V3\
  \ || power == PIN_POWER_STATE_1V8)) {\n\t\t\tdev_err(dev, \"group %s have unsupported\
  \ power: %u\\n\",\n\t\t\t\tgrpname, power);\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto\
  \ dt_failed;\n\t\t}\n\n\t\tret = cv1800_set_power_cfg(pctrl, pinmuxs[0].pin->power_domain,\n\
  \t\t\t\t\t   power);\n\t\tif (ret)\n\t\t\tgoto dt_failed;\n\n\t\tmap[nmaps].type\
  \ = PIN_MAP_TYPE_MUX_GROUP;\n\t\tmap[nmaps].data.mux.function = np->name;\n\t\t\
  map[nmaps].data.mux.group = grpname;\n\t\tnmaps += 1;\n\n\t\tret = pinconf_generic_parse_dt_config(child,\
  \ pctldev,\n\t\t\t\t\t\t      &map[nmaps].data.configs.configs,\n\t\t\t\t\t\t  \
  \    &map[nmaps].data.configs.num_configs);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\
  \ \"failed to parse pin config of group %s: %d\\n\",\n\t\t\t\tgrpname, ret);\n\t\
  \t\tgoto dt_failed;\n\t\t}\n\n\t\tret = pinctrl_generic_add_group(pctldev, grpname,\n\
  \t\t\t\t\t\tpins, npins, pinmuxs);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed\
  \ to add group %s: %d\\n\", grpname, ret);\n\t\t\tgoto dt_failed;\n\t\t}\n\n\t\t\
  /* don't create a map if there are no pinconf settings */\n\t\tif (map[nmaps].data.configs.num_configs\
  \ == 0)\n\t\t\tcontinue;\n\n\t\tmap[nmaps].type = PIN_MAP_TYPE_CONFIGS_GROUP;\n\t\
  \tmap[nmaps].data.configs.group_or_pin = grpname;\n\t\tnmaps += 1;\n\t}\n\n\tret\
  \ = pinmux_generic_add_function(pctldev, np->name,\n\t\t\t\t\t  grpnames, ngroups,\
  \ NULL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error adding function %s: %d\\n\"\
  , np->name, ret);\n\t\tgoto function_failed;\n\t}\n\n\t*maps = map;\n\t*num_maps\
  \ = nmaps;\n\tmutex_unlock(&pctrl->mutex);\n\n\treturn 0;\n\ndt_failed:\n\tof_node_put(child);\n\
  function_failed:\n\tpinctrl_utils_free_map(pctldev, map, nmaps);\n\tmutex_unlock(&pctrl->mutex);\n\
  \treturn ret;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/pinctrl/sophgo/pinctrl-cv18xx.c\
  \ b/drivers/pinctrl/sophgo/pinctrl-cv18xx.c\nindex d18fc5aa84f7..57f2674e75d6 100644\n\
  --- a/drivers/pinctrl/sophgo/pinctrl-cv18xx.c\n+++ b/drivers/pinctrl/sophgo/pinctrl-cv18xx.c\n\
  @@ -221,7 +221,7 @@ static int cv1800_pctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\
  \ \tif (!grpnames)\n \t\treturn -ENOMEM;\n \n-\tmap = devm_kcalloc(dev, ngroups\
  \ * 2, sizeof(*map), GFP_KERNEL);\n+\tmap = kcalloc(ngroups * 2, sizeof(*map), GFP_KERNEL);\n\
  \ \tif (!map)\n \t\treturn -ENOMEM;\n \n```\n"
pattern: '## Bug Pattern


  Allocating memory with device-managed APIs (devm_kcalloc/devm_kmalloc) and then
  manually freeing the same pointer (directly via kfree or indirectly via helpers
  like pinctrl_utils_free_map) in error/cleanup paths. This mixes devm-managed lifetime
  with manual frees, causing a double free when devres later frees the already-freed
  pointer.


  Example:

  - ptr = devm_kcalloc(dev, ...);

  - ... on error: pinctrl_utils_free_map(..., ptr, ...); // internally kfree(ptr)

  - Later: devm cleanup frees ptr again -> double free.'
plan: "1) Program state\n\n- REGISTER_SET_WITH_PROGRAMSTATE(DevmAllocSyms, SymbolRef)\n\
  \  - Purpose: remember which pointer symbols originate from devm-managed allocators\
  \ (devm_kcalloc/devm_kmalloc/\u2026).\n  - We deliberately track SymbolRef, not\
  \ variable regions. In CSA, the same returned pointer symbol flows through assignments\
  \ and arguments, so alias tracking is usually unnecessary for this use case.\n\n\
  - No other traits/maps needed. We will not maintain an alias map to keep the checker\
  \ simple. We rely on the symbolic value propagation of CSA.\n\n2) Callbacks and\
  \ how to implement them\n\nA) checkPostCall \u2014 mark devm-managed allocations\n\
  \n- Goal: whenever a devm-managed allocator returns a pointer, record the returned\
  \ SymbolRef in DevmAllocSyms.\n- Detect allocators:\n  - Implement helper isDevmAllocator(const\
  \ CallEvent &Call):\n    - Return true if callee name is one of:\n      - devm_kcalloc\n\
  \      - devm_kmalloc\n      - devm_kmalloc_array\n      - devm_kzalloc\n      -\
  \ devm_kcalloc_node / devm_kmalloc_node (optional, if you want broader coverage)\n\
  \    - Keep the list tight to avoid FPs.\n- Implementation steps:\n  1. If !isDevmAllocator(Call),\
  \ return.\n  2. SVal Ret = Call.getReturnValue(); extract SymbolRef:\n     - SymbolRef\
  \ Sym = Ret.getAsSymbol();\n     - If null, also try if Ret.getAsRegion() is a SymbolicRegion\
  \ and get its symbol (SymbolicRegion->getSymbol()).\n  3. If a SymbolRef was obtained,\
  \ insert it into DevmAllocSyms via State = State->add<DevmAllocSyms>(Sym) and C.addTransition(State).\n\
  \nB) checkPreCall \u2014 detect manual frees of devm-managed pointers\n\n- Goal:\
  \ flag calls that free a pointer which originates from a devm_* allocator.\n- Recognize\
  \ manual-free-like functions and which argument is freed:\n  - Implement helper\
  \ functionKnownToFree(const CallEvent &Call, SmallVectorImpl<unsigned> &FreedParams):\n\
  \    - If callee name equals:\n      - \"kfree\" -> FreedParams = {0}\n      - \"\
  kvfree\" -> {0}\n      - \"vfree\" -> {0}\n      - \"pinctrl_utils_free_map\" ->\
  \ {1}  // The second argument is freed\n    - Return true if matched, false otherwise.\n\
  - Implementation steps:\n  1. If !functionKnownToFree(Call, FreedParams), return.\n\
  \  2. For each index I in FreedParams:\n     - const Expr *ArgE = Call.getArgExpr(I);\
  \ SVal ArgV = Call.getArgSVal(I).\n     - Skip if definitely null:\n       - If\
  \ ArgV.isZeroConstant() (or using state assumptions it simplifies to only null),\
  \ continue to next parameter.\n     - Extract the pointer symbol:\n       - SymbolRef\
  \ Sym = ArgV.getAsSymbol();\n       - If null, try:\n         - If ArgV.getAsRegion()\
  \ is a SymbolicRegion, get its symbol.\n         - If ArgV.getAsRegion() is an Element/Field\
  \ region whose base is SymbolicRegion, get the base\u2019s symbol.\n     - If Sym\
  \ is non-null and State->contains<DevmAllocSyms>(Sym):\n       - This is a manual\
  \ free of a devm-managed pointer. Report a bug.\n       - Create ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n       - If N is non-null, create a PathSensitiveBugReport:\n\
  \         - Name: \"double free of devm-managed pointer\"\n         - Short message:\
  \ \"Manual free of devm_* allocated pointer (double free)\"\n         - Add the\
  \ argument source range ArgE->getSourceRange() as the primary range.\n         -\
  \ Optionally add a note: the bug path will usually show the allocation; no extra\
  \ state needed.\n       - Emit the report and return.\n- Rationale: The devm-managed\
  \ allocation will be freed automatically on device detach. Manual free via kfree/kvfree\
  \ or helpers (like pinctrl_utils_free_map) introduces a double free risk. We specifically\
  \ handle pinctrl_utils_free_map freeing its 2nd parameter.\n\nC) Optional: checkEndFunction\
  \ / others\n\n- Not necessary. We only need checkPostCall and checkPreCall for this\
  \ pattern.\n- No checkBind: symbol propagation naturally keeps the same pointer\
  \ symbol across assignments in CSA, so alias-tracking maps are not needed for this\
  \ simple pattern.\n\n3) Additional details and safeguards\n\n- Avoid false positives\
  \ on NULL pointers: before reporting, ensure the argument is not definitely NULL\
  \ (skip reports if analyzer proves it\u2019s NULL).\n- Keep the known free table\
  \ small and focused. The primary target is:\n  - kfree/kvfree/vfree\n  - pinctrl_utils_free_map\
  \ (index 1)\n- Keep the known devm allocators focused. The primary target for this\
  \ patch is devm_kcalloc, but include its immediate siblings to make the checker\
  \ generally useful.\n- Reporting:\n  - Keep message short: \"Manual free of devm_*\
  \ allocated pointer (double free)\"\n  - One report per call site. No need to record\
  \ \u201Calready reported\u201D state.\n\n4) Summary of flow\n\n- devm_* allocator\
  \ returns pointer -> checkPostCall taints its SymbolRef by inserting into DevmAllocSyms.\n\
  - Later, a manual free function is called -> checkPreCall checks the freed argument\u2019\
  s symbol against DevmAllocSyms; if present and pointer not proven NULL, report.\n\
  \nThis minimal design reliably finds the target bug pattern exemplified by:\n- map\
  \ = devm_kcalloc(...);\n- ...\n- pinctrl_utils_free_map(..., map, ...); // frees\
  \ parameter 1 internally via kfree(map)\nand similar cases where a devm-managed\
  \ pointer is manually freed."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/SmallVector.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_SET_WITH_PROGRAMSTATE(DevmAllocSyms,\
  \ SymbolRef)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PostCall,\
  \ check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n   \
  \   SAGenTestChecker()\n          : BT(new BugType(this, \"Double free of devm-managed\
  \ pointer\", \"Memory Management\")) {}\n\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      void checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n\n   private:\n      static bool isDevmAllocator(const\
  \ CallEvent &Call, CheckerContext &C);\n      static bool functionKnownToFree(const\
  \ CallEvent &Call,\n                                      llvm::SmallVectorImpl<unsigned>\
  \ &FreedParams,\n                                      CheckerContext &C);\n   \
  \   static SymbolRef getPtrSymbolFromSVal(SVal V);\n      void reportManualFreeOfDevm(const\
  \ CallEvent &Call, const Expr *ArgE, CheckerContext &C) const;\n};\n\nstatic bool\
  \ isNameOneOf(const Expr *E, CheckerContext &C,\n                        std::initializer_list<const\
  \ char*> Names) {\n  if (!E) return false;\n  for (const char *N : Names) {\n  \
  \  if (ExprHasName(E, N, C))\n      return true;\n  }\n  return false;\n}\n\nbool\
  \ SAGenTestChecker::isDevmAllocator(const CallEvent &Call, CheckerContext &C) {\n\
  \  const Expr *OE = Call.getOriginExpr();\n  return isNameOneOf(OE, C, {\n    \"\
  devm_kcalloc\",\n    \"devm_kmalloc\",\n    \"devm_kmalloc_array\",\n    \"devm_kzalloc\"\
  ,\n    \"devm_kcalloc_node\",\n    \"devm_kmalloc_node\",\n    \"devm_kasprintf\"\
  \n  });\n}\n\nbool SAGenTestChecker::functionKnownToFree(const CallEvent &Call,\n\
  \                                           llvm::SmallVectorImpl<unsigned> &FreedParams,\n\
  \                                           CheckerContext &C) {\n  const Expr *OE\
  \ = Call.getOriginExpr();\n  if (!OE)\n    return false;\n\n  if (ExprHasName(OE,\
  \ \"kfree\", C) ||\n      ExprHasName(OE, \"kvfree\", C) ||\n      ExprHasName(OE,\
  \ \"vfree\", C)) {\n    FreedParams.push_back(0);\n    return true;\n  }\n\n  if\
  \ (ExprHasName(OE, \"pinctrl_utils_free_map\", C)) {\n    // pinctrl_utils_free_map(pctldev,\
  \ map, nmaps)\n    FreedParams.push_back(1);\n    return true;\n  }\n\n  return\
  \ false;\n}\n\nSymbolRef SAGenTestChecker::getPtrSymbolFromSVal(SVal V) {\n  if\
  \ (SymbolRef S = V.getAsSymbol())\n    return S;\n\n  if (const MemRegion *MR =\
  \ V.getAsRegion()) {\n    MR = MR->getBaseRegion();\n    if (const auto *SR = dyn_cast<SymbolicRegion>(MR))\n\
  \      return SR->getSymbol();\n  }\n  return nullptr;\n}\n\nvoid SAGenTestChecker::reportManualFreeOfDevm(const\
  \ CallEvent &Call, const Expr *ArgE,\n                                         \
  \     CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Manual free of devm_* allocated pointer (double free)\", N);\n  if\
  \ (ArgE)\n    R->addRange(ArgE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  if (!isDevmAllocator(Call, C))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n\n  SVal Ret = Call.getReturnValue();\n  SymbolRef Sym\
  \ = getPtrSymbolFromSVal(Ret);\n  if (!Sym)\n    return;\n\n  if (!State->contains<DevmAllocSyms>(Sym))\
  \ {\n    State = State->add<DevmAllocSyms>(Sym);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  llvm::SmallVector<unsigned, 4> FreedParams;\n  if (!functionKnownToFree(Call,\
  \ FreedParams, C))\n    return;\n\n  ProgramStateRef State = C.getState();\n\n \
  \ for (unsigned Idx : FreedParams) {\n    if (Idx >= Call.getNumArgs())\n      continue;\n\
  \n    const Expr *ArgE = Call.getArgExpr(Idx);\n    SVal ArgV = Call.getArgSVal(Idx);\n\
  \n    // Skip definite NULL frees if trivially known; conservatively continue otherwise.\n\
  \    if (ArgV.isZeroConstant())\n      continue;\n\n    SymbolRef Sym = getPtrSymbolFromSVal(ArgV);\n\
  \    if (!Sym)\n      continue;\n\n    if (State->contains<DevmAllocSyms>(Sym))\
  \ {\n      reportManualFreeOfDevm(Call, ArgE, C);\n      // One report per call\
  \ site is enough.\n      return;\n    }\n  }\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect manual free of devm_* allocated\
  \ pointers (double free)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
