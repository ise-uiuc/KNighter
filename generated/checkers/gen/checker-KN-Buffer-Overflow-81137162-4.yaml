_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 81137162bfaa7278785b24c1fd2e9e74f082e8e4
commit_type: Buffer-Overflow
index: 4
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include <string>\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// No custom program state is needed.\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"Unbounded strcpy into fixed-size buffer\", \"Buffer Overflow\"\
  )) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \n   private:\n      // Helpers\n      static bool extractFixedArraySizeFromMemberExpr(const\
  \ MemberExpr *ME, llvm::APInt &OutSize, std::string &FieldName);\n      static bool\
  \ getFixedArraySizeFromDestArg(const Expr *DestE, CheckerContext &C, llvm::APInt\
  \ &OutSize, std::string &FieldName);\n      static bool getStringLiteralSizeOfExpr(const\
  \ Expr *E, CheckerContext &C, llvm::APInt &OutSize);\n      static bool getFixedArraySizeFromExpr(const\
  \ Expr *E, CheckerContext &C, llvm::APInt &OutSize);\n};\n\nbool SAGenTestChecker::extractFixedArraySizeFromMemberExpr(const\
  \ MemberExpr *ME,\n                                                           llvm::APInt\
  \ &OutSize,\n                                                           std::string\
  \ &FieldName) {\n  if (!ME)\n    return false;\n  const ValueDecl *VD = ME->getMemberDecl();\n\
  \  const FieldDecl *FD = dyn_cast_or_null<FieldDecl>(VD);\n  if (!FD)\n    return\
  \ false;\n\n  QualType FT = FD->getType();\n  const Type *Ty = FT.getTypePtrOrNull();\n\
  \  if (!Ty)\n    return false;\n\n  const ConstantArrayType *CAT = dyn_cast<ConstantArrayType>(Ty);\n\
  \  if (!CAT)\n    return false;\n\n  OutSize = CAT->getSize();\n  FieldName = FD->getNameAsString();\n\
  \  return true;\n}\n\nbool SAGenTestChecker::getFixedArraySizeFromDestArg(const\
  \ Expr *DestE,\n                                                    CheckerContext\
  \ &C,\n                                                    llvm::APInt &OutSize,\n\
  \                                                    std::string &FieldName) {\n\
  \  if (!DestE)\n    return false;\n\n  // Try to find DeclRefExpr in children\n\
  \  if (const auto *DREChild = findSpecificTypeInChildren<DeclRefExpr>(DestE)) {\n\
  \    if (getArraySizeFromExpr(OutSize, DREChild)) {\n      FieldName.clear();\n\
  \      return true;\n    }\n  }\n\n  // Try direct DeclRefExpr after ignoring implicit\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(DestE->IgnoreImpCasts())) {\n   \
  \ if (getArraySizeFromExpr(OutSize, DRE)) {\n      FieldName.clear();\n      return\
  \ true;\n    }\n  }\n\n  // Try to find MemberExpr in children\n  if (const auto\
  \ *MEChild = findSpecificTypeInChildren<MemberExpr>(DestE)) {\n    if (extractFixedArraySizeFromMemberExpr(MEChild,\
  \ OutSize, FieldName))\n      return true;\n  }\n\n  // Try direct MemberExpr\n\
  \  if (const auto *MEDirect = dyn_cast<MemberExpr>(DestE->IgnoreImpCasts())) {\n\
  \    if (extractFixedArraySizeFromMemberExpr(MEDirect, OutSize, FieldName))\n  \
  \    return true;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::getStringLiteralSizeOfExpr(const\
  \ Expr *E, CheckerContext &C,\n                                                \
  \  llvm::APInt &OutSize) {\n  if (!E)\n    return false;\n  const Expr *EI = E->IgnoreImpCasts();\n\
  \  return getStringSize(OutSize, EI);\n}\n\nbool SAGenTestChecker::getFixedArraySizeFromExpr(const\
  \ Expr *E, CheckerContext &C,\n                                                \
  \ llvm::APInt &OutSize) {\n  if (!E)\n    return false;\n\n  // DeclRefExpr path\n\
  \  if (const auto *DREChild = findSpecificTypeInChildren<DeclRefExpr>(E)) {\n  \
  \  if (getArraySizeFromExpr(OutSize, DREChild))\n      return true;\n  }\n  if (const\
  \ auto *DREDirect = dyn_cast<DeclRefExpr>(E->IgnoreImpCasts())) {\n    if (getArraySizeFromExpr(OutSize,\
  \ DREDirect))\n      return true;\n  }\n\n  // MemberExpr path\n  std::string Dummy;\n\
  \  if (const auto *MEChild = findSpecificTypeInChildren<MemberExpr>(E)) {\n    if\
  \ (extractFixedArraySizeFromMemberExpr(MEChild, OutSize, Dummy))\n      return true;\n\
  \  }\n  if (const auto *MEDirect = dyn_cast<MemberExpr>(E->IgnoreImpCasts())) {\n\
  \    if (extractFixedArraySizeFromMemberExpr(MEDirect, OutSize, Dummy))\n      return\
  \ true;\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return;\n\n  // Confirm it's a call to strcpy\n  if (!ExprHasName(OriginExpr,\
  \ \"strcpy\", C))\n    return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n\
  \  const Expr *DestE = Call.getArgExpr(0);\n  const Expr *SrcE  = Call.getArgExpr(1);\n\
  \  if (!DestE || !SrcE)\n    return;\n\n  // Determine destination fixed array size\n\
  \  llvm::APInt DestSize;\n  std::string FieldName;\n  if (!getFixedArraySizeFromDestArg(DestE,\
  \ C, DestSize, FieldName))\n    return; // Only warn when destination is a known\
  \ fixed-size array\n\n  // Determine source length/upper bound if possible\n  llvm::APInt\
  \ SrcStrLen;\n  bool SrcIsStringLiteral = getStringLiteralSizeOfExpr(SrcE, C, SrcStrLen);\n\
  \n  // If source is a string literal, we can precisely tell overflow:\n  // Need\
  \ DestSize > SrcLen to fit null terminator. If SrcLen >= DestSize, definite overflow.\n\
  \  if (SrcIsStringLiteral) {\n    if (SrcStrLen.uge(DestSize)) {\n      ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n      if (!N)\n        return;\n\n      std::string\
  \ Msg = \"strcpy overflows fixed-size buffer\";\n      if (!FieldName.empty()) {\n\
  \        Msg += \" into field '\";\n        Msg += FieldName;\n        Msg += \"\
  '\";\n      }\n\n      auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg,\
  \ N);\n      R->addRange(Call.getSourceRange());\n      C.emitReport(std::move(R));\n\
  \    }\n    return; // If literal fits, it's safe; no report.\n  }\n\n  // Try to\
  \ detect if source is also a fixed-size array (capacity bound).\n  llvm::APInt SrcArrSize;\n\
  \  if (getFixedArraySizeFromExpr(SrcE, C, SrcArrSize)) {\n    // If source capacity\
  \ is >= dest capacity, strcpy may overflow.\n    // We still treat it as a potential\
  \ overflow.\n    if (SrcArrSize.uge(DestSize)) {\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \      if (!N)\n        return;\n\n      std::string Msg = \"Unbounded strcpy into\
  \ fixed-size buffer may overflow\";\n      if (!FieldName.empty()) {\n        Msg\
  \ += \" (field '\";\n        Msg += FieldName;\n        Msg += \"')\";\n      }\n\
  \n      auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n      R->addRange(Call.getSourceRange());\n\
  \      C.emitReport(std::move(R));\n    }\n    return; // If source capacity < dest\
  \ capacity, likely okay; no report.\n  }\n\n  // Unknown source length; strcpy is\
  \ unbounded -> potential overflow.\n  {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    std::string Msg = \"Unbounded strcpy into fixed-size\
  \ buffer may overflow\";\n    if (!FieldName.empty()) {\n      Msg += \" (field\
  \ '\";\n      Msg += FieldName;\n      Msg += \"')\";\n    }\n\n    auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n    R->addRange(Call.getSourceRange());\n    C.emitReport(std::move(R));\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unbounded strcpy into fixed-size buffers (e.g., struct fields)\
  \ that may overflow\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: hci_core: Fix possible buffer overflow\n\
  \nstruct hci_dev_info has a fixed size name[8] field so in the event that\nhdev->name\
  \ is bigger than that strcpy would attempt to write past its\nsize, so this fixes\
  \ this problem by switching to use strscpy.\n\nFixes: dcda165706b9 (\"Bluetooth:\
  \ hci_core: Fix build warnings\")\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\n\
  \n## Buggy Code\n\n```c\n// Function: hci_get_dev_info in net/bluetooth/hci_core.c\n\
  int hci_get_dev_info(void __user *arg)\n{\n\tstruct hci_dev *hdev;\n\tstruct hci_dev_info\
  \ di;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (copy_from_user(&di, arg,\
  \ sizeof(di)))\n\t\treturn -EFAULT;\n\n\thdev = hci_dev_get(di.dev_id);\n\tif (!hdev)\n\
  \t\treturn -ENODEV;\n\n\t/* When the auto-off is configured it means the transport\n\
  \t * is running, but in that case still indicate that the\n\t * device is actually\
  \ down.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_AUTO_OFF))\n\t\tflags = hdev->flags\
  \ & ~BIT(HCI_UP);\n\telse\n\t\tflags = hdev->flags;\n\n\tstrcpy(di.name, hdev->name);\n\
  \tdi.bdaddr   = hdev->bdaddr;\n\tdi.type     = (hdev->bus & 0x0f) | ((hdev->dev_type\
  \ & 0x03) << 4);\n\tdi.flags    = flags;\n\tdi.pkt_type = hdev->pkt_type;\n\tif\
  \ (lmp_bredr_capable(hdev)) {\n\t\tdi.acl_mtu  = hdev->acl_mtu;\n\t\tdi.acl_pkts\
  \ = hdev->acl_pkts;\n\t\tdi.sco_mtu  = hdev->sco_mtu;\n\t\tdi.sco_pkts = hdev->sco_pkts;\n\
  \t} else {\n\t\tdi.acl_mtu  = hdev->le_mtu;\n\t\tdi.acl_pkts = hdev->le_pkts;\n\t\
  \tdi.sco_mtu  = 0;\n\t\tdi.sco_pkts = 0;\n\t}\n\tdi.link_policy = hdev->link_policy;\n\
  \tdi.link_mode   = hdev->link_mode;\n\n\tmemcpy(&di.stat, &hdev->stat, sizeof(di.stat));\n\
  \tmemcpy(&di.features, &hdev->features, sizeof(di.features));\n\n\tif (copy_to_user(arg,\
  \ &di, sizeof(di)))\n\t\terr = -EFAULT;\n\n\thci_dev_put(hdev);\n\n\treturn err;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c\n\
  index 6ca4c0df9f9c..230d2bbb933b 100644\n--- a/net/bluetooth/hci_core.c\n+++ b/net/bluetooth/hci_core.c\n\
  @@ -908,7 +908,7 @@ int hci_get_dev_info(void __user *arg)\n \telse\n \t\tflags\
  \ = hdev->flags;\n \n-\tstrcpy(di.name, hdev->name);\n+\tstrscpy(di.name, hdev->name,\
  \ sizeof(di.name));\n \tdi.bdaddr   = hdev->bdaddr;\n \tdi.type     = (hdev->bus\
  \ & 0x0f) | ((hdev->dev_type & 0x03) << 4);\n \tdi.flags    = flags;\n```\n"
pattern: '## Bug Pattern


  Using an unbounded string copy (strcpy) to copy a variable-length source string
  into a fixed-size struct field (e.g., name[8]) without validating or limiting the
  length, causing potential buffer overflow when the source exceeds the destination
  size.'
plan: "1) Program State\n- No custom program state is necessary. The pattern is detected\
  \ locally at the call site of strcpy.\n\n2) Callback Functions and Implementation\
  \ Details\n\n- checkPreCall(const CallEvent &Call, CheckerContext &C) const\n  Goal:\
  \ Detect unbounded strcpy into a fixed-size buffer (especially struct fields).\n\
  \  Steps:\n  1. Identify strcpy:\n     - Get callee identifier via Call.getCalleeIdentifier().\n\
  \     - If null or name != \"strcpy\", return.\n\n  2. Extract arguments:\n    \
  \ - DestE = Call.getArgExpr(0)\n     - SrcE  = Call.getArgExpr(1)\n\n  3. Determine\
  \ destination buffer as a fixed-size array:\n     - Remove implicit casts from DestE:\
  \ E0 = DestE->IgnoreImpCasts().\n     - Try to find an underlying DeclRefExpr or\
  \ MemberExpr:\n       - Prefer using findSpecificTypeInChildren<DeclRefExpr>(DestE)\
  \ and if not found, findSpecificTypeInChildren<MemberExpr>(DestE). If these return\
  \ null, also try E0 directly if it is DeclRefExpr or MemberExpr.\n     - If DeclRefExpr:\n\
  \       - Use provided getArraySizeFromExpr(ArraySize, FoundDeclRefExpr).\n    \
  \ - If MemberExpr:\n       - Retrieve the FieldDecl: auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl()).\n\
  \       - From FD->getType(), if it\u2019s ConstantArrayType (const ConstantArrayType\
  \ *CAT = dyn_cast<ConstantArrayType>(FD->getType().getTypePtr())), obtain its size\
  \ (CAT->getSize()).\n     - If destination is not identified as a ConstantArrayType\
  \ with a known bound, return (we only warn when a fixed-size destination is known).\n\
  \n  4. Evaluate source size if possible:\n     - Remove implicit casts from SrcE:\
  \ E1 = SrcE->IgnoreImpCasts().\n     - If E1 is StringLiteral, use provided getStringSize(StringSize,\
  \ E1). If true:\n       - If StringSize >= DestArraySize, report a definite overflow\
  \ (see reporting below).\n       - Else (StringSize < DestArraySize), do not report\
  \ (safe case).\n     - Else (source is not a string literal):\n       - Optionally\
  \ try to detect if source is a fixed-size array too:\n         - Look for DeclRefExpr\
  \ or MemberExpr in the source via findSpecificTypeInChildren.\n         - If found\
  \ and it resolves to ConstantArrayType with size S, and S >= DestArraySize, report\
  \ as a likely overflow.\n       - If no reliable upper bound for source can be determined,\
  \ report a potential overflow because strcpy is unbounded and destination has a\
  \ fixed size.\n\n  5. Bug reporting:\n     - Create a non-fatal error node via generateNonFatalErrorNode()\
  \ and bail out if null.\n     - Message should be short and clear:\n       - For\
  \ definite overflow (string literal too long): \"strcpy overflows fixed-size buffer.\"\
  \n       - For potential overflow (variable-length source): \"Unbounded strcpy into\
  \ fixed-size buffer may overflow.\"\n     - If the destination is a struct field\
  \ (MemberExpr with FieldDecl), include the field name in the message when available\
  \ (e.g., \"\u2026 into field 'name'\").\n     - Use std::make_unique<PathSensitiveBugReport>(BugType,\
  \ Message, ErrorNode) and C.emitReport(std::move(R)).\n\n3) Helper Logic (inside\
  \ the checker; no program state)\n- getFixedArraySizeFromDestArg(const Expr *DestE,\
  \ CheckerContext &C, llvm::APInt &OutSize):\n  - Try DeclRefExpr path first using\
  \ getArraySizeFromExpr(OutSize, DRE).\n  - Try MemberExpr path by inspecting FieldDecl->getType()\
  \ as ConstantArrayType.\n  - If both fail, return false.\n- getSourceStringLiteralSize(const\
  \ Expr *SrcE, CheckerContext &C, llvm::APInt &OutSize):\n  - Use provided getStringSize(OutSize,\
  \ SrcE->IgnoreImpCasts()).\n\n4) Notes and Reasoning\n- We focus on strcpy since\
  \ it is unbounded; strscpy/strlcpy are safe alternatives that require an explicit\
  \ bound. The fix in the patch uses strscpy with sizeof(dest).\n- We only warn when\
  \ the destination size is known and fixed (ConstantArrayType). This targets exactly\
  \ the risky pattern (copying into a fixed-size array field like name[8]).\n- We\
  \ avoid tracking aliases or path conditions; no state maps are needed.\n- We use\
  \ the supplied utilities:\n  - findSpecificTypeInChildren to recover DeclRefExpr/MemberExpr\
  \ under implicit decay/casts.\n  - getArraySizeFromExpr for DeclRefExpr destinations.\n\
  \  - getStringSize for source literals.\n- Reporting is concise, as requested."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include <string>\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// No custom program state is needed.\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"Unbounded strcpy into fixed-size buffer\", \"Buffer Overflow\"\
  )) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \n   private:\n      // Helpers\n      static bool extractFixedArraySizeFromMemberExpr(const\
  \ MemberExpr *ME, llvm::APInt &OutSize, std::string &FieldName);\n      static bool\
  \ getFixedArraySizeFromDestArg(const Expr *DestE, CheckerContext &C, llvm::APInt\
  \ &OutSize, std::string &FieldName);\n      static bool getStringLiteralSizeOfExpr(const\
  \ Expr *E, CheckerContext &C, llvm::APInt &OutSize);\n      static bool getFixedArraySizeFromExpr(const\
  \ Expr *E, CheckerContext &C, llvm::APInt &OutSize);\n};\n\nbool SAGenTestChecker::extractFixedArraySizeFromMemberExpr(const\
  \ MemberExpr *ME,\n                                                           llvm::APInt\
  \ &OutSize,\n                                                           std::string\
  \ &FieldName) {\n  if (!ME)\n    return false;\n  const ValueDecl *VD = ME->getMemberDecl();\n\
  \  const FieldDecl *FD = dyn_cast_or_null<FieldDecl>(VD);\n  if (!FD)\n    return\
  \ false;\n\n  QualType FT = FD->getType();\n  const Type *Ty = FT.getTypePtrOrNull();\n\
  \  if (!Ty)\n    return false;\n\n  const ConstantArrayType *CAT = dyn_cast<ConstantArrayType>(Ty);\n\
  \  if (!CAT)\n    return false;\n\n  OutSize = CAT->getSize();\n  FieldName = FD->getNameAsString();\n\
  \  return true;\n}\n\nbool SAGenTestChecker::getFixedArraySizeFromDestArg(const\
  \ Expr *DestE,\n                                                    CheckerContext\
  \ &C,\n                                                    llvm::APInt &OutSize,\n\
  \                                                    std::string &FieldName) {\n\
  \  if (!DestE)\n    return false;\n\n  // Try to find DeclRefExpr in children\n\
  \  if (const auto *DREChild = findSpecificTypeInChildren<DeclRefExpr>(DestE)) {\n\
  \    if (getArraySizeFromExpr(OutSize, DREChild)) {\n      FieldName.clear();\n\
  \      return true;\n    }\n  }\n\n  // Try direct DeclRefExpr after ignoring implicit\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(DestE->IgnoreImpCasts())) {\n   \
  \ if (getArraySizeFromExpr(OutSize, DRE)) {\n      FieldName.clear();\n      return\
  \ true;\n    }\n  }\n\n  // Try to find MemberExpr in children\n  if (const auto\
  \ *MEChild = findSpecificTypeInChildren<MemberExpr>(DestE)) {\n    if (extractFixedArraySizeFromMemberExpr(MEChild,\
  \ OutSize, FieldName))\n      return true;\n  }\n\n  // Try direct MemberExpr\n\
  \  if (const auto *MEDirect = dyn_cast<MemberExpr>(DestE->IgnoreImpCasts())) {\n\
  \    if (extractFixedArraySizeFromMemberExpr(MEDirect, OutSize, FieldName))\n  \
  \    return true;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::getStringLiteralSizeOfExpr(const\
  \ Expr *E, CheckerContext &C,\n                                                \
  \  llvm::APInt &OutSize) {\n  if (!E)\n    return false;\n  const Expr *EI = E->IgnoreImpCasts();\n\
  \  return getStringSize(OutSize, EI);\n}\n\nbool SAGenTestChecker::getFixedArraySizeFromExpr(const\
  \ Expr *E, CheckerContext &C,\n                                                \
  \ llvm::APInt &OutSize) {\n  if (!E)\n    return false;\n\n  // DeclRefExpr path\n\
  \  if (const auto *DREChild = findSpecificTypeInChildren<DeclRefExpr>(E)) {\n  \
  \  if (getArraySizeFromExpr(OutSize, DREChild))\n      return true;\n  }\n  if (const\
  \ auto *DREDirect = dyn_cast<DeclRefExpr>(E->IgnoreImpCasts())) {\n    if (getArraySizeFromExpr(OutSize,\
  \ DREDirect))\n      return true;\n  }\n\n  // MemberExpr path\n  std::string Dummy;\n\
  \  if (const auto *MEChild = findSpecificTypeInChildren<MemberExpr>(E)) {\n    if\
  \ (extractFixedArraySizeFromMemberExpr(MEChild, OutSize, Dummy))\n      return true;\n\
  \  }\n  if (const auto *MEDirect = dyn_cast<MemberExpr>(E->IgnoreImpCasts())) {\n\
  \    if (extractFixedArraySizeFromMemberExpr(MEDirect, OutSize, Dummy))\n      return\
  \ true;\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return;\n\n  // Confirm it's a call to strcpy\n  if (!ExprHasName(OriginExpr,\
  \ \"strcpy\", C))\n    return;\n\n  if (Call.getNumArgs() < 2)\n    return;\n\n\
  \  const Expr *DestE = Call.getArgExpr(0);\n  const Expr *SrcE  = Call.getArgExpr(1);\n\
  \  if (!DestE || !SrcE)\n    return;\n\n  // Determine destination fixed array size\n\
  \  llvm::APInt DestSize;\n  std::string FieldName;\n  if (!getFixedArraySizeFromDestArg(DestE,\
  \ C, DestSize, FieldName))\n    return; // Only warn when destination is a known\
  \ fixed-size array\n\n  // Determine source length/upper bound if possible\n  llvm::APInt\
  \ SrcStrLen;\n  bool SrcIsStringLiteral = getStringLiteralSizeOfExpr(SrcE, C, SrcStrLen);\n\
  \n  // If source is a string literal, we can precisely tell overflow:\n  // Need\
  \ DestSize > SrcLen to fit null terminator. If SrcLen >= DestSize, definite overflow.\n\
  \  if (SrcIsStringLiteral) {\n    if (SrcStrLen.uge(DestSize)) {\n      ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n      if (!N)\n        return;\n\n      std::string\
  \ Msg = \"strcpy overflows fixed-size buffer\";\n      if (!FieldName.empty()) {\n\
  \        Msg += \" into field '\";\n        Msg += FieldName;\n        Msg += \"\
  '\";\n      }\n\n      auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg,\
  \ N);\n      R->addRange(Call.getSourceRange());\n      C.emitReport(std::move(R));\n\
  \    }\n    return; // If literal fits, it's safe; no report.\n  }\n\n  // Try to\
  \ detect if source is also a fixed-size array (capacity bound).\n  llvm::APInt SrcArrSize;\n\
  \  if (getFixedArraySizeFromExpr(SrcE, C, SrcArrSize)) {\n    // If source capacity\
  \ is >= dest capacity, strcpy may overflow.\n    // We still treat it as a potential\
  \ overflow.\n    if (SrcArrSize.uge(DestSize)) {\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \      if (!N)\n        return;\n\n      std::string Msg = \"Unbounded strcpy into\
  \ fixed-size buffer may overflow\";\n      if (!FieldName.empty()) {\n        Msg\
  \ += \" (field '\";\n        Msg += FieldName;\n        Msg += \"')\";\n      }\n\
  \n      auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n      R->addRange(Call.getSourceRange());\n\
  \      C.emitReport(std::move(R));\n    }\n    return; // If source capacity < dest\
  \ capacity, likely okay; no report.\n  }\n\n  // Unknown source length; strcpy is\
  \ unbounded -> potential overflow.\n  {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    std::string Msg = \"Unbounded strcpy into fixed-size\
  \ buffer may overflow\";\n    if (!FieldName.empty()) {\n      Msg += \" (field\
  \ '\";\n      Msg += FieldName;\n      Msg += \"')\";\n    }\n\n    auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n    R->addRange(Call.getSourceRange());\n    C.emitReport(std::move(R));\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unbounded strcpy into fixed-size buffers (e.g., struct fields)\
  \ that may overflow\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
