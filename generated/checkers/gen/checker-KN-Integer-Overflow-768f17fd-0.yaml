_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 768f17fd25e4a98bf5166148629ecf6f647d5efc
commit_type: Integer-Overflow
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"llvm/ADT/StringRef.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states needed\n// REGISTER_MAP_WITH_PROGRAMSTATE(...) not required\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostStmt<DeclStmt>,\n\
  \        check::Bind,\n        check::PreStmt<ReturnStmt>,\n        check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Narrow shift widened to 64-bit\", \"Integer\")) {}\n\n\
  \      void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;\n      void\
  \ checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n     \
  \ void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;\n      void\
  \ checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\
  \      void analyzeAndReportShiftToWide(const Expr *E, QualType DestTy,\n      \
  \                                 CheckerContext &C, StringRef Ctx) const;\n\n \
  \     static const BinaryOperator *findShiftInTree(const Stmt *S);\n      static\
  \ bool hasExplicitCastToWide64(const Expr *E, ASTContext &ACtx);\n};\n\nstatic const\
  \ BinaryOperator *asShift(const Stmt *S) {\n  if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S))\
  \ {\n    if (BO->getOpcode() == BO_Shl)\n      return BO;\n  }\n  return nullptr;\n\
  }\n\nconst BinaryOperator *SAGenTestChecker::findShiftInTree(const Stmt *S) {\n\
  \  if (!S)\n    return nullptr;\n\n  if (const BinaryOperator *B = asShift(S))\n\
  \    return B;\n\n  for (const Stmt *Child : S->children()) {\n    if (const BinaryOperator\
  \ *Res = findShiftInTree(Child))\n      return Res;\n  }\n  return nullptr;\n}\n\
  \nbool SAGenTestChecker::hasExplicitCastToWide64(const Expr *E, ASTContext &ACtx)\
  \ {\n  if (!E)\n    return false;\n\n  // Look for any explicit cast to integer\
  \ type with width >= 64 within E's subtree.\n  if (const auto *ECE = dyn_cast<ExplicitCastExpr>(E->IgnoreParens()))\
  \ {\n    QualType ToTy = ECE->getType();\n    if (ToTy->isIntegerType() && ACtx.getIntWidth(ToTy)\
  \ >= 64)\n      return true;\n  }\n\n  for (const Stmt *Child : E->children()) {\n\
  \    if (!Child)\n      continue;\n    if (const auto *CE = dyn_cast<Expr>(Child))\
  \ {\n      if (hasExplicitCastToWide64(CE, ACtx))\n        return true;\n    } else\
  \ {\n      if (const BinaryOperator *B = asShift(Child)) {\n        (void)B; //\
  \ not needed here\n      }\n      // Continue traversal for safety\n      if (const\
  \ BinaryOperator *B2 = findShiftInTree(Child)) {\n        (void)B2;\n      }\n \
  \   }\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::analyzeAndReportShiftToWide(const\
  \ Expr *E, QualType DestTy,\n                                                  \
  \ CheckerContext &C, StringRef) const {\n  if (!E)\n    return;\n\n  ASTContext\
  \ &ACtx = C.getASTContext();\n\n  if (!DestTy->isIntegerType())\n    return;\n\n\
  \  unsigned DestW = ACtx.getIntWidth(DestTy);\n  if (DestW < 64)\n    return;\n\n\
  \  // Find a left-shift operator within the expression tree.\n  const BinaryOperator\
  \ *Shl = findShiftInTree(E);\n  if (!Shl || Shl->getOpcode() != BO_Shl)\n    return;\n\
  \n  const Expr *L = Shl->getLHS();\n  const Expr *R = Shl->getRHS();\n  if (!L ||\
  \ !R)\n    return;\n\n  QualType ShlTy = Shl->getType();\n  if (!ShlTy->isIntegerType())\n\
  \    return;\n\n  unsigned ShlW = ACtx.getIntWidth(ShlTy);\n  if (ShlW >= 64)\n\
  \    return; // Shift already performed in 64-bit, OK.\n\n  // If LHS type is already\
  \ 64-bit (or wider), no issue.\n  if (L->getType()->isIntegerType()) {\n    unsigned\
  \ LHSW = ACtx.getIntWidth(L->getType());\n    if (LHSW >= 64)\n      return;\n\n\
  \    // If there is an explicit cast to >=64-bit within the LHS subtree, suppress.\n\
  \    if (hasExplicitCastToWide64(L, ACtx))\n      return;\n\n    // Try to evaluate\
  \ RHS; if it's a constant less than LHS width, suppress to reduce FPs.\n    llvm::APSInt\
  \ RHSEval;\n    if (EvaluateExprToInt(RHSEval, R, C)) {\n      // Treat negative\
  \ or very large values conservatively.\n      if (!RHSEval.isSigned() || !RHSEval.isNegative())\
  \ {\n        uint64_t ShiftAmt = RHSEval.getZExtValue();\n        if (ShiftAmt <\
  \ LHSW) {\n          // Heuristic suppression per plan.\n          return;\n   \
  \     }\n      }\n    }\n  } else {\n    // Non-integer LHS shouldn't happen for\
  \ <<, but be safe.\n    return;\n  }\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto Rpt = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Shift done in 32-bit, widened after; cast left operand to 64-bit before\
  \ <<\", N);\n  Rpt->addRange(Shl->getSourceRange());\n  C.emitReport(std::move(Rpt));\n\
  }\n\nvoid SAGenTestChecker::checkPostStmt(const DeclStmt *DS, CheckerContext &C)\
  \ const {\n  if (!DS)\n    return;\n\n  for (const Decl *D : DS->decls()) {\n  \
  \  const auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      continue;\n    if\
  \ (!VD->hasInit())\n      continue;\n\n    QualType DestTy = VD->getType();\n  \
  \  const Expr *Init = VD->getInit();\n    analyzeAndReportShiftToWide(Init, DestTy,\
  \ C, \"initialization\");\n  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal, SVal,\
  \ const Stmt *S, CheckerContext &C) const {\n  // Only handle assignments: LHS =\
  \ RHS;\n  const auto *BO = dyn_cast_or_null<BinaryOperator>(S);\n  if (!BO || !BO->isAssignmentOp())\n\
  \    return;\n\n  const Expr *LHS = BO->getLHS();\n  const Expr *RHS = BO->getRHS();\n\
  \  if (!LHS || !RHS)\n    return;\n\n  QualType DestTy = LHS->getType();\n  analyzeAndReportShiftToWide(RHS,\
  \ DestTy, C, \"assignment\");\n}\n\nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt\
  \ *RS, CheckerContext &C) const {\n  if (!RS)\n    return;\n  const Expr *RetE =\
  \ RS->getRetValue();\n  if (!RetE)\n    return;\n\n  const StackFrameContext *SFC\
  \ = C.getStackFrame();\n  if (!SFC)\n    return;\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(SFC->getDecl());\n\
  \  if (!FD)\n    return;\n\n  QualType DestTy = FD->getReturnType();\n  analyzeAndReportShiftToWide(RetE,\
  \ DestTy, C, \"return\");\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(Call.getDecl());\n\
  \  if (!FD)\n    return;\n\n  unsigned NumArgs = Call.getNumArgs();\n  unsigned\
  \ NumParams = FD->getNumParams();\n  unsigned N = std::min(NumArgs, NumParams);\n\
  \n  for (unsigned i = 0; i < N; ++i) {\n    const ParmVarDecl *P = FD->getParamDecl(i);\n\
  \    if (!P)\n      continue;\n    QualType DestTy = P->getType();\n    const Expr\
  \ *ArgE = Call.getArgExpr(i);\n    if (!ArgE)\n      continue;\n\n    analyzeAndReportShiftToWide(ArgE,\
  \ DestTy, C, \"argument\");\n  }\n}\n\n} // end anonymous namespace\n\nextern \"\
  C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects 32-bit left shift widened to\
  \ 64-bit after the shift (cast should be before <<)\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/i915/hwmon: Fix static analysis tool reported\
  \ issues\n\nUpdated i915 hwmon with fixes for issues reported by static analysis\
  \ tool.\nFixed integer overflow with upcasting.\n\nv2:\n- Added Fixes tag (Badal).\n\
  - Updated commit message as per review comments (Anshuman).\n\nFixes: 4c2572fe0ae7\
  \ (\"drm/i915/hwmon: Expose power1_max_interval\")\nReviewed-by: Badal Nilawar <badal.nilawar@intel.com>\n\
  Reviewed-by: Anshuman Gupta <anshuman.gupta@intel.com>\nSigned-off-by: Karthik Poosa\
  \ <karthik.poosa@intel.com>\nSigned-off-by: Anshuman Gupta <anshuman.gupta@intel.com>\n\
  Link: https://patchwork.freedesktop.org/patch/msgid/20231204144809.1518704-1-karthik.poosa@intel.com\n\
  (cherry picked from commit ac3420d3d428443a08b923f9118121c170192b62)\nSigned-off-by:\
  \ Jani Nikula <jani.nikula@intel.com>\n\n## Buggy Code\n\n```c\n// Function: hwm_power1_max_interval_store\
  \ in drivers/gpu/drm/i915/i915_hwmon.c\nstatic ssize_t\nhwm_power1_max_interval_store(struct\
  \ device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char\
  \ *buf, size_t count)\n{\n\tstruct hwm_drvdata *ddat = dev_get_drvdata(dev);\n\t\
  struct i915_hwmon *hwmon = ddat->hwmon;\n\tu32 x, y, rxy, x_w = 2; /* 2 bits */\n\
  \tu64 tau4, r, max_win;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf,\
  \ 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Max HW supported tau in '1.x\
  \ * power(2,y)' format, x = 0, y = 0x12\n\t * The hwmon->scl_shift_time default\
  \ of 0xa results in a max tau of 256 seconds\n\t */\n#define PKG_MAX_WIN_DEFAULT\
  \ 0x12ull\n\n\t/*\n\t * val must be < max in hwmon interface units. The steps below\
  \ are\n\t * explained in i915_power1_max_interval_show()\n\t */\n\tr = FIELD_PREP(PKG_MAX_WIN,\
  \ PKG_MAX_WIN_DEFAULT);\n\tx = REG_FIELD_GET(PKG_MAX_WIN_X, r);\n\ty = REG_FIELD_GET(PKG_MAX_WIN_Y,\
  \ r);\n\ttau4 = ((1 << x_w) | x) << y;\n\tmax_win = mul_u64_u32_shr(tau4, SF_TIME,\
  \ hwmon->scl_shift_time + x_w);\n\n\tif (val > max_win)\n\t\treturn -EINVAL;\n\n\
  \t/* val in hw units */\n\tval = DIV_ROUND_CLOSEST_ULL((u64)val << hwmon->scl_shift_time,\
  \ SF_TIME);\n\t/* Convert to 1.x * power(2,y) */\n\tif (!val) {\n\t\t/* Avoid ilog2(0)\
  \ */\n\t\ty = 0;\n\t\tx = 0;\n\t} else {\n\t\ty = ilog2(val);\n\t\t/* x = (val -\
  \ (1 << y)) >> (y - 2); */\n\t\tx = (val - (1ul << y)) << x_w >> y;\n\t}\n\n\trxy\
  \ = REG_FIELD_PREP(PKG_PWR_LIM_1_TIME_X, x) | REG_FIELD_PREP(PKG_PWR_LIM_1_TIME_Y,\
  \ y);\n\n\thwm_locked_with_pm_intel_uncore_rmw(ddat, hwmon->rg.pkg_rapl_limit,\n\
  \t\t\t\t\t    PKG_PWR_LIM_1_TIME, rxy);\n\treturn count;\n}\n```\n\n```c\n// Function:\
  \ hwm_power1_max_interval_show in drivers/gpu/drm/i915/i915_hwmon.c\nstatic ssize_t\n\
  hwm_power1_max_interval_show(struct device *dev, struct device_attribute *attr,\n\
  \t\t\t     char *buf)\n{\n\tstruct hwm_drvdata *ddat = dev_get_drvdata(dev);\n\t\
  struct i915_hwmon *hwmon = ddat->hwmon;\n\tintel_wakeref_t wakeref;\n\tu32 r, x,\
  \ y, x_w = 2; /* 2 bits */\n\tu64 tau4, out;\n\n\twith_intel_runtime_pm(ddat->uncore->rpm,\
  \ wakeref)\n\t\tr = intel_uncore_read(ddat->uncore, hwmon->rg.pkg_rapl_limit);\n\
  \n\tx = REG_FIELD_GET(PKG_PWR_LIM_1_TIME_X, r);\n\ty = REG_FIELD_GET(PKG_PWR_LIM_1_TIME_Y,\
  \ r);\n\t/*\n\t * tau = 1.x * power(2,y), x = bits(23:22), y = bits(21:17)\n\t *\
  \     = (4 | x) << (y - 2)\n\t * where (y - 2) ensures a 1.x fixed point representation\
  \ of 1.x\n\t * However because y can be < 2, we compute\n\t *     tau4 = (4 | x)\
  \ << y\n\t * but add 2 when doing the final right shift to account for units\n\t\
  \ */\n\ttau4 = ((1 << x_w) | x) << y;\n\t/* val in hwmon interface units (millisec)\
  \ */\n\tout = mul_u64_u32_shr(tau4, SF_TIME, hwmon->scl_shift_time + x_w);\n\n\t\
  return sysfs_emit(buf, \"%llu\\n\", out);\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/gpu/drm/i915/i915_hwmon.c b/drivers/gpu/drm/i915/i915_hwmon.c\n\
  index 975da8e7f2a9..8c3f443c8347 100644\n--- a/drivers/gpu/drm/i915/i915_hwmon.c\n\
  +++ b/drivers/gpu/drm/i915/i915_hwmon.c\n@@ -175,7 +175,7 @@ hwm_power1_max_interval_show(struct\
  \ device *dev, struct device_attribute *attr,\n \t *     tau4 = (4 | x) << y\n \t\
  \ * but add 2 when doing the final right shift to account for units\n \t */\n-\t\
  tau4 = ((1 << x_w) | x) << y;\n+\ttau4 = (u64)((1 << x_w) | x) << y;\n \t/* val\
  \ in hwmon interface units (millisec) */\n \tout = mul_u64_u32_shr(tau4, SF_TIME,\
  \ hwmon->scl_shift_time + x_w);\n \n@@ -211,7 +211,7 @@ hwm_power1_max_interval_store(struct\
  \ device *dev,\n \tr = FIELD_PREP(PKG_MAX_WIN, PKG_MAX_WIN_DEFAULT);\n \tx = REG_FIELD_GET(PKG_MAX_WIN_X,\
  \ r);\n \ty = REG_FIELD_GET(PKG_MAX_WIN_Y, r);\n-\ttau4 = ((1 << x_w) | x) << y;\n\
  +\ttau4 = (u64)((1 << x_w) | x) << y;\n \tmax_win = mul_u64_u32_shr(tau4, SF_TIME,\
  \ hwmon->scl_shift_time + x_w);\n \n \tif (val > max_win)\n```\n"
pattern: '## Bug Pattern


  Left-shifting a 32-bit expression and only widening to 64-bit after the shift, causing
  the shift to be performed in 32-bit width and overflow/truncation before assignment:


  u64 tau4 = ((1 << x_w) | x) << y;   // shift happens in 32-bit -> overflow

  // Correct:

  u64 tau4 = (u64)((1 << x_w) | x) << y;


  Root cause: the shift is evaluated in the type of the left operand (u32), so bits
  are lost when y or the result exceeds 32 bits; casting must occur before the shift.'
plan: "Plan to detect 32-bit left-shift widened to 64-bit after the shift (possible\
  \ overflow/truncation)\n\n1) Program state\n- No custom program state is needed.\n\
  \n2) Core idea to detect the bug\n- Find a left-shift expression (Eshl: LHS << RHS)\
  \ whose result type is 32-bit (or narrower), but whose overall destination is 64-bit\
  \ (for example, assigned to a u64 variable, passed to a 64-bit parameter, or returned\
  \ from a 64-bit function).\n- If the shift is performed in 32-bit width and only\
  \ widened afterwards (via implicit cast or assignment), warn.\n- Suppress the warning\
  \ if the shift is already performed in 64-bit (e.g., LHS is explicitly cast to 64-bit\
  \ or is a 64-bit literal like 1ULL) or if RHS is a compile-time constant strictly\
  \ less than the LHS width (i.e., definitely no 32-bit overflow risk). If RHS is\
  \ unknown or could be >= LHS width, warn.\n\n3) Helper utilities\n- Use findSpecificTypeInChildren<T>\
  \ to:\n  - Find the BinaryOperator for the shift (opcode BO_Shl) inside an expression.\n\
  \  - Find any explicit cast (ExplicitCastExpr) within the left operand subtree to\
  \ detect if LHS is already widened to 64-bit.\n- Use EvaluateExprToInt to evaluate\
  \ the RHS (shift count) when it is a constant.\n- Optionally use ExprHasName if\
  \ you want to further refine false positives (not strictly necessary here).\n\n\
  4) Shared helper: analyzeAndReportShiftToWide\n- Input: Expr* E (the expression\
  \ being converted/assigned), QualType DestTy (the destination integer type), CheckerContext\
  \ &C, and a short context string (\u201Cinitialization/assignment/return/argument\u201D\
  ).\n- Steps:\n  1) Ensure DestTy is an integer type and its bit width DestW >= 64\
  \ using C.getASTContext().getIntWidth(DestTy).\n  2) Find a BinaryOperator Shl inside\
  \ E with opcode BO_Shl using findSpecificTypeInChildren<BinaryOperator>(E). If none,\
  \ return.\n  3) Let L = Shl->getLHS(), R = Shl->getRHS(). Compute widths:\n    \
  \ - LHSW = C.getASTContext().getIntWidth(L->getType()) (after implicit promotions).\n\
  \     - ShlW = C.getASTContext().getIntWidth(Shl->getType()).\n     If ShlW >= 64,\
  \ return (shift already performed in 64-bit).\n  4) Check if LHS already explicitly\
  \ widened to 64-bit:\n     - If findSpecificTypeInChildren<ExplicitCastExpr>(L)\
  \ exists and its target type width >= 64, return.\n     - Also, if L->getType()\
  \ width >= 64, return (already wide).\n  5) Analyze RHS (shift count):\n     - Try\
  \ EvaluateExprToInt on R. If success and value < LHSW, suppress the warning to reduce\
  \ false positives.\n     - Otherwise (unknown or value >= LHSW), proceed to warn.\n\
  \  6) Report:\n     - Create a non-fatal error node and emit a PathSensitiveBugReport\
  \ with a short message like:\n       \u201CShift done in 32-bit, widened after;\
  \ cast left operand to 64-bit before <<.\u201D\n     - Highlight the source range\
  \ of the shift expression (Shl->getSourceRange()).\n\n5) Callback selection and\
  \ implementation details\n\n- checkPostStmt(const DeclStmt *DS, CheckerContext &C)\n\
  \  - For each VarDecl VD in DS:\n    - If VD has an initializer:\n      - Let DestTy\
  \ = VD->getType().\n      - Let Init = VD->getInit().\n      - Call analyzeAndReportShiftToWide(Init,\
  \ DestTy, C, \"initialization\").\n  - This catches cases like u64 tau4 = ((1 <<\
  \ x_w) | x) << y;\n\n- checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C)\n  - Only handle assignments: if S is a BinaryOperator and isAssignmentOp():\n\
  \    - BO = cast<BinaryOperator>(S).\n    - DestTy = BO->getLHS()->getType().\n\
  \    - RhsExpr = BO->getRHS()->IgnoreParenImpCasts().\n    - Call analyzeAndReportShiftToWide(RhsExpr,\
  \ DestTy, C, \"assignment\").\n  - This catches tau4 = ((1 << x_w) | x) << y;\n\n\
  - checkPreStmt(const ReturnStmt *RS, CheckerContext &C)\n  - If RS->getRetValue()\
  \ exists:\n    - Get the current FunctionDecl via C.getStackFrame()->getDecl().\n\
  \    - DestTy = FD->getReturnType().\n    - RetE = RS->getRetValue().\n    - Call\
  \ analyzeAndReportShiftToWide(RetE, DestTy, C, \"return\").\n  - This catches return\
  \ ((1 << x_w) | x) << y; in u64-returning functions.\n\n- checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C)\n  - For i in [0, Call.getNumArgs()):\n    - const Expr\
  \ *ArgE = Call.getArgExpr(i).\n    - If Call.getDecl() and i < getNumParams(), get\
  \ ParameterDecl P = getParamDecl(i) and DestTy = P->getType().\n      - If DestTy\
  \ is integer and width >= 64:\n        - Call analyzeAndReportShiftToWide(ArgE,\
  \ DestTy, C, \"argument\").\n  - This catches passing a 32-bit shift to a 64-bit\
  \ parameter.\n\n6) Heuristics to reduce false positives\n- Do not warn if:\n  -\
  \ The shift expression\u2019s resulting type width is already >= 64 (e.g., (u64)lhs\
  \ << y, 1ULL << y).\n  - The RHS is a compile-time constant strictly less than the\
  \ LHS width (value < LHSW).\n- Warn if:\n  - RHS is unknown (cannot evaluate) or\
  \ can be >= LHSW.\n  - Destination width >= 64 and shift is computed in < 64-bit.\n\
  \n7) Bug report\n- Use a single BugType member (e.g., \"Narrow shift widened to\
  \ 64-bit\") initialized once.\n- Short message:\n  - \u201CShift done in 32-bit,\
  \ widened after; cast left operand to 64-bit before <<.\u201D\n- Point to the shift\
  \ expression range.\n\nThis minimal, AST-driven approach robustly flags the exact\
  \ pattern fixed by the patch:\n- Before: u64 tau4 = ((1 << x_w) | x) << y;     \
  \   // shift in 32-bit, then widen\n- After:  u64 tau4 = (u64)((1 << x_w) | x) <<\
  \ y;   // cast to 64-bit before shift"
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"llvm/ADT/StringRef.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states needed\n// REGISTER_MAP_WITH_PROGRAMSTATE(...) not required\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostStmt<DeclStmt>,\n\
  \        check::Bind,\n        check::PreStmt<ReturnStmt>,\n        check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Narrow shift widened to 64-bit\", \"Integer\")) {}\n\n\
  \      void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;\n      void\
  \ checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n     \
  \ void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;\n      void\
  \ checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\
  \      void analyzeAndReportShiftToWide(const Expr *E, QualType DestTy,\n      \
  \                                 CheckerContext &C, StringRef Ctx) const;\n\n \
  \     static const BinaryOperator *findShiftInTree(const Stmt *S);\n      static\
  \ bool hasExplicitCastToWide64(const Expr *E, ASTContext &ACtx);\n};\n\nstatic const\
  \ BinaryOperator *asShift(const Stmt *S) {\n  if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S))\
  \ {\n    if (BO->getOpcode() == BO_Shl)\n      return BO;\n  }\n  return nullptr;\n\
  }\n\nconst BinaryOperator *SAGenTestChecker::findShiftInTree(const Stmt *S) {\n\
  \  if (!S)\n    return nullptr;\n\n  if (const BinaryOperator *B = asShift(S))\n\
  \    return B;\n\n  for (const Stmt *Child : S->children()) {\n    if (const BinaryOperator\
  \ *Res = findShiftInTree(Child))\n      return Res;\n  }\n  return nullptr;\n}\n\
  \nbool SAGenTestChecker::hasExplicitCastToWide64(const Expr *E, ASTContext &ACtx)\
  \ {\n  if (!E)\n    return false;\n\n  // Look for any explicit cast to integer\
  \ type with width >= 64 within E's subtree.\n  if (const auto *ECE = dyn_cast<ExplicitCastExpr>(E->IgnoreParens()))\
  \ {\n    QualType ToTy = ECE->getType();\n    if (ToTy->isIntegerType() && ACtx.getIntWidth(ToTy)\
  \ >= 64)\n      return true;\n  }\n\n  for (const Stmt *Child : E->children()) {\n\
  \    if (!Child)\n      continue;\n    if (const auto *CE = dyn_cast<Expr>(Child))\
  \ {\n      if (hasExplicitCastToWide64(CE, ACtx))\n        return true;\n    } else\
  \ {\n      if (const BinaryOperator *B = asShift(Child)) {\n        (void)B; //\
  \ not needed here\n      }\n      // Continue traversal for safety\n      if (const\
  \ BinaryOperator *B2 = findShiftInTree(Child)) {\n        (void)B2;\n      }\n \
  \   }\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::analyzeAndReportShiftToWide(const\
  \ Expr *E, QualType DestTy,\n                                                  \
  \ CheckerContext &C, StringRef) const {\n  if (!E)\n    return;\n\n  ASTContext\
  \ &ACtx = C.getASTContext();\n\n  if (!DestTy->isIntegerType())\n    return;\n\n\
  \  unsigned DestW = ACtx.getIntWidth(DestTy);\n  if (DestW < 64)\n    return;\n\n\
  \  // Find a left-shift operator within the expression tree.\n  const BinaryOperator\
  \ *Shl = findShiftInTree(E);\n  if (!Shl || Shl->getOpcode() != BO_Shl)\n    return;\n\
  \n  const Expr *L = Shl->getLHS();\n  const Expr *R = Shl->getRHS();\n  if (!L ||\
  \ !R)\n    return;\n\n  QualType ShlTy = Shl->getType();\n  if (!ShlTy->isIntegerType())\n\
  \    return;\n\n  unsigned ShlW = ACtx.getIntWidth(ShlTy);\n  if (ShlW >= 64)\n\
  \    return; // Shift already performed in 64-bit, OK.\n\n  // If LHS type is already\
  \ 64-bit (or wider), no issue.\n  if (L->getType()->isIntegerType()) {\n    unsigned\
  \ LHSW = ACtx.getIntWidth(L->getType());\n    if (LHSW >= 64)\n      return;\n\n\
  \    // If there is an explicit cast to >=64-bit within the LHS subtree, suppress.\n\
  \    if (hasExplicitCastToWide64(L, ACtx))\n      return;\n\n    // Try to evaluate\
  \ RHS; if it's a constant less than LHS width, suppress to reduce FPs.\n    llvm::APSInt\
  \ RHSEval;\n    if (EvaluateExprToInt(RHSEval, R, C)) {\n      // Treat negative\
  \ or very large values conservatively.\n      if (!RHSEval.isSigned() || !RHSEval.isNegative())\
  \ {\n        uint64_t ShiftAmt = RHSEval.getZExtValue();\n        if (ShiftAmt <\
  \ LHSW) {\n          // Heuristic suppression per plan.\n          return;\n   \
  \     }\n      }\n    }\n  } else {\n    // Non-integer LHS shouldn't happen for\
  \ <<, but be safe.\n    return;\n  }\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto Rpt = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Shift done in 32-bit, widened after; cast left operand to 64-bit before\
  \ <<\", N);\n  Rpt->addRange(Shl->getSourceRange());\n  C.emitReport(std::move(Rpt));\n\
  }\n\nvoid SAGenTestChecker::checkPostStmt(const DeclStmt *DS, CheckerContext &C)\
  \ const {\n  if (!DS)\n    return;\n\n  for (const Decl *D : DS->decls()) {\n  \
  \  const auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      continue;\n    if\
  \ (!VD->hasInit())\n      continue;\n\n    QualType DestTy = VD->getType();\n  \
  \  const Expr *Init = VD->getInit();\n    analyzeAndReportShiftToWide(Init, DestTy,\
  \ C, \"initialization\");\n  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal, SVal,\
  \ const Stmt *S, CheckerContext &C) const {\n  // Only handle assignments: LHS =\
  \ RHS;\n  const auto *BO = dyn_cast_or_null<BinaryOperator>(S);\n  if (!BO || !BO->isAssignmentOp())\n\
  \    return;\n\n  const Expr *LHS = BO->getLHS();\n  const Expr *RHS = BO->getRHS();\n\
  \  if (!LHS || !RHS)\n    return;\n\n  QualType DestTy = LHS->getType();\n  analyzeAndReportShiftToWide(RHS,\
  \ DestTy, C, \"assignment\");\n}\n\nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt\
  \ *RS, CheckerContext &C) const {\n  if (!RS)\n    return;\n  const Expr *RetE =\
  \ RS->getRetValue();\n  if (!RetE)\n    return;\n\n  const StackFrameContext *SFC\
  \ = C.getStackFrame();\n  if (!SFC)\n    return;\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(SFC->getDecl());\n\
  \  if (!FD)\n    return;\n\n  QualType DestTy = FD->getReturnType();\n  analyzeAndReportShiftToWide(RetE,\
  \ DestTy, C, \"return\");\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(Call.getDecl());\n\
  \  if (!FD)\n    return;\n\n  unsigned NumArgs = Call.getNumArgs();\n  unsigned\
  \ NumParams = FD->getNumParams();\n  unsigned N = std::min(NumArgs, NumParams);\n\
  \n  for (unsigned i = 0; i < N; ++i) {\n    const ParmVarDecl *P = FD->getParamDecl(i);\n\
  \    if (!P)\n      continue;\n    QualType DestTy = P->getType();\n    const Expr\
  \ *ArgE = Call.getArgExpr(i);\n    if (!ArgE)\n      continue;\n\n    analyzeAndReportShiftToWide(ArgE,\
  \ DestTy, C, \"argument\");\n  }\n}\n\n} // end anonymous namespace\n\nextern \"\
  C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects 32-bit left shift widened to\
  \ 64-bit after the shift (cast should be before <<)\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
