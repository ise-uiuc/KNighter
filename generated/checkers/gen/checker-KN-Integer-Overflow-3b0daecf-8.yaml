_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3b0daecfeac0103aba8b293df07a0cbaf8b43f29
commit_type: Integer-Overflow
index: 8
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n#include \"llvm/ADT/APInt.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\nnamespace {\n/* The checker callbacks are to be decided.\
  \ */\nclass SAGenTestChecker : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unchecked\
  \ size multiplication in allocation\", \"Memory\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\n      bool isSingleSizeAllocCall(const\
  \ CallEvent &Call, CheckerContext &C,\n                                 unsigned\
  \ &SizeIndex, StringRef &NameOut) const;\n\n      bool isSafeCAllocCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n      const BinaryOperator *getMultiplicationInExpr(const\
  \ Expr *E) const;\n\n      const UnaryExprOrTypeTraitExpr *getSizeOfInExpr(const\
  \ Expr *E) const;\n\n      bool tryProveNoOverflow(const BinaryOperator *MulBO,\n\
  \                              const UnaryExprOrTypeTraitExpr *SizeOfE,\n      \
  \                        CheckerContext &C) const;\n\n      void report(const Expr\
  \ *Arg, StringRef CalleeName, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isSafeCAllocCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  // Safe calloc-like helpers\n  if (ExprHasName(Origin,\
  \ \"kcalloc\", C) ||\n      ExprHasName(Origin, \"kvcalloc\", C))\n    return true;\n\
  \  return false;\n}\n\nbool SAGenTestChecker::isSingleSizeAllocCall(const CallEvent\
  \ &Call, CheckerContext &C,\n                                             unsigned\
  \ &SizeIndex, StringRef &NameOut) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Allocation APIs that take a single \"\
  total size\" argument at index 0.\n  static const char *Names[] = {\n      \"kmalloc\"\
  , \"kzalloc\", \"__kmalloc\", \"kmalloc_node\", \"kzalloc_node\",\n      \"vmalloc\"\
  , \"vzalloc\", \"__vmalloc\",\n      \"kvmalloc\", \"kvzalloc\", \"kvmalloc_node\"\
  \n  };\n\n  for (const char *N : Names) {\n    if (ExprHasName(Origin, N, C)) {\n\
  \      NameOut = N;\n      SizeIndex = 0;\n      return true;\n    }\n  }\n  return\
  \ false;\n}\n\nconst BinaryOperator *SAGenTestChecker::getMultiplicationInExpr(const\
  \ Expr *E) const {\n  if (!E)\n    return nullptr;\n  const Expr *EE = E->IgnoreParenImpCasts();\n\
  \  // Look downwards for a BinaryOperator\n  if (const auto *FoundBO = findSpecificTypeInChildren<BinaryOperator>(EE))\n\
  \    if (FoundBO->getOpcode() == BO_Mul)\n      return FoundBO;\n  // If the expression\
  \ itself is a BO *\n  if (const auto *BO = dyn_cast<BinaryOperator>(EE))\n    if\
  \ (BO->getOpcode() == BO_Mul)\n      return BO;\n  return nullptr;\n}\n\nconst UnaryExprOrTypeTraitExpr\
  \ *SAGenTestChecker::getSizeOfInExpr(const Expr *E) const {\n  if (!E)\n    return\
  \ nullptr;\n  const Expr *EE = E->IgnoreParenImpCasts();\n  if (const auto *UETT\
  \ = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(EE)) {\n    if (UETT->getKind()\
  \ == UETT_SizeOf)\n      return UETT;\n  }\n  if (const auto *SelfUETT = dyn_cast<UnaryExprOrTypeTraitExpr>(EE))\
  \ {\n    if (SelfUETT->getKind() == UETT_SizeOf)\n      return SelfUETT;\n  }\n\
  \  return nullptr;\n}\n\nbool SAGenTestChecker::tryProveNoOverflow(const BinaryOperator\
  \ *MulBO,\n                                          const UnaryExprOrTypeTraitExpr\
  \ *SizeOfE,\n                                          CheckerContext &C) const\
  \ {\n  if (!MulBO || !SizeOfE)\n    return false;\n\n  // Evaluate sizeof(...) to\
  \ integer\n  llvm::APSInt ElemSizeAPS;\n  if (!EvaluateExprToInt(ElemSizeAPS, SizeOfE,\
  \ C))\n    return false;\n\n  // Identify the \"count\" side of the multiplication\n\
  \  const Expr *LHS = MulBO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS\
  \ = MulBO->getRHS()->IgnoreParenImpCasts();\n\n  const Expr *CountExpr = nullptr;\n\
  \  // If LHS is sizeof, count is RHS\n  if (isa<UnaryExprOrTypeTraitExpr>(LHS) &&\n\
  \      cast<UnaryExprOrTypeTraitExpr>(LHS)->getKind() == UETT_SizeOf) {\n    CountExpr\
  \ = RHS;\n  } else if (isa<UnaryExprOrTypeTraitExpr>(RHS) &&\n             cast<UnaryExprOrTypeTraitExpr>(RHS)->getKind()\
  \ == UETT_SizeOf) {\n    CountExpr = LHS;\n  } else {\n    // Could be nested expressions;\
  \ fall back to the one that's not sizeof if any\n    // but if neither side is a\
  \ direct sizeof, we can't reliably proceed.\n    return false;\n  }\n\n  // If the\
  \ count expression is a constant, then the whole product should be constant,\n \
  \ // which would have been filtered earlier. So if it's constant, we treat as safe.\n\
  \  llvm::APSInt CountConst;\n  if (EvaluateExprToInt(CountConst, CountExpr, C))\n\
  \    return true;\n\n  // Get symbolic maximum of count\n  ProgramStateRef State\
  \ = C.getState();\n  SVal CountVal = State->getSVal(CountExpr, C.getLocationContext());\n\
  \  SymbolRef CountSym = CountVal.getAsSymbol();\n  if (!CountSym)\n    return false;\n\
  \n  const llvm::APSInt *MaxCount = inferSymbolMaxVal(CountSym, C);\n  if (!MaxCount)\n\
  \    return false;\n\n  ASTContext &ACtx = C.getASTContext();\n  unsigned SizeBits\
  \ = ACtx.getTypeSize(ACtx.getSizeType());\n  unsigned WideBits = SizeBits * 2;\n\
  \n  llvm::APInt ElemSizeNarrow = ElemSizeAPS.getLimitedValue() == 0\n          \
  \                         ? llvm::APInt(SizeBits, 0)\n                         \
  \          : ElemSizeAPS.extOrTrunc(SizeBits).zextOrTrunc(SizeBits);\n  if (ElemSizeNarrow.getBitWidth()\
  \ != SizeBits)\n    ElemSizeNarrow = ElemSizeNarrow.zextOrTrunc(SizeBits);\n\n \
  \ llvm::APInt MaxCountNarrow = MaxCount->extOrTrunc(SizeBits);\n  if (MaxCountNarrow.getBitWidth()\
  \ != SizeBits)\n    MaxCountNarrow = MaxCountNarrow.zextOrTrunc(SizeBits);\n\n \
  \ llvm::APInt ElemSizeWide = ElemSizeNarrow.zext(WideBits);\n  llvm::APInt MaxCountWide\
  \ = MaxCountNarrow.zext(WideBits);\n\n  llvm::APInt ProductWide = MaxCountWide *\
  \ ElemSizeWide;\n\n  llvm::APInt MaxSizeNarrow = llvm::APInt::getAllOnesValue(SizeBits);\n\
  \  llvm::APInt MaxSizeWide = MaxSizeNarrow.zext(WideBits);\n\n  // If product under\
  \ maximum possible count still fits in size_t, it's safe.\n  if (ProductWide.ule(MaxSizeWide))\n\
  \    return true;\n\n  return false;\n}\n\nvoid SAGenTestChecker::report(const Expr\
  \ *Arg, StringRef CalleeName, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  SmallString<128> Msg;\n  Msg += \"Unchecked size multiplication\
  \ in \";\n  Msg += CalleeName;\n  Msg += \"; use kcalloc/kvcalloc (or array_size/struct_size)\
  \ to avoid overflow\";\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  if (Arg)\n    R->addRange(Arg->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  // Do not warn for safe calloc-like helpers.\n  if (isSafeCAllocCall(Call,\
  \ C))\n    return;\n\n  unsigned SizeIdx = 0;\n  StringRef CalleeName;\n  if (!isSingleSizeAllocCall(Call,\
  \ C, SizeIdx, CalleeName))\n    return;\n\n  if (Call.getNumArgs() <= SizeIdx)\n\
  \    return;\n\n  const Expr *SizeArgE = Call.getArgExpr(SizeIdx);\n  if (!SizeArgE)\n\
  \    return;\n\n  // If the whole size expression is a constant, skip (compiler\
  \ already folded it).\n  llvm::APSInt WholeConst;\n  if (EvaluateExprToInt(WholeConst,\
  \ SizeArgE, C))\n    return;\n\n  // We are interested in expressions like sizeof(T)\
  \ * N\n  const BinaryOperator *MulBO = getMultiplicationInExpr(SizeArgE);\n  if\
  \ (!MulBO)\n    return;\n\n  const UnaryExprOrTypeTraitExpr *SizeOfE = getSizeOfInExpr(SizeArgE);\n\
  \  if (!SizeOfE || SizeOfE->getKind() != UETT_SizeOf)\n    return;\n\n  // Try to\
  \ prove safe using a simple max bound check; if provably safe, skip.\n  if (tryProveNoOverflow(MulBO,\
  \ SizeOfE, C))\n    return;\n\n  // Otherwise, report a warning.\n  report(SizeArgE,\
  \ CalleeName, C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unchecked size multiplication in single-size allocation calls;\
  \ suggest kcalloc/kvcalloc\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\namdkfd: use calloc instead of kzalloc to avoid integer\
  \ overflow\n\nThis uses calloc instead of doing the multiplication which might\n\
  overflow.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: kfd_ioctl_get_process_apertures_new in drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\t\t\t\tstruct\
  \ kfd_process *p, void *data)\n{\n\tstruct kfd_ioctl_get_process_apertures_new_args\
  \ *args = data;\n\tstruct kfd_process_device_apertures *pa;\n\tint ret;\n\tint i;\n\
  \n\tdev_dbg(kfd_device, \"get apertures for PASID 0x%x\", p->pasid);\n\n\tif (args->num_of_nodes\
  \ == 0) {\n\t\t/* Return number of nodes, so that user space can alloacate\n\t\t\
  \ * sufficient memory\n\t\t */\n\t\tmutex_lock(&p->mutex);\n\t\targs->num_of_nodes\
  \ = p->n_pdds;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Fill in process-aperture information\
  \ for all available\n\t * nodes, but not more than args->num_of_nodes as that is\n\
  \t * the amount of memory allocated by user\n\t */\n\tpa = kzalloc((sizeof(struct\
  \ kfd_process_device_apertures) *\n\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n\t\
  if (!pa)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&p->mutex);\n\n\tif (!p->n_pdds) {\n\
  \t\targs->num_of_nodes = 0;\n\t\tkfree(pa);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Run\
  \ over all pdd of the process */\n\tfor (i = 0; i < min(p->n_pdds, args->num_of_nodes);\
  \ i++) {\n\t\tstruct kfd_process_device *pdd = p->pdds[i];\n\n\t\tpa[i].gpu_id =\
  \ pdd->dev->id;\n\t\tpa[i].lds_base = pdd->lds_base;\n\t\tpa[i].lds_limit = pdd->lds_limit;\n\
  \t\tpa[i].gpuvm_base = pdd->gpuvm_base;\n\t\tpa[i].gpuvm_limit = pdd->gpuvm_limit;\n\
  \t\tpa[i].scratch_base = pdd->scratch_base;\n\t\tpa[i].scratch_limit = pdd->scratch_limit;\n\
  \n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpu id %u\\n\", pdd->dev->id);\n\t\tdev_dbg(kfd_device,\n\
  \t\t\t\"lds_base %llX\\n\", pdd->lds_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"lds_limit\
  \ %llX\\n\", pdd->lds_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_base %llX\\\
  n\", pdd->gpuvm_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_limit %llX\\n\",\
  \ pdd->gpuvm_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_base %llX\\n\", pdd->scratch_base);\n\
  \t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_limit %llX\\n\", pdd->scratch_limit);\n\
  \t}\n\tmutex_unlock(&p->mutex);\n\n\targs->num_of_nodes = i;\n\tret = copy_to_user(\n\
  \t\t\t(void __user *)args->kfd_process_device_apertures_ptr,\n\t\t\tpa,\n\t\t\t\
  (i * sizeof(struct kfd_process_device_apertures)));\n\tkfree(pa);\n\treturn ret\
  \ ? -EFAULT : 0;\n\nout_unlock:\n\tmutex_unlock(&p->mutex);\n\treturn 0;\n}\n```\n\
  \n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\
  \ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\nindex f9631f4b1a02..55aa74cbc532 100644\n\
  --- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  @@ -779,8 +779,8 @@ static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\
  \ \t * nodes, but not more than args->num_of_nodes as that is\n \t * the amount\
  \ of memory allocated by user\n \t */\n-\tpa = kzalloc((sizeof(struct kfd_process_device_apertures)\
  \ *\n-\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n+\tpa = kcalloc(args->num_of_nodes,\
  \ sizeof(struct kfd_process_device_apertures),\n+\t\t     GFP_KERNEL);\n \tif (!pa)\n\
  \ \t\treturn -ENOMEM;\n \n```\n"
pattern: '## Bug Pattern


  Allocating an array with kmalloc/kzalloc using a manually multiplied size (sizeof(element)
  * count) without overflow checking. This unchecked multiplication can overflow size_t,
  resulting in a too-small allocation and potential out-of-bounds writes. The correct
  pattern is to use kcalloc (or array_size/struct_size helpers), which performs overflow
  checks.'
plan: "Plan\n\n1. Program state\n- No custom program states are needed. This checker\
  \ is a local pattern detector at allocation call sites.\n\n2. Chosen callbacks\n\
  - checkPreCall: Inspect allocation calls and their size arguments before they are\
  \ evaluated, detect the multiplication pattern, and decide whether to report.\n\n\
  3. checkPreCall implementation details\n- Identify target functions:\n  - Warn only\
  \ on allocation functions that take a single \u201Ctotal size\u201D argument:\n\
  \    - kmalloc(size, flags), kzalloc(size, flags), __kmalloc(size, flags), kmalloc_node(size,\
  \ flags, node), kzalloc_node(size, flags, node),\n    - vmalloc(size), vzalloc(size),\
  \ __vmalloc(size, flags, prot),\n    - kvmalloc(size, flags), kvzalloc(size, flags),\
  \ kvmalloc_node(size, flags, node)\n  - Do not warn for kcalloc/kvcalloc (these\
  \ are already safe).\n  - Implementation:\n    - From CallEvent, get callee Identifier\
  \ and compare to a NameSet of the above functions.\n    - Determine the index of\
  \ the \u201Csize\u201D parameter. For all above functions, it is arg index 0.\n\n\
  - Extract and normalize the size expression:\n  - Get Expr *SizeArg = Call.getArgExpr(0)\
  \ and strip parens/implicit casts with IgnoreParenImpCasts.\n\n- Detect multiplication\
  \ pattern:\n  - Use findSpecificTypeInChildren<BinaryOperator>(SizeArg) to locate\
  \ a BinaryOperator.\n  - If none found or opcode != BO_Mul, return (no warning).\n\
  \  - Optional precision: also confirm there is a UnaryExprOrTypeTraitExpr with kind\
  \ UETT_SizeOf somewhere under SizeArg:\n    - Use findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(SizeArg).\
  \ If not found or not UETT_SizeOf, return to reduce false positives.\n  - This focuses\
  \ on the risky pattern sizeof(T) * count (or count * sizeof(T)).\n\n- Filter out\
  \ obvious safe constants:\n  - If EvaluateExprToInt(EvalRes, SizeArg, C) succeeds\
  \ (compile-time constant), return (no warning). This avoids noise for constant expressions\
  \ that the compiler already evaluated safely.\n\n- Try a lightweight overflow feasibility\
  \ check (optional but simple and useful):\n  - Identify the \u201Ccount\u201D operand\
  \ if possible:\n    - From the multiplication BO, let LHS = BO->getLHS()->IgnoreParenImpCasts(),\
  \ RHS likewise.\n    - If one side is UnaryExprOrTypeTraitExpr UETT_SizeOf, pick\
  \ the other side as CountExpr and record ElemSize:\n      - Evaluate Expr to integer\
  \ for sizeof side using EvaluateExprToInt to get ElemSize.\n      - If both sides\
  \ are sizeof/constant (unlikely), return (not a real count pattern).\n  - Check\
  \ if count is safely bounded:\n    - Try EvaluateExprToInt on CountExpr; if it succeeds,\
  \ the product is still non-constant only if CountExpr was constant, but evaluation\
  \ on the whole SizeArg would have succeeded. In practice, if CountExpr is constant\
  \ and ElemSize is constant, SizeArg is constant; we already returned. So skip.\n\
  \    - Else, get SVal CountVal = State->getSVal(CountExpr, C.getLocationContext())\
  \ and see if it is a Symbol (SymbolRef).\n    - If SymbolRef available, call inferSymbolMaxVal(SymbolRef,\
  \ C).\n      - If we get a max value (MaxCount) and we have ElemSize, compute:\n\
  \        - size_t bit width: use C.getASTContext().getTypeSize(C.getASTContext().getSizeType())\
  \ to create a MaxSize APInt of all ones.\n        - Form APInt(ElemSizeBits) for\
  \ ElemSize and zero-extend as needed.\n        - Multiply APInts: MaxCount * ElemSize\
  \ and compare to MaxSize. If product <= MaxSize, return (no warning).\n      - If\
  \ we cannot obtain MaxCount or ElemSize, continue to warning.\n  - If any of the\
  \ above bounding checks fail (unknown or potentially exceeding size_t), proceed\
  \ to report.\n\n- Report:\n  - Create a non-fatal error node with C.generateNonFatalErrorNode().\n\
  \  - Create a PathSensitiveBugReport with a concise message, for example:\n    -\
  \ \"Unchecked size multiplication in kmalloc/kzalloc; use kcalloc to avoid overflow.\"\
  \n  - Attach the source range of SizeArg to the report.\n  - Emit the report via\
  \ C.emitReport(...).\n\n4. Helper utilities to leverage\n- findSpecificTypeInChildren<T>\
  \ to detect BinaryOperator (multiply) and UnaryExprOrTypeTraitExpr (sizeof).\n-\
  \ EvaluateExprToInt to identify constant expressions and element size constants.\n\
  - inferSymbolMaxVal to obtain an upper bound for the count operand.\n- getSourceManager\
  \ and source range APIs (already available in CheckerContext) to highlight SizeArg\
  \ properly.\n\n5. Suppressions and scope\n- Do not warn when:\n  - The callee is\
  \ kcalloc/kvcalloc (already safe).\n  - The \u201Csize\u201D argument is a compile-time\
  \ constant (EvaluateExprToInt succeeds for the whole SizeArg).\n  - A provable upper\
  \ bound on count guarantees no overflow as per the simple max bound check described\
  \ above.\n- Otherwise, warn, since the pattern sizeof(...) * count passed as a \u201C\
  total size\u201D argument is prone to integer overflow and should be replaced by\
  \ kcalloc or array_size/struct_size helpers.\n\n6. No other callbacks needed\n-\
  \ No need for checkPostCall, checkBind, or checkBranchCondition in this checker.\
  \ The entire detection is contained within checkPreCall."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n#include \"llvm/ADT/APInt.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\nnamespace {\n/* The checker callbacks are to be decided.\
  \ */\nclass SAGenTestChecker : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unchecked\
  \ size multiplication in allocation\", \"Memory\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\n      bool isSingleSizeAllocCall(const\
  \ CallEvent &Call, CheckerContext &C,\n                                 unsigned\
  \ &SizeIndex, StringRef &NameOut) const;\n\n      bool isSafeCAllocCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n      const BinaryOperator *getMultiplicationInExpr(const\
  \ Expr *E) const;\n\n      const UnaryExprOrTypeTraitExpr *getSizeOfInExpr(const\
  \ Expr *E) const;\n\n      bool tryProveNoOverflow(const BinaryOperator *MulBO,\n\
  \                              const UnaryExprOrTypeTraitExpr *SizeOfE,\n      \
  \                        CheckerContext &C) const;\n\n      void report(const Expr\
  \ *Arg, StringRef CalleeName, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isSafeCAllocCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  // Safe calloc-like helpers\n  if (ExprHasName(Origin,\
  \ \"kcalloc\", C) ||\n      ExprHasName(Origin, \"kvcalloc\", C))\n    return true;\n\
  \  return false;\n}\n\nbool SAGenTestChecker::isSingleSizeAllocCall(const CallEvent\
  \ &Call, CheckerContext &C,\n                                             unsigned\
  \ &SizeIndex, StringRef &NameOut) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Allocation APIs that take a single \"\
  total size\" argument at index 0.\n  static const char *Names[] = {\n      \"kmalloc\"\
  , \"kzalloc\", \"__kmalloc\", \"kmalloc_node\", \"kzalloc_node\",\n      \"vmalloc\"\
  , \"vzalloc\", \"__vmalloc\",\n      \"kvmalloc\", \"kvzalloc\", \"kvmalloc_node\"\
  \n  };\n\n  for (const char *N : Names) {\n    if (ExprHasName(Origin, N, C)) {\n\
  \      NameOut = N;\n      SizeIndex = 0;\n      return true;\n    }\n  }\n  return\
  \ false;\n}\n\nconst BinaryOperator *SAGenTestChecker::getMultiplicationInExpr(const\
  \ Expr *E) const {\n  if (!E)\n    return nullptr;\n  const Expr *EE = E->IgnoreParenImpCasts();\n\
  \  // Look downwards for a BinaryOperator\n  if (const auto *FoundBO = findSpecificTypeInChildren<BinaryOperator>(EE))\n\
  \    if (FoundBO->getOpcode() == BO_Mul)\n      return FoundBO;\n  // If the expression\
  \ itself is a BO *\n  if (const auto *BO = dyn_cast<BinaryOperator>(EE))\n    if\
  \ (BO->getOpcode() == BO_Mul)\n      return BO;\n  return nullptr;\n}\n\nconst UnaryExprOrTypeTraitExpr\
  \ *SAGenTestChecker::getSizeOfInExpr(const Expr *E) const {\n  if (!E)\n    return\
  \ nullptr;\n  const Expr *EE = E->IgnoreParenImpCasts();\n  if (const auto *UETT\
  \ = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(EE)) {\n    if (UETT->getKind()\
  \ == UETT_SizeOf)\n      return UETT;\n  }\n  if (const auto *SelfUETT = dyn_cast<UnaryExprOrTypeTraitExpr>(EE))\
  \ {\n    if (SelfUETT->getKind() == UETT_SizeOf)\n      return SelfUETT;\n  }\n\
  \  return nullptr;\n}\n\nbool SAGenTestChecker::tryProveNoOverflow(const BinaryOperator\
  \ *MulBO,\n                                          const UnaryExprOrTypeTraitExpr\
  \ *SizeOfE,\n                                          CheckerContext &C) const\
  \ {\n  if (!MulBO || !SizeOfE)\n    return false;\n\n  // Evaluate sizeof(...) to\
  \ integer\n  llvm::APSInt ElemSizeAPS;\n  if (!EvaluateExprToInt(ElemSizeAPS, SizeOfE,\
  \ C))\n    return false;\n\n  // Identify the \"count\" side of the multiplication\n\
  \  const Expr *LHS = MulBO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS\
  \ = MulBO->getRHS()->IgnoreParenImpCasts();\n\n  const Expr *CountExpr = nullptr;\n\
  \  // If LHS is sizeof, count is RHS\n  if (isa<UnaryExprOrTypeTraitExpr>(LHS) &&\n\
  \      cast<UnaryExprOrTypeTraitExpr>(LHS)->getKind() == UETT_SizeOf) {\n    CountExpr\
  \ = RHS;\n  } else if (isa<UnaryExprOrTypeTraitExpr>(RHS) &&\n             cast<UnaryExprOrTypeTraitExpr>(RHS)->getKind()\
  \ == UETT_SizeOf) {\n    CountExpr = LHS;\n  } else {\n    // Could be nested expressions;\
  \ fall back to the one that's not sizeof if any\n    // but if neither side is a\
  \ direct sizeof, we can't reliably proceed.\n    return false;\n  }\n\n  // If the\
  \ count expression is a constant, then the whole product should be constant,\n \
  \ // which would have been filtered earlier. So if it's constant, we treat as safe.\n\
  \  llvm::APSInt CountConst;\n  if (EvaluateExprToInt(CountConst, CountExpr, C))\n\
  \    return true;\n\n  // Get symbolic maximum of count\n  ProgramStateRef State\
  \ = C.getState();\n  SVal CountVal = State->getSVal(CountExpr, C.getLocationContext());\n\
  \  SymbolRef CountSym = CountVal.getAsSymbol();\n  if (!CountSym)\n    return false;\n\
  \n  const llvm::APSInt *MaxCount = inferSymbolMaxVal(CountSym, C);\n  if (!MaxCount)\n\
  \    return false;\n\n  ASTContext &ACtx = C.getASTContext();\n  unsigned SizeBits\
  \ = ACtx.getTypeSize(ACtx.getSizeType());\n  unsigned WideBits = SizeBits * 2;\n\
  \n  llvm::APInt ElemSizeNarrow = ElemSizeAPS.getLimitedValue() == 0\n          \
  \                         ? llvm::APInt(SizeBits, 0)\n                         \
  \          : ElemSizeAPS.extOrTrunc(SizeBits).zextOrTrunc(SizeBits);\n  if (ElemSizeNarrow.getBitWidth()\
  \ != SizeBits)\n    ElemSizeNarrow = ElemSizeNarrow.zextOrTrunc(SizeBits);\n\n \
  \ llvm::APInt MaxCountNarrow = MaxCount->extOrTrunc(SizeBits);\n  if (MaxCountNarrow.getBitWidth()\
  \ != SizeBits)\n    MaxCountNarrow = MaxCountNarrow.zextOrTrunc(SizeBits);\n\n \
  \ llvm::APInt ElemSizeWide = ElemSizeNarrow.zext(WideBits);\n  llvm::APInt MaxCountWide\
  \ = MaxCountNarrow.zext(WideBits);\n\n  llvm::APInt ProductWide = MaxCountWide *\
  \ ElemSizeWide;\n\n  llvm::APInt MaxSizeNarrow = llvm::APInt::getMaxValue(SizeBits);\n\
  \  llvm::APInt MaxSizeWide = MaxSizeNarrow.zext(WideBits);\n\n  // If product under\
  \ maximum possible count still fits in size_t, it's safe.\n  if (ProductWide.ule(MaxSizeWide))\n\
  \    return true;\n\n  return false;\n}\n\nvoid SAGenTestChecker::report(const Expr\
  \ *Arg, StringRef CalleeName, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  SmallString<128> Msg;\n  Msg += \"Unchecked size multiplication\
  \ in \";\n  Msg += CalleeName;\n  Msg += \"; use kcalloc/kvcalloc (or array_size/struct_size)\
  \ to avoid overflow\";\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  if (Arg)\n    R->addRange(Arg->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  // Do not warn for safe calloc-like helpers.\n  if (isSafeCAllocCall(Call,\
  \ C))\n    return;\n\n  unsigned SizeIdx = 0;\n  StringRef CalleeName;\n  if (!isSingleSizeAllocCall(Call,\
  \ C, SizeIdx, CalleeName))\n    return;\n\n  if (Call.getNumArgs() <= SizeIdx)\n\
  \    return;\n\n  const Expr *SizeArgE = Call.getArgExpr(SizeIdx);\n  if (!SizeArgE)\n\
  \    return;\n\n  // If the whole size expression is a constant, skip (compiler\
  \ already folded it).\n  llvm::APSInt WholeConst;\n  if (EvaluateExprToInt(WholeConst,\
  \ SizeArgE, C))\n    return;\n\n  // We are interested in expressions like sizeof(T)\
  \ * N\n  const BinaryOperator *MulBO = getMultiplicationInExpr(SizeArgE);\n  if\
  \ (!MulBO)\n    return;\n\n  const UnaryExprOrTypeTraitExpr *SizeOfE = getSizeOfInExpr(SizeArgE);\n\
  \  if (!SizeOfE || SizeOfE->getKind() != UETT_SizeOf)\n    return;\n\n  // Try to\
  \ prove safe using a simple max bound check; if provably safe, skip.\n  if (tryProveNoOverflow(MulBO,\
  \ SizeOfE, C))\n    return;\n\n  // Otherwise, report a warning.\n  report(SizeArgE,\
  \ CalleeName, C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unchecked size multiplication in single-size allocation calls;\
  \ suggest kcalloc/kvcalloc\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
