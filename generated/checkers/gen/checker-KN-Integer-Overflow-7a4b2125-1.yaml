_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 7a4b21250bf79eef26543d35bd390448646c536b
commit_type: Integer-Overflow
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/PathDiagnostic.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Map the symbol produced by roundup_pow_of_two(...) to its call site.\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupSymMap,\
  \ SymbolRef, const CallExpr*)\n\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<\n    check::Bind,\n    check::BranchCondition\n> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker()\n        : BT(new BugType(this,\n\
  \                         \"Unreliable overflow check with roundup_pow_of_two\"\
  ,\n                         \"API Misuse\")) {}\n\n      void checkBind(SVal Loc,\
  \ SVal Val, const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      static bool isULong32(const CheckerContext &C);\n      static bool isZeroExpr(const\
  \ Expr *E, CheckerContext &C);\n      static const CallExpr* getRoundupCallFromExpr(const\
  \ Expr *E, CheckerContext &C);\n      static const CallExpr* getRoundupCallFromStmt(const\
  \ Stmt *S, CheckerContext &C);\n      void report(const Stmt *Anchor, CheckerContext\
  \ &C) const;\n};\n\nbool SAGenTestChecker::isULong32(const CheckerContext &C) {\n\
  \  const ASTContext &ACtx = C.getASTContext();\n  return ACtx.getTypeSize(ACtx.UnsignedLongTy)\
  \ == 32;\n}\n\nbool SAGenTestChecker::isZeroExpr(const Expr *E, CheckerContext &C)\
  \ {\n  if (!E) return false;\n  llvm::APSInt Res;\n  if (!EvaluateExprToInt(Res,\
  \ E, C))\n    return false;\n  return Res == 0;\n}\n\n// If E is a call to roundup_pow_of_two,\
  \ return it; else nullptr.\nconst CallExpr* SAGenTestChecker::getRoundupCallFromExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return nullptr;\n  E = E->IgnoreParenImpCasts();\n\
  \  if (const auto *CE = dyn_cast<CallExpr>(E)) {\n    if (ExprHasName(CE, \"roundup_pow_of_two\"\
  , C))\n      return CE;\n  }\n  return nullptr;\n}\n\n// Find a CallExpr to roundup_pow_of_two\
  \ within S (search children).\nconst CallExpr* SAGenTestChecker::getRoundupCallFromStmt(const\
  \ Stmt *S, CheckerContext &C) {\n  if (!S) return nullptr;\n  const CallExpr *CE\
  \ = findSpecificTypeInChildren<CallExpr>(S);\n  if (CE && ExprHasName(CE, \"roundup_pow_of_two\"\
  , C))\n    return CE;\n  return nullptr;\n}\n\nvoid SAGenTestChecker::report(const\
  \ Stmt *Anchor, CheckerContext &C) const {\n  if (!BT) return;\n  ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Unreliable overflow check: testing roundup_pow_of_two result\
  \ against 0 on 32-bit.\",\n      N);\n\n  if (Anchor)\n    R->addRange(Anchor->getSourceRange());\n\
  \n  if (Anchor) {\n    PathDiagnosticLocation PLoc =\n        PathDiagnosticLocation::createBegin(Anchor,\
  \ C.getSourceManager(),\n                                            C.getLocationContext());\n\
  \    R->addNote(\"Pre-check the input before calling, e.g., x > 1UL << (BITS_PER_LONG\
  \ - 1).\",\n               PLoc);\n  }\n  C.emitReport(std::move(R));\n}\n\nvoid\
  \ SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  // Record bindings of symbols produced by roundup_pow_of_two(...)\n\
  \  ProgramStateRef State = C.getState();\n\n  // Find a direct call to roundup_pow_of_two\
  \ in the RHS expression context.\n  const CallExpr *CE = getRoundupCallFromStmt(S,\
  \ C);\n  if (!CE)\n    return;\n\n  // We only proceed if the bound value is a symbol\
  \ we can track.\n  SymbolRef Sym = Val.getAsSymbol();\n  if (!Sym)\n    return;\n\
  \n  State = State->set<RoundupSymMap>(Sym, CE);\n  C.addTransition(State);\n}\n\n\
  void SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!isULong32(C))\n    return;\n\n  const Expr *Cond = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!Cond)\n    return;\n  Cond = Cond->IgnoreParenImpCasts();\n\n  ProgramStateRef\
  \ State = C.getState();\n\n  // Case 1: if (!E)\n  if (const auto *UO = dyn_cast<UnaryOperator>(Cond))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *E = UO->getSubExpr()->IgnoreParenImpCasts();\n\
  \n      // Direct: if (!roundup_pow_of_two(...))\n      if (const CallExpr *CE =\
  \ getRoundupCallFromExpr(E, C)) {\n        report(Condition, C);\n        return;\n\
  \      }\n      // Indirect: if (!n) where n was assigned from roundup_pow_of_two(...)\n\
  \      SVal SV = State->getSVal(E, C.getLocationContext());\n      if (SymbolRef\
  \ Sym = SV.getAsSymbol()) {\n        const CallExpr *Orig = State->get<RoundupSymMap>(Sym);\n\
  \        if (Orig) {\n          report(Condition, C);\n          return;\n     \
  \   }\n      }\n    }\n  }\n  // Case 2: if (E == 0) or if (0 == E)\n  else if (const\
  \ auto *BO = dyn_cast<BinaryOperator>(Cond)) {\n    if (BO->getOpcode() == BO_EQ)\
  \ {\n      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n      const Expr\
  \ *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n      // Check RHS == 0\n     \
  \ if (isZeroExpr(RHS, C)) {\n        // Direct: if (roundup_pow_of_two(...) == 0)\n\
  \        if (const CallExpr *CE = getRoundupCallFromExpr(LHS, C)) {\n          report(Condition,\
  \ C);\n          return;\n        }\n        // Indirect: if (n == 0) with n from\
  \ roundup_pow_of_two(...)\n        SVal SV = State->getSVal(LHS, C.getLocationContext());\n\
  \        if (SymbolRef Sym = SV.getAsSymbol()) {\n          const CallExpr *Orig\
  \ = State->get<RoundupSymMap>(Sym);\n          if (Orig) {\n            report(Condition,\
  \ C);\n            return;\n          }\n        }\n      }\n      // Check 0 ==\
  \ LHS\n      if (isZeroExpr(LHS, C)) {\n        if (const CallExpr *CE = getRoundupCallFromExpr(RHS,\
  \ C)) {\n          report(Condition, C);\n          return;\n        }\n       \
  \ SVal SV = State->getSVal(RHS, C.getLocationContext());\n        if (SymbolRef\
  \ Sym = SV.getAsSymbol()) {\n          const CallExpr *Orig = State->get<RoundupSymMap>(Sym);\n\
  \          if (Orig) {\n            report(Condition, C);\n            return;\n\
  \          }\n        }\n      }\n    }\n  }\n\n  // No state change; no need to\
  \ add transition.\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unreliable overflow checks using roundup_pow_of_two result against\
  \ 0 on 32-bit\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbpf: Fix stackmap overflow check on 32-bit arches\n\
  \nThe stackmap code relies on roundup_pow_of_two() to compute the number\nof hash\
  \ buckets, and contains an overflow check by checking if the\nresulting value is\
  \ 0. However, on 32-bit arches, the roundup code itself\ncan overflow by doing a\
  \ 32-bit left-shift of an unsigned long value,\nwhich is undefined behaviour, so\
  \ it is not guaranteed to truncate\nneatly. This was triggered by syzbot on the\
  \ DEVMAP_HASH type, which\ncontains the same check, copied from the hashtab code.\n\
  \nThe commit in the fixes tag actually attempted to fix this, but the fix\ndid not\
  \ account for the UB, so the fix only works on CPUs where an\noverflow does result\
  \ in a neat truncation to zero, which is not\nguaranteed. Checking the value before\
  \ rounding does not have this\nproblem.\n\nFixes: 6183f4d3a0a2 (\"bpf: Check for\
  \ integer overflow when using roundup_pow_of_two()\")\nSigned-off-by: Toke H\xF8\
  iland-J\xF8rgensen <toke@redhat.com>\nReviewed-by: Bui Quang Minh <minhquangbui99@gmail.com>\n\
  Message-ID: <20240307120340.99577-4-toke@redhat.com>\nSigned-off-by: Alexei Starovoitov\
  \ <ast@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: stack_map_alloc in kernel/bpf/stackmap.c\n\
  static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n{\n\tu32 value_size\
  \ = attr->value_size;\n\tstruct bpf_stack_map *smap;\n\tu64 cost, n_buckets;\n\t\
  int err;\n\n\tif (attr->map_flags & ~STACK_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size\
  \ != 4 ||\n\t    value_size < 8 || value_size % 8)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\tBUILD_BUG_ON(sizeof(struct bpf_stack_build_id) % sizeof(u64));\n\tif (attr->map_flags\
  \ & BPF_F_STACK_BUILD_ID) {\n\t\tif (value_size % sizeof(struct bpf_stack_build_id)\
  \ ||\n\t\t    value_size / sizeof(struct bpf_stack_build_id)\n\t\t    > sysctl_perf_event_max_stack)\n\
  \t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n\
  \t\treturn ERR_PTR(-EINVAL);\n\n\t/* hash table size must be power of 2 */\n\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n\tif (!n_buckets)\n\t\treturn ERR_PTR(-E2BIG);\n\
  \n\tcost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);\n\tsmap\
  \ = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\tif (!smap)\n\t\t\
  return ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&smap->map, attr);\n\tsmap->n_buckets\
  \ = n_buckets;\n\n\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\t\
  if (err)\n\t\tgoto free_smap;\n\n\terr = prealloc_elems_and_freelist(smap);\n\t\
  if (err)\n\t\tgoto put_buffers;\n\n\treturn &smap->map;\n\nput_buffers:\n\tput_callchain_buffers();\n\
  free_smap:\n\tbpf_map_area_free(smap);\n\treturn ERR_PTR(err);\n}\n```\n\n## Bug\
  \ Fix Patch\n\n```diff\ndiff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c\n\
  index dff7ba539701..c99f8e5234ac 100644\n--- a/kernel/bpf/stackmap.c\n+++ b/kernel/bpf/stackmap.c\n\
  @@ -91,11 +91,14 @@ static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n\
  \ \t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n \t\treturn ERR_PTR(-EINVAL);\n\
  \ \n-\t/* hash table size must be power of 2 */\n-\tn_buckets = roundup_pow_of_two(attr->max_entries);\n\
  -\tif (!n_buckets)\n+\t/* hash table size must be power of 2; roundup_pow_of_two()\
  \ can overflow\n+\t * into UB on 32-bit arches, so check that first\n+\t */\n+\t\
  if (attr->max_entries > 1UL << 31)\n \t\treturn ERR_PTR(-E2BIG);\n \n+\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n+\n \tcost = n_buckets * sizeof(struct\
  \ stack_map_bucket *) + sizeof(*smap);\n \tsmap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\
  \ \tif (!smap)\n```\n"
pattern: "## Bug Pattern\n\nCalling roundup_pow_of_two(x) on an unchecked 32-bit unsigned\
  \ long input and then detecting overflow by testing the result (e.g., if (!n)).\n\
  \nPattern:\n- n = roundup_pow_of_two(x);\n- if (!n) /* treat as overflow */\n\n\
  Why it\u2019s buggy:\n- On 32-bit arches, if x > 1UL << 31, roundup_pow_of_two()\
  \ may internally perform a left shift by 32, which is undefined behavior. This can\
  \ produce non-zero garbage, so the post-call check (!n) can fail to catch the overflow.\n\
  \nCorrect approach:\n- Pre-validate the input before calling roundup_pow_of_two():\n\
  \  if (x > 1UL << (BITS_PER_LONG - 1))\n      return -E2BIG;\n  n = roundup_pow_of_two(x);"
plan: "1) Program state\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(RoundupSymMap, SymbolRef,\
  \ const CallExpr*)\n  - Purpose: remember which symbolic values come from roundup_pow_of_two(),\
  \ so later zero checks on these symbols can be flagged.\n  - Key = the SymbolRef\
  \ representing the value produced by the call (the same symbol that will be used\
  \ when the code does if (!n) or if (n == 0)).\n  - Value = the CallExpr* of the\
  \ roundup_pow_of_two() call (for pinpointing and messages).\n\n\n2) Callbacks and\
  \ how to implement them\n\nA) checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const\n\n- Goal: Record when a variable is assigned from roundup_pow_of_two(...)\
  \ so that future zero checks on that variable can be detected.\n- Steps:\n  1. Extract\
  \ the RHS CallExpr within S, if any:\n     - Use findSpecificTypeInChildren<CallExpr>(S).\n\
  \     - If not found, return.\n  2. Validate the callee:\n     - Get callee identifier\
  \ and ensure it\u2019s \"roundup_pow_of_two\".\n     - If not, return.\n  3. Get\
  \ the symbol for the assigned value:\n     - From Val.getAsSymbol() (ignore if null).\n\
  \  4. Record in program state:\n     - State = State.set<RoundupSymMap>(Sym, CE).\n\
  \     - C.addTransition(State).\n  5. Optional alias support (simple, low-cost):\n\
  \     - If RHS is a symbol that already exists in RoundupSymMap and this bind does\
  \ not involve a call (e.g., m = n;), we do nothing special: the analyzer typically\
  \ propagates the same symbol to the LHS when no transformation is applied. This\
  \ keeps the solution simple.\n\n\nB) checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const\n\n- Goal: Identify the unreliable overflow check pattern:\n\
  \  - if (!roundup_pow_of_two(x))\n  - if (!n) where n is previously bound to roundup_pow_of_two(x)\n\
  \  - if (roundup_pow_of_two(x) == 0)\n  - if (n == 0) where n is previously bound\
  \ to roundup_pow_of_two(x)\n- Limit to 32-bit unsigned long targets to reduce noise.\n\
  - Steps:\n  1. Early filter for 32-bit unsigned long target:\n     - const ASTContext\
  \ &ACtx = C.getASTContext();\n     - If ACtx.getTypeSize(ACtx.UnsignedLongTy) !=\
  \ 32, return (no warning).\n  2. Normalize the condition:\n     - const Expr *Cond\
  \ = dyn_cast_or_null<Expr>(Condition); if (!Cond) return;\n     - Cond = Cond->IgnoreParenImpCasts();\n\
  \  3. Case 1: Unary logical not (!E)\n     - If Cond is a UnaryOperator with opcode\
  \ UO_LNot:\n       - Let E = UO->getSubExpr()->IgnoreParenImpCasts().\n       -\
  \ Detect direct call:\n         - If E is a CallExpr with callee name \"roundup_pow_of_two\"\
  , report (see reporting below).\n       - Else detect symbol derived from a previous\
  \ call:\n         - SVal SV = C.getSVal(E);\n         - If SymbolRef Sym = SV.getAsSymbol():\n\
  \           - Look up Sym in RoundupSymMap; if present, report.\n  4. Case 2: Equality\
  \ comparison (E == 0) or (0 == E)\n     - If Cond is a BinaryOperator with opcode\
  \ BO_EQ:\n       - Let LHS = BO->getLHS()->IgnoreParenImpCasts();\n       - Let\
  \ RHS = BO->getRHS()->IgnoreParenImpCasts();\n       - Use EvaluateExprToInt to\
  \ check whether either side is the integer constant zero.\n         - If RHS evaluates\
  \ to 0:\n           - Inspect LHS as in step 3 (direct CallExpr or symbol mapped\
  \ in RoundupSymMap).\n         - Else if LHS evaluates to 0:\n           - Inspect\
  \ RHS similarly.\n     - Note: We intentionally do not warn for \"!= 0\" or for\
  \ \"if (n)\" without logical not, since the buggy pattern is specifically using\
  \ zero-result as an overflow indicator.\n  5. Reporting:\n     - Use C.generateNonFatalErrorNode()\
  \ to create the error node; if null, return.\n     - Create a PathSensitiveBugReport\
  \ with a short message:\n       - \"Unreliable overflow check: testing roundup_pow_of_two\
  \ result against 0 on 32-bit.\"\n     - Add a note suggesting the correct approach:\n\
  \       - \"Pre-check the input before calling, e.g., x > 1UL << (BITS_PER_LONG\
  \ - 1).\"\n     - Anchor the report at the current BranchCondition statement.\n\
  \     - C.emitReport(std::move(R)).\n\n\n3) Optional helper logic (inline within\
  \ callbacks)\n\n- bool isRoundupPow2Call(const Expr *E, const CallExpr *&OutCE):\n\
  \  - If E is a CallExpr, get callee Identifier and match \"roundup_pow_of_two\"\
  .\n  - Return true and set OutCE; else false.\n\n- bool isZeroExpr(const Expr *E,\
  \ CheckerContext &C):\n  - Use EvaluateExprToInt to check if it\u2019s a constant\
  \ integer value equal to 0.\n\n- The provided utility findSpecificTypeInChildren<CallExpr>(S)\
  \ helps in checkBind to find the RHS call expression under the assignment or initialization\
  \ statement.\n\n- For robustness, always IgnoreParenImpCasts() when examining expressions.\n\
  \n\n4) Rationale and scope control\n\n- This checker intentionally warns only when:\n\
  \  - The build target\u2019s unsigned long is 32-bit (ASTContext UnsignedLongTy\
  \ size equals 32), which is the environment where roundup_pow_of_two may hit UB\
  \ via a left shift of 32.\n  - A zero check is used as the overflow detection on\
  \ the result of roundup_pow_of_two.\n- We do not attempt to prove the existence\
  \ of an adequate pre-check; keeping the checker simple avoids complex control-flow\
  \ reasoning and reduces false positives in practice.\n- Both uses directly in conditions\
  \ and via variables assigned from the function call are covered.\n\n\n5) Selected\
  \ APIs used\n\n- Program state:\n  - REGISTER_MAP_WITH_PROGRAMSTATE(RoundupSymMap,\
  \ SymbolRef, const CallExpr*)\n- Callbacks:\n  - checkBind to record symbols produced\
  \ by roundup_pow_of_two()\n  - checkBranchCondition to detect if (!n) or (n == 0)\
  \ patterns (including direct call in condition)\n- Utilities:\n  - findSpecificTypeInChildren<CallExpr>\n\
  \  - EvaluateExprToInt\n  - Lexer/getSourceManager not needed\n- Bug report:\n \
  \ - generateNonFatalErrorNode, PathSensitiveBugReport, C.emitReport\n\n\n6) Report\
  \ message\n\n- Title: \"Unreliable overflow check: testing roundup_pow_of_two result\
  \ against 0 on 32-bit.\"\n- One-line note: \"Pre-check the input before calling,\
  \ e.g., x > 1UL << (BITS_PER_LONG - 1).\""
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// Map the symbol produced by roundup_pow_of_two(...)\
  \ to its call site.\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupSymMap, SymbolRef, const\
  \ CallExpr*)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<\n    check::Bind,\n\
  \    check::BranchCondition\n> {\n   mutable std::unique_ptr<BugType> BT;\n\n  \
  \ public:\n      SAGenTestChecker()\n        : BT(new BugType(this,\n          \
  \               \"Unreliable overflow check with roundup_pow_of_two\",\n       \
  \                  \"API Misuse\")) {}\n\n      void checkBind(SVal Loc, SVal Val,\
  \ const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      static bool isULong32(const CheckerContext &C);\n      static bool isZeroExpr(const\
  \ Expr *E, CheckerContext &C);\n      static const CallExpr* getRoundupCallFromExpr(const\
  \ Expr *E, CheckerContext &C);\n      static const CallExpr* getRoundupCallFromStmt(const\
  \ Stmt *S, CheckerContext &C);\n      void report(const Stmt *Anchor, CheckerContext\
  \ &C) const;\n};\n\nbool SAGenTestChecker::isULong32(const CheckerContext &C) {\n\
  \  const ASTContext &ACtx = C.getASTContext();\n  return ACtx.getTypeSize(ACtx.UnsignedLongTy)\
  \ == 32;\n}\n\nbool SAGenTestChecker::isZeroExpr(const Expr *E, CheckerContext &C)\
  \ {\n  if (!E) return false;\n  llvm::APSInt Res;\n  if (!EvaluateExprToInt(Res,\
  \ E, C))\n    return false;\n  return Res == 0;\n}\n\n// If E is a call to roundup_pow_of_two,\
  \ return it; else nullptr.\nconst CallExpr* SAGenTestChecker::getRoundupCallFromExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return nullptr;\n  E = E->IgnoreParenImpCasts();\n\
  \  if (const auto *CE = dyn_cast<CallExpr>(E)) {\n    if (ExprHasName(CE, \"roundup_pow_of_two\"\
  , C))\n      return CE;\n  }\n  return nullptr;\n}\n\n// Find a CallExpr to roundup_pow_of_two\
  \ within S (search children).\nconst CallExpr* SAGenTestChecker::getRoundupCallFromStmt(const\
  \ Stmt *S, CheckerContext &C) {\n  if (!S) return nullptr;\n  const CallExpr *CE\
  \ = findSpecificTypeInChildren<CallExpr>(S);\n  if (CE && ExprHasName(CE, \"roundup_pow_of_two\"\
  , C))\n    return CE;\n  return nullptr;\n}\n\nvoid SAGenTestChecker::report(const\
  \ Stmt *Anchor, CheckerContext &C) const {\n  if (!BT) return;\n  ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Unreliable overflow check: testing roundup_pow_of_two result\
  \ against 0 on 32-bit.\",\n      N);\n\n  if (Anchor)\n    R->addRange(Anchor->getSourceRange());\n\
  \n  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc,\
  \ SVal Val, const Stmt *S, CheckerContext &C) const {\n  // Record bindings of symbols\
  \ produced by roundup_pow_of_two(...)\n  ProgramStateRef State = C.getState();\n\
  \n  // Find a direct call to roundup_pow_of_two in the RHS expression context.\n\
  \  const CallExpr *CE = getRoundupCallFromStmt(S, C);\n  if (!CE)\n    return;\n\
  \n  // We only proceed if the bound value is a symbol we can track.\n  SymbolRef\
  \ Sym = Val.getAsSymbol();\n  if (!Sym)\n    return;\n\n  State = State->set<RoundupSymMap>(Sym,\
  \ CE);\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!isULong32(C))\n    return;\n\
  \n  const Expr *Cond = dyn_cast_or_null<Expr>(Condition);\n  if (!Cond)\n    return;\n\
  \  Cond = Cond->IgnoreParenImpCasts();\n\n  ProgramStateRef State = C.getState();\n\
  \n  // Case 1: if (!E)\n  if (const auto *UO = dyn_cast<UnaryOperator>(Cond)) {\n\
  \    if (UO->getOpcode() == UO_LNot) {\n      const Expr *E = UO->getSubExpr()->IgnoreParenImpCasts();\n\
  \n      // Direct: if (!roundup_pow_of_two(...))\n      if (const CallExpr *CE =\
  \ getRoundupCallFromExpr(E, C)) {\n        report(Condition, C);\n        return;\n\
  \      }\n      // Indirect: if (!n) where n was assigned from roundup_pow_of_two(...)\n\
  \      SVal SV = State->getSVal(E, C.getLocationContext());\n      if (SymbolRef\
  \ Sym = SV.getAsSymbol()) {\n        if (State->get<RoundupSymMap>(Sym)) {\n   \
  \       report(Condition, C);\n          return;\n        }\n      }\n    }\n  }\n\
  \  // Case 2: if (E == 0) or if (0 == E)\n  else if (const auto *BO = dyn_cast<BinaryOperator>(Cond))\
  \ {\n    if (BO->getOpcode() == BO_EQ) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n      // Check\
  \ RHS == 0\n      if (isZeroExpr(RHS, C)) {\n        // Direct: if (roundup_pow_of_two(...)\
  \ == 0)\n        if (const CallExpr *CE = getRoundupCallFromExpr(LHS, C)) {\n  \
  \        report(Condition, C);\n          return;\n        }\n        // Indirect:\
  \ if (n == 0) with n from roundup_pow_of_two(...)\n        SVal SV = State->getSVal(LHS,\
  \ C.getLocationContext());\n        if (SymbolRef Sym = SV.getAsSymbol()) {\n  \
  \        if (State->get<RoundupSymMap>(Sym)) {\n            report(Condition, C);\n\
  \            return;\n          }\n        }\n      }\n      // Check 0 == LHS\n\
  \      if (isZeroExpr(LHS, C)) {\n        if (const CallExpr *CE = getRoundupCallFromExpr(RHS,\
  \ C)) {\n          report(Condition, C);\n          return;\n        }\n       \
  \ SVal SV = State->getSVal(RHS, C.getLocationContext());\n        if (SymbolRef\
  \ Sym = SV.getAsSymbol()) {\n          if (State->get<RoundupSymMap>(Sym)) {\n \
  \           report(Condition, C);\n            return;\n          }\n        }\n\
  \      }\n    }\n  }\n\n  // No state change; no need to add transition.\n}\n\n\
  } // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unreliable overflow checks using roundup_pow_of_two result against\
  \ 0 on 32-bit\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
