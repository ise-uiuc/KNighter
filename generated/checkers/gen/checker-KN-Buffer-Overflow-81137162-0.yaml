_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 81137162bfaa7278785b24c1fd2e9e74f082e8e4
commit_type: Buffer-Overflow
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include\
  \ \"clang/Basic/LangOptions.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states are necessary.\n\nnamespace\
  \ {\n\nclass SAGenTestChecker : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Unbounded\
  \ string copy into fixed-size buffer\",\n                       \"Security\")) {}\n\
  \n  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\nprivate:\n\
  \  // Return true if the call is to strcpy.\n  static bool isStrcpy(const CallEvent\
  \ &Call, CheckerContext &C);\n\n  // Try to obtain a constant array size from an\
  \ expression that refers to an\n  // array variable or a struct/union field of array\
  \ type.\n  static bool getConstArraySize(llvm::APInt &Size, const Expr *E, CheckerContext\
  \ &C);\n\n  // Emit a diagnostic with a short message.\n  void report(const CallEvent\
  \ &Call, CheckerContext &C, StringRef Msg) const;\n};\n\nbool SAGenTestChecker::isStrcpy(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n  return ExprHasName(OriginExpr, \"strcpy\"\
  , C);\n}\n\nbool SAGenTestChecker::getConstArraySize(llvm::APInt &Size, const Expr\
  \ *E, CheckerContext &C) {\n  if (!E)\n    return false;\n\n  const Expr *EI = E->IgnoreParenImpCasts();\n\
  \n  // Try helper for DeclRefExpr to an array.\n  if (getArraySizeFromExpr(Size,\
  \ EI))\n    return true;\n\n  // Try struct/union member that is an array field.\n\
  \  if (const auto *ME = dyn_cast<MemberExpr>(EI)) {\n    const ValueDecl *VD = ME->getMemberDecl();\n\
  \    const auto *FD = dyn_cast_or_null<FieldDecl>(VD);\n    if (!FD)\n      return\
  \ false;\n\n    QualType QT = FD->getType();\n    if (const auto *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr()))\
  \ {\n      Size = CAT->getSize();\n      return true;\n    }\n  }\n\n  return false;\n\
  }\n\nvoid SAGenTestChecker::report(const CallEvent &Call, CheckerContext &C, StringRef\
  \ Msg) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n\
  \  if (const Stmt *S = Call.getOriginExpr())\n    R->addRange(S->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  if (!isStrcpy(Call, C))\n    return;\n\n\
  \  // Extract destination and source expressions.\n  if (Call.getNumArgs() < 2)\n\
  \    return;\n\n  const Expr *DstArg = Call.getArgExpr(0);\n  const Expr *SrcArg\
  \ = Call.getArgExpr(1);\n  if (!DstArg || !SrcArg)\n    return;\n\n  // Determine\
  \ destination fixed-size.\n  llvm::APInt DstSize(64, 0);\n  if (!getConstArraySize(DstSize,\
  \ DstArg, C)) {\n    // If destination size is unknown, skip to reduce false positives.\n\
  \    return;\n  }\n\n  // Try to evaluate source length if it's a string literal.\n\
  \  llvm::APInt SrcLen(64, 0);\n  if (getStringSize(SrcLen, SrcArg)) {\n    // getStringSize\
  \ returns number of chars, not including the null terminator.\n    // strcpy needs\
  \ at least SrcLen + 1 bytes in destination.\n    if (SrcLen.uge(DstSize)) {\n  \
  \    // Definite overflow.\n      SmallString<128> Msg;\n      Msg += \"strcpy overflows\
  \ fixed-size buffer (dest size \";\n      Msg += DstSize.toString(10, false);\n\
  \      Msg += \", source length \";\n      Msg += SrcLen.toString(10, false);\n\
  \      Msg += \")\";\n      report(Call, C, Msg);\n    }\n    // Else, provably\
  \ safe for this literal.\n    return;\n  }\n\n  // Source is not a literal. Try\
  \ to detect a bounded source array.\n  llvm::APInt SrcBound(64, 0);\n  if (getConstArraySize(SrcBound,\
  \ SrcArg, C)) {\n    // We cannot guarantee actual string length; report as possible\
  \ overflow.\n    // Highlight especially when src bound >= dst size.\n    if (SrcBound.uge(DstSize))\
  \ {\n      SmallString<128> Msg;\n      Msg += \"Possible overflow: strcpy into\
  \ fixed-size buffer (dest size \";\n      Msg += DstSize.toString(10, false);\n\
  \      Msg += \", source bound \";\n      Msg += SrcBound.toString(10, false);\n\
  \      Msg += \"); use strscpy(dest, src, sizeof(dest))\";\n      report(Call, C,\
  \ Msg);\n      return;\n    } else {\n      // Still potentially unsafe as strcpy\
  \ is unbounded.\n      report(Call, C, \"Possible overflow: strcpy into fixed-size\
  \ buffer; use strscpy(dest, src, sizeof(dest))\");\n      return;\n    }\n  }\n\n\
  \  // Unknown source size: warn about possible overflow due to unbounded copy.\n\
  \  report(Call, C, \"Possible overflow: strcpy into fixed-size buffer; use strscpy(dest,\
  \ src, sizeof(dest))\");\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects strcpy into fixed-size buffers\
  \ which may overflow; suggests strscpy with sizeof(dest)\",\n      \"\");\n}\n\n\
  extern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: hci_core: Fix possible buffer overflow\n\
  \nstruct hci_dev_info has a fixed size name[8] field so in the event that\nhdev->name\
  \ is bigger than that strcpy would attempt to write past its\nsize, so this fixes\
  \ this problem by switching to use strscpy.\n\nFixes: dcda165706b9 (\"Bluetooth:\
  \ hci_core: Fix build warnings\")\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\n\
  \n## Buggy Code\n\n```c\n// Function: hci_get_dev_info in net/bluetooth/hci_core.c\n\
  int hci_get_dev_info(void __user *arg)\n{\n\tstruct hci_dev *hdev;\n\tstruct hci_dev_info\
  \ di;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (copy_from_user(&di, arg,\
  \ sizeof(di)))\n\t\treturn -EFAULT;\n\n\thdev = hci_dev_get(di.dev_id);\n\tif (!hdev)\n\
  \t\treturn -ENODEV;\n\n\t/* When the auto-off is configured it means the transport\n\
  \t * is running, but in that case still indicate that the\n\t * device is actually\
  \ down.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_AUTO_OFF))\n\t\tflags = hdev->flags\
  \ & ~BIT(HCI_UP);\n\telse\n\t\tflags = hdev->flags;\n\n\tstrcpy(di.name, hdev->name);\n\
  \tdi.bdaddr   = hdev->bdaddr;\n\tdi.type     = (hdev->bus & 0x0f) | ((hdev->dev_type\
  \ & 0x03) << 4);\n\tdi.flags    = flags;\n\tdi.pkt_type = hdev->pkt_type;\n\tif\
  \ (lmp_bredr_capable(hdev)) {\n\t\tdi.acl_mtu  = hdev->acl_mtu;\n\t\tdi.acl_pkts\
  \ = hdev->acl_pkts;\n\t\tdi.sco_mtu  = hdev->sco_mtu;\n\t\tdi.sco_pkts = hdev->sco_pkts;\n\
  \t} else {\n\t\tdi.acl_mtu  = hdev->le_mtu;\n\t\tdi.acl_pkts = hdev->le_pkts;\n\t\
  \tdi.sco_mtu  = 0;\n\t\tdi.sco_pkts = 0;\n\t}\n\tdi.link_policy = hdev->link_policy;\n\
  \tdi.link_mode   = hdev->link_mode;\n\n\tmemcpy(&di.stat, &hdev->stat, sizeof(di.stat));\n\
  \tmemcpy(&di.features, &hdev->features, sizeof(di.features));\n\n\tif (copy_to_user(arg,\
  \ &di, sizeof(di)))\n\t\terr = -EFAULT;\n\n\thci_dev_put(hdev);\n\n\treturn err;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c\n\
  index 6ca4c0df9f9c..230d2bbb933b 100644\n--- a/net/bluetooth/hci_core.c\n+++ b/net/bluetooth/hci_core.c\n\
  @@ -908,7 +908,7 @@ int hci_get_dev_info(void __user *arg)\n \telse\n \t\tflags\
  \ = hdev->flags;\n \n-\tstrcpy(di.name, hdev->name);\n+\tstrscpy(di.name, hdev->name,\
  \ sizeof(di.name));\n \tdi.bdaddr   = hdev->bdaddr;\n \tdi.type     = (hdev->bus\
  \ & 0x0f) | ((hdev->dev_type & 0x03) << 4);\n \tdi.flags    = flags;\n```\n"
pattern: '## Bug Pattern


  Copying a potentially longer string into a fixed-size buffer using an unbounded
  API (e.g., strcpy) without checking or limiting the length of the source, causing
  possible buffer overflow. Concretely:


  char dest[8];

  strcpy(dest, src);  // src may exceed sizeof(dest)


  The correct pattern is to use a bounded copy with the destination size (e.g., strscpy(dest,
  src, sizeof(dest))).'
plan: "1) Program state\n- No custom program state is necessary. This checker is a\
  \ local, call-site based check.\n\n2) Callback functions and implementation steps\n\
  \nA. checkPreCall (core callback; single-pass detection)\n- Goal: Catch unbounded\
  \ string copies where destination is a fixed-size buffer and source may be longer\
  \ than destination.\n\n- Identify target calls:\n  - Retrieve callee identifier\
  \ with Call.getCalleeIdentifier().\n  - If the name equals \"strcpy\", proceed.\
  \ Otherwise, return.\n\n- Extract arguments:\n  - const Expr *DstArg = Call.getArgExpr(0);\n\
  \  - const Expr *SrcArg = Call.getArgExpr(1);\n\n- Determine destination fixed-size:\n\
  \  - Implement a small helper getConstArraySize(Size, DstArg, C):\n    - E = DstArg->IgnoreParenImpCasts().\n\
  \    - First try the provided getArraySizeFromExpr(Size, E).\n    - If that fails\
  \ and E is a MemberExpr:\n      - Get the FieldDecl via cast<FieldDecl>(ME->getMemberDecl()).\n\
  \      - Get the field\u2019s QualType QT = FD->getType().\n      - If QT is ConstantArrayType,\
  \ extract its Size = CAT->getSize().\n      - Return true on success.\n    - If\
  \ the destination is an array (DeclRefExpr to array variable or MemberExpr of array\
  \ field), this returns true and Size is the compile-time bound.\n    - If this helper\
  \ fails (i.e., destination isn't a known fixed-size array), return from the checker\
  \ without warning (to avoid FPs on unknown pointers).\n\n- Evaluate source length\
  \ and decide report kind:\n  - Attempt to get a precise size if it\u2019s a string\
  \ literal:\n    - Use provided getStringSize(SrcLen, SrcArg) on SrcArg->IgnoreImpCasts().\n\
  \    - If true:\n      - Remember: getStringSize returns number of characters without\
  \ the null terminator.\n      - If SrcLen.uge(DstSize): definite overflow (since\
  \ we need at least SrcLen+1 bytes in dest).\n        - Report: \"strcpy into fixed-size\
  \ buffer overflows; use strscpy(dest, src, sizeof(dest)).\"\n      - Else: do nothing\
  \ (provably safe).\n  - If not string literal:\n    - Optionally try to detect an\
  \ obvious bounded source array:\n      - If getConstArraySize(SrcBound, SrcArg,\
  \ C) succeeds:\n        - We still cannot prove the runtime string is shorter than\
  \ DstSize; be conservative.\n        - If SrcBound.uge(DstSize): report as \"possible\
  \ overflow\".\n        - Else: still \"possible overflow\" because strcpy is unbounded\
  \ (keeps FPs low-level but aligned with \"possible overflow\").\n    - Otherwise\
  \ (unknown source size):\n      - Report as \"Possible buffer overflow: strcpy into\
  \ fixed-size buffer; use strscpy(dest, src, sizeof(dest)).\"\n\n- Bug report emission:\n\
  \  - Create a BugType (category: \"Security\", name: \"Unbounded string copy into\
  \ fixed-size buffer\").\n  - Use generateNonFatalErrorNode to create a node.\n \
  \ - Create a PathSensitiveBugReport with a short, clear message:\n    - Definite:\
  \ \"strcpy overflows fixed-size buffer (dest size N, source literal length M).\"\
  \n    - Possible: \"Possible overflow: strcpy into fixed-size buffer; use strscpy(dest,\
  \ src, sizeof(dest)).\"\n  - Add a source range on the call expression or specifically\
  \ the destination argument for clarity.\n  - Emit the report.\n\nB. (Optional) Helper\
  \ utilities to include in the checker\n- getConstArraySize(llvm::APInt &Size, const\
  \ Expr *E, CheckerContext &C):\n  - As described above, try:\n    - getArraySizeFromExpr(Size,\
  \ E->IgnoreParenImpCasts()).\n    - If MemberExpr: extract FieldDecl->getType();\
  \ if ConstantArrayType, set Size.\n  - Return bool success.\n- isStrcpy(const CallEvent\
  \ &Call):\n  - Return true if Call.getCalleeIdentifier() and name == \"strcpy\"\
  .\n\nNotes and rationale\n- This checker purposely restricts diagnostics to cases\
  \ where the destination is a compile-time fixed-size array, which aligns with the\
  \ target bug pattern (e.g., struct field like name[8]).\n- It prefers precision\
  \ when the source is a string literal; otherwise it reports as \"possible overflow,\"\
  \ which matches the kernel change\u2019s reasoning and recommended fix to strscpy\
  \ with sizeof(dest).\n- No alias tracking or state is used to keep implementation\
  \ simple and robust.\n- We avoid warning when destination size is unknown (e.g.,\
  \ arbitrary char*), reducing false positives."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include\
  \ \"clang/Basic/LangOptions.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states are necessary.\n\nnamespace\
  \ {\n\nclass SAGenTestChecker : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Unbounded\
  \ string copy into fixed-size buffer\",\n                       \"Security\")) {}\n\
  \n  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\nprivate:\n\
  \  // Return true if the call is to strcpy.\n  static bool isStrcpy(const CallEvent\
  \ &Call, CheckerContext &C);\n\n  // Try to obtain a constant array size from an\
  \ expression that refers to an\n  // array variable or a struct/union field of array\
  \ type.\n  static bool getConstArraySize(llvm::APInt &Size, const Expr *E, CheckerContext\
  \ &C);\n\n  // Emit a diagnostic with a short message.\n  void report(const CallEvent\
  \ &Call, CheckerContext &C, StringRef Msg) const;\n};\n\nbool SAGenTestChecker::isStrcpy(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n  return ExprHasName(OriginExpr, \"strcpy\"\
  , C);\n}\n\nbool SAGenTestChecker::getConstArraySize(llvm::APInt &Size, const Expr\
  \ *E, CheckerContext &C) {\n  if (!E)\n    return false;\n\n  const Expr *EI = E->IgnoreParenImpCasts();\n\
  \n  // Try helper for DeclRefExpr to an array.\n  if (getArraySizeFromExpr(Size,\
  \ EI))\n    return true;\n\n  // Try struct/union member that is an array field.\n\
  \  if (const auto *ME = dyn_cast<MemberExpr>(EI)) {\n    const ValueDecl *VD = ME->getMemberDecl();\n\
  \    const auto *FD = dyn_cast_or_null<FieldDecl>(VD);\n    if (!FD)\n      return\
  \ false;\n\n    QualType QT = FD->getType();\n    if (const auto *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr()))\
  \ {\n      Size = CAT->getSize();\n      return true;\n    }\n  }\n\n  return false;\n\
  }\n\nvoid SAGenTestChecker::report(const CallEvent &Call, CheckerContext &C, StringRef\
  \ Msg) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n\
  \  if (const Stmt *S = Call.getOriginExpr())\n    R->addRange(S->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  if (!isStrcpy(Call, C))\n    return;\n\n\
  \  // Extract destination and source expressions.\n  if (Call.getNumArgs() < 2)\n\
  \    return;\n\n  const Expr *DstArg = Call.getArgExpr(0);\n  const Expr *SrcArg\
  \ = Call.getArgExpr(1);\n  if (!DstArg || !SrcArg)\n    return;\n\n  // Determine\
  \ destination fixed-size.\n  llvm::APInt DstSize(64, 0);\n  if (!getConstArraySize(DstSize,\
  \ DstArg, C)) {\n    // If destination size is unknown, skip to reduce false positives.\n\
  \    return;\n  }\n\n  // Try to evaluate source length if it's a string literal.\n\
  \  llvm::APInt SrcLen(64, 0);\n  if (getStringSize(SrcLen, SrcArg)) {\n    // getStringSize\
  \ returns number of chars, not including the null terminator.\n    // strcpy needs\
  \ at least SrcLen + 1 bytes in destination.\n    if (SrcLen.uge(DstSize)) {\n  \
  \    // Definite overflow.\n      SmallString<128> Msg;\n      {\n        llvm::raw_svector_ostream\
  \ OS(Msg);\n        OS << \"strcpy overflows fixed-size buffer (dest size \" <<\
  \ DstSize\n           << \", source length \" << SrcLen << \")\";\n      }\n   \
  \   report(Call, C, Msg);\n    }\n    // Else, provably safe for this literal.\n\
  \    return;\n  }\n\n  // Source is not a literal. Try to detect a bounded source\
  \ array.\n  llvm::APInt SrcBound(64, 0);\n  if (getConstArraySize(SrcBound, SrcArg,\
  \ C)) {\n    // We cannot guarantee actual string length; report as possible overflow.\n\
  \    // Highlight especially when src bound >= dst size.\n    if (SrcBound.uge(DstSize))\
  \ {\n      SmallString<128> Msg;\n      {\n        llvm::raw_svector_ostream OS(Msg);\n\
  \        OS << \"Possible overflow: strcpy into fixed-size buffer (dest size \"\n\
  \           << DstSize << \", source bound \" << SrcBound\n           << \"); use\
  \ strscpy(dest, src, sizeof(dest))\";\n      }\n      report(Call, C, Msg);\n  \
  \    return;\n    } else {\n      // Still potentially unsafe as strcpy is unbounded.\n\
  \      report(Call, C, \"Possible overflow: strcpy into fixed-size buffer; use strscpy(dest,\
  \ src, sizeof(dest))\");\n      return;\n    }\n  }\n\n  // Unknown source size:\
  \ warn about possible overflow due to unbounded copy.\n  report(Call, C, \"Possible\
  \ overflow: strcpy into fixed-size buffer; use strscpy(dest, src, sizeof(dest))\"\
  );\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects strcpy into fixed-size buffers which may overflow; suggests strscpy\
  \ with sizeof(dest)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
