_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 2e29b9971ac54dec88baa58856a230ec2f2a2dff
commit_type: Null-Pointer-Dereference
index: 8
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// No custom program states\n\nnamespace\
  \ {\nclass SAGenTestChecker : public Checker<check::BranchCondition> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"Wrong NULL check after allocation\", \"Logic error\")) {}\n\n\
  \      void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \n   private:\n      // Helpers\n      static const Expr *extractCheckedExprForNull(const\
  \ Expr *CondE, CheckerContext &C);\n      static bool isNullLiteral(const Expr *E,\
  \ ASTContext &ACtx);\n      static std::string getExprText(const Expr *E, CheckerContext\
  \ &C);\n      static bool isAllocLikeCall(const CallExpr *CE, CheckerContext &C);\n\
  };\n\nstatic std::string getCalleeNameFromCall(const CallExpr *CE) {\n  if (!CE)\
  \ return {};\n  if (const FunctionDecl *FD = CE->getDirectCallee()) {\n    if (const\
  \ IdentifierInfo *II = FD->getIdentifier())\n      return II->getName().str();\n\
  \  }\n  return {};\n}\n\nstd::string SAGenTestChecker::getExprText(const Expr *E,\
  \ CheckerContext &C) {\n  if (!E) return \"\";\n  const SourceManager &SM = C.getSourceManager();\n\
  \  const LangOptions &LangOpts = C.getLangOpts();\n  CharSourceRange Range = CharSourceRange::getTokenRange(E->getSourceRange());\n\
  \  return Lexer::getSourceText(Range, SM, LangOpts).str();\n}\n\nbool SAGenTestChecker::isNullLiteral(const\
  \ Expr *E, ASTContext &ACtx) {\n  if (!E) return false;\n  E = E->IgnoreParenImpCasts();\n\
  \  if (E->isNullPointerConstant(ACtx, Expr::NPC_ValueDependentIsNull))\n    return\
  \ true;\n  if (const auto *IL = dyn_cast<IntegerLiteral>(E))\n    return IL->getValue()\
  \ == 0;\n  return false;\n}\n\nconst Expr *SAGenTestChecker::extractCheckedExprForNull(const\
  \ Expr *CondE, CheckerContext &C) {\n  if (!CondE) return nullptr;\n  const ASTContext\
  \ &ACtx = C.getASTContext();\n  CondE = CondE->IgnoreParenImpCasts();\n\n  // Pattern:\
  \ if (!X)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if (UO->getOpcode()\
  \ == UO_LNot) {\n      const Expr *Sub = UO->getSubExpr();\n      return Sub ? Sub->IgnoreParenImpCasts()\
  \ : nullptr;\n    }\n  }\n\n  // Pattern: if (X == NULL) or if (NULL == X)\n  if\
  \ (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    if (BO->getOpcode()\
  \ == BO_EQ) {\n      const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n    \
  \  const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n      bool LNull = isNullLiteral(L,\
  \ ACtx);\n      bool RNull = isNullLiteral(R, ACtx);\n      if (LNull && !RNull)\n\
  \        return R;\n      if (RNull && !LNull)\n        return L;\n    }\n  }\n\n\
  \  return nullptr;\n}\n\nbool SAGenTestChecker::isAllocLikeCall(const CallExpr *CE,\
  \ CheckerContext &C) {\n  if (!CE) return false;\n\n  // First try direct callee\
  \ name\n  std::string Name = getCalleeNameFromCall(CE);\n  auto IsAllocName = [&](StringRef\
  \ N) {\n    return Name == N.str() || ExprHasName(CE->getCallee(), N, C);\n  };\n\
  \n  // Common kernel allocators\n  if (IsAllocName(\"kzalloc\")) return true;\n\
  \  if (IsAllocName(\"kvzalloc\")) return true;\n  if (IsAllocName(\"kmalloc\"))\
  \ return true;\n  if (IsAllocName(\"kcalloc\")) return true;\n  if (IsAllocName(\"\
  krealloc\")) return true;\n  if (IsAllocName(\"kmemdup\")) return true;\n\n  //\
  \ devm_ variants too\n  if (IsAllocName(\"devm_kzalloc\")) return true;\n  if (IsAllocName(\"\
  devm_kmalloc\")) return true;\n  if (IsAllocName(\"devm_kcalloc\")) return true;\n\
  \n  return false;\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const {\n  if (!Condition) return;\n\n  const Expr *CondE =\
  \ dyn_cast<Expr>(Condition);\n  if (!CondE) return;\n\n  // 1) Recognize a NULL-check-like\
  \ condition and extract the checked expression.\n  const Expr *CheckedE = extractCheckedExprForNull(CondE,\
  \ C);\n  if (!CheckedE) return;\n\n  // 2) Find the enclosing IfStmt for this condition\
  \ and its containing CompoundStmt.\n  const IfStmt *InnerIf = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!InnerIf) return;\n\n  const CompoundStmt *Comp = findSpecificTypeInParents<CompoundStmt>(InnerIf,\
  \ C);\n  if (!Comp) return;\n\n  // 3) Locate the statement immediately preceding\
  \ the IfStmt within the same block.\n  const Stmt *PrevS = nullptr;\n  unsigned\
  \ Index = 0;\n  bool Found = false;\n  for (const Stmt *S : Comp->body()) {\n  \
  \  if (S == InnerIf) {\n      Found = true;\n      break;\n    }\n    ++Index;\n\
  \  }\n  if (!Found || Index == 0)\n    return;\n\n  // Retrieve (Index - 1)-th statement\
  \ as previous.\n  unsigned Cur = 0;\n  for (const Stmt *S : Comp->body()) {\n  \
  \  if (Cur + 1 == Index) {\n      PrevS = S;\n      break;\n    }\n    ++Cur;\n\
  \  }\n  if (!PrevS) return;\n\n  // 4) Ensure the previous statement is an assignment\
  \ from an allocation call.\n  const BinaryOperator *Assign = dyn_cast<BinaryOperator>(PrevS);\n\
  \  if (!Assign) {\n    // Try to find an assignment inside the statement.\n    Assign\
  \ = findSpecificTypeInChildren<BinaryOperator>(PrevS);\n  }\n  if (!Assign || Assign->getOpcode()\
  \ != BO_Assign)\n    return;\n\n  const Expr *LHS = Assign->getLHS();\n  const Expr\
  \ *RHS = Assign->getRHS();\n  if (!LHS || !RHS) return;\n\n  LHS = LHS->IgnoreParenImpCasts();\n\
  \  RHS = RHS->IgnoreParenImpCasts();\n\n  const CallExpr *AllocCall = dyn_cast<CallExpr>(RHS);\n\
  \  if (!AllocCall) return;\n  if (!isAllocLikeCall(AllocCall, C)) return;\n\n  //\
  \ 5) Compare the checked expression with the allocated lvalue using regions.\n \
  \ const MemRegion *AllocReg = getMemRegionFromExpr(LHS, C);\n  if (!AllocReg) return;\n\
  \  const MemRegion *CheckedReg = getMemRegionFromExpr(CheckedE, C);\n  if (!CheckedReg)\
  \ return;\n\n  // Always obtain base regions as suggested (we still keep originals\
  \ for field info).\n  const MemRegion *AllocBase = AllocReg->getBaseRegion();\n\
  \  const MemRegion *CheckedBase = CheckedReg->getBaseRegion();\n  (void)AllocBase;\n\
  \  (void)CheckedBase;\n\n  // We focus on field-to-field mismatches (siblings within\
  \ the same parent).\n  const auto *AllocField = dyn_cast<FieldRegion>(AllocReg);\n\
  \  const auto *CheckedField = dyn_cast<FieldRegion>(CheckedReg);\n  if (!AllocField\
  \ || !CheckedField)\n    return;\n\n  if (AllocField == CheckedField)\n    return;\
  \ // Correct field checked.\n\n  const MemRegion *AllocParent = AllocField->getSuperRegion();\n\
  \  const MemRegion *CheckedParent = CheckedField->getSuperRegion();\n  if (!AllocParent\
  \ || !CheckedParent)\n    return;\n\n  if (AllocParent != CheckedParent)\n    return;\
  \ // Not siblings in the same object; skip to avoid false positives.\n\n  // Optional\
  \ confidence boost: if 'then' branch immediately returns, it's likely an error path.\n\
  \  // This is optional and non-blocking; we don't require it to report.\n  (void)InnerIf;\n\
  \n  // 6) Report the bug.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N) return;\n\n  std::string CheckedTxt = getExprText(CheckedE, C);\n  std::string\
  \ AllocTxt = getExprText(LHS, C);\n  if (CheckedTxt.empty()) CheckedTxt = \"the\
  \ other field\";\n  if (AllocTxt.empty()) AllocTxt = \"allocated field\";\n\n  std::string\
  \ Msg = \"Wrong NULL check: checking '\" + CheckedTxt +\n                    \"\
  ' after allocating '\" + AllocTxt + \"'\";\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  R->addRange(CondE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects checking the wrong pointer for NULL after an allocation (e.g.,\
  \ checking a different field than the one just allocated)\",\n      \"\");\n}\n\n\
  extern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\narm64/sme: Fix NULL check after kzalloc\n\nFix following\
  \ coccicheck error:\n./arch/arm64/kernel/process.c:322:2-23: alloc with no test,\
  \ possible model on line 326\n\nHere should be dst->thread.sve_state.\n\nFixes:\
  \ 8bd7f91c03d8 (\"arm64/sme: Implement traps and syscall handling for SME\")\nSigned-off-by:\
  \ Wan Jiabing <wanjiabing@vivo.com>\nReviwed-by: Mark Brown <broonie@kernel.org>\n\
  Link: https://lore.kernel.org/r/20220426113054.630983-1-wanjiabing@vivo.com\nSigned-off-by:\
  \ Catalin Marinas <catalin.marinas@arm.com>\n\n## Buggy Code\n\n```c\n// Function:\
  \ arch_dup_task_struct in arch/arm64/kernel/process.c\nint arch_dup_task_struct(struct\
  \ task_struct *dst, struct task_struct *src)\n{\n\tif (current->mm)\n\t\tfpsimd_preserve_current_state();\n\
  \t*dst = *src;\n\n\t/* We rely on the above assignment to initialize dst's thread_flags:\
  \ */\n\tBUILD_BUG_ON(!IS_ENABLED(CONFIG_THREAD_INFO_IN_TASK));\n\n\t/*\n\t * Detach\
  \ src's sve_state (if any) from dst so that it does not\n\t * get erroneously used\
  \ or freed prematurely.  dst's copies\n\t * will be allocated on demand later on\
  \ if dst uses SVE.\n\t * For consistency, also clear TIF_SVE here: this could be\
  \ done\n\t * later in copy_process(), but to avoid tripping up future\n\t * maintainers\
  \ it is best not to leave TIF flags and buffers in\n\t * an inconsistent state,\
  \ even temporarily.\n\t */\n\tdst->thread.sve_state = NULL;\n\tclear_tsk_thread_flag(dst,\
  \ TIF_SVE);\n\n\t/*\n\t * In the unlikely event that we create a new thread with\
  \ ZA\n\t * enabled we should retain the ZA state so duplicate it here.\n\t * This\
  \ may be shortly freed if we exec() or if CLONE_SETTLS\n\t * but it's simpler to\
  \ do it here. To avoid confusing the rest\n\t * of the code ensure that we have\
  \ a sve_state allocated\n\t * whenever za_state is allocated.\n\t */\n\tif (thread_za_enabled(&src->thread))\
  \ {\n\t\tdst->thread.sve_state = kzalloc(sve_state_size(src),\n\t\t\t\t\t\tGFP_KERNEL);\n\
  \t\tif (!dst->thread.za_state)\n\t\t\treturn -ENOMEM;\n\t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n\t\t\t\t\t       za_state_size(src),\n\t\t\t\t\
  \t       GFP_KERNEL);\n\t\tif (!dst->thread.za_state) {\n\t\t\tkfree(dst->thread.sve_state);\n\
  \t\t\tdst->thread.sve_state = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\
  \tdst->thread.za_state = NULL;\n\t\tclear_tsk_thread_flag(dst, TIF_SME);\n\t}\n\n\
  \t/* clear any pending asynchronous tag fault raised by the parent */\n\tclear_tsk_thread_flag(dst,\
  \ TIF_MTE_ASYNC_FAULT);\n\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c\nindex 99c293513817..9734c9fb1a32\
  \ 100644\n--- a/arch/arm64/kernel/process.c\n+++ b/arch/arm64/kernel/process.c\n\
  @@ -321,7 +321,7 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct\
  \ *src)\n \tif (thread_za_enabled(&src->thread)) {\n \t\tdst->thread.sve_state =\
  \ kzalloc(sve_state_size(src),\n \t\t\t\t\t\tGFP_KERNEL);\n-\t\tif (!dst->thread.za_state)\n\
  +\t\tif (!dst->thread.sve_state)\n \t\t\treturn -ENOMEM;\n \t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n \t\t\t\t\t       za_state_size(src),\n```\n"
pattern: "## Bug Pattern\n\nChecking the wrong pointer for NULL after an allocation.\
  \ Specifically, after allocating one field (e.g., dst->thread.sve_state = kzalloc(...)),\
  \ the code erroneously tests a different field (dst->thread.za_state) for NULL,\
  \ causing allocation failures to be missed and leaving related state inconsistent.\n\
  \nExample:\np->sve_state = kzalloc(...);\nif (!p->za_state)   // BUG: should be\
  \ !p->sve_state\n    return -ENOMEM;"
plan: "Plan\n\n1. No custom program state\n- Do not register any custom traits or\
  \ maps. This checker can be implemented with a single AST-pattern check around branch\
  \ conditions, using the provided helpers to walk parents/children and to obtain\
  \ MemRegions.\n\n2. Callback selection\n- Use only checkBranchCondition. This is\
  \ sufficient to:\n  - Detect \u201CNULL-check-like\u201D conditions.\n  - Find the\
  \ immediately preceding statement within the same block.\n  - Verify that statement\
  \ is an allocation assignment.\n  - Compare the checked pointer with the allocated\
  \ lvalue and diagnose a mismatch.\n\n3. Detailed implementation of checkBranchCondition\n\
  3.1. Recognize a NULL-check condition\n- Given the Condition stmt pointer, obtain\
  \ the expression CE = dyn_cast<Expr>(Condition)->IgnoreParenImpCasts().\n- Extract\
  \ the pointer expression CheckedE from CE if CE matches any of:\n  - UnaryOperator\
  \ UO_LNot: !X \u2192 CheckedE = X->IgnoreParenImpCasts().\n  - BinaryOperator BO_EQ:\
  \ (X == 0 or X == NULL) or (0 == X or NULL == X) \u2192 CheckedE = the non-constant/null\
  \ side.\n  - Optionally, handle BO_NE with the same logic only if you want to catch\
  \ non-null checks; to reduce false positives, prefer only the \u201Cnull-check-like\u201D\
  \ patterns above.\n- If none match, return.\n\n3.2. Locate the IfStmt and the immediately\
  \ previous statement in the same compound block\n- Use findSpecificTypeInParents<IfStmt>(Condition,\
  \ C) to get the enclosing IfStmt SIf; if not found, return.\n- Use findSpecificTypeInParents<CompoundStmt>(SIf,\
  \ C) to get the enclosing block Comp; if not found, return.\n- Iterate Comp->body()\
  \ to find SIf\u2019s index i; if i == 0, return (no previous statement).\n- Let\
  \ PrevS = Comp->body()[i-1]; This is the statement just before the if-statement\
  \ in the same block.\n\n3.3. Ensure the previous statement is an assignment from\
  \ an allocation call\n- Check if PrevS is a BinaryOperator with opcode BO_Assign.\
  \ If not, return.\n- Let Assign = cast<BinaryOperator>(PrevS).\n  - LHS = Assign->getLHS()->IgnoreParenImpCasts().\n\
  \  - RHS = Assign->getRHS()->IgnoreParenImpCasts().\n- Verify RHS is a CallExpr\
  \ CECall; if not, return.\n- Extract callee name (IdentifierInfo) and check if it\
  \ is an allocation-like function:\n  - Allowed names (expandable): kzalloc, kvzalloc,\
  \ kmalloc, kcalloc, kmemdup, krealloc, devm_kzalloc, devm_kmalloc, devm_kcalloc.\n\
  \  - If not in the set, return.\n\n3.4. Compare the pointer being NULL-checked with\
  \ the just-allocated lvalue\n- Obtain MemRegions for both expressions:\n  - RegionAlloc\
  \ = getMemRegionFromExpr(LHS, C).\n  - RegionChecked = getMemRegionFromExpr(CheckedE,\
  \ C).\n- If either is null, return (insufficient info).\n- We want to catch the\
  \ specific bug \u201Callocated one field, checked a different field (sibling)\u201D\
  . Do:\n  - Try casting both to FieldRegion:\n    - const auto *FRAlloc = dyn_cast<FieldRegion>(RegionAlloc).\n\
  \    - const auto *FRChecked = dyn_cast<FieldRegion>(RegionChecked).\n  - If both\
  \ are FieldRegion:\n    - If FRAlloc == FRChecked: correct check \u2192 return.\n\
  \    - Else, compare their immediate super regions:\n      - If FRAlloc->getSuperRegion()\
  \ == FRChecked->getSuperRegion():\n        - They are siblings in the same parent\
  \ object (e.g. dst->thread.sve_state vs dst->thread.za_state).\n        - This matches\
  \ the target bug pattern \u2192 report.\n      - Else return (not the specific pattern).\n\
  \  - Otherwise (non-field regions), you may skip reporting to minimize false positives.\
  \ If desired, as an optional relaxed heuristic:\n    - Compare textual bases using\
  \ ExprHasName to see if both share the same base prefix before the last \u201C->\u201D\
  \ or \u201C.\u201D and differ in the last field name; only then report. By default,\
  \ keep it disabled for precision.\n\n3.5. Optional additional filter to reduce false\
  \ positives\n- Check the then-branch of SIf (SIf->getThen()):\n  - If it contains\
  \ an immediate ReturnStmt (possibly in a CompoundStmt of one statement) returning\
  \ some error (commonly -ENOMEM), this strengthens the confidence.\n  - You can attempt\
  \ to detect a negative integer literal with EvaluateExprToInt, but error codes are\
  \ often macros; skip strict checks if it\u2019s too restrictive.\n\n3.6. Reporting\n\
  - If the mismatch is confirmed:\n  - Create a bug type: \u201CWrong NULL check after\
  \ allocation\u201D.\n  - Generate a non-fatal error node and emit a PathSensitiveBugReport.\n\
  \  - Message: \u201CWrong NULL check: checking \u2018X\u2019 after allocating \u2018\
  Y\u2019.\u201D\n    - Extract X and Y from source text via Lexer using the Exprs\
  \ CheckedE and LHS (or use ExprHasName to confirm names).\n  - Attach the primary\
  \ location to the condition expression CheckedE\u2019s source range.\n\n4. Utility\
  \ functions to use\n- findSpecificTypeInParents to get the surrounding IfStmt and\
  \ its CompoundStmt.\n- getMemRegionFromExpr to compare regions and super-regions.\n\
  - ExprHasName optionally for relaxed textual checks.\n- EvaluateExprToInt optionally\
  \ for return value inspection (not required).\n\n5. Notes and scope\n- This checker\
  \ focuses on the immediate-pattern: \u201Calloc into field\u201D immediately followed\
  \ by \u201Cif (!different_field) \u2026\u201D.\n- Keeping it block-local and requiring\
  \ adjacency avoids heavy program-state logic and significantly reduces false positives.\n\
  - Extend the alloc function name set as needed for broader kernel coverage."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// No custom program states\n\nnamespace\
  \ {\nclass SAGenTestChecker : public Checker<check::BranchCondition> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"Wrong NULL check after allocation\", \"Logic error\")) {}\n\n\
  \      void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \n   private:\n      // Helpers\n      static const Expr *extractCheckedExprForNull(const\
  \ Expr *CondE, CheckerContext &C);\n      static bool isNullLiteral(const Expr *E,\
  \ ASTContext &ACtx);\n      static std::string getExprText(const Expr *E, CheckerContext\
  \ &C);\n      static bool isAllocLikeCall(const CallExpr *CE, CheckerContext &C);\n\
  };\n\nstatic std::string getCalleeNameFromCall(const CallExpr *CE) {\n  if (!CE)\
  \ return {};\n  if (const FunctionDecl *FD = CE->getDirectCallee()) {\n    if (const\
  \ IdentifierInfo *II = FD->getIdentifier())\n      return II->getName().str();\n\
  \  }\n  return {};\n}\n\nstd::string SAGenTestChecker::getExprText(const Expr *E,\
  \ CheckerContext &C) {\n  if (!E) return \"\";\n  const SourceManager &SM = C.getSourceManager();\n\
  \  const LangOptions &LangOpts = C.getLangOpts();\n  CharSourceRange Range = CharSourceRange::getTokenRange(E->getSourceRange());\n\
  \  return Lexer::getSourceText(Range, SM, LangOpts).str();\n}\n\nbool SAGenTestChecker::isNullLiteral(const\
  \ Expr *E, ASTContext &ACtx) {\n  if (!E) return false;\n  E = E->IgnoreParenImpCasts();\n\
  \  if (E->isNullPointerConstant(ACtx, Expr::NPC_ValueDependentIsNull))\n    return\
  \ true;\n  if (const auto *IL = dyn_cast<IntegerLiteral>(E))\n    return IL->getValue()\
  \ == 0;\n  return false;\n}\n\nconst Expr *SAGenTestChecker::extractCheckedExprForNull(const\
  \ Expr *CondE, CheckerContext &C) {\n  if (!CondE) return nullptr;\n  ASTContext\
  \ &ACtx = C.getASTContext();\n  CondE = CondE->IgnoreParenImpCasts();\n\n  // Pattern:\
  \ if (!X)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if (UO->getOpcode()\
  \ == UO_LNot) {\n      const Expr *Sub = UO->getSubExpr();\n      return Sub ? Sub->IgnoreParenImpCasts()\
  \ : nullptr;\n    }\n  }\n\n  // Pattern: if (X == NULL) or if (NULL == X)\n  if\
  \ (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    if (BO->getOpcode()\
  \ == BO_EQ) {\n      const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n    \
  \  const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n      bool LNull = isNullLiteral(L,\
  \ ACtx);\n      bool RNull = isNullLiteral(R, ACtx);\n      if (LNull && !RNull)\n\
  \        return R;\n      if (RNull && !LNull)\n        return L;\n    }\n  }\n\n\
  \  return nullptr;\n}\n\nbool SAGenTestChecker::isAllocLikeCall(const CallExpr *CE,\
  \ CheckerContext &C) {\n  if (!CE) return false;\n\n  // First try direct callee\
  \ name\n  std::string Name = getCalleeNameFromCall(CE);\n  auto IsAllocName = [&](StringRef\
  \ N) {\n    return Name == N.str() || ExprHasName(CE->getCallee(), N, C);\n  };\n\
  \n  // Common kernel allocators\n  if (IsAllocName(\"kzalloc\")) return true;\n\
  \  if (IsAllocName(\"kvzalloc\")) return true;\n  if (IsAllocName(\"kmalloc\"))\
  \ return true;\n  if (IsAllocName(\"kcalloc\")) return true;\n  if (IsAllocName(\"\
  krealloc\")) return true;\n  if (IsAllocName(\"kmemdup\")) return true;\n\n  //\
  \ devm_ variants too\n  if (IsAllocName(\"devm_kzalloc\")) return true;\n  if (IsAllocName(\"\
  devm_kmalloc\")) return true;\n  if (IsAllocName(\"devm_kcalloc\")) return true;\n\
  \n  return false;\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const {\n  if (!Condition) return;\n\n  const Expr *CondE =\
  \ dyn_cast<Expr>(Condition);\n  if (!CondE) return;\n\n  // 1) Recognize a NULL-check-like\
  \ condition and extract the checked expression.\n  const Expr *CheckedE = extractCheckedExprForNull(CondE,\
  \ C);\n  if (!CheckedE) return;\n\n  // 2) Find the enclosing IfStmt for this condition\
  \ and its containing CompoundStmt.\n  const IfStmt *InnerIf = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!InnerIf) return;\n\n  const CompoundStmt *Comp = findSpecificTypeInParents<CompoundStmt>(InnerIf,\
  \ C);\n  if (!Comp) return;\n\n  // 3) Locate the statement immediately preceding\
  \ the IfStmt within the same block.\n  const Stmt *PrevS = nullptr;\n  unsigned\
  \ Index = 0;\n  bool Found = false;\n  for (const Stmt *S : Comp->body()) {\n  \
  \  if (S == InnerIf) {\n      Found = true;\n      break;\n    }\n    ++Index;\n\
  \  }\n  if (!Found || Index == 0)\n    return;\n\n  // Retrieve (Index - 1)-th statement\
  \ as previous.\n  unsigned Cur = 0;\n  for (const Stmt *S : Comp->body()) {\n  \
  \  if (Cur + 1 == Index) {\n      PrevS = S;\n      break;\n    }\n    ++Cur;\n\
  \  }\n  if (!PrevS) return;\n\n  // 4) Ensure the previous statement is an assignment\
  \ from an allocation call.\n  const BinaryOperator *Assign = dyn_cast<BinaryOperator>(PrevS);\n\
  \  if (!Assign) {\n    // Try to find an assignment inside the statement.\n    Assign\
  \ = findSpecificTypeInChildren<BinaryOperator>(PrevS);\n  }\n  if (!Assign || Assign->getOpcode()\
  \ != BO_Assign)\n    return;\n\n  const Expr *LHS = Assign->getLHS();\n  const Expr\
  \ *RHS = Assign->getRHS();\n  if (!LHS || !RHS) return;\n\n  LHS = LHS->IgnoreParenImpCasts();\n\
  \  RHS = RHS->IgnoreParenImpCasts();\n\n  const CallExpr *AllocCall = dyn_cast<CallExpr>(RHS);\n\
  \  if (!AllocCall) return;\n  if (!isAllocLikeCall(AllocCall, C)) return;\n\n  //\
  \ 5) Compare the checked expression with the allocated lvalue using regions.\n \
  \ const MemRegion *AllocReg = getMemRegionFromExpr(LHS, C);\n  if (!AllocReg) return;\n\
  \  const MemRegion *CheckedReg = getMemRegionFromExpr(CheckedE, C);\n  if (!CheckedReg)\
  \ return;\n\n  // Always obtain base regions as suggested (we still keep originals\
  \ for field info).\n  const MemRegion *AllocBase = AllocReg->getBaseRegion();\n\
  \  const MemRegion *CheckedBase = CheckedReg->getBaseRegion();\n  (void)AllocBase;\n\
  \  (void)CheckedBase;\n\n  // We focus on field-to-field mismatches (siblings within\
  \ the same parent).\n  const auto *AllocField = dyn_cast<FieldRegion>(AllocReg);\n\
  \  const auto *CheckedField = dyn_cast<FieldRegion>(CheckedReg);\n  if (!AllocField\
  \ || !CheckedField)\n    return;\n\n  if (AllocField == CheckedField)\n    return;\
  \ // Correct field checked.\n\n  const MemRegion *AllocParent = AllocField->getSuperRegion();\n\
  \  const MemRegion *CheckedParent = CheckedField->getSuperRegion();\n  if (!AllocParent\
  \ || !CheckedParent)\n    return;\n\n  if (AllocParent != CheckedParent)\n    return;\
  \ // Not siblings in the same object; skip to avoid false positives.\n\n  // Optional\
  \ confidence boost: if 'then' branch immediately returns, it's likely an error path.\n\
  \  // This is optional and non-blocking; we don't require it to report.\n  (void)InnerIf;\n\
  \n  // 6) Report the bug.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N) return;\n\n  std::string CheckedTxt = getExprText(CheckedE, C);\n  std::string\
  \ AllocTxt = getExprText(LHS, C);\n  if (CheckedTxt.empty()) CheckedTxt = \"the\
  \ other field\";\n  if (AllocTxt.empty()) AllocTxt = \"allocated field\";\n\n  std::string\
  \ Msg = \"Wrong NULL check: checking '\" + CheckedTxt +\n                    \"\
  ' after allocating '\" + AllocTxt + \"'\";\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  R->addRange(CondE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects checking the wrong pointer for NULL after an allocation (e.g.,\
  \ checking a different field than the one just allocated)\",\n      \"\");\n}\n\n\
  extern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
