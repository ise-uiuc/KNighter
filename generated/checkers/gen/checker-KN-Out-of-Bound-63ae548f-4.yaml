_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 63ae548f1054a0b71678d0349c7dc9628ddd42ca
commit_type: Out-of-Bound
index: 4
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/Regions.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"llvm/ADT/APInt.h\"\
  \n#include <string>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No custom program states are required.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::Location> {\n  mutable std::unique_ptr<BugType> BT;\n\n\
  public:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Out-of-bounds LUT\
  \ index\", \"Array bounds\")) {}\n\n  void checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S,\n                     CheckerContext &C) const;\n\nprivate:\n \
  \ // Helpers\n  bool getConstantArrayBound(const MemRegion *R, uint64_t &ArraySize,\n\
  \                             CheckerContext &C) const;\n\n  bool isDefiniteOOB(const\
  \ nonloc::ConcreteInt &Idx, uint64_t ArraySize) const;\n\n  bool isGuardedByBound(const\
  \ Stmt *AccessSite, const Expr *IdxE,\n                        CheckerContext &C)\
  \ const;\n\n  void reportOOB(const Stmt *S, const Expr *IdxE, bool Definite,\n \
  \                CheckerContext &C) const;\n};\n\n// Walk up super-regions until\
  \ we find a TypedValueRegion and try to get a\n// ConstantArrayType from it. Returns\
  \ true and fills ArraySize if found.\nbool SAGenTestChecker::getConstantArrayBound(const\
  \ MemRegion *R,\n                                             uint64_t &ArraySize,\n\
  \                                             CheckerContext &C) const {\n  const\
  \ MemRegion *Cur = R;\n  while (Cur) {\n    if (const auto *TVR = dyn_cast<TypedValueRegion>(Cur))\
  \ {\n      QualType T = TVR->getValueType(C.getASTContext());\n      if (const auto\
  \ *CAT = C.getASTContext().getAsConstantArrayType(T)) {\n        ArraySize = CAT->getSize().getZExtValue();\n\
  \        return true;\n      }\n      // If the typed region is not a constant array,\
  \ we cannot derive a bound.\n      return false;\n    }\n    const auto *SR = dyn_cast<SubRegion>(Cur);\n\
  \    if (!SR)\n      break;\n    Cur = SR->getSuperRegion();\n  }\n  return false;\n\
  }\n\n// Check if a concrete index is definitely out of bounds (negative or >= bound).\n\
  bool SAGenTestChecker::isDefiniteOOB(const nonloc::ConcreteInt &Idx,\n         \
  \                            uint64_t ArraySize) const {\n  const llvm::APSInt &V\
  \ = Idx.getValue();\n  // Negative index is definitely invalid.\n  if (V.isSigned()\
  \ && V.isNegative())\n    return true;\n\n  // Compare V >= ArraySize\n  llvm::APSInt\
  \ Bound(V.getBitWidth(), /*isUnsigned=*/true);\n  Bound = ArraySize;\n  // Use unsigned\
  \ comparison for bound as array size is non-negative.\n  llvm::APSInt VUnsigned\
  \ = V;\n  VUnsigned.setIsUnsigned(true);\n  return VUnsigned >= Bound;\n}\n\n//\
  \ Try to suppress false positives if we are clearly under a guard like\n// \"i <\
  \ TRANSFER_FUNC_POINTS\" nearby. We only do a lightweight syntactic check:\n// the\
  \ condition text must contain both the index variable name and the literal\n// \"\
  TRANSFER_FUNC_POINTS\".\nbool SAGenTestChecker::isGuardedByBound(const Stmt *AccessSite,\n\
  \                                        const Expr *IdxE,\n                   \
  \                     CheckerContext &C) const {\n  if (!AccessSite || !IdxE)\n\
  \    return false;\n\n  // Extract a simple variable name if the index is a DeclRefExpr.\n\
  \  std::string IdxName;\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(IdxE->IgnoreParenCasts()))\
  \ {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n      IdxName\
  \ = VD->getName().str();\n  }\n  if (IdxName.empty())\n    return false;\n\n  //\
  \ Find a nearby condition: IfStmt, WhileStmt, ForStmt.\n  if (const auto *IS = findSpecificTypeInParents<IfStmt>(AccessSite,\
  \ C)) {\n    const Expr *Cond = IS->getCond();\n    if (Cond && ExprHasName(Cond,\
  \ IdxName, C) &&\n        ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\", C))\n    \
  \  return true;\n  }\n\n  if (const auto *WS = findSpecificTypeInParents<WhileStmt>(AccessSite,\
  \ C)) {\n    const Expr *Cond = WS->getCond();\n    if (Cond && ExprHasName(Cond,\
  \ IdxName, C) &&\n        ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\", C))\n    \
  \  return true;\n  }\n\n  if (const auto *FS = findSpecificTypeInParents<ForStmt>(AccessSite,\
  \ C)) {\n    const Expr *Cond = FS->getCond();\n    if (Cond && ExprHasName(Cond,\
  \ IdxName, C) &&\n        ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\", C))\n    \
  \  return true;\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::reportOOB(const\
  \ Stmt *S, const Expr *IdxE,\n                                 bool Definite, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  const char *Msg = Definite\n                        ? \"Out-of-bounds\
  \ array access: index >= array size\"\n                        : \"Possible out-of-bounds\
  \ access: index may exceed array size\";\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n\n  if (IdxE)\n    R->addRange(IdxE->getSourceRange());\n  else if (S)\n\
  \    R->addRange(S->getSourceRange());\n\n  C.emitReport(std::move(R));\n}\n\nvoid\
  \ SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\n      \
  \                               CheckerContext &C) const {\n  // Only check reads\
  \ from arrays (the bug pattern is reading LUTs).\n  if (!IsLoad)\n    return;\n\n\
  \  const MemRegion *MR = Loc.getAsRegion();\n  if (!MR)\n    return;\n\n  // We\
  \ only care about element access like arr[i].\n  const auto *ER = dyn_cast<ElementRegion>(MR);\n\
  \  if (!ER)\n    return;\n\n  // Find a constant array bound from the super region.\n\
  \  uint64_t ArraySize = 0;\n  if (!getConstantArrayBound(ER->getSuperRegion(), ArraySize,\
  \ C))\n    return; // Not a fixed-size array we can reason about.\n\n  // Try to\
  \ find the ArraySubscriptExpr in the AST to obtain the index Expr.\n  const ArraySubscriptExpr\
  \ *ASE =\n      findSpecificTypeInParents<ArraySubscriptExpr>(S, C);\n  if (!ASE)\n\
  \    ASE = findSpecificTypeInChildren<ArraySubscriptExpr>(S);\n\n  const Expr *IdxE\
  \ = ASE ? ASE->getIdx() : nullptr;\n\n  // Evaluate the index SVal from the region.\n\
  \  SVal IdxSV = ER->getIndex();\n\n  // Case 1: Concrete index -> definite check.\n\
  \  if (const auto *CI = IdxSV.getAs<nonloc::ConcreteInt>()) {\n    if (isDefiniteOOB(*CI,\
  \ ArraySize)) {\n      reportOOB(S, IdxE, /*Definite=*/true, C);\n    }\n    return;\n\
  \  }\n\n  // Case 2: Symbolic index -> use constraint info and heuristics.\n  if\
  \ (const auto *SymV = IdxSV.getAs<nonloc::SymbolVal>()) {\n    SymbolRef Sym = SymV->getSymbol();\n\
  \    if (!Sym)\n      return;\n\n    // If the analyzer can infer a maximal value,\
  \ and it can reach/exceed bound,\n    // then warn unless we find a nearby guard.\n\
  \    if (const llvm::APSInt *Max = inferSymbolMaxVal(Sym, C)) {\n      llvm::APInt\
  \ Bound(Max->getBitWidth(), ArraySize, /*isSigned=*/false);\n      if (Max->uge(Bound))\
  \ {\n        // If syntactically guarded by i < TRANSFER_FUNC_POINTS, suppress.\n\
  \        if (!isGuardedByBound(S, IdxE, C))\n          reportOOB(S, IdxE, /*Definite=*/false,\
  \ C);\n      }\n      return;\n    }\n\n    // If we can't infer a max value, rely\
  \ on syntactic guard heuristics.\n    if (!isGuardedByBound(S, IdxE, C)) {\n   \
  \   reportOOB(S, IdxE, /*Definite=*/false, C);\n    }\n    return;\n  }\n\n  //\
  \ Unknown/other index kind: do not report.\n}\n\n} // end anonymous namespace\n\n\
  extern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects possible out-of-bounds accesses\
  \ when indexing fixed-size LUT arrays without proper bound checks\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Fix potential index out of bounds\
  \ in color transformation function\n\nFixes index out of bounds issue in the color\
  \ transformation function.\nThe issue could occur when the index 'i' exceeds the\
  \ number of transfer\nfunction points (TRANSFER_FUNC_POINTS).\n\nThe fix adds a\
  \ check to ensure 'i' is within bounds before accessing the\ntransfer function points.\
  \ If 'i' is out of bounds, an error message is\nlogged and the function returns\
  \ false to indicate an error.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:405\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.red'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:406\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.green'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:407\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.blue'\
  \ 1025 <= s32max\n\nFixes: b629596072e5 (\"drm/amd/display: Build unity lut for\
  \ shaper\")\nCc: Vitaly Prosyak <vitaly.prosyak@amd.com>\nCc: Charlene Liu <Charlene.Liu@amd.com>\n\
  Cc: Harry Wentland <harry.wentland@amd.com>\nCc: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>\n\
  Cc: Roman Li <roman.li@amd.com>\nCc: Aurabindo Pillai <aurabindo.pillai@amd.com>\n\
  Cc: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Srinivasan Shanmugam <srinivasan.shanmugam@amd.com>\n\
  Reviewed-by: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Alex Deucher <alexander.deucher@amd.com>\n\
  \n## Buggy Code\n\n```c\n// Function: cm_helper_translate_curve_to_hw_format in\
  \ drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nbool cm_helper_translate_curve_to_hw_format(struct\
  \ dc_context *ctx,\n\t\t\t\tconst struct dc_transfer_func *output_tf,\n\t\t\t\t\
  struct pwl_params *lut_params, bool fixpoint)\n{\n\tstruct curve_points3 *corner_points;\n\
  \tstruct pwl_result_data *rgb_resulted;\n\tstruct pwl_result_data *rgb;\n\tstruct\
  \ pwl_result_data *rgb_plus_1;\n\tstruct pwl_result_data *rgb_minus_1;\n\n\tint32_t\
  \ region_start, region_end;\n\tint32_t i;\n\tuint32_t j, k, seg_distr[MAX_REGIONS_NUMBER],\
  \ increment, start_index, hw_points;\n\n\tif (output_tf == NULL || lut_params ==\
  \ NULL || output_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\tcorner_points\
  \ = lut_params->corner_points;\n\trgb_resulted = lut_params->rgb_resulted;\n\thw_points\
  \ = 0;\n\n\tmemset(lut_params, 0, sizeof(struct pwl_params));\n\tmemset(seg_distr,\
  \ 0, sizeof(seg_distr));\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ || output_tf->tf\
  \ == TRANSFER_FUNCTION_GAMMA22) {\n\t\t/* 32 segments\n\t\t * segments are from\
  \ 2^-25 to 2^7\n\t\t */\n\t\tfor (i = 0; i < NUMBER_REGIONS ; i++)\n\t\t\tseg_distr[i]\
  \ = 3;\n\n\t\tregion_start = -MAX_LOW_POINT;\n\t\tregion_end   = NUMBER_REGIONS\
  \ - MAX_LOW_POINT;\n\t} else {\n\t\t/* 11 segments\n\t\t * segment is from 2^-10\
  \ to 2^1\n\t\t * There are less than 256 points, for optimization\n\t\t */\n\t\t\
  seg_distr[0] = 3;\n\t\tseg_distr[1] = 4;\n\t\tseg_distr[2] = 4;\n\t\tseg_distr[3]\
  \ = 4;\n\t\tseg_distr[4] = 4;\n\t\tseg_distr[5] = 4;\n\t\tseg_distr[6] = 4;\n\t\t\
  seg_distr[7] = 4;\n\t\tseg_distr[8] = 4;\n\t\tseg_distr[9] = 4;\n\t\tseg_distr[10]\
  \ = 1;\n\n\t\tregion_start = -10;\n\t\tregion_end = 1;\n\t}\n\n\tfor (i = region_end\
  \ - region_start; i < MAX_REGIONS_NUMBER ; i++)\n\t\tseg_distr[i] = -1;\n\n\tfor\
  \ (k = 0; k < MAX_REGIONS_NUMBER; k++) {\n\t\tif (seg_distr[k] != -1)\n\t\t\thw_points\
  \ += (1 << seg_distr[k]);\n\t}\n\n\tj = 0;\n\tfor (k = 0; k < (region_end - region_start);\
  \ k++) {\n\t\tincrement = NUMBER_SW_SEGMENTS / (1 << seg_distr[k]);\n\t\tstart_index\
  \ = (region_start + k + MAX_LOW_POINT) *\n\t\t\t\tNUMBER_SW_SEGMENTS;\n\t\tfor (i\
  \ = start_index; i < start_index + NUMBER_SW_SEGMENTS;\n\t\t\t\ti += increment)\
  \ {\n\t\t\tif (j == hw_points - 1)\n\t\t\t\tbreak;\n\t\t\trgb_resulted[j].red =\
  \ output_tf->tf_pts.red[i];\n\t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n\
  \t\t\trgb_resulted[j].blue = output_tf->tf_pts.blue[i];\n\t\t\tj++;\n\t\t}\n\t}\n\
  \n\t/* last point */\n\tstart_index = (region_end + MAX_LOW_POINT) * NUMBER_SW_SEGMENTS;\n\
  \trgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];\n\trgb_resulted[hw_points\
  \ - 1].green = output_tf->tf_pts.green[start_index];\n\trgb_resulted[hw_points -\
  \ 1].blue = output_tf->tf_pts.blue[start_index];\n\n\trgb_resulted[hw_points].red\
  \ = rgb_resulted[hw_points - 1].red;\n\trgb_resulted[hw_points].green = rgb_resulted[hw_points\
  \ - 1].green;\n\trgb_resulted[hw_points].blue = rgb_resulted[hw_points - 1].blue;\n\
  \n\t// All 3 color channels have same x\n\tcorner_points[0].red.x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\
  \t\t\t\t\t     dc_fixpt_from_int(region_start));\n\tcorner_points[0].green.x = corner_points[0].red.x;\n\
  \tcorner_points[0].blue.x = corner_points[0].red.x;\n\n\tcorner_points[1].red.x\
  \ = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_end));\n\
  \tcorner_points[1].green.x = corner_points[1].red.x;\n\tcorner_points[1].blue.x\
  \ = corner_points[1].red.x;\n\n\tcorner_points[0].red.y = rgb_resulted[0].red;\n\
  \tcorner_points[0].green.y = rgb_resulted[0].green;\n\tcorner_points[0].blue.y =\
  \ rgb_resulted[0].blue;\n\n\tcorner_points[0].red.slope = dc_fixpt_div(corner_points[0].red.y,\n\
  \t\t\tcorner_points[0].red.x);\n\tcorner_points[0].green.slope = dc_fixpt_div(corner_points[0].green.y,\n\
  \t\t\tcorner_points[0].green.x);\n\tcorner_points[0].blue.slope = dc_fixpt_div(corner_points[0].blue.y,\n\
  \t\t\tcorner_points[0].blue.x);\n\n\t/* see comment above, m_arrPoints[1].y should\
  \ be the Y value for the\n\t * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints\
  \ - 1)\n\t */\n\tcorner_points[1].red.y = rgb_resulted[hw_points - 1].red;\n\tcorner_points[1].green.y\
  \ = rgb_resulted[hw_points - 1].green;\n\tcorner_points[1].blue.y = rgb_resulted[hw_points\
  \ - 1].blue;\n\tcorner_points[1].red.slope = dc_fixpt_zero;\n\tcorner_points[1].green.slope\
  \ = dc_fixpt_zero;\n\tcorner_points[1].blue.slope = dc_fixpt_zero;\n\n\tif (output_tf->tf\
  \ == TRANSFER_FUNCTION_PQ) {\n\t\t/* for PQ, we want to have a straight line from\
  \ last HW X point,\n\t\t * and the slope to be such that we hit 1.0 at 10000 nits.\n\
  \t\t */\n\t\tconst struct fixed31_32 end_value =\n\t\t\t\tdc_fixpt_from_int(125);\n\
  \n\t\tcorner_points[1].red.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].red.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].red.x));\n\
  \t\tcorner_points[1].green.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].green.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].green.x));\n\
  \t\tcorner_points[1].blue.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].blue.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].blue.x));\n\
  \t}\n\n\tlut_params->hw_points_num = hw_points;\n\n\tk = 0;\n\tfor (i = 1; i < MAX_REGIONS_NUMBER;\
  \ i++) {\n\t\tif (seg_distr[k] != -1) {\n\t\t\tlut_params->arr_curve_points[k].segments_num\
  \ =\n\t\t\t\t\tseg_distr[k];\n\t\t\tlut_params->arr_curve_points[i].offset =\n\t\
  \t\t\t\tlut_params->arr_curve_points[k].offset + (1 << seg_distr[k]);\n\t\t}\n\t\
  \tk++;\n\t}\n\n\tif (seg_distr[k] != -1)\n\t\tlut_params->arr_curve_points[k].segments_num\
  \ = seg_distr[k];\n\n\trgb = rgb_resulted;\n\trgb_plus_1 = rgb_resulted + 1;\n\t\
  rgb_minus_1 = rgb;\n\n\ti = 1;\n\twhile (i != hw_points + 1) {\n\n\t\tif (i >= hw_points\
  \ - 1) {\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->red, rgb->red))\n\t\t\t\trgb_plus_1->red\
  \ = dc_fixpt_add(rgb->red, rgb_minus_1->delta_red);\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->green,\
  \ rgb->green))\n\t\t\t\trgb_plus_1->green = dc_fixpt_add(rgb->green, rgb_minus_1->delta_green);\n\
  \t\t\tif (dc_fixpt_lt(rgb_plus_1->blue, rgb->blue))\n\t\t\t\trgb_plus_1->blue =\
  \ dc_fixpt_add(rgb->blue, rgb_minus_1->delta_blue);\n\t\t}\n\n\t\trgb->delta_red\
  \   = dc_fixpt_sub(rgb_plus_1->red,   rgb->red);\n\t\trgb->delta_green = dc_fixpt_sub(rgb_plus_1->green,\
  \ rgb->green);\n\t\trgb->delta_blue  = dc_fixpt_sub(rgb_plus_1->blue,  rgb->blue);\n\
  \n\n\t\tif (fixpoint == true) {\n\t\t\tuint32_t red_clamp = dc_fixpt_clamp_u0d14(rgb->delta_red);\n\
  \t\t\tuint32_t green_clamp = dc_fixpt_clamp_u0d14(rgb->delta_green);\n\t\t\tuint32_t\
  \ blue_clamp = dc_fixpt_clamp_u0d14(rgb->delta_blue);\n\n\t\t\tif (red_clamp >>\
  \ 10 || green_clamp >> 10 || blue_clamp >> 10)\n\t\t\t\tDC_LOG_WARNING(\"Losing\
  \ delta precision while programming shaper LUT.\");\n\n\t\t\trgb->delta_red_reg\
  \   = red_clamp & 0x3ff;\n\t\t\trgb->delta_green_reg = green_clamp & 0x3ff;\n\t\t\
  \trgb->delta_blue_reg  = blue_clamp & 0x3ff;\n\t\t\trgb->red_reg         = dc_fixpt_clamp_u0d14(rgb->red);\n\
  \t\t\trgb->green_reg       = dc_fixpt_clamp_u0d14(rgb->green);\n\t\t\trgb->blue_reg\
  \        = dc_fixpt_clamp_u0d14(rgb->blue);\n\t\t}\n\n\t\t++rgb_plus_1;\n\t\trgb_minus_1\
  \ = rgb;\n\t\t++rgb;\n\t\t++i;\n\t}\n\tcm_helper_convert_to_custom_float(rgb_resulted,\n\
  \t\t\t\t\t\tlut_params->corner_points,\n\t\t\t\t\t\thw_points, fixpoint);\n\n\t\
  return true;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\
  \ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nindex b7e57aa27361..b0d192c6e63e\
  \ 100644\n--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n\
  @@ -402,6 +402,11 @@ bool cm_helper_translate_curve_to_hw_format(struct dc_context\
  \ *ctx,\n \t\t\t\ti += increment) {\n \t\t\tif (j == hw_points - 1)\n \t\t\t\tbreak;\n\
  +\t\t\tif (i >= TRANSFER_FUNC_POINTS) {\n+\t\t\t\tDC_LOG_ERROR(\"Index out of bounds:\
  \ i=%d, TRANSFER_FUNC_POINTS=%d\\n\",\n+\t\t\t\t\t     i, TRANSFER_FUNC_POINTS);\n\
  +\t\t\t\treturn false;\n+\t\t\t}\n \t\t\trgb_resulted[j].red = output_tf->tf_pts.red[i];\n\
  \ \t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n \t\t\trgb_resulted[j].blue\
  \ = output_tf->tf_pts.blue[i];\n```\n"
pattern: "## Bug Pattern\n\nIndexing fixed-size LUT arrays with a computed index without\
  \ validating the index against the array\u2019s bound. Specifically, using a loop-controlled,\
  \ arithmetic-derived index (i) to access output_tf->tf_pts.{red,green,blue}[i] while\
  \ terminating the loop based on a different counter (j/hw_points), and without checking\
  \ i < TRANSFER_FUNC_POINTS, which can lead to out-of-bounds array access."
plan: "Plan\n\n1) Program state\n- Do not introduce custom program state. Leverage\
  \ the analyzer\u2019s constraint manager to reason about the index range (inferSymbolMaxVal)\
  \ and keep the checker simple and path-sensitive.\n\n2) Primary callback: checkLocation\n\
  Goal: Detect potential or definite out-of-bounds array element access where the\
  \ array has a known constant bound (e.g., TRANSFER_FUNC_POINTS) and the index can\
  \ exceed that bound.\n\nImplementation details:\n- Trigger only on loads (IsLoad\
  \ == true). We care about reading from LUT arrays like tf_pts.{red,green,blue}[i].\
  \ This avoids false positives on storing into other arrays.\n- Extract the region:\n\
  \  - Convert Loc to a MemRegion via Loc.getAs<loc::MemRegionVal>() and retrieve\
  \ const MemRegion *R.\n  - dyn_cast to const ElementRegion *ER; if it\u2019s not\
  \ an ElementRegion, return.\n  - Get the index SVal: ER->getIndex(). If it\u2019\
  s not a nonloc::ConcreteInt or nonloc::SymbolVal (symbolic), return.\n- Obtain the\
  \ array bound:\n  - Walk up ER->getSuperRegion() until you find a TypedValueRegion\
  \ (FieldRegion/BaseRegion/etc.) and retrieve its QualType using getValueType(C.getASTContext()).\n\
  \  - dyn_cast the QualType to ConstantArrayType; if not a constant array, return.\n\
  \  - Get the array size: ConstantArrayType->getSize() (APInt) and convert to uint64_t\
  \ (ArraySize).\n- Decide if the access may be out-of-bounds:\n  - If the index is\
  \ a nonloc::ConcreteInt, compare to ArraySize. If Index >= ArraySize or Index <\
  \ 0, report as a definite OOB.\n  - If the index is symbolic (nonloc::SymbolVal):\n\
  \    - Extract the SymbolRef; use inferSymbolMaxVal(IndexSym, C).\n    - If maxVal\
  \ is available and maxVal.uge(ArraySize), report a potential OOB (index can reach\
  \ or exceed array bound).\n    - If maxVal is unavailable (null), we cannot prove\
  \ safety. Perform a few lightweight heuristics before reporting:\n      - Try to\
  \ see if this access is under a nearby explicit bound check in the AST. Use findSpecificTypeInParents\
  \ to find the nearest IfStmt or loop condition (ForStmt/WhileStmt) from the Stmt\
  \ argument S:\n        - If an IfStmt or loop condition exists, and its condition\
  \ source contains both the index variable\u2019s textual name and the array bound\
  \ name, suppress the report (likely guarded).\n        - To get the index name:\
  \ cast S to ArraySubscriptExpr and extract the index expression IE; use ExprHasName\
  \ on the condition with the textual form of IE. To check bound symbol presence,\
  \ also use ExprHasName with \"TRANSFER_FUNC_POINTS\" (or, more generally, the bound\u2019\
  s macro name if you can get it from the type\u2019s size expr; if not, just check\
  \ for the literal bound value).\n      - If there is no nearby guard found, report\
  \ a potential OOB (index not proven bounded by the array size).\n- Reporting:\n\
  \  - Create a BugType once (e.g., \u201COut-of-bounds LUT index\u201D).\n  - Generate\
  \ a non-fatal error node via C.generateNonFatalErrorNode().\n  - Build a PathSensitiveBugReport\
  \ with message:\n    - For definite issues: \u201COut-of-bounds array access: index\
  \ is >= array size.\u201D\n    - For potential issues: \u201CPossible out-of-bounds\
  \ access: index may exceed array size; add \u2018i < TRANSFER_FUNC_POINTS\u2019\
  \ check.\u201D\n  - Add the source range of the index expression (ArraySubscriptExpr\u2019\
  s getIdx()) to highlight the exact code.\n- Notes about the target pattern:\n  -\
  \ The buggy pattern terminates the loop based on j/hw_points while indexing with\
  \ i. The constraint manager typically won\u2019t infer a safe upper bound for i\
  \ in such loops, causing maxVal to be unknown or too large, which will trigger the\
  \ potential OOB report.\n  - The last-point indexing (e.g., arr[start_index]) is\
  \ handled the same way since ER->getIndex() will be that computed expression; if\
  \ it\u2019s not constrained against ArraySize, we warn.\n\n3) Optional callback:\
  \ checkBranchCondition (lightweight suppression)\nGoal: Reduce false positives by\
  \ recognizing explicit guard conditions that bound the index variable against the\
  \ array bound.\n\nImplementation details:\n- When a branch condition is visited,\
  \ if its condition is a binary comparison that clearly constrains the index variable\
  \ (e.g., i < TRANSFER_FUNC_POINTS, i <= TRANSFER_FUNC_POINTS-1, TRANSFER_FUNC_POINTS\
  \ > i, etc.), the constraint manager already learns this under the respective branch.\
  \ Therefore, nothing is strictly necessary here.\n- If you find the analyzer fails\
  \ to propagate constraints consistently for macro constants, you can add an extra\
  \ syntactic suppression flag on the ExplodedNode via ProgramPoint tags. However,\
  \ prefer to rely on inferSymbolMaxVal as it reads the already-refined constraints.\n\
  \n4) Minor heuristics (still inside checkLocation)\n- Prefer to report when the\
  \ array base is clearly a LUT-like fixed-size buffer (the ConstantArrayType size\
  \ is large and fixed). If needed, to closely match the patch case, you can additionally:\n\
  \  - Check if the base expression text (use the Stmt S and its children) contains\
  \ \u201Ctf_pts\u201D and any of \u201Cred\u201D, \u201Cgreen\u201D, \u201Cblue\u201D\
  \ via ExprHasName, and raise the priority for such cases. This is optional; the\
  \ core logic remains general.\n\n5) No other callbacks required\n- No need for checkPostCall,\
  \ checkBind, or evalAssume. The constraint manager and the regional reasoning in\
  \ checkLocation are sufficient for this pattern.\n\nSummary of what this catches\n\
  - Accesses like output_tf->tf_pts.red[i] or .green[i] or .blue[i] when i is not\
  \ provably constrained to be less than TRANSFER_FUNC_POINTS.\n- Loop patterns where\
  \ i grows by arithmetic and the loop exits based on a different counter (j/hw_points)\
  \ will typically not refine i\u2019s max value; the checker flags these as potential\
  \ OOB.\n- It also catches definite OOB when the index is concrete and >= bound,\
  \ and \u201Clast point\u201D patterns that compute start_index without proper bound\
  \ checks.\n\nReport message\n- Keep it short and clear:\n  - \u201CPossible out-of-bounds\
  \ access: index may exceed TRANSFER_FUNC_POINTS.\u201D\n  - For definite: \u201C\
  Out-of-bounds array access: index >= TRANSFER_FUNC_POINTS.\u201D"
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"llvm/ADT/APInt.h\"\
  \n#include <string>\n#include <memory>\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// No custom program states are required.\n\n\
  namespace {\n\nclass SAGenTestChecker : public Checker<check::Location> {\n  mutable\
  \ std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new\
  \ BugType(this, \"Out-of-bounds LUT index\", \"Array bounds\")) {}\n\n  void checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S,\n                     CheckerContext &C) const;\n\
  \nprivate:\n  // Helpers\n  bool getConstantArrayBound(const MemRegion *R, uint64_t\
  \ &ArraySize,\n                             CheckerContext &C) const;\n\n  bool\
  \ isDefiniteOOB(const nonloc::ConcreteInt &Idx, uint64_t ArraySize) const;\n\n \
  \ bool isGuardedByBound(const Stmt *AccessSite, const Expr *IdxE,\n            \
  \            CheckerContext &C) const;\n\n  void reportOOB(const Stmt *S, const\
  \ Expr *IdxE, bool Definite,\n                 CheckerContext &C) const;\n};\n\n\
  // Walk up super-regions until we find a TypedValueRegion and try to get a\n// ConstantArrayType\
  \ from it. Returns true and fills ArraySize if found.\nbool SAGenTestChecker::getConstantArrayBound(const\
  \ MemRegion *R,\n                                             uint64_t &ArraySize,\n\
  \                                             CheckerContext &C) const {\n  const\
  \ MemRegion *Cur = R;\n  while (Cur) {\n    if (const auto *TVR = dyn_cast<TypedValueRegion>(Cur))\
  \ {\n      QualType T = TVR->getValueType();\n      if (const auto *CAT = C.getASTContext().getAsConstantArrayType(T))\
  \ {\n        ArraySize = CAT->getSize().getZExtValue();\n        return true;\n\
  \      }\n      // If the typed region is not a constant array, we cannot derive\
  \ a bound.\n      return false;\n    }\n    const auto *SR = dyn_cast<SubRegion>(Cur);\n\
  \    if (!SR)\n      break;\n    Cur = SR->getSuperRegion();\n  }\n  return false;\n\
  }\n\n// Check if a concrete index is definitely out of bounds (negative or >= bound).\n\
  bool SAGenTestChecker::isDefiniteOOB(const nonloc::ConcreteInt &Idx,\n         \
  \                            uint64_t ArraySize) const {\n  const llvm::APSInt &V\
  \ = Idx.getValue();\n  // Negative index is definitely invalid.\n  if (V.isSigned()\
  \ && V.isNegative())\n    return true;\n\n  // Compare V >= ArraySize\n  llvm::APSInt\
  \ Bound(V.getBitWidth(), /*isUnsigned=*/true);\n  Bound = ArraySize;\n  // Use unsigned\
  \ comparison for bound as array size is non-negative.\n  llvm::APSInt VUnsigned\
  \ = V;\n  VUnsigned.setIsUnsigned(true);\n  return VUnsigned >= Bound;\n}\n\n//\
  \ Try to suppress false positives if we are clearly under a guard like\n// \"i <\
  \ TRANSFER_FUNC_POINTS\" nearby. We only do a lightweight syntactic check:\n// the\
  \ condition text must contain both the index variable name and the literal\n// \"\
  TRANSFER_FUNC_POINTS\".\nbool SAGenTestChecker::isGuardedByBound(const Stmt *AccessSite,\n\
  \                                        const Expr *IdxE,\n                   \
  \                     CheckerContext &C) const {\n  if (!AccessSite || !IdxE)\n\
  \    return false;\n\n  // Extract a simple variable name if the index is a DeclRefExpr.\n\
  \  std::string IdxName;\n  if (const auto *DRE = dyn_cast<DeclRefExpr>(IdxE->IgnoreParenCasts()))\
  \ {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n      IdxName\
  \ = VD->getName().str();\n  }\n  if (IdxName.empty())\n    return false;\n\n  //\
  \ Find a nearby condition: IfStmt, WhileStmt, ForStmt.\n  if (const auto *IS = findSpecificTypeInParents<IfStmt>(AccessSite,\
  \ C)) {\n    const Expr *Cond = IS->getCond();\n    if (Cond && ExprHasName(Cond,\
  \ IdxName, C) &&\n        ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\", C))\n    \
  \  return true;\n  }\n\n  if (const auto *WS = findSpecificTypeInParents<WhileStmt>(AccessSite,\
  \ C)) {\n    const Expr *Cond = WS->getCond();\n    if (Cond && ExprHasName(Cond,\
  \ IdxName, C) &&\n        ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\", C))\n    \
  \  return true;\n  }\n\n  if (const auto *FS = findSpecificTypeInParents<ForStmt>(AccessSite,\
  \ C)) {\n    const Expr *Cond = FS->getCond();\n    if (Cond && ExprHasName(Cond,\
  \ IdxName, C) &&\n        ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\", C))\n    \
  \  return true;\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::reportOOB(const\
  \ Stmt *S, const Expr *IdxE,\n                                 bool Definite, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  const char *Msg = Definite\n                        ? \"Out-of-bounds\
  \ array access: index >= array size\"\n                        : \"Possible out-of-bounds\
  \ access: index may exceed array size\";\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n\n  if (IdxE)\n    R->addRange(IdxE->getSourceRange());\n  else if (S)\n\
  \    R->addRange(S->getSourceRange());\n\n  C.emitReport(std::move(R));\n}\n\nvoid\
  \ SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\n      \
  \                               CheckerContext &C) const {\n  // Only check reads\
  \ from arrays (the bug pattern is reading LUTs).\n  if (!IsLoad)\n    return;\n\n\
  \  const MemRegion *MR = Loc.getAsRegion();\n  if (!MR)\n    return;\n\n  // We\
  \ only care about element access like arr[i].\n  const auto *ER = dyn_cast<ElementRegion>(MR);\n\
  \  if (!ER)\n    return;\n\n  // Find a constant array bound from the super region.\n\
  \  uint64_t ArraySize = 0;\n  if (!getConstantArrayBound(ER->getSuperRegion(), ArraySize,\
  \ C))\n    return; // Not a fixed-size array we can reason about.\n\n  // Try to\
  \ find the ArraySubscriptExpr in the AST to obtain the index Expr.\n  const ArraySubscriptExpr\
  \ *ASE =\n      findSpecificTypeInParents<ArraySubscriptExpr>(S, C);\n  if (!ASE)\n\
  \    ASE = findSpecificTypeInChildren<ArraySubscriptExpr>(S);\n\n  const Expr *IdxE\
  \ = ASE ? ASE->getIdx() : nullptr;\n\n  // Evaluate the index SVal from the region.\n\
  \  SVal IdxSV = ER->getIndex();\n\n  // Case 1: Concrete index -> definite check.\n\
  \  if (auto CI = IdxSV.getAs<nonloc::ConcreteInt>()) {\n    if (isDefiniteOOB(*CI,\
  \ ArraySize)) {\n      reportOOB(S, IdxE, /*Definite=*/true, C);\n    }\n    return;\n\
  \  }\n\n  // Case 2: Symbolic index -> use constraint info and heuristics.\n  if\
  \ (auto SymV = IdxSV.getAs<nonloc::SymbolVal>()) {\n    SymbolRef Sym = SymV->getSymbol();\n\
  \    if (!Sym)\n      return;\n\n    // If the analyzer can infer a maximal value,\
  \ and it can reach/exceed bound,\n    // then warn unless we find a nearby guard.\n\
  \    if (const llvm::APSInt *Max = inferSymbolMaxVal(Sym, C)) {\n      llvm::APInt\
  \ Bound(Max->getBitWidth(), ArraySize, /*isSigned=*/false);\n      if (Max->uge(Bound))\
  \ {\n        // If syntactically guarded by i < TRANSFER_FUNC_POINTS, suppress.\n\
  \        if (!isGuardedByBound(S, IdxE, C))\n          reportOOB(S, IdxE, /*Definite=*/false,\
  \ C);\n      }\n      return;\n    }\n\n    // If we can't infer a max value, rely\
  \ on syntactic guard heuristics.\n    if (!isGuardedByBound(S, IdxE, C)) {\n   \
  \   reportOOB(S, IdxE, /*Definite=*/false, C);\n    }\n    return;\n  }\n\n  //\
  \ Unknown/other index kind: do not report.\n}\n\n} // end anonymous namespace\n\n\
  extern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects possible out-of-bounds accesses\
  \ when indexing fixed-size LUT arrays without proper bound checks\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
