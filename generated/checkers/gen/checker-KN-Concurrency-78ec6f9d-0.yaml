_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 78ec6f9df6642418411c534683da6133e0962ec7
commit_type: Concurrency
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"\
  clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n#include <map>\n#include <string>\n#include\
  \ <utility>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\
  \n// No custom program state is necessary for this checker.\n\nnamespace {\n\nenum\
  \ class PerCpuKind { Unknown, ThisCPU, RemoteCPU };\n\nclass SAGenTestChecker\n\
  \    : public Checker<check::ASTCodeBody, check::EndAnalysis> {\n\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\n  // Key: \"<RecordName>.<FieldName>\"\n  using SiteList = llvm::SmallVector<const\
  \ Stmt *, 4>;\n  std::map<std::string, SiteList> LocalRMWSites;     // from this_cpu_ptr\n\
  \  std::map<std::string, SiteList> RemoteWriteSites;  // from per_cpu_ptr\n\npublic:\n\
  \  SAGenTestChecker()\n      : BT(new BugType(this, \"Per-CPU non-atomic RMW race\"\
  , \"Concurrency\")) {}\n\n  void checkASTCodeBody(const Decl *D, AnalysisManager\
  \ &Mgr,\n                        BugReporter &BR) const;\n\n  void checkEndAnalysis(ExplodedGraph\
  \ &G, BugReporter &BR,\n                        ExprEngine &Eng) const;\n\nprivate:\n\
  \  // Utilities used by the AST traversal.\n  static const VarDecl *getReferencedVar(const\
  \ Expr *E) {\n    if (!E)\n      return nullptr;\n    E = E->IgnoreParenCasts();\n\
  \    if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {\n      return dyn_cast<VarDecl>(DRE->getDecl());\n\
  \    }\n    return nullptr;\n  }\n\n  static const MemberExpr *asMemberExpr(const\
  \ Expr *E) {\n    if (!E)\n      return nullptr;\n    return dyn_cast<MemberExpr>(E->IgnoreParenCasts());\n\
  \  }\n\n  static const FieldDecl *getFieldFromMemberExpr(const MemberExpr *ME) {\n\
  \    if (!ME)\n      return nullptr;\n    return dyn_cast<FieldDecl>(ME->getMemberDecl());\n\
  \  }\n\n  static const VarDecl *getBaseVarFromMemberExpr(const MemberExpr *ME) {\n\
  \    if (!ME)\n      return nullptr;\n    const Expr *Base = ME->getBase()->IgnoreParenCasts();\n\
  \    return getReferencedVar(Base);\n  }\n\n  static std::string buildFieldKey(const\
  \ MemberExpr *ME) {\n    if (!ME)\n      return std::string();\n    const FieldDecl\
  \ *FD = getFieldFromMemberExpr(ME);\n    if (!FD)\n      return std::string();\n\
  \n    // Get record name from the base type's pointee (for ->) or directly (for\
  \ .)\n    QualType BaseQT;\n    const Expr *Base = ME->getBase()->IgnoreParenCasts();\n\
  \    if (ME->isArrow())\n      BaseQT = Base->getType()->getPointeeType();\n   \
  \ else\n      BaseQT = Base->getType();\n\n    if (BaseQT.isNull())\n      return\
  \ FD->getNameAsString(); // fallback\n\n    const RecordType *RT = BaseQT->getAs<RecordType>();\n\
  \    std::string RecName;\n    if (RT && RT->getDecl())\n      RecName = RT->getDecl()->getNameAsString();\n\
  \n    if (RecName.empty())\n      return FD->getNameAsString();\n\n    return RecName\
  \ + \".\" + FD->getNameAsString();\n  }\n\n  static bool isCallNamed(const Expr\
  \ *E, StringRef Name) {\n    if (!E)\n      return false;\n    const auto *CE =\
  \ dyn_cast<CallExpr>(E->IgnoreParenCasts());\n    if (!CE)\n      return false;\n\
  \    if (const FunctionDecl *FD = CE->getDirectCallee()) {\n      return FD->getName()\
  \ == Name;\n    }\n    // Fallback: try if callee expression is a DeclRefExpr\n\
  \    const Expr *Callee = CE->getCallee()->IgnoreParenCasts();\n    if (const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(Callee)) {\n      if (const auto *FD2 = dyn_cast<FunctionDecl>(DRE->getDecl()))\n\
  \        return FD2->getName() == Name;\n    }\n    return false;\n    }\n\n  static\
  \ bool rhsReadsSameField(const Expr *RHS, const VarDecl *BaseVar,\n            \
  \                    const FieldDecl *Field) {\n    if (!RHS || !BaseVar || !Field)\n\
  \      return false;\n\n    // Recursive search in RHS for a MemberExpr that refers\
  \ to the same\n    // base VarDecl and same FieldDecl.\n    struct LocalVisitor\
  \ : public RecursiveASTVisitor<LocalVisitor> {\n      const VarDecl *BaseVar;\n\
  \      const FieldDecl *Field;\n      bool Found = false;\n\n      explicit LocalVisitor(const\
  \ VarDecl *BV, const FieldDecl *F)\n          : BaseVar(BV), Field(F) {}\n\n   \
  \   bool VisitMemberExpr(MemberExpr *ME) {\n        if (Found)\n          return\
  \ true;\n        const FieldDecl *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());\n\
  \        if (!FD)\n          return true;\n        if (FD != Field)\n          return\
  \ true;\n        const VarDecl *BV = nullptr;\n        const Expr *Base = ME->getBase();\n\
  \        if (Base)\n          BV = SAGenTestChecker::getReferencedVar(Base);\n \
  \       if (BV == BaseVar) {\n          Found = true;\n        }\n        return\
  \ true;\n      }\n    };\n\n    LocalVisitor V(BaseVar, Field);\n    V.TraverseStmt(const_cast<Expr\
  \ *>(RHS));\n    return V.Found;\n  }\n\n  // Visitor for a single function body.\n\
  \  class FuncVisitor : public RecursiveASTVisitor<FuncVisitor> {\n    ASTContext\
  \ &Ctx;\n    // Local per-function mapping from variables to percpu kind.\n    llvm::DenseMap<const\
  \ VarDecl *, PerCpuKind> VarKinds;\n\n    // References to the checker's global\
  \ site maps.\n    std::map<std::string, SiteList> &LocalRMWSites;\n    std::map<std::string,\
  \ SiteList> &RemoteWriteSites;\n\n  public:\n    FuncVisitor(ASTContext &Ctx,\n\
  \                std::map<std::string, SiteList> &LocalRMW,\n                std::map<std::string,\
  \ SiteList> &RemoteWrites)\n        : Ctx(Ctx), LocalRMWSites(LocalRMW), RemoteWriteSites(RemoteWrites)\
  \ {}\n\n    bool VisitVarDecl(VarDecl *VD) {\n      if (!VD || !VD->hasInit())\n\
  \        return true;\n      const Expr *Init = VD->getInit();\n      handleInitOrAssignmentToVar(VD,\
  \ Init);\n      return true;\n    }\n\n    bool VisitBinaryOperator(BinaryOperator\
  \ *BO) {\n      if (!BO)\n        return true;\n      if (BO->getOpcode() == BO_Assign)\
  \ {\n        const Expr *LHS = BO->getLHS();\n        const Expr *RHS = BO->getRHS();\n\
  \n        // Alias propagation: LHS is a variable, RHS is variable or call\n   \
  \     if (const VarDecl *LHSVar = SAGenTestChecker::getReferencedVar(LHS)) {\n \
  \         handleInitOrAssignmentToVar(LHSVar, RHS);\n        }\n\n        // Remote\
  \ write detection: LHS member through RemoteCPU pointer var\n        if (const MemberExpr\
  \ *ME = SAGenTestChecker::asMemberExpr(LHS)) {\n          const VarDecl *BaseVar\
  \ = SAGenTestChecker::getBaseVarFromMemberExpr(ME);\n          if (BaseVar) {\n\
  \            auto It = VarKinds.find(BaseVar);\n            if (It != VarKinds.end()\
  \ && It->second == PerCpuKind::RemoteCPU) {\n              std::string Key = SAGenTestChecker::buildFieldKey(ME);\n\
  \              if (!Key.empty())\n                RemoteWriteSites[Key].push_back(BO);\n\
  \            }\n          }\n        }\n\n        // Local explicit RMW: LHS is\
  \ member via ThisCPU var and RHS reads same field\n        if (const MemberExpr\
  \ *ME = SAGenTestChecker::asMemberExpr(LHS)) {\n          const VarDecl *BaseVar\
  \ = SAGenTestChecker::getBaseVarFromMemberExpr(ME);\n          const FieldDecl *Field\
  \ = SAGenTestChecker::getFieldFromMemberExpr(ME);\n          if (BaseVar && Field)\
  \ {\n            auto It = VarKinds.find(BaseVar);\n            if (It != VarKinds.end()\
  \ && It->second == PerCpuKind::ThisCPU) {\n              if (SAGenTestChecker::rhsReadsSameField(RHS,\
  \ BaseVar, Field)) {\n                std::string Key = SAGenTestChecker::buildFieldKey(ME);\n\
  \                if (!Key.empty())\n                  LocalRMWSites[Key].push_back(BO);\n\
  \              }\n            }\n          }\n        }\n      }\n      return true;\n\
  \    }\n\n    bool VisitCompoundAssignOperator(CompoundAssignOperator *CAO) {\n\
  \      if (!CAO)\n        return true;\n      const Expr *LHS = CAO->getLHS();\n\
  \      if (const MemberExpr *ME = SAGenTestChecker::asMemberExpr(LHS)) {\n     \
  \   const VarDecl *BaseVar = SAGenTestChecker::getBaseVarFromMemberExpr(ME);\n \
  \       if (BaseVar) {\n          auto It = VarKinds.find(BaseVar);\n          if\
  \ (It != VarKinds.end() && It->second == PerCpuKind::ThisCPU) {\n            std::string\
  \ Key = SAGenTestChecker::buildFieldKey(ME);\n            if (!Key.empty())\n  \
  \            LocalRMWSites[Key].push_back(CAO);\n          }\n        }\n      }\n\
  \      return true;\n    }\n\n  private:\n    void handleInitOrAssignmentToVar(const\
  \ VarDecl *TargetVD, const Expr *RHS) {\n      if (!TargetVD || !RHS)\n        return;\n\
  \n      // If RHS is a call to this_cpu_ptr/per_cpu_ptr\n      if (isCallNamed(RHS,\
  \ \"this_cpu_ptr\")) {\n        VarKinds[TargetVD] = PerCpuKind::ThisCPU;\n    \
  \    return;\n      }\n      if (isCallNamed(RHS, \"per_cpu_ptr\")) {\n        VarKinds[TargetVD]\
  \ = PerCpuKind::RemoteCPU;\n        return;\n      }\n\n      // Alias propagation\
  \ if RHS references another variable\n      if (const VarDecl *RHSVar = SAGenTestChecker::getReferencedVar(RHS))\
  \ {\n        auto It = VarKinds.find(RHSVar);\n        if (It != VarKinds.end()\
  \ && It->second != PerCpuKind::Unknown) {\n          VarKinds[TargetVD] = It->second;\n\
  \        }\n      }\n    }\n  };\n};\n\nvoid SAGenTestChecker::checkASTCodeBody(const\
  \ Decl *D, AnalysisManager &Mgr,\n                                        BugReporter\
  \ &BR) const {\n  if (!D)\n    return;\n  const Stmt *Body = D->getBody();\n  if\
  \ (!Body)\n    return;\n\n  // Perform a per-function AST traversal and collect\
  \ sites into the\n  // checker-level maps (LocalRMWSites and RemoteWriteSites).\n\
  \  ASTContext &Ctx = Mgr.getASTContext();\n  FuncVisitor V(Ctx,\n              \
  \  const_cast<std::map<std::string, SiteList> &>(LocalRMWSites),\n             \
  \   const_cast<std::map<std::string, SiteList> &>(RemoteWriteSites));\n  V.TraverseStmt(const_cast<Stmt\
  \ *>(Body));\n}\n\nvoid SAGenTestChecker::checkEndAnalysis(ExplodedGraph &G, BugReporter\
  \ &BR,\n                                        ExprEngine &Eng) const {\n  if (LocalRMWSites.empty()\
  \ || RemoteWriteSites.empty())\n    return;\n\n  // For each field that has a local\
  \ non-atomic RMW and also has a remote write,\n  // report the local RMW sites and\
  \ add a note pointing to one remote write.\n  for (const auto &LR : LocalRMWSites)\
  \ {\n    const std::string &Key = LR.first;\n    auto RWIt = RemoteWriteSites.find(Key);\n\
  \    if (RWIt == RemoteWriteSites.end())\n      continue;\n\n    const SiteList\
  \ &LocalSites = LR.second;\n    const SiteList &RemoteSites = RWIt->second;\n  \
  \  if (RemoteSites.empty())\n      continue;\n\n    // Representative remote location\
  \ for note.\n    const Stmt *RemoteS = RemoteSites.front();\n    PathDiagnosticLocation\
  \ RemoteLoc =\n        PathDiagnosticLocation::createBegin(RemoteS, BR.getSourceManager(),\n\
  \                                            Eng.getContext());\n\n    for (const\
  \ Stmt *S : LocalSites) {\n      if (!S)\n        continue;\n      PathDiagnosticLocation\
  \ Loc =\n          PathDiagnosticLocation::createBegin(S, BR.getSourceManager(),\n\
  \                                              Eng.getContext());\n\n      auto\
  \ R = std::make_unique<BasicBugReport>(\n          *BT,\n          \"Non-atomic\
  \ RMW on per-CPU field raced with remote write; wrap with READ_ONCE/WRITE_ONCE.\"\
  ,\n          Loc);\n      R->addRange(S->getSourceRange());\n      R->addNote(\"\
  Remote write occurs here\", RemoteLoc);\n      BR.emitReport(std::move(R));\n  \
  \  }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect non-atomic per-CPU RMW raced with remote per_cpu_ptr write; suggest\
  \ READ_ONCE/WRITE_ONCE.\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nmemcg: fix data-race KCSAN bug in rstats\n\nA data-race\
  \ issue in memcg rstat occurs when two distinct code paths\naccess the same 4-byte\
  \ region concurrently.  KCSAN detection triggers the\nfollowing BUG as a result.\n\
  \n\tBUG: KCSAN: data-race in __count_memcg_events / mem_cgroup_css_rstat_flush\n\
  \n\twrite to 0xffffe8ffff98e300 of 4 bytes by task 5274 on cpu 17:\n\tmem_cgroup_css_rstat_flush\
  \ (mm/memcontrol.c:5850)\n\tcgroup_rstat_flush_locked (kernel/cgroup/rstat.c:243\
  \ (discriminator 7))\n\tcgroup_rstat_flush (./include/linux/spinlock.h:401 kernel/cgroup/rstat.c:278)\n\
  \tmem_cgroup_flush_stats.part.0 (mm/memcontrol.c:767)\n\tmemory_numa_stat_show (mm/memcontrol.c:6911)\n\
  <snip>\n\n\tread to 0xffffe8ffff98e300 of 4 bytes by task 410848 on cpu 27:\n\t\
  __count_memcg_events (mm/memcontrol.c:725 mm/memcontrol.c:962)\n\tcount_memcg_event_mm.part.0\
  \ (./include/linux/memcontrol.h:1097 ./include/linux/memcontrol.h:1120)\n\thandle_mm_fault\
  \ (mm/memory.c:5483 mm/memory.c:5622)\n<snip>\n\n\tvalue changed: 0x00000029 ->\
  \ 0x00000000\n\nThe race occurs because two code paths access the same \"stats_updates\"\
  \nlocation.  Although \"stats_updates\" is a per-CPU variable, it is remotely\n\
  accessed by another CPU at\ncgroup_rstat_flush_locked()->mem_cgroup_css_rstat_flush(),\
  \ leading to the\ndata race mentioned.\n\nConsidering that memcg_rstat_updated()\
  \ is in the hot code path, adding a\nlock to protect it may not be desirable, especially\
  \ since this variable\npertains solely to statistics.\n\nTherefore, annotating accesses\
  \ to stats_updates with READ/WRITE_ONCE() can\nprevent KCSAN splats and potential\
  \ partial reads/writes.\n\nLink: https://lkml.kernel.org/r/20240424125940.2410718-1-leitao@debian.org\n\
  Fixes: 9cee7e8ef3e3 (\"mm: memcg: optimize parent iteration in memcg_rstat_updated()\"\
  )\nSigned-off-by: Breno Leitao <leitao@debian.org>\nSuggested-by: Shakeel Butt <shakeel.butt@linux.dev>\n\
  Acked-by: Johannes Weiner <hannes@cmpxchg.org>\nAcked-by: Shakeel Butt <shakeel.butt@linux.dev>\n\
  Reviewed-by: Yosry Ahmed <yosryahmed@google.com>\nCc: Michal Hocko <mhocko@suse.com>\n\
  Cc: Roman Gushchin <roman.gushchin@linux.dev>\nCc: Muchun Song <songmuchun@bytedance.com>\n\
  Signed-off-by: Andrew Morton <akpm@linux-foundation.org>\n\n## Buggy Code\n\n```c\n\
  // Function: memcg_rstat_updated in mm/memcontrol.c\nstatic inline void memcg_rstat_updated(struct\
  \ mem_cgroup *memcg, int val)\n{\n\tstruct memcg_vmstats_percpu *statc;\n\tint cpu\
  \ = smp_processor_id();\n\n\tif (!val)\n\t\treturn;\n\n\tcgroup_rstat_updated(memcg->css.cgroup,\
  \ cpu);\n\tstatc = this_cpu_ptr(memcg->vmstats_percpu);\n\tfor (; statc; statc =\
  \ statc->parent) {\n\t\tstatc->stats_updates += abs(val);\n\t\tif (statc->stats_updates\
  \ < MEMCG_CHARGE_BATCH)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If @memcg is already\
  \ flush-able, increasing stats_updates is\n\t\t * redundant. Avoid the overhead\
  \ of the atomic update.\n\t\t */\n\t\tif (!memcg_vmstats_needs_flush(statc->vmstats))\n\
  \t\t\tatomic64_add(statc->stats_updates,\n\t\t\t\t     &statc->vmstats->stats_updates);\n\
  \t\tstatc->stats_updates = 0;\n\t}\n}\n```\n\n```c\n// Function: mem_cgroup_css_rstat_flush\
  \ in mm/memcontrol.c\nstatic void mem_cgroup_css_rstat_flush(struct cgroup_subsys_state\
  \ *css, int cpu)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\t\
  struct mem_cgroup *parent = parent_mem_cgroup(memcg);\n\tstruct memcg_vmstats_percpu\
  \ *statc;\n\tlong delta, delta_cpu, v;\n\tint i, nid;\n\n\tstatc = per_cpu_ptr(memcg->vmstats_percpu,\
  \ cpu);\n\n\tfor (i = 0; i < MEMCG_NR_STAT; i++) {\n\t\t/*\n\t\t * Collect the aggregated\
  \ propagation counts of groups\n\t\t * below us. We're in a per-cpu loop here and\
  \ this is\n\t\t * a global counter, so the first cycle will get them.\n\t\t */\n\
  \t\tdelta = memcg->vmstats->state_pending[i];\n\t\tif (delta)\n\t\t\tmemcg->vmstats->state_pending[i]\
  \ = 0;\n\n\t\t/* Add CPU changes on this level since the last flush */\n\t\tdelta_cpu\
  \ = 0;\n\t\tv = READ_ONCE(statc->state[i]);\n\t\tif (v != statc->state_prev[i])\
  \ {\n\t\t\tdelta_cpu = v - statc->state_prev[i];\n\t\t\tdelta += delta_cpu;\n\t\t\
  \tstatc->state_prev[i] = v;\n\t\t}\n\n\t\t/* Aggregate counts on this level and\
  \ propagate upwards */\n\t\tif (delta_cpu)\n\t\t\tmemcg->vmstats->state_local[i]\
  \ += delta_cpu;\n\n\t\tif (delta) {\n\t\t\tmemcg->vmstats->state[i] += delta;\n\t\
  \t\tif (parent)\n\t\t\t\tparent->vmstats->state_pending[i] += delta;\n\t\t}\n\t\
  }\n\n\tfor (i = 0; i < NR_MEMCG_EVENTS; i++) {\n\t\tdelta = memcg->vmstats->events_pending[i];\n\
  \t\tif (delta)\n\t\t\tmemcg->vmstats->events_pending[i] = 0;\n\n\t\tdelta_cpu =\
  \ 0;\n\t\tv = READ_ONCE(statc->events[i]);\n\t\tif (v != statc->events_prev[i])\
  \ {\n\t\t\tdelta_cpu = v - statc->events_prev[i];\n\t\t\tdelta += delta_cpu;\n\t\
  \t\tstatc->events_prev[i] = v;\n\t\t}\n\n\t\tif (delta_cpu)\n\t\t\tmemcg->vmstats->events_local[i]\
  \ += delta_cpu;\n\n\t\tif (delta) {\n\t\t\tmemcg->vmstats->events[i] += delta;\n\
  \t\t\tif (parent)\n\t\t\t\tparent->vmstats->events_pending[i] += delta;\n\t\t}\n\
  \t}\n\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tstruct mem_cgroup_per_node *pn\
  \ = memcg->nodeinfo[nid];\n\t\tstruct mem_cgroup_per_node *ppn = NULL;\n\t\tstruct\
  \ lruvec_stats_percpu *lstatc;\n\n\t\tif (parent)\n\t\t\tppn = parent->nodeinfo[nid];\n\
  \n\t\tlstatc = per_cpu_ptr(pn->lruvec_stats_percpu, cpu);\n\n\t\tfor (i = 0; i <\
  \ NR_VM_NODE_STAT_ITEMS; i++) {\n\t\t\tdelta = pn->lruvec_stats.state_pending[i];\n\
  \t\t\tif (delta)\n\t\t\t\tpn->lruvec_stats.state_pending[i] = 0;\n\n\t\t\tdelta_cpu\
  \ = 0;\n\t\t\tv = READ_ONCE(lstatc->state[i]);\n\t\t\tif (v != lstatc->state_prev[i])\
  \ {\n\t\t\t\tdelta_cpu = v - lstatc->state_prev[i];\n\t\t\t\tdelta += delta_cpu;\n\
  \t\t\t\tlstatc->state_prev[i] = v;\n\t\t\t}\n\n\t\t\tif (delta_cpu)\n\t\t\t\tpn->lruvec_stats.state_local[i]\
  \ += delta_cpu;\n\n\t\t\tif (delta) {\n\t\t\t\tpn->lruvec_stats.state[i] += delta;\n\
  \t\t\t\tif (ppn)\n\t\t\t\t\tppn->lruvec_stats.state_pending[i] += delta;\n\t\t\t\
  }\n\t\t}\n\t}\n\tstatc->stats_updates = 0;\n\t/* We are in a per-cpu loop here,\
  \ only do the atomic write once */\n\tif (atomic64_read(&memcg->vmstats->stats_updates))\n\
  \t\tatomic64_set(&memcg->vmstats->stats_updates, 0);\n}\n```\n\n## Bug Fix Patch\n\
  \n```diff\ndiff --git a/mm/memcontrol.c b/mm/memcontrol.c\nindex 9095ab05d47a..a111e0d981ba\
  \ 100644\n--- a/mm/memcontrol.c\n+++ b/mm/memcontrol.c\n@@ -715,6 +715,7 @@ static\
  \ inline void memcg_rstat_updated(struct mem_cgroup *memcg, int val)\n {\n \tstruct\
  \ memcg_vmstats_percpu *statc;\n \tint cpu = smp_processor_id();\n+\tunsigned int\
  \ stats_updates;\n \n \tif (!val)\n \t\treturn;\n@@ -722,8 +723,9 @@ static inline\
  \ void memcg_rstat_updated(struct mem_cgroup *memcg, int val)\n \tcgroup_rstat_updated(memcg->css.cgroup,\
  \ cpu);\n \tstatc = this_cpu_ptr(memcg->vmstats_percpu);\n \tfor (; statc; statc\
  \ = statc->parent) {\n-\t\tstatc->stats_updates += abs(val);\n-\t\tif (statc->stats_updates\
  \ < MEMCG_CHARGE_BATCH)\n+\t\tstats_updates = READ_ONCE(statc->stats_updates) +\
  \ abs(val);\n+\t\tWRITE_ONCE(statc->stats_updates, stats_updates);\n+\t\tif (stats_updates\
  \ < MEMCG_CHARGE_BATCH)\n \t\t\tcontinue;\n \n \t\t/*\n@@ -731,9 +733,9 @@ static\
  \ inline void memcg_rstat_updated(struct mem_cgroup *memcg, int val)\n \t\t * redundant.\
  \ Avoid the overhead of the atomic update.\n \t\t */\n \t\tif (!memcg_vmstats_needs_flush(statc->vmstats))\n\
  -\t\t\tatomic64_add(statc->stats_updates,\n+\t\t\tatomic64_add(stats_updates,\n\
  \ \t\t\t\t     &statc->vmstats->stats_updates);\n-\t\tstatc->stats_updates = 0;\n\
  +\t\tWRITE_ONCE(statc->stats_updates, 0);\n \t}\n }\n \n@@ -5887,7 +5889,7 @@ static\
  \ void mem_cgroup_css_rstat_flush(struct cgroup_subsys_state *css, int cpu)\n \t\
  \t\t}\n \t\t}\n \t}\n-\tstatc->stats_updates = 0;\n+\tWRITE_ONCE(statc->stats_updates,\
  \ 0);\n \t/* We are in a per-cpu loop here, only do the atomic write once */\n \t\
  if (atomic64_read(&memcg->vmstats->stats_updates))\n \t\tatomic64_set(&memcg->vmstats->stats_updates,\
  \ 0);\n```\n"
pattern: "## Bug Pattern\n\nNon-atomic read/modify/write of a per-CPU field that is\
  \ also accessed from other CPUs (remote percpu access), leading to a data race.\n\
  \nExample pattern:\n- Hot path:\n  statc->stats_updates += abs(val);   // plain\
  \ RMW (implicit read + write)\n- Remote flush path (different CPU):\n  statc->stats_updates\
  \ = 0;           // plain write\n\nBecause the same 4-byte field is updated and\
  \ cleared from different CPUs without locking or atomic/once annotations, accesses\
  \ can be torn or reordered. The fix is to wrap accesses with READ_ONCE()/WRITE_ONCE()\
  \ (and avoid non-atomic RMW) to prevent races/partial reads."
plan: "1) Program state\n- No custom program state is necessary. This checker is best\
  \ implemented as an AST-only analysis within each function and then cross-function\
  \ correlation at the end of the analysis.\n- Use checker data members to accumulate:\n\
  \  - A map FieldKey -> SmallVector<const Stmt*> for local non-atomic RMW sites (LocalRMWSites).\n\
  \  - A map FieldKey -> SmallVector<const Stmt*> for remote plain-write sites (RemoteWriteSites).\n\
  \n2) Callback functions and implementation steps\n- checkASTCodeBody(const Decl\
  \ *D, AnalysisManager &Mgr, BugReporter &BR)\n  Goal: For each function body, detect:\n\
  \    a) Variables that point to percpu objects (this_cpu_ptr or per_cpu_ptr).\n\
  \    b) Non-atomic RMW of fields through this_cpu_ptr-based pointers.\n    c) Plain\
  \ writes to the same fields through per_cpu_ptr-based pointers.\n\n  2.1 Local bookkeeping\
  \ within a function\n  - Define an enum PerCpuKind { Unknown, ThisCPU, RemoteCPU\
  \ }.\n  - Maintain a map VarKind: const VarDecl* -> PerCpuKind.\n  - Maintain simple\
  \ aliasing: on pointer copies, propagate PerCpuKind to the target variable.\n  -\
  \ Helper: FieldKey builder for a MemberExpr on pointer-to-record, returning a stable\
  \ key such as \"<RecordName>.<FieldName>\" (e.g., \"memcg_vmstats_percpu.stats_updates\"\
  ). Use:\n    - ME->getMemberDecl()->getNameAsString() for field name.\n    - For\
  \ the base expression\u2019s type, if it\u2019s pointer to record, use the pointee\
  \ record decl name.\n\n  2.2 Detect percpu pointer acquisition and propagate kinds\n\
  \  - Traverse the function\u2019s body with a DFS or RecursiveASTVisitor.\n  - For\
  \ VarDecl with initializer or BinaryOperator \u201C=\u201D where LHS is a DeclRefExpr\
  \ to a VarDecl V:\n    - If RHS is a CallExpr and callee name is \"this_cpu_ptr\"\
  :\n      - VarKind[V] = ThisCPU.\n    - If RHS is a CallExpr and callee name is\
  \ \"per_cpu_ptr\":\n      - VarKind[V] = RemoteCPU.\n      - No need to special-case\
  \ the second argument; any per_cpu_ptr indicates named-CPU access (possibly remote).\n\
  \    - If RHS is a DeclRefExpr to a VarDecl U and VarKind[U] is known:\n      -\
  \ VarKind[V] = VarKind[U]. (alias propagation)\n  - For BinaryOperator \u201C=\u201D\
  \ where both sides are variables (pointer-to-record):\n    - Apply the same alias\
  \ propagation (VarKind[LHSVar] = VarKind[RHSVar] when RHSVar kind known).\n\n  2.3\
  \ Detect local non-atomic RMW on percpu fields (ThisCPU pointers)\n  - CompoundAssignOperator:\n\
  \    - If LHS is a MemberExpr (ME) and the base of ME is a DeclRefExpr to VarDecl\
  \ V with VarKind[V] == ThisCPU:\n      - This is a non-atomic RMW (+=, -=, |=, &=,\
  \ etc). Build FieldKey for ME and record the statement in LocalRMWSites[FieldKey].\n\
  \  - BinaryOperator \u201C=\u201D:\n    - If LHS is a MemberExpr (ME) whose base\
  \ is V with VarKind[V] == ThisCPU:\n      - Check if RHS reads the same field: the\
  \ RHS contains a MemberExpr referencing the same FieldDecl and same base VarDecl\
  \ V. Use a simple recursive walk over RHS to find a MemberExpr with the same FieldDecl\
  \ and base VarDecl.\n      - If so, this is an explicit RMW pattern \u201Cfield\
  \ = field op value\u201D. Record in LocalRMWSites[FieldKey].\n    - Do not attempt\
  \ to special-case READ_ONCE/WRITE_ONCE here; if they were used, the pattern wouldn\u2019\
  t be a compound assignment nor a direct \u201Cfield = field + \u2026\u201D on the\
  \ plain field.\n\n  2.4 Detect remote plain writes on percpu fields (RemoteCPU pointers)\n\
  \  - BinaryOperator \u201C=\u201D:\n    - If LHS is a MemberExpr (ME) and the base\
  \ of ME is a DeclRefExpr to VarDecl V with VarKind[V] == RemoteCPU:\n      - This\
  \ is a plain write to a percpu field in a remote context. Build FieldKey and record\
  \ the statement in RemoteWriteSites[FieldKey].\n  - Optional: Skip if the assignment\
  \ is an atomic intrinsic or a known macro wrapper call. In practice, when WRITE_ONCE\
  \ is used, this will not appear as a simple binary \u201C=\u201D assignment, so\
  \ no extra filtering is usually required.\n\n  Notes:\n  - You can use ExprHasName(CallExpr,\
  \ \"this_cpu_ptr\", C) and ExprHasName(CallExpr, \"per_cpu_ptr\", C) to match callee\
  \ names when walking the AST.\n  - For matching the same field in \u201Cfield =\
  \ field op ...\u201D, compare:\n    - MemberExpr->getMemberDecl() pointers for equality.\n\
  \    - The DeclRefExpr of the base variable for equality.\n\n- checkEndAnalysis(ExplodedGraph\
  \ &G, BugReporter &BR, ExprEngine &Eng)\n  Goal: Emit reports only when both sides\
  \ of the race pattern are present.\n\n  Steps:\n  - For each FieldKey that appears\
  \ in LocalRMWSites and also appears in RemoteWriteSites:\n    - For each Stmt* S\
  \ in LocalRMWSites[FieldKey], emit a report:\n      - Message: \"Non-atomic RMW\
  \ on per-CPU field also written from remote CPU; use READ_ONCE/WRITE_ONCE.\"\n \
  \     - Use BasicBugReport with a custom BugType owned by the checker.\n      -\
  \ Attach S as the primary location.\n      - Optionally add an extra note on one\
  \ of the RemoteWriteSites[FieldKey] statements: \"Remote write occurs here.\"\n\n\
  3) Heuristics and filters to reduce false positives\n- Only consider MemberExpr\
  \ through pointer-to-record where the pointer VarDecl was identified as ThisCPU\
  \ (from this_cpu_ptr) for RMW detection and RemoteCPU (from per_cpu_ptr) for remote\
  \ writes.\n- Do not report if only LocalRMWSites or only RemoteWriteSites exist\
  \ for a given field; require the intersection to be non-empty to approximate \u201C\
  also accessed from other CPUs\u201D.\n- Ignore cases where the left-hand side write\
  \ is clearly done through atomic APIs (e.g., calls like atomic_add/atomic64_add,\
  \ or macros that won\u2019t appear as plain assignments).\n- Because READ_ONCE/WRITE_ONCE\
  \ usage does not yield plain compound assignments or plain \u201C= field + ...\u201D\
  \ on the raw field in the AST, those safe cases naturally do not match.\n\n4) Reporting\n\
  - Use a single BugType: \"Per-CPU non-atomic RMW race\".\n- Emit one BasicBugReport\
  \ per unique RMW site in the intersection.\n- Keep the message short:\n  - \"Non-atomic\
  \ RMW on per-CPU field raced with remote write; wrap with READ_ONCE/WRITE_ONCE.\"\
  \n- Provide a secondary note at a representative remote write site when available\
  \ to help users locate the other side of the race.\n\n5) Utility functions used\n\
  - ExprHasName(...) for identifying calls to this_cpu_ptr and per_cpu_ptr.\n- findSpecificTypeInChildren(...)\
  \ can be used to search a MemberExpr inside RHS when checking \u201Cfield = field\
  \ + ...\u201D.\n- findSpecificTypeInParents(...) can be used to find the closest\
  \ enclosing Stmt if needed for precise report locations."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"\
  clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include\
  \ <map>\n#include <string>\n#include <utility>\n#include <memory>\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ state is necessary for this checker.\n\nnamespace {\n\nenum class PerCpuKind {\
  \ Unknown, ThisCPU, RemoteCPU };\n\nclass SAGenTestChecker\n    : public Checker<check::ASTCodeBody,\
  \ check::EndAnalysis> {\n\n  mutable std::unique_ptr<BugType> BT;\n\n  // Key: \"\
  <RecordName>.<FieldName>\"\n  using SiteList = llvm::SmallVector<const Stmt *, 4>;\n\
  \  std::map<std::string, SiteList> LocalRMWSites;     // from this_cpu_ptr\n  std::map<std::string,\
  \ SiteList> RemoteWriteSites;  // from per_cpu_ptr\n\npublic:\n  SAGenTestChecker()\n\
  \      : BT(new BugType(this, \"Per-CPU non-atomic RMW race\", \"Concurrency\"))\
  \ {}\n\n  void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr,\n         \
  \               BugReporter &BR) const;\n\n  void checkEndAnalysis(ExplodedGraph\
  \ &G, BugReporter &BR,\n                        ExprEngine &Eng) const;\n\nprivate:\n\
  \  // Utilities used by the AST traversal.\n  static const VarDecl *getReferencedVar(const\
  \ Expr *E) {\n    if (!E)\n      return nullptr;\n    E = E->IgnoreParenCasts();\n\
  \    if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {\n      return dyn_cast<VarDecl>(DRE->getDecl());\n\
  \    }\n    return nullptr;\n  }\n\n  static const MemberExpr *asMemberExpr(const\
  \ Expr *E) {\n    if (!E)\n      return nullptr;\n    return dyn_cast<MemberExpr>(E->IgnoreParenCasts());\n\
  \  }\n\n  static const FieldDecl *getFieldFromMemberExpr(const MemberExpr *ME) {\n\
  \    if (!ME)\n      return nullptr;\n    return dyn_cast<FieldDecl>(ME->getMemberDecl());\n\
  \  }\n\n  static const VarDecl *getBaseVarFromMemberExpr(const MemberExpr *ME) {\n\
  \    if (!ME)\n      return nullptr;\n    const Expr *Base = ME->getBase()->IgnoreParenCasts();\n\
  \    return getReferencedVar(Base);\n  }\n\n  static std::string buildFieldKey(const\
  \ MemberExpr *ME) {\n    if (!ME)\n      return std::string();\n    const FieldDecl\
  \ *FD = getFieldFromMemberExpr(ME);\n    if (!FD)\n      return std::string();\n\
  \n    // Get record name from the base type's pointee (for ->) or directly (for\
  \ .)\n    QualType BaseQT;\n    const Expr *Base = ME->getBase()->IgnoreParenCasts();\n\
  \    if (ME->isArrow())\n      BaseQT = Base->getType()->getPointeeType();\n   \
  \ else\n      BaseQT = Base->getType();\n\n    if (BaseQT.isNull())\n      return\
  \ FD->getNameAsString(); // fallback\n\n    const RecordType *RT = BaseQT->getAs<RecordType>();\n\
  \    std::string RecName;\n    if (RT && RT->getDecl())\n      RecName = RT->getDecl()->getNameAsString();\n\
  \n    if (RecName.empty())\n      return FD->getNameAsString();\n\n    return RecName\
  \ + \".\" + FD->getNameAsString();\n  }\n\n  static bool isCallNamed(const Expr\
  \ *E, StringRef Name) {\n    if (!E)\n      return false;\n    const auto *CE =\
  \ dyn_cast<CallExpr>(E->IgnoreParenCasts());\n    if (!CE)\n      return false;\n\
  \    if (const FunctionDecl *FD = CE->getDirectCallee()) {\n      return FD->getName()\
  \ == Name;\n    }\n    // Fallback: try if callee expression is a DeclRefExpr\n\
  \    const Expr *Callee = CE->getCallee()->IgnoreParenCasts();\n    if (const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(Callee)) {\n      if (const auto *FD2 = dyn_cast<FunctionDecl>(DRE->getDecl()))\n\
  \        return FD2->getName() == Name;\n    }\n    return false;\n    }\n\n  static\
  \ bool rhsReadsSameField(const Expr *RHS, const VarDecl *BaseVar,\n            \
  \                    const FieldDecl *Field) {\n    if (!RHS || !BaseVar || !Field)\n\
  \      return false;\n\n    // Recursive search in RHS for a MemberExpr that refers\
  \ to the same\n    // base VarDecl and same FieldDecl.\n    struct LocalVisitor\
  \ : public RecursiveASTVisitor<LocalVisitor> {\n      const VarDecl *BaseVar;\n\
  \      const FieldDecl *Field;\n      bool Found = false;\n\n      explicit LocalVisitor(const\
  \ VarDecl *BV, const FieldDecl *F)\n          : BaseVar(BV), Field(F) {}\n\n   \
  \   bool VisitMemberExpr(MemberExpr *ME) {\n        if (Found)\n          return\
  \ true;\n        const FieldDecl *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());\n\
  \        if (!FD)\n          return true;\n        if (FD != Field)\n          return\
  \ true;\n        const VarDecl *BV = nullptr;\n        const Expr *Base = ME->getBase();\n\
  \        if (Base)\n          BV = SAGenTestChecker::getReferencedVar(Base);\n \
  \       if (BV == BaseVar) {\n          Found = true;\n        }\n        return\
  \ true;\n      }\n    };\n\n    LocalVisitor V(BaseVar, Field);\n    V.TraverseStmt(const_cast<Expr\
  \ *>(RHS));\n    return V.Found;\n  }\n\n  // Visitor for a single function body.\n\
  \  class FuncVisitor : public RecursiveASTVisitor<FuncVisitor> {\n    ASTContext\
  \ &Ctx;\n    // Local per-function mapping from variables to percpu kind.\n    llvm::DenseMap<const\
  \ VarDecl *, PerCpuKind> VarKinds;\n\n    // References to the checker's global\
  \ site maps.\n    std::map<std::string, SiteList> &LocalRMWSites;\n    std::map<std::string,\
  \ SiteList> &RemoteWriteSites;\n\n  public:\n    FuncVisitor(ASTContext &Ctx,\n\
  \                std::map<std::string, SiteList> &LocalRMW,\n                std::map<std::string,\
  \ SiteList> &RemoteWrites)\n        : Ctx(Ctx), LocalRMWSites(LocalRMW), RemoteWriteSites(RemoteWrites)\
  \ {}\n\n    bool VisitVarDecl(VarDecl *VD) {\n      if (!VD || !VD->hasInit())\n\
  \        return true;\n      const Expr *Init = VD->getInit();\n      handleInitOrAssignmentToVar(VD,\
  \ Init);\n      return true;\n    }\n\n    bool VisitBinaryOperator(BinaryOperator\
  \ *BO) {\n      if (!BO)\n        return true;\n      if (BO->getOpcode() == BO_Assign)\
  \ {\n        const Expr *LHS = BO->getLHS();\n        const Expr *RHS = BO->getRHS();\n\
  \n        // Alias propagation: LHS is a variable, RHS is variable or call\n   \
  \     if (const VarDecl *LHSVar = SAGenTestChecker::getReferencedVar(LHS)) {\n \
  \         handleInitOrAssignmentToVar(LHSVar, RHS);\n        }\n\n        // Remote\
  \ write detection: LHS member through RemoteCPU pointer var\n        if (const MemberExpr\
  \ *ME = SAGenTestChecker::asMemberExpr(LHS)) {\n          const VarDecl *BaseVar\
  \ = SAGenTestChecker::getBaseVarFromMemberExpr(ME);\n          if (BaseVar) {\n\
  \            auto It = VarKinds.find(BaseVar);\n            if (It != VarKinds.end()\
  \ && It->second == PerCpuKind::RemoteCPU) {\n              std::string Key = SAGenTestChecker::buildFieldKey(ME);\n\
  \              if (!Key.empty())\n                RemoteWriteSites[Key].push_back(BO);\n\
  \            }\n          }\n        }\n\n        // Local explicit RMW: LHS is\
  \ member via ThisCPU var and RHS reads same field\n        if (const MemberExpr\
  \ *ME = SAGenTestChecker::asMemberExpr(LHS)) {\n          const VarDecl *BaseVar\
  \ = SAGenTestChecker::getBaseVarFromMemberExpr(ME);\n          const FieldDecl *Field\
  \ = SAGenTestChecker::getFieldFromMemberExpr(ME);\n          if (BaseVar && Field)\
  \ {\n            auto It = VarKinds.find(BaseVar);\n            if (It != VarKinds.end()\
  \ && It->second == PerCpuKind::ThisCPU) {\n              if (SAGenTestChecker::rhsReadsSameField(RHS,\
  \ BaseVar, Field)) {\n                std::string Key = SAGenTestChecker::buildFieldKey(ME);\n\
  \                if (!Key.empty())\n                  LocalRMWSites[Key].push_back(BO);\n\
  \              }\n            }\n          }\n        }\n      }\n      return true;\n\
  \    }\n\n    bool VisitCompoundAssignOperator(CompoundAssignOperator *CAO) {\n\
  \      if (!CAO)\n        return true;\n      const Expr *LHS = CAO->getLHS();\n\
  \      if (const MemberExpr *ME = SAGenTestChecker::asMemberExpr(LHS)) {\n     \
  \   const VarDecl *BaseVar = SAGenTestChecker::getBaseVarFromMemberExpr(ME);\n \
  \       if (BaseVar) {\n          auto It = VarKinds.find(BaseVar);\n          if\
  \ (It != VarKinds.end() && It->second == PerCpuKind::ThisCPU) {\n            std::string\
  \ Key = SAGenTestChecker::buildFieldKey(ME);\n            if (!Key.empty())\n  \
  \            LocalRMWSites[Key].push_back(CAO);\n          }\n        }\n      }\n\
  \      return true;\n    }\n\n  private:\n    void handleInitOrAssignmentToVar(const\
  \ VarDecl *TargetVD, const Expr *RHS) {\n      if (!TargetVD || !RHS)\n        return;\n\
  \n      // If RHS is a call to this_cpu_ptr/per_cpu_ptr\n      if (isCallNamed(RHS,\
  \ \"this_cpu_ptr\")) {\n        VarKinds[TargetVD] = PerCpuKind::ThisCPU;\n    \
  \    return;\n      }\n      if (isCallNamed(RHS, \"per_cpu_ptr\")) {\n        VarKinds[TargetVD]\
  \ = PerCpuKind::RemoteCPU;\n        return;\n      }\n\n      // Alias propagation\
  \ if RHS references another variable\n      if (const VarDecl *RHSVar = SAGenTestChecker::getReferencedVar(RHS))\
  \ {\n        auto It = VarKinds.find(RHSVar);\n        if (It != VarKinds.end()\
  \ && It->second != PerCpuKind::Unknown) {\n          VarKinds[TargetVD] = It->second;\n\
  \        }\n      }\n    }\n  };\n};\n\nvoid SAGenTestChecker::checkASTCodeBody(const\
  \ Decl *D, AnalysisManager &Mgr,\n                                        BugReporter\
  \ &BR) const {\n  if (!D)\n    return;\n  const Stmt *Body = D->getBody();\n  if\
  \ (!Body)\n    return;\n\n  // Perform a per-function AST traversal and collect\
  \ sites into the\n  // checker-level maps (LocalRMWSites and RemoteWriteSites).\n\
  \  ASTContext &Ctx = Mgr.getASTContext();\n  FuncVisitor V(Ctx,\n              \
  \  const_cast<std::map<std::string, SiteList> &>(LocalRMWSites),\n             \
  \   const_cast<std::map<std::string, SiteList> &>(RemoteWriteSites));\n  V.TraverseStmt(const_cast<Stmt\
  \ *>(Body));\n}\n\nvoid SAGenTestChecker::checkEndAnalysis(ExplodedGraph &G, BugReporter\
  \ &BR,\n                                        ExprEngine &Eng) const {\n  if (LocalRMWSites.empty()\
  \ || RemoteWriteSites.empty())\n    return;\n\n  // For each field that has a local\
  \ non-atomic RMW and also has a remote write,\n  // report the local RMW sites and\
  \ add a note pointing to one remote write.\n  for (const auto &LR : LocalRMWSites)\
  \ {\n    const std::string &Key = LR.first;\n    auto RWIt = RemoteWriteSites.find(Key);\n\
  \    if (RWIt == RemoteWriteSites.end())\n      continue;\n\n    const SiteList\
  \ &LocalSites = LR.second;\n    const SiteList &RemoteSites = RWIt->second;\n  \
  \  if (RemoteSites.empty())\n      continue;\n\n    // Representative remote location\
  \ for note.\n    const Stmt *RemoteS = RemoteSites.front();\n    PathDiagnosticLocation\
  \ RemoteLoc =\n        PathDiagnosticLocation::createBegin(RemoteS, BR.getSourceManager(),\n\
  \                                            nullptr);\n\n    for (const Stmt *S\
  \ : LocalSites) {\n      if (!S)\n        continue;\n      PathDiagnosticLocation\
  \ Loc =\n          PathDiagnosticLocation::createBegin(S, BR.getSourceManager(),\n\
  \                                              nullptr);\n\n      auto R = std::make_unique<BasicBugReport>(\n\
  \          *BT,\n          \"Non-atomic RMW on per-CPU field raced with remote write;\
  \ wrap with READ_ONCE/WRITE_ONCE.\",\n          Loc);\n      R->addRange(S->getSourceRange());\n\
  \      R->addNote(\"Remote write occurs here\", RemoteLoc);\n      BR.emitReport(std::move(R));\n\
  \    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect non-atomic per-CPU RMW raced with remote per_cpu_ptr write; suggest\
  \ READ_ONCE/WRITE_ONCE.\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
