_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 0f8ca019544a252d1afb468ce840c6dcbac73af4
commit_type: Buffer-Overflow
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n\nusing\
  \ namespace clang;\nusing namespace ento;\nusing namespace taint;\n\nnamespace {\n\
  /* The checker callbacks are to be decided. */\nclass SAGenTestChecker : public\
  \ Checker<check::ASTCodeBody> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n\
  \      SAGenTestChecker() : BT(new BugType(this, \"Index/size mismatch\", \"Array\
  \ Bounds\")) {}\n\n      void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr,\
  \ BugReporter &BR) const;\n\n   private:\n\n      // Helpers for loop analysis\n\
  \      static bool evalToInt(ASTContext &Ctx, const Expr *E, llvm::APSInt &Out);\n\
  \      static bool isZeroInitOfVar(const Stmt *InitS, ASTContext &Ctx, const VarDecl\
  \ *&IndVar);\n      static bool isUnitIncrementOfVar(const Stmt *IncS, const VarDecl\
  \ *IndVar);\n      static bool getExclusiveUpperBound(ASTContext &Ctx, const Expr\
  \ *CondE,\n                                         const VarDecl *IndVar, llvm::APSInt\
  \ &Upper);\n      static bool getArraySizeFromBaseExpr(const Expr *BaseE, llvm::APInt\
  \ &ArraySize);\n      static const ValueDecl *getArrayIdentityFromBaseExpr(const\
  \ Expr *BaseE);\n\n      // Collect all ArraySubscriptExpr nodes within a statement\
  \ subtree.\n      class ASECollector : public RecursiveASTVisitor<ASECollector>\
  \ {\n        public:\n          llvm::SmallVector<const ArraySubscriptExpr *, 16>\
  \ ASEs;\n          bool TraverseStmt(Stmt *S) { return RecursiveASTVisitor::TraverseStmt(S);\
  \ }\n          bool VisitArraySubscriptExpr(const ArraySubscriptExpr *ASE) {\n \
  \           ASEs.push_back(ASE);\n            return true;\n          }\n      };\n\
  \n      // Main analysis for a ForStmt\n      void analyzeForStmt(ForStmt *FS, ASTContext\
  \ &Ctx, BugReporter &BR) const;\n};\n\nbool SAGenTestChecker::evalToInt(ASTContext\
  \ &Ctx, const Expr *E, llvm::APSInt &Out) {\n  if (!E) return false;\n  Expr::EvalResult\
  \ ER;\n  if (E->EvaluateAsInt(ER, Ctx)) {\n    Out = ER.Val.getInt();\n    return\
  \ true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isZeroInitOfVar(const\
  \ Stmt *InitS, ASTContext &Ctx, const VarDecl *&IndVar) {\n  IndVar = nullptr;\n\
  \  if (!InitS) return false;\n\n  // Case 1: \"int i = 0;\"\n  if (const auto *DS\
  \ = dyn_cast<DeclStmt>(InitS)) {\n    if (!DS->isSingleDecl()) return false;\n \
  \   const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());\n    if (!VD) return\
  \ false;\n    if (!VD->getType()->isIntegerType()) return false;\n    const Expr\
  \ *Init = VD->getInit();\n    if (!Init) return false;\n    llvm::APSInt Val;\n\
  \    if (!evalToInt(Ctx, Init, Val)) return false;\n    if (Val != 0) return false;\n\
  \    IndVar = VD;\n    return true;\n  }\n\n  // Case 2: \"i = 0;\"\n  if (const\
  \ auto *BO = dyn_cast<BinaryOperator>(InitS)) {\n    if (BO->getOpcode() != BO_Assign)\
  \ return false;\n    const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  \
  \  const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n    const auto *DRE =\
  \ dyn_cast<DeclRefExpr>(LHS);\n    if (!DRE) return false;\n    const auto *VD =\
  \ dyn_cast<VarDecl>(DRE->getDecl());\n    if (!VD || !VD->getType()->isIntegerType())\
  \ return false;\n    llvm::APSInt Val;\n    if (!evalToInt(Ctx, RHS, Val)) return\
  \ false;\n    if (Val != 0) return false;\n    IndVar = VD;\n    return true;\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isUnitIncrementOfVar(const\
  \ Stmt *IncS, const VarDecl *IndVar) {\n  if (!IncS || !IndVar) return false;\n\n\
  \  // ++i or i++\n  if (const auto *UO = dyn_cast<UnaryOperator>(IncS)) {\n    if\
  \ (UO->getOpcode() == UO_PreInc || UO->getOpcode() == UO_PostInc) {\n      const\
  \ Expr *Sub = UO->getSubExpr()->IgnoreParenImpCasts();\n      if (const auto *DRE\
  \ = dyn_cast<DeclRefExpr>(Sub)) {\n        if (DRE->getDecl() == IndVar)\n     \
  \     return true;\n      }\n    }\n    return false;\n  }\n\n  // i += 1\n  if\
  \ (const auto *CAO = dyn_cast<CompoundAssignOperator>(IncS)) {\n    if (CAO->getOpcode()\
  \ == BO_AddAssign) {\n      const Expr *LHS = CAO->getLHS()->IgnoreParenImpCasts();\n\
  \      const Expr *RHS = CAO->getRHS()->IgnoreParenImpCasts();\n      const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(LHS);\n      if (!DRE || DRE->getDecl() != IndVar)\n\
  \        return false;\n      llvm::APSInt Val;\n      if (!evalToInt(IndVar->getASTContext(),\
  \ RHS, Val))\n        return false;\n      return Val == 1;\n    }\n    return false;\n\
  \  }\n\n  // i = i + 1 or i = 1 + i (optional)\n  if (const auto *BO = dyn_cast<BinaryOperator>(IncS))\
  \ {\n    if (BO->getOpcode() != BO_Assign)\n      return false;\n    const Expr\
  \ *LHS = BO->getLHS()->IgnoreParenImpCasts();\n    const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \    const auto *LHSVar = dyn_cast<DeclRefExpr>(LHS);\n    if (!LHSVar || LHSVar->getDecl()\
  \ != IndVar)\n      return false;\n    if (const auto *Add = dyn_cast<BinaryOperator>(RHS))\
  \ {\n      if (Add->getOpcode() != BO_Add)\n        return false;\n      const Expr\
  \ *A = Add->getLHS()->IgnoreParenImpCasts();\n      const Expr *B = Add->getRHS()->IgnoreParenImpCasts();\n\
  \      llvm::APSInt Val;\n      if (const auto *AR = dyn_cast<DeclRefExpr>(A)) {\n\
  \        if (AR->getDecl() == IndVar && evalToInt(IndVar->getASTContext(), B, Val)\
  \ && Val == 1)\n          return true;\n      }\n      if (const auto *BR = dyn_cast<DeclRefExpr>(B))\
  \ {\n        if (BR->getDecl() == IndVar && evalToInt(IndVar->getASTContext(), A,\
  \ Val) && Val == 1)\n          return true;\n      }\n    }\n    return false;\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::getExclusiveUpperBound(ASTContext\
  \ &Ctx, const Expr *CondE,\n                                              const\
  \ VarDecl *IndVar, llvm::APSInt &Upper) {\n  if (!CondE || !IndVar) return false;\n\
  \n  const auto *BO = dyn_cast<BinaryOperator>(CondE->IgnoreParenImpCasts());\n \
  \ if (!BO) return false;\n\n  BinaryOperator::Opcode Op = BO->getOpcode();\n  const\
  \ Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \n  const DeclRefExpr *LHSVar = dyn_cast<DeclRefExpr>(LHS);\n  const DeclRefExpr\
  \ *RHSVar = dyn_cast<DeclRefExpr>(RHS);\n\n  llvm::APSInt Bound;\n\n  // i < Bound\
  \ or i <= Bound\n  if (LHSVar && LHSVar->getDecl() == IndVar &&\n      (Op == BO_LT\
  \ || Op == BO_LE)) {\n    if (!evalToInt(Ctx, RHS, Bound)) return false;\n    if\
  \ (Op == BO_LT) {\n      Upper = Bound;\n      return true;\n    } else {\n    \
  \  // Upper = Bound + 1\n      llvm::APSInt One(llvm::APInt(Bound.getBitWidth(),\
  \ 1), Bound.isUnsigned());\n      Upper = Bound + One;\n      return true;\n   \
  \ }\n  }\n\n  // Bound > i or Bound >= i\n  if (RHSVar && RHSVar->getDecl() == IndVar\
  \ &&\n      (Op == BO_GT || Op == BO_GE)) {\n    if (!evalToInt(Ctx, LHS, Bound))\
  \ return false;\n    if (Op == BO_GT) {\n      Upper = Bound;\n      return true;\n\
  \    } else {\n      // Upper = Bound + 1\n      llvm::APSInt One(llvm::APInt(Bound.getBitWidth(),\
  \ 1), Bound.isUnsigned());\n      Upper = Bound + One;\n      return true;\n   \
  \ }\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::getArraySizeFromBaseExpr(const\
  \ Expr *BaseE, llvm::APInt &ArraySize) {\n  if (!BaseE) return false;\n  BaseE =\
  \ BaseE->IgnoreParenImpCasts();\n\n  // Case 1: DeclRefExpr to an array variable\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(BaseE)) {\n    if (const auto *VD\
  \ = dyn_cast<VarDecl>(DRE->getDecl())) {\n      QualType QT = VD->getType();\n \
  \     if (const auto *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr())) {\n  \
  \      ArraySize = CAT->getSize();\n        return true;\n      }\n    }\n  }\n\n\
  \  // Case 2: MemberExpr to a field with array type\n  if (const auto *ME = dyn_cast<MemberExpr>(BaseE))\
  \ {\n    const ValueDecl *VD = ME->getMemberDecl();\n    if (const auto *FD = dyn_cast<FieldDecl>(VD))\
  \ {\n      QualType FT = FD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(FT.getTypePtr()))\
  \ {\n        ArraySize = CAT->getSize();\n        return true;\n      }\n    }\n\
  \  }\n\n  return false;\n}\n\nconst ValueDecl *SAGenTestChecker::getArrayIdentityFromBaseExpr(const\
  \ Expr *BaseE) {\n  if (!BaseE) return nullptr;\n  BaseE = BaseE->IgnoreParenImpCasts();\n\
  \n  if (const auto *DRE = dyn_cast<DeclRefExpr>(BaseE)) {\n    return DRE->getDecl();\n\
  \  }\n  if (const auto *ME = dyn_cast<MemberExpr>(BaseE)) {\n    return ME->getMemberDecl();\n\
  \  }\n  return nullptr;\n}\n\nvoid SAGenTestChecker::analyzeForStmt(ForStmt *FS,\
  \ ASTContext &Ctx, BugReporter &BR) const {\n  if (!FS) return;\n\n  // 1) Init:\
  \ find induction var and ensure initialized to 0\n  const VarDecl *IndVar = nullptr;\n\
  \  if (!isZeroInitOfVar(FS->getInit(), Ctx, IndVar))\n    return;\n\n  // 2) Cond:\
  \ convert to exclusive Upper bound\n  llvm::APSInt Upper;\n  if (!getExclusiveUpperBound(Ctx,\
  \ FS->getCond(), IndVar, Upper))\n    return;\n\n  // 3) Inc: ensure unit increment\n\
  \  if (!isUnitIncrementOfVar(FS->getInc(), IndVar))\n    return;\n\n  // 4) Collect\
  \ ASEs in body\n  ASECollector Collector;\n  Collector.TraverseStmt(const_cast<Stmt\
  \ *>(FS->getBody()));\n  if (Collector.ASEs.empty())\n    return;\n\n  // Deduplicate\
  \ reports per (loop, array identity)\n  llvm::SmallPtrSet<const ValueDecl *, 8>\
  \ Reported;\n\n  for (const auto *ASE : Collector.ASEs) {\n    if (!ASE) continue;\n\
  \    const Expr *Idx = ASE->getIdx()->IgnoreParenImpCasts();\n    const auto *IdxDRE\
  \ = dyn_cast<DeclRefExpr>(Idx);\n    if (!IdxDRE || IdxDRE->getDecl() != IndVar)\n\
  \      continue;\n\n    // Resolve array size\n    llvm::APInt ArrSize;\n    const\
  \ Expr *BaseE = ASE->getBase();\n    if (!getArraySizeFromBaseExpr(BaseE, ArrSize))\n\
  \      continue;\n\n    const ValueDecl *Identity = getArrayIdentityFromBaseExpr(BaseE);\n\
  \    if (!Identity)\n      continue;\n\n    if (Reported.contains(Identity))\n \
  \     continue;\n\n    // Compare Upper vs. ArrSize\n    // Convert ArrSize to APSInt\
  \ with the same signedness/bitwidth as Upper\n    llvm::APSInt ArrSizeAPS(ArrSize,\
  \ Upper.isUnsigned());\n\n    // The loop runs i in [0, Upper). For safe indexing,\
  \ we need Upper <= ArrSize.\n    if (Upper > ArrSizeAPS) {\n      // Report\n  \
  \    auto R = std::make_unique<BasicBugReport>(\n          *BT, \"Index may exceed\
  \ array bound\", ASE->getBeginLoc());\n      R->addRange(ASE->getSourceRange());\n\
  \      BR.emitReport(std::move(R));\n      Reported.insert(Identity);\n    }\n \
  \ }\n}\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const {\n  if (!D) return;\n  const auto *FD = dyn_cast<FunctionDecl>(D);\n\
  \  if (!FD) return;\n  const Stmt *Body = FD->getBody();\n  if (!Body) return;\n\
  \n  // Traverse the function body to find ForStmt nodes\n  class BodyVisitor : public\
  \ RecursiveASTVisitor<BodyVisitor> {\n    const SAGenTestChecker &Checker;\n   \
  \ ASTContext &Ctx;\n    BugReporter &BR;\n   public:\n    BodyVisitor(const SAGenTestChecker\
  \ &C, ASTContext &A, BugReporter &B)\n      : Checker(C), Ctx(A), BR(B) {}\n\n \
  \   bool VisitForStmt(ForStmt *FS) {\n      Checker.analyzeForStmt(FS, Ctx, BR);\n\
  \      return true;\n    }\n  };\n\n  BodyVisitor V(*this, Mgr.getASTContext(),\
  \ BR);\n  V.TraverseStmt(const_cast<Stmt *>(Body));\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect index/size mismatch across arrays\
  \ when using a loop bound larger than the array\",\n      \"\");\n}\n\nextern \"\
  C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Prevent potential buffer overflow\
  \ in map_hw_resources\n\nAdds a check in the map_hw_resources function to prevent\
  \ a potential\nbuffer overflow. The function was accessing arrays using an index\
  \ that\ncould potentially be greater than the size of the arrays, leading to a\n\
  buffer overflow.\n\nAdds a check to ensure that the index is within the bounds of\
  \ the\narrays. If the index is out of bounds, an error message is printed and\n\
  break it will continue execution with just ignoring extra data early to\nprevent\
  \ the buffer overflow.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dml2/dml2_wrapper.c:79\
  \ map_hw_resources() error: buffer overflow 'dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_stream_id'\
  \ 6 <= 7\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dml2/dml2_wrapper.c:81 map_hw_resources()\
  \ error: buffer overflow 'dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_plane_id'\
  \ 6 <= 7\n\nFixes: 7966f319c66d (\"drm/amd/display: Introduce DML2\")\nCc: Rodrigo\
  \ Siqueira <Rodrigo.Siqueira@amd.com>\nCc: Roman Li <roman.li@amd.com>\nCc: Qingqing\
  \ Zhuo <Qingqing.Zhuo@amd.com>\nCc: Aurabindo Pillai <aurabindo.pillai@amd.com>\n\
  Cc: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Srinivasan Shanmugam <srinivasan.shanmugam@amd.com>\n\
  Suggested-by: Roman Li <roman.li@amd.com>\nReviewed-by: Roman Li <roman.li@amd.com>\n\
  Reviewed-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>\nSigned-off-by: Alex Deucher\
  \ <alexander.deucher@amd.com>\n\n## Buggy Code\n\n```c\n// Function: map_hw_resources\
  \ in drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c\nstatic void map_hw_resources(struct\
  \ dml2_context *dml2,\n\t\tstruct dml_display_cfg_st *in_out_display_cfg, struct\
  \ dml_mode_support_info_st *mode_support_info)\n{\n\tunsigned int num_pipes = 0;\n\
  \tint i, j;\n\n\tfor (i = 0; i < __DML_NUM_PLANES__; i++) {\n\t\tin_out_display_cfg->hw.ODMMode[i]\
  \ = mode_support_info->ODMMode[i];\n\t\tin_out_display_cfg->hw.DPPPerSurface[i]\
  \ = mode_support_info->DPPPerSurface[i];\n\t\tin_out_display_cfg->hw.DSCEnabled[i]\
  \ = mode_support_info->DSCEnabled[i];\n\t\tin_out_display_cfg->hw.NumberOfDSCSlices[i]\
  \ = mode_support_info->NumberOfDSCSlices[i];\n\t\tin_out_display_cfg->hw.DLGRefClkFreqMHz\
  \ = 24;\n\t\tif (dml2->v20.dml_core_ctx.project != dml_project_dcn35 &&\n\t\t\t\
  dml2->v20.dml_core_ctx.project != dml_project_dcn351) {\n\t\t\t/*dGPU default as\
  \ 50Mhz*/\n\t\t\tin_out_display_cfg->hw.DLGRefClkFreqMHz = 50;\n\t\t}\n\t\tfor (j\
  \ = 0; j < mode_support_info->DPPPerSurface[i]; j++) {\n\t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_stream_id[num_pipes]\
  \ = dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_stream_id[i];\n\t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_stream_id_valid[num_pipes]\
  \ = true;\n\t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_plane_id[num_pipes]\
  \ = dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_plane_id[i];\n\t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_plane_id_valid[num_pipes]\
  \ = true;\n\t\t\tnum_pipes++;\n\t\t}\n\t}\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c\n\
  index 26307e599614..2a58a7687bdb 100644\n--- a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c\n\
  +++ b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c\n@@ -76,6 +76,11 @@ static\
  \ void map_hw_resources(struct dml2_context *dml2,\n \t\t\tin_out_display_cfg->hw.DLGRefClkFreqMHz\
  \ = 50;\n \t\t}\n \t\tfor (j = 0; j < mode_support_info->DPPPerSurface[i]; j++)\
  \ {\n+\t\t\tif (i >= __DML2_WRAPPER_MAX_STREAMS_PLANES__) {\n+\t\t\t\tdml_print(\"\
  DML::%s: Index out of bounds: i=%d, __DML2_WRAPPER_MAX_STREAMS_PLANES__=%d\\n\"\
  ,\n+\t\t\t\t\t  __func__, i, __DML2_WRAPPER_MAX_STREAMS_PLANES__);\n+\t\t\t\tbreak;\n\
  +\t\t\t}\n \t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_stream_id[num_pipes]\
  \ = dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_stream_id[i];\n \t\t\t\
  dml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_stream_id_valid[num_pipes]\
  \ = true;\n \t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_plane_id[num_pipes]\
  \ = dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_plane_id[i];\n```\n"
pattern: "## Bug Pattern\n\nIndex/size mismatch across different arrays: iterating\
  \ an index i using the bound of one domain (e.g., __DML_NUM_PLANES__) and then using\
  \ that same i to access arrays that are smaller (bounded by __DML2_WRAPPER_MAX_STREAMS_PLANES__)\
  \ without validating i against the smaller bound, causing potential out-of-bounds\
  \ access.\n\nExample:\nfor (i = 0; i < SIZE_A; i++) {         // SIZE_A >= SIZE_B\n\
  \    ... = array_B[i];                  // array_B has SIZE_B elements\n    ...\
  \ = array_C[i];                  // array_C has SIZE_B elements\n}"
plan: "1) Program state\n- No custom program state is needed. This checker is a local\
  \ AST-based pattern detector; we do not track runtime/path-sensitive facts.\n\n\
  2) Callbacks and implementation steps\nUse a single AST-level callback to keep the\
  \ checker simple and robust:\n- checkASTCodeBody(const Decl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR)\n\nInside this callback, perform a lightweight AST traversal\
  \ to find \u201Ccanonical\u201D count-up for-loops and detect index/size mismatches\
  \ on array subscripts that use the induction variable.\n\nStep-by-step details:\n\
  \nA. Traverse function body and find canonical count-up for-loops\n- Walk the body\
  \ of D (e.g., RecursiveASTVisitor or a simple recursive walk over Stmts) and visit\
  \ every ForStmt FS.\n- Extract loop components:\n  - Init:\n    - Accept either:\n\
  \      - DeclStmt with a single VarDecl having integer type and an initializer equal\
  \ to 0 (use EvaluateExprToInt on the initializer and require zero).\n      - Or\
  \ BinaryOperator \u201Ci = 0\u201D where LHS is a DeclRefExpr to an integer VarDecl\
  \ and RHS evaluates to 0.\n    - Record the induction variable VarDecl* IndVar if\
  \ found.\n  - Cond:\n    - Accept the forms:\n      - i < Bound\n      - i <= Bound\n\
  \      - Bound > i\n      - Bound >= i\n    - Normalize to an exclusive upper bound\
  \ Upper (i ranges in [0, Upper)):\n      - i < Bound          => Upper = Bound\n\
  \      - i <= Bound         => Upper = Bound + 1 (handle APSInt width/sign properly)\n\
  \      - Bound > i          => Upper = Bound\n      - Bound >= i         => Upper\
  \ = Bound + 1\n    - Use EvaluateExprToInt to evaluate Bound on the side opposite\
  \ to i.\n    - If you cannot find IndVar in the condition or cannot evaluate a constant\
  \ Upper, skip this FS.\n  - Inc:\n    - Accept \u201Ci++\u201D, \u201C++i\u201D\
  , or \u201Ci += 1\u201D.\n    - If the increment is not a unit step on the same\
  \ IndVar, skip this FS.\n\nB. Collect array subscript uses of the induction variable\
  \ inside the loop body\n- Recursively visit all ArraySubscriptExpr (ASE) nodes within\
  \ FS->getBody().\n- For each ASE:\n  - Check that the index expression uses IndVar\
  \ directly:\n    - Let Idx = ASE->getIdx()->IgnoreParenImpCasts().\n    - Accept\
  \ only if Idx is a DeclRefExpr to IndVar. (Keep it simple; this still covers the\
  \ target pattern in the patch.)\n  - Resolve the array being indexed and its constant\
  \ bound:\n    - Let Base = ASE->getBase()->IgnoreParenImpCasts().\n    - Two common\
  \ cases to support:\n      1) Base is a DeclRefExpr of an actual array variable.\n\
  \         - Use the provided getArraySizeFromExpr to obtain ArraySize (APInt).\n\
  \      2) Base is a MemberExpr referring to a field of array type.\n         - Obtain\
  \ the FieldDecl* FD = dyn_cast<FieldDecl>(MemberExpr->getMemberDecl()).\n      \
  \   - If FD->getType() is a ConstantArrayType, cast it and get size via cast<ConstantArrayType>(...)->getSize().\n\
  \    - If neither yields a ConstantArrayType/constant size, skip this ASE (we cannot\
  \ reason about size).\n  - Compare bounds:\n    - Convert Upper (APSInt) and ArraySize\
  \ (APInt) to a common signedness/bit-width for a safe comparison.\n    - If Upper\
  \ > ArraySize, report a bug at this ASE.\n\nC. Optional false-positive suppression:\
  \ detect a guard inside the loop that bounds i before accesses\n- To avoid warning\
  \ when the body has an early-exit guard like:\n  if (i >= ArraySize) { ...; break;\
  \ }\n- Implement a simple guard check:\n  - For the loop body CompoundStmt, scan\
  \ its immediate children statements.\n  - If you find an IfStmt whose condition\
  \ is a comparison between IndVar and a constant value GuardVal such that the comparison\
  \ is \u201Ci >= GuardVal\u201D (or \u201Ci == GuardVal\u201D) and GuardVal equals\
  \ ArraySize, and the Then branch contains a BreakStmt, then consider the body guarded.\n\
  \  - If guarded is detected, skip reporting for accesses to that same array inside\
  \ this loop.\n- Keep this heuristic simple; do not attempt full path analysis or\
  \ sibling ordering beyond checking presence. If desired, refine by checking source\
  \ order using SourceManager::isBeforeInTranslationUnit to ensure the guard appears\
  \ before the ASE.\n\nD. Reporting\n- Create a checker-local BugType (e.g., std::unique_ptr<BugType>\
  \ BT) with a short name like \u201CIndex/size mismatch\u201D.\n- When detecting\
  \ Upper > ArraySize for an ASE, create a BasicBugReport with a concise message,\
  \ for example:\n  - \u201CIndex may exceed array bound: loop bound N, array size\
  \ M\u201D\n- Attach the source range of the ASE (ASE->getSourceRange()) and emit\
  \ the report via BR.emitReport(...).\n- Optional: deduplicate within one loop to\
  \ avoid repeated reports on the same array:\n  - Keep a local SmallSet of pairs\
  \ (ForStmt*, const ValueDecl*) where ValueDecl is the array variable or FieldDecl;\
  \ only report once per (loop, array).\n\n3) Utility functions usage\n- EvaluateExprToInt:\
  \ to evaluate loop bound and zero init; also to evaluate guard RHS constants.\n\
  - getArraySizeFromExpr: to resolve array size for DeclRefExpr bases.\n- findSpecificTypeInChildren/findSpecificTypeInParents:\
  \ not strictly needed; keep traversal explicit and focused for simplicity.\n- ExprHasName:\
  \ not necessary unless you want to special-case macro names; not needed for core\
  \ detection.\n\n4) Notes and constraints\n- This checker intentionally focuses on\
  \ the simple, common, and high-signal case: direct indexing by the loop induction\
  \ variable with a constant loop bound and constant array bound.\n- It naturally\
  \ detects the provided bug pattern where i iterates using a larger domain constant\
  \ (e.g., __DML_NUM_PLANES__) and indexes arrays of a smaller domain (e.g., __DML2_WRAPPER_MAX_STREAMS_PLANES__)\
  \ without proper validation.\n- Path-sensitive modeling (e.g., tracking that an\
  \ if-condition prevents out-of-bounds) is avoided to keep the implementation minimal;\
  \ the optional simple guard detection is provided to reduce obvious false positives."
refined_plan: null
repaired_checker_code: null
tn_score: -10
tp_score: -10
