_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 51df947678360faf1967fe0bd1a40c681f634104
commit_type: Memory-Leak
index: 4
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state: Track the per-iteration allocation symbol per enclosing loop.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(LoopAllocSymMap, const Stmt*, SymbolRef)\n\nnamespace\
  \ {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n \
  \       check::PreCall,\n        check::BranchCondition\n     > {\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"Per-iteration resource\
  \ leak\", \"Memory Management\")) {}\n\n  void checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  void checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const;\n\nprivate:\n  // Helpers\n  bool isPerIterAllocator(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  bool isPerIterFree(const CallEvent &Call,\
  \ CheckerContext &C) const;\n\n  const Stmt *getEnclosingLoopStmt(const Stmt *S,\
  \ CheckerContext &C) const;\n\n  const GotoStmt *thenBranchHasGotoExit(const IfStmt\
  \ *IfS) const;\n  const CallExpr *thenBranchFirstCallExpr(const IfStmt *IfS) const;\n\
  \n  SymbolRef getExprSymbol(const Expr *E, CheckerContext &C) const;\n\n  void reportLeak(const\
  \ Stmt *LocStmt, CheckerContext &C) const;\n};\n\n// -------------------- Helper\
  \ Implementations --------------------\n\nbool SAGenTestChecker::isPerIterAllocator(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n\n  // Match common net_device allocators\
  \ used per-iteration.\n  if (ExprHasName(OriginExpr, \"alloc_etherdev\", C) ||\n\
  \      ExprHasName(OriginExpr, \"alloc_etherdev_mqs\", C) ||\n      ExprHasName(OriginExpr,\
  \ \"alloc_netdev\", C) ||\n      ExprHasName(OriginExpr, \"alloc_netdev_mqs\", C))\
  \ {\n    return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isPerIterFree(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n  return ExprHasName(OriginExpr, \"free_netdev\"\
  , C);\n}\n\nconst Stmt *SAGenTestChecker::getEnclosingLoopStmt(const Stmt *S, CheckerContext\
  \ &C) const {\n  if (!S)\n    return nullptr;\n\n  if (const ForStmt *FS = findSpecificTypeInParents<ForStmt>(S,\
  \ C))\n    return FS;\n  if (const WhileStmt *WS = findSpecificTypeInParents<WhileStmt>(S,\
  \ C))\n    return WS;\n  if (const DoStmt *DS = findSpecificTypeInParents<DoStmt>(S,\
  \ C))\n    return DS;\n\n  return nullptr;\n}\n\nconst GotoStmt *SAGenTestChecker::thenBranchHasGotoExit(const\
  \ IfStmt *IfS) const {\n  if (!IfS)\n    return nullptr;\n  const Stmt *ThenS =\
  \ IfS->getThen();\n  if (!ThenS)\n    return nullptr;\n\n  const GotoStmt *GS =\
  \ findSpecificTypeInChildren<GotoStmt>(ThenS);\n  if (!GS)\n    return nullptr;\n\
  \n  const LabelDecl *LD = GS->getLabel();\n  if (!LD)\n    return nullptr;\n\n \
  \ if (LD->getName() == \"exit\")\n    return GS;\n\n  return nullptr;\n}\n\nconst\
  \ CallExpr *SAGenTestChecker::thenBranchFirstCallExpr(const IfStmt *IfS) const {\n\
  \  if (!IfS)\n    return nullptr;\n  const Stmt *ThenS = IfS->getThen();\n  if (!ThenS)\n\
  \    return nullptr;\n\n  return findSpecificTypeInChildren<CallExpr>(ThenS);\n\
  }\n\nSymbolRef SAGenTestChecker::getExprSymbol(const Expr *E, CheckerContext &C)\
  \ const {\n  if (!E)\n    return nullptr;\n  ProgramStateRef State = C.getState();\n\
  \  SVal V = State->getSVal(E, C.getLocationContext());\n  return V.getAsSymbol();\n\
  }\n\nvoid SAGenTestChecker::reportLeak(const Stmt *LocStmt, CheckerContext &C) const\
  \ {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Possible leak:\
  \ per-iteration net_device not freed on error path\", N);\n  if (LocStmt)\n    R->addRange(LocStmt->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n// -------------------- Checker Callbacks --------------------\n\
  \nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  if (!isPerIterAllocator(Call, C))\n    return;\n\n  // Track the allocation\
  \ symbol for the current loop iteration.\n  SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\n\
  \  if (!RetSym)\n    return;\n\n  const Expr *Origin = Call.getOriginExpr();\n \
  \ if (!Origin)\n    return;\n\n  const Stmt *LoopS = getEnclosingLoopStmt(Origin,\
  \ C);\n  if (!LoopS)\n    return;\n\n  ProgramStateRef State = C.getState();\n \
  \ State = State->set<LoopAllocSymMap>(LoopS, RetSym);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  if (!isPerIterFree(Call, C))\n    return;\n\n  // If a free is called\
  \ on the same symbol we tracked for this loop, clear it.\n  const Expr *Arg0 = Call.getArgExpr(0);\n\
  \  if (!Arg0)\n    return;\n\n  SymbolRef ArgSym = getExprSymbol(Arg0, C);\n  if\
  \ (!ArgSym)\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  // Iterate\
  \ tracked loop allocations and remove any that match the freed symbol.\n  auto Map\
  \ = State->get<LoopAllocSymMap>();\n  bool Changed = false;\n  for (auto I = Map.begin(),\
  \ E = Map.end(); I != E; ++I) {\n    const Stmt *LoopKey = I->first;\n    SymbolRef\
  \ TrackedSym = I->second;\n    if (TrackedSym == ArgSym) {\n      State = State->remove<LoopAllocSymMap>(LoopKey);\n\
  \      Changed = true;\n    }\n  }\n\n  if (Changed)\n    C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!Condition)\n    return;\n\n  // Find the surrounding if-statement\
  \ for this condition.\n  const IfStmt *IfS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IfS)\n    return;\n\n  // Only care about early-exit branches inside\
  \ a loop.\n  const Stmt *LoopS = getEnclosingLoopStmt(IfS, C);\n  if (!LoopS)\n\
  \    return;\n\n  // Determine if this is a bail-out branch: goto exit; or return;\n\
  \  const GotoStmt *GotoExit = thenBranchHasGotoExit(IfS);\n  bool HasReturn = false;\n\
  \  if (!GotoExit) {\n    // Check for return in the then-branch\n    const Stmt\
  \ *ThenS = IfS->getThen();\n    if (ThenS) {\n      const ReturnStmt *RS = findSpecificTypeInChildren<ReturnStmt>(ThenS);\n\
  \      HasReturn = (RS != nullptr);\n    }\n  }\n\n  if (!GotoExit && !HasReturn)\n\
  \    return; // Not a bail-out path we care about.\n\n  ProgramStateRef State =\
  \ C.getState();\n  const SymbolRef *TrackedSymPtr = State->get<LoopAllocSymMap>(LoopS);\n\
  \  if (!TrackedSymPtr)\n    return; // No current per-iteration allocation tracked.\n\
  \n  SymbolRef TrackedSym = *TrackedSymPtr;\n\n  // Precision guard: if the first\
  \ call in the then-branch is free_netdev on this symbol, do not report.\n  const\
  \ CallExpr *FirstCall = thenBranchFirstCallExpr(IfS);\n  if (FirstCall) {\n    //\
  \ Use ExprHasName on the call itself to match \"free_netdev\"\n    if (ExprHasName(FirstCall,\
  \ \"free_netdev\", C)) {\n      if (FirstCall->getNumArgs() >= 1) {\n        const\
  \ Expr *Arg0 = FirstCall->getArg(0);\n        if (Arg0) {\n          SymbolRef ArgSym\
  \ = getExprSymbol(Arg0, C);\n          if (ArgSym && ArgSym == TrackedSym) {\n \
  \           // Freed properly before bail-out.\n            return;\n          }\n\
  \        }\n      }\n    }\n  }\n\n  // Report potential leak at the bail-out site\
  \ (goto or condition).\n  const Stmt *LocStmt = GotoExit ? static_cast<const Stmt\
  \ *>(GotoExit)\n                                 : static_cast<const Stmt *>(IfS->getCond());\n\
  \  reportLeak(LocStmt, C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects per-iteration resource leaks\
  \ when bailing out of a loop without freeing the current allocation\",\n      \"\
  \");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nocteontx2-pf: fix netdev memory leak in rvu_rep_create()\n\
  \nWhen rvu_rep_devlink_port_register() fails, free_netdev(ndev) for this\nincomplete\
  \ iteration before going to \"exit:\" label.\n\nFixes: 9ed0343f561e (\"octeontx2-pf:\
  \ Add devlink port support\")\nReviewed-by: Przemek Kitszel <przemyslaw.kitszel@intel.com>\n\
  Signed-off-by: Harshit Mogalapalli <harshit.m.mogalapalli@oracle.com>\nLink: https://patch.msgid.link/20241217052326.1086191-1-harshit.m.mogalapalli@oracle.com\n\
  Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ rvu_rep_create in drivers/net/ethernet/marvell/octeontx2/nic/rep.c\nint rvu_rep_create(struct\
  \ otx2_nic *priv, struct netlink_ext_ack *extack)\n{\n\tint rep_cnt = priv->rep_cnt;\n\
  \tstruct net_device *ndev;\n\tstruct rep_dev *rep;\n\tint rep_id, err;\n\tu16 pcifunc;\n\
  \n\terr = rvu_rep_rsrc_init(priv);\n\tif (err)\n\t\treturn -ENOMEM;\n\n\tpriv->reps\
  \ = kcalloc(rep_cnt, sizeof(struct rep_dev *), GFP_KERNEL);\n\tif (!priv->reps)\n\
  \t\treturn -ENOMEM;\n\n\tfor (rep_id = 0; rep_id < rep_cnt; rep_id++) {\n\t\tndev\
  \ = alloc_etherdev(sizeof(*rep));\n\t\tif (!ndev) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(extack,\n\
  \t\t\t\t\t       \"PFVF representor:%d creation failed\",\n\t\t\t\t\t       rep_id);\n\
  \t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\trep = netdev_priv(ndev);\n\t\
  \tpriv->reps[rep_id] = rep;\n\t\trep->mdev = priv;\n\t\trep->netdev = ndev;\n\t\t\
  rep->rep_id = rep_id;\n\n\t\tndev->min_mtu = OTX2_MIN_MTU;\n\t\tndev->max_mtu =\
  \ priv->hw.max_mtu;\n\t\tndev->netdev_ops = &rvu_rep_netdev_ops;\n\t\tpcifunc =\
  \ priv->rep_pf_map[rep_id];\n\t\trep->pcifunc = pcifunc;\n\n\t\tsnprintf(ndev->name,\
  \ sizeof(ndev->name), \"Rpf%dvf%d\",\n\t\t\t rvu_get_pf(pcifunc), (pcifunc & RVU_PFVF_FUNC_MASK));\n\
  \n\t\tndev->hw_features = (NETIF_F_RXCSUM | NETIF_F_IP_CSUM |\n\t\t\t       NETIF_F_IPV6_CSUM\
  \ | NETIF_F_RXHASH |\n\t\t\t       NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6);\n\n\
  \t\tndev->hw_features |= NETIF_F_HW_TC;\n\t\tndev->features |= ndev->hw_features;\n\
  \t\teth_hw_addr_random(ndev);\n\t\terr = rvu_rep_devlink_port_register(rep);\n\t\
  \tif (err)\n\t\t\tgoto exit;\n\n\t\tSET_NETDEV_DEVLINK_PORT(ndev, &rep->dl_port);\n\
  \t\terr = register_netdev(ndev);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\
  \t\t\t\t\t   \"PFVF representor registration failed\");\n\t\t\tfree_netdev(ndev);\n\
  \t\t\tgoto exit;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&rep->stats_wrk, rvu_rep_get_stats);\n\
  \t}\n\terr = rvu_rep_napi_init(priv, extack);\n\tif (err)\n\t\tgoto exit;\n\n\t\
  rvu_eswitch_config(priv, true);\n\treturn 0;\nexit:\n\twhile (--rep_id >= 0) {\n\
  \t\trep = priv->reps[rep_id];\n\t\tunregister_netdev(rep->netdev);\n\t\trvu_rep_devlink_port_unregister(rep);\n\
  \t\tfree_netdev(rep->netdev);\n\t}\n\tkfree(priv->reps);\n\trvu_rep_rsrc_free(priv);\n\
  \treturn err;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/net/ethernet/marvell/octeontx2/nic/rep.c\
  \ b/drivers/net/ethernet/marvell/octeontx2/nic/rep.c\nindex 232b10740c13..9e3fcbae5dee\
  \ 100644\n--- a/drivers/net/ethernet/marvell/octeontx2/nic/rep.c\n+++ b/drivers/net/ethernet/marvell/octeontx2/nic/rep.c\n\
  @@ -680,8 +680,10 @@ int rvu_rep_create(struct otx2_nic *priv, struct netlink_ext_ack\
  \ *extack)\n \t\tndev->features |= ndev->hw_features;\n \t\teth_hw_addr_random(ndev);\n\
  \ \t\terr = rvu_rep_devlink_port_register(rep);\n-\t\tif (err)\n+\t\tif (err) {\n\
  +\t\t\tfree_netdev(ndev);\n \t\t\tgoto exit;\n+\t\t}\n \n \t\tSET_NETDEV_DEVLINK_PORT(ndev,\
  \ &rep->dl_port);\n \t\terr = register_netdev(ndev);\n```\n"
pattern: "## Bug Pattern\n\nIn a loop that allocates and initializes per-item resources\
  \ (e.g., alloc_etherdev()), an error occurring mid-iteration before the item is\
  \ fully registered/committed jumps to a common cleanup that tears down only previously\
  \ completed iterations (e.g., while (--idx >= 0)), thereby excluding the current\
  \ (failed) iteration. As a result, resources allocated in the current iteration\
  \ (the net_device) are not freed, causing a memory leak. The fix is to explicitly\
  \ free the current iteration\u2019s resource before jumping to the shared exit path."
plan: "Plan\n\n1. Program state\n- REGISTER_MAP_WITH_PROGRAMSTATE(LoopAllocSymMap,\
  \ const Stmt*, SymbolRef)\n  - Key: the enclosing loop statement (ForStmt/WhileStmt/DoStmt)\
  \ that we are currently inside.\n  - Value: the SymbolRef of the per-iteration resource\
  \ allocated in this iteration (e.g., the pointer returned by alloc_etherdev()).\n\
  \  - Rationale: we only need to remember \u201Cthe current iteration\u2019s\u201D\
  \ allocation per loop to decide whether an early bail-out leaks it. Overwrite the\
  \ value on a new allocation in the same loop to avoid carrying entries from previous\
  \ iterations.\n- (Optional, only if you want slightly better precision) REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap,\
  \ const MemRegion*, SymbolRef)\n  - Track aliases by binding a region (variable/field)\
  \ to the symbol it stores. Use checkBind to update. This helps match free_netdev(rep->netdev)\
  \ to the same symbol returned by alloc_etherdev(). If you want to keep things simpler,\
  \ you can skip this map; the base case with a plain variable (e.g., free_netdev(ndev))\
  \ is already handled using symbols directly.\n\n2. Helper identification\n- isPerIterAllocator(const\
  \ CallEvent&):\n  - Return true when callee is one of:\n    - \"alloc_etherdev\"\
  \n    - \"alloc_etherdev_mqs\"\n    - \"alloc_netdev\"\n    - \"alloc_netdev_mqs\"\
  \n- isPerIterFree(const CallEvent&):\n  - Return true when callee is \"free_netdev\"\
  .\n- getEnclosingLoopStmt(const Stmt*, CheckerContext&):\n  - Using findSpecificTypeInParents<T>\
  \ over T in order: ForStmt, WhileStmt, DoStmt. Return the first found; otherwise\
  \ nullptr.\n- thenBranchHasGotoExit(const IfStmt*):\n  - Find a GotoStmt inside\
  \ the Then branch using findSpecificTypeInChildren<GotoStmt>.\n  - If found, check\
  \ its target label\u2019s name (GotoStmt->getLabel()->getName()) equals \"exit\"\
  . Return true iff so.\n- thenBranchFirstCallExpr(const IfStmt*):\n  - Using findSpecificTypeInChildren<CallExpr>\
  \ on the Then branch. If found, return it; otherwise nullptr.\n- getExprSymbol(const\
  \ Expr*, CheckerContext&):\n  - Fetch SVal with C.getState()->getSVal(E, C.getLocationContext())\
  \ and return getAsSymbol() if present.\n  - If not a symbol and PtrAliasMap is enabled:\
  \ getMemRegionFromExpr(E, C), look it up in PtrAliasMap to retrieve the bound symbol.\n\
  \n3. checkPostCall\n- Goal: record \u201Ccurrent iteration allocation\u201D right\
  \ where allocation happens.\n- Steps:\n  - If !isPerIterAllocator(Call), return.\n\
  \  - Get the return symbol: if SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\
  \ if null, return.\n  - Get the current enclosing loop for the call site (Call.getOriginExpr())\
  \ via getEnclosingLoopStmt. If none, return.\n  - Overwrite LoopAllocSymMap[LoopStmt]\
  \ = RetSym. Overwriting ensures we only keep \u201Cthis iteration\u2019s\u201D most\
  \ recent per-iteration allocation for that loop.\n\n4. checkPreCall\n- Goal: clear\
  \ the \u201Ccurrent iteration allocation\u201D when it is explicitly freed, so the\
  \ checker will not report on subsequent bail-outs.\n- Steps:\n  - If !isPerIterFree(Call),\
  \ return.\n  - Obtain the argument symbol SymArg for arg0 using getExprSymbol(Call.getArgExpr(0),\
  \ C).\n  - If no SymArg, return.\n  - Iterate LoopAllocSymMap entries. If any entry\u2019\
  s value equals SymArg, remove that map entry for its loop key (this allocation is\
  \ freed).\n\n5. checkBranchCondition\n- Goal: detect \u201Cbail-out branches\u201D\
  \ inside a loop that jump to exit (or return) before reaching the end of the iteration,\
  \ and verify that the current iteration\u2019s allocation has not been freed.\n\
  - Steps:\n  - From the Condition, find its IfStmt using findSpecificTypeInParents<IfStmt>.\n\
  \  - If no IfStmt, return.\n  - Find enclosing loop of the IfStmt using getEnclosingLoopStmt(IfStmt,\
  \ C). If none, return. (We only care about early-exit decisions inside loops.)\n\
  \  - Extract the Then branch: const Stmt* ThenS = IfS->getThen().\n  - Check if\
  \ ThenS represents a \u201Cbail-out\u201D:\n    - If thenBranchHasGotoExit(IfS)\
  \ is true, consider it a bail-out.\n    - Else, search for a ReturnStmt in the Then\
  \ branch using findSpecificTypeInChildren<ReturnStmt>. If found, also consider it\
  \ a bail-out.\n    - If neither goto exit nor return is found in ThenS, return.\n\
  \  - If it is a bail-out, look up LoopAllocSymMap[LoopStmt]; if not present, return.\n\
  \  - Precision guard to avoid false positives when the code frees before goto:\n\
  \    - Let FirstCall = thenBranchFirstCallExpr(IfS). If FirstCall is not null and\
  \ its callee name is \"free_netdev\":\n      - Get symbol of its first argument\
  \ ArgSym via getExprSymbol. If ArgSym equals the stored symbol in LoopAllocSymMap[LoopStmt],\
  \ then do not report (this path frees correctly before bail).\n  - If we reach here,\
  \ report a bug:\n    - Message: \"Possible leak: per-iteration net_device not freed\
  \ on error path\"\n    - Location: Prefer the GotoStmt location if found; otherwise\
  \ the IfStmt condition.\n    - Use generateNonFatalErrorNode and std::make_unique<PathSensitiveBugReport>.\n\
  \n6. Optional: small enhancements\n- Recognize other bail-out idioms:\n  - If Then\
  \ branch contains a BreakStmt that exits the loop and a label-based cleanup resides\
  \ after the loop, this might or might not be a leak. To keep the checker simple\
  \ and low-FP, do not handle break/continue; only detect goto exit and return as\
  \ described.\n- Recognize more alloc/free pairs:\n  - You can extend isPerIterAllocator/isPerIterFree\
  \ tables if needed, but keep them narrowly focused to avoid false positives.\n\n\
  7. Why this is sufficient for the target bug pattern\n- The target code allocates\
  \ net_device per iteration and, on an immediate failure (if (err) goto exit;), jumps\
  \ out without freeing the just-allocated device. Our checker:\n  - Records the allocation\
  \ symbol for the current loop iteration.\n  - Sees the early goto exit branch.\n\
  \  - Verifies that free_netdev was not called on the tracked symbol in that branch.\n\
  \  - Emits a warning at the bail-out site, prompting the developer to free the current\
  \ iteration\u2019s resource before the jump.\n\nNotes and usage of provided utilities\n\
  - findSpecificTypeInParents and findSpecificTypeInChildren are used to locate the\
  \ enclosing loop, the IfStmt, and the Goto/Return/Call statements under the Then\
  \ branch.\n- getMemRegionFromExpr and ExprHasName are not required, but you can\
  \ leverage ExprHasName to match function names in a pinch. Prefer callee identifier\
  \ accesses for reliability.\n- EvaluateExprToInt/inferSymbolMaxVal/getArraySizeFromExpr/getStringSize\
  \ are not needed here."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state: Track the per-iteration allocation symbol per enclosing loop.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(LoopAllocSymMap, const Stmt*, SymbolRef)\n\nnamespace\
  \ {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n \
  \       check::PreCall,\n        check::BranchCondition\n     > {\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"Per-iteration resource\
  \ leak\", \"Memory Management\")) {}\n\n  void checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  void checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const;\n\nprivate:\n  // Helpers\n  bool isPerIterAllocator(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  bool isPerIterFree(const CallEvent &Call,\
  \ CheckerContext &C) const;\n\n  const Stmt *getEnclosingLoopStmt(const Stmt *S,\
  \ CheckerContext &C) const;\n\n  const GotoStmt *thenBranchHasGotoExit(const IfStmt\
  \ *IfS) const;\n  const CallExpr *thenBranchFirstCallExpr(const IfStmt *IfS) const;\n\
  \n  SymbolRef getExprSymbol(const Expr *E, CheckerContext &C) const;\n\n  void reportLeak(const\
  \ Stmt *LocStmt, CheckerContext &C) const;\n};\n\n// -------------------- Helper\
  \ Implementations --------------------\n\nbool SAGenTestChecker::isPerIterAllocator(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n\n  // Match common net_device allocators\
  \ used per-iteration.\n  if (ExprHasName(OriginExpr, \"alloc_etherdev\", C) ||\n\
  \      ExprHasName(OriginExpr, \"alloc_etherdev_mqs\", C) ||\n      ExprHasName(OriginExpr,\
  \ \"alloc_netdev\", C) ||\n      ExprHasName(OriginExpr, \"alloc_netdev_mqs\", C))\
  \ {\n    return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isPerIterFree(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n  return ExprHasName(OriginExpr, \"free_netdev\"\
  , C);\n}\n\nconst Stmt *SAGenTestChecker::getEnclosingLoopStmt(const Stmt *S, CheckerContext\
  \ &C) const {\n  if (!S)\n    return nullptr;\n\n  if (const ForStmt *FS = findSpecificTypeInParents<ForStmt>(S,\
  \ C))\n    return FS;\n  if (const WhileStmt *WS = findSpecificTypeInParents<WhileStmt>(S,\
  \ C))\n    return WS;\n  if (const DoStmt *DS = findSpecificTypeInParents<DoStmt>(S,\
  \ C))\n    return DS;\n\n  return nullptr;\n}\n\nconst GotoStmt *SAGenTestChecker::thenBranchHasGotoExit(const\
  \ IfStmt *IfS) const {\n  if (!IfS)\n    return nullptr;\n  const Stmt *ThenS =\
  \ IfS->getThen();\n  if (!ThenS)\n    return nullptr;\n\n  const GotoStmt *GS =\
  \ findSpecificTypeInChildren<GotoStmt>(ThenS);\n  if (!GS)\n    return nullptr;\n\
  \n  const LabelDecl *LD = GS->getLabel();\n  if (!LD)\n    return nullptr;\n\n \
  \ if (LD->getName() == \"exit\")\n    return GS;\n\n  return nullptr;\n}\n\nconst\
  \ CallExpr *SAGenTestChecker::thenBranchFirstCallExpr(const IfStmt *IfS) const {\n\
  \  if (!IfS)\n    return nullptr;\n  const Stmt *ThenS = IfS->getThen();\n  if (!ThenS)\n\
  \    return nullptr;\n\n  return findSpecificTypeInChildren<CallExpr>(ThenS);\n\
  }\n\nSymbolRef SAGenTestChecker::getExprSymbol(const Expr *E, CheckerContext &C)\
  \ const {\n  if (!E)\n    return nullptr;\n  ProgramStateRef State = C.getState();\n\
  \  SVal V = State->getSVal(E, C.getLocationContext());\n  return V.getAsSymbol();\n\
  }\n\nvoid SAGenTestChecker::reportLeak(const Stmt *LocStmt, CheckerContext &C) const\
  \ {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Possible leak:\
  \ per-iteration net_device not freed on error path\", N);\n  if (LocStmt)\n    R->addRange(LocStmt->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n// -------------------- Checker Callbacks --------------------\n\
  \nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  if (!isPerIterAllocator(Call, C))\n    return;\n\n  // Track the allocation\
  \ symbol for the current loop iteration.\n  SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\n\
  \  if (!RetSym)\n    return;\n\n  const Expr *Origin = Call.getOriginExpr();\n \
  \ if (!Origin)\n    return;\n\n  const Stmt *LoopS = getEnclosingLoopStmt(Origin,\
  \ C);\n  if (!LoopS)\n    return;\n\n  ProgramStateRef State = C.getState();\n \
  \ State = State->set<LoopAllocSymMap>(LoopS, RetSym);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  if (!isPerIterFree(Call, C))\n    return;\n\n  // If a free is called\
  \ on the same symbol we tracked for this loop, clear it.\n  const Expr *Arg0 = Call.getArgExpr(0);\n\
  \  if (!Arg0)\n    return;\n\n  SymbolRef ArgSym = getExprSymbol(Arg0, C);\n  if\
  \ (!ArgSym)\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  // Iterate\
  \ tracked loop allocations and remove any that match the freed symbol.\n  auto Map\
  \ = State->get<LoopAllocSymMap>();\n  bool Changed = false;\n  for (auto I = Map.begin(),\
  \ E = Map.end(); I != E; ++I) {\n    const Stmt *LoopKey = I->first;\n    SymbolRef\
  \ TrackedSym = I->second;\n    if (TrackedSym == ArgSym) {\n      State = State->remove<LoopAllocSymMap>(LoopKey);\n\
  \      Changed = true;\n    }\n  }\n\n  if (Changed)\n    C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!Condition)\n    return;\n\n  // Find the surrounding if-statement\
  \ for this condition.\n  const IfStmt *IfS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IfS)\n    return;\n\n  // Only care about early-exit branches inside\
  \ a loop.\n  const Stmt *LoopS = getEnclosingLoopStmt(IfS, C);\n  if (!LoopS)\n\
  \    return;\n\n  // Determine if this is a bail-out branch: goto exit; or return;\n\
  \  const GotoStmt *GotoExit = thenBranchHasGotoExit(IfS);\n  bool HasReturn = false;\n\
  \  if (!GotoExit) {\n    // Check for return in the then-branch\n    const Stmt\
  \ *ThenS = IfS->getThen();\n    if (ThenS) {\n      const ReturnStmt *RS = findSpecificTypeInChildren<ReturnStmt>(ThenS);\n\
  \      HasReturn = (RS != nullptr);\n    }\n  }\n\n  if (!GotoExit && !HasReturn)\n\
  \    return; // Not a bail-out path we care about.\n\n  ProgramStateRef State =\
  \ C.getState();\n  const SymbolRef *TrackedSymPtr = State->get<LoopAllocSymMap>(LoopS);\n\
  \  if (!TrackedSymPtr)\n    return; // No current per-iteration allocation tracked.\n\
  \n  SymbolRef TrackedSym = *TrackedSymPtr;\n\n  // Precision guard: if the first\
  \ call in the then-branch is free_netdev on this symbol, do not report.\n  const\
  \ CallExpr *FirstCall = thenBranchFirstCallExpr(IfS);\n  if (FirstCall) {\n    //\
  \ Use ExprHasName on the call itself to match \"free_netdev\"\n    if (ExprHasName(FirstCall,\
  \ \"free_netdev\", C)) {\n      if (FirstCall->getNumArgs() >= 1) {\n        const\
  \ Expr *Arg0 = FirstCall->getArg(0);\n        if (Arg0) {\n          SymbolRef ArgSym\
  \ = getExprSymbol(Arg0, C);\n          if (ArgSym && ArgSym == TrackedSym) {\n \
  \           // Freed properly before bail-out.\n            return;\n          }\n\
  \        }\n      }\n    }\n  }\n\n  // Report potential leak at the bail-out site\
  \ (goto or condition).\n  const Stmt *LocStmt = GotoExit ? static_cast<const Stmt\
  \ *>(GotoExit)\n                                 : static_cast<const Stmt *>(IfS->getCond());\n\
  \  reportLeak(LocStmt, C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects per-iteration resource leaks\
  \ when bailing out of a loop without freeing the current allocation\",\n      \"\
  \");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
