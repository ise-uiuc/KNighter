_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 0f8ca019544a252d1afb468ce840c6dcbac73af4
commit_type: Buffer-Overflow
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program state is required.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PostStmt<ArraySubscriptExpr>> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Loop bound\
  \ exceeds array size\",\n                       \"Array bounds\")) {}\n\n  void\
  \ checkPostStmt(const ArraySubscriptExpr *ASE, CheckerContext &C) const;\n\nprivate:\n\
  \  // Helper: get loop variable from ForStmt init and ensure it's initialized to\
  \ 0.\n  const VarDecl *getLoopVarFromInit(const Stmt *Init, CheckerContext &C) const;\n\
  \n  // Helper: check increment is ++i, i++, or i += 1 on the loop variable.\n  bool\
  \ isIncrementByOne(const Stmt *IncS, const VarDecl *LoopVD,\n                  \
  \      CheckerContext &C) const;\n\n  // Helper: extract exclusive upper bound from\
  \ condition \"i < N\" or \"i <= N\".\n  bool getExclusiveBoundFromCond(const Expr\
  \ *CondE, const VarDecl *LoopVD,\n                                 llvm::APSInt\
  \ &BoundExcl,\n                                 CheckerContext &C) const;\n\n  //\
  \ Helper: get compile-time array size from base expression.\n  bool getConstArraySizeFromBase(const\
  \ Expr *BaseE, uint64_t &ArraySize,\n                                 CheckerContext\
  \ &C) const;\n\n  // Helper: is the given expression exactly a reference to LoopVD?\n\
  \  static bool isRefToVar(const Expr *E, const VarDecl *VD);\n};\n\nbool SAGenTestChecker::isRefToVar(const\
  \ Expr *E, const VarDecl *VD) {\n  if (!E || !VD)\n    return false;\n  E = E->IgnoreParenImpCasts();\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {\n    return DRE->getDecl()\
  \ == VD;\n  }\n  return false;\n}\n\nconst VarDecl *\nSAGenTestChecker::getLoopVarFromInit(const\
  \ Stmt *Init, CheckerContext &C) const {\n  if (!Init)\n    return nullptr;\n\n\
  \  // Case 1: int i = 0;\n  if (const auto *DS = dyn_cast<DeclStmt>(Init)) {\n \
  \   if (DS->isSingleDecl()) {\n      if (const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl()))\
  \ {\n        if (VD->hasInit()) {\n          llvm::APSInt Val;\n          if (EvaluateExprToInt(Val,\
  \ VD->getInit(), C)) {\n            if (Val == 0)\n              return VD;\n  \
  \        }\n        }\n      }\n    }\n    return nullptr;\n  }\n\n  // Case 2:\
  \ i = 0;\n  if (const auto *BO = dyn_cast<BinaryOperator>(Init)) {\n    if (BO->getOpcode()\
  \ == BO_Assign) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n \
  \     const auto *DRE = dyn_cast<DeclRefExpr>(LHS);\n      const auto *VD = DRE\
  \ ? dyn_cast<VarDecl>(DRE->getDecl()) : nullptr;\n      if (!VD)\n        return\
  \ nullptr;\n\n      llvm::APSInt Val;\n      if (EvaluateExprToInt(Val, BO->getRHS(),\
  \ C) && Val == 0)\n        return VD;\n    }\n  }\n\n  return nullptr;\n}\n\nbool\
  \ SAGenTestChecker::isIncrementByOne(const Stmt *IncS, const VarDecl *LoopVD,\n\
  \                                        CheckerContext &C) const {\n  if (!IncS\
  \ || !LoopVD)\n    return false;\n\n  const auto *IncE = dyn_cast<Expr>(IncS);\n\
  \  if (!IncE)\n    return false;\n\n  const Expr *E = IncE->IgnoreParenCasts();\n\
  \n  // ++i or i++\n  if (const auto *UO = dyn_cast<UnaryOperator>(E)) {\n    if\
  \ ((UO->getOpcode() == UO_PreInc || UO->getOpcode() == UO_PostInc) &&\n        isRefToVar(UO->getSubExpr(),\
  \ LoopVD))\n      return true;\n    return false;\n  }\n\n  // i += 1\n  if (const\
  \ auto *BO = dyn_cast<BinaryOperator>(E)) {\n    if (BO->getOpcode() == BO_AddAssign\
  \ && isRefToVar(BO->getLHS(), LoopVD)) {\n      llvm::APSInt Val;\n      if (EvaluateExprToInt(Val,\
  \ BO->getRHS(), C) && Val == 1)\n        return true;\n    }\n    return false;\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::getExclusiveBoundFromCond(const\
  \ Expr *CondE,\n                                                 const VarDecl *LoopVD,\n\
  \                                                 llvm::APSInt &BoundExcl,\n   \
  \                                              CheckerContext &C) const {\n  if\
  \ (!CondE || !LoopVD)\n    return false;\n\n  const auto *BO = dyn_cast<BinaryOperator>(CondE->IgnoreParenCasts());\n\
  \  if (!BO)\n    return false;\n\n  BinaryOperator::Opcode Op = BO->getOpcode();\n\
  \  if (Op != BO_LT && Op != BO_LE)\n    return false;\n\n  // LHS must be the loop\
  \ var\n  if (!isRefToVar(BO->getLHS(), LoopVD))\n    return false;\n\n  llvm::APSInt\
  \ N;\n  if (!EvaluateExprToInt(N, BO->getRHS(), C))\n    return false;\n\n  BoundExcl\
  \ = N;\n  if (Op == BO_LE) {\n    llvm::APSInt One(N.getBitWidth(), N.isUnsigned());\n\
  \    One = 1;\n    BoundExcl = N + One;\n  }\n  return true;\n}\n\nbool SAGenTestChecker::getConstArraySizeFromBase(const\
  \ Expr *BaseE,\n                                                 uint64_t &ArraySize,\n\
  \                                                 CheckerContext &C) const {\n \
  \ if (!BaseE)\n    return false;\n\n  BaseE = BaseE->IgnoreParenImpCasts();\n\n\
  \  // MemberExpr: struct_field_array[i]\n  if (const auto *ME = dyn_cast<MemberExpr>(BaseE))\
  \ {\n    const ValueDecl *VD = ME->getMemberDecl();\n    const auto *FD = dyn_cast<FieldDecl>(VD);\n\
  \    if (!FD)\n      return false;\n\n    QualType QT = FD->getType();\n    const\
  \ ConstantArrayType *CAT =\n        C.getASTContext().getAsConstantArrayType(QT);\n\
  \    if (!CAT)\n      return false;\n\n    ArraySize = CAT->getSize().getZExtValue();\n\
  \    return true;\n  }\n\n  // DeclRefExpr: local/global array\n  if (const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(BaseE)) {\n    llvm::APInt Sz;\n    if (getArraySizeFromExpr(Sz,\
  \ DRE)) {\n      ArraySize = Sz.getZExtValue();\n      return true;\n    }\n  }\n\
  \n  return false;\n}\n\nvoid SAGenTestChecker::checkPostStmt(const ArraySubscriptExpr\
  \ *ASE,\n                                     CheckerContext &C) const {\n  if (!ASE)\n\
  \    return;\n\n  // 1) Find the enclosing for-statement.\n  const ForStmt *FS =\
  \ findSpecificTypeInParents<ForStmt>(ASE, C);\n  if (!FS)\n    return;\n\n  // 2)\
  \ Extract loop induction variable initialized to 0.\n  const VarDecl *LoopVD = getLoopVarFromInit(FS->getInit(),\
  \ C);\n  if (!LoopVD)\n    return;\n\n  // 3) Check increment is +1.\n  if (!isIncrementByOne(FS->getInc(),\
  \ LoopVD, C))\n    return;\n\n  // 4) Extract loop upper bound as exclusive bound.\n\
  \  llvm::APSInt BoundExcl;\n  if (!getExclusiveBoundFromCond(FS->getCond(), LoopVD,\
  \ BoundExcl, C))\n    return;\n\n  // 5) Ensure index is exactly the loop variable.\n\
  \  const Expr *Idx = ASE->getIdx()->IgnoreParenImpCasts();\n  const auto *IdxDRE\
  \ = dyn_cast<DeclRefExpr>(Idx);\n  if (!IdxDRE)\n    return;\n  if (IdxDRE->getDecl()\
  \ != LoopVD)\n    return;\n\n  // 6) Retrieve the compile-time array size.\n  uint64_t\
  \ ArraySize = 0;\n  if (!getConstArraySizeFromBase(ASE->getBase(), ArraySize, C))\n\
  \    return;\n\n  // 7) Compare loop bound and array size.\n  uint64_t BoundExclVal\
  \ = BoundExcl.getLimitedValue(UINT64_MAX);\n  if (BoundExclVal > ArraySize) {\n\
  \    ExplodedNode *N = C.generateNonFatalErrorNode();\n    if (!N)\n      return;\n\
  \n    auto R = std::make_unique<PathSensitiveBugReport>(\n        *BT, \"Loop bound\
  \ exceeds target array size; possible out-of-bounds \"\n             \"index\",\n\
  \        N);\n    R->addRange(ASE->getSourceRange());\n    C.emitReport(std::move(R));\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects array indexing by loop variable when loop bound exceeds the \"\
  \n      \"array's compile-time size\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Prevent potential buffer overflow\
  \ in map_hw_resources\n\nAdds a check in the map_hw_resources function to prevent\
  \ a potential\nbuffer overflow. The function was accessing arrays using an index\
  \ that\ncould potentially be greater than the size of the arrays, leading to a\n\
  buffer overflow.\n\nAdds a check to ensure that the index is within the bounds of\
  \ the\narrays. If the index is out of bounds, an error message is printed and\n\
  break it will continue execution with just ignoring extra data early to\nprevent\
  \ the buffer overflow.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dml2/dml2_wrapper.c:79\
  \ map_hw_resources() error: buffer overflow 'dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_stream_id'\
  \ 6 <= 7\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dml2/dml2_wrapper.c:81 map_hw_resources()\
  \ error: buffer overflow 'dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_plane_id'\
  \ 6 <= 7\n\nFixes: 7966f319c66d (\"drm/amd/display: Introduce DML2\")\nCc: Rodrigo\
  \ Siqueira <Rodrigo.Siqueira@amd.com>\nCc: Roman Li <roman.li@amd.com>\nCc: Qingqing\
  \ Zhuo <Qingqing.Zhuo@amd.com>\nCc: Aurabindo Pillai <aurabindo.pillai@amd.com>\n\
  Cc: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Srinivasan Shanmugam <srinivasan.shanmugam@amd.com>\n\
  Suggested-by: Roman Li <roman.li@amd.com>\nReviewed-by: Roman Li <roman.li@amd.com>\n\
  Reviewed-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>\nSigned-off-by: Alex Deucher\
  \ <alexander.deucher@amd.com>\n\n## Buggy Code\n\n```c\n// Function: map_hw_resources\
  \ in drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c\nstatic void map_hw_resources(struct\
  \ dml2_context *dml2,\n\t\tstruct dml_display_cfg_st *in_out_display_cfg, struct\
  \ dml_mode_support_info_st *mode_support_info)\n{\n\tunsigned int num_pipes = 0;\n\
  \tint i, j;\n\n\tfor (i = 0; i < __DML_NUM_PLANES__; i++) {\n\t\tin_out_display_cfg->hw.ODMMode[i]\
  \ = mode_support_info->ODMMode[i];\n\t\tin_out_display_cfg->hw.DPPPerSurface[i]\
  \ = mode_support_info->DPPPerSurface[i];\n\t\tin_out_display_cfg->hw.DSCEnabled[i]\
  \ = mode_support_info->DSCEnabled[i];\n\t\tin_out_display_cfg->hw.NumberOfDSCSlices[i]\
  \ = mode_support_info->NumberOfDSCSlices[i];\n\t\tin_out_display_cfg->hw.DLGRefClkFreqMHz\
  \ = 24;\n\t\tif (dml2->v20.dml_core_ctx.project != dml_project_dcn35 &&\n\t\t\t\
  dml2->v20.dml_core_ctx.project != dml_project_dcn351) {\n\t\t\t/*dGPU default as\
  \ 50Mhz*/\n\t\t\tin_out_display_cfg->hw.DLGRefClkFreqMHz = 50;\n\t\t}\n\t\tfor (j\
  \ = 0; j < mode_support_info->DPPPerSurface[i]; j++) {\n\t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_stream_id[num_pipes]\
  \ = dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_stream_id[i];\n\t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_stream_id_valid[num_pipes]\
  \ = true;\n\t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_plane_id[num_pipes]\
  \ = dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_plane_id[i];\n\t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_plane_id_valid[num_pipes]\
  \ = true;\n\t\t\tnum_pipes++;\n\t\t}\n\t}\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c\n\
  index 26307e599614..2a58a7687bdb 100644\n--- a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c\n\
  +++ b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c\n@@ -76,6 +76,11 @@ static\
  \ void map_hw_resources(struct dml2_context *dml2,\n \t\t\tin_out_display_cfg->hw.DLGRefClkFreqMHz\
  \ = 50;\n \t\t}\n \t\tfor (j = 0; j < mode_support_info->DPPPerSurface[i]; j++)\
  \ {\n+\t\t\tif (i >= __DML2_WRAPPER_MAX_STREAMS_PLANES__) {\n+\t\t\t\tdml_print(\"\
  DML::%s: Index out of bounds: i=%d, __DML2_WRAPPER_MAX_STREAMS_PLANES__=%d\\n\"\
  ,\n+\t\t\t\t\t  __func__, i, __DML2_WRAPPER_MAX_STREAMS_PLANES__);\n+\t\t\t\tbreak;\n\
  +\t\t\t}\n \t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_stream_id[num_pipes]\
  \ = dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_stream_id[i];\n \t\t\t\
  dml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_stream_id_valid[num_pipes]\
  \ = true;\n \t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_plane_id[num_pipes]\
  \ = dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_plane_id[i];\n```\n"
pattern: '## Bug Pattern


  Looping with a bound derived from one constant/enumeration (e.g., __DML_NUM_PLANES__)
  and using that loop index to access arrays sized by a different, smaller limit (e.g.,
  __DML2_WRAPPER_MAX_STREAMS_PLANES__) without validating the index. This mismatch
  causes out-of-bounds array access (disp_cfg_to_stream_id[i], disp_cfg_to_plane_id[i])
  when the loop bound exceeds the array size.'
plan: "1) Program state\n- No custom program state is needed. This checker is a local,\
  \ AST-based pattern detector.\n\n2) Callbacks and implementation steps\n\nStep A.\
  \ Hook array subscripts\n- Callback: checkPostStmt(const ArraySubscriptExpr *ASE,\
  \ CheckerContext &C) const\n- Goal: When an array is indexed by a loop induction\
  \ variable whose loop bound comes from one macro/constant, verify that the array\u2019\
  s compile-time size is not smaller than the loop\u2019s upper bound (considering\
  \ the comparison operator). If smaller, report potential out-of-bounds.\n\nImplementation\
  \ details:\n1) Retrieve the nearest enclosing ForStmt\n   - Use findSpecificTypeInParents<ForStmt>(ASE,\
  \ C). If none, return.\n\n2) Extract loop induction variable and its initial value\n\
  \   - From ForStmt->getInit():\n     - Case 1: DeclStmt with a single VarDecl having\
  \ an initializer. Save VarDecl* as LoopVar. Evaluate initializer to int with EvaluateExprToInt;\
  \ require it to be 0; otherwise return.\n     - Case 2: BinaryOperator \u201Ci =\
  \ 0\u201D. The LHS must be DeclRefExpr to a VarDecl (LoopVar). Evaluate RHS with\
  \ EvaluateExprToInt; require it to be 0; otherwise return.\n   - Keep it simple:\
  \ only handle the common \u201Ci = 0\u201D initialization.\n\n3) Check increment\
  \ is +1\n   - From ForStmt->getInc():\n     - Accept UnaryOperator ++i or i++ on\
  \ the same LoopVar.\n     - Accept \u201Ci += 1\u201D (BinaryOperator with opcode\
  \ BO_AddAssign and RHS == 1).\n   - If not matched, return.\n\n4) Extract the loop\
  \ upper bound and the comparison operator\n   - From ForStmt->getCond():\n     -\
  \ Expect BinaryOperator with opcode BO_LT or BO_LE.\n     - LHS must be DeclRefExpr\
  \ to the same LoopVar.\n     - Evaluate RHS to integer bound N via EvaluateExprToInt.\
  \ If fails, return.\n   - Compute the exclusive bound BoundExcl:\n     - If op is\
  \ \u2018<\u2019, BoundExcl = N.\n     - If op is \u2018<=\u2019, BoundExcl = N +\
  \ 1.\n\n5) Ensure the index expression is exactly the loop variable\n   - From ASE->getIdx()->IgnoreParenImpCasts():\n\
  \     - Must be a DeclRefExpr that resolves to the same LoopVar. If not, return.\n\
  \   - Keep it simple: only flag when the index is the loop variable directly (no\
  \ offsets or complex expressions).\n\n6) Retrieve the compile-time array size of\
  \ the subscripted array\n   - We must get the ConstantArrayType of the array being\
  \ subscripted.\n   - From ASE->getBase()->IgnoreParenImpCasts():\n     - If it is\
  \ a MemberExpr:\n       - Get FieldDecl* via getMemberDecl().\n       - Get the\
  \ field\u2019s QualType QT = FD->getType().\n       - Try dyn_cast<ConstantArrayType>(QT.getTypePtr()).\
  \ If not array type, return.\n       - Let ArraySize = CAT->getSize().getZExtValue().\n\
  \     - Else if it is a DeclRefExpr:\n       - Use provided getArraySizeFromExpr(ArraySizeAPInt,\
  \ DeclRefExpr). If success, ArraySize = ArraySizeAPInt.getZExtValue().\n     - Otherwise\
  \ return (we only handle known constant-sized arrays).\n\n7) Compare loop bound\
  \ and array size\n   - If BoundExcl > ArraySize, then the loop can index the array\
  \ out-of-bounds (max index equals BoundExcl-1, so BoundExcl > ArraySize implies\
  \ (BoundExcl-1) >= ArraySize).\n   - If this holds, report a bug.\n\n8) Emit bug\
  \ report\n   - Create a non-fatal error node (C.generateNonFatalErrorNode()).\n\
  \   - Emit a short message: \u201CLoop bound exceeds target array size; possible\
  \ out-of-bounds index.\u201D\n   - Attach the range at ASE->getExprLoc().\n   -\
  \ Use std::make_unique<PathSensitiveBugReport> with a checker-owned BugType.\n\n\
  Notes:\n- This checker intentionally focuses on the common and simple pattern:\n\
  \  - for (int i = 0; i < CONST; i++) arr[i] = ...\n  - Array is a field or variable\
  \ with compile-time constant bound.\n- We do not attempt to model data-dependent\
  \ bounds or complex index expressions.\n- We do not attempt to prove guarding if-statements\
  \ dominate the access; to keep the checker simple, it flags when the loop\u2019\
  s exclusive bound is greater than the array\u2019s size.\n\nStep B. Optional false-positive\
  \ reduction (simple guard recognition)\n- Not required, but if desired and simple,\
  \ before reporting:\n  - Search upwards with findSpecificTypeInParents<const IfStmt>(ASE,\
  \ C) to see if the nearest guarding condition is of the form (i < K) or (i >= K)\
  \ with K <= ArraySize and that ASE is syntactically within the guarded \u201Cthen\u201D\
  \ that enforces i < K.\n  - If detected and trivially safe, suppress. Otherwise\
  \ keep the report.\n- Prefer skipping this to keep implementation minimal, as suggested.\n\
  \n3) Utility functions used\n- findSpecificTypeInParents<T>(...) to locate the enclosing\
  \ ForStmt (and optional enclosing IfStmt if implementing the optional reduction).\n\
  - EvaluateExprToInt(...) to extract numeric values for loop initializer, bound,\
  \ and increments where applicable.\n- getArraySizeFromExpr(...) only for DeclRefExpr\
  \ bases; for struct fields use FieldDecl type and ConstantArrayType directly.\n\n\
  4) Summary of minimal conditions to warn\n- Inside a ForStmt:\n  - init: i = 0 (or\
  \ int i = 0)\n  - cond: i < N or i <= N where N is compile-time int\n  - inc: ++i,\
  \ i++, or i += 1\n- The ArraySubscriptExpr index is i (exactly).\n- The subscripted\
  \ array has compile-time constant size A (from ConstantArrayType).\n- BoundExcl\
  \ > A (i.e., (i runs 0..BoundExcl-1) may reach index >= A).\n- Emit: \u201CLoop\
  \ bound exceeds target array size; possible out-of-bounds index.\u201D"
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program state is required.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PostStmt<ArraySubscriptExpr>> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Loop bound\
  \ exceeds array size\",\n                       \"Array bounds\")) {}\n\n  void\
  \ checkPostStmt(const ArraySubscriptExpr *ASE, CheckerContext &C) const;\n\nprivate:\n\
  \  // Helper: get loop variable from ForStmt init and ensure it's initialized to\
  \ 0.\n  const VarDecl *getLoopVarFromInit(const Stmt *Init, CheckerContext &C) const;\n\
  \n  // Helper: check increment is ++i, i++, or i += 1 on the loop variable.\n  bool\
  \ isIncrementByOne(const Stmt *IncS, const VarDecl *LoopVD,\n                  \
  \      CheckerContext &C) const;\n\n  // Helper: extract exclusive upper bound from\
  \ condition \"i < N\" or \"i <= N\".\n  bool getExclusiveBoundFromCond(const Expr\
  \ *CondE, const VarDecl *LoopVD,\n                                 llvm::APSInt\
  \ &BoundExcl,\n                                 CheckerContext &C) const;\n\n  //\
  \ Helper: get compile-time array size from base expression.\n  bool getConstArraySizeFromBase(const\
  \ Expr *BaseE, uint64_t &ArraySize,\n                                 CheckerContext\
  \ &C) const;\n\n  // Helper: is the given expression exactly a reference to LoopVD?\n\
  \  static bool isRefToVar(const Expr *E, const VarDecl *VD);\n};\n\nbool SAGenTestChecker::isRefToVar(const\
  \ Expr *E, const VarDecl *VD) {\n  if (!E || !VD)\n    return false;\n  E = E->IgnoreParenImpCasts();\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {\n    return DRE->getDecl()\
  \ == VD;\n  }\n  return false;\n}\n\nconst VarDecl *\nSAGenTestChecker::getLoopVarFromInit(const\
  \ Stmt *Init, CheckerContext &C) const {\n  if (!Init)\n    return nullptr;\n\n\
  \  // Case 1: int i = 0;\n  if (const auto *DS = dyn_cast<DeclStmt>(Init)) {\n \
  \   if (DS->isSingleDecl()) {\n      if (const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl()))\
  \ {\n        if (VD->hasInit()) {\n          llvm::APSInt Val;\n          if (EvaluateExprToInt(Val,\
  \ VD->getInit(), C)) {\n            if (Val == 0)\n              return VD;\n  \
  \        }\n        }\n      }\n    }\n    return nullptr;\n  }\n\n  // Case 2:\
  \ i = 0;\n  if (const auto *BO = dyn_cast<BinaryOperator>(Init)) {\n    if (BO->getOpcode()\
  \ == BO_Assign) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n \
  \     const auto *DRE = dyn_cast<DeclRefExpr>(LHS);\n      const auto *VD = DRE\
  \ ? dyn_cast<VarDecl>(DRE->getDecl()) : nullptr;\n      if (!VD)\n        return\
  \ nullptr;\n\n      llvm::APSInt Val;\n      if (EvaluateExprToInt(Val, BO->getRHS(),\
  \ C) && Val == 0)\n        return VD;\n    }\n  }\n\n  return nullptr;\n}\n\nbool\
  \ SAGenTestChecker::isIncrementByOne(const Stmt *IncS, const VarDecl *LoopVD,\n\
  \                                        CheckerContext &C) const {\n  if (!IncS\
  \ || !LoopVD)\n    return false;\n\n  const auto *IncE = dyn_cast<Expr>(IncS);\n\
  \  if (!IncE)\n    return false;\n\n  const Expr *E = IncE->IgnoreParenCasts();\n\
  \n  // ++i or i++\n  if (const auto *UO = dyn_cast<UnaryOperator>(E)) {\n    if\
  \ ((UO->getOpcode() == UO_PreInc || UO->getOpcode() == UO_PostInc) &&\n        isRefToVar(UO->getSubExpr(),\
  \ LoopVD))\n      return true;\n    return false;\n  }\n\n  // i += 1\n  if (const\
  \ auto *BO = dyn_cast<BinaryOperator>(E)) {\n    if (BO->getOpcode() == BO_AddAssign\
  \ && isRefToVar(BO->getLHS(), LoopVD)) {\n      llvm::APSInt Val;\n      if (EvaluateExprToInt(Val,\
  \ BO->getRHS(), C) && Val == 1)\n        return true;\n    }\n    return false;\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::getExclusiveBoundFromCond(const\
  \ Expr *CondE,\n                                                 const VarDecl *LoopVD,\n\
  \                                                 llvm::APSInt &BoundExcl,\n   \
  \                                              CheckerContext &C) const {\n  if\
  \ (!CondE || !LoopVD)\n    return false;\n\n  const auto *BO = dyn_cast<BinaryOperator>(CondE->IgnoreParenCasts());\n\
  \  if (!BO)\n    return false;\n\n  BinaryOperator::Opcode Op = BO->getOpcode();\n\
  \  if (Op != BO_LT && Op != BO_LE)\n    return false;\n\n  // LHS must be the loop\
  \ var\n  if (!isRefToVar(BO->getLHS(), LoopVD))\n    return false;\n\n  llvm::APSInt\
  \ N;\n  if (!EvaluateExprToInt(N, BO->getRHS(), C))\n    return false;\n\n  BoundExcl\
  \ = N;\n  if (Op == BO_LE) {\n    llvm::APSInt One(N.getBitWidth(), N.isUnsigned());\n\
  \    One = 1;\n    BoundExcl = N + One;\n  }\n  return true;\n}\n\nbool SAGenTestChecker::getConstArraySizeFromBase(const\
  \ Expr *BaseE,\n                                                 uint64_t &ArraySize,\n\
  \                                                 CheckerContext &C) const {\n \
  \ if (!BaseE)\n    return false;\n\n  BaseE = BaseE->IgnoreParenImpCasts();\n\n\
  \  // MemberExpr: struct_field_array[i]\n  if (const auto *ME = dyn_cast<MemberExpr>(BaseE))\
  \ {\n    const ValueDecl *VD = ME->getMemberDecl();\n    const auto *FD = dyn_cast<FieldDecl>(VD);\n\
  \    if (!FD)\n      return false;\n\n    QualType QT = FD->getType();\n    const\
  \ ConstantArrayType *CAT =\n        C.getASTContext().getAsConstantArrayType(QT);\n\
  \    if (!CAT)\n      return false;\n\n    ArraySize = CAT->getSize().getZExtValue();\n\
  \    return true;\n  }\n\n  // DeclRefExpr: local/global array\n  if (const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(BaseE)) {\n    llvm::APInt Sz;\n    if (getArraySizeFromExpr(Sz,\
  \ DRE)) {\n      ArraySize = Sz.getZExtValue();\n      return true;\n    }\n  }\n\
  \n  return false;\n}\n\nvoid SAGenTestChecker::checkPostStmt(const ArraySubscriptExpr\
  \ *ASE,\n                                     CheckerContext &C) const {\n  if (!ASE)\n\
  \    return;\n\n  // 1) Find the enclosing for-statement.\n  const ForStmt *FS =\
  \ findSpecificTypeInParents<ForStmt>(ASE, C);\n  if (!FS)\n    return;\n\n  // 2)\
  \ Extract loop induction variable initialized to 0.\n  const VarDecl *LoopVD = getLoopVarFromInit(FS->getInit(),\
  \ C);\n  if (!LoopVD)\n    return;\n\n  // 3) Check increment is +1.\n  if (!isIncrementByOne(FS->getInc(),\
  \ LoopVD, C))\n    return;\n\n  // 4) Extract loop upper bound as exclusive bound.\n\
  \  llvm::APSInt BoundExcl;\n  if (!getExclusiveBoundFromCond(FS->getCond(), LoopVD,\
  \ BoundExcl, C))\n    return;\n\n  // 5) Ensure index is exactly the loop variable.\n\
  \  const Expr *Idx = ASE->getIdx()->IgnoreParenImpCasts();\n  const auto *IdxDRE\
  \ = dyn_cast<DeclRefExpr>(Idx);\n  if (!IdxDRE)\n    return;\n  if (IdxDRE->getDecl()\
  \ != LoopVD)\n    return;\n\n  // 6) Retrieve the compile-time array size.\n  uint64_t\
  \ ArraySize = 0;\n  if (!getConstArraySizeFromBase(ASE->getBase(), ArraySize, C))\n\
  \    return;\n\n  // 7) Compare loop bound and array size.\n  uint64_t BoundExclVal\
  \ = BoundExcl.getLimitedValue(UINT64_MAX);\n  if (BoundExclVal > ArraySize) {\n\
  \    ExplodedNode *N = C.generateNonFatalErrorNode();\n    if (!N)\n      return;\n\
  \n    auto R = std::make_unique<PathSensitiveBugReport>(\n        *BT, \"Loop bound\
  \ exceeds target array size; possible out-of-bounds \"\n             \"index\",\n\
  \        N);\n    R->addRange(ASE->getSourceRange());\n    C.emitReport(std::move(R));\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects array indexing by loop variable when loop bound exceeds the \"\
  \n      \"array's compile-time size\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
