_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: c6087b82a9146826564a55c5ca0164cac40348f5
commit_type: Buffer-Overflow
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include <string>\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// No custom program states\n\n\
  namespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"Unbounded copy_from_user into fixed-size buffer\", \"Security\"\
  )) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \n   private:\n\n      // Try to extract destination fixed-size array info (size\
  \ and name) from an expression.\n      bool getFixedArrayInfo(const Expr *DstExpr,\
  \ CheckerContext &C,\n                             llvm::APInt &ArraySize, std::string\
  \ &DestName) const;\n\n      // Try to determine if NExpr is syntactically clamped\
  \ with min(sizeof(Dest)...)\n      bool isClampedByMinSizeof(const Expr *NExpr,\
  \ StringRef DestName, CheckerContext &C) const;\n\n      // Check if a DeclRefExpr\
  \ refers to an integer-like local variable with an initializer\n      // that is\
  \ constant and <= bound or a min(sizeof(Dest), ...) pattern.\n      bool initializerProvesSafe(const\
  \ DeclRefExpr *DRE, uint64_t Bound,\n                                 StringRef\
  \ DestName, CheckerContext &C) const;\n\n      void report(const CallEvent &Call,\
  \ const Expr *SizeExpr,\n                  const Expr *DstExpr, CheckerContext &C)\
  \ const;\n};\n\nbool SAGenTestChecker::getFixedArrayInfo(const Expr *DstExpr, CheckerContext\
  \ &C,\n                                         llvm::APInt &ArraySize, std::string\
  \ &DestName) const {\n  if (!DstExpr)\n    return false;\n\n  // First, try direct\n\
  \  if (getArraySizeFromExpr(ArraySize, DstExpr)) {\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(DstExpr->IgnoreImplicit()))\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n        DestName\
  \ = VD->getName().str();\n      }\n    } else {\n      // Try to find a DRE for\
  \ name extraction\n      if (const auto *InnerDRE = findSpecificTypeInChildren<DeclRefExpr>(DstExpr))\
  \ {\n        if (const auto *VD = dyn_cast<VarDecl>(InnerDRE->getDecl())) {\n  \
  \        DestName = VD->getName().str();\n        }\n      }\n    }\n    return\
  \ true;\n  }\n\n  // Then, search downward for a DeclRefExpr that names the array\
  \ variable.\n  if (const auto *InnerDRE = findSpecificTypeInChildren<DeclRefExpr>(DstExpr))\
  \ {\n    if (getArraySizeFromExpr(ArraySize, InnerDRE)) {\n      if (const auto\
  \ *VD = dyn_cast<VarDecl>(InnerDRE->getDecl())) {\n        DestName = VD->getName().str();\n\
  \      }\n      return true;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isClampedByMinSizeof(const\
  \ Expr *NExpr, StringRef DestName,\n                                           \
  \ CheckerContext &C) const {\n  if (!NExpr)\n    return false;\n  // Heuristic syntactic\
  \ check: size expression mentions min, sizeof, and the destination array name.\n\
  \  if (ExprHasName(NExpr, \"min\", C) && ExprHasName(NExpr, \"sizeof\", C)) {\n\
  \    if (!DestName.empty() && ExprHasName(NExpr, DestName, C))\n      return true;\n\
  \  }\n  return false;\n}\n\nbool SAGenTestChecker::initializerProvesSafe(const DeclRefExpr\
  \ *DRE, uint64_t Bound,\n                                             StringRef\
  \ DestName, CheckerContext &C) const {\n  if (!DRE)\n    return false;\n  const\
  \ auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n    return false;\n\
  \n  const Expr *Init = VD->getInit();\n  if (!Init)\n    return false;\n\n  llvm::APSInt\
  \ InitVal;\n  if (EvaluateExprToInt(InitVal, Init, C)) {\n    uint64_t InitU = InitVal.getLimitedValue();\n\
  \    if (InitU <= Bound)\n      return true;\n  }\n\n  // Check for syntactic clamp\
  \ in initializer\n  if (isClampedByMinSizeof(Init, DestName, C))\n    return true;\n\
  \n  return false;\n}\n\nvoid SAGenTestChecker::report(const CallEvent &Call, const\
  \ Expr *SizeExpr,\n                              const Expr *DstExpr, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Unbounded copy_from_user into fixed-size buffer\", N);\n\n  if (SizeExpr)\n\
  \    R->addRange(SizeExpr->getSourceRange());\n  if (DstExpr)\n    R->addRange(DstExpr->getSourceRange());\n\
  \n  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return;\n\n  // Identify copy_from_user by source text name\
  \ to be robust with wrappers.\n  if (!ExprHasName(Origin, \"copy_from_user\", C))\n\
  \    return;\n\n  if (Call.getNumArgs() < 3)\n    return;\n\n  const Expr *DstExpr\
  \ = Call.getArgExpr(0);\n  const Expr *SizeExpr = Call.getArgExpr(2);\n  if (!DstExpr\
  \ || !SizeExpr)\n    return;\n\n  // Destination must be a fixed-size array in scope\n\
  \  llvm::APInt ArraySize;\n  std::string DestName;\n  if (!getFixedArrayInfo(DstExpr,\
  \ C, ArraySize, DestName))\n    return; // Only warn for fixed-size arrays we can\
  \ resolve\n\n  uint64_t ArrSizeU = ArraySize.getLimitedValue();\n  uint64_t Bound\
  \ = ArrSizeU > 0 ? (ArrSizeU - 1) : 0;\n\n  // Case A: Constant size\n  llvm::APSInt\
  \ ConstSizeVal;\n  if (EvaluateExprToInt(ConstSizeVal, SizeExpr, C)) {\n    uint64_t\
  \ N = ConstSizeVal.getLimitedValue();\n    if (N <= Bound)\n      return; // safe\n\
  \    report(Call, SizeExpr, DstExpr, C);\n    return;\n  }\n\n  // Case B: Symbolic\
  \ size with known maximum\n  SVal NVal = Call.getArgSVal(2);\n  if (SymbolRef Sym\
  \ = NVal.getAsSymbol()) {\n    if (const llvm::APSInt *MaxV = inferSymbolMaxVal(Sym,\
  \ C)) {\n      uint64_t MaxU = MaxV->getLimitedValue();\n      if (MaxU <= Bound)\n\
  \        return; // safe\n      // else continue with other syntactic checks\n \
  \   }\n  }\n\n  // Case C: Syntactic clamp pattern in the size expression itself\n\
  \  if (isClampedByMinSizeof(SizeExpr, DestName, C))\n    return; // safe\n\n  //\
  \ Case D: Size is a local variable with an initializer clamp\n  if (const auto *SizeDRE\
  \ = dyn_cast<DeclRefExpr>(SizeExpr->IgnoreParenCasts())) {\n    if (initializerProvesSafe(SizeDRE,\
  \ Bound, DestName, C))\n      return; // safe\n  }\n\n  // If none of the above\
  \ proves safety, report\n  report(Call, SizeExpr, DstExpr, C);\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unbounded copy_from_user into fixed-size buffers (missing min(sizeof(buf)-1,\
  \ nbytes) clamp)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nscsi: lpfc: Prevent lpfc_debugfs_lockstat_write()\
  \ buffer overflow\n\nA static code analysis tool flagged the possibility of buffer\
  \ overflow when\nusing copy_from_user() for a debugfs entry.\n\nCurrently, it is\
  \ possible that copy_from_user() copies more bytes than what\nwould fit in the mybuf\
  \ char array.  Add a min() restriction check between\nsizeof(mybuf) - 1 and nbytes\
  \ passed from the userspace buffer to protect\nagainst buffer overflow.\n\nLink:\
  \ https://lore.kernel.org/r/20230301231626.9621-2-justintee8345@gmail.com\nSigned-off-by:\
  \ Justin Tee <justin.tee@broadcom.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>\n\
  \n## Buggy Code\n\n```c\n// Function: lpfc_debugfs_lockstat_write in drivers/scsi/lpfc/lpfc_debugfs.c\n\
  static ssize_t\nlpfc_debugfs_lockstat_write(struct file *file, const char __user\
  \ *buf,\n\t\t\t    size_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug =\
  \ file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\
  \tstruct lpfc_sli4_hdw_queue *qp;\n\tchar mybuf[64];\n\tchar *pbuf;\n\tint i;\n\n\
  \tmemset(mybuf, 0, sizeof(mybuf));\n\n\tif (copy_from_user(mybuf, buf, nbytes))\n\
  \t\treturn -EFAULT;\n\tpbuf = &mybuf[0];\n\n\tif ((strncmp(pbuf, \"reset\", strlen(\"\
  reset\")) == 0) ||\n\t    (strncmp(pbuf, \"zero\", strlen(\"zero\")) == 0)) {\n\t\
  \tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\t\tqp = &phba->sli4_hba.hdwq[i];\n\
  \t\t\tqp->lock_conflict.alloc_xri_get = 0;\n\t\t\tqp->lock_conflict.alloc_xri_put\
  \ = 0;\n\t\t\tqp->lock_conflict.free_xri = 0;\n\t\t\tqp->lock_conflict.wq_access\
  \ = 0;\n\t\t\tqp->lock_conflict.alloc_pvt_pool = 0;\n\t\t\tqp->lock_conflict.mv_from_pvt_pool\
  \ = 0;\n\t\t\tqp->lock_conflict.mv_to_pub_pool = 0;\n\t\t\tqp->lock_conflict.mv_to_pvt_pool\
  \ = 0;\n\t\t\tqp->lock_conflict.free_pvt_pool = 0;\n\t\t\tqp->lock_conflict.free_pub_pool\
  \ = 0;\n\t\t\tqp->lock_conflict.wq_access = 0;\n\t\t}\n\t}\n\treturn nbytes;\n}\n\
  ```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/scsi/lpfc/lpfc_debugfs.c\
  \ b/drivers/scsi/lpfc/lpfc_debugfs.c\nindex f5252e45a48a..3e365e5e194a 100644\n\
  --- a/drivers/scsi/lpfc/lpfc_debugfs.c\n+++ b/drivers/scsi/lpfc/lpfc_debugfs.c\n\
  @@ -2157,10 +2157,13 @@ lpfc_debugfs_lockstat_write(struct file *file, const char\
  \ __user *buf,\n \tchar mybuf[64];\n \tchar *pbuf;\n \tint i;\n+\tsize_t bsize;\n\
  \ \n \tmemset(mybuf, 0, sizeof(mybuf));\n \n-\tif (copy_from_user(mybuf, buf, nbytes))\n\
  +\tbsize = min(nbytes, (sizeof(mybuf) - 1));\n+\n+\tif (copy_from_user(mybuf, buf,\
  \ bsize))\n \t\treturn -EFAULT;\n \tpbuf = &mybuf[0];\n \n@@ -2181,7 +2184,7 @@\
  \ lpfc_debugfs_lockstat_write(struct file *file, const char __user *buf,\n \t\t\t\
  qp->lock_conflict.wq_access = 0;\n \t\t}\n \t}\n-\treturn nbytes;\n+\treturn bsize;\n\
  \ }\n #endif\n \n```\n"
pattern: '## Bug Pattern


  Copying user-provided data into a fixed-size buffer with copy_from_user() using
  the untrusted nbytes (write count) without clamping it to the destination buffer
  size (e.g., sizeof(buf) - 1). This allows a user to pass a larger nbytes than the
  buffer can hold, causing a stack buffer overflow in debugfs/sysfs write handlers.'
plan: "Plan\n\n1. No custom program states\n   - Keep it simple and path-insensitive.\
  \ Do not introduce program state maps/traits initially.\n   - Rely on direct AST/expr\
  \ inspection at the call site and light-weight value reasoning via:\n     - getArraySizeFromExpr\n\
  \     - findSpecificTypeInChildren\n     - EvaluateExprToInt\n     - inferSymbolMaxVal\n\
  \     - ExprHasName\n\n2. Callback selection\n   - Use only checkPreCall for the\
  \ first iteration.\n   - Optional enhancement (if needed): add checkBind to recognize\
  \ a common clamp assignment pattern and cache a \u201Cclamped\u201D fact for the\
  \ specific size variable and buffer.\n\n3. checkPreCall (core detection)\n   - Goal:\
  \ Flag calls to copy_from_user(dst, src, nbytes) where:\n     - dst is a fixed-size\
  \ array in the current scope, and\n     - nbytes is not provably bounded to dst\u2019\
  s size (preferably <= sizeof(dst) - 1).\n   - Steps:\n     1) Identify target function\n\
  \        - If Call.getCalleeIdentifier()->getName() != \"copy_from_user\", return.\n\
  \     2) Extract arguments\n        - Arg0 = destination expression (ToExpr)\n \
  \       - Arg1 = source (unused)\n        - Arg2 = size expression (NExpr)\n   \
  \  3) Determine the destination buffer size\n        - Try getArraySizeFromExpr(ArraySize,\
  \ ToExpr).\n        - If that fails (due to decay or &buf[0]), call findSpecificTypeInChildren<DeclRefExpr>(ToExpr)\
  \ to find a DeclRefExpr referencing the array, then call getArraySizeFromExpr on\
  \ that DeclRefExpr.\n        - If still not found, return (we only warn when destination\
  \ is a compile-time fixed-size array).\n        - Compute Bound = ArraySize - 1\
  \ (to match kernel\u2019s string use case and the target pattern).\n     4) Try\
  \ to prove the size argument is safe\n        - Case A: Constant size\n        \
  \  - If EvaluateExprToInt(Const, NExpr) succeeds:\n            - If Const <= Bound,\
  \ OK -> return.\n            - Else, report (unsafe).\n        - Case B: Symbolic\
  \ size with known maximum\n          - Obtain SVal for NExpr; if it has a SymbolRef,\
  \ call inferSymbolMaxVal(Sym, C).\n          - If maxVal exists and maxVal <= Bound,\
  \ OK -> return.\n          - If maxVal > Bound or unknown, continue checking for\
  \ syntactic clamp patterns.\n        - Case C: Syntactic clamp pattern in the size\
  \ expression itself\n          - If ExprHasName(NExpr, \"min\", C) AND ExprHasName(NExpr,\
  \ \"sizeof\", C):\n            - Additionally, if we can get the destination variable\
  \ name (from DeclRefExpr of dst), check ExprHasName(NExpr, DestVarName, C).\n  \
  \          - If true, consider it clamped -> return.\n        - Case D: The size\
  \ is a local variable with an initializer clamp\n          - If NExpr is a DeclRefExpr\
  \ to a VarDecl (e.g., bsize), try:\n            - If VarDecl has an initializer\
  \ Init:\n              - If EvaluateExprToInt(Const, Init) succeeds and Const <=\
  \ Bound -> return.\n              - Else if ExprHasName(Init, \"min\", C) AND ExprHasName(Init,\
  \ \"sizeof\", C) AND ExprHasName(Init, DestVarName, C) -> return.\n        - If\
  \ none of the above proves safety -> report.\n     5) Emit report\n        - Create\
  \ a non-fatal error node and emit a PathSensitiveBugReport.\n        - Message:\
  \ \"Unbounded copy_from_user into fixed-size buffer\"\n        - Point the primary\
  \ range to Arg2 (size argument). Optionally, add a note range on Arg0 (destination).\n\
  \        - Keep it short per Suggestions.\n\n4. Optional enhancement: checkBind\
  \ for clamp assignments (if you want to reduce false positives)\n   - Rationale:\
  \ handle patterns like:\n     - bsize = min(nbytes, sizeof(buf) - 1);\n     - or\
  \ bsize set via conditional clamp: if (nbytes > sizeof(buf)-1) bsize = sizeof(buf)-1;\
  \ else bsize = nbytes;\n   - Minimal approach:\n     - REGISTER_MAP_WITH_PROGRAMSTATE(ClampOkMap,\
  \ const MemRegion*, const MemRegion*)\n       - Map: size variable region -> destination\
  \ buffer region that the clamp ties to.\n     - In checkBind:\n       - When binding\
  \ to a region corresponding to an integer variable (LHS), analyze RHS:\n       \
  \  - If ExprHasName(RHS, \"min\", C) AND ExprHasName(RHS, \"sizeof\", C):\n    \
  \       - Try to find a DeclRefExpr for the destination array inside RHS via findSpecificTypeInChildren<DeclRefExpr>()\
  \ and ensure it refers to a ConstantArray VarDecl.\n           - If found, insert\
  \ ClampOkMap[LHSRegion] = DestArrayRegion.\n     - In checkPreCall:\n       - If\
  \ Arg2 is a variable, look up ClampOkMap for its region. If present and DestArrayRegion\
  \ equals the destination array region for Arg0, then consider safe and return.\n\
  \   - This enhancement keeps state small and highly targeted to this bug pattern.\n\
  \n5. Notes and heuristics\n   - Only warn when destination is a compile-time constant-sized\
  \ array; skip otherwise to avoid false positives.\n   - Prefer Bound = sizeof(buf)\
  \ - 1 to align with the kernel\u2019s pattern in the patch. This matches the \u201C\
  string\u201D expectation that follows many debugfs writes.\n   - Do not attempt\
  \ to validate the return value (nbytes vs bsize) for this checker; focus strictly\
  \ on the overflow risk at copy_from_user.\n   - Keep the checker conservative: if\
  \ safety cannot be proven by any of the checks above, emit the warning."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include <string>\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// No custom program states\n\n\
  namespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"Unbounded copy_from_user into fixed-size buffer\", \"Security\"\
  )) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \n   private:\n\n      // Try to extract destination fixed-size array info (size\
  \ and name) from an expression.\n      bool getFixedArrayInfo(const Expr *DstExpr,\
  \ CheckerContext &C,\n                             llvm::APInt &ArraySize, std::string\
  \ &DestName) const;\n\n      // Try to determine if NExpr is syntactically clamped\
  \ with min(sizeof(Dest)...)\n      bool isClampedByMinSizeof(const Expr *NExpr,\
  \ StringRef DestName, CheckerContext &C) const;\n\n      // Check if a DeclRefExpr\
  \ refers to an integer-like local variable with an initializer\n      // that is\
  \ constant and <= bound or a min(sizeof(Dest), ...) pattern.\n      bool initializerProvesSafe(const\
  \ DeclRefExpr *DRE, uint64_t Bound,\n                                 StringRef\
  \ DestName, CheckerContext &C) const;\n\n      void report(const CallEvent &Call,\
  \ const Expr *SizeExpr,\n                  const Expr *DstExpr, CheckerContext &C)\
  \ const;\n};\n\nbool SAGenTestChecker::getFixedArrayInfo(const Expr *DstExpr, CheckerContext\
  \ &C,\n                                         llvm::APInt &ArraySize, std::string\
  \ &DestName) const {\n  if (!DstExpr)\n    return false;\n\n  // First, try direct\n\
  \  if (getArraySizeFromExpr(ArraySize, DstExpr)) {\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(DstExpr->IgnoreImplicit()))\
  \ {\n      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n        DestName\
  \ = VD->getName().str();\n      }\n    } else {\n      // Try to find a DRE for\
  \ name extraction\n      if (const auto *InnerDRE = findSpecificTypeInChildren<DeclRefExpr>(DstExpr))\
  \ {\n        if (const auto *VD = dyn_cast<VarDecl>(InnerDRE->getDecl())) {\n  \
  \        DestName = VD->getName().str();\n        }\n      }\n    }\n    return\
  \ true;\n  }\n\n  // Then, search downward for a DeclRefExpr that names the array\
  \ variable.\n  if (const auto *InnerDRE = findSpecificTypeInChildren<DeclRefExpr>(DstExpr))\
  \ {\n    if (getArraySizeFromExpr(ArraySize, InnerDRE)) {\n      if (const auto\
  \ *VD = dyn_cast<VarDecl>(InnerDRE->getDecl())) {\n        DestName = VD->getName().str();\n\
  \      }\n      return true;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isClampedByMinSizeof(const\
  \ Expr *NExpr, StringRef DestName,\n                                           \
  \ CheckerContext &C) const {\n  if (!NExpr)\n    return false;\n  // Heuristic syntactic\
  \ check: size expression mentions min, sizeof, and the destination array name.\n\
  \  if (ExprHasName(NExpr, \"min\", C) && ExprHasName(NExpr, \"sizeof\", C)) {\n\
  \    if (!DestName.empty() && ExprHasName(NExpr, DestName, C))\n      return true;\n\
  \  }\n  return false;\n}\n\nbool SAGenTestChecker::initializerProvesSafe(const DeclRefExpr\
  \ *DRE, uint64_t Bound,\n                                             StringRef\
  \ DestName, CheckerContext &C) const {\n  if (!DRE)\n    return false;\n  const\
  \ auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n    return false;\n\
  \n  const Expr *Init = VD->getInit();\n  if (!Init)\n    return false;\n\n  llvm::APSInt\
  \ InitVal;\n  if (EvaluateExprToInt(InitVal, Init, C)) {\n    uint64_t InitU = InitVal.getLimitedValue();\n\
  \    if (InitU <= Bound)\n      return true;\n  }\n\n  // Check for syntactic clamp\
  \ in initializer\n  if (isClampedByMinSizeof(Init, DestName, C))\n    return true;\n\
  \n  return false;\n}\n\nvoid SAGenTestChecker::report(const CallEvent &Call, const\
  \ Expr *SizeExpr,\n                              const Expr *DstExpr, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Unbounded copy_from_user into fixed-size buffer\", N);\n\n  if (SizeExpr)\n\
  \    R->addRange(SizeExpr->getSourceRange());\n  if (DstExpr)\n    R->addRange(DstExpr->getSourceRange());\n\
  \n  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return;\n\n  // Identify copy_from_user by source text name\
  \ to be robust with wrappers.\n  if (!ExprHasName(Origin, \"copy_from_user\", C))\n\
  \    return;\n\n  if (Call.getNumArgs() < 3)\n    return;\n\n  const Expr *DstExpr\
  \ = Call.getArgExpr(0);\n  const Expr *SizeExpr = Call.getArgExpr(2);\n  if (!DstExpr\
  \ || !SizeExpr)\n    return;\n\n  // Destination must be a fixed-size array in scope\n\
  \  llvm::APInt ArraySize;\n  std::string DestName;\n  if (!getFixedArrayInfo(DstExpr,\
  \ C, ArraySize, DestName))\n    return; // Only warn for fixed-size arrays we can\
  \ resolve\n\n  uint64_t ArrSizeU = ArraySize.getLimitedValue();\n  uint64_t Bound\
  \ = ArrSizeU > 0 ? (ArrSizeU - 1) : 0;\n\n  // Case A: Constant size\n  llvm::APSInt\
  \ ConstSizeVal;\n  if (EvaluateExprToInt(ConstSizeVal, SizeExpr, C)) {\n    uint64_t\
  \ N = ConstSizeVal.getLimitedValue();\n    if (N <= Bound)\n      return; // safe\n\
  \    report(Call, SizeExpr, DstExpr, C);\n    return;\n  }\n\n  // Case B: Symbolic\
  \ size with known maximum\n  SVal NVal = Call.getArgSVal(2);\n  if (SymbolRef Sym\
  \ = NVal.getAsSymbol()) {\n    if (const llvm::APSInt *MaxV = inferSymbolMaxVal(Sym,\
  \ C)) {\n      uint64_t MaxU = MaxV->getLimitedValue();\n      if (MaxU <= Bound)\n\
  \        return; // safe\n      // else continue with other syntactic checks\n \
  \   }\n  }\n\n  // Case C: Syntactic clamp pattern in the size expression itself\n\
  \  if (isClampedByMinSizeof(SizeExpr, DestName, C))\n    return; // safe\n\n  //\
  \ Case D: Size is a local variable with an initializer clamp\n  if (const auto *SizeDRE\
  \ = dyn_cast<DeclRefExpr>(SizeExpr->IgnoreParenCasts())) {\n    if (initializerProvesSafe(SizeDRE,\
  \ Bound, DestName, C))\n      return; // safe\n  }\n\n  // If none of the above\
  \ proves safety, report\n  report(Call, SizeExpr, DstExpr, C);\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unbounded copy_from_user into fixed-size buffers (missing min(sizeof(buf)-1,\
  \ nbytes) clamp)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
