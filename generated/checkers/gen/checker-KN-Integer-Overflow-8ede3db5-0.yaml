_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 8ede3db5061bb1fe28e2c9683329aafa89d2b1b4
commit_type: Integer-Overflow
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ state needed.\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n\
  \      : BT(new BugType(this, \"Overflow check defeated by narrowing cast\",\n \
  \                      \"Integer\")) {}\n\n  void checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n\nprivate:\n  // Returns the ExplicitCastExpr that\
  \ is suspicious, or nullptr if none.\n  const ExplicitCastExpr *isSuspiciousCastArg(const\
  \ Expr *ArgE,\n                                              QualType ResPointeeCanonical,\n\
  \                                              uint64_t ResWidthBits,\n        \
  \                                      ASTContext &ACtx) const;\n};\n\nconst ExplicitCastExpr\
  \ *SAGenTestChecker::isSuspiciousCastArg(\n    const Expr *ArgE, QualType ResPointeeCanonical,\
  \ uint64_t ResWidthBits,\n    ASTContext &ACtx) const {\n  if (!ArgE)\n    return\
  \ nullptr;\n\n  // Do not ignore explicit casts, but do ignore parens.\n  const\
  \ Expr *E = ArgE->IgnoreParens();\n  const auto *CE = dyn_cast<ExplicitCastExpr>(E);\n\
  \  if (!CE)\n    return nullptr;\n\n  QualType CastDestTy = CE->getType().getCanonicalType();\n\
  \  if (!CastDestTy->isIntegerType() || !CastDestTy->isSignedIntegerType())\n   \
  \ return nullptr;\n\n  if (CastDestTy != ResPointeeCanonical)\n    return nullptr;\n\
  \n  const Expr *Sub = CE->getSubExpr()->IgnoreImpCasts();\n  if (!Sub)\n    return\
  \ nullptr;\n\n  QualType SubTy = Sub->getType().getCanonicalType();\n  if (!SubTy->isIntegerType()\
  \ || !SubTy->isUnsignedIntegerType())\n    return nullptr;\n\n  uint64_t SubWidthBits\
  \ = ACtx.getTypeSize(SubTy);\n  if (SubWidthBits <= ResWidthBits)\n    return nullptr;\n\
  \n  return CE;\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call,\n\
  \                                    CheckerContext &C) const {\n  const Expr *Origin\
  \ = Call.getOriginExpr();\n  if (!Origin)\n    return;\n\n  // Prefer robust name\
  \ check using source text.\n  if (!ExprHasName(Origin, \"check_add_overflow\", C))\n\
  \    return;\n\n  if (Call.getNumArgs() != 3)\n    return;\n\n  // Get result argument\
  \ type: it must be pointer to signed integer type.\n  const Expr *ResArgE = Call.getArgExpr(2);\n\
  \  if (!ResArgE)\n    return;\n\n  QualType ResArgTy = ResArgE->getType();\n  const\
  \ Type *ResArgTyPtr = ResArgTy.getTypePtrOrNull();\n  if (!ResArgTyPtr || !ResArgTyPtr->isPointerType())\n\
  \    return;\n\n  QualType ResPointeeTy = ResArgTy->getPointeeType();\n  if (ResPointeeTy.isNull())\n\
  \    return;\n\n  if (!ResPointeeTy->isIntegerType() || !ResPointeeTy->isSignedIntegerType())\n\
  \    return;\n\n  ASTContext &ACtx = C.getASTContext();\n  QualType ResPointeeCanonical\
  \ = ResPointeeTy.getCanonicalType();\n  uint64_t ResWidthBits = ACtx.getTypeSize(ResPointeeCanonical);\n\
  \n  // Check first two operands for suspicious explicit narrowing cast.\n  const\
  \ ExplicitCastExpr *BadCast = nullptr;\n  for (unsigned i = 0; i < 2; ++i) {\n \
  \   const Expr *ArgE = Call.getArgExpr(i);\n    const ExplicitCastExpr *Candidate\
  \ =\n        isSuspiciousCastArg(ArgE, ResPointeeCanonical, ResWidthBits, ACtx);\n\
  \    if (Candidate) {\n      BadCast = Candidate;\n      break; // Report once per\
  \ callsite.\n    }\n  }\n\n  if (!BadCast)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Narrowing cast to signed type before check_add_overflow may hide \"\
  \n           \"overflow; avoid casting size-related values to int.\",\n      N);\n\
  \  R->addRange(BadCast->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n\
  } // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects narrowing signed casts to match result type before \"\n     \
  \ \"check_add_overflow that may hide overflow\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nio_uring/net: fix overflow check in io_recvmsg_mshot_prep()\n\
  \nThe \"controllen\" variable is type size_t (unsigned long).  Casting it\nto int\
  \ could lead to an integer underflow.\n\nThe check_add_overflow() function considers\
  \ the type of the destination\nwhich is type int.  If we add two positive values\
  \ and the result cannot\nfit in an integer then that's counted as an overflow.\n\
  \nHowever, if we cast \"controllen\" to an int and it turns negative, then\nnegative\
  \ values *can* fit into an int type so there is no overflow.\n\nGood: 100 + (unsigned\
  \ long)-4 = 96  <-- overflow\n Bad: 100 + (int)-4 = 96 <-- no overflow\n\nI deleted\
  \ the cast of the sizeof() as well.  That's not a bug but the\ncast is unnecessary.\n\
  \nFixes: 9b0fc3c054ff (\"io_uring: fix types in io_recvmsg_multishot_overflow\"\
  )\nSigned-off-by: Dan Carpenter <dan.carpenter@linaro.org>\nLink: https://lore.kernel.org/r/138bd2e2-ede8-4bcc-aa7b-f3d9de167a37@moroto.mountain\n\
  Signed-off-by: Jens Axboe <axboe@kernel.dk>\n\n## Buggy Code\n\n```c\n// Function:\
  \ io_recvmsg_mshot_prep in io_uring/net.c\nstatic int io_recvmsg_mshot_prep(struct\
  \ io_kiocb *req,\n\t\t\t\t struct io_async_msghdr *iomsg,\n\t\t\t\t int namelen,\
  \ size_t controllen)\n{\n\tif ((req->flags & (REQ_F_APOLL_MULTISHOT|REQ_F_BUFFER_SELECT))\
  \ ==\n\t\t\t  (REQ_F_APOLL_MULTISHOT|REQ_F_BUFFER_SELECT)) {\n\t\tint hdr;\n\n\t\
  \tif (unlikely(namelen < 0))\n\t\t\treturn -EOVERFLOW;\n\t\tif (check_add_overflow((int)sizeof(struct\
  \ io_uring_recvmsg_out),\n\t\t\t\t\tnamelen, &hdr))\n\t\t\treturn -EOVERFLOW;\n\t\
  \tif (check_add_overflow(hdr, (int)controllen, &hdr))\n\t\t\treturn -EOVERFLOW;\n\
  \n\t\tiomsg->namelen = namelen;\n\t\tiomsg->controllen = controllen;\n\t\treturn\
  \ 0;\n\t}\n\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/io_uring/net.c\
  \ b/io_uring/net.c\nindex 40d4542bfe2a..1640e985cd08 100644\n--- a/io_uring/net.c\n\
  +++ b/io_uring/net.c\n@@ -559,10 +559,10 @@ static int io_recvmsg_mshot_prep(struct\
  \ io_kiocb *req,\n \n \t\tif (unlikely(namelen < 0))\n \t\t\treturn -EOVERFLOW;\n\
  -\t\tif (check_add_overflow((int)sizeof(struct io_uring_recvmsg_out),\n+\t\tif (check_add_overflow(sizeof(struct\
  \ io_uring_recvmsg_out),\n \t\t\t\t\tnamelen, &hdr))\n \t\t\treturn -EOVERFLOW;\n\
  -\t\tif (check_add_overflow(hdr, (int)controllen, &hdr))\n+\t\tif (check_add_overflow(hdr,\
  \ controllen, &hdr))\n \t\t\treturn -EOVERFLOW;\n \n \t\tiomsg->namelen = namelen;\n\
  ```\n"
pattern: "## Bug Pattern\n\nCasting a size-related unsigned value (e.g., size_t) to\
  \ a narrower signed type (e.g., int) before an overflow check with check_add_overflow(),\
  \ where the result pointer is of the signed narrower type. This can turn large positive\
  \ inputs into negative values that fit in int, causing the overflow check to falsely\
  \ report \u201Cno overflow.\u201D\n\nExample:\n- Bad: check_add_overflow(hdr, (int)controllen,\
  \ &hdr);\n- Good: avoid narrowing cast; do not convert size_t to int before the\
  \ check."
plan: "1) Program state\n- No custom program state is needed. The bug is a local,\
  \ purely syntactic/type-mismatch pattern at a single callsite.\n\n2) Callbacks and\
  \ implementation steps\n- Use only checkPreCall. This is sufficient to analyze the\
  \ callsite of check_add_overflow() and its arguments.\n\nStep A \u2014 Identify\
  \ the target call\n- In checkPreCall(const CallEvent &Call, CheckerContext &C):\n\
  \  - Get callee identifier via Call.getCalleeIdentifier(); return if null.\n  -\
  \ If name != \"check_add_overflow\", return.\n  - Ensure there are exactly 3 arguments.\n\
  \  - Let ResArg = Call.getArgExpr(2). Get its type and assert it\u2019s a pointer\
  \ type.\n  - Let ResTy = ResArg->getType()->getPointeeType(). If ResTy is not an\
  \ integer type, return. If it\u2019s an unsigned integer type, return (the reported\
  \ pattern requires a signed destination).\n  - Record ResTyCanonical = ResTy.getCanonicalType(),\
  \ and compute ResWidthBits = C.getASTContext().getTypeSize(ResTy).\n\nStep B \u2014\
  \ Detect the suspicious narrowing signed cast on operands\n- For each of the first\
  \ two arguments (i = 0, 1):\n  - Let E = Call.getArgExpr(i)->IgnoreParens() (do\
  \ not ignore explicit casts).\n  - Check if E is an explicit cast expression:\n\
  \    - Prefer dyn_cast<ExplicitCastExpr>(E). This matches CStyleCastExpr and C++\
  \ explicit casts. If it is not an ExplicitCastExpr, continue to next argument.\n\
  \  - Let CastDestTy = CastExpr->getType().getCanonicalType().\n  - Require:\n  \
  \  - CastDestTy is an integer type and isSignedIntegerType().\n    - CastDestTy\
  \ is the same as ResTyCanonical (the result pointer\u2019s base type).\n  - Let\
  \ Sub = CastExpr->getSubExpr()->IgnoreImpCasts(); let SubTy = Sub->getType().getCanonicalType().\n\
  \  - Require:\n    - SubTy is an integer type and SubTy isUnsignedIntegerType().\n\
  \    - Compute SubWidthBits = C.getASTContext().getTypeSize(SubTy).\n    - SubWidthBits\
  \ > ResWidthBits (this ensures the cast is a narrowing from a wider unsigned type,\
  \ like size_t, to a narrower signed type, like int).\n  - If all conditions hold,\
  \ this argument is suspicious.\n\nStep C \u2014 Report once per callsite\n- If either\
  \ argument 0 or 1 is suspicious (as per Step B), emit a bug report:\n  - Create\
  \ a BugType once (e.g., checker member) named \"Overflow check defeated by narrowing\
  \ cast\".\n  - Generate a non-fatal error node: if (!N) return; N = C.generateNonFatalErrorNode().\n\
  \  - Message: \"Narrowing cast to signed type before check_add_overflow may hide\
  \ overflow; avoid casting size-related values to int.\"\n  - Highlight the explicit\
  \ cast source range (use the ExplicitCastExpr\u2019s source range).\n  - Use PathSensitiveBugReport\
  \ with the created BugType and message, and emit via C.emitReport().\n\nNotes and\
  \ heuristics\n- This checker intentionally requires the explicit cast destination\
  \ type to match the result pointer\u2019s base integer type (e.g., int). This keeps\
  \ the signal precise and directly matches the kernel bug pattern:\n  - Bad: check_add_overflow(hdr,\
  \ (int)controllen, &hdr) where hdr is int.\n  - Bad: check_add_overflow((int)sizeof(...),\
  \ namelen, &hdr) where hdr is int.\n- The check covers both operands. If both are\
  \ suspicious, report once for the first encountered; this avoids duplicate diagnostics\
  \ per callsite.\n- The first-argument sizeof case is naturally handled because sizeof\
  \ returns a size_t-typed expression (unsigned, usually wider than int), and an explicit\
  \ cast to int meets the heuristic.\n\nUtility functions usage\n- No program state\
  \ utility needed.\n- Use C.getASTContext() to get type sizes for the narrowing check.\n\
  - No taint or alias analysis is involved.\n- Optionally use ExprHasName if you later\
  \ generalize to detect other overflow helpers, but not needed for the current plan.\n\
  \nChosen callbacks summary\n- checkPreCall:\n  - Match \"check_add_overflow\".\n\
  \  - Extract result pointer pointee type; require signed integer.\n  - Detect explicit\
  \ cast of an unsigned wider integer to the same signed type as the result (int)\
  \ in either operand.\n  - Report with concise message and highlight the cast."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ state needed.\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n\
  \      : BT(new BugType(this, \"Overflow check defeated by narrowing cast\",\n \
  \                      \"Integer\")) {}\n\n  void checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n\nprivate:\n  // Returns the ExplicitCastExpr that\
  \ is suspicious, or nullptr if none.\n  const ExplicitCastExpr *isSuspiciousCastArg(const\
  \ Expr *ArgE,\n                                              QualType ResPointeeCanonical,\n\
  \                                              uint64_t ResWidthBits,\n        \
  \                                      ASTContext &ACtx) const;\n};\n\nconst ExplicitCastExpr\
  \ *SAGenTestChecker::isSuspiciousCastArg(\n    const Expr *ArgE, QualType ResPointeeCanonical,\
  \ uint64_t ResWidthBits,\n    ASTContext &ACtx) const {\n  if (!ArgE)\n    return\
  \ nullptr;\n\n  // Do not ignore explicit casts, but do ignore parens.\n  const\
  \ Expr *E = ArgE->IgnoreParens();\n  const auto *CE = dyn_cast<ExplicitCastExpr>(E);\n\
  \  if (!CE)\n    return nullptr;\n\n  QualType CastDestTy = CE->getType().getCanonicalType();\n\
  \  if (!CastDestTy->isIntegerType() || !CastDestTy->isSignedIntegerType())\n   \
  \ return nullptr;\n\n  if (CastDestTy != ResPointeeCanonical)\n    return nullptr;\n\
  \n  const Expr *Sub = CE->getSubExpr()->IgnoreImpCasts();\n  if (!Sub)\n    return\
  \ nullptr;\n\n  QualType SubTy = Sub->getType().getCanonicalType();\n  if (!SubTy->isIntegerType()\
  \ || !SubTy->isUnsignedIntegerType())\n    return nullptr;\n\n  uint64_t SubWidthBits\
  \ = ACtx.getTypeSize(SubTy);\n  if (SubWidthBits <= ResWidthBits)\n    return nullptr;\n\
  \n  return CE;\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call,\n\
  \                                    CheckerContext &C) const {\n  const Expr *Origin\
  \ = Call.getOriginExpr();\n  if (!Origin)\n    return;\n\n  // Prefer robust name\
  \ check using source text.\n  if (!ExprHasName(Origin, \"check_add_overflow\", C))\n\
  \    return;\n\n  if (Call.getNumArgs() != 3)\n    return;\n\n  // Get result argument\
  \ type: it must be pointer to signed integer type.\n  const Expr *ResArgE = Call.getArgExpr(2);\n\
  \  if (!ResArgE)\n    return;\n\n  QualType ResArgTy = ResArgE->getType();\n  const\
  \ Type *ResArgTyPtr = ResArgTy.getTypePtrOrNull();\n  if (!ResArgTyPtr || !ResArgTyPtr->isPointerType())\n\
  \    return;\n\n  QualType ResPointeeTy = ResArgTy->getPointeeType();\n  if (ResPointeeTy.isNull())\n\
  \    return;\n\n  if (!ResPointeeTy->isIntegerType() || !ResPointeeTy->isSignedIntegerType())\n\
  \    return;\n\n  ASTContext &ACtx = C.getASTContext();\n  QualType ResPointeeCanonical\
  \ = ResPointeeTy.getCanonicalType();\n  uint64_t ResWidthBits = ACtx.getTypeSize(ResPointeeCanonical);\n\
  \n  // Check first two operands for suspicious explicit narrowing cast.\n  const\
  \ ExplicitCastExpr *BadCast = nullptr;\n  for (unsigned i = 0; i < 2; ++i) {\n \
  \   const Expr *ArgE = Call.getArgExpr(i);\n    const ExplicitCastExpr *Candidate\
  \ =\n        isSuspiciousCastArg(ArgE, ResPointeeCanonical, ResWidthBits, ACtx);\n\
  \    if (Candidate) {\n      BadCast = Candidate;\n      break; // Report once per\
  \ callsite.\n    }\n  }\n\n  if (!BadCast)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Narrowing cast to signed type before check_add_overflow may hide \"\
  \n           \"overflow; avoid casting size-related values to int.\",\n      N);\n\
  \  R->addRange(BadCast->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n\
  } // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects narrowing signed casts to match result type before \"\n     \
  \ \"check_add_overflow that may hide overflow\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
