_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3b0daecfeac0103aba8b293df07a0cbaf8b43f29
commit_type: Integer-Overflow
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states are necessary.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Array allocation\
  \ with kmalloc/kzalloc may overflow\", \"Memory\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n      // Returns true\
  \ if E represents a multiplication that contains a sizeof(...)\n      // term and\
  \ another \"count\" term. Outputs CountExpr and SizeofExpr on success.\n      static\
  \ bool isMulOfSizeof(const Expr *E, const Expr *&CountExpr, const Expr *&SizeofExpr);\n\
  \n      // Helper to check if an expression is a sizeof.\n      static bool isSizeOfExpr(const\
  \ Expr *E);\n\n      // Helper to match allocator names using ExprHasName.\n   \
  \   static bool isTargetAllocator(const CallEvent &Call, CheckerContext &C);\n};\n\
  \nbool SAGenTestChecker::isSizeOfExpr(const Expr *E) {\n  E = E ? E->IgnoreParenImpCasts()\
  \ : nullptr;\n  if (!E) return false;\n  if (const auto *UETT = dyn_cast<UnaryExprOrTypeTraitExpr>(E))\
  \ {\n    return UETT->getKind() == UETT_SizeOf;\n  }\n  return false;\n}\n\nbool\
  \ SAGenTestChecker::isMulOfSizeof(const Expr *E, const Expr *&CountExpr, const Expr\
  \ *&SizeofExpr) {\n  CountExpr = nullptr;\n  SizeofExpr = nullptr;\n  if (!E) return\
  \ false;\n\n  const Expr *EE = E->IgnoreParenImpCasts();\n\n  auto TryFromBO = [&](const\
  \ BinaryOperator *BO) -> bool {\n    if (!BO || BO->getOpcode() != BO_Mul)\n   \
  \   return false;\n\n    const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \    const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n\n    if (isSizeOfExpr(L))\
  \ {\n      SizeofExpr = L;\n      CountExpr = R;\n      return true;\n    }\n  \
  \  if (isSizeOfExpr(R)) {\n      SizeofExpr = R;\n      CountExpr = L;\n      return\
  \ true;\n    }\n    return false;\n  };\n\n  if (const auto *TopBO = dyn_cast<BinaryOperator>(EE))\
  \ {\n    if (TryFromBO(TopBO))\n      return true;\n  }\n\n  // Look deeper in the\
  \ expression tree for a multiplication node.\n  if (const auto *InnerBO = findSpecificTypeInChildren<BinaryOperator>(EE))\
  \ {\n    return TryFromBO(InnerBO);\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isTargetAllocator(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Target functions:\n  // kmalloc(size,\
  \ gfp)\n  // kzalloc(size, gfp)\n  // __kmalloc(size, gfp)\n  // kmalloc_node(size,\
  \ gfp, node)\n  // kzalloc_node(size, gfp, node)\n  static const char *Targets[]\
  \ = {\n      \"kmalloc\", \"kzalloc\", \"__kmalloc\", \"kmalloc_node\", \"kzalloc_node\"\
  \n  };\n\n  for (const char *Name : Targets) {\n    if (ExprHasName(Origin, Name,\
  \ C))\n      return true;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isTargetAllocator(Call, C))\n\
  \    return;\n\n  if (Call.getNumArgs() < 1)\n    return;\n\n  const Expr *SizeArgE\
  \ = Call.getArgExpr(0);\n  if (!SizeArgE)\n    return;\n\n  const Expr *CountExpr\
  \ = nullptr;\n  const Expr *SizeofExpr = nullptr;\n  if (!isMulOfSizeof(SizeArgE,\
  \ CountExpr, SizeofExpr))\n    return;\n\n  // Suppress if the count is a compile-time\
  \ constant to reduce noise.\n  llvm::APSInt EvalRes;\n  if (CountExpr && EvaluateExprToInt(EvalRes,\
  \ CountExpr, C)) {\n    return; // Constant count - skip warning.\n  }\n\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"kmalloc/kzalloc size uses count * element size; use kcalloc(count,\
  \ elem_size, ...) to avoid overflow\",\n      N);\n\n  R->addRange(SizeArgE->getSourceRange());\n\
  \  if (CountExpr)\n    R->addRange(CountExpr->getSourceRange());\n  if (SizeofExpr)\n\
  \    R->addRange(SizeofExpr->getSourceRange());\n\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects kmalloc/kzalloc array allocations using count*sizeof that may\
  \ overflow; suggests kcalloc\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\namdkfd: use calloc instead of kzalloc to avoid integer\
  \ overflow\n\nThis uses calloc instead of doing the multiplication which might\n\
  overflow.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: kfd_ioctl_get_process_apertures_new in drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\t\t\t\tstruct\
  \ kfd_process *p, void *data)\n{\n\tstruct kfd_ioctl_get_process_apertures_new_args\
  \ *args = data;\n\tstruct kfd_process_device_apertures *pa;\n\tint ret;\n\tint i;\n\
  \n\tdev_dbg(kfd_device, \"get apertures for PASID 0x%x\", p->pasid);\n\n\tif (args->num_of_nodes\
  \ == 0) {\n\t\t/* Return number of nodes, so that user space can alloacate\n\t\t\
  \ * sufficient memory\n\t\t */\n\t\tmutex_lock(&p->mutex);\n\t\targs->num_of_nodes\
  \ = p->n_pdds;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Fill in process-aperture information\
  \ for all available\n\t * nodes, but not more than args->num_of_nodes as that is\n\
  \t * the amount of memory allocated by user\n\t */\n\tpa = kzalloc((sizeof(struct\
  \ kfd_process_device_apertures) *\n\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n\t\
  if (!pa)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&p->mutex);\n\n\tif (!p->n_pdds) {\n\
  \t\targs->num_of_nodes = 0;\n\t\tkfree(pa);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Run\
  \ over all pdd of the process */\n\tfor (i = 0; i < min(p->n_pdds, args->num_of_nodes);\
  \ i++) {\n\t\tstruct kfd_process_device *pdd = p->pdds[i];\n\n\t\tpa[i].gpu_id =\
  \ pdd->dev->id;\n\t\tpa[i].lds_base = pdd->lds_base;\n\t\tpa[i].lds_limit = pdd->lds_limit;\n\
  \t\tpa[i].gpuvm_base = pdd->gpuvm_base;\n\t\tpa[i].gpuvm_limit = pdd->gpuvm_limit;\n\
  \t\tpa[i].scratch_base = pdd->scratch_base;\n\t\tpa[i].scratch_limit = pdd->scratch_limit;\n\
  \n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpu id %u\\n\", pdd->dev->id);\n\t\tdev_dbg(kfd_device,\n\
  \t\t\t\"lds_base %llX\\n\", pdd->lds_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"lds_limit\
  \ %llX\\n\", pdd->lds_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_base %llX\\\
  n\", pdd->gpuvm_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_limit %llX\\n\",\
  \ pdd->gpuvm_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_base %llX\\n\", pdd->scratch_base);\n\
  \t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_limit %llX\\n\", pdd->scratch_limit);\n\
  \t}\n\tmutex_unlock(&p->mutex);\n\n\targs->num_of_nodes = i;\n\tret = copy_to_user(\n\
  \t\t\t(void __user *)args->kfd_process_device_apertures_ptr,\n\t\t\tpa,\n\t\t\t\
  (i * sizeof(struct kfd_process_device_apertures)));\n\tkfree(pa);\n\treturn ret\
  \ ? -EFAULT : 0;\n\nout_unlock:\n\tmutex_unlock(&p->mutex);\n\treturn 0;\n}\n```\n\
  \n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\
  \ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\nindex f9631f4b1a02..55aa74cbc532 100644\n\
  --- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  @@ -779,8 +779,8 @@ static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\
  \ \t * nodes, but not more than args->num_of_nodes as that is\n \t * the amount\
  \ of memory allocated by user\n \t */\n-\tpa = kzalloc((sizeof(struct kfd_process_device_apertures)\
  \ *\n-\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n+\tpa = kcalloc(args->num_of_nodes,\
  \ sizeof(struct kfd_process_device_apertures),\n+\t\t     GFP_KERNEL);\n \tif (!pa)\n\
  \ \t\treturn -ENOMEM;\n \n```\n"
pattern: '## Bug Pattern


  Allocating an array with kmalloc/kzalloc using a manually multiplied size without
  overflow checking, where the element count may be large or user-controlled:

  pa = kzalloc(sizeof(struct kfd_process_device_apertures) * args->num_of_nodes, GFP_KERNEL);


  This can overflow the multiplication, allocate too small a buffer, and lead to out-of-bounds
  writes when populating up to args->num_of_nodes elements. The correct pattern is
  to use kcalloc(count, size, GFP_KERNEL), which performs overflow checking:

  pa = kcalloc(args->num_of_nodes, sizeof(struct kfd_process_device_apertures), GFP_KERNEL);'
plan: "Plan\n\n1. Program state\n- No custom program state is necessary. This checker\
  \ is purely syntactic/semantic on the call expression and its size argument.\n\n\
  2. Callback functions\n- Use only checkPreCall. It is sufficient to:\n  - Identify\
  \ calls to kmalloc/kzalloc-like allocators that take a single size parameter.\n\
  \  - Inspect the size argument\u2019s AST for a \u201Csizeof(.) * count\u201D (or\
  \ count * sizeof(.)) multiplication pattern.\n  - Suppress the report if the \u201C\
  count\u201D side is a compile-time constant.\n  - Emit a concise warning suggesting\
  \ kcalloc.\n\n3. Targets and matching\n- Functions to flag:\n  - kmalloc(size, gfp)\n\
  \  - kzalloc(size, gfp)\n  - __kmalloc(size, gfp)\n  - kmalloc_node(size, gfp, node)\n\
  \  - kzalloc_node(size, gfp, node)\n- Ignore already-safe APIs: kcalloc, kmalloc_array,\
  \ kvmalloc_array, kvcalloc, struct_size, array_size, etc. We only match the above\
  \ \u201Cone size argument\u201D kmalloc-like functions.\n\n4. checkPreCall implementation\n\
  - Step A: Identify target allocator\n  - Get the callee name with Call.getCalleeIdentifier()->getName().\n\
  \  - If not in {\"kmalloc\", \"kzalloc\", \"__kmalloc\", \"kmalloc_node\", \"kzalloc_node\"\
  }, return.\n- Step B: Obtain the size expression\n  - For all matched functions,\
  \ the first argument (index 0) is the size.\n  - Expr *SizeArg = Call.getArgExpr(0)->IgnoreParenImpCasts().\n\
  - Step C: Detect \u201Csizeof * count\u201D pattern\n  - Define a small helper:\
  \ bool isMulOfSizeof(const Expr *E, const Expr *&CountExpr, const Expr *&SizeofExpr).\n\
  \    - If E is a BinaryOperator with opcode BO_Mul:\n      - Let L = LHS->IgnoreParenImpCasts(),\
  \ R = RHS->IgnoreParenImpCasts().\n      - If L is a UnaryExprOrTypeTraitExpr of\
  \ kind UETT_SizeOf, then CountExpr = R and SizeofExpr = L, return true.\n      -\
  \ Else if R is UETT_SizeOf, then CountExpr = L and SizeofExpr = R, return true.\n\
  \    - Otherwise, try to find a multiplication deeper in the tree:\n      - Use\
  \ findSpecificTypeInChildren<BinaryOperator>(E) to get a sub-multiplication (if\
  \ any) and apply the above \u201CL/R\u201D logic. If none, return false.\n- Step\
  \ D: Suppress obvious constants\n  - If isMulOfSizeof(SizeArg, CountExpr, SizeofExpr)\
  \ is false, return.\n  - Try to evaluate CountExpr to a constant with EvaluateExprToInt(...,\
  \ CountExpr, C).\n    - If true (constant), do not warn to avoid noisy false positives\
  \ for fixed-size arrays.\n- Step E: Emit the report\n  - Create a BugType once (e.g.,\
  \ \u201Ckmalloc/kzalloc array allocation overflow risk\u201D).\n  - Use C.generateNonFatalErrorNode()\
  \ to get an error node.\n  - Emit a PathSensitiveBugReport (or BasicBugReport) with\
  \ a short message, e.g.:\n    - \u201Ckmalloc/kzalloc size uses count * element\
  \ size; use kcalloc(count, elem_size, ...) to avoid overflow.\u201D\n  - Optionally,\
  \ add source ranges:\n    - Highlight the SizeArg range.\n    - If available, also\
  \ highlight CountExpr and SizeofExpr subranges for clarity.\n\n5. Helper details\n\
  - isMulOfSizeof:\n  - Prefer checking the top-level BinaryOperator first (fast path).\n\
  \  - If not a BinaryOperator at the top, use findSpecificTypeInChildren<BinaryOperator>\
  \ to find a multiplication somewhere in the size expression (to catch cases like\
  \ casts and parenthesized expressions).\n  - Accept both sizeof(type) and sizeof(expr)\
  \ via UnaryExprOrTypeTraitExpr (UETT_SizeOf).\n- Constant suppression:\n  - Use\
  \ the provided EvaluateExprToInt to filter out expressions that evaluate to a compile-time\
  \ integer. If EvaluateExprToInt returns true, skip reporting.\n- False-positive\
  \ control (kept simple on purpose):\n  - Do not attempt to track pre-call overflow\
  \ guards (e.g., \u201Cif (n > ULONG_MAX / sizeof(T)) ...\u201D). Keeping the checker\
  \ simple and focused: it warns on non-constant count multiplications and suggests\
  \ kcalloc. This matches the typical kernel recommendation and the provided patch.\n\
  \n6. Notes/edges the checker will handle\n- Handles both n * sizeof(T) and sizeof(T)\
  \ * n (either operand).\n- Handles implicit/explicit casts and parentheses around\
  \ operands via IgnoreParenImpCasts.\n- Will not warn on direct calls to kcalloc/kmalloc_array/kvcalloc/kvmalloc_array/etc.\n\
  - Keeps noise low by suppressing constant-count patterns.\n\n7. Reporting\n- One\
  \ concise message per detected call site:\n  - Title: \u201CArray allocation with\
  \ kmalloc/kzalloc may overflow\u201D\n  - Message: \u201Ckmalloc/kzalloc size uses\
  \ count * element size; use kcalloc(count, elem_size, ...) to avoid overflow.\u201D\
  \n- Use std::make_unique<PathSensitiveBugReport> on the created node and C.emitReport."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states are necessary.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Array allocation\
  \ with kmalloc/kzalloc may overflow\", \"Memory\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n      // Returns true\
  \ if E represents a multiplication that contains a sizeof(...)\n      // term and\
  \ another \"count\" term. Outputs CountExpr and SizeofExpr on success.\n      static\
  \ bool isMulOfSizeof(const Expr *E, const Expr *&CountExpr, const Expr *&SizeofExpr);\n\
  \n      // Helper to check if an expression is a sizeof.\n      static bool isSizeOfExpr(const\
  \ Expr *E);\n\n      // Helper to match allocator names using ExprHasName.\n   \
  \   static bool isTargetAllocator(const CallEvent &Call, CheckerContext &C);\n};\n\
  \nbool SAGenTestChecker::isSizeOfExpr(const Expr *E) {\n  E = E ? E->IgnoreParenImpCasts()\
  \ : nullptr;\n  if (!E) return false;\n  if (const auto *UETT = dyn_cast<UnaryExprOrTypeTraitExpr>(E))\
  \ {\n    return UETT->getKind() == UETT_SizeOf;\n  }\n  return false;\n}\n\nbool\
  \ SAGenTestChecker::isMulOfSizeof(const Expr *E, const Expr *&CountExpr, const Expr\
  \ *&SizeofExpr) {\n  CountExpr = nullptr;\n  SizeofExpr = nullptr;\n  if (!E) return\
  \ false;\n\n  const Expr *EE = E->IgnoreParenImpCasts();\n\n  auto TryFromBO = [&](const\
  \ BinaryOperator *BO) -> bool {\n    if (!BO || BO->getOpcode() != BO_Mul)\n   \
  \   return false;\n\n    const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \    const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n\n    if (isSizeOfExpr(L))\
  \ {\n      SizeofExpr = L;\n      CountExpr = R;\n      return true;\n    }\n  \
  \  if (isSizeOfExpr(R)) {\n      SizeofExpr = R;\n      CountExpr = L;\n      return\
  \ true;\n    }\n    return false;\n  };\n\n  if (const auto *TopBO = dyn_cast<BinaryOperator>(EE))\
  \ {\n    if (TryFromBO(TopBO))\n      return true;\n  }\n\n  // Look deeper in the\
  \ expression tree for a multiplication node.\n  if (const auto *InnerBO = findSpecificTypeInChildren<BinaryOperator>(EE))\
  \ {\n    return TryFromBO(InnerBO);\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isTargetAllocator(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Target functions:\n  // kmalloc(size,\
  \ gfp)\n  // kzalloc(size, gfp)\n  // __kmalloc(size, gfp)\n  // kmalloc_node(size,\
  \ gfp, node)\n  // kzalloc_node(size, gfp, node)\n  static const char *Targets[]\
  \ = {\n      \"kmalloc\", \"kzalloc\", \"__kmalloc\", \"kmalloc_node\", \"kzalloc_node\"\
  \n  };\n\n  for (const char *Name : Targets) {\n    if (ExprHasName(Origin, Name,\
  \ C))\n      return true;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isTargetAllocator(Call, C))\n\
  \    return;\n\n  if (Call.getNumArgs() < 1)\n    return;\n\n  const Expr *SizeArgE\
  \ = Call.getArgExpr(0);\n  if (!SizeArgE)\n    return;\n\n  const Expr *CountExpr\
  \ = nullptr;\n  const Expr *SizeofExpr = nullptr;\n  if (!isMulOfSizeof(SizeArgE,\
  \ CountExpr, SizeofExpr))\n    return;\n\n  // Suppress if the count is a compile-time\
  \ constant to reduce noise.\n  llvm::APSInt EvalRes;\n  if (CountExpr && EvaluateExprToInt(EvalRes,\
  \ CountExpr, C)) {\n    return; // Constant count - skip warning.\n  }\n\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"kmalloc/kzalloc size uses count * element size; use kcalloc(count,\
  \ elem_size, ...) to avoid overflow\",\n      N);\n\n  R->addRange(SizeArgE->getSourceRange());\n\
  \  if (CountExpr)\n    R->addRange(CountExpr->getSourceRange());\n  if (SizeofExpr)\n\
  \    R->addRange(SizeofExpr->getSourceRange());\n\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects kmalloc/kzalloc array allocations using count*sizeof that may\
  \ overflow; suggests kcalloc\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
