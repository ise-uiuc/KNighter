_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 67801fa67b94ebd0e4da7a77ac2d9f321b75fbe0
commit_type: UAF
index: 4
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state: published object regions and those modified after publishing.\n\
  REGISTER_SET_WITH_PROGRAMSTATE(PublishedSet, const MemRegion*)\nREGISTER_SET_WITH_PROGRAMSTATE(ModifiedAfterPublishSet,\
  \ const MemRegion*)\n// Map a published region to the call site where it was published\
  \ (for diagnostics).\nREGISTER_MAP_WITH_PROGRAMSTATE(PublishCallSiteMap, const MemRegion*,\
  \ const Stmt*)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n \
  \       check::PostCall,\n        check::PreCall,\n        check::Bind,\n      \
  \  check::PreStmt<ReturnStmt>\n     > {\n\n  mutable std::unique_ptr<BugType> BT;\n\
  \npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Publishing object\
  \ before final initialization\",\n                       \"Concurrency\")) {}\n\n\
  \  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n  void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkBind(SVal Loc, SVal Val,\
  \ const Stmt *S, CheckerContext &C) const;\n  void checkPreStmt(const ReturnStmt\
  \ *RS, CheckerContext &C) const;\n\nprivate:\n  // Helper: identify known \"publish\
  \ to ID registry\" calls and provide entry arg index.\n  bool isPublishCall(const\
  \ CallEvent &Call, CheckerContext &C,\n                     unsigned &EntryIndex)\
  \ const;\n\n  // Helper: get pointee base region from a call argument by index.\n\
  \  const MemRegion *getArgPointeeBaseRegion(const CallEvent &Call, unsigned Idx)\
  \ const;\n\n  // Helper: from a location SVal get the root/base region of the object\
  \ being written.\n  const MemRegion *getRootBaseFromLoc(SVal Loc) const;\n\n  //\
  \ Mark region as modified after publish.\n  ProgramStateRef markModifiedAfterPublish(ProgramStateRef\
  \ State,\n                                           const MemRegion *BaseR) const;\n\
  \n  // Report bug for a region.\n  void reportForRegion(const MemRegion *R, const\
  \ Stmt *PublishSite,\n                       CheckerContext &C) const;\n};\n\nbool\
  \ SAGenTestChecker::isPublishCall(const CallEvent &Call, CheckerContext &C,\n  \
  \                                   unsigned &EntryIndex) const {\n  const Expr\
  \ *E = Call.getOriginExpr();\n  if (!E)\n    return false;\n\n  // Known registry\
  \ publish APIs and their entry/object parameter index.\n  // - xa_alloc(xa, idp,\
  \ entry, limit, gfp)\n  if (ExprHasName(E, \"xa_alloc\", C)) {\n    EntryIndex =\
  \ 2;\n    return true;\n  }\n  // - xa_store(xa, index, entry, gfp) (optional)\n\
  \  if (ExprHasName(E, \"xa_store\", C)) {\n    EntryIndex = 2;\n    return true;\n\
  \  }\n  // - idr_alloc(idr, entry, start, end, gfp)\n  if (ExprHasName(E, \"idr_alloc\"\
  , C)) {\n    EntryIndex = 1;\n    return true;\n  }\n  // - idr_alloc_u32(idr, entry,\
  \ idp, gfp)\n  if (ExprHasName(E, \"idr_alloc_u32\", C)) {\n    EntryIndex = 1;\n\
  \    return true;\n  }\n  // - idr_alloc_cyclic(idr, entry, start, end, gfp)\n \
  \ if (ExprHasName(E, \"idr_alloc_cyclic\", C)) {\n    EntryIndex = 1;\n    return\
  \ true;\n  }\n\n  return false;\n}\n\nconst MemRegion *SAGenTestChecker::getArgPointeeBaseRegion(const\
  \ CallEvent &Call,\n                                                           unsigned\
  \ Idx) const {\n  if (Idx >= Call.getNumArgs())\n    return nullptr;\n  SVal ArgV\
  \ = Call.getArgSVal(Idx);\n  const MemRegion *R = ArgV.getAsRegion();\n  if (!R)\n\
  \    return nullptr;\n  return R->getBaseRegion();\n}\n\nconst MemRegion *SAGenTestChecker::getRootBaseFromLoc(SVal\
  \ Loc) const {\n  if (const MemRegion *R = Loc.getAsRegion())\n    return R->getBaseRegion();\n\
  \  return nullptr;\n}\n\nProgramStateRef\nSAGenTestChecker::markModifiedAfterPublish(ProgramStateRef\
  \ State,\n                                           const MemRegion *BaseR) const\
  \ {\n  if (!BaseR)\n    return State;\n  if (State->contains<PublishedSet>(BaseR))\
  \ {\n    State = State->add<ModifiedAfterPublishSet>(BaseR);\n  }\n  return State;\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\n             \
  \                        CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  unsigned EntryIndex = 0;\n  if (!isPublishCall(Call, C, EntryIndex))\n    return;\n\
  \n  const MemRegion *EntryBase = getArgPointeeBaseRegion(Call, EntryIndex);\n  if\
  \ (!EntryBase)\n    return;\n\n  // Mark as published and remember call site for\
  \ diagnostics.\n  State = State->add<PublishedSet>(EntryBase);\n  if (const Stmt\
  \ *S = Call.getOriginExpr()) {\n    State = State->set<PublishCallSiteMap>(EntryBase,\
  \ S);\n  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call,\n                                    CheckerContext &C) const\
  \ {\n  ProgramStateRef State = C.getState();\n\n  // Don't consider publish calls\
  \ themselves as \"modifications after publish\".\n  unsigned DummyIdx = 0;\n  if\
  \ (isPublishCall(Call, C, DummyIdx))\n    return;\n\n  // If a known-dereferencing\
  \ function is called with a published object,\n  // consider that as \"used/modified\
  \ after publish\".\n  llvm::SmallVector<unsigned, 4> DerefParams;\n  bool HasKnownDeref\
  \ = functionKnownToDeref(Call, DerefParams);\n\n  if (HasKnownDeref) {\n    for\
  \ (unsigned PI : DerefParams) {\n      const MemRegion *ArgBase = getArgPointeeBaseRegion(Call,\
  \ PI);\n      if (!ArgBase)\n        continue;\n      if (State->contains<PublishedSet>(ArgBase))\
  \ {\n        State = State->add<ModifiedAfterPublishSet>(ArgBase);\n      }\n  \
  \  }\n  }\n\n  if (State != C.getState())\n    C.addTransition(State);\n}\n\nvoid\
  \ SAGenTestChecker::checkBind(SVal Loc, SVal /*Val*/, const Stmt *S,\n         \
  \                        CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Any write into a field/element of a published object after it was published.\n\
  \  const MemRegion *BaseR = getRootBaseFromLoc(Loc);\n  if (!BaseR)\n    return;\n\
  \n  if (State->contains<PublishedSet>(BaseR)) {\n    State = State->add<ModifiedAfterPublishSet>(BaseR);\n\
  \    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::reportForRegion(const\
  \ MemRegion *R, const Stmt *PublishSite,\n                                     \
  \  CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto Rpt = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Object inserted into ID registry before final initialization; \"\n\
  \           \"make xa_alloc/idr_alloc the last step.\",\n      N);\n\n  if (PublishSite)\
  \ {\n    Rpt->addRange(PublishSite->getSourceRange());\n  }\n  C.emitReport(std::move(Rpt));\n\
  }\n\nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt *RS,\n               \
  \                     CheckerContext &C) const {\n  if (!RS)\n    return;\n\n  const\
  \ Expr *Ret = RS->getRetValue();\n  if (!Ret)\n    return;\n\n  llvm::APSInt RetVal;\n\
  \  if (!EvaluateExprToInt(RetVal, Ret, C))\n    return;\n\n  // Only warn on success\
  \ return (commonly 0).\n  if (RetVal != 0)\n    return;\n\n  ProgramStateRef State\
  \ = C.getState();\n  auto ModifiedSet = State->get<ModifiedAfterPublishSet>();\n\
  \  if (ModifiedSet.isEmpty())\n    return;\n\n  for (auto It = ModifiedSet.begin();\
  \ It != ModifiedSet.end(); ++It) {\n    const MemRegion *R = *It;\n    if (!R)\n\
  \      continue;\n\n    if (State->contains<PublishedSet>(R)) {\n      const Stmt\
  \ *PubSite = nullptr;\n      if (const Stmt *const *P = State->get<PublishCallSiteMap>(R))\n\
  \        PubSite = *P;\n\n      reportForRegion(R, PubSite, C);\n    }\n  }\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects publishing objects into ID registries (xa/idr) before final initialization\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/xe/queue: move xa_alloc to prevent UAF\n\nEvil\
  \ user can guess the next id of the queue before the ioctl completes\nand then call\
  \ queue destroy ioctl to trigger UAF since create ioctl is\nstill referencing the\
  \ same queue. Move the xa_alloc all the way to the end\nto prevent this.\n\nv2:\n\
  \ - Rebase\n\nFixes: 2149ded63079 (\"drm/xe: Fix use after free when client stats\
  \ are captured\")\nSigned-off-by: Matthew Auld <matthew.auld@intel.com>\nCc: Matthew\
  \ Brost <matthew.brost@intel.com>\nReviewed-by: Nirmoy Das <nirmoy.das@intel.com>\n\
  Reviewed-by: Matthew Brost <matthew.brost@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20240925071426.144015-4-matthew.auld@intel.com\n\
  (cherry picked from commit 16536582ddbebdbdf9e1d7af321bbba2bf955a87)\nSigned-off-by:\
  \ Lucas De Marchi <lucas.demarchi@intel.com>\n\n## Buggy Code\n\n```c\n// Function:\
  \ xe_exec_queue_create_ioctl in drivers/gpu/drm/xe/xe_exec_queue.c\nint xe_exec_queue_create_ioctl(struct\
  \ drm_device *dev, void *data,\n\t\t\t       struct drm_file *file)\n{\n\tstruct\
  \ xe_device *xe = to_xe_device(dev);\n\tstruct xe_file *xef = to_xe_file(file);\n\
  \tstruct drm_xe_exec_queue_create *args = data;\n\tstruct drm_xe_engine_class_instance\
  \ eci[XE_HW_ENGINE_MAX_INSTANCE];\n\tstruct drm_xe_engine_class_instance __user\
  \ *user_eci =\n\t\tu64_to_user_ptr(args->instances);\n\tstruct xe_hw_engine *hwe;\n\
  \tstruct xe_vm *vm;\n\tstruct xe_gt *gt;\n\tstruct xe_tile *tile;\n\tstruct xe_exec_queue\
  \ *q = NULL;\n\tu32 logical_mask;\n\tu32 id;\n\tu32 len;\n\tint err;\n\n\tif (XE_IOCTL_DBG(xe,\
  \ args->flags) ||\n\t    XE_IOCTL_DBG(xe, args->reserved[0] || args->reserved[1]))\n\
  \t\treturn -EINVAL;\n\n\tlen = args->width * args->num_placements;\n\tif (XE_IOCTL_DBG(xe,\
  \ !len || len > XE_HW_ENGINE_MAX_INSTANCE))\n\t\treturn -EINVAL;\n\n\terr = __copy_from_user(eci,\
  \ user_eci,\n\t\t\t       sizeof(struct drm_xe_engine_class_instance) *\n\t\t\t\
  \       len);\n\tif (XE_IOCTL_DBG(xe, err))\n\t\treturn -EFAULT;\n\n\tif (XE_IOCTL_DBG(xe,\
  \ eci[0].gt_id >= xe->info.gt_count))\n\t\treturn -EINVAL;\n\n\tif (eci[0].engine_class\
  \ == DRM_XE_ENGINE_CLASS_VM_BIND) {\n\t\tif (XE_IOCTL_DBG(xe, args->width != 1)\
  \ ||\n\t\t    XE_IOCTL_DBG(xe, args->num_placements != 1) ||\n\t\t    XE_IOCTL_DBG(xe,\
  \ eci[0].engine_instance != 0))\n\t\t\treturn -EINVAL;\n\n\t\tfor_each_tile(tile,\
  \ xe, id) {\n\t\t\tstruct xe_exec_queue *new;\n\t\t\tu32 flags = EXEC_QUEUE_FLAG_VM;\n\
  \n\t\t\tif (id)\n\t\t\t\tflags |= EXEC_QUEUE_FLAG_BIND_ENGINE_CHILD;\n\n\t\t\tnew\
  \ = xe_exec_queue_create_bind(xe, tile, flags,\n\t\t\t\t\t\t\targs->extensions);\n\
  \t\t\tif (IS_ERR(new)) {\n\t\t\t\terr = PTR_ERR(new);\n\t\t\t\tif (q)\n\t\t\t\t\t\
  goto put_exec_queue;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (id == 0)\n\t\t\t\t\
  q = new;\n\t\t\telse\n\t\t\t\tlist_add_tail(&new->multi_gt_list,\n\t\t\t\t\t   \
  \   &q->multi_gt_link);\n\t\t}\n\t} else {\n\t\tgt = xe_device_get_gt(xe, eci[0].gt_id);\n\
  \t\tlogical_mask = calc_validate_logical_mask(xe, gt, eci,\n\t\t\t\t\t\t\t  args->width,\n\
  \t\t\t\t\t\t\t  args->num_placements);\n\t\tif (XE_IOCTL_DBG(xe, !logical_mask))\n\
  \t\t\treturn -EINVAL;\n\n\t\thwe = xe_hw_engine_lookup(xe, eci[0]);\n\t\tif (XE_IOCTL_DBG(xe,\
  \ !hwe))\n\t\t\treturn -EINVAL;\n\n\t\tvm = xe_vm_lookup(xef, args->vm_id);\n\t\t\
  if (XE_IOCTL_DBG(xe, !vm))\n\t\t\treturn -ENOENT;\n\n\t\terr = down_read_interruptible(&vm->lock);\n\
  \t\tif (err) {\n\t\t\txe_vm_put(vm);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (XE_IOCTL_DBG(xe,\
  \ xe_vm_is_closed_or_banned(vm))) {\n\t\t\tup_read(&vm->lock);\n\t\t\txe_vm_put(vm);\n\
  \t\t\treturn -ENOENT;\n\t\t}\n\n\t\tq = xe_exec_queue_create(xe, vm, logical_mask,\n\
  \t\t\t\t\t args->width, hwe, 0,\n\t\t\t\t\t args->extensions);\n\t\tup_read(&vm->lock);\n\
  \t\txe_vm_put(vm);\n\t\tif (IS_ERR(q))\n\t\t\treturn PTR_ERR(q);\n\n\t\tif (xe_vm_in_preempt_fence_mode(vm))\
  \ {\n\t\t\tq->lr.context = dma_fence_context_alloc(1);\n\n\t\t\terr = xe_vm_add_compute_exec_queue(vm,\
  \ q);\n\t\t\tif (XE_IOCTL_DBG(xe, err))\n\t\t\t\tgoto put_exec_queue;\n\t\t}\n\n\
  \t\tif (q->vm && q->hwe->hw_engine_group) {\n\t\t\terr = xe_hw_engine_group_add_exec_queue(q->hwe->hw_engine_group,\
  \ q);\n\t\t\tif (err)\n\t\t\t\tgoto put_exec_queue;\n\t\t}\n\t}\n\n\terr = xa_alloc(&xef->exec_queue.xa,\
  \ &id, q, xa_limit_32b, GFP_KERNEL);\n\tif (err)\n\t\tgoto kill_exec_queue;\n\n\t\
  args->exec_queue_id = id;\n\tq->xef = xe_file_get(xef);\n\n\treturn 0;\n\nkill_exec_queue:\n\
  \txe_exec_queue_kill(q);\nput_exec_queue:\n\txe_exec_queue_put(q);\n\treturn err;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/xe/xe_exec_queue.c\
  \ b/drivers/gpu/drm/xe/xe_exec_queue.c\nindex 7743ebdcbf4b..d098d2dd1b2d 100644\n\
  --- a/drivers/gpu/drm/xe/xe_exec_queue.c\n+++ b/drivers/gpu/drm/xe/xe_exec_queue.c\n\
  @@ -635,12 +635,14 @@ int xe_exec_queue_create_ioctl(struct drm_device *dev, void\
  \ *data,\n \t\t}\n \t}\n \n+\tq->xef = xe_file_get(xef);\n+\n+\t/* user id alloc\
  \ must always be last in ioctl to prevent UAF */\n \terr = xa_alloc(&xef->exec_queue.xa,\
  \ &id, q, xa_limit_32b, GFP_KERNEL);\n \tif (err)\n \t\tgoto kill_exec_queue;\n\
  \ \n \targs->exec_queue_id = id;\n-\tq->xef = xe_file_get(xef);\n \n \treturn 0;\n\
  \ \n```\n"
pattern: '## Bug Pattern


  Publishing a newly created object to a user-visible ID registry (e.g., xa_alloc/idr_alloc)
  before the object is fully initialized and before the create ioctl completes. This
  early registration makes the object discoverable (often with a predictable/guessable
  ID), allowing a concurrent destroy ioctl to free it while the create path still
  uses it, leading to a use-after-free. The fix is to defer inserting into the ID
  map until the last step of the ioctl, after taking needed references and completing
  initialization.'
plan: "Plan\n\n1. Program state customizations\n- REGISTER_SET_WITH_PROGRAMSTATE(PublishedSet,\
  \ const MemRegion*)\n  - Tracks object regions that have been published into an\
  \ ID registry (xa/idr).\n- REGISTER_SET_WITH_PROGRAMSTATE(ModifiedAfterPublishSet,\
  \ const MemRegion*)\n  - Tracks published object regions that were modified/used\
  \ after publication.\n- REGISTER_MAP_WITH_PROGRAMSTATE(PublishCallSiteMap, const\
  \ MemRegion*, const Stmt*)\n  - Records the call site (Stmt*) where the object was\
  \ published, for diagnostics.\n\n2. Helper identification of \u201Cpublish\u201D\
  \ APIs\n- Maintain a small internal table mapping known registry-publish functions\
  \ to the index of their \u201Centry/object\u201D parameter:\n  - xa_alloc: entry\
  \ param index = 2\n  - idr_alloc: entry param index = 1\n  - idr_alloc_u32: entry\
  \ param index = 1\n  - idr_alloc_cyclic: entry param index = 1\n  - xa_store (optional):\
  \ entry param index = 2\n- Implement a helper bool isPublishCall(const CallEvent\
  \ &Call, unsigned &EntryIndex) which:\n  - Checks the callee identifier.\n  - If\
  \ name matches one of the above, sets EntryIndex appropriately and returns true.\n\
  \  - Otherwise returns false.\n\n3. Intercept publication and mark the object (checkPostCall)\n\
  - Use checkPostCall to observe calls after the engine evaluates them (we want the\
  \ path to continue only on success).\n- If isPublishCall(Call, EntryIndex) is true:\n\
  \  - Obtain the argument expression at EntryIndex (Call.getArgExpr(EntryIndex)).\n\
  \  - Get the associated memory region with getMemRegionFromExpr(ArgExpr, C). This\
  \ should resolve to the pointee region of the object pointer being published (e.g.,\
  \ q).\n  - If region is non-null:\n    - Add region to PublishedSet.\n    - Record\
  \ the call site in PublishCallSiteMap[Region] = Call.getOriginExpr() (or any available\
  \ const Stmt* from the call).\n    - Do not add to ModifiedAfterPublishSet here;\
  \ we only mark modifications detected later.\n  - Note: We do not immediately report\
  \ here; we wait to see if this path ends in a success return and if there are further\
  \ modifications.\n\n4. Track modifications to the published object (checkBind)\n\
  - Use checkBind to detect field or element writes to the already-published object.\n\
  - For each bind:\n  - If Loc corresponds to a region that is a FieldRegion or ElementRegion:\n\
  \    - Walk up to its base region via getSuperRegion chain and obtain the \u201C\
  root\u201D or \u201Cbase\u201D pointee region R (the region representing the struct/object\
  \ pointed to by q).\n    - If R \u2208 PublishedSet:\n      - Insert R into ModifiedAfterPublishSet\
  \ (this indicates the object was modified after publication).\n- This detects patterns\
  \ like q->field = ... occurring after xa_alloc/idr_alloc.\n\n5. Track post-publish\
  \ use via calls that dereference the object (checkPreCall)\n- Use checkPreCall to\
  \ catch function calls where the published object is passed and likely dereferenced\
  \ after publication (a strong indication that publishing was not the last step).\n\
  - For any call that is not one of the publish functions:\n  - Iterate the call\u2019\
  s arguments. For each argument Ai:\n    - Obtain its MemRegion with getMemRegionFromExpr(Ai,\
  \ C).\n    - If region Ri is non-null and Ri \u2208 PublishedSet:\n      - Optional\
  \ precise filter: If functionKnownToDeref(Call, DerefParams) returns true and i\
  \ \u2208 DerefParams, then mark Ri as modified:\n        - Insert Ri into ModifiedAfterPublishSet.\n\
  \      - Conservative fallback (optional): If you want broader coverage, you may\
  \ skip the known-to-deref test and mark Ri modified if the call name suggests side\
  \ effects (contains \u201Cadd\u201D, \u201Cinit\u201D, \u201Cattach\u201D, \u201C\
  register\u201D), using ExprHasName on the callee expression. This is optional and\
  \ should be used carefully to avoid FPs. Prefer functionKnownToDeref if available.\n\
  \n6. Report at success return only (checkPreStmt on ReturnStmt)\n- Use checkPreStmt(const\
  \ ReturnStmt *RS, CheckerContext &C).\n- Evaluate the return value:\n  - If EvaluateExprToInt(EvalRes,\
  \ RS->getRetValue(), C) and EvalRes == 0, we are on a success-return path (typical\
  \ for create ioctls returning 0).\n- On success path:\n  - Iterate through ModifiedAfterPublishSet:\n\
  \    - For each region R in ModifiedAfterPublishSet which is also in PublishedSet,\
  \ issue a bug report (one per region per path).\n    - Retrieve the original publish\
  \ call site S = PublishCallSiteMap[R] for better diagnostics.\n  - Message: \u201C\
  Object inserted into ID registry before final initialization; make xa_alloc/idr_alloc\
  \ the last step.\u201D\n  - Implementation:\n    - auto N = C.generateNonFatalErrorNode();\n\
  \    - if (!N) return;\n    - auto BR = std::make_unique<PathSensitiveBugReport>(BugType,\
  \ Msg, N);\n    - If S exists, add a note location with BR->addRange(S->getSourceRange());\
  \ and/or BR->addNote(\u201CPublished here\u201D, S->getBeginLoc());\n    - C.emitReport(std::move(BR)).\n\
  \n7. Reset/cleanup behavior\n- No special end-of-function cleanup is required; ProgramState\
  \ is path-sensitive. ModifiedAfterPublishSet and PublishedSet exist per path.\n\
  - To avoid duplicate reports, you may:\n  - Only report once per region per success-return\
  \ statement (typical CSA behavior already deduplicates sufficiently), or\n  - Clear\
  \ ModifiedAfterPublishSet in the report branch if necessary (optional).\n\n8. Minimizing\
  \ false positives\n- Only warn when:\n  - A publish call (xa_alloc/idr_alloc/\u2026\
  ) occurs, and\n  - After that publication, we observe a field write into the same\
  \ object (q->field = \u2026) or a known-to-deref call using that object, and\n \
  \ - The current path returns 0 (success).\n- This combination tightly matches the\
  \ target pattern \u201Cpublish must be last step before success,\u201D and avoids\
  \ warning on error/cleanup paths.\n\n9. Optional refinements (if needed)\n- Additional\
  \ heuristic specific to common kernel patterns:\n  - If after publish we specifically\
  \ detect q->xef = foo_get(...) (detected via RHS call name with suffix \u201C_get\u201D\
  ), prioritize reporting (this is exactly the bug in the provided patch).\n- Extend\
  \ the publish function table if other subsystems use different names for ID registries.\n\
  \nChosen callbacks summary\n- checkPostCall:\n  - Detect and mark publish calls;\
  \ add object region to PublishedSet and record call site.\n- checkBind:\n  - Detect\
  \ and record field assignments to published object; add to ModifiedAfterPublishSet.\n\
  - checkPreCall:\n  - Detect post-publish dereferencing of the object by other functions\
  \ (using functionKnownToDeref); add to ModifiedAfterPublishSet.\n- checkPreStmt(ReturnStmt):\n\
  \  - On success return (return 0), emit a report for any object present in both\
  \ PublishedSet and ModifiedAfterPublishSet.\n\nNotes on utility functions\n- getMemRegionFromExpr\
  \ is used to map expressions (arguments and LHS/RHS when needed) to MemRegion pointers.\n\
  - functionKnownToDeref helps reduce false positives by only considering calls that\
  \ dereference pointer parameters.\n- EvaluateExprToInt is used to confirm success\
  \ return (0).\n\nBug report message\n- Short and clear:\n  - Title: \u201CPublishing\
  \ object before final initialization.\u201D\n  - Description: \u201CObject inserted\
  \ into ID registry before final initialization; make xa_alloc/idr_alloc the last\
  \ step.\u201D"
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state: published object regions and those modified after publishing.\n\
  REGISTER_SET_WITH_PROGRAMSTATE(PublishedSet, const MemRegion*)\nREGISTER_SET_WITH_PROGRAMSTATE(ModifiedAfterPublishSet,\
  \ const MemRegion*)\n// Map a published region to the call site where it was published\
  \ (for diagnostics).\nREGISTER_MAP_WITH_PROGRAMSTATE(PublishCallSiteMap, const MemRegion*,\
  \ const Stmt*)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n \
  \       check::PostCall,\n        check::PreCall,\n        check::Bind,\n      \
  \  check::PreStmt<ReturnStmt>\n     > {\n\n  mutable std::unique_ptr<BugType> BT;\n\
  \npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Publishing object\
  \ before final initialization\",\n                       \"Concurrency\")) {}\n\n\
  \  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n  void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkBind(SVal Loc, SVal Val,\
  \ const Stmt *S, CheckerContext &C) const;\n  void checkPreStmt(const ReturnStmt\
  \ *RS, CheckerContext &C) const;\n\nprivate:\n  // Helper: identify known \"publish\
  \ to ID registry\" calls and provide entry arg index.\n  bool isPublishCall(const\
  \ CallEvent &Call, CheckerContext &C,\n                     unsigned &EntryIndex)\
  \ const;\n\n  // Helper: get pointee base region from a call argument by index.\n\
  \  const MemRegion *getArgPointeeBaseRegion(const CallEvent &Call, unsigned Idx)\
  \ const;\n\n  // Helper: from a location SVal get the root/base region of the object\
  \ being written.\n  const MemRegion *getRootBaseFromLoc(SVal Loc) const;\n\n  //\
  \ Mark region as modified after publish.\n  ProgramStateRef markModifiedAfterPublish(ProgramStateRef\
  \ State,\n                                           const MemRegion *BaseR) const;\n\
  \n  // Report bug for a region.\n  void reportForRegion(const MemRegion *R, const\
  \ Stmt *PublishSite,\n                       CheckerContext &C) const;\n};\n\nbool\
  \ SAGenTestChecker::isPublishCall(const CallEvent &Call, CheckerContext &C,\n  \
  \                                   unsigned &EntryIndex) const {\n  const Expr\
  \ *E = Call.getOriginExpr();\n  if (!E)\n    return false;\n\n  // Known registry\
  \ publish APIs and their entry/object parameter index.\n  // - xa_alloc(xa, idp,\
  \ entry, limit, gfp)\n  if (ExprHasName(E, \"xa_alloc\", C)) {\n    EntryIndex =\
  \ 2;\n    return true;\n  }\n  // - xa_store(xa, index, entry, gfp) (optional)\n\
  \  if (ExprHasName(E, \"xa_store\", C)) {\n    EntryIndex = 2;\n    return true;\n\
  \  }\n  // - idr_alloc(idr, entry, start, end, gfp)\n  if (ExprHasName(E, \"idr_alloc\"\
  , C)) {\n    EntryIndex = 1;\n    return true;\n  }\n  // - idr_alloc_u32(idr, entry,\
  \ idp, gfp)\n  if (ExprHasName(E, \"idr_alloc_u32\", C)) {\n    EntryIndex = 1;\n\
  \    return true;\n  }\n  // - idr_alloc_cyclic(idr, entry, start, end, gfp)\n \
  \ if (ExprHasName(E, \"idr_alloc_cyclic\", C)) {\n    EntryIndex = 1;\n    return\
  \ true;\n  }\n\n  return false;\n}\n\nconst MemRegion *SAGenTestChecker::getArgPointeeBaseRegion(const\
  \ CallEvent &Call,\n                                                           unsigned\
  \ Idx) const {\n  if (Idx >= Call.getNumArgs())\n    return nullptr;\n  SVal ArgV\
  \ = Call.getArgSVal(Idx);\n  const MemRegion *R = ArgV.getAsRegion();\n  if (!R)\n\
  \    return nullptr;\n  return R->getBaseRegion();\n}\n\nconst MemRegion *SAGenTestChecker::getRootBaseFromLoc(SVal\
  \ Loc) const {\n  if (const MemRegion *R = Loc.getAsRegion())\n    return R->getBaseRegion();\n\
  \  return nullptr;\n}\n\nProgramStateRef\nSAGenTestChecker::markModifiedAfterPublish(ProgramStateRef\
  \ State,\n                                           const MemRegion *BaseR) const\
  \ {\n  if (!BaseR)\n    return State;\n  if (State->contains<PublishedSet>(BaseR))\
  \ {\n    State = State->add<ModifiedAfterPublishSet>(BaseR);\n  }\n  return State;\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\n             \
  \                        CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  unsigned EntryIndex = 0;\n  if (!isPublishCall(Call, C, EntryIndex))\n    return;\n\
  \n  const MemRegion *EntryBase = getArgPointeeBaseRegion(Call, EntryIndex);\n  if\
  \ (!EntryBase)\n    return;\n\n  // Mark as published and remember call site for\
  \ diagnostics.\n  State = State->add<PublishedSet>(EntryBase);\n  if (const Stmt\
  \ *S = Call.getOriginExpr()) {\n    State = State->set<PublishCallSiteMap>(EntryBase,\
  \ S);\n  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call,\n                                    CheckerContext &C) const\
  \ {\n  ProgramStateRef State = C.getState();\n\n  // Don't consider publish calls\
  \ themselves as \"modifications after publish\".\n  unsigned DummyIdx = 0;\n  if\
  \ (isPublishCall(Call, C, DummyIdx))\n    return;\n\n  // If a known-dereferencing\
  \ function is called with a published object,\n  // consider that as \"used/modified\
  \ after publish\".\n  llvm::SmallVector<unsigned, 4> DerefParams;\n  bool HasKnownDeref\
  \ = functionKnownToDeref(Call, DerefParams);\n\n  if (HasKnownDeref) {\n    for\
  \ (unsigned PI : DerefParams) {\n      const MemRegion *ArgBase = getArgPointeeBaseRegion(Call,\
  \ PI);\n      if (!ArgBase)\n        continue;\n      if (State->contains<PublishedSet>(ArgBase))\
  \ {\n        State = State->add<ModifiedAfterPublishSet>(ArgBase);\n      }\n  \
  \  }\n  }\n\n  if (State != C.getState())\n    C.addTransition(State);\n}\n\nvoid\
  \ SAGenTestChecker::checkBind(SVal Loc, SVal /*Val*/, const Stmt *S,\n         \
  \                        CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Any write into a field/element of a published object after it was published.\n\
  \  const MemRegion *BaseR = getRootBaseFromLoc(Loc);\n  if (!BaseR)\n    return;\n\
  \n  if (State->contains<PublishedSet>(BaseR)) {\n    State = State->add<ModifiedAfterPublishSet>(BaseR);\n\
  \    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::reportForRegion(const\
  \ MemRegion *R, const Stmt *PublishSite,\n                                     \
  \  CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto Rpt = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Object inserted into ID registry before final initialization; \"\n\
  \           \"make xa_alloc/idr_alloc the last step.\",\n      N);\n\n  if (PublishSite)\
  \ {\n    Rpt->addRange(PublishSite->getSourceRange());\n  }\n  C.emitReport(std::move(Rpt));\n\
  }\n\nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt *RS,\n               \
  \                     CheckerContext &C) const {\n  if (!RS)\n    return;\n\n  const\
  \ Expr *Ret = RS->getRetValue();\n  if (!Ret)\n    return;\n\n  llvm::APSInt RetVal;\n\
  \  if (!EvaluateExprToInt(RetVal, Ret, C))\n    return;\n\n  // Only warn on success\
  \ return (commonly 0).\n  if (RetVal != 0)\n    return;\n\n  ProgramStateRef State\
  \ = C.getState();\n  auto ModifiedSet = State->get<ModifiedAfterPublishSet>();\n\
  \  if (ModifiedSet.isEmpty())\n    return;\n\n  for (auto It = ModifiedSet.begin();\
  \ It != ModifiedSet.end(); ++It) {\n    const MemRegion *R = *It;\n    if (!R)\n\
  \      continue;\n\n    if (State->contains<PublishedSet>(R)) {\n      const Stmt\
  \ *PubSite = nullptr;\n      if (const Stmt *const *P = State->get<PublishCallSiteMap>(R))\n\
  \        PubSite = *P;\n\n      reportForRegion(R, PubSite, C);\n    }\n  }\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects publishing objects into ID registries (xa/idr) before final initialization\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
