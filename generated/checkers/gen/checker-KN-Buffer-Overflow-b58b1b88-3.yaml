_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: b58b1b883b9b702e25204dbe2b221eecc8ecd159
commit_type: Buffer-Overflow
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// No custom program states needed.\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<check::Bind> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"I/O iterator underflow\", \"Logic\")) {}\n\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\n   private:\n     \
  \ // Helpers\n      static bool isIovIterCountFieldRegion(const MemRegion *MR);\n\
  \      static bool isIovIterCountMemberExpr(const Expr *E);\n      static bool looksLikeIovIterCount(const\
  \ Expr *E, CheckerContext &C);\n      static bool looksLikeRoundUp(const Expr *E,\
  \ CheckerContext &C);\n      static bool refersToVar(const Expr *E, const VarDecl\
  \ *VD);\n      static bool isZeroExpr(const Expr *E, CheckerContext &C);\n\n   \
  \   // Find last RHS expression that defines VD before 'Before' within 'CS'.\n \
  \     static const Expr* findLastDefRHSForVarBefore(const VarDecl *VD,\n       \
  \                                             const CompoundStmt *CS,\n        \
  \                                            const Stmt *Before,\n             \
  \                                       const Stmt *&DefStmt);\n\n      // Search\
  \ guards between From (exclusive) and To (exclusive) in CS.\n      static bool guardedByShortenCheck(const\
  \ CompoundStmt *CS,\n                                        const Stmt *From, const\
  \ Stmt *To,\n                                        const VarDecl *VD, CheckerContext\
  \ &C);\n\n      static bool condChecksShortenVsIterCount(const Expr *Cond,\n   \
  \                                            const VarDecl *VD,\n              \
  \                                 CheckerContext &C);\n\n      static bool branchAssignsVarZero(const\
  \ Stmt *Body, const VarDecl *VD,\n                                       CheckerContext\
  \ &C);\n};\n\n// --------- Helper implementations ---------\n\nstatic const Expr*\
  \ ignoreCastsAndParens(const Expr *E) {\n  if (!E) return nullptr;\n  return E->IgnoreParenImpCasts();\n\
  }\n\nbool SAGenTestChecker::isIovIterCountFieldRegion(const MemRegion *MR) {\n \
  \ if (!MR) return false;\n  MR = MR->getBaseRegion();\n  const FieldRegion *FR =\
  \ dyn_cast<FieldRegion>(MR);\n  if (!FR) return false;\n\n  const FieldDecl *FD\
  \ = FR->getDecl();\n  if (!FD) return false;\n  if (FD->getName() != \"count\")\
  \ return false;\n\n  const RecordDecl *RD = FD->getParent();\n  if (!RD) return\
  \ false;\n  // 'struct iov_iter'\n  if (RD->getName() == \"iov_iter\")\n    return\
  \ true;\n\n  return false;\n}\n\nbool SAGenTestChecker::isIovIterCountMemberExpr(const\
  \ Expr *E) {\n  if (!E) return false;\n  E = ignoreCastsAndParens(E);\n  const MemberExpr\
  \ *ME = dyn_cast<MemberExpr>(E);\n  if (!ME) return false;\n\n  const ValueDecl\
  \ *VD = ME->getMemberDecl();\n  if (!VD) return false;\n  if (VD->getName() != \"\
  count\")\n    return false;\n\n  // Try to confirm the base is an iov_iter\n  const\
  \ FieldDecl *FD = dyn_cast<FieldDecl>(VD);\n  if (!FD) return false;\n  const RecordDecl\
  \ *RD = FD->getParent();\n  if (!RD) return false;\n  return RD->getName() == \"\
  iov_iter\";\n}\n\nbool SAGenTestChecker::looksLikeIovIterCount(const Expr *E, CheckerContext\
  \ &C) {\n  if (!E) return false;\n  E = ignoreCastsAndParens(E);\n\n  if (isIovIterCountMemberExpr(E))\n\
  \    return true;\n\n  // iov_iter_count(iter)\n  if (ExprHasName(E, \"iov_iter_count\"\
  , C))\n    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::looksLikeRoundUp(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return false;\n  E = ignoreCastsAndParens(E);\n\
  \n  // If a direct call expression with callee id\n  if (const CallExpr *CE = dyn_cast<CallExpr>(E))\
  \ {\n    if (const FunctionDecl *FD = CE->getDirectCallee()) {\n      StringRef\
  \ Name = FD->getIdentifier() ? FD->getName() : \"\";\n      if (Name == \"round_up\"\
  \ || Name == \"roundup\" || Name == \"ALIGN\")\n        return true;\n    }\n  }\n\
  \n  // Fallback: textual name (handles macros)\n  if (ExprHasName(E, \"round_up\"\
  , C) || ExprHasName(E, \"roundup\", C) ||\n      ExprHasName(E, \"ALIGN\", C))\n\
  \    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::refersToVar(const\
  \ Expr *E, const VarDecl *VD) {\n  if (!E || !VD) return false;\n  E = ignoreCastsAndParens(E);\n\
  \n  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E)) {\n    return DRE->getDecl()\
  \ == VD;\n  }\n\n  // Recurse into binary/unary/conditional etc.\n  for (const Stmt\
  \ *Child : E->children()) {\n    if (const Expr *CE = dyn_cast_or_null<Expr>(Child))\
  \ {\n      if (refersToVar(CE, VD)) return true;\n    }\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isZeroExpr(const Expr *E, CheckerContext &C) {\n  if\
  \ (!E) return false;\n  E = ignoreCastsAndParens(E);\n\n  if (const IntegerLiteral\
  \ *IL = dyn_cast<IntegerLiteral>(E)) {\n    return IL->getValue() == 0;\n  }\n\n\
  \  llvm::APSInt Val;\n  if (EvaluateExprToInt(Val, E, C))\n    return Val == 0;\n\
  \n  return false;\n}\n\nconst Expr* SAGenTestChecker::findLastDefRHSForVarBefore(const\
  \ VarDecl *VD,\n                                                         const CompoundStmt\
  \ *CS,\n                                                         const Stmt *Before,\n\
  \                                                         const Stmt *&DefStmt)\
  \ {\n  if (!VD || !CS || !Before) return nullptr;\n  const Expr *LastRHS = nullptr;\n\
  \  DefStmt = nullptr;\n\n  for (const Stmt *S : CS->body()) {\n    if (S == Before)\n\
  \      break;\n\n    // Handle DeclStmt: \"size_t shorten = expr;\"\n    if (const\
  \ auto *DS = dyn_cast<DeclStmt>(S)) {\n      for (const Decl *D : DS->decls()) {\n\
  \        if (const auto *Var = dyn_cast<VarDecl>(D)) {\n          if (Var == VD\
  \ && Var->hasInit()) {\n            LastRHS = Var->getInit();\n            DefStmt\
  \ = DS;\n          }\n        }\n      }\n    }\n\n    // Handle simple assignment:\
  \ \"shorten = expr;\"\n    if (const auto *BO = dyn_cast<BinaryOperator>(S)) {\n\
  \      if (BO->getOpcode() == BO_Assign) {\n        const Expr *LHS = ignoreCastsAndParens(BO->getLHS());\n\
  \        if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS)) {\n          if (DRE->getDecl()\
  \ == VD) {\n            LastRHS = BO->getRHS();\n            DefStmt = BO;\n   \
  \       }\n        }\n      }\n    }\n  }\n\n  return LastRHS;\n}\n\nbool SAGenTestChecker::branchAssignsVarZero(const\
  \ Stmt *Body,\n                                            const VarDecl *VD,\n\
  \                                            CheckerContext &C) {\n  if (!Body ||\
  \ !VD) return false;\n\n  // Walk the subtree to find \"VD = 0;\"\n  if (const auto\
  \ *BO = dyn_cast<BinaryOperator>(Body)) {\n    if (BO->getOpcode() == BO_Assign)\
  \ {\n      const Expr *LHS = ignoreCastsAndParens(BO->getLHS());\n      const Expr\
  \ *RHS = ignoreCastsAndParens(BO->getRHS());\n      if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS))\
  \ {\n        if (DRE->getDecl() == VD && isZeroExpr(RHS, C))\n          return true;\n\
  \      }\n    }\n  }\n\n  for (const Stmt *Child : Body->children()) {\n    if (!Child)\
  \ continue;\n    if (branchAssignsVarZero(Child, VD, C))\n      return true;\n \
  \ }\n  return false;\n}\n\nbool SAGenTestChecker::condChecksShortenVsIterCount(const\
  \ Expr *Cond,\n                                                    const VarDecl\
  \ *VD,\n                                                    CheckerContext &C) {\n\
  \  if (!Cond) return false;\n  Cond = ignoreCastsAndParens(Cond);\n\n  // Look for\
  \ comparison with >= or >\n  if (const auto *BO = dyn_cast<BinaryOperator>(Cond))\
  \ {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n    if (Op == BO_GE || Op\
  \ == BO_GT) {\n      const Expr *L = ignoreCastsAndParens(BO->getLHS());\n     \
  \ const Expr *R = ignoreCastsAndParens(BO->getRHS());\n\n      bool LeftIsShorten\
  \ = refersToVar(L, VD);\n      bool RightIsShorten = refersToVar(R, VD);\n     \
  \ bool LeftIsIterLen = looksLikeIovIterCount(L, C);\n      bool RightIsIterLen =\
  \ looksLikeIovIterCount(R, C);\n\n      // shorten >= iter->count   OR   iter->count\
  \ <= shorten (same meaning)\n      if ((LeftIsShorten && RightIsIterLen) || (RightIsShorten\
  \ && LeftIsIterLen))\n        return true;\n    }\n  }\n\n  // Fallback textual\
  \ guard in condition (coarse)\n  if (ExprHasName(Cond, VD->getName(), C) &&\n  \
  \    (ExprHasName(Cond, \"iov_iter_count\", C) || ExprHasName(Cond, \"count\", C)))\
  \ {\n    return true;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::guardedByShortenCheck(const\
  \ CompoundStmt *CS,\n                                             const Stmt *From,\
  \ const Stmt *To,\n                                             const VarDecl *VD,\n\
  \                                             CheckerContext &C) {\n  if (!CS ||\
  \ !To || !VD) return false;\n\n  bool InRange = (From == nullptr);\n  for (const\
  \ Stmt *S : CS->body()) {\n    if (!InRange) {\n      if (S == From) InRange = true;\n\
  \      continue;\n    }\n    if (S == To)\n      break;\n\n    if (const auto *IfS\
  \ = dyn_cast<IfStmt>(S)) {\n      const Expr *Cond = IfS->getCond();\n      if (condChecksShortenVsIterCount(Cond,\
  \ VD, C)) {\n        // Check if then-branch assigns VD to 0 (like: shorten = 0;)\n\
  \        if (const Stmt *Then = IfS->getThen()) {\n          if (branchAssignsVarZero(Then,\
  \ VD, C))\n            return true;\n        }\n      }\n    }\n  }\n  return false;\n\
  }\n\n// --------- Main logic ---------\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  // We target writes\
  \ to iter->count (struct iov_iter::count)\n  const MemRegion *MR = Loc.getAsRegion();\n\
  \  if (!MR) return;\n  MR = MR->getBaseRegion();\n  if (!isIovIterCountFieldRegion(MR))\n\
  \    return;\n\n  if (!S) return;\n\n  const CompoundAssignOperator *CAO = dyn_cast<CompoundAssignOperator>(S);\n\
  \  const BinaryOperator *BOAssign = dyn_cast<BinaryOperator>(S);\n\n  const Expr\
  \ *ShrinkExpr = nullptr;\n  const Stmt *DefStmt = nullptr;\n  const BinaryOperator\
  \ *Diff = nullptr;\n\n  // Case 1: iter->count -= X;\n  if (CAO && CAO->getOpcode()\
  \ == BO_SubAssign) {\n    // We only analyze pattern when LHS is iter->count; Loc\
  \ already ensures that.\n    ShrinkExpr = CAO->getRHS();\n  }\n  // Case 2: iter->count\
  \ = iter->count - X; or count = something;\n  else if (BOAssign && BOAssign->getOpcode()\
  \ == BO_Assign) {\n    // LHS should be iter->count; the Loc filter ensures this.\n\
  \    const Expr *RHS = BOAssign->getRHS();\n    if (!RHS) return;\n    RHS = ignoreCastsAndParens(RHS);\n\
  \    if (const auto *BOsub = dyn_cast<BinaryOperator>(RHS)) {\n      if (BOsub->getOpcode()\
  \ == BO_Sub) {\n        // Recognize \"iter->count = iter->count - shrink\"\n  \
  \      // Then shrink is the other side, but we actually need shrink itself only\
  \ if used as A-B separately.\n        // However, our pattern focuses on shrink\
  \ being computed as A-B. This assignment form is less common.\n        // We'll\
  \ treat RHS entirely later only if it matches A - B directly.\n        Diff = BOsub;\n\
  \      }\n    } else {\n      // Maybe \"iter->count = iter->count - shorten\" wasn't\
  \ parsed as BinaryOperator at this level.\n      // Or simply \"iter->count = count\
  \ - shorten;\" not our primary target.\n      return;\n    }\n  } else {\n    return;\n\
  \  }\n\n  const Expr *DiffExpr = nullptr;\n\n  // If ShrinkExpr is a variable, find\
  \ its definition as A - B\n  if (ShrinkExpr) {\n    ShrinkExpr = ignoreCastsAndParens(ShrinkExpr);\n\
  \    if (const auto *DRE = dyn_cast<DeclRefExpr>(ShrinkExpr)) {\n      const VarDecl\
  \ *VD = dyn_cast<VarDecl>(DRE->getDecl());\n      if (!VD) return;\n\n      // Find\
  \ the containing CompoundStmt\n      const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(S,\
  \ C);\n      const Expr *DefRHS = findLastDefRHSForVarBefore(VD, CS, S, DefStmt);\n\
  \      if (!DefRHS) return;\n\n      DefRHS = ignoreCastsAndParens(DefRHS);\n  \
  \    if (const auto *BOsub = dyn_cast<BinaryOperator>(DefRHS)) {\n        if (BOsub->getOpcode()\
  \ != BO_Sub)\n          return;\n        DiffExpr = BOsub;\n\n        // Try to\
  \ detect whether there's a guard like:\n        // if (shorten >= iter->count) shorten\
  \ = 0;\n        if (guardedByShortenCheck(CS, DefStmt, S, VD, C)) {\n          return;\
  \ // Properly guarded; do not warn.\n        }\n      } else {\n        return;\n\
  \      }\n    } else if (const auto *BOsub = dyn_cast<BinaryOperator>(ShrinkExpr))\
  \ {\n      if (BOsub->getOpcode() != BO_Sub)\n        return;\n      DiffExpr =\
  \ BOsub;\n    } else {\n      return;\n    }\n  } else if (Diff) {\n    DiffExpr\
  \ = Diff;\n  }\n\n  if (!DiffExpr)\n    return;\n\n  // Ensure it's an unsigned\
  \ 'A - B' style computation.\n  QualType T = DiffExpr->getType();\n  if (!T->isUnsignedIntegerType())\n\
  \    return;\n\n  const auto *BOsub = dyn_cast<BinaryOperator>(DiffExpr);\n  if\
  \ (!BOsub || BOsub->getOpcode() != BO_Sub)\n    return;\n\n  const Expr *A = ignoreCastsAndParens(BOsub->getLHS());\n\
  \  const Expr *B = ignoreCastsAndParens(BOsub->getRHS());\n  if (!A || !B) return;\n\
  \n  // Heuristic recognition of A (current length) and B (aligned length)\n  bool\
  \ AisLen = looksLikeIovIterCount(A, C) || isIovIterCountMemberExpr(A);\n  bool BisAligned\
  \ = looksLikeRoundUp(B, C);\n  if (!(AisLen && BisAligned)) {\n    // Try the opposite\
  \ (be conservative)\n    bool AisAligned = looksLikeRoundUp(A, C);\n    bool BisLen\
  \ = looksLikeIovIterCount(B, C) || isIovIterCountMemberExpr(B);\n    if (!(AisAligned\
  \ && BisLen)) {\n      return; // Not the pattern we look for\n    } else {\n  \
  \    // If it's aligned - len, then it's not our \"shrink = len - aligned\" idiom.\n\
  \      // This is not the underflow pattern we're targeting.\n      return;\n  \
  \  }\n  }\n\n  // Optional constant pruning: if we can prove A >= B at compile-time,\
  \ skip.\n  llvm::APSInt Aval, Bval;\n  if (EvaluateExprToInt(Aval, A, C) && EvaluateExprToInt(Bval,\
  \ B, C)) {\n    if (Aval >= Bval)\n      return;\n  }\n\n  // Report a potential\
  \ underflow\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Potential underflow\
  \ of iter->count when shrinking by aligned length\", N);\n  R->addRange(S->getSourceRange());\n\
  \n  // If we have a defining statement like \"shorten = A - round_up(...);\", point\
  \ to it.\n  if (DefStmt) {\n    PathDiagnosticLocation DefLoc = PathDiagnosticLocation::createBegin(DefStmt,\
  \ C.getSourceManager(), C.getLocationContext());\n    R->addNote(\"shrink amount\
  \ computed here\", DefLoc);\n  }\n\n  C.emitReport(std::move(R));\n}\n\n} // end\
  \ anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects underflow when shrinking iov_iter->count by aligned length without\
  \ guard\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbcachefs: fix iov_iter count underflow on sub-block\
  \ dio read\n\nbch2_direct_IO_read() checks the request offset and size for sector\n\
  alignment and then falls through to a couple calculations to shrink\nthe size of\
  \ the request based on the inode size. The problem is that\nthese checks round up\
  \ to the fs block size, which runs the risk of\nunderflowing iter->count if the\
  \ block size happens to be large\nenough. This is triggered by fstest generic/361\
  \ with a 4k block\nsize, which subsequently leads to a crash. To avoid this crash,\n\
  check that the shorten length doesn't exceed the overall length of\nthe iter.\n\n\
  Fixes:\nSigned-off-by: Brian Foster <bfoster@redhat.com>\nReviewed-by: Su Yue <glass.su@suse.com>\n\
  Signed-off-by: Kent Overstreet <kent.overstreet@linux.dev>\n\n## Buggy Code\n\n\
  ```c\n// Function: bch2_direct_IO_read in fs/bcachefs/fs-io-direct.c\nstatic int\
  \ bch2_direct_IO_read(struct kiocb *req, struct iov_iter *iter)\n{\n\tstruct file\
  \ *file = req->ki_filp;\n\tstruct bch_inode_info *inode = file_bch_inode(file);\n\
  \tstruct bch_fs *c = inode->v.i_sb->s_fs_info;\n\tstruct bch_io_opts opts;\n\tstruct\
  \ dio_read *dio;\n\tstruct bio *bio;\n\tloff_t offset = req->ki_pos;\n\tbool sync\
  \ = is_sync_kiocb(req);\n\tsize_t shorten;\n\tssize_t ret;\n\n\tbch2_inode_opts_get(&opts,\
  \ c, &inode->ei_inode);\n\n\t/* bios must be 512 byte aligned: */\n\tif ((offset|iter->count)\
  \ & (SECTOR_SIZE - 1))\n\t\treturn -EINVAL;\n\n\tret = min_t(loff_t, iter->count,\n\
  \t\t    max_t(loff_t, 0, i_size_read(&inode->v) - offset));\n\n\tif (!ret)\n\t\t\
  return ret;\n\n\tshorten = iov_iter_count(iter) - round_up(ret, block_bytes(c));\n\
  \titer->count -= shorten;\n\n\tbio = bio_alloc_bioset(NULL,\n\t\t\t       bio_iov_vecs_to_alloc(iter,\
  \ BIO_MAX_VECS),\n\t\t\t       REQ_OP_READ,\n\t\t\t       GFP_KERNEL,\n\t\t\t  \
  \     &c->dio_read_bioset);\n\n\tbio->bi_end_io = bch2_direct_IO_read_endio;\n\n\
  \tdio = container_of(bio, struct dio_read, rbio.bio);\n\tclosure_init(&dio->cl,\
  \ NULL);\n\n\t/*\n\t * this is a _really_ horrible hack just to avoid an atomic\
  \ sub at the\n\t * end:\n\t */\n\tif (!sync) {\n\t\tset_closure_fn(&dio->cl, bch2_dio_read_complete,\
  \ NULL);\n\t\tatomic_set(&dio->cl.remaining,\n\t\t\t   CLOSURE_REMAINING_INITIALIZER\
  \ -\n\t\t\t   CLOSURE_RUNNING +\n\t\t\t   CLOSURE_DESTRUCTOR);\n\t} else {\n\t\t\
  atomic_set(&dio->cl.remaining,\n\t\t\t   CLOSURE_REMAINING_INITIALIZER + 1);\n\t\
  \tdio->cl.closure_get_happened = true;\n\t}\n\n\tdio->req\t= req;\n\tdio->ret\t\
  = ret;\n\t/*\n\t * This is one of the sketchier things I've encountered: we have\
  \ to skip\n\t * the dirtying of requests that are internal from the kernel (i.e.\
  \ from\n\t * loopback), because we'll deadlock on page_lock.\n\t */\n\tdio->should_dirty\
  \ = iter_is_iovec(iter);\n\n\tgoto start;\n\twhile (iter->count) {\n\t\tbio = bio_alloc_bioset(NULL,\n\
  \t\t\t\t       bio_iov_vecs_to_alloc(iter, BIO_MAX_VECS),\n\t\t\t\t       REQ_OP_READ,\n\
  \t\t\t\t       GFP_KERNEL,\n\t\t\t\t       &c->bio_read);\n\t\tbio->bi_end_io\t\t\
  = bch2_direct_IO_read_split_endio;\nstart:\n\t\tbio->bi_opf\t\t= REQ_OP_READ|REQ_SYNC;\n\
  \t\tbio->bi_iter.bi_sector\t= offset >> 9;\n\t\tbio->bi_private\t\t= dio;\n\n\t\t\
  ret = bio_iov_iter_get_pages(bio, iter);\n\t\tif (ret < 0) {\n\t\t\t/* XXX: fault\
  \ inject this path */\n\t\t\tbio->bi_status = BLK_STS_RESOURCE;\n\t\t\tbio_endio(bio);\n\
  \t\t\tbreak;\n\t\t}\n\n\t\toffset += bio->bi_iter.bi_size;\n\n\t\tif (dio->should_dirty)\n\
  \t\t\tbio_set_pages_dirty(bio);\n\n\t\tif (iter->count)\n\t\t\tclosure_get(&dio->cl);\n\
  \n\t\tbch2_read(c, rbio_init(bio, opts), inode_inum(inode));\n\t}\n\n\titer->count\
  \ += shorten;\n\n\tif (sync) {\n\t\tclosure_sync(&dio->cl);\n\t\tclosure_debug_destroy(&dio->cl);\n\
  \t\tret = dio->ret;\n\t\tbio_check_or_release(&dio->rbio.bio, dio->should_dirty);\n\
  \t\treturn ret;\n\t} else {\n\t\treturn -EIOCBQUEUED;\n\t}\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/fs/bcachefs/fs-io-direct.c b/fs/bcachefs/fs-io-direct.c\n\
  index e3b219e19e10..33cb6da3a5ad 100644\n--- a/fs/bcachefs/fs-io-direct.c\n+++ b/fs/bcachefs/fs-io-direct.c\n\
  @@ -88,6 +88,8 @@ static int bch2_direct_IO_read(struct kiocb *req, struct iov_iter\
  \ *iter)\n \t\treturn ret;\n \n \tshorten = iov_iter_count(iter) - round_up(ret,\
  \ block_bytes(c));\n+\tif (shorten >= iter->count)\n+\t\tshorten = 0;\n \titer->count\
  \ -= shorten;\n \n \tbio = bio_alloc_bioset(NULL,\n```\n"
pattern: '## Bug Pattern


  Computing a shrink amount as an unsigned difference between the current I/O length
  and a block-aligned length, and then subtracting it from iter->count without verifying
  that the aligned length is not larger than the current length. Specifically:

  - shorten = iov_iter_count(iter) - round_up(len, block_size) uses size_t

  - If round_up(len, block_size) > iov_iter_count(iter), the subtraction underflows

  - Iter->count -= shorten then massively underflows, corrupting iterator length


  This occurs when aligning a sub-block request (e.g., 512B) to a larger filesystem
  block (e.g., 4K) without bounding the shrinkage.'
plan: "1) Program state\n- No custom program state needed. This checker can be implemented\
  \ with pattern-based inspection around the write to iter->count. We will rely on\
  \ local AST inspection and the provided utility helpers.\n\n2) Callbacks and implementation\
  \ details\n\nA) checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C)\n\
  Goal: Detect a subtractive shrink of iter->count that uses an unsigned difference\
  \ \u201CA - B\u201D where A is the current I/O length and B is a block-aligned length\
  \ (round_up), without a guard ensuring B <= A (or an equivalent guard, e.g., shorten\
  \ <= iter->count).\n\nSteps:\n1. Filter for writes to iter->count:\n   - Ensure\
  \ Loc is a region for a record field named \u201Ccount\u201D, and the base type\
  \ is (or contains) \u201Cstruct iov_iter\u201D. You can retrieve the FieldRegion\
  \ and FieldDecl, then check FieldDecl->getName() == \"count\". Optionally check\
  \ the base type string contains \u201Ciov_iter\u201D.\n   - Extract the statement\
  \ S that caused the bind. It should be:\n     - A CompoundAssignOperator \u201C\
  -=\u201D with LHS being \u201Citer->count\u201D, or\n     - A BinaryOperator \u201C\
  =\u201D with LHS \u201Citer->count\u201D.\n   - If neither, return.\n\n2. Extract\
  \ the \u201Cshrink\u201D expression:\n   - If S is a CompoundAssignOperator with\
  \ \u201C-=\u201D, let ShrinkExpr = the RHS.\n   - If S is a BinaryOperator \u201C\
  =\u201D, try to detect the pattern \u201Citer->count = <something>\u201D. If RHS\
  \ is a BinaryOperator \u201C-\u201D, and one side references the current count (i.e.,\
  \ MemberExpr matching iter->count), then the other side is ShrinkExpr. Otherwise,\
  \ if RHS is just a variable (e.g., \u201Cshorten\u201D), set ShrinkExpr = that variable\
  \ and resolve it in step 3.\n\n3. Resolve the shrink computation (find \u201CA -\
  \ B\u201D):\n   - If ShrinkExpr is already a BinaryOperator \u201C-\u201D, let DiffExpr\
  \ = ShrinkExpr.\n   - Else if ShrinkExpr is a DeclRefExpr to a variable (e.g., \u201C\
  shorten\u201D), find the most recent assignment/initialization to that variable\
  \ in the same scope before S:\n     - Use findSpecificTypeInParents to get the surrounding\
  \ CompoundStmt.\n     - Iterate the CompoundStmt body, remembering statements until\
  \ you reach S; track the last DeclStmt or BinaryOperator that defines/assigns the\
  \ variable. Pick the last one before S.\n     - From that defining statement, extract\
  \ its RHS as DiffExpr.\n   - If no definition found or DiffExpr is not a BinaryOperator\
  \ \u201C-\u201D (or types don\u2019t match below), return.\n\n4. Recognize A and\
  \ B:\n   - Let A = LHS of DiffExpr; B = RHS of DiffExpr.\n   - Check that DiffExpr\u2019\
  s type is unsigned (preferably isUnsignedIntegerType()), or that A and B are both\
  \ size_t (when available).\n   - Heuristically recognize:\n     - A is \u201Ccurrent\
  \ I/O length\u201D: either a call expression containing the name \u201Ciov_iter_count\u201D\
  \ (ExprHasName(A, \"iov_iter_count\", C)) or a MemberExpr referring to \u201Citer->count\u201D\
  .\n     - B is an aligned length: call expression or macro text containing \u201C\
  round_up\u201D or \u201Croundup\u201D or possibly \u201CALIGN\u201D. You can use:\n\
  \       - If CallExpr: get callee identifier and check name equals \u201Cround_up\u201D\
  \ or \u201Croundup\u201D.\n       - Else: fallback to ExprHasName(B, \"round_up\"\
  , C) || ExprHasName(B, \"roundup\", C) || ExprHasName(B, \"ALIGN\", C).\n   - If\
  \ this structure doesn\u2019t match, return.\n\n5. Try trivial constant pruning\
  \ (optional, to reduce FPs):\n   - If both A and B evaluate to integers via EvaluateExprToInt\
  \ and A >= B, then skip reporting.\n   - Otherwise, proceed (we assume potential\
  \ underflow exists).\n\n6. Guard detection between definition of DiffExpr and the\
  \ write to iter->count:\n   - Look for a dominating guard that prevents underflow,\
  \ in the same CompoundStmt between the statement defining DiffExpr (or ShrinkExpr)\
  \ and S:\n     - A guard like \u201Cif (shorten >= iter->count) shorten = 0;\u201D\
  \ or equivalent.\n     - Or a condition that ensures B <= A, e.g., \u201Cif (round_up(...)\
  \ > iov_iter_count(...)) { adjust; }\u201D.\n   - Implement a simple scan:\n   \
  \  - In the CompoundStmt body between the defining statement and S, search for an\
  \ IfStmt.\n     - For each IfStmt condition, use ExprHasName to look for:\n    \
  \   - Either: both names of Shrink variable and \u201Ccount\u201D, with a comparison\
  \ operator \u201C>=\u201D or \u201C>\u201D, or\n       - Both \u201Cround_up\u201D\
  /\u201Croundup\u201D and \u201Ciov_iter_count\u201D/\u201Ccount\u201D with a comparison\
  \ that implies B <= A (e.g., \u201Cround_up(...) > iov_iter_count(...)\u201D).\n\
  \     - Also check the guarded block for an assignment like \u201Cshorten = 0\u201D\
  \ or a branch that prevents subtracting too much (coarse heuristic: in the true\
  \ branch, any assignment to shrink var to 0 or to a bounded value; you can do a\
  \ simple ExprHasName on assignment target and RHS \u201C0\u201D).\n   - If a suitable\
  \ guard is found, return (do not warn).\n\n7. Report:\n   - Create a BugType once\
  \ (e.g., \u201CUnderflow in I/O shrink\u201D).\n   - Generate a non-fatal error\
  \ node and emit a PathSensitiveBugReport at S with a short message:\n     - \u201C\
  Possible underflow: subtracting unsigned shorten may exceed iter->count\u201D\n\
  \     - Alternatively: \u201CPotential underflow of iter->count when shrinking by\
  \ aligned length\u201D\n   - Optionally add a note on the definition line of DiffExpr\
  \ pointing out \u201Cshorten = A - round_up(...);\u201D to improve diagnosability.\n\
  \nHelper utilities to implement/lean on:\n- bool isIterCountMember(const Expr *E):\n\
  \  - Return true if E is a MemberExpr named \u201Ccount\u201D whose base type stringifies\
  \ to something containing \u201Ciov_iter\u201D.\n- bool looksLikeIovIterCount(const\
  \ Expr *E, CheckerContext &C):\n  - Return ExprHasName(E, \"iov_iter_count\", C)\
  \ or E is isIterCountMember(E).\n- bool looksLikeRoundUp(const Expr *E, CheckerContext\
  \ &C):\n  - If it\u2019s a CallExpr with callee id \u201Cround_up\u201D or \u201C\
  roundup\u201D, return true.\n  - Else fallback to ExprHasName(E, \"round_up\", C)\
  \ || ExprHasName(E, \"roundup\", C) || ExprHasName(E, \"ALIGN\", C).\n- const BinaryOperator*\
  \ findLastAssignToVarBefore(const VarDecl *VD, const CompoundStmt *CS, const Stmt\
  \ *Before):\n  - Iterate CS->body() in order until Before; track last BinaryOperator\
  \ with \u201C=\u201D or last DeclStmt initializing VD.\n\nNotes:\n- This checker\
  \ is intentionally narrow to the kernel idiom:\n  - It only triggers when subtracting\
  \ an unsigned difference formed by the \u201Ccurrent length minus aligned length\u201D\
  \ idiom involving iov_iter_count/iter->count and round_up/roundup/ALIGN.\n  - It\
  \ suppresses when a guard \u201Cshorten >= iter->count\u201D (or equivalent) exists\
  \ before the decrement, matching the upstream fix \u201Cif (shorten >= iter->count)\
  \ shorten = 0;\u201D.\n- The implementation keeps things simple: no custom program\
  \ state, no alias tracking, and only local-scope scans with available AST helpers.\n\
  - If desired, add a small whitelist to skip when the checker observes an immediate\
  \ guard at the same line or on the previous statement to reduce false positives\
  \ even further."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// No custom program states needed.\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<check::Bind> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"I/O iterator underflow\", \"Logic\")) {}\n\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\n   private:\n     \
  \ // Helpers\n      static bool isIovIterCountFieldRegion(const MemRegion *MR);\n\
  \      static bool isIovIterCountMemberExpr(const Expr *E);\n      static bool looksLikeIovIterCount(const\
  \ Expr *E, CheckerContext &C);\n      static bool looksLikeRoundUp(const Expr *E,\
  \ CheckerContext &C);\n      static bool refersToVar(const Expr *E, const VarDecl\
  \ *VD);\n      static bool isZeroExpr(const Expr *E, CheckerContext &C);\n\n   \
  \   // Find last RHS expression that defines VD before 'Before' within 'CS'.\n \
  \     static const Expr* findLastDefRHSForVarBefore(const VarDecl *VD,\n       \
  \                                             const CompoundStmt *CS,\n        \
  \                                            const Stmt *Before,\n             \
  \                                       const Stmt *&DefStmt);\n\n      // Search\
  \ guards between From (exclusive) and To (exclusive) in CS.\n      static bool guardedByShortenCheck(const\
  \ CompoundStmt *CS,\n                                        const Stmt *From, const\
  \ Stmt *To,\n                                        const VarDecl *VD, CheckerContext\
  \ &C);\n\n      static bool condChecksShortenVsIterCount(const Expr *Cond,\n   \
  \                                            const VarDecl *VD,\n              \
  \                                 CheckerContext &C);\n\n      static bool branchAssignsVarZero(const\
  \ Stmt *Body, const VarDecl *VD,\n                                       CheckerContext\
  \ &C);\n};\n\n// --------- Helper implementations ---------\n\nstatic const Expr*\
  \ ignoreCastsAndParens(const Expr *E) {\n  if (!E) return nullptr;\n  return E->IgnoreParenImpCasts();\n\
  }\n\nbool SAGenTestChecker::isIovIterCountFieldRegion(const MemRegion *MR) {\n \
  \ if (!MR) return false;\n  MR = MR->getBaseRegion();\n  const FieldRegion *FR =\
  \ dyn_cast<FieldRegion>(MR);\n  if (!FR) return false;\n\n  const FieldDecl *FD\
  \ = FR->getDecl();\n  if (!FD) return false;\n  if (FD->getName() != \"count\")\
  \ return false;\n\n  const RecordDecl *RD = FD->getParent();\n  if (!RD) return\
  \ false;\n  // 'struct iov_iter'\n  if (RD->getName() == \"iov_iter\")\n    return\
  \ true;\n\n  return false;\n}\n\nbool SAGenTestChecker::isIovIterCountMemberExpr(const\
  \ Expr *E) {\n  if (!E) return false;\n  E = ignoreCastsAndParens(E);\n  const MemberExpr\
  \ *ME = dyn_cast<MemberExpr>(E);\n  if (!ME) return false;\n\n  const ValueDecl\
  \ *VD = ME->getMemberDecl();\n  if (!VD) return false;\n  if (VD->getName() != \"\
  count\")\n    return false;\n\n  // Try to confirm the base is an iov_iter\n  const\
  \ FieldDecl *FD = dyn_cast<FieldDecl>(VD);\n  if (!FD) return false;\n  const RecordDecl\
  \ *RD = FD->getParent();\n  if (!RD) return false;\n  return RD->getName() == \"\
  iov_iter\";\n}\n\nbool SAGenTestChecker::looksLikeIovIterCount(const Expr *E, CheckerContext\
  \ &C) {\n  if (!E) return false;\n  E = ignoreCastsAndParens(E);\n\n  if (isIovIterCountMemberExpr(E))\n\
  \    return true;\n\n  // iov_iter_count(iter)\n  if (ExprHasName(E, \"iov_iter_count\"\
  , C))\n    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::looksLikeRoundUp(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return false;\n  E = ignoreCastsAndParens(E);\n\
  \n  // If a direct call expression with callee id\n  if (const CallExpr *CE = dyn_cast<CallExpr>(E))\
  \ {\n    if (const FunctionDecl *FD = CE->getDirectCallee()) {\n      StringRef\
  \ Name = FD->getIdentifier() ? FD->getName() : \"\";\n      if (Name == \"round_up\"\
  \ || Name == \"roundup\" || Name == \"ALIGN\")\n        return true;\n    }\n  }\n\
  \n  // Fallback: textual name (handles macros)\n  if (ExprHasName(E, \"round_up\"\
  , C) || ExprHasName(E, \"roundup\", C) ||\n      ExprHasName(E, \"ALIGN\", C))\n\
  \    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::refersToVar(const\
  \ Expr *E, const VarDecl *VD) {\n  if (!E || !VD) return false;\n  E = ignoreCastsAndParens(E);\n\
  \n  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E)) {\n    return DRE->getDecl()\
  \ == VD;\n  }\n\n  // Recurse into binary/unary/conditional etc.\n  for (const Stmt\
  \ *Child : E->children()) {\n    if (const Expr *CE = dyn_cast_or_null<Expr>(Child))\
  \ {\n      if (refersToVar(CE, VD)) return true;\n    }\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::isZeroExpr(const Expr *E, CheckerContext &C) {\n  if\
  \ (!E) return false;\n  E = ignoreCastsAndParens(E);\n\n  if (const IntegerLiteral\
  \ *IL = dyn_cast<IntegerLiteral>(E)) {\n    return IL->getValue() == 0;\n  }\n\n\
  \  llvm::APSInt Val;\n  if (EvaluateExprToInt(Val, E, C))\n    return Val == 0;\n\
  \n  return false;\n}\n\nconst Expr* SAGenTestChecker::findLastDefRHSForVarBefore(const\
  \ VarDecl *VD,\n                                                         const CompoundStmt\
  \ *CS,\n                                                         const Stmt *Before,\n\
  \                                                         const Stmt *&DefStmt)\
  \ {\n  if (!VD || !CS || !Before) return nullptr;\n  const Expr *LastRHS = nullptr;\n\
  \  DefStmt = nullptr;\n\n  for (const Stmt *S : CS->body()) {\n    if (S == Before)\n\
  \      break;\n\n    // Handle DeclStmt: \"size_t shorten = expr;\"\n    if (const\
  \ auto *DS = dyn_cast<DeclStmt>(S)) {\n      for (const Decl *D : DS->decls()) {\n\
  \        if (const auto *Var = dyn_cast<VarDecl>(D)) {\n          if (Var == VD\
  \ && Var->hasInit()) {\n            LastRHS = Var->getInit();\n            DefStmt\
  \ = DS;\n          }\n        }\n      }\n    }\n\n    // Handle simple assignment:\
  \ \"shorten = expr;\"\n    if (const auto *BO = dyn_cast<BinaryOperator>(S)) {\n\
  \      if (BO->getOpcode() == BO_Assign) {\n        const Expr *LHS = ignoreCastsAndParens(BO->getLHS());\n\
  \        if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS)) {\n          if (DRE->getDecl()\
  \ == VD) {\n            LastRHS = BO->getRHS();\n            DefStmt = BO;\n   \
  \       }\n        }\n      }\n    }\n  }\n\n  return LastRHS;\n}\n\nbool SAGenTestChecker::branchAssignsVarZero(const\
  \ Stmt *Body,\n                                            const VarDecl *VD,\n\
  \                                            CheckerContext &C) {\n  if (!Body ||\
  \ !VD) return false;\n\n  // Walk the subtree to find \"VD = 0;\"\n  if (const auto\
  \ *BO = dyn_cast<BinaryOperator>(Body)) {\n    if (BO->getOpcode() == BO_Assign)\
  \ {\n      const Expr *LHS = ignoreCastsAndParens(BO->getLHS());\n      const Expr\
  \ *RHS = ignoreCastsAndParens(BO->getRHS());\n      if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS))\
  \ {\n        if (DRE->getDecl() == VD && isZeroExpr(RHS, C))\n          return true;\n\
  \      }\n    }\n  }\n\n  for (const Stmt *Child : Body->children()) {\n    if (!Child)\
  \ continue;\n    if (branchAssignsVarZero(Child, VD, C))\n      return true;\n \
  \ }\n  return false;\n}\n\nbool SAGenTestChecker::condChecksShortenVsIterCount(const\
  \ Expr *Cond,\n                                                    const VarDecl\
  \ *VD,\n                                                    CheckerContext &C) {\n\
  \  if (!Cond) return false;\n  Cond = ignoreCastsAndParens(Cond);\n\n  // Look for\
  \ comparison with >= or >\n  if (const auto *BO = dyn_cast<BinaryOperator>(Cond))\
  \ {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n    if (Op == BO_GE || Op\
  \ == BO_GT) {\n      const Expr *L = ignoreCastsAndParens(BO->getLHS());\n     \
  \ const Expr *R = ignoreCastsAndParens(BO->getRHS());\n\n      bool LeftIsShorten\
  \ = refersToVar(L, VD);\n      bool RightIsShorten = refersToVar(R, VD);\n     \
  \ bool LeftIsIterLen = looksLikeIovIterCount(L, C);\n      bool RightIsIterLen =\
  \ looksLikeIovIterCount(R, C);\n\n      // shorten >= iter->count   OR   iter->count\
  \ <= shorten (same meaning)\n      if ((LeftIsShorten && RightIsIterLen) || (RightIsShorten\
  \ && LeftIsIterLen))\n        return true;\n    }\n  }\n\n  // Fallback textual\
  \ guard in condition (coarse)\n  if (ExprHasName(Cond, VD->getName(), C) &&\n  \
  \    (ExprHasName(Cond, \"iov_iter_count\", C) || ExprHasName(Cond, \"count\", C)))\
  \ {\n    return true;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::guardedByShortenCheck(const\
  \ CompoundStmt *CS,\n                                             const Stmt *From,\
  \ const Stmt *To,\n                                             const VarDecl *VD,\n\
  \                                             CheckerContext &C) {\n  if (!CS ||\
  \ !To || !VD) return false;\n\n  bool InRange = (From == nullptr);\n  for (const\
  \ Stmt *S : CS->body()) {\n    if (!InRange) {\n      if (S == From) InRange = true;\n\
  \      continue;\n    }\n    if (S == To)\n      break;\n\n    if (const auto *IfS\
  \ = dyn_cast<IfStmt>(S)) {\n      const Expr *Cond = IfS->getCond();\n      if (condChecksShortenVsIterCount(Cond,\
  \ VD, C)) {\n        // Check if then-branch assigns VD to 0 (like: shorten = 0;)\n\
  \        if (const Stmt *Then = IfS->getThen()) {\n          if (branchAssignsVarZero(Then,\
  \ VD, C))\n            return true;\n        }\n      }\n    }\n  }\n  return false;\n\
  }\n\n// --------- Main logic ---------\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  // We target writes\
  \ to iter->count (struct iov_iter::count)\n  const MemRegion *MR = Loc.getAsRegion();\n\
  \  if (!MR) return;\n  MR = MR->getBaseRegion();\n  if (!isIovIterCountFieldRegion(MR))\n\
  \    return;\n\n  if (!S) return;\n\n  const CompoundAssignOperator *CAO = dyn_cast<CompoundAssignOperator>(S);\n\
  \  const BinaryOperator *BOAssign = dyn_cast<BinaryOperator>(S);\n\n  const Expr\
  \ *ShrinkExpr = nullptr;\n  const Stmt *DefStmt = nullptr;\n  const BinaryOperator\
  \ *Diff = nullptr;\n\n  // Case 1: iter->count -= X;\n  if (CAO && CAO->getOpcode()\
  \ == BO_SubAssign) {\n    // We only analyze pattern when LHS is iter->count; Loc\
  \ already ensures that.\n    ShrinkExpr = CAO->getRHS();\n  }\n  // Case 2: iter->count\
  \ = iter->count - X; or count = something;\n  else if (BOAssign && BOAssign->getOpcode()\
  \ == BO_Assign) {\n    // LHS should be iter->count; the Loc filter ensures this.\n\
  \    const Expr *RHS = BOAssign->getRHS();\n    if (!RHS) return;\n    RHS = ignoreCastsAndParens(RHS);\n\
  \    if (const auto *BOsub = dyn_cast<BinaryOperator>(RHS)) {\n      if (BOsub->getOpcode()\
  \ == BO_Sub) {\n        // Recognize \"iter->count = iter->count - shrink\"\n  \
  \      // Then shrink is the other side, but we actually need shrink itself only\
  \ if used as A-B separately.\n        // However, our pattern focuses on shrink\
  \ being computed as A-B. This assignment form is less common.\n        // We'll\
  \ treat RHS entirely later only if it matches A - B directly.\n        Diff = BOsub;\n\
  \      }\n    } else {\n      // Maybe \"iter->count = iter->count - shorten\" wasn't\
  \ parsed as BinaryOperator at this level.\n      // Or simply \"iter->count = count\
  \ - shorten;\" not our primary target.\n      return;\n    }\n  } else {\n    return;\n\
  \  }\n\n  const Expr *DiffExpr = nullptr;\n\n  // If ShrinkExpr is a variable, find\
  \ its definition as A - B\n  if (ShrinkExpr) {\n    ShrinkExpr = ignoreCastsAndParens(ShrinkExpr);\n\
  \    if (const auto *DRE = dyn_cast<DeclRefExpr>(ShrinkExpr)) {\n      const VarDecl\
  \ *VD = dyn_cast<VarDecl>(DRE->getDecl());\n      if (!VD) return;\n\n      // Find\
  \ the containing CompoundStmt\n      const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(S,\
  \ C);\n      const Expr *DefRHS = findLastDefRHSForVarBefore(VD, CS, S, DefStmt);\n\
  \      if (!DefRHS) return;\n\n      DefRHS = ignoreCastsAndParens(DefRHS);\n  \
  \    if (const auto *BOsub = dyn_cast<BinaryOperator>(DefRHS)) {\n        if (BOsub->getOpcode()\
  \ != BO_Sub)\n          return;\n        DiffExpr = BOsub;\n\n        // Try to\
  \ detect whether there's a guard like:\n        // if (shorten >= iter->count) shorten\
  \ = 0;\n        if (guardedByShortenCheck(CS, DefStmt, S, VD, C)) {\n          return;\
  \ // Properly guarded; do not warn.\n        }\n      } else {\n        return;\n\
  \      }\n    } else if (const auto *BOsub = dyn_cast<BinaryOperator>(ShrinkExpr))\
  \ {\n      if (BOsub->getOpcode() != BO_Sub)\n        return;\n      DiffExpr =\
  \ BOsub;\n    } else {\n      return;\n    }\n  } else if (Diff) {\n    DiffExpr\
  \ = Diff;\n  }\n\n  if (!DiffExpr)\n    return;\n\n  // Ensure it's an unsigned\
  \ 'A - B' style computation.\n  QualType T = DiffExpr->getType();\n  if (!T->isUnsignedIntegerType())\n\
  \    return;\n\n  const auto *BOsub = dyn_cast<BinaryOperator>(DiffExpr);\n  if\
  \ (!BOsub || BOsub->getOpcode() != BO_Sub)\n    return;\n\n  const Expr *A = ignoreCastsAndParens(BOsub->getLHS());\n\
  \  const Expr *B = ignoreCastsAndParens(BOsub->getRHS());\n  if (!A || !B) return;\n\
  \n  // Heuristic recognition of A (current length) and B (aligned length)\n  bool\
  \ AisLen = looksLikeIovIterCount(A, C) || isIovIterCountMemberExpr(A);\n  bool BisAligned\
  \ = looksLikeRoundUp(B, C);\n  if (!(AisLen && BisAligned)) {\n    // Try the opposite\
  \ (be conservative)\n    bool AisAligned = looksLikeRoundUp(A, C);\n    bool BisLen\
  \ = looksLikeIovIterCount(B, C) || isIovIterCountMemberExpr(B);\n    if (!(AisAligned\
  \ && BisLen)) {\n      return; // Not the pattern we look for\n    } else {\n  \
  \    // If it's aligned - len, then it's not our \"shrink = len - aligned\" idiom.\n\
  \      // This is not the underflow pattern we're targeting.\n      return;\n  \
  \  }\n  }\n\n  // Optional constant pruning: if we can prove A >= B at compile-time,\
  \ skip.\n  llvm::APSInt Aval, Bval;\n  if (EvaluateExprToInt(Aval, A, C) && EvaluateExprToInt(Bval,\
  \ B, C)) {\n    if (Aval >= Bval)\n      return;\n  }\n\n  // Report a potential\
  \ underflow\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Potential underflow\
  \ of iter->count when shrinking by aligned length\", N);\n  R->addRange(S->getSourceRange());\n\
  \n  // If we have a defining statement like \"shorten = A - round_up(...);\", point\
  \ to it.\n  if (DefStmt) {\n    PathDiagnosticLocation DefLoc = PathDiagnosticLocation::createBegin(DefStmt,\
  \ C.getSourceManager(), C.getLocationContext());\n    R->addNote(\"shrink amount\
  \ computed here\", DefLoc);\n  }\n\n  C.emitReport(std::move(R));\n}\n\n} // end\
  \ anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects underflow when shrinking iov_iter->count by aligned length without\
  \ guard\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
