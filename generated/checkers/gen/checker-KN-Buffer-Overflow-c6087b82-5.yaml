_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: c6087b82a9146826564a55c5ca0164cac40348f5
commit_type: Buffer-Overflow
index: 5
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states are required for this checker.\n\nnamespace {\n\nclass\
  \ SAGenTestChecker : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"Unbounded copy_from_user\
  \ length\", \"Security\")) {}\n\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\nprivate:\n  // Returns true if Expr text contains any of the common\
  \ clamping helpers plus sizeof(dest)\n  bool isClampedBySizeExpr(const Expr *LenE,\
  \ StringRef DestName, CheckerContext &C) const;\n\n  // Try to conclude the length\
  \ is bounded by the destination's array size.\n  bool isLengthProvablySafe(const\
  \ Expr *LenE, const Expr *DestE,\n                            const llvm::APInt\
  \ &ArraySize, CheckerContext &C) const;\n\n  // Try to conclude the variable used\
  \ as length is clamped/safe, by inspecting its initializer.\n  bool isLenVarInitSafe(const\
  \ VarDecl *VD, StringRef DestName,\n                        const llvm::APInt &ArraySize,\
  \ CheckerContext &C) const;\n\n  // Helper to evaluate constant and compare to array\
  \ size.\n  bool constLEArraySize(const Expr *E, const llvm::APInt &ArraySize, CheckerContext\
  \ &C) const;\n};\n\nbool SAGenTestChecker::constLEArraySize(const Expr *E, const\
  \ llvm::APInt &ArraySize,\n                                        CheckerContext\
  \ &C) const {\n  if (!E)\n    return false;\n  llvm::APSInt EvalRes;\n  if (!EvaluateExprToInt(EvalRes,\
  \ E, C))\n    return false;\n\n  uint64_t LenVal = EvalRes.isSigned() ? (uint64_t)EvalRes.getSExtValue()\n\
  \                                       : EvalRes.getZExtValue();\n  uint64_t ArrSz\
  \ = ArraySize.getLimitedValue(UINT64_MAX);\n  return LenVal <= ArrSz;\n}\n\nbool\
  \ SAGenTestChecker::isClampedBySizeExpr(const Expr *LenE, StringRef DestName,\n\
  \                                           CheckerContext &C) const {\n  if (!LenE)\n\
  \    return false;\n  // Recognize common clamp idioms: min/min_t/min3/clamp with\
  \ sizeof(dest)\n  bool HasClampFunc = ExprHasName(LenE, \"min\", C) ||\n       \
  \               ExprHasName(LenE, \"min_t\", C) ||\n                      ExprHasName(LenE,\
  \ \"min3\", C) ||\n                      ExprHasName(LenE, \"clamp\", C);\n  if\
  \ (!HasClampFunc)\n    return false;\n\n  if (!DestName.empty()) {\n    std::string\
  \ SizeofDest = (\"sizeof(\" + DestName + \")\").str();\n    if (ExprHasName(LenE,\
  \ SizeofDest, C))\n      return true;\n  }\n  // If we cannot match the exact destination\
  \ name in sizeof, be conservative: do not claim safe.\n  return false;\n}\n\nbool\
  \ SAGenTestChecker::isLenVarInitSafe(const VarDecl *VD, StringRef DestName,\n  \
  \                                      const llvm::APInt &ArraySize,\n         \
  \                               CheckerContext &C) const {\n  if (!VD || !VD->hasInit())\n\
  \    return false;\n\n  const Expr *Init = VD->getInit();\n  if (!Init)\n    return\
  \ false;\n\n  // Constant <= array size\n  if (constLEArraySize(Init, ArraySize,\
  \ C))\n    return true;\n\n  // Clamp idiom using sizeof(dest)\n  if (isClampedBySizeExpr(Init,\
  \ DestName, C))\n    return true;\n\n  // We can try to see if Init has a symbolic\
  \ max <= array size.\n  SVal InitVal = C.getState()->getSVal(Init, C.getLocationContext());\n\
  \  if (SymbolRef Sym = InitVal.getAsSymbol()) {\n    if (const llvm::APSInt *Max\
  \ = inferSymbolMaxVal(Sym, C)) {\n      uint64_t MaxV = Max->isSigned() ? (uint64_t)Max->getSExtValue()\n\
  \                                      : Max->getZExtValue();\n      uint64_t ArrSz\
  \ = ArraySize.getLimitedValue(UINT64_MAX);\n      if (MaxV <= ArrSz)\n        return\
  \ true;\n    }\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isLengthProvablySafe(const\
  \ Expr *LenE, const Expr *DestE,\n                                            const\
  \ llvm::APInt &ArraySize,\n                                            CheckerContext\
  \ &C) const {\n  if (!LenE || !DestE)\n    return false;\n\n  // 1) Constant evaluation\n\
  \  if (constLEArraySize(LenE, ArraySize, C))\n    return true;\n\n  // Determine\
  \ destination variable name if available\n  StringRef DestName;\n  if (const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(DestE->IgnoreImplicit())) {\n    if (const auto *VD\
  \ = dyn_cast<VarDecl>(DRE->getDecl())) {\n      DestName = VD->getName();\n    }\n\
  \  }\n\n  // 2) Symbolic maximum\n  SVal LenVal = C.getState()->getSVal(LenE, C.getLocationContext());\n\
  \  if (SymbolRef Sym = LenVal.getAsSymbol()) {\n    if (const llvm::APSInt *Max\
  \ = inferSymbolMaxVal(Sym, C)) {\n      uint64_t MaxV = Max->isSigned() ? (uint64_t)Max->getSExtValue()\n\
  \                                      : Max->getZExtValue();\n      uint64_t ArrSz\
  \ = ArraySize.getLimitedValue(UINT64_MAX);\n      if (MaxV <= ArrSz)\n        return\
  \ true;\n    }\n  }\n\n  // 3) Clamp idioms e.g. min(nbytes, sizeof(buf)[-1])\n\
  \  if (isClampedBySizeExpr(LenE, DestName, C))\n    return true;\n\n  // 4) If Len\
  \ is a variable, check its initializer for clamping patterns\n  if (const auto *LenDRE\
  \ = dyn_cast<DeclRefExpr>(LenE->IgnoreParenCasts())) {\n    if (const auto *LenVD\
  \ = dyn_cast<VarDecl>(LenDRE->getDecl())) {\n      if (isLenVarInitSafe(LenVD, DestName,\
  \ ArraySize, C))\n        return true;\n    }\n  }\n\n  return false;\n}\n\nvoid\
  \ SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  // Verify function name via expression text\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr || !ExprHasName(OriginExpr, \"copy_from_user\", C))\n    return;\n\
  \n  // Expect 3 arguments: (dst, src, len)\n  if (Call.getNumArgs() != 3)\n    return;\n\
  \n  const Expr *DestE = Call.getArgExpr(0);\n  const Expr *LenE  = Call.getArgExpr(2);\n\
  \  if (!DestE || !LenE)\n    return;\n\n  // Destination must be a fixed-size array\
  \ we can reason about\n  llvm::APInt ArraySize;\n  if (!getArraySizeFromExpr(ArraySize,\
  \ DestE))\n    return; // Unknown destination bound; avoid false positives\n\n \
  \ // If length is not provably <= sizeof(dest), warn\n  if (!isLengthProvablySafe(LenE,\
  \ DestE, ArraySize, C)) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"copy_from_user length not clamped to destination buffer size\",\
  \ N);\n\n    if (const auto *CE = dyn_cast<CallExpr>(OriginExpr))\n      R->addRange(CE->getSourceRange());\n\
  \    R->addRange(DestE->getSourceRange());\n    R->addRange(LenE->getSourceRange());\n\
  \n    R->addNote(\"Clamp length, e.g., min(nbytes, sizeof(buf) - 1), and use the\
  \ \"\n               \"clamped value for both copy and return size if applicable.\"\
  ,\n               PathDiagnosticLocation::createBegin(OriginExpr, C.getSourceManager(),\n\
  \                                                   C.getLocationContext()));\n\
  \    C.emitReport(std::move(R));\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect unbounded copy_from_user into\
  \ fixed-size buffers (possible overflow)\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nscsi: lpfc: Prevent lpfc_debugfs_lockstat_write()\
  \ buffer overflow\n\nA static code analysis tool flagged the possibility of buffer\
  \ overflow when\nusing copy_from_user() for a debugfs entry.\n\nCurrently, it is\
  \ possible that copy_from_user() copies more bytes than what\nwould fit in the mybuf\
  \ char array.  Add a min() restriction check between\nsizeof(mybuf) - 1 and nbytes\
  \ passed from the userspace buffer to protect\nagainst buffer overflow.\n\nLink:\
  \ https://lore.kernel.org/r/20230301231626.9621-2-justintee8345@gmail.com\nSigned-off-by:\
  \ Justin Tee <justin.tee@broadcom.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>\n\
  \n## Buggy Code\n\n```c\n// Function: lpfc_debugfs_lockstat_write in drivers/scsi/lpfc/lpfc_debugfs.c\n\
  static ssize_t\nlpfc_debugfs_lockstat_write(struct file *file, const char __user\
  \ *buf,\n\t\t\t    size_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug =\
  \ file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\
  \tstruct lpfc_sli4_hdw_queue *qp;\n\tchar mybuf[64];\n\tchar *pbuf;\n\tint i;\n\n\
  \tmemset(mybuf, 0, sizeof(mybuf));\n\n\tif (copy_from_user(mybuf, buf, nbytes))\n\
  \t\treturn -EFAULT;\n\tpbuf = &mybuf[0];\n\n\tif ((strncmp(pbuf, \"reset\", strlen(\"\
  reset\")) == 0) ||\n\t    (strncmp(pbuf, \"zero\", strlen(\"zero\")) == 0)) {\n\t\
  \tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\t\tqp = &phba->sli4_hba.hdwq[i];\n\
  \t\t\tqp->lock_conflict.alloc_xri_get = 0;\n\t\t\tqp->lock_conflict.alloc_xri_put\
  \ = 0;\n\t\t\tqp->lock_conflict.free_xri = 0;\n\t\t\tqp->lock_conflict.wq_access\
  \ = 0;\n\t\t\tqp->lock_conflict.alloc_pvt_pool = 0;\n\t\t\tqp->lock_conflict.mv_from_pvt_pool\
  \ = 0;\n\t\t\tqp->lock_conflict.mv_to_pub_pool = 0;\n\t\t\tqp->lock_conflict.mv_to_pvt_pool\
  \ = 0;\n\t\t\tqp->lock_conflict.free_pvt_pool = 0;\n\t\t\tqp->lock_conflict.free_pub_pool\
  \ = 0;\n\t\t\tqp->lock_conflict.wq_access = 0;\n\t\t}\n\t}\n\treturn nbytes;\n}\n\
  ```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/scsi/lpfc/lpfc_debugfs.c\
  \ b/drivers/scsi/lpfc/lpfc_debugfs.c\nindex f5252e45a48a..3e365e5e194a 100644\n\
  --- a/drivers/scsi/lpfc/lpfc_debugfs.c\n+++ b/drivers/scsi/lpfc/lpfc_debugfs.c\n\
  @@ -2157,10 +2157,13 @@ lpfc_debugfs_lockstat_write(struct file *file, const char\
  \ __user *buf,\n \tchar mybuf[64];\n \tchar *pbuf;\n \tint i;\n+\tsize_t bsize;\n\
  \ \n \tmemset(mybuf, 0, sizeof(mybuf));\n \n-\tif (copy_from_user(mybuf, buf, nbytes))\n\
  +\tbsize = min(nbytes, (sizeof(mybuf) - 1));\n+\n+\tif (copy_from_user(mybuf, buf,\
  \ bsize))\n \t\treturn -EFAULT;\n \tpbuf = &mybuf[0];\n \n@@ -2181,7 +2184,7 @@\
  \ lpfc_debugfs_lockstat_write(struct file *file, const char __user *buf,\n \t\t\t\
  qp->lock_conflict.wq_access = 0;\n \t\t}\n \t}\n-\treturn nbytes;\n+\treturn bsize;\n\
  \ }\n #endif\n \n```\n"
pattern: '## Bug Pattern


  Copying user-provided data into a fixed-size buffer using copy_from_user() with
  an unbounded, user-controlled length (nbytes), i.e.:


  char buf[64];

  if (copy_from_user(buf, user_buf, nbytes))  // nbytes may exceed sizeof(buf)


  This allows a stack buffer overflow. The correct pattern is to clamp the copy length
  to the buffer size (typically sizeof(buf) - 1 if later treated as a string) and
  use that bounded length for both copying and the return value.'
plan: "Plan\n\n1. Program State\n   - No custom program state is required. This checker\
  \ is a local syntactic/semantic validation around a single call site of copy_from_user().\
  \ Keep it stateless to stay simple and robust.\n\n2. Callbacks\n   - Use only checkPreCall.\
  \ Optionally (non-essential) use checkEndFunction to verify the returned value matches\
  \ the clamped length if you decide to enforce the \u201Cuse bounded length for return\
  \ value\u201D as well.\n\n3. checkPreCall: Detect unbounded copy_from_user into\
  \ a fixed-size buffer\n   - Goal: When encountering copy_from_user(dst, src, len),\
  \ warn if len is not provably bounded by the size of the destination fixed-size\
  \ buffer (ideally sizeof(buf) - 1 when later used as string).\n   - Steps:\n   \
  \  1) Match function:\n        - If callee name is \"copy_from_user\" (via Call.getCalleeIdentifier()->getName()).\n\
  \        - Require exactly 3 arguments; extract:\n          - DestExpr = Call.getArgExpr(0)\n\
  \          - LenExpr  = Call.getArgExpr(2)\n     2) Identify a fixed-size destination\
  \ buffer:\n        - Use getArraySizeFromExpr(ArraySize, DestExpr) to obtain a constant\
  \ array size. If this fails (destination is not a constant array, e.g., pointer\
  \ param), skip to avoid false positives.\n        - Save DestVarName if possible:\n\
  \          - If DestExpr is DeclRefExpr to a VarDecl, get VD->getName().\n     3)\
  \ Determine if the length argument is already clamped (fast textual/structural checks):\n\
  \        - If EvaluateExprToInt(EvalRes, LenExpr, C) succeeds:\n          - If EvalRes\
  \ <= ArraySize (treat as safe). If you want to enforce string semantics, use ArraySize\
  \ - 1 as the bound.\n          - Otherwise, report.\n        - Else, try to infer\
  \ a symbolic upper bound:\n          - Extract the SVal of LenExpr and its SymbolRef;\
  \ use inferSymbolMaxVal(Sym, C).\n          - If maxVal exists and maxVal <= ArraySize\
  \ (or ArraySize - 1 for string semantics), treat as safe. Otherwise continue checks.\n\
  \        - Else, try to detect common clamp idioms by inspecting the expression\
  \ text and structure:\n          - If ExprHasName(LenExpr, \"min\", C) or ExprHasName(LenExpr,\
  \ \"min_t\", C) or ExprHasName(LenExpr, \"min3\", C) or ExprHasName(LenExpr, \"\
  clamp\", C):\n            - If also ExprHasName(LenExpr, \"sizeof\", C) and (DestVarName\
  \ is known and ExprHasName(LenExpr, (\"sizeof(\" + DestVarName + \")\").str(), C)),\
  \ treat as safe.\n            - Else if ExprHasName(LenExpr, \"sizeof\", C) without\
  \ DestVarName match, conservatively treat as safe (to reduce false positives), but\
  \ this is optional; tighter: require sizeof to mention the exact destination buffer\
  \ name if available.\n        - Else, if LenExpr is a DeclRefExpr to a local variable\
  \ (e.g., bsize):\n          - Inspect the VarDecl initializer if present:\n    \
  \        - If it contains min/min_t/min3/clamp and sizeof(DestVarName), treat as\
  \ safe.\n            - If it is a constant and <= ArraySize (or -1 for string semantics),\
  \ treat as safe.\n          - If no initializer or not conclusive, proceed to warn\
  \ (the most common unsafe pattern passes a parameter like nbytes unchanged).\n \
  \    4) Reporting:\n        - If none of the above \u201Csafe\u201D conditions hold,\
  \ emit a bug:\n          - Message: \"copy_from_user length not clamped to destination\
  \ buffer size\"\n          - Use a PathSensitiveBugReport.\n          - Highlight\
  \ the call expression, the destination argument, and the length argument as interesting\
  \ sources.\n          - Provide a short fix-it hint in the description: \"Clamp\
  \ length: min(nbytes, sizeof(buf) - 1)\".\n\n4. Optional enhancement (return value\
  \ consistency): checkEndFunction\n   - Purpose: If you enforced and detected clamping\
  \ (e.g., bsize) and the function returns the original unbounded parameter (e.g.,\
  \ nbytes), flag a secondary advisory.\n   - Simplest approach without program state:\n\
  \     - Within checkPreCall when you detect a safe clamp via a variable (e.g., LenExpr\
  \ is DeclRefExpr to var \u2018bsize\u2019), store the SourceRange or the identifier\
  \ name of this var in a small local set keyed by the current function (could be\
  \ a static map keyed by LCtx function pointer). This is optional but requires minimal\
  \ state. Alternatively, skip this feature to keep the checker purely stateless.\n\
  \     - In checkEndFunction, if the ReturnStmt returns a DeclRefExpr of a function\
  \ parameter (like \u2018nbytes\u2019) and you previously observed a clamped variable\
  \ used as copy length in this function, warn:\n       - Message: \"Function returns\
  \ unbounded length; return the clamped length used for copy\"\n     - Keep this\
  \ as a low-priority note. It\u2019s not required for detecting the overflow.\n\n\
  5. Utilities to use\n   - getArraySizeFromExpr to obtain fixed buffer size from\
  \ the destination expression.\n   - EvaluateExprToInt for constant-length expressions.\n\
  \   - inferSymbolMaxVal for symbolic length upper-bound reasoning.\n   - ExprHasName\
  \ to detect min/min_t/min3/clamp/sizeof patterns and check whether sizeof references\
  \ the destination buffer variable.\n   - findSpecificTypeInParents/Children are\
  \ not necessary for the core detection, so avoid unless you add extra context checks.\n\
  \n6. False-positive control\n   - Only warn when:\n     - Destination is a constant-sized\
  \ array (we know the bound), and\n     - The length argument is not provably bounded\
  \ by that array\u2019s size through constant evaluation, symbolic upper bound, or\
  \ clear min()/sizeof() idioms.\n   - This keeps the checker precise and focused\
  \ on the pattern in the provided patch.\n\n7. Summary of minimal implementation\n\
  \   - No program state traits/maps.\n   - One core callback: checkPreCall.\n   -\
  \ Logic:\n     - Match copy_from_user.\n     - Get dest array size; if unknown,\
  \ skip.\n     - Assess len boundedness:\n       - Constant <= size (or size - 1)\
  \ \u2192 safe.\n       - Symbolic max <= size (or size - 1) \u2192 safe.\n     \
  \  - Len contains min()/sizeof(dest) clamp idiom \u2192 safe.\n       - Len is var\
  \ with initializer using min()/sizeof(dest) \u2192 safe.\n       - Otherwise \u2192\
  \ report.\n   - Short, clear report message."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states are required for this checker.\n\nnamespace {\n\nclass\
  \ SAGenTestChecker : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"Unbounded copy_from_user\
  \ length\", \"Security\")) {}\n\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\nprivate:\n  // Returns true if Expr text contains any of the common\
  \ clamping helpers plus sizeof(dest)\n  bool isClampedBySizeExpr(const Expr *LenE,\
  \ StringRef DestName, CheckerContext &C) const;\n\n  // Try to conclude the length\
  \ is bounded by the destination's array size.\n  bool isLengthProvablySafe(const\
  \ Expr *LenE, const Expr *DestE,\n                            const llvm::APInt\
  \ &ArraySize, CheckerContext &C) const;\n\n  // Try to conclude the variable used\
  \ as length is clamped/safe, by inspecting its initializer.\n  bool isLenVarInitSafe(const\
  \ VarDecl *VD, StringRef DestName,\n                        const llvm::APInt &ArraySize,\
  \ CheckerContext &C) const;\n\n  // Helper to evaluate constant and compare to array\
  \ size.\n  bool constLEArraySize(const Expr *E, const llvm::APInt &ArraySize, CheckerContext\
  \ &C) const;\n};\n\nbool SAGenTestChecker::constLEArraySize(const Expr *E, const\
  \ llvm::APInt &ArraySize,\n                                        CheckerContext\
  \ &C) const {\n  if (!E)\n    return false;\n  llvm::APSInt EvalRes;\n  if (!EvaluateExprToInt(EvalRes,\
  \ E, C))\n    return false;\n\n  uint64_t LenVal = EvalRes.isSigned() ? (uint64_t)EvalRes.getSExtValue()\n\
  \                                       : EvalRes.getZExtValue();\n  uint64_t ArrSz\
  \ = ArraySize.getLimitedValue(UINT64_MAX);\n  return LenVal <= ArrSz;\n}\n\nbool\
  \ SAGenTestChecker::isClampedBySizeExpr(const Expr *LenE, StringRef DestName,\n\
  \                                           CheckerContext &C) const {\n  if (!LenE)\n\
  \    return false;\n  // Recognize common clamp idioms: min/min_t/min3/clamp with\
  \ sizeof(dest)\n  bool HasClampFunc = ExprHasName(LenE, \"min\", C) ||\n       \
  \               ExprHasName(LenE, \"min_t\", C) ||\n                      ExprHasName(LenE,\
  \ \"min3\", C) ||\n                      ExprHasName(LenE, \"clamp\", C);\n  if\
  \ (!HasClampFunc)\n    return false;\n\n  if (!DestName.empty()) {\n    std::string\
  \ SizeofDest = (\"sizeof(\" + DestName + \")\").str();\n    if (ExprHasName(LenE,\
  \ SizeofDest, C))\n      return true;\n  }\n  // If we cannot match the exact destination\
  \ name in sizeof, be conservative: do not claim safe.\n  return false;\n}\n\nbool\
  \ SAGenTestChecker::isLenVarInitSafe(const VarDecl *VD, StringRef DestName,\n  \
  \                                      const llvm::APInt &ArraySize,\n         \
  \                               CheckerContext &C) const {\n  if (!VD || !VD->hasInit())\n\
  \    return false;\n\n  const Expr *Init = VD->getInit();\n  if (!Init)\n    return\
  \ false;\n\n  // Constant <= array size\n  if (constLEArraySize(Init, ArraySize,\
  \ C))\n    return true;\n\n  // Clamp idiom using sizeof(dest)\n  if (isClampedBySizeExpr(Init,\
  \ DestName, C))\n    return true;\n\n  // We can try to see if Init has a symbolic\
  \ max <= array size.\n  SVal InitVal = C.getState()->getSVal(Init, C.getLocationContext());\n\
  \  if (SymbolRef Sym = InitVal.getAsSymbol()) {\n    if (const llvm::APSInt *Max\
  \ = inferSymbolMaxVal(Sym, C)) {\n      uint64_t MaxV = Max->isSigned() ? (uint64_t)Max->getSExtValue()\n\
  \                                      : Max->getZExtValue();\n      uint64_t ArrSz\
  \ = ArraySize.getLimitedValue(UINT64_MAX);\n      if (MaxV <= ArrSz)\n        return\
  \ true;\n    }\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isLengthProvablySafe(const\
  \ Expr *LenE, const Expr *DestE,\n                                            const\
  \ llvm::APInt &ArraySize,\n                                            CheckerContext\
  \ &C) const {\n  if (!LenE || !DestE)\n    return false;\n\n  // 1) Constant evaluation\n\
  \  if (constLEArraySize(LenE, ArraySize, C))\n    return true;\n\n  // Determine\
  \ destination variable name if available\n  StringRef DestName;\n  if (const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(DestE->IgnoreImplicit())) {\n    if (const auto *VD\
  \ = dyn_cast<VarDecl>(DRE->getDecl())) {\n      DestName = VD->getName();\n    }\n\
  \  }\n\n  // 2) Symbolic maximum\n  SVal LenVal = C.getState()->getSVal(LenE, C.getLocationContext());\n\
  \  if (SymbolRef Sym = LenVal.getAsSymbol()) {\n    if (const llvm::APSInt *Max\
  \ = inferSymbolMaxVal(Sym, C)) {\n      uint64_t MaxV = Max->isSigned() ? (uint64_t)Max->getSExtValue()\n\
  \                                      : Max->getZExtValue();\n      uint64_t ArrSz\
  \ = ArraySize.getLimitedValue(UINT64_MAX);\n      if (MaxV <= ArrSz)\n        return\
  \ true;\n    }\n  }\n\n  // 3) Clamp idioms e.g. min(nbytes, sizeof(buf)[-1])\n\
  \  if (isClampedBySizeExpr(LenE, DestName, C))\n    return true;\n\n  // 4) If Len\
  \ is a variable, check its initializer for clamping patterns\n  if (const auto *LenDRE\
  \ = dyn_cast<DeclRefExpr>(LenE->IgnoreParenCasts())) {\n    if (const auto *LenVD\
  \ = dyn_cast<VarDecl>(LenDRE->getDecl())) {\n      if (isLenVarInitSafe(LenVD, DestName,\
  \ ArraySize, C))\n        return true;\n    }\n  }\n\n  return false;\n}\n\nvoid\
  \ SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  // Verify function name via expression text\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr || !ExprHasName(OriginExpr, \"copy_from_user\", C))\n    return;\n\
  \n  // Expect 3 arguments: (dst, src, len)\n  if (Call.getNumArgs() != 3)\n    return;\n\
  \n  const Expr *DestE = Call.getArgExpr(0);\n  const Expr *LenE  = Call.getArgExpr(2);\n\
  \  if (!DestE || !LenE)\n    return;\n\n  // Destination must be a fixed-size array\
  \ we can reason about\n  llvm::APInt ArraySize;\n  if (!getArraySizeFromExpr(ArraySize,\
  \ DestE))\n    return; // Unknown destination bound; avoid false positives\n\n \
  \ // If length is not provably <= sizeof(dest), warn\n  if (!isLengthProvablySafe(LenE,\
  \ DestE, ArraySize, C)) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"copy_from_user length not clamped to destination buffer size\",\
  \ N);\n\n    if (const auto *CE = dyn_cast<CallExpr>(OriginExpr))\n      R->addRange(CE->getSourceRange());\n\
  \    R->addRange(DestE->getSourceRange());\n    R->addRange(LenE->getSourceRange());\n\
  \n    R->addNote(\"Clamp length, e.g., min(nbytes, sizeof(buf) - 1), and use the\
  \ \"\n               \"clamped value for both copy and return size if applicable.\"\
  ,\n               PathDiagnosticLocation::createBegin(OriginExpr, C.getSourceManager(),\n\
  \                                                   C.getLocationContext()));\n\
  \    C.emitReport(std::move(R));\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect unbounded copy_from_user into\
  \ fixed-size buffers (possible overflow)\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
