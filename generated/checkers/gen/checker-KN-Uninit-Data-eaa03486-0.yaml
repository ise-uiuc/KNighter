_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: eaa03486d932572dfd1c5f64f9dfebe572ad88c0
commit_type: Uninit-Data
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(StatusVarAssignedMap,\
  \ const MemRegion*, bool)\nREGISTER_SET_WITH_PROGRAMSTATE(ReportedSet, const MemRegion*)\n\
  \nnamespace {\nclass SAGenTestChecker\n  : public Checker<\n        check::PostStmt<DeclStmt>,\n\
  \        check::Bind,\n        check::PreStmt<ReturnStmt>\n    > {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Uninitialized\
  \ return\", \"Logic error\")) {}\n\n      void checkPostStmt(const DeclStmt *DS,\
  \ CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const Stmt\
  \ *S, CheckerContext &C) const;\n      void checkPreStmt(const ReturnStmt *RS, CheckerContext\
  \ &C) const;\n\n   private:\n      static const FunctionDecl *getEnclosingFunction(const\
  \ CheckerContext &C);\n      static bool functionReturnsInteger(const CheckerContext\
  \ &C);\n      static bool isCandidateStatusVar(const VarDecl *VD, const CheckerContext\
  \ &C);\n      static const MemRegion *getVarRegion(const VarDecl *VD, CheckerContext\
  \ &C);\n      void reportUninitializedReturn(const VarDecl *VD, const MemRegion\
  \ *R,\n                                     const ReturnStmt *RS, CheckerContext\
  \ &C) const;\n};\n\nconst FunctionDecl *SAGenTestChecker::getEnclosingFunction(const\
  \ CheckerContext &C) {\n  const Decl *D = C.getLocationContext() ? C.getLocationContext()->getDecl()\
  \ : nullptr;\n  return dyn_cast_or_null<FunctionDecl>(D);\n}\n\nbool SAGenTestChecker::functionReturnsInteger(const\
  \ CheckerContext &C) {\n  const FunctionDecl *FD = getEnclosingFunction(C);\n  if\
  \ (!FD)\n    return false;\n  return FD->getReturnType()->isIntegerType();\n}\n\n\
  bool SAGenTestChecker::isCandidateStatusVar(const VarDecl *VD, const CheckerContext\
  \ &C) {\n  if (!VD)\n    return false;\n\n  if (!VD->hasLocalStorage())\n    return\
  \ false;\n  if (VD->isStaticLocal())\n    return false;\n  if (!VD->getType()->isIntegerType())\n\
  \    return false;\n  if (VD->hasInit())\n    return false;\n  if (!functionReturnsInteger(C))\n\
  \    return false;\n\n  if (const IdentifierInfo *II = VD->getIdentifier()) {\n\
  \    StringRef Name = II->getName();\n    if (Name == \"ret\" || Name == \"rc\"\
  \ || Name == \"err\")\n      return true;\n  }\n  return false;\n}\n\nconst MemRegion\
  \ *SAGenTestChecker::getVarRegion(const VarDecl *VD, CheckerContext &C) {\n  ProgramStateRef\
  \ State = C.getState();\n  if (!State || !VD)\n    return nullptr;\n  const LocationContext\
  \ *LCtx = C.getLocationContext();\n  if (!LCtx)\n    return nullptr;\n  const MemRegion\
  \ *MR = State->getRegionManager().getVarRegion(VD, LCtx);\n  return MR;\n}\n\nvoid\
  \ SAGenTestChecker::checkPostStmt(const DeclStmt *DS, CheckerContext &C) const {\n\
  \  if (!DS)\n    return;\n\n  ProgramStateRef State = C.getState();\n  ProgramStateRef\
  \ NewState = State;\n\n  for (const Decl *D : DS->decls()) {\n    const VarDecl\
  \ *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      continue;\n\n    if (!isCandidateStatusVar(VD,\
  \ C))\n      continue;\n\n    const MemRegion *MR = getVarRegion(VD, C);\n    if\
  \ (!MR)\n      continue;\n    MR = MR->getBaseRegion();\n    if (!MR)\n      continue;\n\
  \n    // Initialize tracking as \"unassigned\"/\"uninitialized\"\n    NewState =\
  \ NewState->set<StatusVarAssignedMap>(MR, false);\n  }\n\n  if (NewState != State)\n\
  \    C.addTransition(NewState);\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc,\
  \ SVal, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  const MemRegion *R = Loc.getAsRegion();\n  if (!R)\n    return;\n  R = R->getBaseRegion();\n\
  \  if (!R)\n    return;\n\n  const bool *Tracked = State->get<StatusVarAssignedMap>(R);\n\
  \  if (!Tracked)\n    return;\n\n  // Any store to the tracked variable marks it\
  \ as assigned on this path.\n  ProgramStateRef NewState = State->set<StatusVarAssignedMap>(R,\
  \ true);\n  if (NewState != State)\n    C.addTransition(NewState);\n}\n\nvoid SAGenTestChecker::reportUninitializedReturn(const\
  \ VarDecl *VD, const MemRegion *R,\n                                           \
  \      const ReturnStmt *RS, CheckerContext &C) const {\n  if (!BT || !R || !RS)\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n\n  // Avoid duplicate\
  \ reports for the same region on the same path.\n  if (State->contains<ReportedSet>(R))\n\
  \    return;\n\n  ProgramStateRef NewState = State->add<ReportedSet>(R);\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode(NewState);\n  if (!N)\n    return;\n\n  std::string\
  \ VarName = VD ? VD->getName().str() : std::string(\"variable\");\n  std::string\
  \ Msg = \"returning uninitialized local '\" + VarName + \"'\";\n\n  auto Rpt = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  Rpt->addRange(RS->getSourceRange());\n  C.emitReport(std::move(Rpt));\n\
  }\n\nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt *RS, CheckerContext &C)\
  \ const {\n  if (!RS)\n    return;\n  if (!functionReturnsInteger(C))\n    return;\n\
  \n  const Expr *E = RS->getRetValue();\n  if (!E)\n    return;\n\n  const Expr *SimpE\
  \ = E->IgnoreParenImpCasts();\n  const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(SimpE);\n\
  \  if (!DRE)\n    return;\n\n  const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl());\n\
  \  if (!VD)\n    return;\n\n  const MemRegion *MR = getVarRegion(VD, C);\n  if (!MR)\n\
  \    return;\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  const bool *Assigned = State->get<StatusVarAssignedMap>(MR);\n\
  \n  // If we tracked it and it is still unassigned -> bug\n  if (Assigned && !*Assigned)\
  \ {\n    reportUninitializedReturn(VD, MR, RS, C);\n    return;\n  }\n\n  // If\
  \ not tracked (e.g., missed DeclStmt), but it is a candidate, also warn.\n  if (!Assigned\
  \ && isCandidateStatusVar(VD, C)) {\n    reportUninitializedReturn(VD, MR, RS, C);\n\
  \    return;\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects returning an uninitialized local status variable (e.g., 'ret')\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nregmap: maple: Fix uninitialized symbol 'ret' warnings\n\
  \nFix warnings reported by smatch by initializing local 'ret' variable\nto 0.\n\n\
  drivers/base/regmap/regcache-maple.c:186 regcache_maple_drop()\nerror: uninitialized\
  \ symbol 'ret'.\ndrivers/base/regmap/regcache-maple.c:290 regcache_maple_sync()\n\
  error: uninitialized symbol 'ret'.\n\nSigned-off-by: Richard Fitzgerald <rf@opensource.cirrus.com>\n\
  Fixes: f033c26de5a5 (\"regmap: Add maple tree based register cache\")\nLink: https://lore.kernel.org/r/20240329144630.1965159-1-rf@opensource.cirrus.com\n\
  Signed-off-by: Mark Brown <broonie@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ regcache_maple_drop in drivers/base/regmap/regcache-maple.c\nstatic int regcache_maple_drop(struct\
  \ regmap *map, unsigned int min,\n\t\t\t       unsigned int max)\n{\n\tstruct maple_tree\
  \ *mt = map->cache;\n\tMA_STATE(mas, mt, min, max);\n\tunsigned long *entry, *lower,\
  \ *upper;\n\tunsigned long lower_index, lower_last;\n\tunsigned long upper_index,\
  \ upper_last;\n\tint ret;\n\n\tlower = NULL;\n\tupper = NULL;\n\n\tmas_lock(&mas);\n\
  \n\tmas_for_each(&mas, entry, max) {\n\t\t/*\n\t\t * This is safe because the regmap\
  \ lock means the\n\t\t * Maple lock is redundant, but we need to take it due\n\t\
  \t * to lockdep asserts in the maple tree code.\n\t\t */\n\t\tmas_unlock(&mas);\n\
  \n\t\t/* Do we need to save any of this entry? */\n\t\tif (mas.index < min) {\n\t\
  \t\tlower_index = mas.index;\n\t\t\tlower_last = min -1;\n\n\t\t\tlower = kmemdup(entry,\
  \ ((min - mas.index) *\n\t\t\t\t\t\tsizeof(unsigned long)),\n\t\t\t\t\tmap->alloc_flags);\n\
  \t\t\tif (!lower) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_unlocked;\n\t\t\t\
  }\n\t\t}\n\n\t\tif (mas.last > max) {\n\t\t\tupper_index = max + 1;\n\t\t\tupper_last\
  \ = mas.last;\n\n\t\t\tupper = kmemdup(&entry[max - mas.index + 1],\n\t\t\t\t\t\
  ((mas.last - max) *\n\t\t\t\t\t sizeof(unsigned long)),\n\t\t\t\t\tmap->alloc_flags);\n\
  \t\t\tif (!upper) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_unlocked;\n\t\t\t\
  }\n\t\t}\n\n\t\tkfree(entry);\n\t\tmas_lock(&mas);\n\t\tmas_erase(&mas);\n\n\t\t\
  /* Insert new nodes with the saved data */\n\t\tif (lower) {\n\t\t\tmas_set_range(&mas,\
  \ lower_index, lower_last);\n\t\t\tret = mas_store_gfp(&mas, lower, map->alloc_flags);\n\
  \t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tlower = NULL;\n\t\t}\n\n\t\tif (upper)\
  \ {\n\t\t\tmas_set_range(&mas, upper_index, upper_last);\n\t\t\tret = mas_store_gfp(&mas,\
  \ upper, map->alloc_flags);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tupper\
  \ = NULL;\n\t\t}\n\t}\n\nout:\n\tmas_unlock(&mas);\nout_unlocked:\n\tkfree(lower);\n\
  \tkfree(upper);\n\n\treturn ret;\n}\n```\n\n```c\n// Function: regcache_maple_sync\
  \ in drivers/base/regmap/regcache-maple.c\nstatic int regcache_maple_sync(struct\
  \ regmap *map, unsigned int min,\n\t\t\t       unsigned int max)\n{\n\tstruct maple_tree\
  \ *mt = map->cache;\n\tunsigned long *entry;\n\tMA_STATE(mas, mt, min, max);\n\t\
  unsigned long lmin = min;\n\tunsigned long lmax = max;\n\tunsigned int r, v, sync_start;\n\
  \tint ret;\n\tbool sync_needed = false;\n\n\tmap->cache_bypass = true;\n\n\trcu_read_lock();\n\
  \n\tmas_for_each(&mas, entry, max) {\n\t\tfor (r = max(mas.index, lmin); r <= min(mas.last,\
  \ lmax); r++) {\n\t\t\tv = entry[r - mas.index];\n\n\t\t\tif (regcache_reg_needs_sync(map,\
  \ r, v)) {\n\t\t\t\tif (!sync_needed) {\n\t\t\t\t\tsync_start = r;\n\t\t\t\t\tsync_needed\
  \ = true;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!sync_needed)\n\t\t\
  \t\tcontinue;\n\n\t\t\tret = regcache_maple_sync_block(map, entry, &mas,\n\t\t\t\
  \t\t\t\tsync_start, r);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tsync_needed\
  \ = false;\n\t\t}\n\n\t\tif (sync_needed) {\n\t\t\tret = regcache_maple_sync_block(map,\
  \ entry, &mas,\n\t\t\t\t\t\t\tsync_start, r);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto\
  \ out;\n\t\t\tsync_needed = false;\n\t\t}\n\t}\n\nout:\n\trcu_read_unlock();\n\n\
  \tmap->cache_bypass = false;\n\n\treturn ret;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/base/regmap/regcache-maple.c b/drivers/base/regmap/regcache-maple.c\n\
  index c1776127a572..55999a50ccc0 100644\n--- a/drivers/base/regmap/regcache-maple.c\n\
  +++ b/drivers/base/regmap/regcache-maple.c\n@@ -112,7 +112,7 @@ static int regcache_maple_drop(struct\
  \ regmap *map, unsigned int min,\n \tunsigned long *entry, *lower, *upper;\n \t\
  unsigned long lower_index, lower_last;\n \tunsigned long upper_index, upper_last;\n\
  -\tint ret;\n+\tint ret = 0;\n \n \tlower = NULL;\n \tupper = NULL;\n@@ -244,7 +244,7\
  \ @@ static int regcache_maple_sync(struct regmap *map, unsigned int min,\n \tunsigned\
  \ long lmin = min;\n \tunsigned long lmax = max;\n \tunsigned int r, v, sync_start;\n\
  -\tint ret;\n+\tint ret = 0;\n \tbool sync_needed = false;\n \n \tmap->cache_bypass\
  \ = true;\n```\n"
pattern: '## Bug Pattern


  Returning an uninitialized local status variable:

  - A local int (ret) is declared without initialization and only assigned in some
  error branches inside loops/goto paths.

  - If no error occurs or the loop is not entered, control reaches a common return
  path that returns ret, which remains uninitialized.

  - This yields an undefined/garbage return value instead of 0 (success).'
plan: "Plan: Checker for returning an uninitialized local status variable (e.g., \u201C\
  ret\u201D)\n\n1) Program state\n- Keep it minimal and path-sensitive.\n- REGISTER_MAP_WITH_PROGRAMSTATE(StatusVarAssignedMap,\
  \ const MemRegion*, bool)\n  - Key: VarRegion of the local status variable.\n  -\
  \ Value: true if definitely assigned on the current path; false if declared without\
  \ initializer and not yet assigned.\n- Optional (to avoid duplicate reports on the\
  \ same path):\n  - REGISTER_SET_WITH_PROGRAMSTATE(ReportedSet, const MemRegion*)\n\
  \  - Only report once per region per path.\n\n2) Helper predicates/utilities\n-\
  \ isCandidateStatusVar(const VarDecl* VD, const CheckerContext &C):\n  - Return\
  \ true iff all hold:\n    - VD->hasLocalStorage() is true and not VD->isStaticLocal()\n\
  \    - VD->getType()->isIntegerType()\n    - VD->hasInit() is false (declared without\
  \ initializer)\n    - Function being analyzed returns an integer type (getEnclosingFunctionDecl()->getReturnType()->isIntegerType())\n\
  \    - VD->getName() is one of {\"ret\", \"rc\", \"err\"} (include at least \"ret\"\
  ; configurable; keep it strict by default).\n- getVarRegion(const VarDecl *VD, CheckerContext\
  \ &C):\n  - Use C.getState()->getRegionManager().getVarRegion(VD, C.getLocationContext())\
  \ to obtain the VarRegion.\n- isReturnedTrackedVar(const ReturnStmt *RS, CheckerContext\
  \ &C, const MemRegion *&R):\n  - Let E = RS->getRetValue(); if null, return false.\n\
  \  - E = E->IgnoreParenImpCasts().\n  - If E is a DeclRefExpr to a local VarDecl\
  \ (candidate or not), get its MemRegion via the provided utility getMemRegionFromExpr(E,\
  \ C). If R belongs to StatusVarAssignedMap, return true.\n\n3) Callbacks and their\
  \ logic\n\nA) checkPostStmt(const DeclStmt *DS, CheckerContext &C)\n- Goal: Register\
  \ candidate status variables (e.g., \u201Cint ret;\u201D) as uninitialized.\n- For\
  \ each Decl in DS:\n  - If it is a VarDecl* VD and isCandidateStatusVar(VD, C):\n\
  \    - const MemRegion *R = getVarRegion(VD, C).\n    - If R is non-null, add (R\
  \ -> false) into StatusVarAssignedMap.\n- Rationale: Tracks only candidate status\
  \ variables that are declared without initializer.\n\nB) checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C)\n- Goal: Mark the tracked local status\
  \ variable as assigned whenever there is a store to it (direct assignment, compound\
  \ assignment, increments, etc.).\n- Get const MemRegion *R = Loc.getAsRegion();\
  \ if null, return.\n- Use R = R->getBaseRegion() for robustness.\n- If StatusVarAssignedMap\
  \ contains R:\n  - Update (R -> true) in the map.\n- Rationale: Any store to the\
  \ tracked variable makes it initialized on that path.\n\nC) checkPreStmt(const ReturnStmt\
  \ *RS, CheckerContext &C)\n- Goal: Detect returns of a tracked status variable while\
  \ it may be uninitialized on the current path.\n- Early-out if the enclosing function\u2019\
  s return type is not an integer type.\n- If isReturnedTrackedVar(RS, C, R) is true:\n\
  \  - Lookup R in StatusVarAssignedMap.\n  - If found and value is false (uninitialized),\
  \ or not found but the VD meets the candidate criteria:\n    - If using ReportedSet\
  \ and R is already present, skip.\n    - Generate a non-fatal error node.\n    -\
  \ Emit a PathSensitiveBugReport with a short message: \"returning uninitialized\
  \ local 'ret'\".\n    - Optionally add a note range at the DeclStmt where the variable\
  \ was declared (by retrieving its SourceRange from the VarDecl).\n    - Insert R\
  \ into ReportedSet (if used).\n- Rationale: The analyzer will explore both paths;\
  \ it will report precisely where the variable remains uninitialized when returned.\n\
  \n4) Optional refinements (keep simple if unnecessary)\n- Support more status variable\
  \ names: {\"ret\", \"rc\", \"err\"}; you can add others if needed.\n- If you want\
  \ to be more general (but risk more noise), you can remove the name heuristic and\
  \ track any local integer variable that is returned by value. In that case, only\
  \ insert into the map when the VarDecl is uninitialized and either:\n  - The function\
  \ returns an integer type; and\n  - The variable is used as a return value later\
  \ (you can keep the broad registration and rely on path-sensitivity).\n- To reduce\
  \ noise further, only track variables that are used in at least one ReturnStmt (you\
  \ can detect this in checkASTCodeBody by scanning the function body once, but this\
  \ adds complexity; typically unnecessary).\n\n5) Notes on corner cases and why they\
  \ are handled\n- Assignments from multiple places (including inside loops/gotos)\
  \ are covered by checkBind; path-sensitivity ensures that if a path doesn\u2019\
  t perform an assignment, the map still says false, producing a warning on return.\n\
  - \u201CNo loop iterations\u201D case (e.g., assignment inside a loop that may not\
  \ run) is naturally caught: the path skipping the loop body will keep the variable\
  \ uninitialized.\n- Compound assignments (+=, ++, etc.) still bind a value to the\
  \ variable; checkBind will mark the variable as assigned, which is conservative\
  \ and good enough for this bug pattern focusing on the return.\n- Return expressions\
  \ using casts or parentheses are handled via IgnoreParenImpCasts() and the getMemRegionFromExpr\
  \ utility.\n\n6) Bug report\n- Type: BugType(\"Uninitialized return\", \"Logic error\"\
  )\n- Message: \"returning uninitialized local 'ret'\"\n- Emit via generateNonFatalErrorNode\
  \ and PathSensitiveBugReport\n- Keep the message short and clear as required."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(StatusVarAssignedMap,\
  \ const MemRegion*, bool)\nREGISTER_SET_WITH_PROGRAMSTATE(ReportedSet, const MemRegion*)\n\
  \nnamespace {\nclass SAGenTestChecker\n  : public Checker<\n        check::PostStmt<DeclStmt>,\n\
  \        check::Bind,\n        check::PreStmt<ReturnStmt>\n    > {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Uninitialized\
  \ return\", \"Logic error\")) {}\n\n      void checkPostStmt(const DeclStmt *DS,\
  \ CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const Stmt\
  \ *S, CheckerContext &C) const;\n      void checkPreStmt(const ReturnStmt *RS, CheckerContext\
  \ &C) const;\n\n   private:\n      static const FunctionDecl *getEnclosingFunction(const\
  \ CheckerContext &C);\n      static bool functionReturnsInteger(const CheckerContext\
  \ &C);\n      static bool isCandidateStatusVar(const VarDecl *VD, const CheckerContext\
  \ &C);\n      static const MemRegion *getVarRegion(const VarDecl *VD, CheckerContext\
  \ &C);\n      void reportUninitializedReturn(const VarDecl *VD, const MemRegion\
  \ *R,\n                                     const ReturnStmt *RS, CheckerContext\
  \ &C) const;\n};\n\nconst FunctionDecl *SAGenTestChecker::getEnclosingFunction(const\
  \ CheckerContext &C) {\n  const Decl *D = C.getLocationContext() ? C.getLocationContext()->getDecl()\
  \ : nullptr;\n  return dyn_cast_or_null<FunctionDecl>(D);\n}\n\nbool SAGenTestChecker::functionReturnsInteger(const\
  \ CheckerContext &C) {\n  const FunctionDecl *FD = getEnclosingFunction(C);\n  if\
  \ (!FD)\n    return false;\n  return FD->getReturnType()->isIntegerType();\n}\n\n\
  bool SAGenTestChecker::isCandidateStatusVar(const VarDecl *VD, const CheckerContext\
  \ &C) {\n  if (!VD)\n    return false;\n\n  if (!VD->hasLocalStorage())\n    return\
  \ false;\n  if (VD->isStaticLocal())\n    return false;\n  if (!VD->getType()->isIntegerType())\n\
  \    return false;\n  if (VD->hasInit())\n    return false;\n  if (!functionReturnsInteger(C))\n\
  \    return false;\n\n  if (const IdentifierInfo *II = VD->getIdentifier()) {\n\
  \    StringRef Name = II->getName();\n    if (Name == \"ret\" || Name == \"rc\"\
  \ || Name == \"err\")\n      return true;\n  }\n  return false;\n}\n\nconst MemRegion\
  \ *SAGenTestChecker::getVarRegion(const VarDecl *VD, CheckerContext &C) {\n  ProgramStateRef\
  \ State = C.getState();\n  if (!State || !VD)\n    return nullptr;\n  const LocationContext\
  \ *LCtx = C.getLocationContext();\n  if (!LCtx)\n    return nullptr;\n  const MemRegion\
  \ *MR = C.getSValBuilder().getRegionManager().getVarRegion(VD, LCtx);\n  return\
  \ MR;\n}\n\nvoid SAGenTestChecker::checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C) const {\n  if (!DS)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  ProgramStateRef NewState = State;\n\n  for (const Decl *D : DS->decls()) {\n\
  \    const VarDecl *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      continue;\n\n\
  \    if (!isCandidateStatusVar(VD, C))\n      continue;\n\n    const MemRegion *MR\
  \ = getVarRegion(VD, C);\n    if (!MR)\n      continue;\n    MR = MR->getBaseRegion();\n\
  \    if (!MR)\n      continue;\n\n    // Initialize tracking as \"unassigned\"/\"\
  uninitialized\"\n    NewState = NewState->set<StatusVarAssignedMap>(MR, false);\n\
  \  }\n\n  if (NewState != State)\n    C.addTransition(NewState);\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  const MemRegion *R = Loc.getAsRegion();\n  if (!R)\n    return;\n\
  \  R = R->getBaseRegion();\n  if (!R)\n    return;\n\n  const bool *Tracked = State->get<StatusVarAssignedMap>(R);\n\
  \  if (!Tracked)\n    return;\n\n  // Any store to the tracked variable marks it\
  \ as assigned on this path.\n  ProgramStateRef NewState = State->set<StatusVarAssignedMap>(R,\
  \ true);\n  if (NewState != State)\n    C.addTransition(NewState);\n}\n\nvoid SAGenTestChecker::reportUninitializedReturn(const\
  \ VarDecl *VD, const MemRegion *R,\n                                           \
  \      const ReturnStmt *RS, CheckerContext &C) const {\n  if (!BT || !R || !RS)\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n\n  // Avoid duplicate\
  \ reports for the same region on the same path.\n  if (State->contains<ReportedSet>(R))\n\
  \    return;\n\n  ProgramStateRef NewState = State->add<ReportedSet>(R);\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode(NewState);\n  if (!N)\n    return;\n\n  std::string\
  \ VarName = VD ? VD->getName().str() : std::string(\"variable\");\n  std::string\
  \ Msg = \"returning uninitialized local '\" + VarName + \"'\";\n\n  auto Rpt = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  Rpt->addRange(RS->getSourceRange());\n  C.emitReport(std::move(Rpt));\n\
  }\n\nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt *RS, CheckerContext &C)\
  \ const {\n  if (!RS)\n    return;\n  if (!functionReturnsInteger(C))\n    return;\n\
  \n  const Expr *E = RS->getRetValue();\n  if (!E)\n    return;\n\n  const Expr *SimpE\
  \ = E->IgnoreParenImpCasts();\n  const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(SimpE);\n\
  \  if (!DRE)\n    return;\n\n  const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl());\n\
  \  if (!VD)\n    return;\n\n  const MemRegion *MR = getVarRegion(VD, C);\n  if (!MR)\n\
  \    return;\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  const bool *Assigned = State->get<StatusVarAssignedMap>(MR);\n\
  \n  // If we tracked it and it is still unassigned -> bug\n  if (Assigned && !*Assigned)\
  \ {\n    reportUninitializedReturn(VD, MR, RS, C);\n    return;\n  }\n\n  // If\
  \ not tracked (e.g., missed DeclStmt), but it is a candidate, also warn.\n  if (!Assigned\
  \ && isCandidateStatusVar(VD, C)) {\n    reportUninitializedReturn(VD, MR, RS, C);\n\
  \    return;\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects returning an uninitialized local status variable (e.g., 'ret')\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
