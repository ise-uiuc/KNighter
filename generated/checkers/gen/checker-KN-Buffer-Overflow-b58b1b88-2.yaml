_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: b58b1b883b9b702e25204dbe2b221eecc8ecd159
commit_type: Buffer-Overflow
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Track the \"shorten\" variable and which iov_iter variable it is derived from.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(ShortenIterMap, const VarDecl*, const VarDecl*)\n\
  // Track whether a given \"shorten\" variable is guarded (bounded) before use.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(ShortenGuardedMap, const VarDecl*, bool)\n\nnamespace\
  \ {\n\nclass SAGenTestChecker : public Checker<check::PostStmt<DeclStmt>,\n    \
  \                                    check::Bind,\n                            \
  \            check::BranchCondition> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unbounded iov_iter\
  \ count decrement\", \"Arithmetic\")) {}\n\n      void checkPostStmt(const DeclStmt\
  \ *DS, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const Stmt\
  \ *Condition, CheckerContext &C) const;\n\n   private:\n\n      // Helpers\n   \
  \   static bool isUnsignedSizeLike(QualType T);\n      static const VarDecl* getVarDeclFromDeclRefExpr(const\
  \ Expr *E);\n      static const VarDecl* getIterVarFromCountExpr(const Expr *E,\
  \ CheckerContext &C);\n      static const VarDecl* getIterVarFromIterCountCall(const\
  \ CallExpr *CE, CheckerContext &C);\n      static const VarDecl* getIterVarFromMemberCount(const\
  \ Expr *E);\n      static bool isIterCountMemberExprForVar(const Expr *E, const\
  \ VarDecl *IterVD);\n\n      static bool isSubOfIterCount(const Expr *E, const VarDecl*\
  \ &OutIter, CheckerContext &C);\n\n      static const BinaryOperator* getAsBinaryOperator(const\
  \ Stmt *S);\n      static const CompoundAssignOperator* getAsCompoundAssignOperator(const\
  \ Stmt *S);\n\n      void recordShortenVar(const VarDecl *ShortenVD, const VarDecl\
  \ *IterVD, CheckerContext &C) const;\n\n      const VarDecl* findShortenVarInExprForIter(const\
  \ Expr *E, CheckerContext &C, ProgramStateRef State, const VarDecl *IterVD) const;\n\
  \n      void maybeReportOnSubtract(const Stmt *S, const VarDecl *IterVD, const VarDecl\
  \ *ShortenVD, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isUnsignedSizeLike(QualType\
  \ T) {\n  if (T.isNull())\n    return false;\n  return T->isUnsignedIntegerType();\n\
  }\n\nconst VarDecl* SAGenTestChecker::getVarDeclFromDeclRefExpr(const Expr *E) {\n\
  \  if (!E) return nullptr;\n  E = E->IgnoreParenImpCasts();\n  if (const auto *DRE\
  \ = dyn_cast<DeclRefExpr>(E)) {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n\
  \      return VD;\n  }\n  return nullptr;\n}\n\n// Try to get the iov_iter VarDecl\
  \ from an expression which is either:\n// - iov_iter_count(iter)\n// - iter->count\
  \ (or iter.count)\nconst VarDecl* SAGenTestChecker::getIterVarFromCountExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return nullptr;\n  E = E->IgnoreParenImpCasts();\n\
  \n  if (const auto *CE = dyn_cast<CallExpr>(E)) {\n    return getIterVarFromIterCountCall(CE,\
  \ C);\n  }\n\n  if (const VarDecl *VD = getIterVarFromMemberCount(E))\n    return\
  \ VD;\n\n  return nullptr;\n}\n\nconst VarDecl* SAGenTestChecker::getIterVarFromIterCountCall(const\
  \ CallExpr *CE, CheckerContext &C) {\n  if (!CE) return nullptr;\n  // Prefer textual\
  \ name check for robustness (macros/inline).\n  if (!ExprHasName(CE, \"iov_iter_count\"\
  , C))\n    return nullptr;\n  if (CE->getNumArgs() < 1)\n    return nullptr;\n \
  \ const Expr *Arg0 = CE->getArg(0)->IgnoreParenImpCasts();\n  return getVarDeclFromDeclRefExpr(Arg0);\n\
  }\n\nconst VarDecl* SAGenTestChecker::getIterVarFromMemberCount(const Expr *E) {\n\
  \  E = E ? E->IgnoreParenImpCasts() : nullptr;\n  if (!E) return nullptr;\n  if\
  \ (const auto *ME = dyn_cast<MemberExpr>(E)) {\n    // We expect member named \"\
  count\".\n    if (ME->getMemberNameInfo().getAsString() != \"count\")\n      return\
  \ nullptr;\n    const Expr *Base = ME->getBase();\n    if (!Base) return nullptr;\n\
  \    Base = Base->IgnoreParenImpCasts();\n    return getVarDeclFromDeclRefExpr(Base);\n\
  \  }\n  return nullptr;\n}\n\nbool SAGenTestChecker::isIterCountMemberExprForVar(const\
  \ Expr *E, const VarDecl *IterVD) {\n  if (!E || !IterVD) return false;\n  E = E->IgnoreParenImpCasts();\n\
  \  if (const auto *ME = dyn_cast<MemberExpr>(E)) {\n    if (ME->getMemberNameInfo().getAsString()\
  \ != \"count\")\n      return false;\n    const VarDecl *BaseVD = getVarDeclFromDeclRefExpr(ME->getBase());\n\
  \    return BaseVD == IterVD;\n  }\n  return false;\n}\n\n// Check if E is a subtraction\
  \ where LHS is iov_iter_count(iter) or iter->count.\n// If yes, set OutIter to that\
  \ iter VarDecl.\nbool SAGenTestChecker::isSubOfIterCount(const Expr *E, const VarDecl*\
  \ &OutIter, CheckerContext &C) {\n  OutIter = nullptr;\n  if (!E) return false;\n\
  \  E = E->IgnoreParenImpCasts();\n  const auto *BO = dyn_cast<BinaryOperator>(E);\n\
  \  if (!BO || BO->getOpcode() != BO_Sub)\n    return false;\n\n  const Expr *LHS\
  \ = BO->getLHS()->IgnoreParenImpCasts();\n\n  if (const VarDecl *VD = getIterVarFromCountExpr(LHS,\
  \ C)) {\n    OutIter = VD;\n    return true;\n  }\n  return false;\n}\n\nconst BinaryOperator*\
  \ SAGenTestChecker::getAsBinaryOperator(const Stmt *S) {\n  return dyn_cast_or_null<BinaryOperator>(S);\n\
  }\nconst CompoundAssignOperator* SAGenTestChecker::getAsCompoundAssignOperator(const\
  \ Stmt *S) {\n  return dyn_cast_or_null<CompoundAssignOperator>(S);\n}\n\nvoid SAGenTestChecker::recordShortenVar(const\
  \ VarDecl *ShortenVD, const VarDecl *IterVD, CheckerContext &C) const {\n  if (!ShortenVD\
  \ || !IterVD)\n    return;\n\n  ProgramStateRef State = C.getState();\n  State =\
  \ State->set<ShortenIterMap>(ShortenVD, IterVD);\n  State = State->set<ShortenGuardedMap>(ShortenVD,\
  \ false);\n  C.addTransition(State);\n}\n\n// Find a VarDecl (shorten var) referenced\
  \ in E that is already recorded and maps to IterVD.\nconst VarDecl* SAGenTestChecker::findShortenVarInExprForIter(const\
  \ Expr *E, CheckerContext &C, ProgramStateRef State, const VarDecl *IterVD) const\
  \ {\n  if (!E || !IterVD) return nullptr;\n  // Try to find a DeclRefExpr in children\
  \ and check if it is a known shorten var for this iter.\n  if (const auto *DRE =\
  \ findSpecificTypeInChildren<DeclRefExpr>(E)) {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n      if (const VarDecl *MappedIter = State->get<ShortenIterMap>(VD)) {\n \
  \       if (MappedIter == IterVD)\n          return VD;\n      }\n    }\n  }\n \
  \ return nullptr;\n}\n\nvoid SAGenTestChecker::maybeReportOnSubtract(const Stmt\
  \ *S, const VarDecl *IterVD, const VarDecl *ShortenVD, CheckerContext &C) const\
  \ {\n  if (!S || !IterVD || !ShortenVD) return;\n\n  ProgramStateRef State = C.getState();\n\
  \  const bool *Guarded = State->get<ShortenGuardedMap>(ShortenVD);\n  // Only report\
  \ if we know this shorten is tracked and not guarded.\n  if (!Guarded || *Guarded\
  \ == true)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Unbounded iov_iter count decrement may underflow\",\n     \
  \ N);\n  R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n\
  // Record \"shorten\" variables created via declarations with initializers like\n\
  //   size_t shorten = iov_iter_count(iter) - something;\n//   size_t shorten = iter->count\
  \ - something;\nvoid SAGenTestChecker::checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C) const {\n  if (!DS) return;\n\n  for (const auto *DI : DS->decls()) {\n  \
  \  const auto *VD = dyn_cast<VarDecl>(DI);\n    if (!VD) continue;\n\n    if (!VD->hasInit())\n\
  \      continue;\n\n    if (!isUnsignedSizeLike(VD->getType()))\n      continue;\n\
  \n    const Expr *Init = VD->getInit();\n    if (!Init) continue;\n\n    const VarDecl\
  \ *IterVD = nullptr;\n    if (isSubOfIterCount(Init, IterVD, C)) {\n      recordShortenVar(VD,\
  \ IterVD, C);\n      continue;\n    }\n\n    // Also allow \"iter->count - something\"\
  \n    const Expr *InitE = Init->IgnoreParenImpCasts();\n    if (const auto *BO =\
  \ dyn_cast<BinaryOperator>(InitE)) {\n      if (BO->getOpcode() == BO_Sub) {\n \
  \       const VarDecl *BaseIter = getIterVarFromMemberCount(BO->getLHS());\n   \
  \     if (BaseIter) {\n          recordShortenVar(VD, BaseIter, C);\n        }\n\
  \      }\n    }\n  }\n}\n\n// Detect:\n// 1) Recording assignment form: shorten\
  \ = iov_iter_count(iter) - ...;\n// 2) Unsafe decrement:\n//    - iter->count -=\
  \ shorten;\n//    - iter->count = iter->count - shorten;\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  if (!S) return;\n\n\
  \  ProgramStateRef State = C.getState();\n\n  // Part A: Record shorten when assigned\
  \ outside of declaration.\n  if (const auto *BO = getAsBinaryOperator(S)) {\n  \
  \  if (BO->getOpcode() == BO_Assign) {\n      const VarDecl *LHSVD = getVarDeclFromDeclRefExpr(BO->getLHS());\n\
  \      if (LHSVD && isUnsignedSizeLike(LHSVD->getType())) {\n        const VarDecl\
  \ *IterVD = nullptr;\n        if (isSubOfIterCount(BO->getRHS(), IterVD, C)) {\n\
  \          recordShortenVar(LHSVD, IterVD, C);\n        } else {\n          // Also\
  \ allow \"iter->count - something\"\n          const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \          if (const auto *SubBO = dyn_cast<BinaryOperator>(RHS)) {\n          \
  \  if (SubBO->getOpcode() == BO_Sub) {\n              const VarDecl *BaseIter =\
  \ getIterVarFromMemberCount(SubBO->getLHS());\n              if (BaseIter) {\n \
  \               recordShortenVar(LHSVD, BaseIter, C);\n              }\n       \
  \     }\n          }\n        }\n      }\n    }\n  }\n\n  // Part B: Find unsafe\
  \ decrement of iter->count by shorten.\n  // Case 1: iter->count -= shorten;\n \
  \ if (const auto *CAO = getAsCompoundAssignOperator(S)) {\n    if (CAO->getOpcode()\
  \ == BO_SubAssign) {\n      const Expr *LHS = CAO->getLHS()->IgnoreParenImpCasts();\n\
  \      const VarDecl *IterVD = getIterVarFromMemberCount(LHS);\n      if (IterVD)\
  \ {\n        const VarDecl *ShortenVD = findShortenVarInExprForIter(CAO->getRHS(),\
  \ C, State, IterVD);\n        if (ShortenVD) {\n          maybeReportOnSubtract(S,\
  \ IterVD, ShortenVD, C);\n        }\n      }\n    }\n  }\n\n  // Case 2: iter->count\
  \ = iter->count - shorten;\n  if (const auto *BO2 = getAsBinaryOperator(S)) {\n\
  \    if (BO2->getOpcode() == BO_Assign) {\n      const Expr *LHS = BO2->getLHS()->IgnoreParenImpCasts();\n\
  \      const VarDecl *IterVD = getIterVarFromMemberCount(LHS);\n      if (IterVD)\
  \ {\n        const Expr *RHS = BO2->getRHS()->IgnoreParenImpCasts();\n        if\
  \ (const auto *SubBO = dyn_cast<BinaryOperator>(RHS)) {\n          if (SubBO->getOpcode()\
  \ == BO_Sub) {\n            // Ensure RHS LHS is same iter->count\n            if\
  \ (isIterCountMemberExprForVar(SubBO->getLHS(), IterVD)) {\n              const\
  \ VarDecl *ShortenVD = findShortenVarInExprForIter(SubBO->getRHS(), C, State, IterVD);\n\
  \              if (ShortenVD) {\n                maybeReportOnSubtract(S, IterVD,\
  \ ShortenVD, C);\n              }\n            }\n          }\n        }\n     \
  \ }\n    }\n  }\n}\n\n// Mark \"shorten\" as guarded if we see a condition like:\n\
  //   if (shorten >= iter->count) ...    or    if (shorten > iter->count)\n// Symmetric\
  \ forms are also accepted.\nvoid SAGenTestChecker::checkBranchCondition(const Stmt\
  \ *Condition, CheckerContext &C) const {\n  if (!Condition) {\n    C.addTransition(C.getState());\n\
  \    return;\n  }\n\n  const auto *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\
  \ {\n    C.addTransition(C.getState());\n    return;\n  }\n\n  CondE = CondE->IgnoreParenImpCasts();\n\
  \n  const auto *BO = dyn_cast<BinaryOperator>(CondE);\n  if (!BO) {\n    C.addTransition(C.getState());\n\
  \    return;\n  }\n\n  BinaryOperatorKind Op = BO->getOpcode();\n  if (Op != BO_GE\
  \ && Op != BO_GT && Op != BO_LE && Op != BO_LT)\n  {\n    C.addTransition(C.getState());\n\
  \    return;\n  }\n\n  ProgramStateRef State = C.getState();\n  const Expr *LHS\
  \ = BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \n  // Helper lambda to process a pattern: ShortenVD (DeclRefExpr) vs iter->count\
  \ (MemberExpr)\n  auto TryMarkGuarded = [&](const Expr *ShortenExpr, const Expr\
  \ *IterCountExpr) -> bool {\n    const VarDecl *ShortenVD = getVarDeclFromDeclRefExpr(ShortenExpr);\n\
  \    if (!ShortenVD) return false;\n\n    const VarDecl *MappedIter = State->get<ShortenIterMap>(ShortenVD);\n\
  \    if (!MappedIter) return false;\n\n    if (!isIterCountMemberExprForVar(IterCountExpr,\
  \ MappedIter))\n      return false;\n\n    // Mark guarded\n    State = State->set<ShortenGuardedMap>(ShortenVD,\
  \ true);\n    C.addTransition(State);\n    return true;\n  };\n\n  // Accept both\
  \ sides\n  if (TryMarkGuarded(LHS, RHS))\n    return;\n  (void)TryMarkGuarded(RHS,\
  \ LHS);\n\n  // If no match, still transition\n  C.addTransition(State);\n}\n\n\
  } // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect unbounded iov_iter count decrement that may underflow (size_t)\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbcachefs: fix iov_iter count underflow on sub-block\
  \ dio read\n\nbch2_direct_IO_read() checks the request offset and size for sector\n\
  alignment and then falls through to a couple calculations to shrink\nthe size of\
  \ the request based on the inode size. The problem is that\nthese checks round up\
  \ to the fs block size, which runs the risk of\nunderflowing iter->count if the\
  \ block size happens to be large\nenough. This is triggered by fstest generic/361\
  \ with a 4k block\nsize, which subsequently leads to a crash. To avoid this crash,\n\
  check that the shorten length doesn't exceed the overall length of\nthe iter.\n\n\
  Fixes:\nSigned-off-by: Brian Foster <bfoster@redhat.com>\nReviewed-by: Su Yue <glass.su@suse.com>\n\
  Signed-off-by: Kent Overstreet <kent.overstreet@linux.dev>\n\n## Buggy Code\n\n\
  ```c\n// Function: bch2_direct_IO_read in fs/bcachefs/fs-io-direct.c\nstatic int\
  \ bch2_direct_IO_read(struct kiocb *req, struct iov_iter *iter)\n{\n\tstruct file\
  \ *file = req->ki_filp;\n\tstruct bch_inode_info *inode = file_bch_inode(file);\n\
  \tstruct bch_fs *c = inode->v.i_sb->s_fs_info;\n\tstruct bch_io_opts opts;\n\tstruct\
  \ dio_read *dio;\n\tstruct bio *bio;\n\tloff_t offset = req->ki_pos;\n\tbool sync\
  \ = is_sync_kiocb(req);\n\tsize_t shorten;\n\tssize_t ret;\n\n\tbch2_inode_opts_get(&opts,\
  \ c, &inode->ei_inode);\n\n\t/* bios must be 512 byte aligned: */\n\tif ((offset|iter->count)\
  \ & (SECTOR_SIZE - 1))\n\t\treturn -EINVAL;\n\n\tret = min_t(loff_t, iter->count,\n\
  \t\t    max_t(loff_t, 0, i_size_read(&inode->v) - offset));\n\n\tif (!ret)\n\t\t\
  return ret;\n\n\tshorten = iov_iter_count(iter) - round_up(ret, block_bytes(c));\n\
  \titer->count -= shorten;\n\n\tbio = bio_alloc_bioset(NULL,\n\t\t\t       bio_iov_vecs_to_alloc(iter,\
  \ BIO_MAX_VECS),\n\t\t\t       REQ_OP_READ,\n\t\t\t       GFP_KERNEL,\n\t\t\t  \
  \     &c->dio_read_bioset);\n\n\tbio->bi_end_io = bch2_direct_IO_read_endio;\n\n\
  \tdio = container_of(bio, struct dio_read, rbio.bio);\n\tclosure_init(&dio->cl,\
  \ NULL);\n\n\t/*\n\t * this is a _really_ horrible hack just to avoid an atomic\
  \ sub at the\n\t * end:\n\t */\n\tif (!sync) {\n\t\tset_closure_fn(&dio->cl, bch2_dio_read_complete,\
  \ NULL);\n\t\tatomic_set(&dio->cl.remaining,\n\t\t\t   CLOSURE_REMAINING_INITIALIZER\
  \ -\n\t\t\t   CLOSURE_RUNNING +\n\t\t\t   CLOSURE_DESTRUCTOR);\n\t} else {\n\t\t\
  atomic_set(&dio->cl.remaining,\n\t\t\t   CLOSURE_REMAINING_INITIALIZER + 1);\n\t\
  \tdio->cl.closure_get_happened = true;\n\t}\n\n\tdio->req\t= req;\n\tdio->ret\t\
  = ret;\n\t/*\n\t * This is one of the sketchier things I've encountered: we have\
  \ to skip\n\t * the dirtying of requests that are internal from the kernel (i.e.\
  \ from\n\t * loopback), because we'll deadlock on page_lock.\n\t */\n\tdio->should_dirty\
  \ = iter_is_iovec(iter);\n\n\tgoto start;\n\twhile (iter->count) {\n\t\tbio = bio_alloc_bioset(NULL,\n\
  \t\t\t\t       bio_iov_vecs_to_alloc(iter, BIO_MAX_VECS),\n\t\t\t\t       REQ_OP_READ,\n\
  \t\t\t\t       GFP_KERNEL,\n\t\t\t\t       &c->bio_read);\n\t\tbio->bi_end_io\t\t\
  = bch2_direct_IO_read_split_endio;\nstart:\n\t\tbio->bi_opf\t\t= REQ_OP_READ|REQ_SYNC;\n\
  \t\tbio->bi_iter.bi_sector\t= offset >> 9;\n\t\tbio->bi_private\t\t= dio;\n\n\t\t\
  ret = bio_iov_iter_get_pages(bio, iter);\n\t\tif (ret < 0) {\n\t\t\t/* XXX: fault\
  \ inject this path */\n\t\t\tbio->bi_status = BLK_STS_RESOURCE;\n\t\t\tbio_endio(bio);\n\
  \t\t\tbreak;\n\t\t}\n\n\t\toffset += bio->bi_iter.bi_size;\n\n\t\tif (dio->should_dirty)\n\
  \t\t\tbio_set_pages_dirty(bio);\n\n\t\tif (iter->count)\n\t\t\tclosure_get(&dio->cl);\n\
  \n\t\tbch2_read(c, rbio_init(bio, opts), inode_inum(inode));\n\t}\n\n\titer->count\
  \ += shorten;\n\n\tif (sync) {\n\t\tclosure_sync(&dio->cl);\n\t\tclosure_debug_destroy(&dio->cl);\n\
  \t\tret = dio->ret;\n\t\tbio_check_or_release(&dio->rbio.bio, dio->should_dirty);\n\
  \t\treturn ret;\n\t} else {\n\t\treturn -EIOCBQUEUED;\n\t}\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/fs/bcachefs/fs-io-direct.c b/fs/bcachefs/fs-io-direct.c\n\
  index e3b219e19e10..33cb6da3a5ad 100644\n--- a/fs/bcachefs/fs-io-direct.c\n+++ b/fs/bcachefs/fs-io-direct.c\n\
  @@ -88,6 +88,8 @@ static int bch2_direct_IO_read(struct kiocb *req, struct iov_iter\
  \ *iter)\n \t\treturn ret;\n \n \tshorten = iov_iter_count(iter) - round_up(ret,\
  \ block_bytes(c));\n+\tif (shorten >= iter->count)\n+\t\tshorten = 0;\n \titer->count\
  \ -= shorten;\n \n \tbio = bio_alloc_bioset(NULL,\n```\n"
pattern: "## Bug Pattern\n\nAdjusting an iov_iter\u2019s byte count using unsigned\
  \ size arithmetic without bounding the decrement, specifically:\n\n- Compute a \u201C\
  shrink\u201D amount as (available_count - round_up(request_len, block_size)).\n\
  - Store it in a size_t and subtract it from iter->count.\n- If round_up(request_len,\
  \ block_size) > available_count, the subtraction underflows (size_t), and iter->count\
  \ becomes a huge value.\n\nIn code:\nsize_t shorten = iov_iter_count(iter) - round_up(ret,\
  \ block_bytes(c));\niter->count -= shorten;  // underflows if round_up(...) > iov_iter_count(iter)\n\
  \nRoot cause: missing check/cap ensuring the rounded-up length does not exceed the\
  \ iterator\u2019s total length before subtracting, leading to unsigned underflow\
  \ of iter->count."
plan: "Plan\n\n1. Program state customization\n- Define two maps to track the \u201C\
  shorten\u201D variable and whether it has been safely bounded before use:\n  - REGISTER_MAP_WITH_PROGRAMSTATE(ShortenIterMap,\
  \ const VarDecl*, const VarDecl*)\n    - Key: VarDecl* of the \u201Cshorten\u201D\
  \ variable (or any variable assigned the shrink amount).\n    - Value: VarDecl*\
  \ of the iov_iter variable used to derive the shrink amount (the argument to iov_iter_count()\
  \ or the base of iter->count).\n  - REGISTER_MAP_WITH_PROGRAMSTATE(ShortenGuardedMap,\
  \ const VarDecl*, bool)\n    - Key: VarDecl* of the \u201Cshorten\u201D variable.\n\
  \    - Value: true if there is a guard like \u201Cshorten >= iter->count\u201D (or\
  \ strict variants) seen on the current path before subtracting; false otherwise.\n\
  \n2. Helper matching utilities (internal to the checker)\n- getIterVarFromCountExpr(const\
  \ Expr* E) -> const VarDecl*\n  - Return the VarDecl of the iter variable if E is\
  \ either:\n    - CallExpr callee name \u201Ciov_iter_count\u201D with a single DeclRefExpr\
  \ argument; return its VarDecl.\n    - MemberExpr with member name \u201Ccount\u201D\
  \ and base as DeclRefExpr; return base VarDecl.\n  - Otherwise, return nullptr.\n\
  - isSubOfIterCount(const Expr *E, const VarDecl* &OutIter) -> bool\n  - If E is\
  \ a BinaryOperator with opcode BO_Sub:\n    - Try getIterVarFromCountExpr on the\
  \ LHS; if non-null, set OutIter and return true.\n  - Otherwise false.\n- isIterCountMemberExprForVar(const\
  \ Expr *E, const VarDecl *IterVD) -> bool\n  - If E is a MemberExpr with member\
  \ name \u201Ccount\u201D and base is DeclRefExpr referring to IterVD, return true.\n\
  - getShortenVarFromExpr(const Expr *E) -> const VarDecl*\n  - If E contains a DeclRefExpr\
  \ referring to a local VarDecl, return its VarDecl.\n- isUnsignedSizeLike(QualType\
  \ T) -> bool\n  - Return T->isUnsignedIntegerType() to ensure we\u2019re dealing\
  \ with size_t-like unsigned.\n\n3. checkPostStmt(const DeclStmt* DS)\n- Goal: Record\
  \ \u201Cshorten\u201D variables created via declarations with initializers of the\
  \ form iov_iter_count(iter) - something OR iter->count - something.\n- Steps:\n\
  \  - For each VarDecl VD in DS:\n    - If VD->hasInit():\n      - Let Init = VD->getInit()->IgnoreParenImpCasts().\n\
  \      - If isSubOfIterCount(Init, IterVD) is true and VD->getType() is unsigned\
  \ integer (isUnsignedSizeLike), update state:\n        - State = State->set<ShortenIterMap>(VD,\
  \ IterVD)\n        - State = State->set<ShortenGuardedMap>(VD, false)\n        -\
  \ C.addTransition(State)\n\n4. checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C)\n- Part A: Also record \u201Cshorten\u201D when assigned later (not just declared).\n\
  \  - If S is a BinaryOperator with opcode BO_Assign:\n    - LHS: if it\u2019s a\
  \ DeclRefExpr to VarDecl VD, and VD->getType() is unsigned:\n      - RHS = BO->getRHS()->IgnoreParenImpCasts()\n\
  \      - If isSubOfIterCount(RHS, IterVD) is true:\n        - State = State->set<ShortenIterMap>(VD,\
  \ IterVD)\n        - State = State->set<ShortenGuardedMap>(VD, false)\n        -\
  \ C.addTransition(State)\n- Part B: Detect decrement of iter->count by \u201Cshorten\u201D\
  \ without prior bounding.\n  - Handle two shapes:\n    1) CompoundAssignOperator\
  \ (iter->count -= shorten):\n      - If S is CompoundAssignOperator CAO and CAO->getOpcode()\
  \ == BO_SubAssign:\n        - LHS is MemberExpr ME: base should be DeclRefExpr to\
  \ IterVD.\n        - RHS contains a DeclRefExpr to some VarDecl ShortenVD.\n   \
  \     - Check if ShortenVD exists in ShortenIterMap and maps to IterVD.\n      \
  \  - Check ShortenGuardedMap[ShortenVD] == false.\n        - If all true, report\
  \ bug (see step 6).\n    2) BinaryOperator assignment (iter->count = iter->count\
  \ - shorten):\n      - If S is BinaryOperator BO with opcode BO_Assign:\n      \
  \  - LHS must be MemberExpr ME equal to iter->count for some IterVD.\n        -\
  \ RHS is BinaryOperator Sub with LHS equal to the same iter->count MemberExpr and\
  \ RHS DeclRefExpr to ShortenVD.\n        - Check ShortenIterMap[ShortenVD] == IterVD\
  \ and ShortenGuardedMap[ShortenVD] == false.\n        - If all true, report bug.\n\
  \n5. checkBranchCondition(const Stmt *Condition, CheckerContext &C)\n- Goal: Mark\
  \ \u201Cshorten\u201D as guarded if a bounding check is present on the path.\n-\
  \ Recognize common guard patterns:\n  - If Condition is BinaryOperator with op >=\
  \ or > (or their symmetric forms):\n    - Pattern A: shorten >= iter->count (or\
  \ >)\n      - Try to identify ShortenVD on one side:\n        - If side contains\
  \ a DeclRefExpr to a VarDecl ShortenVD that exists in ShortenIterMap:\n        \
  \  - On the other side, check isIterCountMemberExprForVar(side, IterVDMapped) where\
  \ IterVDMapped = ShortenIterMap[ShortenVD].\n          - If yes, mark bounded:\n\
  \            - State = State->set<ShortenGuardedMap>(ShortenVD, true)\n        \
  \    - C.addTransition(State)\n    - Pattern B: round_up(...) > iov_iter_count(iter)\
  \ (optional, broader coverage)\n      - If one side\u2019s expression text contains\
  \ \u201Ciov_iter_count\u201D and resolves to IterVD X via getIterVarFromCountExpr,\
  \ and the other side contains \u201Cround_up\u201D, then for every ShortenVD in\
  \ ShortenIterMap mapping to IterVD X:\n        - State = State->set<ShortenGuardedMap>(ShortenVD,\
  \ true)\n        - C.addTransition(State)\n- Notes:\n  - Use both AST matching (preferred)\
  \ and textual fallback via ExprHasName when encountering macros/inlines. For example,\
  \ if callee cannot be resolved, use ExprHasName(E, \"iov_iter_count\", C).\n\n6.\
  \ Bug reporting\n- When an unsafe decrement is detected in checkBind:\n  - Create\
  \ a non-fatal error node: if (!N) return; to avoid duplicate reports.\n  - Message:\
  \ \u201CPossible underflow: iter->count decreased by unbounded size_t shorten.\u201D\
  \n  - Create a PathSensitiveBugReport with a succinct description:\n    - Title:\
  \ \u201CUnbounded iov_iter count decrement may underflow\u201D\n    - Description:\
  \ \u201Cround_up(...) can exceed available count; subtracting into size_t underflows\
  \ iter->count.\u201D\n  - Attach the statement S as the location.\n  - Optionally,\
  \ add notes pointing to:\n    - The declaration/assignment of ShortenVD (if available)\
  \ and\n    - The missing/absent guard (if ShortenGuardedMap is false on this path).\n\
  \  - Emit the report.\n\n7. Minimizing false positives\n- Only flag when:\n  - The\
  \ LHS being decremented is exactly iter->count for the same IterVD recorded from\
  \ the shorten computation.\n  - The shrink variable is an unsigned integer (size_t-like).\n\
  \  - No guard observed on the current path: ShortenGuardedMap[ShortenVD] is false.\n\
  - Do not emit when a guard is present:\n  - If we saw a guard condition of the recognized\
  \ forms on this path, we set ShortenGuardedMap to true and thus suppress the warning.\n\
  \n8. Callbacks summary and roles\n- checkPostStmt(DeclStmt): Record \u201Cshorten\
  \ = iov_iter_count(iter) - \u2026\u201D or \u201Cshorten = iter->count - \u2026\u201D\
  .\n- checkBind: \n  - Record \u201Cshorten\u201D on assignment form.\n  - Detect\
  \ \u201Citer->count -= shorten;\u201D or \u201Citer->count = iter->count - shorten;\u201D\
  \ and report if unguarded.\n- checkBranchCondition: Mark \u201Cshorten\u201D as\
  \ guarded for conditions like \u201Cshorten >= iter->count\u201D (preferred) or\
  \ \u201Cround_up(...) > iov_iter_count(iter)\u201D.\n- No other callbacks are necessary.\n\
  \nThis plan detects the specific unsafe pattern where a size_t shrink amount derived\
  \ from iov_iter_count/iter->count is subtracted from iter->count without bounding,\
  \ which could underflow when the rounded-up length exceeds the available count."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Track the \"shorten\" variable and which iov_iter variable it is derived from.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(ShortenIterMap, const VarDecl*, const VarDecl*)\n\
  // Track whether a given \"shorten\" variable is guarded (bounded) before use.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(ShortenGuardedMap, const VarDecl*, bool)\n\nnamespace\
  \ {\n\nclass SAGenTestChecker : public Checker<check::PostStmt<DeclStmt>,\n    \
  \                                    check::Bind,\n                            \
  \            check::BranchCondition> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unbounded iov_iter\
  \ count decrement\", \"Arithmetic\")) {}\n\n      void checkPostStmt(const DeclStmt\
  \ *DS, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const Stmt\
  \ *Condition, CheckerContext &C) const;\n\n   private:\n\n      // Helpers\n   \
  \   static bool isUnsignedSizeLike(QualType T);\n      static const VarDecl* getVarDeclFromDeclRefExpr(const\
  \ Expr *E);\n      static const VarDecl* getIterVarFromCountExpr(const Expr *E,\
  \ CheckerContext &C);\n      static const VarDecl* getIterVarFromIterCountCall(const\
  \ CallExpr *CE, CheckerContext &C);\n      static const VarDecl* getIterVarFromMemberCount(const\
  \ Expr *E);\n      static bool isIterCountMemberExprForVar(const Expr *E, const\
  \ VarDecl *IterVD);\n\n      static bool isSubOfIterCount(const Expr *E, const VarDecl*\
  \ &OutIter, CheckerContext &C);\n\n      static const BinaryOperator* getAsBinaryOperator(const\
  \ Stmt *S);\n      static const CompoundAssignOperator* getAsCompoundAssignOperator(const\
  \ Stmt *S);\n\n      void recordShortenVar(const VarDecl *ShortenVD, const VarDecl\
  \ *IterVD, CheckerContext &C) const;\n\n      const VarDecl* findShortenVarInExprForIter(const\
  \ Expr *E, CheckerContext &C, ProgramStateRef State, const VarDecl *IterVD) const;\n\
  \n      void maybeReportOnSubtract(const Stmt *S, const VarDecl *IterVD, const VarDecl\
  \ *ShortenVD, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isUnsignedSizeLike(QualType\
  \ T) {\n  if (T.isNull())\n    return false;\n  return T->isUnsignedIntegerType();\n\
  }\n\nconst VarDecl* SAGenTestChecker::getVarDeclFromDeclRefExpr(const Expr *E) {\n\
  \  if (!E) return nullptr;\n  E = E->IgnoreParenImpCasts();\n  if (const auto *DRE\
  \ = dyn_cast<DeclRefExpr>(E)) {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n\
  \      return VD;\n  }\n  return nullptr;\n}\n\n// Try to get the iov_iter VarDecl\
  \ from an expression which is either:\n// - iov_iter_count(iter)\n// - iter->count\
  \ (or iter.count)\nconst VarDecl* SAGenTestChecker::getIterVarFromCountExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return nullptr;\n  E = E->IgnoreParenImpCasts();\n\
  \n  if (const auto *CE = dyn_cast<CallExpr>(E)) {\n    return getIterVarFromIterCountCall(CE,\
  \ C);\n  }\n\n  if (const VarDecl *VD = getIterVarFromMemberCount(E))\n    return\
  \ VD;\n\n  return nullptr;\n}\n\nconst VarDecl* SAGenTestChecker::getIterVarFromIterCountCall(const\
  \ CallExpr *CE, CheckerContext &C) {\n  if (!CE) return nullptr;\n  // Prefer textual\
  \ name check for robustness (macros/inline).\n  if (!ExprHasName(CE, \"iov_iter_count\"\
  , C))\n    return nullptr;\n  if (CE->getNumArgs() < 1)\n    return nullptr;\n \
  \ const Expr *Arg0 = CE->getArg(0)->IgnoreParenImpCasts();\n  return getVarDeclFromDeclRefExpr(Arg0);\n\
  }\n\nconst VarDecl* SAGenTestChecker::getIterVarFromMemberCount(const Expr *E) {\n\
  \  E = E ? E->IgnoreParenImpCasts() : nullptr;\n  if (!E) return nullptr;\n  if\
  \ (const auto *ME = dyn_cast<MemberExpr>(E)) {\n    // We expect member named \"\
  count\".\n    if (ME->getMemberNameInfo().getAsString() != \"count\")\n      return\
  \ nullptr;\n    const Expr *Base = ME->getBase();\n    if (!Base) return nullptr;\n\
  \    Base = Base->IgnoreParenImpCasts();\n    return getVarDeclFromDeclRefExpr(Base);\n\
  \  }\n  return nullptr;\n}\n\nbool SAGenTestChecker::isIterCountMemberExprForVar(const\
  \ Expr *E, const VarDecl *IterVD) {\n  if (!E || !IterVD) return false;\n  E = E->IgnoreParenImpCasts();\n\
  \  if (const auto *ME = dyn_cast<MemberExpr>(E)) {\n    if (ME->getMemberNameInfo().getAsString()\
  \ != \"count\")\n      return false;\n    const VarDecl *BaseVD = getVarDeclFromDeclRefExpr(ME->getBase());\n\
  \    return BaseVD == IterVD;\n  }\n  return false;\n}\n\n// Check if E is a subtraction\
  \ where LHS is iov_iter_count(iter) or iter->count.\n// If yes, set OutIter to that\
  \ iter VarDecl.\nbool SAGenTestChecker::isSubOfIterCount(const Expr *E, const VarDecl*\
  \ &OutIter, CheckerContext &C) {\n  OutIter = nullptr;\n  if (!E) return false;\n\
  \  E = E->IgnoreParenImpCasts();\n  const auto *BO = dyn_cast<BinaryOperator>(E);\n\
  \  if (!BO || BO->getOpcode() != BO_Sub)\n    return false;\n\n  const Expr *LHS\
  \ = BO->getLHS()->IgnoreParenImpCasts();\n\n  if (const VarDecl *VD = getIterVarFromCountExpr(LHS,\
  \ C)) {\n    OutIter = VD;\n    return true;\n  }\n  return false;\n}\n\nconst BinaryOperator*\
  \ SAGenTestChecker::getAsBinaryOperator(const Stmt *S) {\n  return dyn_cast_or_null<BinaryOperator>(S);\n\
  }\nconst CompoundAssignOperator* SAGenTestChecker::getAsCompoundAssignOperator(const\
  \ Stmt *S) {\n  return dyn_cast_or_null<CompoundAssignOperator>(S);\n}\n\nvoid SAGenTestChecker::recordShortenVar(const\
  \ VarDecl *ShortenVD, const VarDecl *IterVD, CheckerContext &C) const {\n  if (!ShortenVD\
  \ || !IterVD)\n    return;\n\n  ProgramStateRef State = C.getState();\n  State =\
  \ State->set<ShortenIterMap>(ShortenVD, IterVD);\n  State = State->set<ShortenGuardedMap>(ShortenVD,\
  \ false);\n  C.addTransition(State);\n}\n\n// Find a VarDecl (shorten var) referenced\
  \ in E that is already recorded and maps to IterVD.\nconst VarDecl* SAGenTestChecker::findShortenVarInExprForIter(const\
  \ Expr *E, CheckerContext &C, ProgramStateRef State, const VarDecl *IterVD) const\
  \ {\n  if (!E || !IterVD) return nullptr;\n  // Try to find a DeclRefExpr in children\
  \ and check if it is a known shorten var for this iter.\n  if (const auto *DRE =\
  \ findSpecificTypeInChildren<DeclRefExpr>(E)) {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n      if (const VarDecl *const *MappedIter = State->get<ShortenIterMap>(VD))\
  \ {\n        if (*MappedIter == IterVD)\n          return VD;\n      }\n    }\n\
  \  }\n  return nullptr;\n}\n\nvoid SAGenTestChecker::maybeReportOnSubtract(const\
  \ Stmt *S, const VarDecl *IterVD, const VarDecl *ShortenVD, CheckerContext &C) const\
  \ {\n  if (!S || !IterVD || !ShortenVD) return;\n\n  ProgramStateRef State = C.getState();\n\
  \  const bool *Guarded = State->get<ShortenGuardedMap>(ShortenVD);\n  // Only report\
  \ if we know this shorten is tracked and not guarded.\n  if (!Guarded || *Guarded\
  \ == true)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Unbounded iov_iter count decrement may underflow\",\n     \
  \ N);\n  R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n\
  // Record \"shorten\" variables created via declarations with initializers like\n\
  //   size_t shorten = iov_iter_count(iter) - something;\n//   size_t shorten = iter->count\
  \ - something;\nvoid SAGenTestChecker::checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C) const {\n  if (!DS) return;\n\n  for (const auto *DI : DS->decls()) {\n  \
  \  const auto *VD = dyn_cast<VarDecl>(DI);\n    if (!VD) continue;\n\n    if (!VD->hasInit())\n\
  \      continue;\n\n    if (!isUnsignedSizeLike(VD->getType()))\n      continue;\n\
  \n    const Expr *Init = VD->getInit();\n    if (!Init) continue;\n\n    const VarDecl\
  \ *IterVD = nullptr;\n    if (isSubOfIterCount(Init, IterVD, C)) {\n      recordShortenVar(VD,\
  \ IterVD, C);\n      continue;\n    }\n\n    // Also allow \"iter->count - something\"\
  \n    const Expr *InitE = Init->IgnoreParenImpCasts();\n    if (const auto *BO =\
  \ dyn_cast<BinaryOperator>(InitE)) {\n      if (BO->getOpcode() == BO_Sub) {\n \
  \       const VarDecl *BaseIter = getIterVarFromMemberCount(BO->getLHS());\n   \
  \     if (BaseIter) {\n          recordShortenVar(VD, BaseIter, C);\n        }\n\
  \      }\n    }\n  }\n}\n\n// Detect:\n// 1) Recording assignment form: shorten\
  \ = iov_iter_count(iter) - ...;\n// 2) Unsafe decrement:\n//    - iter->count -=\
  \ shorten;\n//    - iter->count = iter->count - shorten;\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  if (!S) return;\n\n\
  \  ProgramStateRef State = C.getState();\n\n  // Part A: Record shorten when assigned\
  \ outside of declaration.\n  if (const auto *BO = getAsBinaryOperator(S)) {\n  \
  \  if (BO->getOpcode() == BO_Assign) {\n      const VarDecl *LHSVD = getVarDeclFromDeclRefExpr(BO->getLHS());\n\
  \      if (LHSVD && isUnsignedSizeLike(LHSVD->getType())) {\n        const VarDecl\
  \ *IterVD = nullptr;\n        if (isSubOfIterCount(BO->getRHS(), IterVD, C)) {\n\
  \          recordShortenVar(LHSVD, IterVD, C);\n        } else {\n          // Also\
  \ allow \"iter->count - something\"\n          const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \          if (const auto *SubBO = dyn_cast<BinaryOperator>(RHS)) {\n          \
  \  if (SubBO->getOpcode() == BO_Sub) {\n              const VarDecl *BaseIter =\
  \ getIterVarFromMemberCount(SubBO->getLHS());\n              if (BaseIter) {\n \
  \               recordShortenVar(LHSVD, BaseIter, C);\n              }\n       \
  \     }\n          }\n        }\n      }\n    }\n  }\n\n  // Part B: Find unsafe\
  \ decrement of iter->count by shorten.\n  // Case 1: iter->count -= shorten;\n \
  \ if (const auto *CAO = getAsCompoundAssignOperator(S)) {\n    if (CAO->getOpcode()\
  \ == BO_SubAssign) {\n      const Expr *LHS = CAO->getLHS()->IgnoreParenImpCasts();\n\
  \      const VarDecl *IterVD = getIterVarFromMemberCount(LHS);\n      if (IterVD)\
  \ {\n        const VarDecl *ShortenVD = findShortenVarInExprForIter(CAO->getRHS(),\
  \ C, State, IterVD);\n        if (ShortenVD) {\n          maybeReportOnSubtract(S,\
  \ IterVD, ShortenVD, C);\n        }\n      }\n    }\n  }\n\n  // Case 2: iter->count\
  \ = iter->count - shorten;\n  if (const auto *BO2 = getAsBinaryOperator(S)) {\n\
  \    if (BO2->getOpcode() == BO_Assign) {\n      const Expr *LHS = BO2->getLHS()->IgnoreParenImpCasts();\n\
  \      const VarDecl *IterVD = getIterVarFromMemberCount(LHS);\n      if (IterVD)\
  \ {\n        const Expr *RHS = BO2->getRHS()->IgnoreParenImpCasts();\n        if\
  \ (const auto *SubBO = dyn_cast<BinaryOperator>(RHS)) {\n          if (SubBO->getOpcode()\
  \ == BO_Sub) {\n            // Ensure RHS LHS is same iter->count\n            if\
  \ (isIterCountMemberExprForVar(SubBO->getLHS(), IterVD)) {\n              const\
  \ VarDecl *ShortenVD = findShortenVarInExprForIter(SubBO->getRHS(), C, State, IterVD);\n\
  \              if (ShortenVD) {\n                maybeReportOnSubtract(S, IterVD,\
  \ ShortenVD, C);\n              }\n            }\n          }\n        }\n     \
  \ }\n    }\n  }\n}\n\n// Mark \"shorten\" as guarded if we see a condition like:\n\
  //   if (shorten >= iter->count) ...    or    if (shorten > iter->count)\n// Symmetric\
  \ forms are also accepted.\nvoid SAGenTestChecker::checkBranchCondition(const Stmt\
  \ *Condition, CheckerContext &C) const {\n  if (!Condition) {\n    C.addTransition(C.getState());\n\
  \    return;\n  }\n\n  const auto *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\
  \ {\n    C.addTransition(C.getState());\n    return;\n  }\n\n  CondE = CondE->IgnoreParenImpCasts();\n\
  \n  const auto *BO = dyn_cast<BinaryOperator>(CondE);\n  if (!BO) {\n    C.addTransition(C.getState());\n\
  \    return;\n  }\n\n  BinaryOperatorKind Op = BO->getOpcode();\n  if (Op != BO_GE\
  \ && Op != BO_GT && Op != BO_LE && Op != BO_LT)\n  {\n    C.addTransition(C.getState());\n\
  \    return;\n  }\n\n  ProgramStateRef State = C.getState();\n  const Expr *LHS\
  \ = BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \n  // Helper lambda to process a pattern: ShortenVD (DeclRefExpr) vs iter->count\
  \ (MemberExpr)\n  auto TryMarkGuarded = [&](const Expr *ShortenExpr, const Expr\
  \ *IterCountExpr) -> bool {\n    const VarDecl *ShortenVD = getVarDeclFromDeclRefExpr(ShortenExpr);\n\
  \    if (!ShortenVD) return false;\n\n    const VarDecl *const *MappedIterPtr =\
  \ State->get<ShortenIterMap>(ShortenVD);\n    if (!MappedIterPtr) return false;\n\
  \    const VarDecl *MappedIter = *MappedIterPtr;\n\n    if (!isIterCountMemberExprForVar(IterCountExpr,\
  \ MappedIter))\n      return false;\n\n    // Mark guarded\n    State = State->set<ShortenGuardedMap>(ShortenVD,\
  \ true);\n    C.addTransition(State);\n    return true;\n  };\n\n  // Accept both\
  \ sides\n  if (TryMarkGuarded(LHS, RHS))\n    return;\n  (void)TryMarkGuarded(RHS,\
  \ LHS);\n\n  // If no match, still transition\n  C.addTransition(State);\n}\n\n\
  } // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect unbounded iov_iter count decrement that may underflow (size_t)\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
