_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: d313eb8b77557a6d5855f42d2234bd592c7b50dd
commit_type: Uninit-Data
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Decl.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/AST/Type.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Tracks local struct variables that have been fully zeroed by memset/bzero.\nREGISTER_MAP_WITH_PROGRAMSTATE(ZeroedStructMap,\
  \ const MemRegion*, bool)\n\nnamespace {\nclass SAGenTestChecker : public Checker<check::PostCall,\
  \ check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n   SAGenTestChecker()\n\
  \     : BT(new BugType(this,\n                      \"Kernel infoleak: copying stack\
  \ struct with uninitialized padding\",\n                      \"Security\")) {}\n\
  \n   void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n   void\
  \ checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\nprivate:\n  \
  \ // Helpers\n   static bool isZeroingFunc(const CallEvent &Call, CheckerContext\
  \ &C);\n   static bool isNLAPutLike(const CallEvent &Call, CheckerContext &C);\n\
  \   static bool pickNlaArgsIndices(const CallEvent &Call, CheckerContext &C,\n \
  \                                 unsigned &LenIdx, unsigned &DataIdx);\n\n   static\
  \ const VarDecl* getAddrOfLocalVar(const Expr *E, CheckerContext &C,\n         \
  \                                  const MemRegion* &OutRegion);\n\n   static bool\
  \ tryEvalToUnsigned(const Expr *E, CheckerContext &C, uint64_t &Out);\n   static\
  \ uint64_t getTypeSizeInBytes(QualType QT, CheckerContext &C);\n   static bool recordHasPadding(QualType\
  \ QT, CheckerContext &C);\n};\n\n// Return true if the call is memset/__builtin_memset/bzero\n\
  bool SAGenTestChecker::isZeroingFunc(const CallEvent &Call, CheckerContext &C) {\n\
  \  const Expr *OE = Call.getOriginExpr();\n  if (!OE)\n    return false;\n  if (ExprHasName(OE,\
  \ \"memset\", C))\n    return true;\n  if (ExprHasName(OE, \"__builtin_memset\"\
  , C))\n    return true;\n  if (ExprHasName(OE, \"bzero\", C))\n    return true;\n\
  \  return false;\n}\n\n// Return true if the call is one of nla_put-like functions\
  \ we care about.\nbool SAGenTestChecker::isNLAPutLike(const CallEvent &Call, CheckerContext\
  \ &C) {\n  const Expr *OE = Call.getOriginExpr();\n  if (!OE)\n    return false;\n\
  \  return ExprHasName(OE, \"nla_put\", C) ||\n         ExprHasName(OE, \"nla_put_64bit\"\
  , C) ||\n         ExprHasName(OE, \"nla_put_nohdr\", C) ||\n         ExprHasName(OE,\
  \ \"nla_put_with_pad\", C);\n}\n\n// Determine argument indices for len and data\
  \ for nla_put-like calls.\nbool SAGenTestChecker::pickNlaArgsIndices(const CallEvent\
  \ &Call, CheckerContext &C,\n                                          unsigned\
  \ &LenIdx, unsigned &DataIdx) {\n  const Expr *OE = Call.getOriginExpr();\n  if\
  \ (!OE)\n    return false;\n\n  if (ExprHasName(OE, \"nla_put_nohdr\", C)) {\n \
  \   // nla_put_nohdr(skb, len, data)\n    if (Call.getNumArgs() < 3)\n      return\
  \ false;\n    LenIdx = 1;\n    DataIdx = 2;\n    return true;\n  }\n\n  if (ExprHasName(OE,\
  \ \"nla_put\", C) ||\n      ExprHasName(OE, \"nla_put_64bit\", C) ||\n      ExprHasName(OE,\
  \ \"nla_put_with_pad\", C)) {\n    // nla_put*(skb, type, len, data, ...)\n    if\
  \ (Call.getNumArgs() < 4)\n      return false;\n    LenIdx = 2;\n    DataIdx = 3;\n\
  \    return true;\n  }\n\n  return false;\n}\n\n// If E is &localVar, return the\
  \ VarDecl and its MemRegion (base region).\nconst VarDecl* SAGenTestChecker::getAddrOfLocalVar(const\
  \ Expr *E, CheckerContext &C,\n                                                \
  \   const MemRegion* &OutRegion) {\n  OutRegion = nullptr;\n  if (!E)\n    return\
  \ nullptr;\n\n  E = E->IgnoreParenImpCasts();\n  const auto *UO = dyn_cast<UnaryOperator>(E);\n\
  \  if (!UO || UO->getOpcode() != UO_AddrOf)\n    return nullptr;\n\n  const Expr\
  \ *Sub = UO->getSubExpr();\n  if (!Sub)\n    return nullptr;\n\n  Sub = Sub->IgnoreParenImpCasts();\n\
  \  const auto *DRE = dyn_cast<DeclRefExpr>(Sub);\n  if (!DRE)\n    return nullptr;\n\
  \n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n    return\
  \ nullptr;\n\n  // Only consider local variables (stack-allocated in function scope).\n\
  \  if (!VD->hasLocalStorage())\n    return nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(DRE,\
  \ C);\n  if (!MR)\n    return nullptr;\n  MR = MR->getBaseRegion();\n  if (!MR)\n\
  \    return nullptr;\n\n  OutRegion = MR;\n  return VD;\n}\n\nbool SAGenTestChecker::tryEvalToUnsigned(const\
  \ Expr *E, CheckerContext &C, uint64_t &Out) {\n  if (!E)\n    return false;\n \
  \ llvm::APSInt V;\n  if (!EvaluateExprToInt(V, E, C))\n    return false;\n  Out\
  \ = V.getZExtValue();\n  return true;\n}\n\nuint64_t SAGenTestChecker::getTypeSizeInBytes(QualType\
  \ QT, CheckerContext &C) {\n  return C.getASTContext().getTypeSizeInChars(QT).getQuantity();\n\
  }\n\n// Determine if a struct type has internal padding or tail padding.\nbool SAGenTestChecker::recordHasPadding(QualType\
  \ QT, CheckerContext &C) {\n  QT = QT.getCanonicalType();\n  if (!QT->isStructureType())\n\
  \    return false;\n\n  const auto *RT = QT->getAs<RecordType>();\n  if (!RT)\n\
  \    return false;\n\n  const RecordDecl *RD = RT->getDecl();\n  if (!RD)\n    return\
  \ false;\n  if (RD->isUnion())\n    return false;\n  if (!RD->isCompleteDefinition())\n\
  \    return false;\n\n  ASTContext &Ctx = C.getASTContext();\n  const ASTRecordLayout\
  \ &Layout = Ctx.getASTRecordLayout(RD);\n\n  uint64_t PrevEndBits = 0;\n  unsigned\
  \ Index = 0;\n  for (const FieldDecl *FD : RD->fields()) {\n    if (!FD)\n     \
  \ continue;\n\n    // If this is a flexible array member at end, stop checking here.\n\
  \    // We conservatively ignore it for padding calculation.\n    if (FD->getType()->isIncompleteArrayType())\n\
  \      break;\n\n    uint64_t FieldOffsetBits = Layout.getFieldOffset(Index);\n\
  \    uint64_t FieldSizeBits = 0;\n\n    if (FD->isBitField()) {\n      // Bit-field\
  \ width in bits\n      FieldSizeBits = FD->getBitWidthValue(Ctx);\n    } else {\n\
  \      FieldSizeBits = Ctx.getTypeSize(FD->getType()); // in bits\n    }\n\n   \
  \ if (FieldOffsetBits > PrevEndBits) {\n      // Gap detected -> internal padding\n\
  \      return true;\n    }\n\n    uint64_t EndBits = FieldOffsetBits + FieldSizeBits;\n\
  \    if (EndBits > PrevEndBits)\n      PrevEndBits = EndBits;\n\n    ++Index;\n\
  \  }\n\n  // Tail padding: struct size (including alignment) > end of last field.\n\
  \  uint64_t RecordSizeBits = Ctx.getTypeSize(QT); // in bits\n  if (RecordSizeBits\
  \ > PrevEndBits)\n    return true;\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isZeroingFunc(Call, C))\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE)\n    return;\n\n  // memset(dst, value, size)\n  if (ExprHasName(OE,\
  \ \"memset\", C) || ExprHasName(OE, \"__builtin_memset\", C)) {\n    if (Call.getNumArgs()\
  \ < 3)\n      return;\n\n    const MemRegion *MR = nullptr;\n    const VarDecl *VD\
  \ = getAddrOfLocalVar(Call.getArgExpr(0), C, MR);\n    if (!VD || !MR)\n      return;\n\
  \n    // value must be 0\n    uint64_t ValU = 0;\n    if (!tryEvalToUnsigned(Call.getArgExpr(1),\
  \ C, ValU))\n      return;\n    if (ValU != 0)\n      return;\n\n    // size must\
  \ cover the whole struct\n    uint64_t SizeU = 0;\n    if (!tryEvalToUnsigned(Call.getArgExpr(2),\
  \ C, SizeU))\n      return;\n\n    uint64_t TypeSize = getTypeSizeInBytes(VD->getType(),\
  \ C);\n    if (SizeU >= TypeSize) {\n      State = State->set<ZeroedStructMap>(MR,\
  \ true);\n      C.addTransition(State);\n    }\n    return;\n  }\n\n  // bzero(dst,\
  \ size)\n  if (ExprHasName(OE, \"bzero\", C)) {\n    if (Call.getNumArgs() < 2)\n\
  \      return;\n\n    const MemRegion *MR = nullptr;\n    const VarDecl *VD = getAddrOfLocalVar(Call.getArgExpr(0),\
  \ C, MR);\n    if (!VD || !MR)\n      return;\n\n    uint64_t SizeU = 0;\n    if\
  \ (!tryEvalToUnsigned(Call.getArgExpr(1), C, SizeU))\n      return;\n\n    uint64_t\
  \ TypeSize = getTypeSizeInBytes(VD->getType(), C);\n    if (SizeU >= TypeSize) {\n\
  \      State = State->set<ZeroedStructMap>(MR, true);\n      C.addTransition(State);\n\
  \    }\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  if (!isNLAPutLike(Call, C))\n    return;\n\
  \n  unsigned LenIdx = 0, DataIdx = 0;\n  if (!pickNlaArgsIndices(Call, C, LenIdx,\
  \ DataIdx))\n    return;\n\n  if (Call.getNumArgs() <= std::max(LenIdx, DataIdx))\n\
  \    return;\n\n  // Data argument must be &localStructVar\n  const MemRegion *MR\
  \ = nullptr;\n  const VarDecl *VD = getAddrOfLocalVar(Call.getArgExpr(DataIdx),\
  \ C, MR);\n  if (!VD || !MR)\n    return;\n\n  QualType VarQT = VD->getType();\n\
  \  if (!VarQT->isStructureType())\n    return;\n\n  if (!recordHasPadding(VarQT,\
  \ C))\n    return;\n\n  // len must be exactly sizeof(var)\n  uint64_t LenU = 0;\n\
  \  if (!tryEvalToUnsigned(Call.getArgExpr(LenIdx), C, LenU))\n    return;\n\n  uint64_t\
  \ TypeSize = getTypeSizeInBytes(VarQT, C);\n  if (LenU != TypeSize)\n    return;\n\
  \n  // If explicitly zeroed before, consider safe.\n  ProgramStateRef State = C.getState();\n\
  \  const bool *Zeroed = State->get<ZeroedStructMap>(MR);\n  if (Zeroed && *Zeroed)\n\
  \    return;\n\n  // Report: copying stack struct with padding directly to user\
  \ space\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n      \"Copying\
  \ stack struct with uninitialized padding; zero it before nla_put\",\n      N);\n\
  \  const Expr *DataE = Call.getArgExpr(DataIdx);\n  if (DataE)\n    R->addRange(DataE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect copying stack struct with padding\
  \ to user via nla_put without zeroing\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/sched: act_skbmod: prevent kernel-infoleak\n\n\
  syzbot found that tcf_skbmod_dump() was copying four bytes\nfrom kernel stack to\
  \ user space [1].\n\nThe issue here is that 'struct tc_skbmod' has a four bytes\
  \ hole.\n\nWe need to clear the structure before filling fields.\n\n[1]\nBUG: KMSAN:\
  \ kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in copy_to_user_iter lib/iov_iter.c:24 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_and_advance2 include/linux/iov_iter.h:245\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in iterate_and_advance include/linux/iov_iter.h:271\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n  copy_to_user_iter\
  \ lib/iov_iter.c:24 [inline]\n  iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \  iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\n  iterate_and_advance\
  \ include/linux/iov_iter.h:271 [inline]\n  _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  copy_to_iter include/linux/uio.h:196 [inline]\n  simple_copy_to_iter net/core/datagram.c:532\
  \ [inline]\n  __skb_datagram_iter+0x185/0x1000 net/core/datagram.c:420\n  skb_copy_datagram_iter+0x5c/0x200\
  \ net/core/datagram.c:546\n  skb_copy_datagram_msg include/linux/skbuff.h:4050 [inline]\n\
  \  netlink_recvmsg+0x432/0x1610 net/netlink/af_netlink.c:1962\n  sock_recvmsg_nosec\
  \ net/socket.c:1046 [inline]\n  sock_recvmsg+0x2c4/0x340 net/socket.c:1068\n  __sys_recvfrom+0x35a/0x5f0\
  \ net/socket.c:2242\n  __do_sys_recvfrom net/socket.c:2260 [inline]\n  __se_sys_recvfrom\
  \ net/socket.c:2256 [inline]\n  __x64_sys_recvfrom+0x126/0x1d0 net/socket.c:2256\n\
  \ do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nUninit\
  \ was stored to memory at:\n  pskb_expand_head+0x30f/0x19d0 net/core/skbuff.c:2253\n\
  \  netlink_trim+0x2c2/0x330 net/netlink/af_netlink.c:1317\n  netlink_unicast+0x9f/0x1260\
  \ net/netlink/af_netlink.c:1351\n  nlmsg_unicast include/net/netlink.h:1144 [inline]\n\
  \  nlmsg_notify+0x21d/0x2f0 net/netlink/af_netlink.c:2610\n  rtnetlink_send+0x73/0x90\
  \ net/core/rtnetlink.c:741\n  rtnetlink_maybe_send include/linux/rtnetlink.h:17\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2048 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x146e/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nUninit was stored to memory at:\n  __nla_put lib/nlattr.c:1041 [inline]\n  nla_put+0x1c6/0x230\
  \ lib/nlattr.c:1099\n  tcf_skbmod_dump+0x23f/0xc20 net/sched/act_skbmod.c:256\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n  tcf_action_dump+0x1fd/0x460 net/sched/act_api.c:1251\n\
  \  tca_get_fill+0x519/0x7a0 net/sched/act_api.c:1628\n  tcf_add_notify_msg net/sched/act_api.c:2023\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2042 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x1365/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nLocal variable opt created at:\n  tcf_skbmod_dump+0x9d/0xc20 net/sched/act_skbmod.c:244\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n\nBytes 188-191 of 248 are uninitialized\nMemory access\
  \ of size 248 starts at ffff888117697680\nData copied to user address 00007ffe56d855f0\n\
  \nFixes: 86da71b57383 (\"net_sched: Introduce skbmod action\")\nSigned-off-by: Eric\
  \ Dumazet <edumazet@google.com>\nAcked-by: Jamal Hadi Salim <jhs@mojatatu.com>\n\
  Link: https://lore.kernel.org/r/20240403130908.93421-1-edumazet@google.com\nSigned-off-by:\
  \ Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: tcf_skbmod_dump\
  \ in net/sched/act_skbmod.c\nstatic int tcf_skbmod_dump(struct sk_buff *skb, struct\
  \ tc_action *a,\n\t\t\t   int bind, int ref)\n{\n\tstruct tcf_skbmod *d = to_skbmod(a);\n\
  \tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_skbmod_params  *p;\n\t\
  struct tc_skbmod opt = {\n\t\t.index   = d->tcf_index,\n\t\t.refcnt  = refcount_read(&d->tcf_refcnt)\
  \ - ref,\n\t\t.bindcnt = atomic_read(&d->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t\
  \ t;\n\n\tspin_lock_bh(&d->tcf_lock);\n\topt.action = d->tcf_action;\n\tp = rcu_dereference_protected(d->skbmod_p,\n\
  \t\t\t\t      lockdep_is_held(&d->tcf_lock));\n\topt.flags  = p->flags;\n\tif (nla_put(skb,\
  \ TCA_SKBMOD_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_DMAC) &&\n\t    nla_put(skb, TCA_SKBMOD_DMAC, ETH_ALEN, p->eth_dst))\n\
  \t\tgoto nla_put_failure;\n\tif ((p->flags & SKBMOD_F_SMAC) &&\n\t    nla_put(skb,\
  \ TCA_SKBMOD_SMAC, ETH_ALEN, p->eth_src))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_ETYPE) &&\n\t    nla_put_u16(skb, TCA_SKBMOD_ETYPE, ntohs(p->eth_type)))\n\
  \t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &d->tcf_tm);\n\tif (nla_put_64bit(skb,\
  \ TCA_SKBMOD_TM, sizeof(t), &t, TCA_SKBMOD_PAD))\n\t\tgoto nla_put_failure;\n\n\t\
  spin_unlock_bh(&d->tcf_lock);\n\treturn skb->len;\nnla_put_failure:\n\tspin_unlock_bh(&d->tcf_lock);\n\
  \tnlmsg_trim(skb, b);\n\treturn -1;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff\
  \ --git a/net/sched/act_skbmod.c b/net/sched/act_skbmod.c\nindex 39945b139c48..cd0accaf844a\
  \ 100644\n--- a/net/sched/act_skbmod.c\n+++ b/net/sched/act_skbmod.c\n@@ -241,13\
  \ +241,13 @@ static int tcf_skbmod_dump(struct sk_buff *skb, struct tc_action *a,\n\
  \ \tstruct tcf_skbmod *d = to_skbmod(a);\n \tunsigned char *b = skb_tail_pointer(skb);\n\
  \ \tstruct tcf_skbmod_params  *p;\n-\tstruct tc_skbmod opt = {\n-\t\t.index   =\
  \ d->tcf_index,\n-\t\t.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n-\t\t.bindcnt\
  \ = atomic_read(&d->tcf_bindcnt) - bind,\n-\t};\n+\tstruct tc_skbmod opt;\n \tstruct\
  \ tcf_t t;\n \n+\tmemset(&opt, 0, sizeof(opt));\n+\topt.index   = d->tcf_index;\n\
  +\topt.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n+\topt.bindcnt = atomic_read(&d->tcf_bindcnt)\
  \ - bind;\n \tspin_lock_bh(&d->tcf_lock);\n \topt.action = d->tcf_action;\n \tp\
  \ = rcu_dereference_protected(d->skbmod_p,\n```\n"
pattern: '## Bug Pattern


  Copying a stack-allocated struct to user space (e.g., via nla_put(..., sizeof(struct),
  &obj)) after only partially initializing its fields, leaving structure padding/holes
  uninitialized. Because designated/field-by-field initialization does not zero padding,
  sizeof(struct) copies include uninitialized bytes, causing a kernel info leak.


  Example:

  struct S { u32 a; u8 b; /* padding */ u32 c; };

  struct S s = { .a = x, .c = y };  // padding remains uninitialized

  nla_put(skb, ATTR, sizeof(s), &s);  // leaks padding


  Fix: zero the struct first (memset(&s, 0, sizeof(s)) or use kzalloc for heap objects)
  before filling fields.'
plan: "1) Program state\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(ZeroedStructMap, const\
  \ MemRegion*, bool)\n  - Tracks stack-allocated struct variables that have been\
  \ explicitly zeroed. Key is the MemRegion of the variable; value = true means \u201C\
  fully zeroed by memset/bzero\u201D. Absence or false means \u201Cnot known to be\
  \ zeroed\u201D.\n\nNo other custom state or tainting is needed.\n\n\n2) Helper utilities\
  \ and predicates\n\nAdd small internal helpers (use the provided utility functions\
  \ where suitable):\n\n- bool isZeroingFunc(const CallEvent &Call)\n  - Return true\
  \ if callee name is one of: \"memset\", \"__builtin_memset\", \"bzero\".\n\n- bool\
  \ isNLAPutLike(const CallEvent &Call)\n  - Return true if callee name is one of:\
  \ \"nla_put\", \"nla_put_64bit\", \"nla_put_nohdr\", \"nla_put_with_pad\".\n\n-\
  \ const VarDecl* getAddrOfLocalVar(const Expr *E, CheckerContext &C, const MemRegion*\
  \ &OutRegion)\n  - If E (after IgnoreParenImpCasts) is a UnaryOperator (UO_AddrOf)\
  \ of a DeclRefExpr to a VarDecl with local storage, return the VarDecl. Also set\
  \ OutRegion = getMemRegionFromExpr(InnerDRE, C). Return nullptr otherwise.\n\n-\
  \ bool tryEvalToUnsigned(const Expr *E, CheckerContext &C, uint64_t &Out)\n  - Use\
  \ EvaluateExprToInt. If success, set Out to unsigned value and return true.\n\n\
  - uint64_t getTypeSizeInBytes(QualType QT, CheckerContext &C)\n  - Use C.getASTContext().getTypeSizeInChars(QT).getQuantity().\n\
  \n- bool recordHasPadding(QualType QT, CheckerContext &C)\n  - If QT is not a structure\
  \ (record) or is a union, return false early.\n  - Use ASTContext.getASTRecordLayout(RecordDecl)\
  \ to:\n    - Iterate over non-bitfield fields; compute gap between each field\u2019\
  s offset+size and next field\u2019s offset; if any gap > 0, return true.\n    -\
  \ Also check tail padding: if record size in bytes > last field end offset in bytes,\
  \ return true.\n  - Return true if any padding present; else false.\n\nNotes:\n\
  - Only treat structure types (not unions) as candidates for padding checks.\n- For\
  \ memset: confirm zero value argument == 0.\n- For both memset/bzero: confirm size\
  \ argument is >= sizeof(struct) to consider \u201Cfully zeroed\u201D.\n\n\n3) Callback:\
  \ checkPostCall\n\nPurpose: recognize and record when a local struct variable is\
  \ fully zeroed.\n\n- If !isZeroingFunc(Call), return.\n- For \"memset\":\n  - Expect\
  \ 3 args: ptr, value, size.\n  - Extract arg0 and find local VarDecl and its region\
  \ via getAddrOfLocalVar. If not found, return.\n  - Verify value (arg1) evaluates\
  \ to 0 (tryEvalToUnsigned).\n  - Evaluate size (arg2). If cannot evaluate, do not\
  \ assume zeroed; return.\n  - Compute sizeof(varType). If size >= sizeof, set ZeroedStructMap[region]\
  \ = true.\n- For \"bzero\":\n  - Expect 2 args: ptr, size. Same extraction of local\
  \ VarDecl.\n  - Evaluate size and compare size >= sizeof(varType). If yes, set ZeroedStructMap[region]\
  \ = true.\n\nDo not clear the map on further writes; once zeroed, it remains safe\
  \ for our purpose.\n\n\n4) Callback: checkPreCall\n\nPurpose: detect copying a stack\
  \ struct with potential uninitialized padding to user space via nla_put-like functions.\n\
  \n- If !isNLAPutLike(Call), return.\n- Identify the data argument (index 3) and\
  \ the length argument (index 2).\n  - Extract arg3 and obtain the local VarDecl\
  \ and region via getAddrOfLocalVar. If not a direct &localVar, return (we keep checker\
  \ simple and avoid aliasing).\n  - Get the variable QualType; require it is a record\
  \ (struct) and not a union.\n  - If !recordHasPadding(varType, C), return (no padding,\
  \ no infoleak).\n  - Evaluate arg2 (length) using tryEvalToUnsigned. If not evaluatable,\
  \ return (to avoid false positives).\n  - Compute sizeof(varType). If length !=\
  \ sizeof(varType), return (we only warn when the whole struct object is copied).\n\
  \  - Query ZeroedStructMap for this region. If map contains region with true, return\
  \ (safe).\n  - Otherwise, report a bug:\n    - Generate a non-fatal error node.\n\
  \    - Create a PathSensitiveBugReport with a short message like:\n      \"Copying\
  \ stack struct with uninitialized padding; zero it before nla_put\"\n    - Highlight\
  \ the data argument expression (arg3).\n    - Emit the report.\n\n\n5) Optional\
  \ minor callbacks\n\n- No need for checkBind, checkLocation, checkBranchCondition,\
  \ or DeclStmt hooks. We keep the checker focused and simple.\n- No need for alias\
  \ tracking; we purposefully only detect the clear and common pattern \u201Cnla_put(...,\
  \ sizeof(var), &var)\u201D.\n\n6) Heuristics to reduce false positives\n\n- Only\
  \ warn when:\n  - The copied pointer is directly &localStructVar (no globals, no\
  \ heap).\n  - The struct type has padding based on ASTRecordLayout.\n  - The length\
  \ exactly equals sizeof(struct).\n  - There was no prior zeroing recognized by memset/bzero\
  \ with size covering the entire struct.\n- Do not treat aggregate initializers or\
  \ assignments like \u201Cvar = (struct T){0}\u201D or \u201Cstruct T var = { ...\
  \ }\u201D as safe, since they do not guarantee padding is zeroed.\n\n\n7) Function\
  \ name and index summary\n\n- Zeroing functions (checkPostCall):\n  - \"memset\"\
  : args [0]=dst, [1]=value, [2]=size\n  - \"__builtin_memset\": same as memset\n\
  \  - \"bzero\": args [0]=dst, [1]=size\n\n- Copy-to-user via netlink (checkPreCall):\n\
  \  - \"nla_put\": args [0]=skb, [1]=type, [2]=len, [3]=data\n  - \"nla_put_64bit\"\
  : args [0]=skb, [1]=type, [2]=len, [3]=data, [4]=pad\n  - \"nla_put_nohdr\": args\
  \ [0]=skb, [1]=len, [2]=data  (For this one, use index [1]=len, [2]=data. Add a\
  \ small branch in isNLAPutLike-handling to pick indices per function.)\n  - \"nla_put_with_pad\"\
  : args [0]=skb, [1]=type, [2]=len, [3]=data, [4]=pad\n\n\n8) Bug report\n\n- Use\
  \ PathSensitiveBugReport (short message):\n  - Title: \"Kernel infoleak: copying\
  \ stack struct with uninitialized padding\"\n  - Description: \"Copying stack struct\
  \ with uninitialized padding; zero it before nla_put\"\n- Add the data argument\
  \ range to the report.\n- Use generateNonFatalErrorNode to create the node before\
  \ emitting."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Decl.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/AST/Type.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Tracks local struct variables that have been fully zeroed by memset/bzero.\nREGISTER_MAP_WITH_PROGRAMSTATE(ZeroedStructMap,\
  \ const MemRegion*, bool)\n\nnamespace {\nclass SAGenTestChecker : public Checker<check::PostCall,\
  \ check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n   SAGenTestChecker()\n\
  \     : BT(new BugType(this,\n                      \"Kernel infoleak: copying stack\
  \ struct with uninitialized padding\",\n                      \"Security\")) {}\n\
  \n   void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n   void\
  \ checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\nprivate:\n  \
  \ // Helpers\n   static bool isZeroingFunc(const CallEvent &Call, CheckerContext\
  \ &C);\n   static bool isNLAPutLike(const CallEvent &Call, CheckerContext &C);\n\
  \   static bool pickNlaArgsIndices(const CallEvent &Call, CheckerContext &C,\n \
  \                                 unsigned &LenIdx, unsigned &DataIdx);\n\n   static\
  \ const VarDecl* getAddrOfLocalVar(const Expr *E, CheckerContext &C,\n         \
  \                                  const MemRegion* &OutRegion);\n\n   static bool\
  \ tryEvalToUnsigned(const Expr *E, CheckerContext &C, uint64_t &Out);\n   static\
  \ uint64_t getTypeSizeInBytes(QualType QT, CheckerContext &C);\n   static bool recordHasPadding(QualType\
  \ QT, CheckerContext &C);\n};\n\n// Return true if the call is memset/__builtin_memset/bzero\n\
  bool SAGenTestChecker::isZeroingFunc(const CallEvent &Call, CheckerContext &C) {\n\
  \  const Expr *OE = Call.getOriginExpr();\n  if (!OE)\n    return false;\n  if (ExprHasName(OE,\
  \ \"memset\", C))\n    return true;\n  if (ExprHasName(OE, \"__builtin_memset\"\
  , C))\n    return true;\n  if (ExprHasName(OE, \"bzero\", C))\n    return true;\n\
  \  return false;\n}\n\n// Return true if the call is one of nla_put-like functions\
  \ we care about.\nbool SAGenTestChecker::isNLAPutLike(const CallEvent &Call, CheckerContext\
  \ &C) {\n  const Expr *OE = Call.getOriginExpr();\n  if (!OE)\n    return false;\n\
  \  return ExprHasName(OE, \"nla_put\", C) ||\n         ExprHasName(OE, \"nla_put_64bit\"\
  , C) ||\n         ExprHasName(OE, \"nla_put_nohdr\", C) ||\n         ExprHasName(OE,\
  \ \"nla_put_with_pad\", C);\n}\n\n// Determine argument indices for len and data\
  \ for nla_put-like calls.\nbool SAGenTestChecker::pickNlaArgsIndices(const CallEvent\
  \ &Call, CheckerContext &C,\n                                          unsigned\
  \ &LenIdx, unsigned &DataIdx) {\n  const Expr *OE = Call.getOriginExpr();\n  if\
  \ (!OE)\n    return false;\n\n  if (ExprHasName(OE, \"nla_put_nohdr\", C)) {\n \
  \   // nla_put_nohdr(skb, len, data)\n    if (Call.getNumArgs() < 3)\n      return\
  \ false;\n    LenIdx = 1;\n    DataIdx = 2;\n    return true;\n  }\n\n  if (ExprHasName(OE,\
  \ \"nla_put\", C) ||\n      ExprHasName(OE, \"nla_put_64bit\", C) ||\n      ExprHasName(OE,\
  \ \"nla_put_with_pad\", C)) {\n    // nla_put*(skb, type, len, data, ...)\n    if\
  \ (Call.getNumArgs() < 4)\n      return false;\n    LenIdx = 2;\n    DataIdx = 3;\n\
  \    return true;\n  }\n\n  return false;\n}\n\n// If E is &localVar, return the\
  \ VarDecl and its MemRegion (base region).\nconst VarDecl* SAGenTestChecker::getAddrOfLocalVar(const\
  \ Expr *E, CheckerContext &C,\n                                                \
  \   const MemRegion* &OutRegion) {\n  OutRegion = nullptr;\n  if (!E)\n    return\
  \ nullptr;\n\n  E = E->IgnoreParenImpCasts();\n  const auto *UO = dyn_cast<UnaryOperator>(E);\n\
  \  if (!UO || UO->getOpcode() != UO_AddrOf)\n    return nullptr;\n\n  const Expr\
  \ *Sub = UO->getSubExpr();\n  if (!Sub)\n    return nullptr;\n\n  Sub = Sub->IgnoreParenImpCasts();\n\
  \  const auto *DRE = dyn_cast<DeclRefExpr>(Sub);\n  if (!DRE)\n    return nullptr;\n\
  \n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n    return\
  \ nullptr;\n\n  // Only consider local variables (stack-allocated in function scope).\n\
  \  if (!VD->hasLocalStorage())\n    return nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(DRE,\
  \ C);\n  if (!MR)\n    return nullptr;\n  MR = MR->getBaseRegion();\n  if (!MR)\n\
  \    return nullptr;\n\n  OutRegion = MR;\n  return VD;\n}\n\nbool SAGenTestChecker::tryEvalToUnsigned(const\
  \ Expr *E, CheckerContext &C, uint64_t &Out) {\n  if (!E)\n    return false;\n \
  \ llvm::APSInt V;\n  if (!EvaluateExprToInt(V, E, C))\n    return false;\n  Out\
  \ = V.getZExtValue();\n  return true;\n}\n\nuint64_t SAGenTestChecker::getTypeSizeInBytes(QualType\
  \ QT, CheckerContext &C) {\n  return C.getASTContext().getTypeSizeInChars(QT).getQuantity();\n\
  }\n\n// Determine if a struct type has internal padding or tail padding.\nbool SAGenTestChecker::recordHasPadding(QualType\
  \ QT, CheckerContext &C) {\n  QT = QT.getCanonicalType();\n  if (!QT->isStructureType())\n\
  \    return false;\n\n  const auto *RT = QT->getAs<RecordType>();\n  if (!RT)\n\
  \    return false;\n\n  const RecordDecl *RD = RT->getDecl();\n  if (!RD)\n    return\
  \ false;\n  if (RD->isUnion())\n    return false;\n  if (!RD->isCompleteDefinition())\n\
  \    return false;\n\n  ASTContext &Ctx = C.getASTContext();\n  const ASTRecordLayout\
  \ &Layout = Ctx.getASTRecordLayout(RD);\n\n  uint64_t PrevEndBits = 0;\n  unsigned\
  \ Index = 0;\n  for (const FieldDecl *FD : RD->fields()) {\n    if (!FD)\n     \
  \ continue;\n\n    // If this is a flexible array member at end, stop checking here.\n\
  \    // We conservatively ignore it for padding calculation.\n    if (FD->getType()->isIncompleteArrayType())\n\
  \      break;\n\n    uint64_t FieldOffsetBits = Layout.getFieldOffset(Index);\n\
  \    uint64_t FieldSizeBits = 0;\n\n    if (FD->isBitField()) {\n      // Bit-field\
  \ width in bits\n      FieldSizeBits = FD->getBitWidthValue(Ctx);\n    } else {\n\
  \      FieldSizeBits = Ctx.getTypeSize(FD->getType()); // in bits\n    }\n\n   \
  \ if (FieldOffsetBits > PrevEndBits) {\n      // Gap detected -> internal padding\n\
  \      return true;\n    }\n\n    uint64_t EndBits = FieldOffsetBits + FieldSizeBits;\n\
  \    if (EndBits > PrevEndBits)\n      PrevEndBits = EndBits;\n\n    ++Index;\n\
  \  }\n\n  // Tail padding: struct size (including alignment) > end of last field.\n\
  \  uint64_t RecordSizeBits = Ctx.getTypeSize(QT); // in bits\n  if (RecordSizeBits\
  \ > PrevEndBits)\n    return true;\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isZeroingFunc(Call, C))\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE)\n    return;\n\n  // memset(dst, value, size)\n  if (ExprHasName(OE,\
  \ \"memset\", C) || ExprHasName(OE, \"__builtin_memset\", C)) {\n    if (Call.getNumArgs()\
  \ < 3)\n      return;\n\n    const MemRegion *MR = nullptr;\n    const VarDecl *VD\
  \ = getAddrOfLocalVar(Call.getArgExpr(0), C, MR);\n    if (!VD || !MR)\n      return;\n\
  \n    // value must be 0\n    uint64_t ValU = 0;\n    if (!tryEvalToUnsigned(Call.getArgExpr(1),\
  \ C, ValU))\n      return;\n    if (ValU != 0)\n      return;\n\n    // size must\
  \ cover the whole struct\n    uint64_t SizeU = 0;\n    if (!tryEvalToUnsigned(Call.getArgExpr(2),\
  \ C, SizeU))\n      return;\n\n    uint64_t TypeSize = getTypeSizeInBytes(VD->getType(),\
  \ C);\n    if (SizeU >= TypeSize) {\n      State = State->set<ZeroedStructMap>(MR,\
  \ true);\n      C.addTransition(State);\n    }\n    return;\n  }\n\n  // bzero(dst,\
  \ size)\n  if (ExprHasName(OE, \"bzero\", C)) {\n    if (Call.getNumArgs() < 2)\n\
  \      return;\n\n    const MemRegion *MR = nullptr;\n    const VarDecl *VD = getAddrOfLocalVar(Call.getArgExpr(0),\
  \ C, MR);\n    if (!VD || !MR)\n      return;\n\n    uint64_t SizeU = 0;\n    if\
  \ (!tryEvalToUnsigned(Call.getArgExpr(1), C, SizeU))\n      return;\n\n    uint64_t\
  \ TypeSize = getTypeSizeInBytes(VD->getType(), C);\n    if (SizeU >= TypeSize) {\n\
  \      State = State->set<ZeroedStructMap>(MR, true);\n      C.addTransition(State);\n\
  \    }\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  if (!isNLAPutLike(Call, C))\n    return;\n\
  \n  unsigned LenIdx = 0, DataIdx = 0;\n  if (!pickNlaArgsIndices(Call, C, LenIdx,\
  \ DataIdx))\n    return;\n\n  if (Call.getNumArgs() <= std::max(LenIdx, DataIdx))\n\
  \    return;\n\n  // Data argument must be &localStructVar\n  const MemRegion *MR\
  \ = nullptr;\n  const VarDecl *VD = getAddrOfLocalVar(Call.getArgExpr(DataIdx),\
  \ C, MR);\n  if (!VD || !MR)\n    return;\n\n  QualType VarQT = VD->getType();\n\
  \  if (!VarQT->isStructureType())\n    return;\n\n  if (!recordHasPadding(VarQT,\
  \ C))\n    return;\n\n  // len must be exactly sizeof(var)\n  uint64_t LenU = 0;\n\
  \  if (!tryEvalToUnsigned(Call.getArgExpr(LenIdx), C, LenU))\n    return;\n\n  uint64_t\
  \ TypeSize = getTypeSizeInBytes(VarQT, C);\n  if (LenU != TypeSize)\n    return;\n\
  \n  // If explicitly zeroed before, consider safe.\n  ProgramStateRef State = C.getState();\n\
  \  const bool *Zeroed = State->get<ZeroedStructMap>(MR);\n  if (Zeroed && *Zeroed)\n\
  \    return;\n\n  // Report: copying stack struct with padding directly to user\
  \ space\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n      \"Copying\
  \ stack struct with uninitialized padding; zero it before nla_put\",\n      N);\n\
  \  const Expr *DataE = Call.getArgExpr(DataIdx);\n  if (DataE)\n    R->addRange(DataE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect copying stack struct with padding\
  \ to user via nla_put without zeroing\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
