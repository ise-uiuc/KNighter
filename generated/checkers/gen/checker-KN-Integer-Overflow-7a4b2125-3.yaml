_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 7a4b21250bf79eef26543d35bd390448646c536b
commit_type: Integer-Overflow
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// Program state: track variables (mem\
  \ regions) that store results of roundup_pow_of_two(arg)\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion*, const Expr*)\n\nnamespace {\n\n/* The checker callbacks are\
  \ to be decided. */\nclass SAGenTestChecker : public Checker<check::Bind, check::BranchCondition>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"UB-prone overflow check for roundup_pow_of_two\", \"\
  API Misuse\")) {}\n\n      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const;\n      void checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const;\n\n   private:\n\n      // Helpers\n      static bool isRoundupPow2Call(const\
  \ CallExpr *CE, CheckerContext &C);\n      static bool isZeroLiteral(const Expr\
  \ *E, CheckerContext &C);\n      static const MemRegion* getRegionFromDeclRef(const\
  \ Expr *E, CheckerContext &C);\n\n      static bool isNegated(const Expr *Cond,\
  \ const Expr *&Inner);\n      static bool isEqZeroCheck(const Expr *Cond, const\
  \ Expr *&NonZeroSide, CheckerContext &C);\n\n      void reportIssue(const Stmt *Anchor,\
  \ CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isRoundupPow2Call(const\
  \ CallExpr *CE, CheckerContext &C) {\n  if (!CE) return false;\n\n  if (const FunctionDecl\
  \ *FD = CE->getDirectCallee()) {\n    if (const IdentifierInfo *ID = FD->getIdentifier())\
  \ {\n      if (ID->getName() == \"roundup_pow_of_two\")\n        return true;\n\
  \    }\n  }\n  // Fallback: textual match on the callee expression if not a direct\
  \ callee\n  const Expr *CalleeE = CE->getCallee();\n  return CalleeE ? ExprHasName(CalleeE,\
  \ \"roundup_pow_of_two\", C) : false;\n}\n\nbool SAGenTestChecker::isZeroLiteral(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return false;\n  llvm::APSInt Val;\n\
  \  if (EvaluateExprToInt(Val, E, C)) {\n    return Val == 0;\n  }\n  // Also handle\
  \ null pointer constants treated as zero in integer context\n  if (E->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull))\n    return true;\n  return false;\n}\n\nconst\
  \ MemRegion* SAGenTestChecker::getRegionFromDeclRef(const Expr *E, CheckerContext\
  \ &C) {\n  if (!E) return nullptr;\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR) return nullptr;\n  return MR->getBaseRegion();\n}\n\nbool SAGenTestChecker::isNegated(const\
  \ Expr *Cond, const Expr *&Inner) {\n  if (!Cond) return false;\n  Cond = Cond->IgnoreParenCasts();\n\
  \  if (const auto *UO = dyn_cast<UnaryOperator>(Cond)) {\n    if (UO->getOpcode()\
  \ == UO_LNot) {\n      Inner = UO->getSubExpr()->IgnoreParenCasts();\n      return\
  \ true;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isEqZeroCheck(const\
  \ Expr *Cond, const Expr *&NonZeroSide, CheckerContext &C) {\n  if (!Cond) return\
  \ false;\n  Cond = Cond->IgnoreParenCasts();\n  if (const auto *BO = dyn_cast<BinaryOperator>(Cond))\
  \ {\n    if (BO->getOpcode() == BO_EQ) {\n      const Expr *L = BO->getLHS()->IgnoreParenCasts();\n\
  \      const Expr *R = BO->getRHS()->IgnoreParenCasts();\n      if (isZeroLiteral(L,\
  \ C)) {\n        NonZeroSide = R;\n        return true;\n      }\n      if (isZeroLiteral(R,\
  \ C)) {\n        NonZeroSide = L;\n        return true;\n      }\n    }\n  }\n \
  \ return false;\n}\n\nvoid SAGenTestChecker::reportIssue(const Stmt *Anchor, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n      \"Do not\
  \ detect roundup_pow_of_two overflow via zero; pre-validate input (x <= 1UL << 31)\"\
  ,\n      N);\n  if (Anchor)\n    R->addRange(Anchor->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *DstR\
  \ = Loc.getAsRegion();\n  if (!DstR)\n    return;\n  DstR = DstR->getBaseRegion();\n\
  \  if (!DstR)\n    return;\n\n  // Try to find a call expression within the statement\
  \ being bound.\n  const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(S);\n\
  \  if (CE && isRoundupPow2Call(CE, C)) {\n    // Record that this region stores\
  \ a result of roundup_pow_of_two(arg)\n    const Expr *Arg = nullptr;\n    if (CE->getNumArgs()\
  \ >= 1)\n      Arg = CE->getArg(0)->IgnoreParenImpCasts();\n\n    State = State->set<RoundupResMap>(DstR,\
  \ Arg);\n    C.addTransition(State);\n    return;\n  }\n\n  // If this region was\
  \ previously recorded and now being overwritten\n  // with a non-roundup value,\
  \ clear the record.\n  if (State->contains<RoundupResMap>(DstR)) {\n    State =\
  \ State->remove<RoundupResMap>(DstR);\n    C.addTransition(State);\n  }\n}\n\nvoid\
  \ SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE) {\n    C.addTransition(State);\n    return;\n  }\n  CondE = CondE->IgnoreParenImpCasts();\n\
  \n  // A) Direct call-in-condition pattern: if (!roundup_pow_of_two(x)) or if (roundup_pow_of_two(x)\
  \ == 0)\n  if (const CallExpr *InnerCE = findSpecificTypeInChildren<CallExpr>(CondE))\
  \ {\n    if (InnerCE && isRoundupPow2Call(InnerCE, C)) {\n      const Expr *Inner\
  \ = nullptr;\n      if (isNegated(CondE, Inner) && Inner == InnerCE) {\n       \
  \ reportIssue(Condition, C);\n        return;\n      }\n      const Expr *NonZeroSide\
  \ = nullptr;\n      if (isEqZeroCheck(CondE, NonZeroSide, C) && NonZeroSide == InnerCE)\
  \ {\n        reportIssue(Condition, C);\n        return;\n      }\n    }\n  }\n\n\
  \  // B) Variable-based pattern: if (!n) or if (n == 0) where n holds roundup result.\n\
  \  const Expr *Inner = nullptr;\n  if (isNegated(CondE, Inner)) {\n    // if (!n)\n\
  \    const Expr *E = Inner ? Inner->IgnoreParenCasts() : nullptr;\n    if (E) {\n\
  \      if (const MemRegion *MR = getRegionFromDeclRef(E, C)) {\n        if (State->contains<RoundupResMap>(MR))\
  \ {\n          reportIssue(Condition, C);\n          return;\n        }\n      }\n\
  \    }\n  } else {\n    // if (n == 0)\n    const Expr *NonZeroSide = nullptr;\n\
  \    if (isEqZeroCheck(CondE, NonZeroSide, C)) {\n      const Expr *E = NonZeroSide\
  \ ? NonZeroSide->IgnoreParenCasts() : nullptr;\n      if (E) {\n        if (const\
  \ MemRegion *MR = getRegionFromDeclRef(E, C)) {\n          if (State->contains<RoundupResMap>(MR))\
  \ {\n            reportIssue(Condition, C);\n            return;\n          }\n\
  \        }\n      }\n    }\n  }\n\n  C.addTransition(State);\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects zero-check overflow detection on roundup_pow_of_two results;\
  \ advise pre-validation to avoid UB on 32-bit\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbpf: Fix stackmap overflow check on 32-bit arches\n\
  \nThe stackmap code relies on roundup_pow_of_two() to compute the number\nof hash\
  \ buckets, and contains an overflow check by checking if the\nresulting value is\
  \ 0. However, on 32-bit arches, the roundup code itself\ncan overflow by doing a\
  \ 32-bit left-shift of an unsigned long value,\nwhich is undefined behaviour, so\
  \ it is not guaranteed to truncate\nneatly. This was triggered by syzbot on the\
  \ DEVMAP_HASH type, which\ncontains the same check, copied from the hashtab code.\n\
  \nThe commit in the fixes tag actually attempted to fix this, but the fix\ndid not\
  \ account for the UB, so the fix only works on CPUs where an\noverflow does result\
  \ in a neat truncation to zero, which is not\nguaranteed. Checking the value before\
  \ rounding does not have this\nproblem.\n\nFixes: 6183f4d3a0a2 (\"bpf: Check for\
  \ integer overflow when using roundup_pow_of_two()\")\nSigned-off-by: Toke H\xF8\
  iland-J\xF8rgensen <toke@redhat.com>\nReviewed-by: Bui Quang Minh <minhquangbui99@gmail.com>\n\
  Message-ID: <20240307120340.99577-4-toke@redhat.com>\nSigned-off-by: Alexei Starovoitov\
  \ <ast@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: stack_map_alloc in kernel/bpf/stackmap.c\n\
  static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n{\n\tu32 value_size\
  \ = attr->value_size;\n\tstruct bpf_stack_map *smap;\n\tu64 cost, n_buckets;\n\t\
  int err;\n\n\tif (attr->map_flags & ~STACK_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size\
  \ != 4 ||\n\t    value_size < 8 || value_size % 8)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\tBUILD_BUG_ON(sizeof(struct bpf_stack_build_id) % sizeof(u64));\n\tif (attr->map_flags\
  \ & BPF_F_STACK_BUILD_ID) {\n\t\tif (value_size % sizeof(struct bpf_stack_build_id)\
  \ ||\n\t\t    value_size / sizeof(struct bpf_stack_build_id)\n\t\t    > sysctl_perf_event_max_stack)\n\
  \t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n\
  \t\treturn ERR_PTR(-EINVAL);\n\n\t/* hash table size must be power of 2 */\n\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n\tif (!n_buckets)\n\t\treturn ERR_PTR(-E2BIG);\n\
  \n\tcost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);\n\tsmap\
  \ = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\tif (!smap)\n\t\t\
  return ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&smap->map, attr);\n\tsmap->n_buckets\
  \ = n_buckets;\n\n\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\t\
  if (err)\n\t\tgoto free_smap;\n\n\terr = prealloc_elems_and_freelist(smap);\n\t\
  if (err)\n\t\tgoto put_buffers;\n\n\treturn &smap->map;\n\nput_buffers:\n\tput_callchain_buffers();\n\
  free_smap:\n\tbpf_map_area_free(smap);\n\treturn ERR_PTR(err);\n}\n```\n\n## Bug\
  \ Fix Patch\n\n```diff\ndiff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c\n\
  index dff7ba539701..c99f8e5234ac 100644\n--- a/kernel/bpf/stackmap.c\n+++ b/kernel/bpf/stackmap.c\n\
  @@ -91,11 +91,14 @@ static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n\
  \ \t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n \t\treturn ERR_PTR(-EINVAL);\n\
  \ \n-\t/* hash table size must be power of 2 */\n-\tn_buckets = roundup_pow_of_two(attr->max_entries);\n\
  -\tif (!n_buckets)\n+\t/* hash table size must be power of 2; roundup_pow_of_two()\
  \ can overflow\n+\t * into UB on 32-bit arches, so check that first\n+\t */\n+\t\
  if (attr->max_entries > 1UL << 31)\n \t\treturn ERR_PTR(-E2BIG);\n \n+\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n+\n \tcost = n_buckets * sizeof(struct\
  \ stack_map_bucket *) + sizeof(*smap);\n \tsmap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\
  \ \tif (!smap)\n```\n"
pattern: '## Bug Pattern


  Computing a power-of-two size with roundup_pow_of_two(x) on an unvalidated 32-bit
  unsigned long input and detecting overflow by checking the returned value (e.g.,
  if (!n)).


  On 32-bit arches, roundup_pow_of_two() internally does a left shift (1UL << k).
  For x > (1UL << 31), this implies a shift by 32 bits, which is undefined behavior.
  Relying on the result being 0 to detect overflow is non-portable and unsafe. The
  correct pattern is to pre-validate that x <= (1UL << 31) before calling roundup_pow_of_two(),
  avoiding the UB entirely.'
plan: "Plan\n\n1. Program state customization\n- REGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion*, const Expr*)\n  - Key: the MemRegion that holds the result of\
  \ a roundup_pow_of_two(...) call.\n  - Value: the argument expression passed to\
  \ roundup_pow_of_two (stored as const Expr* only to give context if needed; not\
  \ required for reporting).\n- No other state is necessary. We keep the checker simple\
  \ and local to the anti-pattern.\n\n2. Helper utilities (internal to the checker)\n\
  - bool isRoundupPow2Call(const CallExpr *CE, CheckerContext &C)\n  - Return true\
  \ if CE\u2019s callee identifier name equals \"roundup_pow_of_two\".\n- bool isZeroLiteral(const\
  \ Expr *E, CheckerContext &C)\n  - Use EvaluateExprToInt(EvalRes, E, C); return\
  \ true if evaluable and equal to 0.\n- const MemRegion* getRegionFromDeclRef(const\
  \ Expr *E, CheckerContext &C)\n  - If E is a DeclRefExpr, return getMemRegionFromExpr(E,\
  \ C). Otherwise return nullptr.\n- Pattern matchers on conditions:\n  - bool isNegated(const\
  \ Expr *Cond, const Expr *&Inner)\n    - If Cond is a UnaryOperator with opcode\
  \ UO_LNot, set Inner to its subexpression and return true.\n  - bool isEqZeroCheck(const\
  \ Expr *Cond, const Expr *&NonZeroSide, CheckerContext &C)\n    - If Cond is a BinaryOperator\
  \ with opcode BO_EQ, and one side is zero (isZeroLiteral), set NonZeroSide to the\
  \ other side and return true.\n\n3. checkBind(SVal Loc, SVal Val, const Stmt *S,\
  \ CheckerContext &C)\nGoal: Record variables that receive results of roundup_pow_of_two(...)\
  \ and clear the record when overwritten with non-roundup values.\n- Extract the\
  \ destination region:\n  - const MemRegion *DstR = Loc.getAsRegion(); if (!DstR)\
  \ return.\n- Try to find a call expression within the statement being bound:\n \
  \ - const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(S).\n  - If CE and\
  \ isRoundupPow2Call(CE, C):\n    - Record: State = State->set<RoundupResMap>(DstR,\
  \ CE->getArg(0)->IgnoreParenImpCasts()).\n    - C.addTransition(State).\n    - Return.\n\
  - Otherwise, if DstR is present in RoundupResMap (i.e., the tracked variable is\
  \ being overwritten with something else), clear it:\n  - State = State->remove<RoundupResMap>(DstR);\
  \ C.addTransition(State).\n\nRationale: This captures both assignments n = roundup_pow_of_two(x)\
  \ and initializations u64 n = roundup_pow_of_two(x) via the bind event on DeclStmt/assignment.\
  \ It also cleans up on subsequent overwrites to reduce false positives.\n\n4. checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C)\nGoal: Detect the anti-pattern: using the\
  \ result of roundup_pow_of_two to detect overflow by checking if it is zero (e.g.,\
  \ if (!n) or if (n == 0)). Also handle the direct inline pattern if (!roundup_pow_of_two(x)).\n\
  - Let const Expr *Cond = dyn_cast<Expr>(Condition)->IgnoreParenImpCasts(); if (!Cond)\
  \ return.\n\nA) Direct-call-in-condition pattern\n- If const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(Cond):\n\
  \  - If isRoundupPow2Call(CE, C):\n    - Check if Cond is a negation of CE:\n  \
  \    - If isNegated(Cond, Inner) and Inner == CE:\n        - Report bug at Cond\
  \ (see step 6).\n        - Return.\n    - Check equality-to-zero form: if isEqZeroCheck(Cond,\
  \ NonZeroSide, C) and NonZeroSide == CE:\n      - Report bug.\n      - Return.\n\
  \nB) Variable-based pattern\n- If isNegated(Cond, Inner):\n  - If Inner is a DeclRefExpr\
  \ DRE, get region R = getRegionFromDeclRef(DRE, C).\n  - If R && State->contains<RoundupResMap>(R):\
  \ report bug.\n- Else if isEqZeroCheck(Cond, NonZeroSide, C):\n  - If NonZeroSide\
  \ is a DeclRefExpr DRE, get region R = getRegionFromDeclRef(DRE, C).\n  - If R &&\
  \ State->contains<RoundupResMap>(R): report bug.\n\nNote:\n- We deliberately keep\
  \ this simple and local: we do not attempt to prove whether there is a prior guard\
  \ Arg <= (1UL << 31). The unsafe pattern exists regardless because it relies on\
  \ UB in roundup_pow_of_two on 32-bit UL to detect overflow via zero result. The\
  \ simplest rule is to warn whenever zero is used to detect overflow for a roundup_pow_of_two\
  \ result.\n\n5. Optional cleanups (not strictly necessary)\n- No need for checkRegionChanges/checkEndFunction;\
  \ the map is path-sensitive and will be dropped at function end naturally.\n\n6.\
  \ Bug report\n- Create a BugType once (e.g., \"UB-prone overflow check for roundup_pow_of_two\
  \ result\").\n- Message: \"Do not detect roundup_pow_of_two overflow via zero; pre-validate\
  \ input (x <= 1UL << 31) to avoid UB on 32-bit.\"\n- Use generateNonFatalErrorNode\
  \ and std::make_unique<PathSensitiveBugReport>. Anchor at the condition expression\
  \ (Cond).\n- Optionally, add a path note when recording the result in checkBind:\
  \ \u201Cresult of roundup_pow_of_two stored here\u201D by attaching a note to the\
  \ bind location, if desired, but keep the primary message short.\n\n7. Summary of\
  \ chosen callbacks\n- checkBind: Track variables assigned from roundup_pow_of_two(...)\
  \ and clear tracking when overwritten.\n- checkBranchCondition: Detect zero-checks\
  \ on either the tracked variable or directly on the call expression, and report.\n\
  \n8. Notes on utilities usage\n- findSpecificTypeInChildren is used in both checkBind\
  \ (to find the call in assignment/decl) and checkBranchCondition (to find direct-call-in-condition).\n\
  - EvaluateExprToInt is used to robustly detect zero literal in equality checks.\n\
  - getMemRegionFromExpr is used to map DeclRefExpr to its region for lookups in RoundupResMap."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// Program state: track variables (mem\
  \ regions) that store results of roundup_pow_of_two(arg)\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion*, const Expr*)\n\nnamespace {\n\n/* The checker callbacks are\
  \ to be decided. */\nclass SAGenTestChecker : public Checker<check::Bind, check::BranchCondition>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"UB-prone overflow check for roundup_pow_of_two\", \"\
  API Misuse\")) {}\n\n      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const;\n      void checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const;\n\n   private:\n\n      // Helpers\n      static bool isRoundupPow2Call(const\
  \ CallExpr *CE, CheckerContext &C);\n      static bool isZeroLiteral(const Expr\
  \ *E, CheckerContext &C);\n      static const MemRegion* getRegionFromDeclRef(const\
  \ Expr *E, CheckerContext &C);\n\n      static bool isNegated(const Expr *Cond,\
  \ const Expr *&Inner);\n      static bool isEqZeroCheck(const Expr *Cond, const\
  \ Expr *&NonZeroSide, CheckerContext &C);\n\n      void reportIssue(const Stmt *Anchor,\
  \ CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isRoundupPow2Call(const\
  \ CallExpr *CE, CheckerContext &C) {\n  if (!CE) return false;\n\n  if (const FunctionDecl\
  \ *FD = CE->getDirectCallee()) {\n    if (const IdentifierInfo *ID = FD->getIdentifier())\
  \ {\n      if (ID->getName() == \"roundup_pow_of_two\")\n        return true;\n\
  \    }\n  }\n  // Fallback: textual match on the callee expression if not a direct\
  \ callee\n  const Expr *CalleeE = CE->getCallee();\n  return CalleeE ? ExprHasName(CalleeE,\
  \ \"roundup_pow_of_two\", C) : false;\n}\n\nbool SAGenTestChecker::isZeroLiteral(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return false;\n  llvm::APSInt Val;\n\
  \  if (EvaluateExprToInt(Val, E, C)) {\n    return Val == 0;\n  }\n  // Also handle\
  \ null pointer constants treated as zero in integer context\n  if (E->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull))\n    return true;\n  return false;\n}\n\nconst\
  \ MemRegion* SAGenTestChecker::getRegionFromDeclRef(const Expr *E, CheckerContext\
  \ &C) {\n  if (!E) return nullptr;\n  const MemRegion *MR = getMemRegionFromExpr(E,\
  \ C);\n  if (!MR) return nullptr;\n  return MR->getBaseRegion();\n}\n\nbool SAGenTestChecker::isNegated(const\
  \ Expr *Cond, const Expr *&Inner) {\n  if (!Cond) return false;\n  Cond = Cond->IgnoreParenCasts();\n\
  \  if (const auto *UO = dyn_cast<UnaryOperator>(Cond)) {\n    if (UO->getOpcode()\
  \ == UO_LNot) {\n      Inner = UO->getSubExpr()->IgnoreParenCasts();\n      return\
  \ true;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isEqZeroCheck(const\
  \ Expr *Cond, const Expr *&NonZeroSide, CheckerContext &C) {\n  if (!Cond) return\
  \ false;\n  Cond = Cond->IgnoreParenCasts();\n  if (const auto *BO = dyn_cast<BinaryOperator>(Cond))\
  \ {\n    if (BO->getOpcode() == BO_EQ) {\n      const Expr *L = BO->getLHS()->IgnoreParenCasts();\n\
  \      const Expr *R = BO->getRHS()->IgnoreParenCasts();\n      if (isZeroLiteral(L,\
  \ C)) {\n        NonZeroSide = R;\n        return true;\n      }\n      if (isZeroLiteral(R,\
  \ C)) {\n        NonZeroSide = L;\n        return true;\n      }\n    }\n  }\n \
  \ return false;\n}\n\nvoid SAGenTestChecker::reportIssue(const Stmt *Anchor, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n      \"Do not\
  \ detect roundup_pow_of_two overflow via zero; pre-validate input (x <= 1UL << 31)\"\
  ,\n      N);\n  if (Anchor)\n    R->addRange(Anchor->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *DstR\
  \ = Loc.getAsRegion();\n  if (!DstR)\n    return;\n  DstR = DstR->getBaseRegion();\n\
  \  if (!DstR)\n    return;\n\n  // Try to find a call expression within the statement\
  \ being bound.\n  const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(S);\n\
  \  if (CE && isRoundupPow2Call(CE, C)) {\n    // Record that this region stores\
  \ a result of roundup_pow_of_two(arg)\n    const Expr *Arg = nullptr;\n    if (CE->getNumArgs()\
  \ >= 1)\n      Arg = CE->getArg(0)->IgnoreParenImpCasts();\n\n    State = State->set<RoundupResMap>(DstR,\
  \ Arg);\n    C.addTransition(State);\n    return;\n  }\n\n  // If this region was\
  \ previously recorded and now being overwritten\n  // with a non-roundup value,\
  \ clear the record.\n  if (State->contains<RoundupResMap>(DstR)) {\n    State =\
  \ State->remove<RoundupResMap>(DstR);\n    C.addTransition(State);\n  }\n}\n\nvoid\
  \ SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE) {\n    C.addTransition(State);\n    return;\n  }\n  CondE = CondE->IgnoreParenImpCasts();\n\
  \n  // A) Direct call-in-condition pattern: if (!roundup_pow_of_two(x)) or if (roundup_pow_of_two(x)\
  \ == 0)\n  if (const CallExpr *InnerCE = findSpecificTypeInChildren<CallExpr>(CondE))\
  \ {\n    if (InnerCE && isRoundupPow2Call(InnerCE, C)) {\n      const Expr *Inner\
  \ = nullptr;\n      if (isNegated(CondE, Inner) && Inner == InnerCE) {\n       \
  \ reportIssue(Condition, C);\n        return;\n      }\n      const Expr *NonZeroSide\
  \ = nullptr;\n      if (isEqZeroCheck(CondE, NonZeroSide, C) && NonZeroSide == InnerCE)\
  \ {\n        reportIssue(Condition, C);\n        return;\n      }\n    }\n  }\n\n\
  \  // B) Variable-based pattern: if (!n) or if (n == 0) where n holds roundup result.\n\
  \  const Expr *Inner = nullptr;\n  if (isNegated(CondE, Inner)) {\n    // if (!n)\n\
  \    const Expr *E = Inner ? Inner->IgnoreParenCasts() : nullptr;\n    if (E) {\n\
  \      if (const MemRegion *MR = getRegionFromDeclRef(E, C)) {\n        if (State->contains<RoundupResMap>(MR))\
  \ {\n          reportIssue(Condition, C);\n          return;\n        }\n      }\n\
  \    }\n  } else {\n    // if (n == 0)\n    const Expr *NonZeroSide = nullptr;\n\
  \    if (isEqZeroCheck(CondE, NonZeroSide, C)) {\n      const Expr *E = NonZeroSide\
  \ ? NonZeroSide->IgnoreParenCasts() : nullptr;\n      if (E) {\n        if (const\
  \ MemRegion *MR = getRegionFromDeclRef(E, C)) {\n          if (State->contains<RoundupResMap>(MR))\
  \ {\n            reportIssue(Condition, C);\n            return;\n          }\n\
  \        }\n      }\n    }\n  }\n\n  C.addTransition(State);\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects zero-check overflow detection on roundup_pow_of_two results;\
  \ advise pre-validation to avoid UB on 32-bit\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
