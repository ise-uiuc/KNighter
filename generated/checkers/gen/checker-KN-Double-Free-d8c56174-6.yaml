_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: d8c561741ef83980114b3f7f95ffac54600f3f16
commit_type: Double-Free
index: 6
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state maps\n// Tracks \u201Csoftware SQ object\u201D instances (the base\
  \ pointer/struct region for sq) that have had a successful low-level create call\
  \ observed.\nREGISTER_MAP_WITH_PROGRAMSTATE(SQCreated, const MemRegion*, bool)\n\
  // Maps the field region of sq->sqn to the base MemRegion of sq (kept for completeness,\
  \ though we primarily compute base directly).\nREGISTER_MAP_WITH_PROGRAMSTATE(SQFieldToBase,\
  \ const MemRegion*, const MemRegion*)\n// Maps the symbolic return value from hws_send_ring_set_sq_rdy()\
  \ to the owning sq base region.\nREGISTER_MAP_WITH_PROGRAMSTATE(RetSymToSQBase,\
  \ SymbolRef, const MemRegion*)\n// Marks that we are currently in the error branch\
  \ that corresponds to \u201Cset_sq_rdy() failed\u201D for a specific sq.\nREGISTER_MAP_WITH_PROGRAMSTATE(SQErrBranchActive,\
  \ const MemRegion*, bool)\n\nnamespace {\n\nstatic bool callHasName(const CallEvent\
  \ &Call, CheckerContext &C, StringRef Name) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  return ExprHasName(Origin, Name, C);\n}\n\n\
  static const MemberExpr *getMemberExprFromArg(const Expr *E, CheckerContext &C)\
  \ {\n  if (!E)\n    return nullptr;\n  return findSpecificTypeInChildren<MemberExpr>(E);\n\
  }\n\n// Compute the base region that represents the SQ object being pointed to,\n\
  // by taking the FieldRegion of 'sq->sqn' MemberExpr and getting its base.\nstatic\
  \ const MemRegion *getSQBaseRegionFromMemberExpr(const MemberExpr *ME, CheckerContext\
  \ &C) {\n  if (!ME)\n    return nullptr;\n\n  // Important: do not IgnoreImplicit()\
  \ before getMemRegionFromExpr per guidance.\n  const MemRegion *FieldReg = getMemRegionFromExpr(ME,\
  \ C);\n  if (!FieldReg)\n    return nullptr;\n\n  const MemRegion *BaseReg = FieldReg->getBaseRegion();\n\
  \  return BaseReg;\n}\n\n// Extract base region of SQ from a function argument that\
  \ is the 'sq' pointer.\n// We want the pointee's base region (the software SQ object),\
  \ so we fetch the\n// region value of the expression and take its base.\nstatic\
  \ const MemRegion *getSQBaseRegionFromPointerArg(const Expr *E, CheckerContext &C)\
  \ {\n  if (!E)\n    return nullptr;\n\n  // Do not IgnoreImplicit() here.\n  const\
  \ MemRegion *Reg = getMemRegionFromExpr(E, C);\n  if (!Reg)\n    return nullptr;\n\
  \n  // Always normalize to the base region, per guidance.\n  return Reg->getBaseRegion();\n\
  }\n\nclass SAGenTestChecker\n  : public Checker<\n      check::PostCall,\n     \
  \ check::PreCall,\n      check::BranchCondition\n    > {\n\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"Wrong cleanup after\
  \ SQ set_rdy failure\", \"Resource Management\")) {}\n\n  void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  void checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const;\n\nprivate:\n  // Helpers recognizing specific functions\n\
  \  static bool isCreateSQ(const CallEvent &Call, CheckerContext &C) {\n    return\
  \ callHasName(Call, C, \"mlx5_core_create_sq\");\n  }\n  static bool isSetSQReady(const\
  \ CallEvent &Call, CheckerContext &C) {\n    return callHasName(Call, C, \"hws_send_ring_set_sq_rdy\"\
  );\n  }\n  static bool isCloseSQ(const CallEvent &Call, CheckerContext &C) {\n \
  \   return callHasName(Call, C, \"hws_send_ring_close_sq\");\n  }\n  static bool\
  \ isDestroySQ(const CallEvent &Call, CheckerContext &C) {\n    return callHasName(Call,\
  \ C, \"mlx5_core_destroy_sq\");\n  }\n\n  void reportWrongCleanup(const CallEvent\
  \ &Call, CheckerContext &C) const;\n};\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Track mlx5_core_create_sq(mdev, in, inlen, &sq->sqn)\n  if (isCreateSQ(Call,\
  \ C)) {\n    // 4th argument (index 3) is expected to be &sq->sqn\n    if (Call.getNumArgs()\
  \ > 3) {\n      const Expr *Arg3 = Call.getArgExpr(3);\n      const MemberExpr *ME\
  \ = getMemberExprFromArg(Arg3, C);\n      if (ME) {\n        const MemRegion *BaseReg\
  \ = getSQBaseRegionFromMemberExpr(ME, C);\n        if (BaseReg) {\n          //\
  \ Optionally keep a trivial field->base map for completeness\n          const MemRegion\
  \ *FieldReg = getMemRegionFromExpr(ME, C);\n          if (FieldReg) {\n        \
  \    // Per guidance, use base region normalization for keys as well\n         \
  \   State = State->set<SQFieldToBase>(FieldReg->getBaseRegion(), BaseReg);\n   \
  \       }\n          State = State->set<SQCreated>(BaseReg, true);\n          C.addTransition(State);\n\
  \          return;\n        }\n      }\n    }\n  }\n\n  // Track hws_send_ring_set_sq_rdy(mdev,\
  \ sq->sqn)\n  if (isSetSQReady(Call, C)) {\n    if (Call.getNumArgs() > 1) {\n \
  \     const Expr *Arg1 = Call.getArgExpr(1);\n      const MemberExpr *ME = getMemberExprFromArg(Arg1,\
  \ C);\n      if (ME) {\n        const MemRegion *BaseReg = getSQBaseRegionFromMemberExpr(ME,\
  \ C);\n        if (BaseReg) {\n          // Map the return symbol to the SQ base\
  \ region\n          SVal Ret = Call.getReturnValue();\n          if (SymbolRef RetSym\
  \ = Ret.getAsSymbol()) {\n            State = State->set<RetSymToSQBase>(RetSym,\
  \ BaseReg);\n            // Clean any stale error-branch marker for fresh call context.\n\
  \            State = State->remove<SQErrBranchActive>(BaseReg);\n            C.addTransition(State);\n\
  \            return;\n          }\n        } else {\n          // As a fallback,\
  \ try mapping via field->base if we had it\n          const MemRegion *FieldReg\
  \ = getMemRegionFromExpr(ME, C);\n          if (FieldReg) {\n            const MemRegion\
  \ *MappedBase = State->get<SQFieldToBase>(FieldReg->getBaseRegion());\n        \
  \    if (MappedBase) {\n              if (SymbolRef RetSym = Call.getReturnValue().getAsSymbol())\
  \ {\n                State = State->set<RetSymToSQBase>(RetSym, MappedBase);\n \
  \               State = State->remove<SQErrBranchActive>(MappedBase);\n        \
  \        C.addTransition(State);\n                return;\n              }\n   \
  \         }\n          }\n        }\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!Condition)\n    return;\n\n\
  \  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n  SVal CondV = State->getSVal(CondE, C.getLocationContext());\n\
  \n  // We only care about conditions like \"if (err)\" that are backed by a symbol.\n\
  \  if (SymbolRef Sym = CondV.getAsSymbol()) {\n    // Check if this symbol was the\
  \ return of hws_send_ring_set_sq_rdy\n    const MemRegion *BaseReg = State->get<RetSymToSQBase>(Sym);\n\
  \    if (BaseReg) {\n      // Split states on this condition\n      if (auto DV\
  \ = CondV.getAs<DefinedOrUnknownSVal>()) {\n        ProgramStateRef StateTrue, StateFalse;\n\
  \        std::tie(StateTrue, StateFalse) = State->assume(*DV);\n        bool didTransition\
  \ = false;\n\n        if (StateTrue) {\n          StateTrue = StateTrue->set<SQErrBranchActive>(BaseReg,\
  \ true);\n          C.addTransition(StateTrue);\n          didTransition = true;\n\
  \        }\n        if (StateFalse) {\n          // Not in error branch\n      \
  \    StateFalse = StateFalse->remove<SQErrBranchActive>(BaseReg);\n          C.addTransition(StateFalse);\n\
  \          didTransition = true;\n        }\n        if (didTransition)\n      \
  \    return; // We handled branching explicitly\n      }\n    }\n  }\n  // Otherwise\
  \ do nothing special; let core handle the branch.\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // We only report on the problematic cleanup: hws_send_ring_close_sq(sq)\n \
  \ if (isCloseSQ(Call, C)) {\n    if (Call.getNumArgs() > 0) {\n      const Expr\
  \ *Arg0 = Call.getArgExpr(0);\n      const MemRegion *BaseReg = getSQBaseRegionFromPointerArg(Arg0,\
  \ C);\n      if (!BaseReg)\n        return;\n\n      const bool *WasCreated = State->get<SQCreated>(BaseReg);\n\
  \      const bool *ErrActive = State->get<SQErrBranchActive>(BaseReg);\n\n     \
  \ if (WasCreated && *WasCreated && ErrActive && *ErrActive) {\n        // We are\
  \ in the error branch after set_sq_rdy() failed and a create was observed.\n   \
  \     // Calling the high-level close here may double free.\n        reportWrongCleanup(Call,\
  \ C);\n      }\n    }\n    return;\n  }\n\n  // Optional: recognizing mlx5_core_destroy_sq\
  \ is not necessary for reporting,\n  // but included here for completeness. We don't\
  \ mutate state.\n  if (isDestroySQ(Call, C)) {\n    // No action required.\n   \
  \ return;\n  }\n}\n\nvoid SAGenTestChecker::reportWrongCleanup(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"High-level close in intermediate error path may double free; call\
  \ mlx5_core_destroy_sq().\", N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects wrong cleanup after SQ set_rdy failure that may cause double\
  \ free; use mlx5_core_destroy_sq()\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/mlx5: HWS, fixed double-free in error flow of\
  \ creating SQ\n\nWhen SQ creation fails, call the appropriate mlx5_core destroy\
  \ function.\n\nThis fixes the following smatch warnings:\n  divers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c:739\n\
  \    hws_send_ring_open_sq() warn: 'sq->dep_wqe' double freed\n    hws_send_ring_open_sq()\
  \ warn: 'sq->wq_ctrl.buf.frags' double freed\n    hws_send_ring_open_sq() warn:\
  \ 'sq->wr_priv' double freed\n\nFixes: 2ca62599aa0b (\"net/mlx5: HWS, added send\
  \ engine and context handling\")\nReported-by: Dan Carpenter <dan.carpenter@linaro.org>\n\
  Closes: https://lore.kernel.org/all/e4ebc227-4b25-49bf-9e4c-14b7ea5c6a07@stanley.mountain/\n\
  Signed-off-by: Yevgeny Kliteynik <kliteyn@nvidia.com>\nSigned-off-by: Saeed Mahameed\
  \ <saeedm@nvidia.com>\n\n## Buggy Code\n\n```c\n// Function: hws_send_ring_create_sq\
  \ in drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\nstatic\
  \ int hws_send_ring_create_sq(struct mlx5_core_dev *mdev, u32 pdn,\n\t\t\t\t   void\
  \ *sqc_data,\n\t\t\t\t   struct mlx5hws_send_engine *queue,\n\t\t\t\t   struct mlx5hws_send_ring_sq\
  \ *sq,\n\t\t\t\t   struct mlx5hws_send_ring_cq *cq)\n{\n\tvoid *in, *sqc, *wq;\n\
  \tint inlen, err;\n\tu8 ts_format;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_sq_in) +\n\
  \t\tsizeof(u64) * sq->wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\
  \tif (!in)\n\t\treturn -ENOMEM;\n\n\tsqc = MLX5_ADDR_OF(create_sq_in, in, ctx);\n\
  \twq = MLX5_ADDR_OF(sqc, sqc, wq);\n\n\tmemcpy(sqc, sqc_data, MLX5_ST_SZ_BYTES(sqc));\n\
  \tMLX5_SET(sqc, sqc, cqn, cq->mcq.cqn);\n\n\tMLX5_SET(sqc, sqc, state, MLX5_SQC_STATE_RST);\n\
  \tMLX5_SET(sqc, sqc, flush_in_error_en, 1);\n\n\tts_format = mlx5_is_real_time_sq(mdev)\
  \ ? MLX5_TIMESTAMP_FORMAT_REAL_TIME :\n\t\t\t\t\t\t MLX5_TIMESTAMP_FORMAT_FREE_RUNNING;\n\
  \tMLX5_SET(sqc, sqc, ts_format, ts_format);\n\n\tMLX5_SET(wq, wq, wq_type, MLX5_WQ_TYPE_CYCLIC);\n\
  \tMLX5_SET(wq, wq, uar_page, mdev->mlx5e_res.hw_objs.bfreg.index);\n\tMLX5_SET(wq,\
  \ wq, log_wq_pg_sz, sq->wq_ctrl.buf.page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(wq,\
  \ wq, dbr_addr, sq->wq_ctrl.db.dma);\n\n\tmlx5_fill_page_frag_array(&sq->wq_ctrl.buf,\n\
  \t\t\t\t  (__be64 *)MLX5_ADDR_OF(wq, wq, pas));\n\n\terr = mlx5_core_create_sq(mdev,\
  \ in, inlen, &sq->sqn);\n\n\tkvfree(in);\n\n\treturn err;\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\
  \ b/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\nindex a1adbb48735c..0c7989184c30\
  \ 100644\n--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\n\
  +++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\n@@ -653,6\
  \ +653,12 @@ static int hws_send_ring_create_sq(struct mlx5_core_dev *mdev, u32\
  \ pdn,\n \treturn err;\n }\n \n+static void hws_send_ring_destroy_sq(struct mlx5_core_dev\
  \ *mdev,\n+\t\t\t\t     struct mlx5hws_send_ring_sq *sq)\n+{\n+\tmlx5_core_destroy_sq(mdev,\
  \ sq->sqn);\n+}\n+\n static int hws_send_ring_set_sq_rdy(struct mlx5_core_dev *mdev,\
  \ u32 sqn)\n {\n \tvoid *in, *sqc;\n@@ -696,7 +702,7 @@ static int hws_send_ring_create_sq_rdy(struct\
  \ mlx5_core_dev *mdev, u32 pdn,\n \n \terr = hws_send_ring_set_sq_rdy(mdev, sq->sqn);\n\
  \ \tif (err)\n-\t\thws_send_ring_close_sq(sq);\n+\t\thws_send_ring_destroy_sq(mdev,\
  \ sq);\n \n \treturn err;\n }\n```\n"
pattern: "## Bug Pattern\n\nUsing a high-level \u201Cclose/free\u201D cleanup helper\
  \ in an intermediate error path after only a subset of resources has been acquired,\
  \ causing software-owned memory to be freed twice. Specifically, after successfully\
  \ creating a HW SQ (mlx5_core_create_sq) but failing to set it ready, the code called\
  \ hws_send_ring_close_sq(sq), which frees software buffers (e.g., sq->dep_wqe, sq->wq_ctrl.buf.frags,\
  \ sq->wr_priv) that are also freed later by the outer cleanup, leading to double\
  \ free. The correct pattern is to undo only what was just acquired (call the matching\
  \ low-level destroy, mlx5_core_destroy_sq) and leave higher-level resource freeing\
  \ to the owning cleanup path."
plan: "Plan\n\n1) Program state\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(SQCreated, const\
  \ MemRegion*, bool)\n  - Tracks \u201Csoftware SQ object\u201D instances (the base\
  \ pointer/struct region for sq) that have had a successful low-level create call\
  \ observed.\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(SQFieldToBase, const MemRegion*,\
  \ const MemRegion*)\n  - Maps the field region of sq->sqn to the base MemRegion\
  \ of sq. This lets us correlate calls that pass sq->sqn (by address or by value)\
  \ with the owning sq object.\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(RetSymToSQBase,\
  \ SymbolRef, const MemRegion*)\n  - Maps the symbolic return value from hws_send_ring_set_sq_rdy()\
  \ to the owning sq base region. This is used to recognize the error branch when\
  \ the condition checks that return.\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(SQErrBranchActive,\
  \ const MemRegion*, bool)\n  - Marks that we are currently in the error branch that\
  \ corresponds to \u201Cset_sq_rdy() failed\u201D for a specific sq. This is path-sensitive\
  \ and only present on the branch where the condition is true.\n\n\n2) Helper identification\
  \ and extraction\n\n- Function recognition by name:\n  - isCreateSQ(Call): callee\
  \ == \"mlx5_core_create_sq\"\n  - isSetSQReady(Call): callee == \"hws_send_ring_set_sq_rdy\"\
  \n  - isCloseSQ(Call): callee == \"hws_send_ring_close_sq\"\n  - isDestroySQ(Call):\
  \ callee == \"mlx5_core_destroy_sq\"\n\n- Extract base sq region from expressions:\n\
  \  - From &sq->sqn:\n    - Use findSpecificTypeInChildren<MemberExpr>(ArgExpr) to\
  \ get the MemberExpr (ME).\n    - Base expression: ME->getBase()->IgnoreImpCasts().\n\
  \    - Base region: getMemRegionFromExpr(BaseExpr, C).\n    - Field region: getMemRegionFromExpr(ME,\
  \ C) (the region of sq->sqn).\n  - From sq->sqn (by value):\n    - Same MemberExpr\
  \ extraction and base-region derivation as above.\n\n- If extraction fails (not\
  \ a MemberExpr on sq->sqn), skip to avoid false positives. Keep the logic simple\
  \ and conservative.\n\n\n3) checkPostCall\n\n- For mlx5_core_create_sq:\n  - Obtain\
  \ the 4th argument (index 3) expression; expect it to be &sq->sqn.\n  - Extract\
  \ FieldRegion (sq->sqn) and BaseRegion (sq) as described above.\n  - Record SQFieldToBase[FieldRegion]\
  \ = BaseRegion.\n  - Mark SQCreated[BaseRegion] = true.\n\n- For hws_send_ring_set_sq_rdy:\n\
  \  - Obtain the 2nd argument (index 1) expression; expect sq->sqn by value.\n  -\
  \ Extract FieldRegion from the MemberExpr; look up BaseRegion via SQFieldToBase[FieldRegion].\n\
  \  - Get the return SVal of the call; if it has a SymbolRef RetSym:\n    - RetSymToSQBase[RetSym]\
  \ = BaseRegion.\n    - Optionally clear any stale SQErrBranchActive[BaseRegion]\
  \ entry to ensure we only react to the most recent call (not strictly necessary,\
  \ but keeps state clean).\n\n\n4) checkBranchCondition\n\n- Purpose: detect the\
  \ \u201Cerror branch\u201D that checks the return from hws_send_ring_set_sq_rdy.\n\
  - If Condition is an Expr:\n  - SVal CondV = Ctx.getSVal(Expr).\n  - If CondV is\
  \ a DefinedOrUnknownSVal backed by a SymbolRef Sym (e.g., \u201Cif (err)\u201D pattern):\n\
  \    - Query RetSymToSQBase[Sym] to get BaseRegion.\n    - If found, split states\
  \ using assume:\n      - auto [StateT, StateF] = Ctx.getState()->assume(CondV);\n\
  \      - If StateT: set SQErrBranchActive[BaseRegion] = true in StateT.\n      -\
  \ If StateF: remove SQErrBranchActive[BaseRegion] (or set false) in StateF.\n  \
  \    - Emit transitions for the available states and return.\n- If no matching symbol/base\
  \ found, do nothing (let the core handle branching).\n\n\n5) checkPreCall\n\n- For\
  \ hws_send_ring_close_sq:\n  - Extract the argument (index 0) as the BaseRegion\
  \ (sq).\n  - Check:\n    - SQCreated[BaseRegion] == true (we observed a prior create)\n\
  \    - SQErrBranchActive[BaseRegion] == true (we are in \u201Cset_sq_rdy failed\u201D\
  \ branch)\n  - If both hold, report a bug:\n    - Create a non-fatal error node\
  \ and emit a PathSensitiveBugReport.\n    - Message: \u201CHigh-level close in error\
  \ path after set_sq_rdy; may double free. Use mlx5_core_destroy_sq().\u201D\n  -\
  \ Regardless of reporting, do not mutate state here (let path sensitivity handle\
  \ flow). The presence of SQErrBranchActive is already branch-specific.\n\n- For\
  \ mlx5_core_destroy_sq (optional cleanup):\n  - If you want to minimize follow-up\
  \ noise, extract BaseRegion from context if available (not strictly necessary).\n\
  \  - If the function uses only sqn, you can skip updating SQCreated; the main goal\
  \ is to flag the wrong close in the error branch.\n\n\n6) Notes and simplifications\n\
  \n- We purposely require:\n  - Observed create_sq with &sq->sqn before warning (SQCreated\
  \ flag).\n  - Error branch detected specifically from the return value of set_sq_rdy\
  \ (via RetSymToSQBase and BranchCondition).\n  - The close call must pass the same\
  \ sq object we mapped (argument 0).\n- This keeps the checker precise for the target\
  \ pattern and avoids generic double-free heuristics.\n- We do not attempt to track\
  \ aliasing of sq or sqn beyond straightforward MemberExpr extraction (simple and\
  \ robust for this case).\n\n\n7) Bug report details\n\n- Use generateNonFatalErrorNode\
  \ for the error node.\n- Use std::make_unique<PathSensitiveBugReport> with a short\
  \ message:\n  - Title: \u201CWrong cleanup after SQ set_rdy failure\u201D\n  - Description:\
  \ \u201CHigh-level close in intermediate error path may double free; call mlx5_core_destroy_sq().\u201D\
  \n- Attach the call to hws_send_ring_close_sq as the interesting location."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state maps\n// Tracks \u201Csoftware SQ object\u201D instances (the base\
  \ pointer/struct region for sq) that have had a successful low-level create call\
  \ observed.\nREGISTER_MAP_WITH_PROGRAMSTATE(SQCreated, const MemRegion*, bool)\n\
  // Maps the field region of sq->sqn to the base MemRegion of sq (kept for completeness,\
  \ though we primarily compute base directly).\nREGISTER_MAP_WITH_PROGRAMSTATE(SQFieldToBase,\
  \ const MemRegion*, const MemRegion*)\n// Maps the symbolic return value from hws_send_ring_set_sq_rdy()\
  \ to the owning sq base region.\nREGISTER_MAP_WITH_PROGRAMSTATE(RetSymToSQBase,\
  \ SymbolRef, const MemRegion*)\n// Marks that we are currently in the error branch\
  \ that corresponds to \u201Cset_sq_rdy() failed\u201D for a specific sq.\nREGISTER_MAP_WITH_PROGRAMSTATE(SQErrBranchActive,\
  \ const MemRegion*, bool)\n\nnamespace {\n\nstatic bool callHasName(const CallEvent\
  \ &Call, CheckerContext &C, StringRef Name) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  return ExprHasName(Origin, Name, C);\n}\n\n\
  static const MemberExpr *getMemberExprFromArg(const Expr *E, CheckerContext &C)\
  \ {\n  if (!E)\n    return nullptr;\n  return findSpecificTypeInChildren<MemberExpr>(E);\n\
  }\n\n// Compute the base region that represents the SQ object being pointed to,\n\
  // by taking the FieldRegion of 'sq->sqn' MemberExpr and getting its base.\nstatic\
  \ const MemRegion *getSQBaseRegionFromMemberExpr(const MemberExpr *ME, CheckerContext\
  \ &C) {\n  if (!ME)\n    return nullptr;\n\n  // Important: do not IgnoreImplicit()\
  \ before getMemRegionFromExpr per guidance.\n  const MemRegion *FieldReg = getMemRegionFromExpr(ME,\
  \ C);\n  if (!FieldReg)\n    return nullptr;\n\n  const MemRegion *BaseReg = FieldReg->getBaseRegion();\n\
  \  return BaseReg;\n}\n\n// Extract base region of SQ from a function argument that\
  \ is the 'sq' pointer.\n// We want the pointee's base region (the software SQ object),\
  \ so we fetch the\n// region value of the expression and take its base.\nstatic\
  \ const MemRegion *getSQBaseRegionFromPointerArg(const Expr *E, CheckerContext &C)\
  \ {\n  if (!E)\n    return nullptr;\n\n  // Do not IgnoreImplicit() here.\n  const\
  \ MemRegion *Reg = getMemRegionFromExpr(E, C);\n  if (!Reg)\n    return nullptr;\n\
  \n  // Always normalize to the base region, per guidance.\n  return Reg->getBaseRegion();\n\
  }\n\nclass SAGenTestChecker\n  : public Checker<\n      check::PostCall,\n     \
  \ check::PreCall,\n      check::BranchCondition\n    > {\n\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"Wrong cleanup after\
  \ SQ set_rdy failure\", \"Resource Management\")) {}\n\n  void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  void checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const;\n\nprivate:\n  // Helpers recognizing specific functions\n\
  \  static bool isCreateSQ(const CallEvent &Call, CheckerContext &C) {\n    return\
  \ callHasName(Call, C, \"mlx5_core_create_sq\");\n  }\n  static bool isSetSQReady(const\
  \ CallEvent &Call, CheckerContext &C) {\n    return callHasName(Call, C, \"hws_send_ring_set_sq_rdy\"\
  );\n  }\n  static bool isCloseSQ(const CallEvent &Call, CheckerContext &C) {\n \
  \   return callHasName(Call, C, \"hws_send_ring_close_sq\");\n  }\n  static bool\
  \ isDestroySQ(const CallEvent &Call, CheckerContext &C) {\n    return callHasName(Call,\
  \ C, \"mlx5_core_destroy_sq\");\n  }\n\n  void reportWrongCleanup(const CallEvent\
  \ &Call, CheckerContext &C) const;\n};\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Track mlx5_core_create_sq(mdev, in, inlen, &sq->sqn)\n  if (isCreateSQ(Call,\
  \ C)) {\n    // 4th argument (index 3) is expected to be &sq->sqn\n    if (Call.getNumArgs()\
  \ > 3) {\n      const Expr *Arg3 = Call.getArgExpr(3);\n      const MemberExpr *ME\
  \ = getMemberExprFromArg(Arg3, C);\n      if (ME) {\n        const MemRegion *BaseReg\
  \ = getSQBaseRegionFromMemberExpr(ME, C);\n        if (BaseReg) {\n          //\
  \ Optionally keep a trivial field->base map for completeness\n          const MemRegion\
  \ *FieldReg = getMemRegionFromExpr(ME, C);\n          if (FieldReg) {\n        \
  \    // Per guidance, use base region normalization for keys as well\n         \
  \   State = State->set<SQFieldToBase>(FieldReg->getBaseRegion(), BaseReg);\n   \
  \       }\n          State = State->set<SQCreated>(BaseReg, true);\n          C.addTransition(State);\n\
  \          return;\n        }\n      }\n    }\n  }\n\n  // Track hws_send_ring_set_sq_rdy(mdev,\
  \ sq->sqn)\n  if (isSetSQReady(Call, C)) {\n    if (Call.getNumArgs() > 1) {\n \
  \     const Expr *Arg1 = Call.getArgExpr(1);\n      const MemberExpr *ME = getMemberExprFromArg(Arg1,\
  \ C);\n      if (ME) {\n        const MemRegion *BaseReg = getSQBaseRegionFromMemberExpr(ME,\
  \ C);\n        if (BaseReg) {\n          // Map the return symbol to the SQ base\
  \ region\n          SVal Ret = Call.getReturnValue();\n          if (SymbolRef RetSym\
  \ = Ret.getAsSymbol()) {\n            State = State->set<RetSymToSQBase>(RetSym,\
  \ BaseReg);\n            // Clean any stale error-branch marker for fresh call context.\n\
  \            State = State->remove<SQErrBranchActive>(BaseReg);\n            C.addTransition(State);\n\
  \            return;\n          }\n        } else {\n          // As a fallback,\
  \ try mapping via field->base if we had it\n          const MemRegion *FieldReg\
  \ = getMemRegionFromExpr(ME, C);\n          if (FieldReg) {\n            const MemRegion\
  \ * const *MappedBasePtr =\n                State->get<SQFieldToBase>(FieldReg->getBaseRegion());\n\
  \            if (MappedBasePtr) {\n              const MemRegion *MappedBase = *MappedBasePtr;\n\
  \              if (SymbolRef RetSym = Call.getReturnValue().getAsSymbol()) {\n \
  \               State = State->set<RetSymToSQBase>(RetSym, MappedBase);\n      \
  \          State = State->remove<SQErrBranchActive>(MappedBase);\n             \
  \   C.addTransition(State);\n                return;\n              }\n        \
  \    }\n          }\n        }\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!Condition)\n    return;\n\n\
  \  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n  SVal CondV = State->getSVal(CondE, C.getLocationContext());\n\
  \n  // We only care about conditions like \"if (err)\" that are backed by a symbol.\n\
  \  if (SymbolRef Sym = CondV.getAsSymbol()) {\n    // Check if this symbol was the\
  \ return of hws_send_ring_set_sq_rdy\n    const MemRegion * const *BaseRegPtr =\
  \ State->get<RetSymToSQBase>(Sym);\n    if (BaseRegPtr) {\n      const MemRegion\
  \ *BaseReg = *BaseRegPtr;\n      // Split states on this condition\n      if (auto\
  \ DV = CondV.getAs<DefinedOrUnknownSVal>()) {\n        ProgramStateRef StateTrue,\
  \ StateFalse;\n        std::tie(StateTrue, StateFalse) = State->assume(*DV);\n \
  \       bool didTransition = false;\n\n        if (StateTrue) {\n          StateTrue\
  \ = StateTrue->set<SQErrBranchActive>(BaseReg, true);\n          C.addTransition(StateTrue);\n\
  \          didTransition = true;\n        }\n        if (StateFalse) {\n       \
  \   // Not in error branch\n          StateFalse = StateFalse->remove<SQErrBranchActive>(BaseReg);\n\
  \          C.addTransition(StateFalse);\n          didTransition = true;\n     \
  \   }\n        if (didTransition)\n          return; // We handled branching explicitly\n\
  \      }\n    }\n  }\n  // Otherwise do nothing special; let core handle the branch.\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n\n  // We only report on the\
  \ problematic cleanup: hws_send_ring_close_sq(sq)\n  if (isCloseSQ(Call, C)) {\n\
  \    if (Call.getNumArgs() > 0) {\n      const Expr *Arg0 = Call.getArgExpr(0);\n\
  \      const MemRegion *BaseReg = getSQBaseRegionFromPointerArg(Arg0, C);\n    \
  \  if (!BaseReg)\n        return;\n\n      const bool *WasCreated = State->get<SQCreated>(BaseReg);\n\
  \      const bool *ErrActive = State->get<SQErrBranchActive>(BaseReg);\n\n     \
  \ if (WasCreated && *WasCreated && ErrActive && *ErrActive) {\n        // We are\
  \ in the error branch after set_sq_rdy() failed and a create was observed.\n   \
  \     // Calling the high-level close here may double free.\n        reportWrongCleanup(Call,\
  \ C);\n      }\n    }\n    return;\n  }\n\n  // Optional: recognizing mlx5_core_destroy_sq\
  \ is not necessary for reporting,\n  // but included here for completeness. We don't\
  \ mutate state.\n  if (isDestroySQ(Call, C)) {\n    // No action required.\n   \
  \ return;\n  }\n}\n\nvoid SAGenTestChecker::reportWrongCleanup(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"High-level close in intermediate error path may double free; call\
  \ mlx5_core_destroy_sq().\", N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects wrong cleanup after SQ set_rdy failure that may cause double\
  \ free; use mlx5_core_destroy_sq()\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
