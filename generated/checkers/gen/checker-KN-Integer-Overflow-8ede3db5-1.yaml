_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 8ede3db5061bb1fe28e2c9683329aafa89d2b1b4
commit_type: Integer-Overflow
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ state is required.\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Lossy cast hides overflow in add_overflow check\", \"\
  API Misuse\")) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\n   private:\n      static bool isAddOverflowLike(const CallEvent\
  \ &Call, CheckerContext &C);\n      static const Expr *getExplicitNarrowingCastOfSizeRelated(const\
  \ Expr *E, ASTContext &ACtx);\n};\n\nstatic bool isSignedIntegerType(QualType QT)\
  \ {\n  if (QT.isNull()) return false;\n  const Type *Ty = QT.getTypePtrOrNull();\n\
  \  if (!Ty) return false;\n  return QT->isIntegerType() && QT->isSignedIntegerType();\n\
  }\n\nbool SAGenTestChecker::isAddOverflowLike(const CallEvent &Call, CheckerContext\
  \ &C) {\n  const Expr *Origin = Call.getOriginExpr();\n  if (Origin) {\n    // Prefer\
  \ direct source-text name matching on the origin expression.\n    if (ExprHasName(Origin,\
  \ \"check_add_overflow\", C))\n      return true;\n    if (ExprHasName(Origin, \"\
  __builtin_add_overflow\", C))\n      return true;\n    // Some kernels use macros/wrappers\
  \ that still contain \"add_overflow\".\n    if (ExprHasName(Origin, \"add_overflow\"\
  , C))\n      return true;\n  }\n\n  // Fallback: use callee identifier if available.\n\
  \  if (const IdentifierInfo *ID = Call.getCalleeIdentifier()) {\n    StringRef N\
  \ = ID->getName();\n    if (N == \"check_add_overflow\")\n      return true;\n \
  \   if (N.contains(\"add_overflow\"))\n      return true;\n  }\n  return false;\n\
  }\n\n// Return the explicit cast expression if E is a top-level explicit cast that\n\
  // converts a size-related value (sizeof or size_t) to a signed integer type\n//\
  \ that is narrower, or same-width signed from unsigned. Otherwise, return null.\n\
  const Expr *SAGenTestChecker::getExplicitNarrowingCastOfSizeRelated(const Expr *E,\n\
  \                                                                    ASTContext\
  \ &ACtx) {\n  if (!E)\n    return nullptr;\n  const Expr *Top = E->IgnoreParens();\
  \ // do not ignore explicit casts\n\n  // In C, explicit casts are CStyleCastExpr.\n\
  \  const auto *CSE = dyn_cast<CStyleCastExpr>(Top);\n  if (!CSE)\n    return nullptr;\n\
  \n  QualType ToT = CSE->getType().getCanonicalType();\n  if (!isSignedIntegerType(ToT))\n\
  \    return nullptr;\n\n  const Expr *Sub = CSE->getSubExpr();\n  if (!Sub)\n  \
  \  return nullptr;\n\n  // Ignore parens around the subexpr; keep implicit casts\
  \ if any to read FromT.\n  const Expr *CoreSub = Sub->IgnoreParens();\n  QualType\
  \ FromT = CoreSub->getType().getCanonicalType();\n  if (FromT.isNull())\n    return\
  \ nullptr;\n\n  // Determine if the subexpr is size-related: either sizeof(...)\
  \ expr,\n  // or the type of the subexpr is size_t.\n  bool IsSizeof = false;\n\
  \  if (const auto *UETT = dyn_cast<UnaryExprOrTypeTraitExpr>(CoreSub)) {\n    if\
  \ (UETT->getKind() == UETT_SizeOf)\n      IsSizeof = true;\n  }\n\n  bool IsSizeT\
  \ = (FromT == ACtx.getSizeType());\n  if (!IsSizeof && !IsSizeT)\n    return nullptr;\n\
  \n  // Signedness and bit widths.\n  bool FromIsUnsigned = FromT->isUnsignedIntegerType();\n\
  \  unsigned FromBits = ACtx.getTypeSize(FromT);\n  unsigned ToBits   = ACtx.getTypeSize(ToT);\n\
  \n  // Problematic if:\n  // - To is signed and narrower than From (truncation).\n\
  \  // - Or same width, converting from unsigned to signed (can flip negative).\n\
  \  if (ToBits < FromBits)\n    return CSE;\n  if (ToBits == FromBits && FromIsUnsigned)\n\
  \    return CSE;\n\n  return nullptr;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isAddOverflowLike(Call, C))\n\
  \    return;\n\n  if (Call.getNumArgs() != 3)\n    return;\n\n  ASTContext &ACtx\
  \ = C.getASTContext();\n\n  const Expr *Arg0 = Call.getArgExpr(0);\n  const Expr\
  \ *Arg1 = Call.getArgExpr(1);\n\n  const Expr *BadA = getExplicitNarrowingCastOfSizeRelated(Arg0,\
  \ ACtx);\n  const Expr *BadB = getExplicitNarrowingCastOfSizeRelated(Arg1, ACtx);\n\
  \n  if (!BadA && !BadB)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Lossy cast to int in check_add_overflow may hide overflow; avoid casting\
  \ sizeof/size_t to int\", N);\n\n  if (BadA)\n    R->addRange(BadA->getSourceRange());\n\
  \  if (BadB)\n    R->addRange(BadB->getSourceRange());\n\n  if (const Expr *OE =\
  \ Call.getOriginExpr())\n    R->addRange(OE->getSourceRange());\n\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects lossy casts of size-related operands in add_overflow checks that\
  \ can hide overflow\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nio_uring/net: fix overflow check in io_recvmsg_mshot_prep()\n\
  \nThe \"controllen\" variable is type size_t (unsigned long).  Casting it\nto int\
  \ could lead to an integer underflow.\n\nThe check_add_overflow() function considers\
  \ the type of the destination\nwhich is type int.  If we add two positive values\
  \ and the result cannot\nfit in an integer then that's counted as an overflow.\n\
  \nHowever, if we cast \"controllen\" to an int and it turns negative, then\nnegative\
  \ values *can* fit into an int type so there is no overflow.\n\nGood: 100 + (unsigned\
  \ long)-4 = 96  <-- overflow\n Bad: 100 + (int)-4 = 96 <-- no overflow\n\nI deleted\
  \ the cast of the sizeof() as well.  That's not a bug but the\ncast is unnecessary.\n\
  \nFixes: 9b0fc3c054ff (\"io_uring: fix types in io_recvmsg_multishot_overflow\"\
  )\nSigned-off-by: Dan Carpenter <dan.carpenter@linaro.org>\nLink: https://lore.kernel.org/r/138bd2e2-ede8-4bcc-aa7b-f3d9de167a37@moroto.mountain\n\
  Signed-off-by: Jens Axboe <axboe@kernel.dk>\n\n## Buggy Code\n\n```c\n// Function:\
  \ io_recvmsg_mshot_prep in io_uring/net.c\nstatic int io_recvmsg_mshot_prep(struct\
  \ io_kiocb *req,\n\t\t\t\t struct io_async_msghdr *iomsg,\n\t\t\t\t int namelen,\
  \ size_t controllen)\n{\n\tif ((req->flags & (REQ_F_APOLL_MULTISHOT|REQ_F_BUFFER_SELECT))\
  \ ==\n\t\t\t  (REQ_F_APOLL_MULTISHOT|REQ_F_BUFFER_SELECT)) {\n\t\tint hdr;\n\n\t\
  \tif (unlikely(namelen < 0))\n\t\t\treturn -EOVERFLOW;\n\t\tif (check_add_overflow((int)sizeof(struct\
  \ io_uring_recvmsg_out),\n\t\t\t\t\tnamelen, &hdr))\n\t\t\treturn -EOVERFLOW;\n\t\
  \tif (check_add_overflow(hdr, (int)controllen, &hdr))\n\t\t\treturn -EOVERFLOW;\n\
  \n\t\tiomsg->namelen = namelen;\n\t\tiomsg->controllen = controllen;\n\t\treturn\
  \ 0;\n\t}\n\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/io_uring/net.c\
  \ b/io_uring/net.c\nindex 40d4542bfe2a..1640e985cd08 100644\n--- a/io_uring/net.c\n\
  +++ b/io_uring/net.c\n@@ -559,10 +559,10 @@ static int io_recvmsg_mshot_prep(struct\
  \ io_kiocb *req,\n \n \t\tif (unlikely(namelen < 0))\n \t\t\treturn -EOVERFLOW;\n\
  -\t\tif (check_add_overflow((int)sizeof(struct io_uring_recvmsg_out),\n+\t\tif (check_add_overflow(sizeof(struct\
  \ io_uring_recvmsg_out),\n \t\t\t\t\tnamelen, &hdr))\n \t\t\treturn -EOVERFLOW;\n\
  -\t\tif (check_add_overflow(hdr, (int)controllen, &hdr))\n+\t\tif (check_add_overflow(hdr,\
  \ controllen, &hdr))\n \t\t\treturn -EOVERFLOW;\n \n \t\tiomsg->namelen = namelen;\n\
  ```\n"
pattern: '## Bug Pattern


  Using check_add_overflow() with a narrower destination type (int) while downcasting
  size-related operands (size_t/sizeof) to int, causing truncation/sign-change. Large
  size_t values can become negative when cast to int, making the addition appear non-overflowing
  in int and thus bypassing the overflow check. The check must be performed in the
  widest relevant type (e.g., size_t) without lossy casts.'
plan: "Plan to detect lossy casts in check_add_overflow calls\n\n1. Program state\n\
  - No custom program state is needed. This checker is purely syntactic/semantic on\
  \ calls. Do not register any ProgramState maps or traits.\n\n2. Callback selection\n\
  - Use checkPreCall only.\n  - We only need to inspect the call expression\u2019\
  s callee name and argument ASTs and report immediately if we find the pattern.\n\
  - No other callbacks are required.\n\n3. Call identification (checkPreCall)\n- Retrieve\
  \ the callee identifier: if none, return.\n- Match the function name against:\n\
  \  - \"check_add_overflow\"\n  - or contains \"add_overflow\" to catch the builtin\
  \ \"__builtin_add_overflow\" invoked through the kernel macro.\n- If not matched,\
  \ return.\n- Retrieve the three arguments: A = arg0, B = arg1, C = arg2. If the\
  \ number of arguments is not 3, return.\n\n4. Extract destination type (for context;\
  \ no direct reporting basis)\n- From C (arg2), try to get the pointee type:\n  -\
  \ If arg2 is a UnaryOperator with opcode UO_AddrOf on a DeclRefExpr, get the VarDecl\u2019\
  s type (pointee type Tdest).\n  - If it\u2019s an arbitrary expression, attempt\
  \ to get the SVal\u2019s region with getMemRegionFromExpr and infer the pointee\
  \ QualType; if unavailable, skip Tdest-based checks.\n- We will NOT report based\
  \ solely on Tdest being \u201Cint\u201D to avoid false positives (the target patch\
  \ still uses \u2018int hdr\u2019). This info is only used as context.\n\n5. Detect\
  \ lossy explicit casts on operands A/B\nImplement a helper isExplicitNarrowingCastOfSizeRelated(const\
  \ Expr *E, ASTContext &ACtx):\n- Goal: return true if E contains an explicit cast\
  \ (top-level) that converts a size-related value (size_t or sizeof) to a signed\
  \ narrower (or equal-width signed from unsigned) integer type (commonly int).\n\
  - Steps:\n  - Let Top = E->IgnoreParens() (do NOT ignore explicit casts).\n  - If\
  \ Top is not a CStyleCastExpr/CXXFunctionalCastExpr/CXXStaticCastExpr, return false.\n\
  \  - Let ToT = Top->getType().getCanonicalType(); let Sub = castExpr->getSubExpr()->IgnoreParens();\
  \ let FromT = Sub->getType().getCanonicalType().\n  - Check that ToT is an integer\
  \ type. If not, return false.\n  - Determine if Sub is \u201Csize-related\u201D\
  :\n    - Sub is a UnaryExprOrTypeTraitExpr of kind UETT_SizeOf.\n    - OR FromT\
  \ == ACtx.getSizeType() (canonical type comparison).\n  - If not size-related, return\
  \ false.\n  - Compute bit widths and signedness:\n    - unsigned FromIsUnsigned\
  \ = FromT->isUnsignedIntegerType();\n    - unsigned ToIsSigned = ToT->isSignedIntegerType();\n\
  \    - unsigned FromBits = ACtx.getTypeSize(FromT);\n    - unsigned ToBits = ACtx.getTypeSize(ToT).\n\
  \  - Consider it a problematic narrowing if any of:\n    - ToBits < FromBits (truncation),\
  \ regardless of signedness.\n    - ToBits == FromBits and FromIsUnsigned and ToIsSigned\
  \ (unsigned-to-signed same-width, can flip to negative).\n- Return true if problematic\
  \ narrowing; otherwise false.\n\n6. Apply detection on both operands and report\n\
  - In checkPreCall, evaluate:\n  - BadA = isExplicitNarrowingCastOfSizeRelated(Call.getArgExpr(0),\
  \ ACtx)\n  - BadB = isExplicitNarrowingCastOfSizeRelated(Call.getArgExpr(1), ACtx)\n\
  - If BadA || BadB:\n  - Create a non-fatal error node via generateNonFatalErrorNode.\n\
  \  - Emit a PathSensitiveBugReport with a short message:\n    - \u201CLossy cast\
  \ to int in check_add_overflow may hide overflow; avoid casting sizeof/size_t to\
  \ int.\u201D\n  - Add a note range at the casted argument expression for better\
  \ pinpointing.\n\n7. Heuristics and false-positive control\n- Only report when there\
  \ is an explicit narrowing cast on A or B from size-related type to a signed narrower\
  \ or equal-width-signed type. This matches the target patch (casts removed) and\
  \ avoids flagging uses where only the destination is \u2018int\u2019.\n- Do NOT\
  \ report when there are no explicit casts on A/B, even if the destination result\
  \ variable is of narrower type (to avoid false positives on existing kernel idioms\
  \ like \u2018int hdr\u2019).\n\n8. Utility usage\n- getMemRegionFromExpr: optional,\
  \ if trying to refine destination type provenance; not required for reporting.\n\
  - ExprHasName: not required; we rely on AST kinds to detect sizeof and types.\n\
  - findSpecificTypeInParents/Children: not required.\n\n9. Summary of minimal implementation\
  \ steps\n- No program state.\n- Implement checkPreCall:\n  - Match callee name:\
  \ \"check_add_overflow\" or contains \"add_overflow\".\n  - For arg0/arg1, detect\
  \ explicit narrowing cast from size-related type using isExplicitNarrowingCastOfSizeRelated.\n\
  \  - If found, report a bug with a short, clear message at the cast location."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ state is required.\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Lossy cast hides overflow in add_overflow check\", \"\
  API Misuse\")) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\n   private:\n      static bool isAddOverflowLike(const CallEvent\
  \ &Call, CheckerContext &C);\n      static const Expr *getExplicitNarrowingCastOfSizeRelated(const\
  \ Expr *E, ASTContext &ACtx);\n};\n\nstatic bool isSignedIntegerType(QualType QT)\
  \ {\n  if (QT.isNull()) return false;\n  const Type *Ty = QT.getTypePtrOrNull();\n\
  \  if (!Ty) return false;\n  return QT->isIntegerType() && QT->isSignedIntegerType();\n\
  }\n\nbool SAGenTestChecker::isAddOverflowLike(const CallEvent &Call, CheckerContext\
  \ &C) {\n  const Expr *Origin = Call.getOriginExpr();\n  if (Origin) {\n    // Prefer\
  \ direct source-text name matching on the origin expression.\n    if (ExprHasName(Origin,\
  \ \"check_add_overflow\", C))\n      return true;\n    if (ExprHasName(Origin, \"\
  __builtin_add_overflow\", C))\n      return true;\n    // Some kernels use macros/wrappers\
  \ that still contain \"add_overflow\".\n    if (ExprHasName(Origin, \"add_overflow\"\
  , C))\n      return true;\n  }\n\n  // Fallback: use callee identifier if available.\n\
  \  if (const IdentifierInfo *ID = Call.getCalleeIdentifier()) {\n    StringRef N\
  \ = ID->getName();\n    if (N == \"check_add_overflow\")\n      return true;\n \
  \   if (N.contains(\"add_overflow\"))\n      return true;\n  }\n  return false;\n\
  }\n\n// Return the explicit cast expression if E is a top-level explicit cast that\n\
  // converts a size-related value (sizeof or size_t) to a signed integer type\n//\
  \ that is narrower, or same-width signed from unsigned. Otherwise, return null.\n\
  const Expr *SAGenTestChecker::getExplicitNarrowingCastOfSizeRelated(const Expr *E,\n\
  \                                                                    ASTContext\
  \ &ACtx) {\n  if (!E)\n    return nullptr;\n  const Expr *Top = E->IgnoreParens();\
  \ // do not ignore explicit casts\n\n  // In C, explicit casts are CStyleCastExpr.\n\
  \  const auto *CSE = dyn_cast<CStyleCastExpr>(Top);\n  if (!CSE)\n    return nullptr;\n\
  \n  QualType ToT = CSE->getType().getCanonicalType();\n  if (!isSignedIntegerType(ToT))\n\
  \    return nullptr;\n\n  const Expr *Sub = CSE->getSubExpr();\n  if (!Sub)\n  \
  \  return nullptr;\n\n  // Ignore parens around the subexpr; keep implicit casts\
  \ if any to read FromT.\n  const Expr *CoreSub = Sub->IgnoreParens();\n  QualType\
  \ FromT = CoreSub->getType().getCanonicalType();\n  if (FromT.isNull())\n    return\
  \ nullptr;\n\n  // Determine if the subexpr is size-related: either sizeof(...)\
  \ expr,\n  // or the type of the subexpr is size_t.\n  bool IsSizeof = false;\n\
  \  if (const auto *UETT = dyn_cast<UnaryExprOrTypeTraitExpr>(CoreSub)) {\n    if\
  \ (UETT->getKind() == UETT_SizeOf)\n      IsSizeof = true;\n  }\n\n  bool IsSizeT\
  \ = (FromT == ACtx.getSizeType());\n  if (!IsSizeof && !IsSizeT)\n    return nullptr;\n\
  \n  // Signedness and bit widths.\n  bool FromIsUnsigned = FromT->isUnsignedIntegerType();\n\
  \  unsigned FromBits = ACtx.getTypeSize(FromT);\n  unsigned ToBits   = ACtx.getTypeSize(ToT);\n\
  \n  // Problematic if:\n  // - To is signed and narrower than From (truncation).\n\
  \  // - Or same width, converting from unsigned to signed (can flip negative).\n\
  \  if (ToBits < FromBits)\n    return CSE;\n  if (ToBits == FromBits && FromIsUnsigned)\n\
  \    return CSE;\n\n  return nullptr;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isAddOverflowLike(Call, C))\n\
  \    return;\n\n  if (Call.getNumArgs() != 3)\n    return;\n\n  ASTContext &ACtx\
  \ = C.getASTContext();\n\n  const Expr *Arg0 = Call.getArgExpr(0);\n  const Expr\
  \ *Arg1 = Call.getArgExpr(1);\n\n  const Expr *BadA = getExplicitNarrowingCastOfSizeRelated(Arg0,\
  \ ACtx);\n  const Expr *BadB = getExplicitNarrowingCastOfSizeRelated(Arg1, ACtx);\n\
  \n  if (!BadA && !BadB)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Lossy cast to int in check_add_overflow may hide overflow; avoid casting\
  \ sizeof/size_t to int\", N);\n\n  if (BadA)\n    R->addRange(BadA->getSourceRange());\n\
  \  if (BadB)\n    R->addRange(BadB->getSourceRange());\n\n  if (const Expr *OE =\
  \ Call.getOriginExpr())\n    R->addRange(OE->getSourceRange());\n\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects lossy casts of size-related operands in add_overflow checks that\
  \ can hide overflow\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
