_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3f7d9c1964fcd16d02a8a9d4fd6f6cb60c4cc530
commit_type: Out-of-Bound
index: 5
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state: track variables/fields that hold rss_max_key_size and need validation.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(RssKeySizeMap, const MemRegion *, unsigned)\n\nnamespace\
  \ {\n\nenum RssKeyCheckState : unsigned {\n  NeedsCheck = 0,\n  Checked = 1\n};\n\
  \nclass SAGenTestChecker\n  : public Checker<\n      check::PostCall,        //\
  \ track virtio_cread8(... rss_max_key_size)\n      check::PreCall,         // detect\
  \ uses as length in memcpy/memmove/memset/sg_init_one\n      check::BranchCondition\
  \  // mark checked when compared against VIRTIO_NET_RSS_MAX_KEY_SIZE\n    > {\n\
  \   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(std::make_unique<BugType>(this, \"Unchecked device-reported RSS key length\"\
  , \"API Misuse\")) {}\n\n      void checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n      void checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const;\n      void checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const;\n\n   private:\n      // Helpers\n      bool isVirtioCread8RssKeySize(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      const MemRegion *getAssignedRegionForCallResult(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      ProgramStateRef markRegionCheckedIfComparedToMax(const\
  \ Stmt *Cond, CheckerContext &C, ProgramStateRef State) const;\n      bool isKnownLengthUse(const\
  \ CallEvent &Call, CheckerContext &C, unsigned &LenParamIdx) const;\n      const\
  \ MemRegion *argExprRegion(const CallEvent &Call, unsigned Idx, CheckerContext &C)\
  \ const;\n      void reportUncheckedLengthUse(const Stmt *UseSite, CheckerContext\
  \ &C, const MemRegion *R) const;\n};\n\n// Determine if this call is virtio_cread8(...)\
  \ where an argument mentions rss_max_key_size.\nbool SAGenTestChecker::isVirtioCread8RssKeySize(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Use source-text matching for callee name\
  \ as suggested.\n  if (!ExprHasName(Origin, \"virtio_cread8\", C))\n    return false;\n\
  \n  // Look for \"rss_max_key_size\" in any argument's source.\n  for (unsigned\
  \ i = 0; i < Call.getNumArgs(); ++i) {\n    if (const Expr *AE = Call.getArgExpr(i))\
  \ {\n      if (ExprHasName(AE, \"rss_max_key_size\", C))\n        return true;\n\
  \    }\n  }\n  return false;\n}\n\n// From the virtio_cread8(...) call, find the\
  \ assignment LHS region that receives the result.\nconst MemRegion *SAGenTestChecker::getAssignedRegionForCallResult(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return nullptr;\n  const auto *CE = dyn_cast<CallExpr>(Origin);\n\
  \  if (!CE)\n    return nullptr;\n\n  // Ascend to parent BinaryOperator '='\n \
  \ const BinaryOperator *BO = findSpecificTypeInParents<BinaryOperator>(CE, C);\n\
  \  if (!BO || !BO->isAssignmentOp())\n    return nullptr;\n\n  const Expr *LHS =\
  \ BO->getLHS();\n  if (!LHS)\n    return nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(LHS,\
  \ C);\n  if (!MR)\n    return nullptr;\n  MR = MR->getBaseRegion();\n  return MR;\n\
  }\n\n// If a branch condition compares the tracked variable to VIRTIO_NET_RSS_MAX_KEY_SIZE,\
  \ mark it checked.\nProgramStateRef SAGenTestChecker::markRegionCheckedIfComparedToMax(const\
  \ Stmt *Cond, CheckerContext &C, ProgramStateRef State) const {\n  const Expr *CondE\
  \ = dyn_cast_or_null<Expr>(Cond);\n  if (!CondE)\n    return State;\n\n  // Ensure\
  \ the macro appears in the condition.\n  if (!ExprHasName(CondE, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C))\n    return State;\n\n  // Try to find a MemberExpr (e.g., vi->rss_key_size)\
  \ first.\n  const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(Cond);\n\
  \  const Expr *TargetExpr = nullptr;\n  if (ME) {\n    TargetExpr = ME;\n  } else\
  \ {\n    // Fallback: find a DeclRefExpr (e.g., local variable holding the size)\n\
  \    const DeclRefExpr *DRE = findSpecificTypeInChildren<DeclRefExpr>(Cond);\n \
  \   if (DRE)\n      TargetExpr = DRE;\n  }\n\n  if (!TargetExpr)\n    return State;\n\
  \n  const MemRegion *MR = getMemRegionFromExpr(TargetExpr, C);\n  if (!MR)\n   \
  \ return State;\n  MR = MR->getBaseRegion();\n\n  const unsigned *Val = State->get<RssKeySizeMap>(MR);\n\
  \  if (Val && *Val == NeedsCheck) {\n    State = State->set<RssKeySizeMap>(MR, Checked);\n\
  \  }\n  return State;\n}\n\n// Recognize common functions where a length parameter\
  \ is used.\nbool SAGenTestChecker::isKnownLengthUse(const CallEvent &Call, CheckerContext\
  \ &C, unsigned &LenParamIdx) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // memcpy/memmove/memset have length as\
  \ the 3rd argument (index 2).\n  if (ExprHasName(Origin, \"memcpy\", C) ||\n   \
  \   ExprHasName(Origin, \"memmove\", C) ||\n      ExprHasName(Origin, \"memset\"\
  , C)) {\n    LenParamIdx = 2;\n    return true;\n  }\n\n  // sg_init_one(sg, buf,\
  \ buflen)\n  if (ExprHasName(Origin, \"sg_init_one\", C)) {\n    LenParamIdx = 2;\n\
  \    return true;\n  }\n\n  return false;\n}\n\n// Obtain the MemRegion corresponding\
  \ to an argument expression (try MemberExpr then DeclRefExpr).\nconst MemRegion\
  \ *SAGenTestChecker::argExprRegion(const CallEvent &Call, unsigned Idx, CheckerContext\
  \ &C) const {\n  if (Idx >= Call.getNumArgs())\n    return nullptr;\n\n  const Expr\
  \ *ArgE = Call.getArgExpr(Idx);\n  if (!ArgE)\n    return nullptr;\n\n  // Prefer\
  \ a MemberExpr inside the argument (typical for vi->rss_key_size).\n  if (const\
  \ MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(ArgE)) {\n    const MemRegion\
  \ *MR = getMemRegionFromExpr(ME, C);\n    if (MR)\n      return MR->getBaseRegion();\n\
  \  }\n\n  if (const DeclRefExpr *DRE = findSpecificTypeInChildren<DeclRefExpr>(ArgE))\
  \ {\n    const MemRegion *MR = getMemRegionFromExpr(DRE, C);\n    if (MR)\n    \
  \  return MR->getBaseRegion();\n  }\n\n  // As a last resort, try the raw expression\
  \ (may fail if rvalue).\n  const MemRegion *MR = getMemRegionFromExpr(ArgE, C);\n\
  \  if (MR)\n    return MR->getBaseRegion();\n\n  return nullptr;\n}\n\nvoid SAGenTestChecker::reportUncheckedLengthUse(const\
  \ Stmt *UseSite, CheckerContext &C, const MemRegion *R) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto Rpt = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Device-reported RSS key length is used without validating against\
  \ VIRTIO_NET_RSS_MAX_KEY_SIZE\",\n      N);\n  if (UseSite)\n    Rpt->addRange(UseSite->getSourceRange());\n\
  \  C.emitReport(std::move(Rpt));\n}\n\n// Post-call: track assignments from virtio_cread8(...\
  \ rss_max_key_size)\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  if (!isVirtioCread8RssKeySize(Call, C))\n    return;\n\
  \n  const MemRegion *Assigned = getAssignedRegionForCallResult(Call, C);\n  if (!Assigned)\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  State = State->set<RssKeySizeMap>(Assigned,\
  \ NeedsCheck);\n  C.addTransition(State);\n}\n\n// When encountering branch conditions,\
  \ mark the length as checked if compared to macro.\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  State = markRegionCheckedIfComparedToMax(Condition, C, State);\n  C.addTransition(State);\n\
  }\n\n// Pre-call: detect using the unvalidated length as the size argument in known\
  \ functions.\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  unsigned LenIdx = 0;\n  if (!isKnownLengthUse(Call, C, LenIdx))\n\
  \    return;\n\n  const MemRegion *LenReg = argExprRegion(Call, LenIdx, C);\n  if\
  \ (!LenReg)\n    return;\n\n  ProgramStateRef State = C.getState();\n  const unsigned\
  \ *Val = State->get<RssKeySizeMap>(LenReg);\n  if (!Val)\n    return;\n\n  if (*Val\
  \ == NeedsCheck) {\n    // Found a use of the length before validating against the\
  \ max.\n    reportUncheckedLengthUse(Call.getOriginExpr(), C, LenReg);\n  }\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects using device-reported RSS key length without checking against\
  \ VIRTIO_NET_RSS_MAX_KEY_SIZE\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nvirtio_net: Add hash_key_length check\n\nAdd hash_key_length\
  \ check in virtnet_probe() to avoid possible out of\nbound errors when setting/reading\
  \ the hash key.\n\nFixes: c7114b1249fa (\"drivers/net/virtio_net: Added basic RSS\
  \ support.\")\nSigned-off-by: Philo Lu <lulie@linux.alibaba.com>\nSigned-off-by:\
  \ Xuan Zhuo <xuanzhuo@linux.alibaba.com>\nAcked-by: Joe Damato <jdamato@fastly.com>\n\
  Acked-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: virtnet_probe in drivers/net/virtio_net.c\n\
  static int virtnet_probe(struct virtio_device *vdev)\n{\n\tint i, err = -ENOMEM;\n\
  \tstruct net_device *dev;\n\tstruct virtnet_info *vi;\n\tu16 max_queue_pairs;\n\t\
  int mtu = 0;\n\n\t/* Find if host supports multiqueue/rss virtio_net device */\n\
  \tmax_queue_pairs = 1;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MQ) || virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_RSS))\n\t\tmax_queue_pairs =\n\t\t     virtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config, max_virtqueue_pairs));\n\n\t/* We need at least 2 queue's */\n\
  \tif (max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||\n\t    max_queue_pairs\
  \ > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||\n\t    !virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\
  \t\tmax_queue_pairs = 1;\n\n\t/* Allocate ourselves a network device with room for\
  \ our info */\n\tdev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);\n\
  \tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* Set up network device as normal. */\n\t\
  dev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE |\n\t\t\t   IFF_TX_SKB_NO_LINEAR;\n\
  \tdev->netdev_ops = &virtnet_netdev;\n\tdev->stat_ops = &virtnet_stat_ops;\n\tdev->features\
  \ = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev,\
  \ &vdev->dev);\n\n\t/* Do we support \"hardware\" checksums? */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_CSUM)) {\n\t\t/* This opens up the world of extra features. */\n\t\
  \tdev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\t\tif (csum)\n\t\t\tdev->features\
  \ |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO))\
  \ {\n\t\t\tdev->hw_features |= NETIF_F_TSO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\
  \t\t}\n\t\t/* Individual feature bits: what can host handle? */\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_ECN))\n\t\t\tdev->hw_features |= NETIF_F_TSO_ECN;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_USO))\n\t\t\tdev->hw_features |= NETIF_F_GSO_UDP_L4;\n\n\t\t\
  dev->features |= NETIF_F_GSO_ROBUST;\n\n\t\tif (gso)\n\t\t\tdev->features |= dev->hw_features\
  \ & NETIF_F_ALL_TSO;\n\t\t/* (!csum && gso) case will be fixed by register_netdev()\
  \ */\n\t}\n\n\t/* 1. With VIRTIO_NET_F_GUEST_CSUM negotiation, the driver doesn't\n\
  \t * need to calculate checksums for partially checksummed packets,\n\t * as they're\
  \ considered valid by the upper layer.\n\t * 2. Without VIRTIO_NET_F_GUEST_CSUM\
  \ negotiation, the driver only\n\t * receives fully checksummed packets. The device\
  \ may assist in\n\t * validating these packets' checksums, so the driver won't have\
  \ to.\n\t */\n\tdev->features |= NETIF_F_RXCSUM;\n\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_GUEST_TSO4) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6))\n\
  \t\tdev->features |= NETIF_F_GRO_HW;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS))\n\
  \t\tdev->hw_features |= NETIF_F_GRO_HW;\n\n\tdev->vlan_features = dev->features;\n\
  \tdev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT;\n\n\t/* MTU\
  \ range: 68 - 65535 */\n\tdev->min_mtu = MIN_MTU;\n\tdev->max_mtu = MAX_MTU;\n\n\
  \t/* Configuration may specify what MAC to use.  Otherwise random. */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MAC)) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tvirtio_cread_bytes(vdev,\n\
  \t\t\t\t   offsetof(struct virtio_net_config, mac),\n\t\t\t\t   addr, ETH_ALEN);\n\
  \t\teth_hw_addr_set(dev, addr);\n\t} else {\n\t\teth_hw_addr_random(dev);\n\t\t\
  dev_info(&vdev->dev, \"Assigned random MAC address %pM\\n\",\n\t\t\t dev->dev_addr);\n\
  \t}\n\n\t/* Set up our device-specific information */\n\tvi = netdev_priv(dev);\n\
  \tvi->dev = dev;\n\tvi->vdev = vdev;\n\tvdev->priv = vi;\n\n\tINIT_WORK(&vi->config_work,\
  \ virtnet_config_changed_work);\n\tINIT_WORK(&vi->rx_mode_work, virtnet_rx_mode_work);\n\
  \tspin_lock_init(&vi->refill_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))\
  \ {\n\t\tvi->mergeable_rx_bufs = true;\n\t\tdev->xdp_features |= NETDEV_XDP_ACT_RX_SG;\n\
  \t}\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HASH_REPORT))\n\t\tvi->has_rss_hash_report\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_RSS)) {\n\t\tvi->has_rss\
  \ = true;\n\n\t\tvi->rss_indir_table_size =\n\t\t\tvirtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config,\n\t\t\t\trss_max_indirection_table_length));\n\t}\n\terr =\
  \ rss_indirection_table_alloc(&vi->rss, vi->rss_indir_table_size);\n\tif (err)\n\
  \t\tgoto free;\n\n\tif (vi->has_rss || vi->has_rss_hash_report) {\n\t\tvi->rss_key_size\
  \ =\n\t\t\tvirtio_cread8(vdev, offsetof(struct virtio_net_config, rss_max_key_size));\n\
  \n\t\tvi->rss_hash_types_supported =\n\t\t    virtio_cread32(vdev, offsetof(struct\
  \ virtio_net_config, supported_hash_types));\n\t\tvi->rss_hash_types_supported &=\n\
  \t\t\t\t~(VIRTIO_NET_RSS_HASH_TYPE_IP_EX |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_TCP_EX\
  \ |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_UDP_EX);\n\n\t\tdev->hw_features |= NETIF_F_RXHASH;\n\
  \t\tdev->xdp_metadata_ops = &virtnet_xdp_metadata_ops;\n\t}\n\n\tif (vi->has_rss_hash_report)\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_v1_hash);\n\telse if (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MRG_RXBUF) ||\n\t\t virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\telse\n\t\tvi->hdr_len\
  \ = sizeof(struct virtio_net_hdr);\n\n\tif (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT)\
  \ ||\n\t    virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\tvi->any_header_sg\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\t\tvi->has_cvq\
  \ = true;\n\n\tmutex_init(&vi->cvq_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MTU))\
  \ {\n\t\tmtu = virtio_cread16(vdev,\n\t\t\t\t     offsetof(struct virtio_net_config,\n\
  \t\t\t\t\t      mtu));\n\t\tif (mtu < dev->min_mtu) {\n\t\t\t/* Should never trigger:\
  \ MTU was previously validated\n\t\t\t * in virtnet_validate.\n\t\t\t */\n\t\t\t\
  dev_err(&vdev->dev,\n\t\t\t\t\"device MTU appears to have changed it is now %d <\
  \ %d\",\n\t\t\t\tmtu, dev->min_mtu);\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\
  \t}\n\n\t\tdev->mtu = mtu;\n\t\tdev->max_mtu = mtu;\n\t}\n\n\tvirtnet_set_big_packets(vi,\
  \ mtu);\n\n\tif (vi->any_header_sg)\n\t\tdev->needed_headroom = vi->hdr_len;\n\n\
  \t/* Enable multiqueue by default */\n\tif (num_online_cpus() >= max_queue_pairs)\n\
  \t\tvi->curr_queue_pairs = max_queue_pairs;\n\telse\n\t\tvi->curr_queue_pairs =\
  \ num_online_cpus();\n\tvi->max_queue_pairs = max_queue_pairs;\n\n\t/* Allocate/initialize\
  \ the rx/tx queues, and invoke find_vqs */\n\terr = init_vqs(vi);\n\tif (err)\n\t\
  \tgoto free;\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_NOTF_COAL)) {\n\t\
  \tvi->intr_coal_rx.max_usecs = 0;\n\t\tvi->intr_coal_tx.max_usecs = 0;\n\t\tvi->intr_coal_rx.max_packets\
  \ = 0;\n\n\t\t/* Keep the default values of the coalescing parameters\n\t\t * aligned\
  \ with the default napi_tx state.\n\t\t */\n\t\tif (vi->sq[0].napi.weight)\n\t\t\
  \tvi->intr_coal_tx.max_packets = 1;\n\t\telse\n\t\t\tvi->intr_coal_tx.max_packets\
  \ = 0;\n\t}\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_VQ_NOTF_COAL)) {\n\
  \t\t/* The reason is the same as VIRTIO_NET_F_NOTF_COAL. */\n\t\tfor (i = 0; i <\
  \ vi->max_queue_pairs; i++)\n\t\t\tif (vi->sq[i].napi.weight)\n\t\t\t\tvi->sq[i].intr_coal.max_packets\
  \ = 1;\n\n\t\terr = virtnet_init_irq_moder(vi);\n\t\tif (err)\n\t\t\tgoto free;\n\
  \t}\n\n#ifdef CONFIG_SYSFS\n\tif (vi->mergeable_rx_bufs)\n\t\tdev->sysfs_rx_queue_group\
  \ = &virtio_net_mrg_rx_group;\n#endif\n\tnetif_set_real_num_tx_queues(dev, vi->curr_queue_pairs);\n\
  \tnetif_set_real_num_rx_queues(dev, vi->curr_queue_pairs);\n\n\tvirtnet_init_settings(dev);\n\
  \n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_STANDBY)) {\n\t\tvi->failover = net_failover_create(vi->dev);\n\
  \t\tif (IS_ERR(vi->failover)) {\n\t\t\terr = PTR_ERR(vi->failover);\n\t\t\tgoto\
  \ free_vqs;\n\t\t}\n\t}\n\n\tif (vi->has_rss || vi->has_rss_hash_report)\n\t\tvirtnet_init_default_rss(vi);\n\
  \n\tenable_rx_mode_work(vi);\n\n\t/* serialize netdev register + virtio_device_ready()\
  \ with ndo_open() */\n\trtnl_lock();\n\n\terr = register_netdevice(dev);\n\tif (err)\
  \ {\n\t\tpr_debug(\"virtio_net: registering device failed\\n\");\n\t\trtnl_unlock();\n\
  \t\tgoto free_failover;\n\t}\n\n\t/* Disable config change notification until ndo_open.\
  \ */\n\tvirtio_config_driver_disable(vi->vdev);\n\n\tvirtio_device_ready(vdev);\n\
  \n\tvirtnet_set_queues(vi, vi->curr_queue_pairs);\n\n\t/* a random MAC address has\
  \ been assigned, notify the device.\n\t * We don't fail probe if VIRTIO_NET_F_CTRL_MAC_ADDR\
  \ is not there\n\t * because many devices work fine without getting MAC explicitly\n\
  \t */\n\tif (!virtio_has_feature(vdev, VIRTIO_NET_F_MAC) &&\n\t    virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_CTRL_MAC_ADDR)) {\n\t\tstruct scatterlist sg;\n\n\t\tsg_init_one(&sg,\
  \ dev->dev_addr, dev->addr_len);\n\t\tif (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MAC,\n\
  \t\t\t\t\t  VIRTIO_NET_CTRL_MAC_ADDR_SET, &sg)) {\n\t\t\tpr_debug(\"virtio_net:\
  \ setting MAC address failed\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr = -EINVAL;\n\
  \t\t\tgoto free_unregister_netdev;\n\t\t}\n\t}\n\n\tif (virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_DEVICE_STATS)) {\n\t\tstruct virtio_net_stats_capabilities *stats_cap\
  \  __free(kfree) = NULL;\n\t\tstruct scatterlist sg;\n\t\t__le64 v;\n\n\t\tstats_cap\
  \ = kzalloc(sizeof(*stats_cap), GFP_KERNEL);\n\t\tif (!stats_cap) {\n\t\t\trtnl_unlock();\n\
  \t\t\terr = -ENOMEM;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tsg_init_one(&sg,\
  \ stats_cap, sizeof(*stats_cap));\n\n\t\tif (!virtnet_send_command_reply(vi, VIRTIO_NET_CTRL_STATS,\n\
  \t\t\t\t\t\tVIRTIO_NET_CTRL_STATS_QUERY,\n\t\t\t\t\t\tNULL, &sg)) {\n\t\t\tpr_debug(\"\
  virtio_net: fail to get stats capability\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr\
  \ = -EINVAL;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tv = stats_cap->supported_stats_types[0];\n\
  \t\tvi->device_stats_cap = le64_to_cpu(v);\n\t}\n\n\t/* Assume link up if device\
  \ can't report link status,\n\t   otherwise get link status from config. */\n\t\
  netif_carrier_off(dev);\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS))\
  \ {\n\t\tvirtnet_config_changed_work(&vi->config_work);\n\t} else {\n\t\tvi->status\
  \ = VIRTIO_NET_S_LINK_UP;\n\t\tvirtnet_update_settings(vi);\n\t\tnetif_carrier_on(dev);\n\
  \t}\n\n\tfor (i = 0; i < ARRAY_SIZE(guest_offloads); i++)\n\t\tif (virtio_has_feature(vi->vdev,\
  \ guest_offloads[i]))\n\t\t\tset_bit(guest_offloads[i], &vi->guest_offloads);\n\t\
  vi->guest_offloads_capable = vi->guest_offloads;\n\n\trtnl_unlock();\n\n\terr =\
  \ virtnet_cpu_notif_add(vi);\n\tif (err) {\n\t\tpr_debug(\"virtio_net: registering\
  \ cpu notifier failed\\n\");\n\t\tgoto free_unregister_netdev;\n\t}\n\n\tpr_debug(\"\
  virtnet: registered device %s with %d RX and TX vq's\\n\",\n\t\t dev->name, max_queue_pairs);\n\
  \n\treturn 0;\n\nfree_unregister_netdev:\n\tunregister_netdev(dev);\nfree_failover:\n\
  \tnet_failover_destroy(vi->failover);\nfree_vqs:\n\tvirtio_reset_device(vdev);\n\
  \tcancel_delayed_work_sync(&vi->refill);\n\tfree_receive_page_frags(vi);\n\tvirtnet_del_vqs(vi);\n\
  free:\n\tfree_netdev(dev);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c\nindex 4b507007d242..545dda8ec077\
  \ 100644\n--- a/drivers/net/virtio_net.c\n+++ b/drivers/net/virtio_net.c\n@@ -6451,6\
  \ +6451,12 @@ static int virtnet_probe(struct virtio_device *vdev)\n \tif (vi->has_rss\
  \ || vi->has_rss_hash_report) {\n \t\tvi->rss_key_size =\n \t\t\tvirtio_cread8(vdev,\
  \ offsetof(struct virtio_net_config, rss_max_key_size));\n+\t\tif (vi->rss_key_size\
  \ > VIRTIO_NET_RSS_MAX_KEY_SIZE) {\n+\t\t\tdev_err(&vdev->dev, \"rss_max_key_size=%u\
  \ exceeds the limit %u.\\n\",\n+\t\t\t\tvi->rss_key_size, VIRTIO_NET_RSS_MAX_KEY_SIZE);\n\
  +\t\t\terr = -EINVAL;\n+\t\t\tgoto free;\n+\t\t}\n \n \t\tvi->rss_hash_types_supported\
  \ =\n \t\t    virtio_cread32(vdev, offsetof(struct virtio_net_config, supported_hash_types));\n\
  ```\n"
pattern: '## Bug Pattern


  Using a device-reported length (e.g., rss_max_key_size read from virtio_net_config)
  directly to size memory operations on a fixed-size buffer without validating it
  against the protocol-defined maximum. In this case, failing to check that vi->rss_key_size
  <= VIRTIO_NET_RSS_MAX_KEY_SIZE before using it to set/read the RSS hash key can
  cause out-of-bounds memory access.'
plan: "1) Program state\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(RssKeySizeMap, const MemRegion\
  \ *, unsigned)\n  - Value: 0 = NeedsCheck, 1 = Checked.\n  - Tracks integer variables/fields\
  \ that store rss_max_key_size read from the device and must be validated against\
  \ VIRTIO_NET_RSS_MAX_KEY_SIZE before use as a length.\n\nNo other custom traits/sets\
  \ are needed.\n\n\n2) Helper checks/utilities\n\n- isVirtioCread8RssKeySize(const\
  \ CallEvent &Call, CheckerContext &C)\n  - Return true if callee identifier is \"\
  virtio_cread8\" and one of its arguments contains the field name \"rss_max_key_size\"\
  .\n  - Implementation detail:\n    - Check Call.getCalleeIdentifier()->getName()\
  \ == \"virtio_cread8\".\n    - Inspect the offset argument expression (typically\
  \ the 2nd arg) with ExprHasName(Arg, \"rss_max_key_size\", C).\n\n- getAssignedRegionForCallResult(const\
  \ CallEvent &Call, CheckerContext &C)\n  - From the CallExpr, go up to the parent\
  \ BinaryOperator '=' using findSpecificTypeInParents<BinaryOperator>.\n  - If found,\
  \ get LHS expression and resolve its MemRegion via getMemRegionFromExpr.\n  - Return\
  \ the region (or null if not found).\n\n- markRegionCheckedIfComparedToMax(const\
  \ Stmt *Cond, CheckerContext &C)\n  - If condition compares a tracked variable to\
  \ the macro VIRTIO_NET_RSS_MAX_KEY_SIZE, mark it Checked regardless of comparison\
  \ direction.\n  - Implementation detail:\n    - Use findSpecificTypeInChildren<DeclRefExpr>(Cond)\
  \ to get the primary DRE; resolve its MemRegion; if it exists in RssKeySizeMap with\
  \ NeedsCheck\n    - Also ensure the condition source contains \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  \ via ExprHasName(CondExpr, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\", C).\n    - Update the\
  \ map entry to Checked.\n\n- isKnownLengthUse(const CallEvent &Call, unsigned &LenParamIdx)\n\
  \  - Return true if Call is one of the known routines that take a length parameter:\n\
  \    - \"memcpy\" (len index = 2)\n    - \"memmove\" (len index = 2)\n    - \"memset\"\
  \ (len index = 2)\n    - \"sg_init_one\" (len index = 2)\n  - Populate LenParamIdx\
  \ accordingly.\n\n- argExprRegion(const CallEvent &Call, unsigned Idx, CheckerContext\
  \ &C)\n  - Return the MemRegion if the argument at Idx reduces to a variable/field\
  \ region using getMemRegionFromExpr on the argument expression.\n\n- reportUncheckedLengthUse(const\
  \ Stmt *UseSite, CheckerContext &C, const MemRegion *R)\n  - Generate a non-fatal\
  \ error node and create a PathSensitiveBugReport with a short message:\n    - \"\
  Device-reported RSS key length is used without validating against VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  \n  - Attach the UseSite as the location.\n\n\n3) Callbacks and logic\n\n- checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C)\n  - Goal: identify assignments from virtio_cread8(...\
  \ rss_max_key_size) and mark the LHS region as NeedsCheck.\n  - Steps:\n    - If\
  \ !isVirtioCread8RssKeySize(Call, C) return.\n    - Find the assigned-to region\
  \ with getAssignedRegionForCallResult(Call, C).\n    - If region found, set RssKeySizeMap[region]\
  \ = NeedsCheck in the state and C.addTransition(newState).\n\n- checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C)\n  - Goal: mark the tracked variable as Checked\
  \ when it is compared with VIRTIO_NET_RSS_MAX_KEY_SIZE.\n  - Steps:\n    - If ExprHasName(cast<Expr>(Condition),\
  \ \"VIRTIO_NET_RSS_MAX_KEY_SIZE\", C) is false, return.\n    - Try to resolve the\
  \ variable used in the condition:\n      - Use findSpecificTypeInChildren<DeclRefExpr>(Condition)\
  \ to get a DRE (common case).\n      - If a DRE is found, get its MemRegion.\n \
  \     - If region exists in RssKeySizeMap with NeedsCheck, update to Checked and\
  \ transition.\n    - Note: Do not attempt to reason about branch direction; any\
  \ explicit comparison is accepted as a guard.\n\n- checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C)\n  - Goal: detect dangerous use of the unvalidated length\
  \ as a size argument.\n  - Steps:\n    - unsigned LenIdx; if (!isKnownLengthUse(Call,\
  \ LenIdx)) return.\n    - const Expr *LenArgE = Call.getArgExpr(LenIdx).\n    -\
  \ Resolve the region: const MemRegion *R = getMemRegionFromExpr(LenArgE, C).\n \
  \     - If R is null, also try the common case of MemberExpr/DeclRefExpr via IgnoreImplicit/IgnoreParenCasts\
  \ and re-run getMemRegionFromExpr.\n    - If R is in RssKeySizeMap with value NeedsCheck:\n\
  \      - Report via reportUncheckedLengthUse(Call.getOriginExpr(), C, R).\n    \
  \  - Do not transition the state to Checked; the warning is path-sensitive at the\
  \ first use without prior guard.\n\n- Optional: checkEndFunction(const ReturnStmt\
  \ *RS, CheckerContext &C)\n  - No specific action needed. The map will be discarded\
  \ with the function context.\n\n\n4) Notes and constraints\n\n- This checker is\
  \ intentionally narrow:\n  - It only tracks rss_max_key_size read through virtio_cread8\
  \ with an offsetof() argument containing the field name \"rss_max_key_size\".\n\
  \  - It requires that the length be assigned to a variable/field (e.g., vi->rss_key_size\
  \ = virtio_cread8(...)).\n  - It considers any comparison with the macro \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  \ as a valid check (regardless of direction) to keep the implementation simple and\
  \ robust to style variations.\n\n- It will warn on calls where the unvalidated variable\
  \ is used as the length parameter of common memory/sg helpers (memcpy, memmove,\
  \ memset, sg_init_one). This models the \u201Cset/read hash key\u201D pattern where\
  \ the device-provided length sizes an operation on a fixed-size buffer.\n\n- Utilities\
  \ used:\n  - findSpecificTypeInParents to get the assignment LHS.\n  - getMemRegionFromExpr\
  \ to resolve tracked variables/fields.\n  - ExprHasName to detect both the offsetof\
  \ field \"rss_max_key_size\" and the max macro \"VIRTIO_NET_RSS_MAX_KEY_SIZE\" in\
  \ conditions."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state: track variables/fields that hold rss_max_key_size and need validation.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(RssKeySizeMap, const MemRegion *, unsigned)\n\nnamespace\
  \ {\n\nenum RssKeyCheckState : unsigned {\n  NeedsCheck = 0,\n  Checked = 1\n};\n\
  \nclass SAGenTestChecker\n  : public Checker<\n      check::PostCall,        //\
  \ track virtio_cread8(... rss_max_key_size)\n      check::PreCall,         // detect\
  \ uses as length in memcpy/memmove/memset/sg_init_one\n      check::BranchCondition\
  \  // mark checked when compared against VIRTIO_NET_RSS_MAX_KEY_SIZE\n    > {\n\
  \   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(std::make_unique<BugType>(this, \"Unchecked device-reported RSS key length\"\
  , \"API Misuse\")) {}\n\n      void checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n      void checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const;\n      void checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const;\n\n   private:\n      // Helpers\n      bool isVirtioCread8RssKeySize(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      const MemRegion *getAssignedRegionForCallResult(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      ProgramStateRef markRegionCheckedIfComparedToMax(const\
  \ Stmt *Cond, CheckerContext &C, ProgramStateRef State) const;\n      bool isKnownLengthUse(const\
  \ CallEvent &Call, CheckerContext &C, unsigned &LenParamIdx) const;\n      const\
  \ MemRegion *argExprRegion(const CallEvent &Call, unsigned Idx, CheckerContext &C)\
  \ const;\n      void reportUncheckedLengthUse(const Stmt *UseSite, CheckerContext\
  \ &C, const MemRegion *R) const;\n};\n\n// Determine if this call is virtio_cread8(...)\
  \ where an argument mentions rss_max_key_size.\nbool SAGenTestChecker::isVirtioCread8RssKeySize(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Use source-text matching for callee name\
  \ as suggested.\n  if (!ExprHasName(Origin, \"virtio_cread8\", C))\n    return false;\n\
  \n  // Look for \"rss_max_key_size\" in any argument's source.\n  for (unsigned\
  \ i = 0; i < Call.getNumArgs(); ++i) {\n    if (const Expr *AE = Call.getArgExpr(i))\
  \ {\n      if (ExprHasName(AE, \"rss_max_key_size\", C))\n        return true;\n\
  \    }\n  }\n  return false;\n}\n\n// From the virtio_cread8(...) call, find the\
  \ assignment LHS region that receives the result.\nconst MemRegion *SAGenTestChecker::getAssignedRegionForCallResult(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return nullptr;\n  const auto *CE = dyn_cast<CallExpr>(Origin);\n\
  \  if (!CE)\n    return nullptr;\n\n  // Ascend to parent BinaryOperator '='\n \
  \ const BinaryOperator *BO = findSpecificTypeInParents<BinaryOperator>(CE, C);\n\
  \  if (!BO || !BO->isAssignmentOp())\n    return nullptr;\n\n  const Expr *LHS =\
  \ BO->getLHS();\n  if (!LHS)\n    return nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(LHS,\
  \ C);\n  if (!MR)\n    return nullptr;\n  MR = MR->getBaseRegion();\n  return MR;\n\
  }\n\n// If a branch condition compares the tracked variable to VIRTIO_NET_RSS_MAX_KEY_SIZE,\
  \ mark it checked.\nProgramStateRef SAGenTestChecker::markRegionCheckedIfComparedToMax(const\
  \ Stmt *Cond, CheckerContext &C, ProgramStateRef State) const {\n  const Expr *CondE\
  \ = dyn_cast_or_null<Expr>(Cond);\n  if (!CondE)\n    return State;\n\n  // Ensure\
  \ the macro appears in the condition.\n  if (!ExprHasName(CondE, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C))\n    return State;\n\n  // Try to find a MemberExpr (e.g., vi->rss_key_size)\
  \ first.\n  const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(Cond);\n\
  \  const Expr *TargetExpr = nullptr;\n  if (ME) {\n    TargetExpr = ME;\n  } else\
  \ {\n    // Fallback: find a DeclRefExpr (e.g., local variable holding the size)\n\
  \    const DeclRefExpr *DRE = findSpecificTypeInChildren<DeclRefExpr>(Cond);\n \
  \   if (DRE)\n      TargetExpr = DRE;\n  }\n\n  if (!TargetExpr)\n    return State;\n\
  \n  const MemRegion *MR = getMemRegionFromExpr(TargetExpr, C);\n  if (!MR)\n   \
  \ return State;\n  MR = MR->getBaseRegion();\n\n  const unsigned *Val = State->get<RssKeySizeMap>(MR);\n\
  \  if (Val && *Val == NeedsCheck) {\n    State = State->set<RssKeySizeMap>(MR, Checked);\n\
  \  }\n  return State;\n}\n\n// Recognize common functions where a length parameter\
  \ is used.\nbool SAGenTestChecker::isKnownLengthUse(const CallEvent &Call, CheckerContext\
  \ &C, unsigned &LenParamIdx) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // memcpy/memmove/memset have length as\
  \ the 3rd argument (index 2).\n  if (ExprHasName(Origin, \"memcpy\", C) ||\n   \
  \   ExprHasName(Origin, \"memmove\", C) ||\n      ExprHasName(Origin, \"memset\"\
  , C)) {\n    LenParamIdx = 2;\n    return true;\n  }\n\n  // sg_init_one(sg, buf,\
  \ buflen)\n  if (ExprHasName(Origin, \"sg_init_one\", C)) {\n    LenParamIdx = 2;\n\
  \    return true;\n  }\n\n  return false;\n}\n\n// Obtain the MemRegion corresponding\
  \ to an argument expression (try MemberExpr then DeclRefExpr).\nconst MemRegion\
  \ *SAGenTestChecker::argExprRegion(const CallEvent &Call, unsigned Idx, CheckerContext\
  \ &C) const {\n  if (Idx >= Call.getNumArgs())\n    return nullptr;\n\n  const Expr\
  \ *ArgE = Call.getArgExpr(Idx);\n  if (!ArgE)\n    return nullptr;\n\n  // Prefer\
  \ a MemberExpr inside the argument (typical for vi->rss_key_size).\n  if (const\
  \ MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(ArgE)) {\n    const MemRegion\
  \ *MR = getMemRegionFromExpr(ME, C);\n    if (MR)\n      return MR->getBaseRegion();\n\
  \  }\n\n  if (const DeclRefExpr *DRE = findSpecificTypeInChildren<DeclRefExpr>(ArgE))\
  \ {\n    const MemRegion *MR = getMemRegionFromExpr(DRE, C);\n    if (MR)\n    \
  \  return MR->getBaseRegion();\n  }\n\n  // As a last resort, try the raw expression\
  \ (may fail if rvalue).\n  const MemRegion *MR = getMemRegionFromExpr(ArgE, C);\n\
  \  if (MR)\n    return MR->getBaseRegion();\n\n  return nullptr;\n}\n\nvoid SAGenTestChecker::reportUncheckedLengthUse(const\
  \ Stmt *UseSite, CheckerContext &C, const MemRegion *R) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto Rpt = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Device-reported RSS key length is used without validating against\
  \ VIRTIO_NET_RSS_MAX_KEY_SIZE\",\n      N);\n  if (UseSite)\n    Rpt->addRange(UseSite->getSourceRange());\n\
  \  C.emitReport(std::move(Rpt));\n}\n\n// Post-call: track assignments from virtio_cread8(...\
  \ rss_max_key_size)\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  if (!isVirtioCread8RssKeySize(Call, C))\n    return;\n\
  \n  const MemRegion *Assigned = getAssignedRegionForCallResult(Call, C);\n  if (!Assigned)\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  State = State->set<RssKeySizeMap>(Assigned,\
  \ NeedsCheck);\n  C.addTransition(State);\n}\n\n// When encountering branch conditions,\
  \ mark the length as checked if compared to macro.\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  State = markRegionCheckedIfComparedToMax(Condition, C, State);\n  C.addTransition(State);\n\
  }\n\n// Pre-call: detect using the unvalidated length as the size argument in known\
  \ functions.\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  unsigned LenIdx = 0;\n  if (!isKnownLengthUse(Call, C, LenIdx))\n\
  \    return;\n\n  const MemRegion *LenReg = argExprRegion(Call, LenIdx, C);\n  if\
  \ (!LenReg)\n    return;\n\n  ProgramStateRef State = C.getState();\n  const unsigned\
  \ *Val = State->get<RssKeySizeMap>(LenReg);\n  if (!Val)\n    return;\n\n  if (*Val\
  \ == NeedsCheck) {\n    // Found a use of the length before validating against the\
  \ max.\n    reportUncheckedLengthUse(Call.getOriginExpr(), C, LenReg);\n  }\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects using device-reported RSS key length without checking against\
  \ VIRTIO_NET_RSS_MAX_KEY_SIZE\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
