_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: ec1aae190c7729ffdd3603de311dc00f7ff988f9
commit_type: Misuse
index: 6
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state: set of object base regions whose __counted_by counter\n// has been\
  \ initialized (written on this path).\nREGISTER_SET_WITH_PROGRAMSTATE(InitCounterSet,\
  \ const MemRegion*)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::Bind,\n        check::PreCall,\n        check::Location> {\n\n \
  \ mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n      :\
  \ BT(std::make_unique<BugType>(this,\n                                     \"Write\
  \ to flexible array before counter init\",\n                                   \
  \  \"Memory Error\")) {}\n\n  void checkBind(SVal Loc, SVal Val, const Stmt *S,\
  \ CheckerContext &C) const;\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  void checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext\
  \ &C) const;\n\nprivate:\n  // Helpers\n  static const FieldRegion *findEnclosingFieldRegion(const\
  \ MemRegion *R);\n  static bool isCountedByFlexibleArrayField(const FieldDecl *FD);\n\
  \  static bool isFieldCounterForAnyCountedByInRecord(const FieldDecl *F);\n  static\
  \ bool isMemcpyLike(const CallEvent &Call, CheckerContext &C);\n  static bool isZeroLengthCopy(const\
  \ CallEvent &Call, unsigned LenIdx, CheckerContext &C);\n  void reportWriteBeforeCounterInit(const\
  \ Stmt *S, CheckerContext &C) const;\n};\n\n// Ascend the region chain to find the\
  \ FieldRegion that encloses R (if any).\nconst FieldRegion *SAGenTestChecker::findEnclosingFieldRegion(const\
  \ MemRegion *R) {\n  if (!R) return nullptr;\n  const MemRegion *Cur = R;\n  while\
  \ (Cur) {\n    if (const auto *FR = dyn_cast<FieldRegion>(Cur))\n      return FR;\n\
  \    Cur = Cur->getSuperRegion();\n  }\n  return nullptr;\n}\n\n// Returns true\
  \ if FD is a flexible-array field annotated with counted_by.\nbool SAGenTestChecker::isCountedByFlexibleArrayField(const\
  \ FieldDecl *FD) {\n  if (!FD) return false;\n  const CountedByAttr *CBA = FD->getAttr<CountedByAttr>();\n\
  \  if (!CBA) return false;\n\n  QualType QT = FD->getType();\n  const Type *Ty =\
  \ QT.getTypePtrOrNull();\n  if (!Ty) return false;\n\n  // Flexible array members\
  \ in C are represented as IncompleteArrayType.\n  if (isa<IncompleteArrayType>(Ty))\n\
  \    return true;\n\n  return false;\n}\n\n// Returns true if field F is the counter\
  \ referenced by any counted_by flexible array\n// field in the same record.\nbool\
  \ SAGenTestChecker::isFieldCounterForAnyCountedByInRecord(const FieldDecl *F) {\n\
  \  if (!F) return false;\n  const RecordDecl *RD = dyn_cast<RecordDecl>(F->getParent());\n\
  \  if (!RD) return false;\n\n  for (const FieldDecl *FD : RD->fields()) {\n    if\
  \ (!FD) continue;\n    // Only consider flexible-array fields with counted_by\n\
  \    if (!isCountedByFlexibleArrayField(FD))\n      continue;\n\n    if (const auto\
  \ *CBA = FD->getAttr<CountedByAttr>()) {\n#if 1\n      // Preferred: attribute should\
  \ carry a resolved FieldDecl.\n      if (const FieldDecl *CounterFD = CBA->getCountedByField())\
  \ {\n        if (CounterFD == F)\n          return true;\n      }\n#else\n     \
  \ // Fallback (if API differs): compare by name if resolved decl is not available.\n\
  \      // This block is disabled by default; the above should work on Clang 18.\n\
  \      if (const IdentifierInfo *IID = F->getIdentifier()) {\n        // If the\
  \ attribute provides an expression/name accessor, compare text.\n        // Not\
  \ used in default build.\n      }\n#endif\n    }\n  }\n  return false;\n}\n\nbool\
  \ SAGenTestChecker::isMemcpyLike(const CallEvent &Call, CheckerContext &C) {\n \
  \ const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr) return false;\n\
  \n  // We focus on memcpy and memmove (dest, src, len).\n  if (ExprHasName(OriginExpr,\
  \ \"memcpy\", C)) return true;\n  if (ExprHasName(OriginExpr, \"memmove\", C)) return\
  \ true;\n  // Optionally, memset (dest, val, len) could also write, but not needed\
  \ for the target bug.\n  // if (ExprHasName(OriginExpr, \"memset\", C)) return true;\n\
  \n  return false;\n}\n\nbool SAGenTestChecker::isZeroLengthCopy(const CallEvent\
  \ &Call, unsigned LenIdx, CheckerContext &C) {\n  if (Call.getNumArgs() <= LenIdx)\
  \ return false;\n  const Expr *LenE = Call.getArgExpr(LenIdx);\n  if (!LenE) return\
  \ false;\n  llvm::APSInt Val;\n  if (EvaluateExprToInt(Val, LenE, C)) {\n    return\
  \ Val == 0;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::reportWriteBeforeCounterInit(const\
  \ Stmt *S, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n   \
  \   *BT, \"write to flexible array before updating its __counted_by counter\", N);\n\
  \  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// Mark the object as having its counter initialized when we see a write to\
  \ the counter field.\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const {\n  const MemRegion *LocReg = Loc.getAsRegion();\n\
  \  if (!LocReg) return;\n\n  // We need the field being written.\n  const FieldRegion\
  \ *FR = dyn_cast<FieldRegion>(LocReg);\n  if (!FR) return;\n\n  const FieldDecl\
  \ *WrittenFD = FR->getDecl();\n  if (!WrittenFD) return;\n\n  // Is this field a\
  \ counter for any counted_by flexible-array in the same record?\n  if (!isFieldCounterForAnyCountedByInRecord(WrittenFD))\n\
  \    return;\n\n  // Identify the base object region of the containing object instance.\n\
  \  const MemRegion *ObjReg = FR->getSuperRegion();\n  if (!ObjReg) return;\n  ObjReg\
  \ = ObjReg->getBaseRegion();\n  if (!ObjReg) return;\n\n  ProgramStateRef State\
  \ = C.getState();\n  State = State->add<InitCounterSet>(ObjReg);\n  C.addTransition(State);\n\
  }\n\n// Detect memcpy/memmove writing into a flexible-array member before its counter\
  \ is initialized.\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  if (!isMemcpyLike(Call, C))\n    return;\n\n  // Destination is\
  \ argument 0 for memcpy/memmove.\n  if (Call.getNumArgs() < 1)\n    return;\n\n\
  \  const Expr *DstE = Call.getArgExpr(0);\n  if (!DstE) return;\n\n  const MemRegion\
  \ *DstReg = getMemRegionFromExpr(DstE, C);\n  if (!DstReg) return;\n\n  // Keep\
  \ original region for climbing; also respect guideline to get base region.\n  const\
  \ FieldRegion *DstFR = findEnclosingFieldRegion(DstReg);\n  if (!DstFR) return;\n\
  \n  const FieldDecl *DstFD = DstFR->getDecl();\n  if (!DstFD) return;\n\n  // Only\
  \ care if destination is a counted_by flexible-array field.\n  if (!isCountedByFlexibleArrayField(DstFD))\n\
  \    return;\n\n  // If length is provably zero, skip warning.\n  // memcpy/memmove\
  \ length is arg index 2.\n  if (isZeroLengthCopy(Call, 2u, C))\n    return;\n\n\
  \  // Check whether the counter of this object has been initialized on this path.\n\
  \  const MemRegion *ObjReg = DstFR->getSuperRegion();\n  if (!ObjReg) return;\n\
  \  ObjReg = ObjReg->getBaseRegion();\n  if (!ObjReg) return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  if (!State->contains<InitCounterSet>(ObjReg)) {\n   \
  \ // Counter not yet initialized: report.\n    reportWriteBeforeCounterInit(Call.getOriginExpr(),\
  \ C);\n  }\n}\n\n// Catch direct stores into the flexible-array region (e.g., event->data[i]\
  \ = ...)\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt\
  \ *S, CheckerContext &C) const {\n  if (IsLoad) return; // Only interested in writes\n\
  \n  const MemRegion *R = Loc.getAsRegion();\n  if (!R) return;\n\n  const FieldRegion\
  \ *FR = findEnclosingFieldRegion(R);\n  if (!FR) return;\n\n  const FieldDecl *FD\
  \ = FR->getDecl();\n  if (!FD) return;\n\n  if (!isCountedByFlexibleArrayField(FD))\n\
  \    return;\n\n  const MemRegion *ObjReg = FR->getSuperRegion();\n  if (!ObjReg)\
  \ return;\n  ObjReg = ObjReg->getBaseRegion();\n  if (!ObjReg) return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  if (!State->contains<InitCounterSet>(ObjReg)) {\n   \
  \ reportWriteBeforeCounterInit(S, C);\n  }\n}\n\n} // end anonymous namespace\n\n\
  extern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect writes to flexible-array members\
  \ before initializing their __counted_by counters\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nwifi: brcmfmac: fweh: Fix boot crash on Raspberry\
  \ Pi 4\n\nFix boot crash on Raspberry Pi by moving the update to `event->datalen`\n\
  before data is copied into flexible-array member `data` via `memcpy()`.\n\nFlexible-array\
  \ member `data` was annotated with `__counted_by(datalen)`\nin commit 62d19b358088\
  \ (\"wifi: brcmfmac: fweh: Add __counted_by for\nstruct brcmf_fweh_queue_item and\
  \ use struct_size()\"). The intention of\nthis is to gain visibility into the size\
  \ of `data` at run-time through\nits _counter_ (in this case `datalen`), and with\
  \ this have its accesses\nbounds-checked at run-time via CONFIG_FORTIFY_SOURCE and\n\
  CONFIG_UBSAN_BOUNDS.\n\nTo effectively accomplish the above, we shall update the\
  \ counter\n(`datalen`), before the first access to the flexible array (`data`),\n\
  which was also done in the mentioned commit.\n\nHowever, commit edec42821911 (\"\
  wifi: brcmfmac: allow per-vendor event\nhandling\") inadvertently caused a buffer\
  \ overflow, detected by\nFORTIFY_SOURCE. It moved the `event->datalen = datalen;`\
  \ update to after\nthe first `data` access, at which point `event->datalen` was\
  \ not yet\nupdated from zero (after calling `kzalloc()`), leading to the overflow\n\
  issue.\n\nThis fix repositions the `event->datalen = datalen;` update before\naccessing\
  \ `data`, restoring the intended buffer overflow protection. :)\n\nFixes: edec42821911\
  \ (\"wifi: brcmfmac: allow per-vendor event handling\")\nReported-by: Nathan Chancellor\
  \ <nathan@kernel.org>\nCloses: https://gist.github.com/nathanchance/e22f681f3bfc467f15cdf6605021aaa6\n\
  Tested-by: Nathan Chancellor <nathan@kernel.org>\nSigned-off-by: Gustavo A. R. Silva\
  \ <gustavoars@kernel.org>\nReviewed-by: Kees Cook <keescook@chromium.org>\nAcked-by:\
  \ Arend van Spriel <arend.vanspriel@broadcom.com>\nSigned-off-by: Kalle Valo <kvalo@kernel.org>\n\
  Link: https://msgid.link/Zc+3PFCUvLoVlpg8@neat\n\n## Buggy Code\n\n```c\n// Function:\
  \ brcmf_fweh_process_event in drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c\n\
  void brcmf_fweh_process_event(struct brcmf_pub *drvr,\n\t\t\t      struct brcmf_event\
  \ *event_packet,\n\t\t\t      u32 packet_len, gfp_t gfp)\n{\n\tu32 fwevt_idx;\n\t\
  struct brcmf_fweh_info *fweh = drvr->fweh;\n\tstruct brcmf_fweh_queue_item *event;\n\
  \tvoid *data;\n\tu32 datalen;\n\n\t/* get event info */\n\tfwevt_idx = get_unaligned_be32(&event_packet->msg.event_type);\n\
  \tdatalen = get_unaligned_be32(&event_packet->msg.datalen);\n\tdata = &event_packet[1];\n\
  \n\tif (fwevt_idx >= fweh->num_event_codes)\n\t\treturn;\n\n\tif (fwevt_idx != BRCMF_E_IF\
  \ && !fweh->evt_handler[fwevt_idx])\n\t\treturn;\n\n\tif (datalen > BRCMF_DCMD_MAXLEN\
  \ ||\n\t    datalen + sizeof(*event_packet) > packet_len)\n\t\treturn;\n\n\tevent\
  \ = kzalloc(struct_size(event, data, datalen), gfp);\n\tif (!event)\n\t\treturn;\n\
  \n\tevent->code = fwevt_idx;\n\tevent->ifidx = event_packet->msg.ifidx;\n\n\t/*\
  \ use memcpy to get aligned event message */\n\tmemcpy(&event->emsg, &event_packet->msg,\
  \ sizeof(event->emsg));\n\tmemcpy(event->data, data, datalen);\n\tevent->datalen\
  \ = datalen;\n\tmemcpy(event->ifaddr, event_packet->eth.h_dest, ETH_ALEN);\n\n\t\
  brcmf_fweh_queue_event(fweh, event);\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff\
  \ --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c\n\
  index 0774f6c59226..f0b6a7607f16 100644\n--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c\n\
  +++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c\n@@ -497,12 +497,12\
  \ @@ void brcmf_fweh_process_event(struct brcmf_pub *drvr,\n \t\treturn;\n \n \t\
  event->code = fwevt_idx;\n+\tevent->datalen = datalen;\n \tevent->ifidx = event_packet->msg.ifidx;\n\
  \ \n \t/* use memcpy to get aligned event message */\n \tmemcpy(&event->emsg, &event_packet->msg,\
  \ sizeof(event->emsg));\n \tmemcpy(event->data, data, datalen);\n-\tevent->datalen\
  \ = datalen;\n \tmemcpy(event->ifaddr, event_packet->eth.h_dest, ETH_ALEN);\n \n\
  \ \tbrcmf_fweh_queue_event(fweh, event);\n```\n"
pattern: "## Bug Pattern\n\nWriting to a flexible-array member annotated with __counted_by(len)\
  \ before initializing its length counter.\n\nExample:\n- Struct has: size_t datalen;\
  \ u8 data[] __counted_by(datalen);\n- Memory is kzalloc\u2019d (datalen == 0).\n\
  - Code does memcpy(event->data, src, datalen) before setting event->datalen = datalen.\n\
  \nBecause FORTIFY/UBSAN uses the counter to bound-check the flexible array, accessing\
  \ data before setting datalen (still zero) triggers a bounds violation or crash.\
  \ The counter must be set before any access to the flexible array."
plan: "Plan\n\n1. Program state\n- REGISTER_SET_WITH_PROGRAMSTATE(InitCounterSet,\
  \ const MemRegion*)\n  - Purpose: track, per object instance, that its __counted_by\
  \ counter field has been initialized (i.e., we observed an assignment to the counter\
  \ field on this path).\n  - Key choice: use the base object region (the struct/object\
  \ that contains the flexible array and its counter). This allows us to later match\
  \ writes to the flexible-array field back to whether its counter was initialized\
  \ for that specific object.\n\n2. Callbacks and logic\n\n2.1 checkBind (mark counter\
  \ as initialized)\n- Goal: when code assigns to a field that acts as a __counted_by\
  \ counter, record that the object\u2019s counter has been initialized.\n- Steps:\n\
  \  - This callback provides Loc (the lvalue being written to). If Loc is a loc::MemRegionVal\
  \ whose region is a FieldRegion FR, proceed.\n  - Let F = FR->getDecl() (FieldDecl\
  \ of the written field).\n  - Determine if F is a counter for any flexible-array\
  \ field in the same record:\n    - Get the parent record: const RecordDecl *RD =\
  \ dyn_cast<RecordDecl>(F->getParent()).\n    - Iterate RD->fields():\n      - For\
  \ each FieldDecl FD in RD, check if FD has CountedByAttr (FD->hasAttr<CountedByAttr>()).\n\
  \      - If yes, check if that attribute names/targets exactly the current field\
  \ F as the counter (via the attr API, e.g., FD->getAttr<CountedByAttr>()->getCountedByField()\
  \ == F; if the API differs, use available methods to resolve and compare the referenced\
  \ field).\n      - If any flexible-array field FD is counted_by F, then this store\
  \ is initializing the counter for this object type.\n    - If not matched, return.\n\
  \  - If matched:\n    - Get the base object region: const MemRegion *BaseObj = FR->getSuperRegion().\n\
  \    - Update state: add BaseObj to InitCounterSet.\n  - Notes:\n    - Only mark\
  \ initialization; no need to track the assigned numeric value for this checker (keeping\
  \ it simple).\n    - This will correctly handle event->datalen = ... by marking\
  \ the region for \u2018event\u2019 as initialized.\n\n2.2 checkPreCall (detect writes\
  \ to flexible arrays before counter init)\n- Goal: catch calls like memcpy/memmove/memset/str*\
  \ that write into a flexible-array member with __counted_by before its counter is\
  \ initialized.\n- Target functions:\n  - Start minimal: \"memcpy\" and \"memmove\"\
  . Optionally include \"memset\", \"strscpy\", \"strlcpy\", \"copy_from_user\" if\
  \ desired later.\n- Steps:\n  - Identify callee name using Call.getCalleeIdentifier()->getName().\n\
  \  - If not in the target set, return.\n  - Obtain the destination expression index:\n\
  \    - memcpy/memmove: arg 0 is destination.\n    - memset: arg 0 is destination\
  \ (only include if you decide to support memset).\n    - For strscpy/strlcpy: arg\
  \ 0 is destination (optional).\n  - Let const Expr *DstE = Call.getArgExpr(0)->IgnoreParenCasts().\n\
  \  - Resolve its region: const MemRegion *R = getMemRegionFromExpr(DstE, C).\n \
  \ - If R is null, return.\n  - Climb region layers to find the flexible-array FieldRegion:\n\
  \    - If R is an ElementRegion, replace R with its super region until not an ElementRegion.\n\
  \    - Now if R is a FieldRegion FR, proceed; else return.\n  - Confirm that the\
  \ field is a flexible-array member with __counted_by:\n    - const FieldDecl *FD\
  \ = FR->getDecl().\n    - Ensure FD->hasAttr<CountedByAttr>(). If not, return.\n\
  \    - Also ensure that FD\u2019s type is an incomplete array type (flexible array)\
  \ or otherwise clearly a counted_by flexible-array field. If needed, check dyn_cast<IncompleteArrayType>(FD->getType().getTypePtr()).\n\
  \  - Extract the base object region: const MemRegion *BaseObj = FR->getSuperRegion().\n\
  \  - Check initialization:\n    - If BaseObj is not in InitCounterSet, this indicates\
  \ a write into the flexible array before its counter was initialized. Report a bug.\n\
  \    - Small suppression: if the call has a length argument that can be proven to\
  \ be zero, skip reporting. For memcpy/memmove, this is arg 2. Use EvaluateExprToInt\
  \ on that argument and skip if the value is known zero.\n  - Reporting:\n    - Use\
  \ generateNonFatalErrorNode and emit a PathSensitiveBugReport with a short message\
  \ like:\n      \"write to flexible array before updating its __counted_by counter\"\
  \n    - Attach the call expression as the report location.\n\n2.3 checkLocation\
  \ (catch direct stores into the flexible array)\n- Goal: detect non-function-call\
  \ writes like event->data[i] = ... or *(event->data) = ...\n- Steps:\n  - Only act\
  \ when IsLoad == false (store).\n  - If Loc is a loc::MemRegionVal, get region R.\n\
  \  - Climb ElementRegion layers to its super region until we reach FieldRegion FR\
  \ or fail.\n  - If FR is null, return.\n  - Check FR->getDecl() for CountedByAttr\
  \ and flexible array type (as above).\n  - Get BaseObj = FR->getSuperRegion().\n\
  \  - If BaseObj not in InitCounterSet, report as in checkPreCall with the same short\
  \ message.\n  - This complements checkPreCall and catches array-subscripting or\
  \ pointer-deref writes.\n\n3. Optional refinements (safe to skip initially)\n- Length\
  \ consistency: If you want stricter checking, record the numeric value assigned\
  \ to the counter field (when EvaluateExprToInt on the RHS of the assignment in checkBind\
  \ succeeds), using a second map:\n  - REGISTER_MAP_WITH_PROGRAMSTATE(CounterValueMap,\
  \ const MemRegion*, llvm::APSInt)\n  - Then in checkPreCall, evaluate the copy size\
  \ and warn if it exceeds the recorded counter value. This is not strictly required\
  \ to catch the target pattern and can be added later.\n- Aliasing: If pointers to\
  \ the same object alias, assignments through either pointer should count. CSA region\
  \ modeling often provides the same super region for the object, but for robustness\
  \ you could add:\n  - REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*,\
  \ const MemRegion*)\n  - In checkBind, on pointer-to-pointer assignments (p2 = p1),\
  \ relate their regions. When marking or querying InitCounterSet, resolve through\
  \ aliases. This is optional and can be deferred to keep the checker simple.\n\n\
  4. Utility function usage\n- getMemRegionFromExpr: used to resolve MemRegions for\
  \ expressions.\n- EvaluateExprToInt: used to detect known-zero lengths to suppress\
  \ benign memcpy/memmove(\u2026, 0).\n- findSpecificTypeInParents / findSpecificTypeInChildren:\
  \ not strictly necessary in this plan.\n- ExprHasName: not necessary here.\n- functionKnownToDeref:\
  \ not necessary here.\n\n5. Summary of minimal implementation steps\n- State: InitCounterSet\
  \ to track objects whose counted_by counter got initialized.\n- checkBind: when\
  \ storing to a FieldRegion F, if F is the counter referenced by any CountedByAttr\
  \ flexible-array field in its record, add FR->getSuperRegion() to InitCounterSet.\n\
  - checkPreCall: for memcpy/memmove, if dest refers to a flexible-array FieldRegion\
  \ with CountedByAttr, and its BaseObj is not in InitCounterSet (and length != 0\
  \ if known), report.\n- checkLocation: on stores, if target region belongs to a\
  \ flexible-array FieldRegion with CountedByAttr and BaseObj not in InitCounterSet,\
  \ report.\n\n6. Bug report\n- Use std::make_unique<PathSensitiveBugReport>.\n- Message:\
  \ \"write to flexible array before updating its __counted_by counter\".\n- Attach\
  \ the offending statement (CallExpr for memcpy/memmove, or the store statement for\
  \ direct writes)."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/Attr.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program state: set\
  \ of object base regions whose __counted_by counter\n// has been initialized (written\
  \ on this path).\nREGISTER_SET_WITH_PROGRAMSTATE(InitCounterSet, const MemRegion*)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::Bind,\n\
  \        check::PreCall,\n        check::Location> {\n\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(std::make_unique<BugType>(this,\n\
  \                                     \"Write to flexible array before counter init\"\
  ,\n                                     \"Memory Error\")) {}\n\n  void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n  void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkLocation(SVal Loc, bool\
  \ IsLoad, const Stmt *S, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n \
  \ static const FieldRegion *findEnclosingFieldRegion(const MemRegion *R);\n  static\
  \ bool isCountedByFlexibleArrayField(const FieldDecl *FD);\n  static bool isFieldCounterForAnyCountedByInRecord(const\
  \ FieldDecl *F);\n  static bool isMemcpyLike(const CallEvent &Call, CheckerContext\
  \ &C);\n  static bool isZeroLengthCopy(const CallEvent &Call, unsigned LenIdx, CheckerContext\
  \ &C);\n  void reportWriteBeforeCounterInit(const Stmt *S, CheckerContext &C) const;\n\
  };\n\n// Ascend the region chain to find the FieldRegion that encloses R (if any).\n\
  const FieldRegion *SAGenTestChecker::findEnclosingFieldRegion(const MemRegion *R)\
  \ {\n  if (!R) return nullptr;\n  const MemRegion *Cur = R;\n  while (Cur) {\n \
  \   if (const auto *FR = dyn_cast<FieldRegion>(Cur))\n      return FR;\n    const\
  \ auto *SR = dyn_cast<SubRegion>(Cur);\n    if (!SR)\n      break;\n    Cur = SR->getSuperRegion();\n\
  \  }\n  return nullptr;\n}\n\n// Returns true if FD is a flexible-array field annotated\
  \ with counted_by.\nbool SAGenTestChecker::isCountedByFlexibleArrayField(const FieldDecl\
  \ *FD) {\n  if (!FD) return false;\n  const CountedByAttr *CBA = FD->getAttr<CountedByAttr>();\n\
  \  if (!CBA) return false;\n\n  QualType QT = FD->getType();\n  const Type *Ty =\
  \ QT.getTypePtrOrNull();\n  if (!Ty) return false;\n\n  // Flexible array members\
  \ in C are represented as IncompleteArrayType.\n  if (isa<IncompleteArrayType>(Ty))\n\
  \    return true;\n\n  return false;\n}\n\n// Returns true if field F is the counter\
  \ referenced by any counted_by flexible array\n// field in the same record.\nbool\
  \ SAGenTestChecker::isFieldCounterForAnyCountedByInRecord(const FieldDecl *F) {\n\
  \  if (!F) return false;\n  const RecordDecl *RD = dyn_cast<RecordDecl>(F->getParent());\n\
  \  if (!RD) return false;\n\n  for (const FieldDecl *FD : RD->fields()) {\n    if\
  \ (!FD) continue;\n    // Only consider flexible-array fields with counted_by\n\
  \    if (!isCountedByFlexibleArrayField(FD))\n      continue;\n\n    if (const auto\
  \ *CBA = FD->getAttr<CountedByAttr>()) {\n      // On Clang 18, CountedByAttr stores\
  \ the referenced field's IdentifierInfo.\n      if (const IdentifierInfo *CounterName\
  \ = CBA->getCountedByField()) {\n        if (F->getIdentifier() == CounterName)\n\
  \          return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isMemcpyLike(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr) return false;\n\n  // We focus on memcpy and memmove (dest,\
  \ src, len).\n  if (ExprHasName(OriginExpr, \"memcpy\", C)) return true;\n  if (ExprHasName(OriginExpr,\
  \ \"memmove\", C)) return true;\n  // Optionally, memset (dest, val, len) could\
  \ also write, but not needed for the target bug.\n  // if (ExprHasName(OriginExpr,\
  \ \"memset\", C)) return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::isZeroLengthCopy(const\
  \ CallEvent &Call, unsigned LenIdx, CheckerContext &C) {\n  if (Call.getNumArgs()\
  \ <= LenIdx) return false;\n  const Expr *LenE = Call.getArgExpr(LenIdx);\n  if\
  \ (!LenE) return false;\n  llvm::APSInt Val;\n  if (EvaluateExprToInt(Val, LenE,\
  \ C)) {\n    return Val == 0;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::reportWriteBeforeCounterInit(const\
  \ Stmt *S, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n   \
  \   *BT, \"write to flexible array before updating its __counted_by counter\", N);\n\
  \  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// Mark the object as having its counter initialized when we see a write to\
  \ the counter field.\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const {\n  const MemRegion *LocReg = Loc.getAsRegion();\n\
  \  if (!LocReg) return;\n\n  // We need the field being written.\n  const FieldRegion\
  \ *FR = dyn_cast<FieldRegion>(LocReg);\n  if (!FR) return;\n\n  const FieldDecl\
  \ *WrittenFD = FR->getDecl();\n  if (!WrittenFD) return;\n\n  // Is this field a\
  \ counter for any counted_by flexible-array in the same record?\n  if (!isFieldCounterForAnyCountedByInRecord(WrittenFD))\n\
  \    return;\n\n  // Identify the base object region of the containing object instance.\n\
  \  const MemRegion *ObjReg = FR->getSuperRegion();\n  if (!ObjReg) return;\n  ObjReg\
  \ = ObjReg->getBaseRegion();\n  if (!ObjReg) return;\n\n  ProgramStateRef State\
  \ = C.getState();\n  State = State->add<InitCounterSet>(ObjReg);\n  C.addTransition(State);\n\
  }\n\n// Detect memcpy/memmove writing into a flexible-array member before its counter\
  \ is initialized.\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  if (!isMemcpyLike(Call, C))\n    return;\n\n  // Destination is\
  \ argument 0 for memcpy/memmove.\n  if (Call.getNumArgs() < 1)\n    return;\n\n\
  \  const Expr *DstE = Call.getArgExpr(0);\n  if (!DstE) return;\n\n  const MemRegion\
  \ *DstReg = getMemRegionFromExpr(DstE, C);\n  if (!DstReg) return;\n\n  // Keep\
  \ original region for climbing; also respect guideline to get base region.\n  const\
  \ FieldRegion *DstFR = findEnclosingFieldRegion(DstReg);\n  if (!DstFR) return;\n\
  \n  const FieldDecl *DstFD = DstFR->getDecl();\n  if (!DstFD) return;\n\n  // Only\
  \ care if destination is a counted_by flexible-array field.\n  if (!isCountedByFlexibleArrayField(DstFD))\n\
  \    return;\n\n  // If length is provably zero, skip warning.\n  // memcpy/memmove\
  \ length is arg index 2.\n  if (isZeroLengthCopy(Call, 2u, C))\n    return;\n\n\
  \  // Check whether the counter of this object has been initialized on this path.\n\
  \  const MemRegion *ObjReg = DstFR->getSuperRegion();\n  if (!ObjReg) return;\n\
  \  ObjReg = ObjReg->getBaseRegion();\n  if (!ObjReg) return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  if (!State->contains<InitCounterSet>(ObjReg)) {\n   \
  \ // Counter not yet initialized: report.\n    reportWriteBeforeCounterInit(Call.getOriginExpr(),\
  \ C);\n  }\n}\n\n// Catch direct stores into the flexible-array region (e.g., event->data[i]\
  \ = ...)\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt\
  \ *S, CheckerContext &C) const {\n  if (IsLoad) return; // Only interested in writes\n\
  \n  const MemRegion *R = Loc.getAsRegion();\n  if (!R) return;\n\n  const FieldRegion\
  \ *FR = findEnclosingFieldRegion(R);\n  if (!FR) return;\n\n  const FieldDecl *FD\
  \ = FR->getDecl();\n  if (!FD) return;\n\n  if (!isCountedByFlexibleArrayField(FD))\n\
  \    return;\n\n  const MemRegion *ObjReg = FR->getSuperRegion();\n  if (!ObjReg)\
  \ return;\n  ObjReg = ObjReg->getBaseRegion();\n  if (!ObjReg) return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  if (!State->contains<InitCounterSet>(ObjReg)) {\n   \
  \ reportWriteBeforeCounterInit(S, C);\n  }\n}\n\n} // end anonymous namespace\n\n\
  extern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect writes to flexible-array members\
  \ before initializing their __counted_by counters\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
