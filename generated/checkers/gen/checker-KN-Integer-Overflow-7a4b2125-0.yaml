_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 7a4b21250bf79eef26543d35bd390448646c536b
commit_type: Integer-Overflow
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// Map variables that currently hold the result of roundup_pow_of_two(...)\n\
  // We keep the originating Stmt* (CallExpr) just for diagnostic purposes.\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion*, const Stmt*)\n\nnamespace {\nclass SAGenTestChecker\n  : public\
  \ Checker<\n        check::Bind,\n        check::BranchCondition\n    > {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\n       \
  \   : BT(new BugType(this, \"Unreliable overflow check after roundup_pow_of_two()\"\
  ,\n                                 \"Logic error\")) {}\n\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      static bool isRoundupPow2Call(const CallExpr *CE, CheckerContext &C);\n \
  \     static bool isZeroConstant(const Expr *E, CheckerContext &C);\n      static\
  \ bool extractCheckedExpr(const Expr *Cond, const Expr* &ECheck, CheckerContext\
  \ &C);\n      void reportIssue(const Stmt *CondSite, const Stmt *OriginCE, CheckerContext\
  \ &C) const;\n};\n\n// Helper: check if a CallExpr calls roundup_pow_of_two(...)\n\
  bool SAGenTestChecker::isRoundupPow2Call(const CallExpr *CE, CheckerContext &C)\
  \ {\n  if (!CE)\n    return false;\n\n  // Prefer robust name check on source text\n\
  \  if (ExprHasName(CE, \"roundup_pow_of_two\", C))\n    return true;\n\n  // Fall\
  \ back to direct callee if available\n  if (const FunctionDecl *FD = CE->getDirectCallee())\
  \ {\n    if (FD->getIdentifier() && FD->getName() == \"roundup_pow_of_two\")\n \
  \     return true;\n  }\n  // Also try on the callee expr directly\n  if (ExprHasName(CE->getCallee(),\
  \ \"roundup_pow_of_two\", C))\n    return true;\n\n  return false;\n}\n\n// Helper:\
  \ determine if expression equals integer zero (or null constant)\nbool SAGenTestChecker::isZeroConstant(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E)\n    return false;\n\n  llvm::APSInt\
  \ Res;\n  if (EvaluateExprToInt(Res, E, C))\n    return Res == 0;\n\n  if (const\
  \ auto *IL = dyn_cast<IntegerLiteral>(E->IgnoreParenCasts()))\n    return IL->getValue()\
  \ == 0;\n\n  // Also consider NULL-like constants\n  if (E->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull))\n    return true;\n\n  return false;\n}\n\n//\
  \ Helper: from a condition, extract the expression that is being checked for zero\n\
  // Match: !X  -> ECheck = X\n//        X == 0 or 0 == X -> ECheck = X\nbool SAGenTestChecker::extractCheckedExpr(const\
  \ Expr *Cond, const Expr* &ECheck, CheckerContext &C) {\n  if (!Cond)\n    return\
  \ false;\n\n  const Expr *ECond = Cond->IgnoreParenImpCasts();\n\n  if (const auto\
  \ *UO = dyn_cast<UnaryOperator>(ECond)) {\n    if (UO->getOpcode() == UO_LNot) {\n\
  \      ECheck = UO->getSubExpr();\n      return true;\n    }\n  }\n\n  if (const\
  \ auto *BO = dyn_cast<BinaryOperator>(ECond)) {\n    if (BO->getOpcode() == BO_EQ)\
  \ {\n      const Expr *L = BO->getLHS();\n      const Expr *R = BO->getRHS();\n\
  \      if (isZeroConstant(L, C)) {\n        ECheck = R;\n        return true;\n\
  \      }\n      if (isZeroConstant(R, C)) {\n        ECheck = L;\n        return\
  \ true;\n      }\n    }\n  }\n\n  return false;\n}\n\n// Report a concise warning\n\
  void SAGenTestChecker::reportIssue(const Stmt *CondSite, const Stmt *OriginCE, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n\
  \      \"Unreliable overflow check after roundup_pow_of_two()\",\n      N);\n\n\
  \  if (CondSite)\n    R->addRange(CondSite->getSourceRange());\n\n  if (OriginCE)\
  \ {\n    PathDiagnosticLocation Loc =\n        PathDiagnosticLocation::createBegin(OriginCE,\
  \ C.getSourceManager(), C.getLocationContext());\n    R->addNote(\"Value comes from\
  \ roundup_pow_of_two() here\", Loc, &C.getSourceManager());\n  }\n\n  R->addNote(\"\
  roundup_pow_of_two() may overflow (UB) on 32-bit; check the input before rounding\
  \ (e.g., x > 1UL << 31).\");\n\n  C.emitReport(std::move(R));\n}\n\n// Track binds:\
  \ mark variables assigned from roundup_pow_of_two(...); clear otherwise\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  const MemRegion *LReg\
  \ = Loc.getAsRegion();\n  if (!LReg)\n    return;\n  LReg = LReg->getBaseRegion();\n\
  \  if (!LReg)\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  // Find\
  \ a CallExpr within this bind stmt (works for init and assignment)\n  const CallExpr\
  \ *CE = findSpecificTypeInChildren<CallExpr>(S);\n  if (!CE) {\n    // No call involved\
  \ -> clear stale info for this variable\n    State = State->remove<RoundupResMap>(LReg);\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  // Only track if this call is\
  \ roundup_pow_of_two(...)\n  if (isRoundupPow2Call(CE, C)) {\n    State = State->set<RoundupResMap>(LReg,\
  \ CE);\n  } else {\n    State = State->remove<RoundupResMap>(LReg);\n  }\n\n  C.addTransition(State);\n\
  }\n\n// Detect conditions like !n or n == 0 where n is the result of roundup_pow_of_two(...)\n\
  // Also detect !roundup_pow_of_two(x) and roundup_pow_of_two(x) == 0\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  // Only warn on 32-bit unsigned\
  \ long targets\n  ASTContext &ACtx = C.getASTContext();\n  if (ACtx.getTypeSize(ACtx.UnsignedLongTy)\
  \ != 32)\n    return;\n\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE)\n    return;\n\n  const Expr *CheckedExpr = nullptr;\n  if (!extractCheckedExpr(CondE,\
  \ CheckedExpr, C))\n    return;\n\n  // Case 1: Direct call in the check (e.g.,\
  \ if (!roundup_pow_of_two(x)))\n  if (const auto *CE = dyn_cast<CallExpr>(CheckedExpr->IgnoreParenImpCasts()))\
  \ {\n    if (isRoundupPow2Call(CE, C)) {\n      reportIssue(Condition, CE, C);\n\
  \      return;\n    }\n  }\n\n  // Case 2: Variable previously assigned from roundup_pow_of_two(...)\n\
  \  ProgramStateRef State = C.getState();\n  const MemRegion *MR = getMemRegionFromExpr(CheckedExpr,\
  \ C);\n  if (!MR)\n    return;\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  if (const Stmt *Origin = State->get<RoundupResMap>(MR)) {\n    reportIssue(Condition,\
  \ Origin, C);\n    return;\n  }\n}\n\n} // end anonymous namespace\n\nextern \"\
  C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect unreliable overflow checks after\
  \ roundup_pow_of_two() on 32-bit targets\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbpf: Fix stackmap overflow check on 32-bit arches\n\
  \nThe stackmap code relies on roundup_pow_of_two() to compute the number\nof hash\
  \ buckets, and contains an overflow check by checking if the\nresulting value is\
  \ 0. However, on 32-bit arches, the roundup code itself\ncan overflow by doing a\
  \ 32-bit left-shift of an unsigned long value,\nwhich is undefined behaviour, so\
  \ it is not guaranteed to truncate\nneatly. This was triggered by syzbot on the\
  \ DEVMAP_HASH type, which\ncontains the same check, copied from the hashtab code.\n\
  \nThe commit in the fixes tag actually attempted to fix this, but the fix\ndid not\
  \ account for the UB, so the fix only works on CPUs where an\noverflow does result\
  \ in a neat truncation to zero, which is not\nguaranteed. Checking the value before\
  \ rounding does not have this\nproblem.\n\nFixes: 6183f4d3a0a2 (\"bpf: Check for\
  \ integer overflow when using roundup_pow_of_two()\")\nSigned-off-by: Toke H\xF8\
  iland-J\xF8rgensen <toke@redhat.com>\nReviewed-by: Bui Quang Minh <minhquangbui99@gmail.com>\n\
  Message-ID: <20240307120340.99577-4-toke@redhat.com>\nSigned-off-by: Alexei Starovoitov\
  \ <ast@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: stack_map_alloc in kernel/bpf/stackmap.c\n\
  static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n{\n\tu32 value_size\
  \ = attr->value_size;\n\tstruct bpf_stack_map *smap;\n\tu64 cost, n_buckets;\n\t\
  int err;\n\n\tif (attr->map_flags & ~STACK_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size\
  \ != 4 ||\n\t    value_size < 8 || value_size % 8)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\tBUILD_BUG_ON(sizeof(struct bpf_stack_build_id) % sizeof(u64));\n\tif (attr->map_flags\
  \ & BPF_F_STACK_BUILD_ID) {\n\t\tif (value_size % sizeof(struct bpf_stack_build_id)\
  \ ||\n\t\t    value_size / sizeof(struct bpf_stack_build_id)\n\t\t    > sysctl_perf_event_max_stack)\n\
  \t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n\
  \t\treturn ERR_PTR(-EINVAL);\n\n\t/* hash table size must be power of 2 */\n\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n\tif (!n_buckets)\n\t\treturn ERR_PTR(-E2BIG);\n\
  \n\tcost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);\n\tsmap\
  \ = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\tif (!smap)\n\t\t\
  return ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&smap->map, attr);\n\tsmap->n_buckets\
  \ = n_buckets;\n\n\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\t\
  if (err)\n\t\tgoto free_smap;\n\n\terr = prealloc_elems_and_freelist(smap);\n\t\
  if (err)\n\t\tgoto put_buffers;\n\n\treturn &smap->map;\n\nput_buffers:\n\tput_callchain_buffers();\n\
  free_smap:\n\tbpf_map_area_free(smap);\n\treturn ERR_PTR(err);\n}\n```\n\n## Bug\
  \ Fix Patch\n\n```diff\ndiff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c\n\
  index dff7ba539701..c99f8e5234ac 100644\n--- a/kernel/bpf/stackmap.c\n+++ b/kernel/bpf/stackmap.c\n\
  @@ -91,11 +91,14 @@ static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n\
  \ \t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n \t\treturn ERR_PTR(-EINVAL);\n\
  \ \n-\t/* hash table size must be power of 2 */\n-\tn_buckets = roundup_pow_of_two(attr->max_entries);\n\
  -\tif (!n_buckets)\n+\t/* hash table size must be power of 2; roundup_pow_of_two()\
  \ can overflow\n+\t * into UB on 32-bit arches, so check that first\n+\t */\n+\t\
  if (attr->max_entries > 1UL << 31)\n \t\treturn ERR_PTR(-E2BIG);\n \n+\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n+\n \tcost = n_buckets * sizeof(struct\
  \ stack_map_bucket *) + sizeof(*smap);\n \tsmap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\
  \ \tif (!smap)\n```\n"
pattern: "## Bug Pattern\n\nUsing roundup_pow_of_two(x) on unbounded input and detecting\
  \ overflow by testing the rounded result for zero:\n\n```\nn = roundup_pow_of_two(x);\n\
  if (!n)\n    /* assume overflow */\n```\n\nOn 32-bit architectures, roundup_pow_of_two()\
  \ can perform a 32-bit left shift by \u2265 32, invoking undefined behavior. This\
  \ makes the post-rounding check (n == 0) unreliable. The correct approach is to\
  \ validate x (e.g., x > 1UL << 31) before calling roundup_pow_of_two()."
plan: "1) Program state customizations\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion*, const Stmt*)\n  - Purpose: mark scalar variables whose current\
  \ value comes from roundup_pow_of_two(...). The mapped Stmt* can be the originating\
  \ CallExpr (used only for diagnostics context; presence in map is the main signal).\n\
  \  - We do not need alias tracking or other traits.\n\n2) Callback functions and\
  \ implementation steps\n\nStep A \u2014 Track assignments/initializations from roundup_pow_of_two\
  \ (checkBind)\n\n- Hook: void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const\n- Goal: whenever a variable is assigned or initialized with the result\
  \ of roundup_pow_of_two(...), record that the variable currently stores a \u201C\
  rounded\u201D value. If the variable is assigned something else later, clear the\
  \ mark.\n\nImplementation details:\n- Early exits:\n  - If Loc is not a region (Loc.getAsRegion()\
  \ == nullptr), return.\n  - Ignore non-scalar regions (but in practice a VarRegion\
  \ is fine).\n- Identify whether this bind comes from a call to roundup_pow_of_two:\n\
  \  - Use findSpecificTypeInChildren<CallExpr>(S) to fetch a CallExpr within the\
  \ binding Stmt (works for both initialization and assignment).\n  - If no CallExpr\
  \ is found, then this bind does not originate from a call; remove the region from\
  \ RoundupResMap (to avoid stale marks) and return.\n  - If a CallExpr CE is found:\n\
  \    - Determine whether CE calls roundup_pow_of_two:\n      - Prefer CE->getDirectCallee()\
  \ and compare getNameAsString() == \"roundup_pow_of_two\".\n      - If callee cannot\
  \ be resolved (e.g., macro/inline), fall back to ExprHasName(CE, \"roundup_pow_of_two\"\
  , C).\n    - If it is a roundup_pow_of_two call:\n      - Add mapping: State = State->set<RoundupResMap>(Region,\
  \ CE); C.addTransition(State).\n    - Otherwise:\n      - Remove any existing mapping\
  \ for this region (clear stale info).\n- Result: after this step, any variable currently\
  \ holding the result of roundup_pow_of_two is tracked in RoundupResMap.\n\nStep\
  \ B \u2014 Detect unreliable zero-check on the rounded result (checkBranchCondition)\n\
  \n- Hook: void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const\n\
  - Goal: catch if-statements like:\n  - if (!n) where n is the result of roundup_pow_of_two(...)\n\
  \  - if (n == 0) or if (0 == n) where n is the result of roundup_pow_of_two(...)\n\
  \  - if (!roundup_pow_of_two(x)) or if (roundup_pow_of_two(x) == 0)\n  These indicate\
  \ the bad overflow check the patch fixes.\n- Architecture guard:\n  - Only report\
  \ on 32-bit unsigned long targets, because the UB is specifically on 32-bit arches.\n\
  \  - Determine with: C.getASTContext().getTypeSize(C.getASTContext().UnsignedLongTy)\
  \ == 32 (bits). If not 32, return without reporting.\n\nImplementation details:\n\
  - Extract the expression ECond = cast<Expr>(Condition)->IgnoreParenImpCasts() if\
  \ possible; otherwise return.\n- Pattern match three common forms to obtain a \u201C\
  checked expression\u201D ECheck:\n  1) UnaryOperator \u2018!\u2019:\n     - If isa<UnaryOperator>(ECond)\
  \ and getOpcode() == UO_LNot:\n       - ECheck = getSubExpr()->IgnoreParenImpCasts().\n\
  \  2) BinaryOperator \u2018==\u2019:\n     - If isa<BinaryOperator>(ECond) and getOpcode()\
  \ == BO_EQ:\n       - Let L = LHS->IgnoreParenImpCasts(); R = RHS->IgnoreParenImpCasts().\n\
  \       - If either side is an integer constant expression equal to 0, let ECheck\
  \ be the other side.\n  3) We deliberately ignore \u201Cif (n)\u201D and \u201C\
  if (n != 0)\u201D because they are not overflow checks, but \u201Cif (!n)\u201D\
  \ and \u201Cif (n == 0)\u201D are typical overflow checks. Keeping the scope tight\
  \ reduces false positives.\n- Now decide if ECheck is a roundup_pow_of_two result:\n\
  \  - Case A: ECheck is a CallExpr CE:\n    - If CE is a call to roundup_pow_of_two\
  \ (same name checks as in Step A), this is a match; report.\n  - Case B: ECheck\
  \ is a reference to a tracked variable:\n    - Try to get the MemRegion: const MemRegion\
  \ *R = getMemRegionFromExpr(ECheck, C).\n    - If R != nullptr and RoundupResMap\
  \ contains R, this is a match; report.\n  - Otherwise, do nothing.\n- Reporting:\n\
  \  - Create a non-fatal error node and emit a PathSensitiveBugReport with a concise\
  \ message, e.g.:\n    - \u201CUnreliable overflow check after roundup_pow_of_two();\
  \ validate input before rounding.\u201D\n  - Optionally attach a note to the saved\
  \ CallExpr from RoundupResMap (if available) to point to where the rounded value\
  \ was produced.\n\n3) Helper routines to implement\n\n- bool isRoundupPow2Call(const\
  \ CallExpr *CE, CheckerContext &C)\n  - Return true if CE->getDirectCallee() has\
  \ name \u201Croundup_pow_of_two\u201D.\n  - If unresolved, use ExprHasName(CE, \"\
  roundup_pow_of_two\", C).\n- bool isZeroConstant(const Expr *E, CheckerContext &C)\n\
  \  - Use EvaluateExprToInt(APSInt, E, C) and check equals zero. If Evaluate fails,\
  \ also check for IntegerLiteral(0).\n- bool extractCheckedExpr(const Expr *Cond,\
  \ const Expr* &ECheck, CheckerContext &C)\n  - Implement the pattern matching described\
  \ in Step B to extract ECheck from \u2018!X\u2019 or \u2018X == 0\u2019/\u20180\
  \ == X\u2019.\n\n4) Why this suffices\n\n- We only need to detect the pattern of\
  \ using the rounded result as an overflow detector via zero check. Tracking the\
  \ source variable via a small map is enough and avoids complex dataflow.\n- Restricting\
  \ to 32-bit unsigned long eliminates false positives on 64-bit targets where the\
  \ behavior is well-defined.\n- Catching both direct calls in the condition and checks\
  \ on variables previously assigned from roundup_pow_of_two covers the common kernel\
  \ patterns found in practice.\n\n5) Bug report message\n\n- Title: \u201CUnreliable\
  \ overflow check after roundup_pow_of_two()\u201D\n- Message: \u201Croundup_pow_of_two()\
  \ may overflow (UB) on 32-bit; check the input before rounding (e.g., x > 1UL <<\
  \ 31).\u201D"
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// Map variables that currently hold the result of roundup_pow_of_two(...)\n\
  // We keep the originating Stmt* (CallExpr) just for diagnostic purposes.\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion*, const Stmt*)\n\nnamespace {\nclass SAGenTestChecker\n  : public\
  \ Checker<\n        check::Bind,\n        check::BranchCondition\n    > {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\n       \
  \   : BT(new BugType(this, \"Unreliable overflow check after roundup_pow_of_two()\"\
  ,\n                                 \"Logic error\")) {}\n\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      static bool isRoundupPow2Call(const CallExpr *CE, CheckerContext &C);\n \
  \     static bool isZeroConstant(const Expr *E, CheckerContext &C);\n      static\
  \ bool extractCheckedExpr(const Expr *Cond, const Expr* &ECheck, CheckerContext\
  \ &C);\n      void reportIssue(const Stmt *CondSite, const Stmt *OriginCE, CheckerContext\
  \ &C) const;\n};\n\n// Helper: check if a CallExpr calls roundup_pow_of_two(...)\n\
  bool SAGenTestChecker::isRoundupPow2Call(const CallExpr *CE, CheckerContext &C)\
  \ {\n  if (!CE)\n    return false;\n\n  // Prefer robust name check on source text\n\
  \  if (ExprHasName(CE, \"roundup_pow_of_two\", C))\n    return true;\n\n  // Fall\
  \ back to direct callee if available\n  if (const FunctionDecl *FD = CE->getDirectCallee())\
  \ {\n    if (FD->getIdentifier() && FD->getName() == \"roundup_pow_of_two\")\n \
  \     return true;\n  }\n  // Also try on the callee expr directly\n  if (ExprHasName(CE->getCallee(),\
  \ \"roundup_pow_of_two\", C))\n    return true;\n\n  return false;\n}\n\n// Helper:\
  \ determine if expression equals integer zero (or null constant)\nbool SAGenTestChecker::isZeroConstant(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E)\n    return false;\n\n  llvm::APSInt\
  \ Res;\n  if (EvaluateExprToInt(Res, E, C))\n    return Res == 0;\n\n  if (const\
  \ auto *IL = dyn_cast<IntegerLiteral>(E->IgnoreParenCasts()))\n    return IL->getValue()\
  \ == 0;\n\n  // Also consider NULL-like constants\n  if (E->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull))\n    return true;\n\n  return false;\n}\n\n//\
  \ Helper: from a condition, extract the expression that is being checked for zero\n\
  // Match: !X  -> ECheck = X\n//        X == 0 or 0 == X -> ECheck = X\nbool SAGenTestChecker::extractCheckedExpr(const\
  \ Expr *Cond, const Expr* &ECheck, CheckerContext &C) {\n  if (!Cond)\n    return\
  \ false;\n\n  const Expr *ECond = Cond->IgnoreParenImpCasts();\n\n  if (const auto\
  \ *UO = dyn_cast<UnaryOperator>(ECond)) {\n    if (UO->getOpcode() == UO_LNot) {\n\
  \      ECheck = UO->getSubExpr();\n      return true;\n    }\n  }\n\n  if (const\
  \ auto *BO = dyn_cast<BinaryOperator>(ECond)) {\n    if (BO->getOpcode() == BO_EQ)\
  \ {\n      const Expr *L = BO->getLHS();\n      const Expr *R = BO->getRHS();\n\
  \      if (isZeroConstant(L, C)) {\n        ECheck = R;\n        return true;\n\
  \      }\n      if (isZeroConstant(R, C)) {\n        ECheck = L;\n        return\
  \ true;\n      }\n    }\n  }\n\n  return false;\n}\n\n// Report a concise warning\n\
  void SAGenTestChecker::reportIssue(const Stmt *CondSite, const Stmt *OriginCE, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n\
  \      \"Unreliable overflow check after roundup_pow_of_two()\",\n      N);\n\n\
  \  if (CondSite)\n    R->addRange(CondSite->getSourceRange());\n\n  if (OriginCE)\
  \ {\n    PathDiagnosticLocation Loc =\n        PathDiagnosticLocation::createBegin(OriginCE,\
  \ C.getSourceManager(), C.getLocationContext());\n    R->addNote(\"Value comes from\
  \ roundup_pow_of_two() here\", Loc);\n  }\n\n  if (CondSite) {\n    PathDiagnosticLocation\
  \ Loc2 =\n        PathDiagnosticLocation::createBegin(CondSite, C.getSourceManager(),\
  \ C.getLocationContext());\n    R->addNote(\"roundup_pow_of_two() may overflow (UB)\
  \ on 32-bit; check the input before rounding (e.g., x > 1UL << 31).\", Loc2);\n\
  \  }\n\n  C.emitReport(std::move(R));\n}\n\n// Track binds: mark variables assigned\
  \ from roundup_pow_of_two(...); clear otherwise\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  const MemRegion *LReg\
  \ = Loc.getAsRegion();\n  if (!LReg)\n    return;\n  LReg = LReg->getBaseRegion();\n\
  \  if (!LReg)\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  // Find\
  \ a CallExpr within this bind stmt (works for init and assignment)\n  const CallExpr\
  \ *CE = findSpecificTypeInChildren<CallExpr>(S);\n  if (!CE) {\n    // No call involved\
  \ -> clear stale info for this variable\n    State = State->remove<RoundupResMap>(LReg);\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  // Only track if this call is\
  \ roundup_pow_of_two(...)\n  if (isRoundupPow2Call(CE, C)) {\n    State = State->set<RoundupResMap>(LReg,\
  \ CE);\n  } else {\n    State = State->remove<RoundupResMap>(LReg);\n  }\n\n  C.addTransition(State);\n\
  }\n\n// Detect conditions like !n or n == 0 where n is the result of roundup_pow_of_two(...)\n\
  // Also detect !roundup_pow_of_two(x) and roundup_pow_of_two(x) == 0\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  // Only warn on 32-bit unsigned\
  \ long targets\n  ASTContext &ACtx = C.getASTContext();\n  if (ACtx.getTypeSize(ACtx.UnsignedLongTy)\
  \ != 32)\n    return;\n\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE)\n    return;\n\n  const Expr *CheckedExpr = nullptr;\n  if (!extractCheckedExpr(CondE,\
  \ CheckedExpr, C))\n    return;\n\n  // Case 1: Direct call in the check (e.g.,\
  \ if (!roundup_pow_of_two(x)))\n  if (const auto *CE = dyn_cast<CallExpr>(CheckedExpr->IgnoreParenImpCasts()))\
  \ {\n    if (isRoundupPow2Call(CE, C)) {\n      reportIssue(Condition, CE, C);\n\
  \      return;\n    }\n  }\n\n  // Case 2: Variable previously assigned from roundup_pow_of_two(...)\n\
  \  ProgramStateRef State = C.getState();\n  const MemRegion *MR = getMemRegionFromExpr(CheckedExpr,\
  \ C);\n  if (!MR)\n    return;\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  if (const Stmt *const *OriginPtr = State->get<RoundupResMap>(MR)) {\n    const\
  \ Stmt *Origin = *OriginPtr;\n    reportIssue(Condition, Origin, C);\n    return;\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect unreliable overflow checks after roundup_pow_of_two() on 32-bit\
  \ targets\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
