_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: c8dafb0e4398dacc362832098a04b97da3b0395b
commit_type: Memory-Leak
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program states: track\
  \ the lifecycle of \"req\" objects.\nREGISTER_MAP_WITH_PROGRAMSTATE(ReqInitSeenMap,\
  \ const MemRegion*, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(ReqAcquiredMap, const\
  \ MemRegion*, bool)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::BeginFunction,\n        check::PostCall,\n        check::PreCall,\n\
  \        check::PreStmt<ReturnStmt>,\n        check::EndFunction> {\n\n  mutable\
  \ std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(std::make_unique<BugType>(this,\n\
  \                                     \"Missing hwrm_req_drop on error path\",\n\
  \                                     \"Resource Management\")) {}\n\n  void checkBeginFunction(CheckerContext\
  \ &C) const;\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n  void checkPreStmt(const\
  \ ReturnStmt *RS, CheckerContext &C) const;\n  void checkEndFunction(const ReturnStmt\
  \ *RS, CheckerContext &C) const;\n\nprivate:\n  // Helper: match callee name using\
  \ source text, fallback to identifier if needed.\n  static bool isCallee(const CallEvent\
  \ &Call, StringRef Name, CheckerContext &C);\n\n  // Helper: extract the MemRegion\
  \ of the 'req' argument at given index.\n  static const MemRegion* getReqRegion(const\
  \ CallEvent &Call, unsigned Index, CheckerContext &C);\n\n  // Report a missing-drop\
  \ issue at the given statement.\n  void reportMissingDrop(const Stmt *S, CheckerContext\
  \ &C) const;\n};\n\n// Helper implementations\n\nbool SAGenTestChecker::isCallee(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) {\n  const Expr *Origin =\
  \ Call.getOriginExpr();\n  if (Origin && ExprHasName(Origin, Name, C))\n    return\
  \ true;\n  if (const IdentifierInfo *ID = Call.getCalleeIdentifier())\n    return\
  \ ID->getName() == Name;\n  return false;\n}\n\nconst MemRegion* SAGenTestChecker::getReqRegion(const\
  \ CallEvent &Call, unsigned Index, CheckerContext &C) {\n  if (Index >= Call.getNumArgs())\n\
  \    return nullptr;\n  const Expr *ArgE = Call.getArgExpr(Index);\n  if (!ArgE)\n\
  \    return nullptr;\n  const MemRegion *R = getMemRegionFromExpr(ArgE, C);\n  if\
  \ (!R)\n    return nullptr;\n  R = R->getBaseRegion();\n  return R;\n}\n\nvoid SAGenTestChecker::reportMissingDrop(const\
  \ Stmt *S, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Request not released: missing hwrm_req_drop() before return\", N);\n\
  \  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// Callbacks\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n  // Clear maps at function\
  \ entry to avoid cross-function contamination.\n  State = State->remove<ReqInitSeenMap>();\n\
  \  State = State->remove<ReqAcquiredMap>();\n  C.addTransition(State);\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  ProgramStateRef State = C.getState();\n\n  // Mark that init has been seen\
  \ for this req.\n  if (isCallee(Call, \"hwrm_req_init\", C)) {\n    const MemRegion\
  \ *R = getReqRegion(Call, 1, C);\n    if (!R)\n      return;\n    State = State->set<ReqInitSeenMap>(R,\
  \ true);\n    C.addTransition(State);\n    return;\n  }\n\n  // On drop, clear any\
  \ acquired/init state for this req.\n  if (isCallee(Call, \"hwrm_req_drop\", C))\
  \ {\n    const MemRegion *R = getReqRegion(Call, 1, C);\n    if (!R)\n      return;\n\
  \    State = State->remove<ReqAcquiredMap>(R);\n    State = State->remove<ReqInitSeenMap>(R);\n\
  \    C.addTransition(State);\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Treat replace as the acquisition point (we've passed successful init).\n\
  \  if (isCallee(Call, \"hwrm_req_replace\", C)) {\n    const MemRegion *R = getReqRegion(Call,\
  \ 1, C);\n    if (!R)\n      return;\n\n    const bool *InitSeen = State->get<ReqInitSeenMap>(R);\n\
  \    if (InitSeen && *InitSeen) {\n      State = State->set<ReqAcquiredMap>(R, true);\n\
  \      C.addTransition(State);\n    }\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkPreStmt(const\
  \ ReturnStmt *RS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  // If any req is marked acquired (replace seen, no drop yet), warn.\n  auto M\
  \ = State->get<ReqAcquiredMap>();\n  if (!M.isEmpty()) {\n    reportMissingDrop(RS,\
  \ C);\n  }\n}\n\nvoid SAGenTestChecker::checkEndFunction(const ReturnStmt *RS, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  auto M = State->get<ReqAcquiredMap>();\n\
  \  if (!M.isEmpty()) {\n    // Function end without proper drop.\n    reportMissingDrop(RS,\
  \ C);\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect missing hwrm_req_drop() on error paths after hwrm_req_replace()\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbnxt_en: Fix possible memory leak when hwrm_req_replace\
  \ fails\n\nWhen hwrm_req_replace() fails, the driver is not invoking bnxt_req_drop()\n\
  which could cause a memory leak.\n\nFixes: bbf33d1d9805 (\"bnxt_en: update all firmware\
  \ calls to use the new APIs\")\nReviewed-by: Pavan Chebbi <pavan.chebbi@broadcom.com>\n\
  Signed-off-by: Kalesh AP <kalesh-anakkur.purayil@broadcom.com>\nSigned-off-by: Michael\
  \ Chan <michael.chan@broadcom.com>\nLink: https://patch.msgid.link/20250104043849.3482067-2-michael.chan@broadcom.com\n\
  Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ bnxt_send_msg in drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\nint bnxt_send_msg(struct\
  \ bnxt_en_dev *edev,\n\t\t\t struct bnxt_fw_msg *fw_msg)\n{\n\tstruct net_device\
  \ *dev = edev->net;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct output *resp;\n\
  \tstruct input *req;\n\tu32 resp_len;\n\tint rc;\n\n\tif (bp->fw_reset_state)\n\t\
  \treturn -EBUSY;\n\n\trc = hwrm_req_init(bp, req, 0 /* don't care */);\n\tif (rc)\n\
  \t\treturn rc;\n\n\trc = hwrm_req_replace(bp, req, fw_msg->msg, fw_msg->msg_len);\n\
  \tif (rc)\n\t\treturn rc;\n\n\thwrm_req_timeout(bp, req, fw_msg->timeout);\n\tresp\
  \ = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tresp_len = le16_to_cpu(resp->resp_len);\n\
  \tif (resp_len) {\n\t\tif (fw_msg->resp_max_len < resp_len)\n\t\t\tresp_len = fw_msg->resp_max_len;\n\
  \n\t\tmemcpy(fw_msg->resp, resp, resp_len);\n\t}\n\thwrm_req_drop(bp, req);\n\t\
  return rc;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\
  \ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\nindex b771c84cdd89..0ed26e3a28f4\
  \ 100644\n--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\n+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\n\
  @@ -208,7 +208,7 @@ int bnxt_send_msg(struct bnxt_en_dev *edev,\n \n \trc = hwrm_req_replace(bp,\
  \ req, fw_msg->msg, fw_msg->msg_len);\n \tif (rc)\n-\t\treturn rc;\n+\t\tgoto drop_req;\n\
  \ \n \thwrm_req_timeout(bp, req, fw_msg->timeout);\n \tresp = hwrm_req_hold(bp,\
  \ req);\n@@ -220,6 +220,7 @@ int bnxt_send_msg(struct bnxt_en_dev *edev,\n \n \t\
  \tmemcpy(fw_msg->resp, resp, resp_len);\n \t}\n+drop_req:\n \thwrm_req_drop(bp,\
  \ req);\n \treturn rc;\n }\n```\n"
pattern: "## Bug Pattern\n\nResource acquired via hwrm_req_init(...) is not released\
  \ on all error paths. Specifically, after successful hwrm_req_init, an early return\
  \ on a subsequent failure (e.g., hwrm_req_replace(...) returning error) exits without\
  \ the required hwrm_req_drop(...), leaking the request object.\n\nPattern snippet:\n\
  hwrm_req_init(bp, req, ...);\n/* ... */\nrc = hwrm_req_replace(bp, req, ...);\n\
  if (rc)\n    return rc;  // missing hwrm_req_drop(bp, req) before returning"
plan: "1) Program state\n\n- Use two small maps to track the request object life-cycle:\n\
  \  - REGISTER_MAP_WITH_PROGRAMSTATE(ReqInitSeenMap, const MemRegion*, bool)\n  \
  \  - Key: the MemRegion of the req argument.\n    - Value: true means we have seen\
  \ hwrm_req_init(...) for that req on this path.\n  - REGISTER_MAP_WITH_PROGRAMSTATE(ReqAcquiredMap,\
  \ const MemRegion*, bool)\n    - Key: the MemRegion of the req argument.\n    -\
  \ Value: true means a request is active and must be released with hwrm_req_drop(...).\n\
  \n- No taint or traits are needed. Keep it path-sensitive and simple.\n\n- Helper\
  \ utilities:\n  - bool isCallee(const CallEvent &Call, StringRef Name): compare\
  \ Call.getCalleeIdentifier()->getName().\n  - const MemRegion* getReqRegion(const\
  \ CallEvent &Call, unsigned Index, CheckerContext &C):\n    - return getMemRegionFromExpr(Call.getArgExpr(Index),\
  \ C).\n  - Reuse the provided getMemRegionFromExpr utility.\n\n\n2) Callbacks and\
  \ logic\n\nA) checkBeginFunction(CheckerContext &C)\n- Clear both maps at the beginning\
  \ of each function:\n  - State = State->remove<ReqInitSeenMap>()\n  - State = State->remove<ReqAcquiredMap>()\n\
  - Rationale: avoid cross-function contamination.\n\nB) checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C)\n- Goal: mark init seen; clear on drop.\n- Steps:\n\
  \  - If isCallee(Call, \"hwrm_req_init\"):\n    - Get req region: R = getReqRegion(Call,\
  \ 1, C); if (!R) return.\n    - State = State->set<ReqInitSeenMap>(R, true)\n  \
  \  - C.addTransition(State)\n  - Else if isCallee(Call, \"hwrm_req_drop\"):\n  \
  \  - Get req region R; if (!R) return.\n    - State = State->remove<ReqAcquiredMap>(R)\n\
  \    - Optionally also: State = State->remove<ReqInitSeenMap>(R)\n    - C.addTransition(State)\n\
  \nC) checkPreCall(const CallEvent &Call, CheckerContext &C)\n- Goal: mark resource\
  \ as \u201Cacquired\u201D at the first use that implies init succeeded.\n- We use\
  \ hwrm_req_replace(...) as the acquisition point because code paths that reach replace\
  \ have already passed the init success check (matches the target pattern and minimizes\
  \ false positives).\n- Steps:\n  - If isCallee(Call, \"hwrm_req_replace\"):\n  \
  \  - Get req region R; if (!R) return.\n    - Only proceed if State->contains<ReqInitSeenMap>(R)\
  \ (InitSeen true). This ensures replace is paired with a prior init on the same\
  \ path.\n    - State = State->set<ReqAcquiredMap>(R, true)\n    - C.addTransition(State)\n\
  \nD) checkPreStmt(const ReturnStmt *RS, CheckerContext &C)\n- Goal: detect early\
  \ returns while a req is still acquired (i.e., missing hwrm_req_drop on this path).\n\
  - Steps:\n  - Fetch current State.\n  - If ReqAcquiredMap is empty: return.\n  -\
  \ Otherwise, report a bug once per ReturnStmt (just pick the first outstanding req\
  \ region):\n    - Create a BugType (class-level singleton): \"Missing hwrm_req_drop\
  \ on error path\"\n    - Node = C.generateNonFatalErrorNode()\n    - If Node:\n\
  \      - Create PathSensitiveBugReport with message: \"Request not released: missing\
  \ hwrm_req_drop() before return\"\n      - Optionally, if you want a location hint,\
  \ use RS->getBeginLoc() as the primary location.\n      - Emit report.\n\n- Note:\
  \ This purposefully focuses on the post-init, post-replace early return scenario\
  \ (the outstanding ReqAcquiredMap precisely means we\u2019ve passed replace without\
  \ a matching drop), which matches the target bug.\n\nE) checkEndFunction(const ReturnStmt\
  \ *RS, CheckerContext &C)\n- Goal: catch missing drop at function end without explicit\
  \ return (or just as an extra safety net).\n- Steps:\n  - Same logic as in checkPreStmt(ReturnStmt):\
  \ if ReqAcquiredMap not empty, report once.\n\nF) Optional: checkASTCodeBody / others\n\
  - Not necessary for this pattern; path-sensitive callbacks above are sufficient.\n\
  \n\n3) Matching details\n\n- API names to match (exact):\n  - Acquisition sequence:\n\
  \    - hwrm_req_init(bp, req, ...)\n    - hwrm_req_replace(bp, req, ..., ...)\n\
  \  - Release:\n    - hwrm_req_drop(bp, req)\n\n- Argument index for req is 1 (0-based):\n\
  \  - req is the 2nd argument in all three functions. Always take the MemRegion of\
  \ Call.getArgExpr(1) via getMemRegionFromExpr.\n\n- We do not rely on the rc variable\
  \ name, branch shape, or specific return expressions. The checker is robust to coding\
  \ style, because it only cares whether a return (or function end) occurs while a\
  \ req is still marked acquired (i.e., replace seen, no drop yet).\n\n\n4) Why this\
  \ is minimal yet accurate\n\n- We avoid modeling the success/failure value of hwrm_req_init\
  \ and complicated branching. Instead, we mark acquisition only after hwrm_req_replace,\
  \ which is known (by driver conventions and the provided patch) to follow a successful\
  \ init. This keeps the checker simple and reduces false positives.\n- We ensure\
  \ release is recognized only by hwrm_req_drop matching the same req.\n- We warn\
  \ only when returning while a req is outstanding, which directly corresponds to\
  \ the bug (resource leak on error paths).\n- We do not require pointer alias tracking\
  \ because the bnxt pattern consistently passes the same req variable; if needed\
  \ later, alias tracking can be added with a separate PtrAliasMap and checkBind,\
  \ but it\u2019s unnecessary for this concrete pattern.\n\n\n5) Report message\n\n\
  - Keep it short and clear:\n  - Title: \"Missing hwrm_req_drop on error path\"\n\
  \  - Message: \"Request not released: missing hwrm_req_drop() before return\"\n\n\
  \n6) Utility functions usage\n\n- getMemRegionFromExpr: used to extract the MemRegion\
  \ key from the req argument in all three functions.\n- No need for findSpecificTypeInParents/Children,\
  \ EvaluateExprToInt, inferSymbolMaxVal, or ExprHasName for this pattern."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program states: track\
  \ the lifecycle of \"req\" objects.\nREGISTER_MAP_WITH_PROGRAMSTATE(ReqInitSeenMap,\
  \ const MemRegion*, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(ReqAcquiredMap, const\
  \ MemRegion*, bool)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::BeginFunction,\n        check::PostCall,\n        check::PreCall,\n\
  \        check::PreStmt<ReturnStmt>,\n        check::EndFunction> {\n\n  mutable\
  \ std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(std::make_unique<BugType>(this,\n\
  \                                     \"Missing hwrm_req_drop on error path\",\n\
  \                                     \"Resource Management\")) {}\n\n  void checkBeginFunction(CheckerContext\
  \ &C) const;\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n  void checkPreStmt(const\
  \ ReturnStmt *RS, CheckerContext &C) const;\n  void checkEndFunction(const ReturnStmt\
  \ *RS, CheckerContext &C) const;\n\nprivate:\n  // Helper: match callee name using\
  \ source text, fallback to identifier if needed.\n  static bool isCallee(const CallEvent\
  \ &Call, StringRef Name, CheckerContext &C);\n\n  // Helper: extract the MemRegion\
  \ of the 'req' argument at given index.\n  static const MemRegion* getReqRegion(const\
  \ CallEvent &Call, unsigned Index, CheckerContext &C);\n\n  // Report a missing-drop\
  \ issue at the given statement.\n  void reportMissingDrop(const Stmt *S, CheckerContext\
  \ &C) const;\n};\n\n// Helper implementations\n\nbool SAGenTestChecker::isCallee(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) {\n  const Expr *Origin =\
  \ Call.getOriginExpr();\n  if (Origin && ExprHasName(Origin, Name, C))\n    return\
  \ true;\n  if (const IdentifierInfo *ID = Call.getCalleeIdentifier())\n    return\
  \ ID->getName() == Name;\n  return false;\n}\n\nconst MemRegion* SAGenTestChecker::getReqRegion(const\
  \ CallEvent &Call, unsigned Index, CheckerContext &C) {\n  if (Index >= Call.getNumArgs())\n\
  \    return nullptr;\n  const Expr *ArgE = Call.getArgExpr(Index);\n  if (!ArgE)\n\
  \    return nullptr;\n  const MemRegion *R = getMemRegionFromExpr(ArgE, C);\n  if\
  \ (!R)\n    return nullptr;\n  R = R->getBaseRegion();\n  return R;\n}\n\nvoid SAGenTestChecker::reportMissingDrop(const\
  \ Stmt *S, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Request not released: missing hwrm_req_drop() before return\", N);\n\
  \  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// Callbacks\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n  // Clear maps at function\
  \ entry to avoid cross-function contamination.\n  State = State->remove<ReqInitSeenMap>();\n\
  \  State = State->remove<ReqAcquiredMap>();\n  C.addTransition(State);\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  ProgramStateRef State = C.getState();\n\n  // Mark that init has been seen\
  \ for this req.\n  if (isCallee(Call, \"hwrm_req_init\", C)) {\n    const MemRegion\
  \ *R = getReqRegion(Call, 1, C);\n    if (!R)\n      return;\n    State = State->set<ReqInitSeenMap>(R,\
  \ true);\n    C.addTransition(State);\n    return;\n  }\n\n  // On drop, clear any\
  \ acquired/init state for this req.\n  if (isCallee(Call, \"hwrm_req_drop\", C))\
  \ {\n    const MemRegion *R = getReqRegion(Call, 1, C);\n    if (!R)\n      return;\n\
  \    State = State->remove<ReqAcquiredMap>(R);\n    State = State->remove<ReqInitSeenMap>(R);\n\
  \    C.addTransition(State);\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Treat replace as the acquisition point (we've passed successful init).\n\
  \  if (isCallee(Call, \"hwrm_req_replace\", C)) {\n    const MemRegion *R = getReqRegion(Call,\
  \ 1, C);\n    if (!R)\n      return;\n\n    const bool *InitSeen = State->get<ReqInitSeenMap>(R);\n\
  \    if (InitSeen && *InitSeen) {\n      State = State->set<ReqAcquiredMap>(R, true);\n\
  \      C.addTransition(State);\n    }\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkPreStmt(const\
  \ ReturnStmt *RS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  // If any req is marked acquired (replace seen, no drop yet), warn.\n  auto M\
  \ = State->get<ReqAcquiredMap>();\n  if (!M.isEmpty()) {\n    reportMissingDrop(RS,\
  \ C);\n  }\n}\n\nvoid SAGenTestChecker::checkEndFunction(const ReturnStmt *RS, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  auto M = State->get<ReqAcquiredMap>();\n\
  \  if (!M.isEmpty()) {\n    // Function end without proper drop.\n    reportMissingDrop(RS,\
  \ C);\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect missing hwrm_req_drop() on error paths after hwrm_req_replace()\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
