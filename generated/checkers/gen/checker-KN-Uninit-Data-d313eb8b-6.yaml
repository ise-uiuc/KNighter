_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: d313eb8b77557a6d5855f42d2234bd592c7b50dd
commit_type: Uninit-Data
index: 6
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state maps:\n// - ZeroedStructMap: base region of a local struct -> true\
  \ if definitely fully zeroed to sizeof(struct)\n// - PtrAliasMap: pointer region\
  \ -> base pointee region (e.g., p -> VarRegion(s))\nREGISTER_MAP_WITH_PROGRAMSTATE(ZeroedStructMap,\
  \ const MemRegion*, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*,\
  \ const MemRegion*)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall,\n\
  \                                        check::PostCall,\n                    \
  \                    check::Bind> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Copying non-zeroed\
  \ stack struct to user\", \"Kernel Information Leak\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const;\n\n   private:\n\n      // Helpers\n      static\
  \ bool isMemsetLike(const CallEvent &Call, CheckerContext &C);\n      static bool\
  \ isMemzeroLike(const CallEvent &Call, CheckerContext &C);\n\n      static bool\
  \ isUserCopySink(const CallEvent &Call, CheckerContext &C,\n                   \
  \              unsigned &LenIdx, unsigned &DataIdx);\n\n      static const MemRegion\
  \ *extractPointeeBaseRegion(const Expr *PtrExpr,\n                             \
  \                          CheckerContext &C);\n\n      static bool isLocalStructVarRegion(const\
  \ MemRegion *R);\n      static uint64_t getTypeSizeInBytes(QualType QT, ASTContext\
  \ &Ctx);\n\n      static bool evalSizeArgEqualsVarSize(const Expr *LenE,\n     \
  \                                      const VarRegion *VR,\n                  \
  \                         CheckerContext &C);\n\n      static bool evalExprIsZero(const\
  \ Expr *E, CheckerContext &C);\n\n      void markZeroedIfFullSize(const Expr *DstE,\n\
  \                                const Expr *LenE,\n                           \
  \     bool ImplicitZero,\n                                const Expr *ValE,\n  \
  \                              CheckerContext &C) const;\n\n      void reportLeakAtCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n};\n\n// Determine if the call is\
  \ memset-like (memset/__memset/__builtin_memset).\nbool SAGenTestChecker::isMemsetLike(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  return ExprHasName(Origin, \"memset\", C)\
  \ ||\n         ExprHasName(Origin, \"__memset\", C) ||\n         ExprHasName(Origin,\
  \ \"__builtin_memset\", C);\n}\n\n// Determine if the call is memzero-like (memzero_explicit/bzero).\n\
  bool SAGenTestChecker::isMemzeroLike(const CallEvent &Call, CheckerContext &C) {\n\
  \  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n\
  \  return ExprHasName(Origin, \"memzero_explicit\", C) ||\n         ExprHasName(Origin,\
  \ \"bzero\", C);\n}\n\n// Identify sinks that copy data to user or netlink attribute\
  \ with explicit length and data pointer.\n// Returns true and sets LenIdx/DataIdx\
  \ if recognized.\nbool SAGenTestChecker::isUserCopySink(const CallEvent &Call, CheckerContext\
  \ &C,\n                                      unsigned &LenIdx, unsigned &DataIdx)\
  \ {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n\
  \n  // Order matters because ExprHasName checks for substring containment.\n  if\
  \ (ExprHasName(Origin, \"nla_put_64bit\", C)) {\n    if (Call.getNumArgs() >= 4)\
  \ {\n      LenIdx = 2; DataIdx = 3; return true;\n    }\n  }\n  if (ExprHasName(Origin,\
  \ \"nla_put\", C)) {\n    if (Call.getNumArgs() >= 4) {\n      LenIdx = 2; DataIdx\
  \ = 3; return true;\n    }\n  }\n  if (ExprHasName(Origin, \"__copy_to_user\", C))\
  \ {\n    if (Call.getNumArgs() >= 3) {\n      LenIdx = 2; DataIdx = 1; return true;\n\
  \    }\n  }\n  if (ExprHasName(Origin, \"copy_to_user_iter\", C)) {\n    if (Call.getNumArgs()\
  \ >= 3) {\n      LenIdx = 2; DataIdx = 1; return true;\n    }\n  }\n  if (ExprHasName(Origin,\
  \ \"copy_to_user\", C)) {\n    if (Call.getNumArgs() >= 3) {\n      LenIdx = 2;\
  \ DataIdx = 1; return true;\n    }\n  }\n  if (ExprHasName(Origin, \"_copy_to_iter\"\
  , C)) {\n    if (Call.getNumArgs() >= 2) {\n      LenIdx = 1; DataIdx = 0; return\
  \ true;\n    }\n  }\n  return false;\n}\n\n// Follow alias map to get the ultimate\
  \ base region (ideally a VarRegion of the struct).\nconst MemRegion *SAGenTestChecker::extractPointeeBaseRegion(const\
  \ Expr *PtrExpr,\n                                                            CheckerContext\
  \ &C) {\n  if (!PtrExpr)\n    return nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(PtrExpr,\
  \ C);\n  if (!MR)\n    return nullptr;\n\n  MR = MR->getBaseRegion();\n  if (!MR)\n\
  \    return nullptr;\n\n  ProgramStateRef State = C.getState();\n  // Follow alias\
  \ chain: pointer region -> base pointee region.\n  const MemRegion *Cur = MR;\n\
  \  llvm::SmallPtrSet<const MemRegion*, 8> Visited;\n  while (true) {\n    if (!Cur)\n\
  \      break;\n    if (!Visited.insert(Cur).second)\n      break; // avoid cycles\n\
  \    const MemRegion *Next = State->get<PtrAliasMap>(Cur);\n    if (!Next)\n   \
  \   break;\n    Cur = Next->getBaseRegion();\n  }\n  return Cur ? Cur->getBaseRegion()\
  \ : nullptr;\n}\n\nbool SAGenTestChecker::isLocalStructVarRegion(const MemRegion\
  \ *R) {\n  if (!R)\n    return false;\n  const VarRegion *VR = dyn_cast<VarRegion>(R);\n\
  \  if (!VR)\n    return false;\n  const VarDecl *VD = dyn_cast<VarDecl>(VR->getDecl());\n\
  \  if (!VD)\n    return false;\n  if (!VD->hasLocalStorage() || !VD->isLocalVarDecl())\n\
  \    return false;\n  QualType T = VD->getType();\n  return !T.isNull() && T->isRecordType();\n\
  }\n\nuint64_t SAGenTestChecker::getTypeSizeInBytes(QualType QT, ASTContext &Ctx)\
  \ {\n  if (QT.isNull())\n    return 0;\n  return Ctx.getTypeSizeInChars(QT).getQuantity();\n\
  }\n\nbool SAGenTestChecker::evalSizeArgEqualsVarSize(const Expr *LenE,\n       \
  \                                         const VarRegion *VR,\n               \
  \                                 CheckerContext &C) {\n  if (!LenE || !VR)\n  \
  \  return false;\n  llvm::APSInt Res;\n  if (!EvaluateExprToInt(Res, LenE, C))\n\
  \    return false;\n\n  const VarDecl *VD = dyn_cast<VarDecl>(VR->getDecl());\n\
  \  if (!VD)\n    return false;\n  uint64_t VarSize = getTypeSizeInBytes(VD->getType(),\
  \ C.getASTContext());\n\n  // Compare as unsigned\n  uint64_t LenVal = Res.isSigned()\
  \ ? Res.getSExtValue() : Res.getZExtValue();\n  return LenVal == VarSize;\n}\n\n\
  bool SAGenTestChecker::evalExprIsZero(const Expr *E, CheckerContext &C) {\n  if\
  \ (!E)\n    return false;\n  llvm::APSInt Res;\n  if (!EvaluateExprToInt(Res, E,\
  \ C))\n    return false;\n  return Res == 0;\n}\n\n// If destination points to a\
  \ local struct, and the length equals sizeof(struct),\n// and the value is zero\
  \ (or implicit zero), mark the struct as zeroed.\nvoid SAGenTestChecker::markZeroedIfFullSize(const\
  \ Expr *DstE,\n                                            const Expr *LenE,\n \
  \                                           bool ImplicitZero,\n               \
  \                             const Expr *ValE,\n                              \
  \              CheckerContext &C) const {\n  if (!DstE || !LenE)\n    return;\n\n\
  \  if (!ImplicitZero) {\n    if (!ValE)\n      return;\n    if (!evalExprIsZero(ValE,\
  \ C))\n      return;\n  }\n\n  const MemRegion *Base = extractPointeeBaseRegion(DstE,\
  \ C);\n  if (!Base)\n    return;\n  const VarRegion *VR = dyn_cast<VarRegion>(Base);\n\
  \  if (!VR)\n    return;\n\n  if (!isLocalStructVarRegion(VR))\n    return;\n\n\
  \  if (!evalSizeArgEqualsVarSize(LenE, VR, C))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  State = State->set<ZeroedStructMap>(VR, true);\n  C.addTransition(State);\n\
  }\n\n// Track pointer aliasing: if LHS is a pointer var and RHS is &struct or another\
  \ pointer alias,\n// map LHS region -> ultimate base pointee region.\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\
  \ {\n    C.addTransition(State);\n    return;\n  }\n  LHSReg = LHSReg->getBaseRegion();\n\
  \  if (!LHSReg) {\n    C.addTransition(State);\n    return;\n  }\n\n  const MemRegion\
  \ *RReg = Val.getAsRegion();\n  if (!RReg) {\n    // We could drop the alias, but\
  \ keep it simple: do nothing.\n    C.addTransition(State);\n    return;\n  }\n \
  \ RReg = RReg->getBaseRegion();\n  if (!RReg) {\n    C.addTransition(State);\n \
  \   return;\n  }\n\n  // Resolve RHS to ultimate base if it's already an alias.\n\
  \  const MemRegion *Ultimate = RReg;\n  llvm::SmallPtrSet<const MemRegion*, 8> Visited;\n\
  \  while (true) {\n    if (!Ultimate)\n      break;\n    if (!Visited.insert(Ultimate).second)\n\
  \      break;\n    const MemRegion *Next = State->get<PtrAliasMap>(Ultimate);\n\
  \    if (!Next)\n      break;\n    Ultimate = Next->getBaseRegion();\n  }\n\n  State\
  \ = State->set<PtrAliasMap>(LHSReg, Ultimate);\n  C.addTransition(State);\n}\n\n\
  // Post-call: detect zeroing operations and mark structs as fully zeroed.\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  if (isMemsetLike(Call, C)) {\n    if (Call.getNumArgs() >= 3) {\n      const\
  \ Expr *DstE = Call.getArgExpr(0);\n      const Expr *ValE = Call.getArgExpr(1);\n\
  \      const Expr *LenE = Call.getArgExpr(2);\n      markZeroedIfFullSize(DstE,\
  \ LenE, false, ValE, C);\n    }\n    return;\n  }\n\n  if (isMemzeroLike(Call, C))\
  \ {\n    if (Call.getNumArgs() >= 2) {\n      const Expr *DstE = Call.getArgExpr(0);\n\
  \      const Expr *LenE = Call.getArgExpr(1);\n      markZeroedIfFullSize(DstE,\
  \ LenE, true, nullptr, C);\n    }\n    return;\n  }\n}\n\n// Pre-call: report if\
  \ copying a local stack struct by sizeof(struct) without prior zeroing.\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  unsigned LenIdx = 0, DataIdx =\
  \ 0;\n  if (!isUserCopySink(Call, C, LenIdx, DataIdx))\n    return;\n\n  if (Call.getNumArgs()\
  \ <= std::max(LenIdx, DataIdx))\n    return;\n\n  const Expr *DataE = Call.getArgExpr(DataIdx);\n\
  \  const Expr *LenE = Call.getArgExpr(LenIdx);\n  if (!DataE || !LenE)\n    return;\n\
  \n  const MemRegion *Base = extractPointeeBaseRegion(DataE, C);\n  if (!Base)\n\
  \    return;\n\n  const VarRegion *VR = dyn_cast<VarRegion>(Base);\n  if (!VR)\n\
  \    return;\n\n  if (!isLocalStructVarRegion(VR))\n    return;\n\n  if (!evalSizeArgEqualsVarSize(LenE,\
  \ VR, C))\n    return;\n\n  ProgramStateRef State = C.getState();\n  const bool\
  \ *Zeroed = State->get<ZeroedStructMap>(VR);\n  // If not marked as zeroed, warn.\n\
  \  if (!(Zeroed && *Zeroed)) {\n    reportLeakAtCall(Call, C);\n  }\n}\n\nvoid SAGenTestChecker::reportLeakAtCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Copying non-zeroed stack struct to user; zero it first.\", N);\n \
  \ if (const Expr *E = Call.getOriginExpr())\n    R->addRange(E->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects copying of partially-initialized\
  \ stack structs to user space without zeroing\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/sched: act_skbmod: prevent kernel-infoleak\n\n\
  syzbot found that tcf_skbmod_dump() was copying four bytes\nfrom kernel stack to\
  \ user space [1].\n\nThe issue here is that 'struct tc_skbmod' has a four bytes\
  \ hole.\n\nWe need to clear the structure before filling fields.\n\n[1]\nBUG: KMSAN:\
  \ kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in copy_to_user_iter lib/iov_iter.c:24 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_and_advance2 include/linux/iov_iter.h:245\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in iterate_and_advance include/linux/iov_iter.h:271\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n  copy_to_user_iter\
  \ lib/iov_iter.c:24 [inline]\n  iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \  iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\n  iterate_and_advance\
  \ include/linux/iov_iter.h:271 [inline]\n  _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  copy_to_iter include/linux/uio.h:196 [inline]\n  simple_copy_to_iter net/core/datagram.c:532\
  \ [inline]\n  __skb_datagram_iter+0x185/0x1000 net/core/datagram.c:420\n  skb_copy_datagram_iter+0x5c/0x200\
  \ net/core/datagram.c:546\n  skb_copy_datagram_msg include/linux/skbuff.h:4050 [inline]\n\
  \  netlink_recvmsg+0x432/0x1610 net/netlink/af_netlink.c:1962\n  sock_recvmsg_nosec\
  \ net/socket.c:1046 [inline]\n  sock_recvmsg+0x2c4/0x340 net/socket.c:1068\n  __sys_recvfrom+0x35a/0x5f0\
  \ net/socket.c:2242\n  __do_sys_recvfrom net/socket.c:2260 [inline]\n  __se_sys_recvfrom\
  \ net/socket.c:2256 [inline]\n  __x64_sys_recvfrom+0x126/0x1d0 net/socket.c:2256\n\
  \ do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nUninit\
  \ was stored to memory at:\n  pskb_expand_head+0x30f/0x19d0 net/core/skbuff.c:2253\n\
  \  netlink_trim+0x2c2/0x330 net/netlink/af_netlink.c:1317\n  netlink_unicast+0x9f/0x1260\
  \ net/netlink/af_netlink.c:1351\n  nlmsg_unicast include/net/netlink.h:1144 [inline]\n\
  \  nlmsg_notify+0x21d/0x2f0 net/netlink/af_netlink.c:2610\n  rtnetlink_send+0x73/0x90\
  \ net/core/rtnetlink.c:741\n  rtnetlink_maybe_send include/linux/rtnetlink.h:17\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2048 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x146e/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nUninit was stored to memory at:\n  __nla_put lib/nlattr.c:1041 [inline]\n  nla_put+0x1c6/0x230\
  \ lib/nlattr.c:1099\n  tcf_skbmod_dump+0x23f/0xc20 net/sched/act_skbmod.c:256\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n  tcf_action_dump+0x1fd/0x460 net/sched/act_api.c:1251\n\
  \  tca_get_fill+0x519/0x7a0 net/sched/act_api.c:1628\n  tcf_add_notify_msg net/sched/act_api.c:2023\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2042 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x1365/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nLocal variable opt created at:\n  tcf_skbmod_dump+0x9d/0xc20 net/sched/act_skbmod.c:244\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n\nBytes 188-191 of 248 are uninitialized\nMemory access\
  \ of size 248 starts at ffff888117697680\nData copied to user address 00007ffe56d855f0\n\
  \nFixes: 86da71b57383 (\"net_sched: Introduce skbmod action\")\nSigned-off-by: Eric\
  \ Dumazet <edumazet@google.com>\nAcked-by: Jamal Hadi Salim <jhs@mojatatu.com>\n\
  Link: https://lore.kernel.org/r/20240403130908.93421-1-edumazet@google.com\nSigned-off-by:\
  \ Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: tcf_skbmod_dump\
  \ in net/sched/act_skbmod.c\nstatic int tcf_skbmod_dump(struct sk_buff *skb, struct\
  \ tc_action *a,\n\t\t\t   int bind, int ref)\n{\n\tstruct tcf_skbmod *d = to_skbmod(a);\n\
  \tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_skbmod_params  *p;\n\t\
  struct tc_skbmod opt = {\n\t\t.index   = d->tcf_index,\n\t\t.refcnt  = refcount_read(&d->tcf_refcnt)\
  \ - ref,\n\t\t.bindcnt = atomic_read(&d->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t\
  \ t;\n\n\tspin_lock_bh(&d->tcf_lock);\n\topt.action = d->tcf_action;\n\tp = rcu_dereference_protected(d->skbmod_p,\n\
  \t\t\t\t      lockdep_is_held(&d->tcf_lock));\n\topt.flags  = p->flags;\n\tif (nla_put(skb,\
  \ TCA_SKBMOD_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_DMAC) &&\n\t    nla_put(skb, TCA_SKBMOD_DMAC, ETH_ALEN, p->eth_dst))\n\
  \t\tgoto nla_put_failure;\n\tif ((p->flags & SKBMOD_F_SMAC) &&\n\t    nla_put(skb,\
  \ TCA_SKBMOD_SMAC, ETH_ALEN, p->eth_src))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_ETYPE) &&\n\t    nla_put_u16(skb, TCA_SKBMOD_ETYPE, ntohs(p->eth_type)))\n\
  \t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &d->tcf_tm);\n\tif (nla_put_64bit(skb,\
  \ TCA_SKBMOD_TM, sizeof(t), &t, TCA_SKBMOD_PAD))\n\t\tgoto nla_put_failure;\n\n\t\
  spin_unlock_bh(&d->tcf_lock);\n\treturn skb->len;\nnla_put_failure:\n\tspin_unlock_bh(&d->tcf_lock);\n\
  \tnlmsg_trim(skb, b);\n\treturn -1;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff\
  \ --git a/net/sched/act_skbmod.c b/net/sched/act_skbmod.c\nindex 39945b139c48..cd0accaf844a\
  \ 100644\n--- a/net/sched/act_skbmod.c\n+++ b/net/sched/act_skbmod.c\n@@ -241,13\
  \ +241,13 @@ static int tcf_skbmod_dump(struct sk_buff *skb, struct tc_action *a,\n\
  \ \tstruct tcf_skbmod *d = to_skbmod(a);\n \tunsigned char *b = skb_tail_pointer(skb);\n\
  \ \tstruct tcf_skbmod_params  *p;\n-\tstruct tc_skbmod opt = {\n-\t\t.index   =\
  \ d->tcf_index,\n-\t\t.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n-\t\t.bindcnt\
  \ = atomic_read(&d->tcf_bindcnt) - bind,\n-\t};\n+\tstruct tc_skbmod opt;\n \tstruct\
  \ tcf_t t;\n \n+\tmemset(&opt, 0, sizeof(opt));\n+\topt.index   = d->tcf_index;\n\
  +\topt.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n+\topt.bindcnt = atomic_read(&d->tcf_bindcnt)\
  \ - bind;\n \tspin_lock_bh(&d->tcf_lock);\n \topt.action = d->tcf_action;\n \tp\
  \ = rcu_dereference_protected(d->skbmod_p,\n```\n"
pattern: '## Bug Pattern


  Creating a stack-allocated struct and initializing only some fields (e.g., via a
  designated initializer), then copying the entire struct (sizeof(struct)) to user
  space (e.g., via nla_put/copy_to_user). Because stack padding/holes and any untouched
  fields remain uninitialized, this leaks kernel stack data.


  Example pattern:

  struct S s = { .a = val_a, .b = val_b };  // not all fields/padding initialized

  ... // maybe set a few more fields

  nla_put(skb, ATTR, sizeof(s), &s);        // copies uninitialized bytes too


  Correct pattern is to zero-initialize the struct first (e.g., memset(&s, 0, sizeof(s))
  or use kzalloc) before setting fields.'
plan: "1) Program state\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(ZeroedStructMap, const\
  \ MemRegion*, bool)\n  - Meaning: key is the base region of a stack-allocated struct;\
  \ value true means \u201Cdefinitely zero-cleared in full size.\u201D Absence or\
  \ false means unknown/not cleared.\n- REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap,\
  \ const MemRegion*, const MemRegion*)\n  - Tracks pointer aliases: maps a pointer\
  \ variable\u2019s region (LHS) to the base pointee region (e.g., &opt -> VarRegion(opt)).\
  \ This allows us to resolve data arguments passed through temporaries.\n\n2) Helper\
  \ predicates and utilities\n\n- isZeroingFunction(const CallEvent &Call)\n  - Return\
  \ true for memset, __memset, __builtin_memset, memzero_explicit, bzero. Check via\
  \ Call.getCalleeIdentifier()->getName().\n- isUserCopySink(const CallEvent &Call,\
  \ unsigned &LenIdx, unsigned &DataIdx)\n  - Identify sinks and set parameter indices:\n\
  \    - nla_put(skb, type, len, data): LenIdx=2, DataIdx=3\n    - nla_put_64bit(skb,\
  \ type, len, data, padattr): LenIdx=2, DataIdx=3\n    - copy_to_user(to, from, n):\
  \ LenIdx=2, DataIdx=1\n    - __copy_to_user(to, from, n): LenIdx=2, DataIdx=1\n\
  \    - copy_to_user_iter / _copy_to_iter variants:\n      - copy_to_user_iter(to,\
  \ from, n): LenIdx=2, DataIdx=1\n      - _copy_to_iter(addr, bytes, ...): LenIdx=1,\
  \ DataIdx=0\n  - Return false if callee not recognized.\n- extractPointeeBaseRegion(const\
  \ Expr *PtrExpr, CheckerContext &C)\n  - Use getMemRegionFromExpr(PtrExpr, C) to\
  \ get region R.\n  - Resolve aliases by repeatedly looking up PtrAliasMap[R] until\
  \ fixed point; if any step yields a base VarRegion (the original struct region),\
  \ return it.\n  - If syntactically PtrExpr is UnaryOperator \u2018&\u2019 of a DeclRefExpr\
  \ to a VarDecl, also extract its VarRegion directly as a fallback.\n- isLocalStructVarRegion(const\
  \ MemRegion *R)\n  - Check R is a VarRegion whose VarDecl is a local variable (isLocalVarDeclOrParm()\
  \ && hasLocalStorage()) and its type is a RecordType.\n- getTypeSizeInBytes(QualType\
  \ QT, ASTContext &Ctx)\n  - Return (size_t) Ctx.getTypeSizeInChars(QT).getQuantity().\n\
  - evalSizeArgEqualsVarSize(const Expr *LenE, const VarRegion *VR, CheckerContext\
  \ &C)\n  - Evaluate len constant via EvaluateExprToInt(...). If success:\n    -\
  \ Compute var size via VR->getValueType() and ASTContext.\n    - Return true if\
  \ equal. Otherwise false.\n  - If evaluation fails, conservatively return false\
  \ (to avoid false positives).\n- markZeroedIfFullSize(const Expr *Dst, const Expr\
  \ *ValOrZero, const Expr *Len, CheckerContext &C)\n  - For memset-style:\n    -\
  \ Confirm ValOrZero evaluates to zero (EvaluateExprToInt or integer literal 0).\n\
  \    - Extract base region of Dst with extractPointeeBaseRegion.\n    - If base\
  \ region is a local struct and evalSizeArgEqualsVarSize(Len, VR, C) is true: set\
  \ ZeroedStructMap[VR]=true in state.\n\n3) Callbacks\n\n- checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const\n  - Track pointer aliases:\n   \
  \ - If Loc is a MemRegion (LHS) and Val is a loc::MemRegionVal (RHS), do:\n    \
  \  - Let L = LHS MemRegion; R = RHS MemRegion.\n      - Resolve base for R:\n  \
  \      - If PtrAliasMap contains R -> Base, then map L -> Base.\n        - Else\
  \ map L -> R (direct reference).\n    - This handles p = &opt; and p2 = p; by chaining\
  \ entries.\n  - Do not modify ZeroedStructMap here.\n\n- checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const\n  - Zeroing recognition:\n    - If isZeroingFunction(Call):\n\
  \      - For memset-like: Dst = arg0, Val = arg1, Len = arg2.\n      - For memzero_explicit/bzero-like:\
  \ Dst = arg0, Len = arg1 (Val is implicitly 0).\n      - Apply markZeroedIfFullSize(Dst,\
  \ Val/implicit0, Len, C) to set ZeroedStructMap[VR]=true.\n  - No reporting here.\n\
  \n- checkPreCall(const CallEvent &Call, CheckerContext &C) const\n  - Sink detection:\n\
  \    - unsigned LenIdx, DataIdx; if (!isUserCopySink(Call, LenIdx, DataIdx)) return;\n\
  \    - Get data expression De = Call.getArgExpr(DataIdx); len expression Le = Call.getArgExpr(LenIdx).\n\
  \    - Resolve base region VR = dyn_cast<VarRegion>(extractPointeeBaseRegion(De,\
  \ C)).\n    - If VR is null or not a local struct, return (we only flag local stack\
  \ structs).\n    - Check len matches sizeof of the struct: if !evalSizeArgEqualsVarSize(Le,\
  \ VR, C), return.\n    - Query ZeroedStructMap[VR]:\n      - If state has VR mapped\
  \ to true, OK, return.\n      - Otherwise (absent or false), emit bug:\n       \
  \ - Create error node via generateNonFatalErrorNode().\n        - Report with PathSensitiveBugReport:\
  \ \u201CStruct not zero-initialized before user copy (may leak stack data).\u201D\
  \n        - Attach range of the call (Call.getOriginExpr()) as location.\n\n4) Optional\
  \ syntactic aids (kept conservative to reduce false positives)\n\n- We intentionally\
  \ do NOT treat aggregate initializers (e.g., = {0}, designated inits) as \u201C\
  zeroed,\u201D because they may not clear padding/holes. Only explicit zeroing via\
  \ memset/memzero_explicit/bzero that covers sizeof(variable) qualifies.\n- We do\
  \ not warn if the copy size can\u2019t be evaluated or doesn\u2019t equal sizeof(variable).\
  \ This avoids false positives when only a subset is copied.\n\n5) Notes on robustness\
  \ and scope\n\n- This checker focuses on the common kernel pattern: stack struct\
  \ s; set some fields; nla_put(..., sizeof(s), &s) or copy_to_user(..., &s, sizeof(s))\
  \ without a prior full memset/memzero. It warns only when:\n  - Data argument resolves\
  \ to a local struct\u2019s address (directly or via tracked aliases), and\n  - The\
  \ size argument equals sizeof(the struct), and\n  - No qualifying zeroing call was\
  \ seen on that struct beforehand on the current path.\n- The maps are path-sensitive.\
  \ Aliases are tracked only through pointer-to-region bindings via checkBind, sufficient\
  \ for p = &s; p2 = p; patterns.\n\n6) Minimal bug report details\n\n- Short message:\
  \ \u201CCopying non-zeroed stack struct to user; zero it first.\u201D\n- Category:\
  \ Kernel Information Leak\n- Location: the sink call expression.\n- No need for\
  \ additional notes unless desired (e.g., point to last zeroing site if present)."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include \"llvm/ADT/SmallPtrSet.h\"\n#include <algorithm>\n#include <cstdint>\n\
  #include <memory>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// Program state maps:\n// - ZeroedStructMap: base region of a local\
  \ struct -> true if definitely fully zeroed to sizeof(struct)\n// - PtrAliasMap:\
  \ pointer region -> base pointee region (e.g., p -> VarRegion(s))\nREGISTER_MAP_WITH_PROGRAMSTATE(ZeroedStructMap,\
  \ const MemRegion*, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*,\
  \ const MemRegion*)\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall,\n\
  \                                        check::PostCall,\n                    \
  \                    check::Bind> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Copying non-zeroed\
  \ stack struct to user\", \"Kernel Information Leak\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const;\n\n   private:\n\n      // Helpers\n      static\
  \ bool isMemsetLike(const CallEvent &Call, CheckerContext &C);\n      static bool\
  \ isMemzeroLike(const CallEvent &Call, CheckerContext &C);\n\n      static bool\
  \ isUserCopySink(const CallEvent &Call, CheckerContext &C,\n                   \
  \              unsigned &LenIdx, unsigned &DataIdx);\n\n      static const MemRegion\
  \ *extractPointeeBaseRegion(const Expr *PtrExpr,\n                             \
  \                          CheckerContext &C);\n\n      static bool isLocalStructVarRegion(const\
  \ MemRegion *R);\n      static uint64_t getTypeSizeInBytes(QualType QT, ASTContext\
  \ &Ctx);\n\n      static bool evalSizeArgEqualsVarSize(const Expr *LenE,\n     \
  \                                      const VarRegion *VR,\n                  \
  \                         CheckerContext &C);\n\n      static bool evalExprIsZero(const\
  \ Expr *E, CheckerContext &C);\n\n      void markZeroedIfFullSize(const Expr *DstE,\n\
  \                                const Expr *LenE,\n                           \
  \     bool ImplicitZero,\n                                const Expr *ValE,\n  \
  \                              CheckerContext &C) const;\n\n      void reportLeakAtCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n};\n\n// Determine if the call is\
  \ memset-like (memset/__memset/__builtin_memset).\nbool SAGenTestChecker::isMemsetLike(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n  return ExprHasName(Origin, \"memset\", C)\
  \ ||\n         ExprHasName(Origin, \"__memset\", C) ||\n         ExprHasName(Origin,\
  \ \"__builtin_memset\", C);\n}\n\n// Determine if the call is memzero-like (memzero_explicit/bzero).\n\
  bool SAGenTestChecker::isMemzeroLike(const CallEvent &Call, CheckerContext &C) {\n\
  \  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n\
  \  return ExprHasName(Origin, \"memzero_explicit\", C) ||\n         ExprHasName(Origin,\
  \ \"bzero\", C);\n}\n\n// Identify sinks that copy data to user or netlink attribute\
  \ with explicit length and data pointer.\n// Returns true and sets LenIdx/DataIdx\
  \ if recognized.\nbool SAGenTestChecker::isUserCopySink(const CallEvent &Call, CheckerContext\
  \ &C,\n                                      unsigned &LenIdx, unsigned &DataIdx)\
  \ {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n\
  \n  // Order matters because ExprHasName checks for substring containment.\n  if\
  \ (ExprHasName(Origin, \"nla_put_64bit\", C)) {\n    if (Call.getNumArgs() >= 4)\
  \ {\n      LenIdx = 2; DataIdx = 3; return true;\n    }\n  }\n  if (ExprHasName(Origin,\
  \ \"nla_put\", C)) {\n    if (Call.getNumArgs() >= 4) {\n      LenIdx = 2; DataIdx\
  \ = 3; return true;\n    }\n  }\n  if (ExprHasName(Origin, \"__copy_to_user\", C))\
  \ {\n    if (Call.getNumArgs() >= 3) {\n      LenIdx = 2; DataIdx = 1; return true;\n\
  \    }\n  }\n  if (ExprHasName(Origin, \"copy_to_user_iter\", C)) {\n    if (Call.getNumArgs()\
  \ >= 3) {\n      LenIdx = 2; DataIdx = 1; return true;\n    }\n  }\n  if (ExprHasName(Origin,\
  \ \"copy_to_user\", C)) {\n    if (Call.getNumArgs() >= 3) {\n      LenIdx = 2;\
  \ DataIdx = 1; return true;\n    }\n  }\n  if (ExprHasName(Origin, \"_copy_to_iter\"\
  , C)) {\n    if (Call.getNumArgs() >= 2) {\n      LenIdx = 1; DataIdx = 0; return\
  \ true;\n    }\n  }\n  return false;\n}\n\n// Follow alias map to get the ultimate\
  \ base region (ideally a VarRegion of the struct).\nconst MemRegion *SAGenTestChecker::extractPointeeBaseRegion(const\
  \ Expr *PtrExpr,\n                                                            CheckerContext\
  \ &C) {\n  if (!PtrExpr)\n    return nullptr;\n\n  const MemRegion *MR = getMemRegionFromExpr(PtrExpr,\
  \ C);\n  if (!MR)\n    return nullptr;\n\n  MR = MR->getBaseRegion();\n  if (!MR)\n\
  \    return nullptr;\n\n  ProgramStateRef State = C.getState();\n  // Follow alias\
  \ chain: pointer region -> base pointee region.\n  const MemRegion *Cur = MR;\n\
  \  llvm::SmallPtrSet<const MemRegion*, 8> Visited;\n  while (true) {\n    if (!Cur)\n\
  \      break;\n    if (!Visited.insert(Cur).second)\n      break; // avoid cycles\n\
  \    const MemRegion *const *NextPtr = State->get<PtrAliasMap>(Cur);\n    if (!NextPtr)\n\
  \      break;\n    const MemRegion *Next = *NextPtr;\n    if (!Next)\n      break;\n\
  \    Cur = Next->getBaseRegion();\n  }\n  return Cur ? Cur->getBaseRegion() : nullptr;\n\
  }\n\nbool SAGenTestChecker::isLocalStructVarRegion(const MemRegion *R) {\n  if (!R)\n\
  \    return false;\n  const VarRegion *VR = dyn_cast<VarRegion>(R);\n  if (!VR)\n\
  \    return false;\n  const VarDecl *VD = dyn_cast<VarDecl>(VR->getDecl());\n  if\
  \ (!VD)\n    return false;\n  if (!VD->hasLocalStorage() || !VD->isLocalVarDecl())\n\
  \    return false;\n  QualType T = VD->getType();\n  return !T.isNull() && T->isRecordType();\n\
  }\n\nuint64_t SAGenTestChecker::getTypeSizeInBytes(QualType QT, ASTContext &Ctx)\
  \ {\n  if (QT.isNull())\n    return 0;\n  return Ctx.getTypeSizeInChars(QT).getQuantity();\n\
  }\n\nbool SAGenTestChecker::evalSizeArgEqualsVarSize(const Expr *LenE,\n       \
  \                                         const VarRegion *VR,\n               \
  \                                 CheckerContext &C) {\n  if (!LenE || !VR)\n  \
  \  return false;\n  llvm::APSInt Res;\n  if (!EvaluateExprToInt(Res, LenE, C))\n\
  \    return false;\n\n  const VarDecl *VD = dyn_cast<VarDecl>(VR->getDecl());\n\
  \  if (!VD)\n    return false;\n  uint64_t VarSize = getTypeSizeInBytes(VD->getType(),\
  \ C.getASTContext());\n\n  // Compare as unsigned\n  uint64_t LenVal = Res.isSigned()\
  \ ? Res.getSExtValue() : Res.getZExtValue();\n  return LenVal == VarSize;\n}\n\n\
  bool SAGenTestChecker::evalExprIsZero(const Expr *E, CheckerContext &C) {\n  if\
  \ (!E)\n    return false;\n  llvm::APSInt Res;\n  if (!EvaluateExprToInt(Res, E,\
  \ C))\n    return false;\n  return Res == 0;\n}\n\n// If destination points to a\
  \ local struct, and the length equals sizeof(struct),\n// and the value is zero\
  \ (or implicit zero), mark the struct as zeroed.\nvoid SAGenTestChecker::markZeroedIfFullSize(const\
  \ Expr *DstE,\n                                            const Expr *LenE,\n \
  \                                           bool ImplicitZero,\n               \
  \                             const Expr *ValE,\n                              \
  \              CheckerContext &C) const {\n  if (!DstE || !LenE)\n    return;\n\n\
  \  if (!ImplicitZero) {\n    if (!ValE)\n      return;\n    if (!evalExprIsZero(ValE,\
  \ C))\n      return;\n  }\n\n  const MemRegion *Base = extractPointeeBaseRegion(DstE,\
  \ C);\n  if (!Base)\n    return;\n  const VarRegion *VR = dyn_cast<VarRegion>(Base);\n\
  \  if (!VR)\n    return;\n\n  if (!isLocalStructVarRegion(VR))\n    return;\n\n\
  \  if (!evalSizeArgEqualsVarSize(LenE, VR, C))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  State = State->set<ZeroedStructMap>(VR, true);\n  C.addTransition(State);\n\
  }\n\n// Track pointer aliasing: if LHS is a pointer var and RHS is &struct or another\
  \ pointer alias,\n// map LHS region -> ultimate base pointee region.\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\
  \ {\n    C.addTransition(State);\n    return;\n  }\n  LHSReg = LHSReg->getBaseRegion();\n\
  \  if (!LHSReg) {\n    C.addTransition(State);\n    return;\n  }\n\n  const MemRegion\
  \ *RReg = Val.getAsRegion();\n  if (!RReg) {\n    // We could drop the alias, but\
  \ keep it simple: do nothing.\n    C.addTransition(State);\n    return;\n  }\n \
  \ RReg = RReg->getBaseRegion();\n  if (!RReg) {\n    C.addTransition(State);\n \
  \   return;\n  }\n\n  // Resolve RHS to ultimate base if it's already an alias.\n\
  \  const MemRegion *Ultimate = RReg;\n  llvm::SmallPtrSet<const MemRegion*, 8> Visited;\n\
  \  while (true) {\n    if (!Ultimate)\n      break;\n    if (!Visited.insert(Ultimate).second)\n\
  \      break;\n    const MemRegion *const *NextPtr = State->get<PtrAliasMap>(Ultimate);\n\
  \    if (!NextPtr)\n      break;\n    const MemRegion *Next = *NextPtr;\n    if\
  \ (!Next)\n      break;\n    Ultimate = Next->getBaseRegion();\n  }\n\n  State =\
  \ State->set<PtrAliasMap>(LHSReg, Ultimate);\n  C.addTransition(State);\n}\n\n//\
  \ Post-call: detect zeroing operations and mark structs as fully zeroed.\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (isMemsetLike(Call, C)) {\n\
  \    if (Call.getNumArgs() >= 3) {\n      const Expr *DstE = Call.getArgExpr(0);\n\
  \      const Expr *ValE = Call.getArgExpr(1);\n      const Expr *LenE = Call.getArgExpr(2);\n\
  \      markZeroedIfFullSize(DstE, LenE, false, ValE, C);\n    }\n    return;\n \
  \ }\n\n  if (isMemzeroLike(Call, C)) {\n    if (Call.getNumArgs() >= 2) {\n    \
  \  const Expr *DstE = Call.getArgExpr(0);\n      const Expr *LenE = Call.getArgExpr(1);\n\
  \      markZeroedIfFullSize(DstE, LenE, true, nullptr, C);\n    }\n    return;\n\
  \  }\n}\n\n// Pre-call: report if copying a local stack struct by sizeof(struct)\
  \ without prior zeroing.\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  unsigned LenIdx = 0, DataIdx = 0;\n  if (!isUserCopySink(Call,\
  \ C, LenIdx, DataIdx))\n    return;\n\n  if (Call.getNumArgs() <= std::max(LenIdx,\
  \ DataIdx))\n    return;\n\n  const Expr *DataE = Call.getArgExpr(DataIdx);\n  const\
  \ Expr *LenE = Call.getArgExpr(LenIdx);\n  if (!DataE || !LenE)\n    return;\n\n\
  \  const MemRegion *Base = extractPointeeBaseRegion(DataE, C);\n  if (!Base)\n \
  \   return;\n\n  const VarRegion *VR = dyn_cast<VarRegion>(Base);\n  if (!VR)\n\
  \    return;\n\n  if (!isLocalStructVarRegion(VR))\n    return;\n\n  if (!evalSizeArgEqualsVarSize(LenE,\
  \ VR, C))\n    return;\n\n  ProgramStateRef State = C.getState();\n  const bool\
  \ *Zeroed = State->get<ZeroedStructMap>(VR);\n  // If not marked as zeroed, warn.\n\
  \  if (!(Zeroed && *Zeroed)) {\n    reportLeakAtCall(Call, C);\n  }\n}\n\nvoid SAGenTestChecker::reportLeakAtCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Copying non-zeroed stack struct to user; zero it first.\", N);\n \
  \ if (const Expr *E = Call.getOriginExpr())\n    R->addRange(E->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects copying of partially-initialized\
  \ stack structs to user space without zeroing\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
