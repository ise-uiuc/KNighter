_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 81137162bfaa7278785b24c1fd2e9e74f082e8e4
commit_type: Buffer-Overflow
index: 7
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states are needed for this pattern.\n\nnamespace {\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unbounded string\
  \ copy to fixed-size buffer\", \"Security\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n      bool isStrcpyCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n      // Extract fixed array size\
  \ and element type from a struct/union field used as expression E.\n      bool getFixedArraySizeFromStructField(const\
  \ Expr *E, CheckerContext &C,\n                                            llvm::APInt\
  \ &Size, QualType &ElemTy) const;\n\n      // Returns true if the element type is\
  \ char/signed char/unsigned char (after canonicalization).\n      bool isCharLikeType(QualType\
  \ T) const;\n\n      // Try to get a constant array size from an arbitrary expression\
  \ (decl ref or member expr).\n      bool getConstArraySizeFromExpr(const Expr *E,\
  \ CheckerContext &C, llvm::APInt &Size) const;\n\n      void reportStrcpyOverflow(const\
  \ CallEvent &Call, CheckerContext &C, bool Definite) const;\n};\n\nbool SAGenTestChecker::isStrcpyCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n  // Use the provided helper to match the\
  \ callee name.\n  return ExprHasName(OriginExpr, \"strcpy\", C);\n}\n\nbool SAGenTestChecker::isCharLikeType(QualType\
  \ T) const {\n  QualType CT = T.getCanonicalType().getUnqualifiedType();\n  return\
  \ CT->isCharType() || CT->isSignedCharType() || CT->isUnsignedCharType();\n}\n\n\
  bool SAGenTestChecker::getFixedArraySizeFromStructField(const Expr *E, CheckerContext\
  \ &C,\n                                                        llvm::APInt &Size,\
  \ QualType &ElemTy) const {\n  if (!E)\n    return false;\n\n  // Find the underlying\
  \ MemberExpr (e.g., di.name) in the expression.\n  const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(E);\n\
  \  if (!ME)\n    return false;\n\n  const ValueDecl *VD = ME->getMemberDecl();\n\
  \  const FieldDecl *FD = dyn_cast<FieldDecl>(VD);\n  if (!FD)\n    return false;\n\
  \n  QualType FT = FD->getType();\n  const ConstantArrayType *CAT = C.getASTContext().getAsConstantArrayType(FT);\n\
  \  if (!CAT)\n    return false;\n\n  ElemTy = CAT->getElementType();\n  Size = CAT->getSize();\n\
  \  return true;\n}\n\nbool SAGenTestChecker::getConstArraySizeFromExpr(const Expr\
  \ *E, CheckerContext &C, llvm::APInt &Size) const {\n  if (!E)\n    return false;\n\
  \n  // First try the helper for DeclRefExpr-based arrays.\n  if (getArraySizeFromExpr(Size,\
  \ E))\n    return true;\n\n  // If that fails, try to see if it's a struct/union\
  \ field with constant array type.\n  const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(E);\n\
  \  if (!ME)\n    return false;\n\n  const ValueDecl *VD = ME->getMemberDecl();\n\
  \  const FieldDecl *FD = dyn_cast<FieldDecl>(VD);\n  if (!FD)\n    return false;\n\
  \n  const ConstantArrayType *CAT = C.getASTContext().getAsConstantArrayType(FD->getType());\n\
  \  if (!CAT)\n    return false;\n\n  Size = CAT->getSize();\n  return true;\n}\n\
  \nvoid SAGenTestChecker::reportStrcpyOverflow(const CallEvent &Call, CheckerContext\
  \ &C, bool Definite) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  const char *Msg = Definite\n                      \
  \  ? \"strcpy overflows fixed-size field\"\n                        : \"strcpy into\
  \ fixed-size struct field may overflow; use strscpy(..., sizeof(dest))\";\n\n  auto\
  \ R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n  R->addRange(Call.getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  if (!isStrcpyCall(Call, C))\n    return;\n\
  \n  if (Call.getNumArgs() < 2)\n    return;\n\n  const Expr *DestArg = Call.getArgExpr(0);\n\
  \  const Expr *SrcArg  = Call.getArgExpr(1);\n  if (!DestArg || !SrcArg)\n    return;\n\
  \n  // Destination must be a struct/union field that is a constant-size char array.\n\
  \  llvm::APInt DestSize;\n  QualType DestElemTy;\n  if (!getFixedArraySizeFromStructField(DestArg,\
  \ C, DestSize, DestElemTy))\n    return;\n\n  if (!isCharLikeType(DestElemTy))\n\
  \    return;\n\n  // Analyze source.\n  // 1) If it's a string literal, check if\
  \ it fits (including NUL terminator).\n  llvm::APInt StrLen;\n  if (getStringSize(StrLen,\
  \ SrcArg)) {\n    uint64_t Required = StrLen.getZExtValue() + 1; // include NUL\n\
  \    uint64_t DstCap = DestSize.getZExtValue();\n    if (Required > DstCap) {\n\
  \      // Definite overflow\n      reportStrcpyOverflow(Call, C, /*Definite=*/true);\n\
  \    }\n    return; // Literal fits or overflow already reported.\n  }\n\n  // 2)\
  \ If source has a known constant array bound and it's larger than dest, report possible\
  \ overflow.\n  llvm::APInt SrcSize;\n  if (getConstArraySizeFromExpr(SrcArg, C,\
  \ SrcSize)) {\n    uint64_t SrcCap = SrcSize.getZExtValue();\n    uint64_t DstCap\
  \ = DestSize.getZExtValue();\n    if (SrcCap > DstCap) {\n      // Likely overflow\
  \ because src capacity exceeds dest capacity.\n      reportStrcpyOverflow(Call,\
  \ C, /*Definite=*/false);\n    }\n    return;\n  }\n\n  // 3) Otherwise, unknown/unbounded\
  \ source copied via strcpy into fixed-size field: report possible overflow.\n  reportStrcpyOverflow(Call,\
  \ C, /*Definite=*/false);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects strcpy into fixed-size struct\
  \ field; suggest using strscpy with sizeof(dest)\",\n      \"\");\n}\n\nextern \"\
  C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: hci_core: Fix possible buffer overflow\n\
  \nstruct hci_dev_info has a fixed size name[8] field so in the event that\nhdev->name\
  \ is bigger than that strcpy would attempt to write past its\nsize, so this fixes\
  \ this problem by switching to use strscpy.\n\nFixes: dcda165706b9 (\"Bluetooth:\
  \ hci_core: Fix build warnings\")\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\n\
  \n## Buggy Code\n\n```c\n// Function: hci_get_dev_info in net/bluetooth/hci_core.c\n\
  int hci_get_dev_info(void __user *arg)\n{\n\tstruct hci_dev *hdev;\n\tstruct hci_dev_info\
  \ di;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (copy_from_user(&di, arg,\
  \ sizeof(di)))\n\t\treturn -EFAULT;\n\n\thdev = hci_dev_get(di.dev_id);\n\tif (!hdev)\n\
  \t\treturn -ENODEV;\n\n\t/* When the auto-off is configured it means the transport\n\
  \t * is running, but in that case still indicate that the\n\t * device is actually\
  \ down.\n\t */\n\tif (hci_dev_test_flag(hdev, HCI_AUTO_OFF))\n\t\tflags = hdev->flags\
  \ & ~BIT(HCI_UP);\n\telse\n\t\tflags = hdev->flags;\n\n\tstrcpy(di.name, hdev->name);\n\
  \tdi.bdaddr   = hdev->bdaddr;\n\tdi.type     = (hdev->bus & 0x0f) | ((hdev->dev_type\
  \ & 0x03) << 4);\n\tdi.flags    = flags;\n\tdi.pkt_type = hdev->pkt_type;\n\tif\
  \ (lmp_bredr_capable(hdev)) {\n\t\tdi.acl_mtu  = hdev->acl_mtu;\n\t\tdi.acl_pkts\
  \ = hdev->acl_pkts;\n\t\tdi.sco_mtu  = hdev->sco_mtu;\n\t\tdi.sco_pkts = hdev->sco_pkts;\n\
  \t} else {\n\t\tdi.acl_mtu  = hdev->le_mtu;\n\t\tdi.acl_pkts = hdev->le_pkts;\n\t\
  \tdi.sco_mtu  = 0;\n\t\tdi.sco_pkts = 0;\n\t}\n\tdi.link_policy = hdev->link_policy;\n\
  \tdi.link_mode   = hdev->link_mode;\n\n\tmemcpy(&di.stat, &hdev->stat, sizeof(di.stat));\n\
  \tmemcpy(&di.features, &hdev->features, sizeof(di.features));\n\n\tif (copy_to_user(arg,\
  \ &di, sizeof(di)))\n\t\terr = -EFAULT;\n\n\thci_dev_put(hdev);\n\n\treturn err;\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c\n\
  index 6ca4c0df9f9c..230d2bbb933b 100644\n--- a/net/bluetooth/hci_core.c\n+++ b/net/bluetooth/hci_core.c\n\
  @@ -908,7 +908,7 @@ int hci_get_dev_info(void __user *arg)\n \telse\n \t\tflags\
  \ = hdev->flags;\n \n-\tstrcpy(di.name, hdev->name);\n+\tstrscpy(di.name, hdev->name,\
  \ sizeof(di.name));\n \tdi.bdaddr   = hdev->bdaddr;\n \tdi.type     = (hdev->bus\
  \ & 0x0f) | ((hdev->dev_type & 0x03) << 4);\n \tdi.flags    = flags;\n```\n"
pattern: '## Bug Pattern


  Using an unbounded string copy (strcpy) to copy a variable-length source into a
  fixed-size destination buffer within a struct, without checking the destination
  size. Example: strcpy(di.name, hdev->name) where di.name is a small fixed array
  (name[8]) and hdev->name may be longer, causing buffer overflow. The correct pattern
  is to use a bounded copy (e.g., strscpy(dest, src, sizeof(dest))).'
plan: "Plan\n\n1) Program state\n- No custom program state is needed. This is a local,\
  \ call-site pattern: detect unbounded copy into a fixed-size struct field and report\
  \ immediately when found.\n\n2) Callback functions\n- Use only checkPreCall. This\
  \ is sufficient to inspect the function call, extract the destination/source, reason\
  \ about sizes, and report.\n\n3) checkPreCall (detailed steps)\n- Identify target\
  \ calls:\n  - Get the callee identifier via Call.getCalleeIdentifier().\n  - If\
  \ the name equals \"strcpy\", proceed; otherwise return.\n\n- Validate argument\
  \ count:\n  - Ensure there are at least 2 arguments (dest, src). If not, return.\n\
  \n- Extract and analyze the destination argument (dest):\n  - Let DestArg = Call.getArgExpr(0).\n\
  \  - Goal: Confirm dest is a struct/union field of constant array type (the bug\
  \ pattern).\n  - Use findSpecificTypeInChildren<MemberExpr>(DestArg) to find the\
  \ MemberExpr that represents the field access (e.g., di.name).\n    - If not found,\
  \ do not report (we only target fixed-size struct/union fields).\n  - From MemberExpr,\
  \ get the FieldDecl (FD) via getMemberDecl().\n  - Obtain the canonical type of\
  \ the field: QualType FT = FD->getType().\n    - Check if FT is a ConstantArrayType.\
  \ If not, return (we only target fixed-size arrays).\n    - If ConstantArrayType\
  \ (CAT), record:\n      - DestElemTy = CAT->getElementType().\n      - DestSize\
  \ = CAT->getSize() (llvm::APInt).\n    - Optionally restrict to character arrays:\n\
  \      - If DestElemTy is not a char-like type (BuiltinType::Char_S, Char_U, SChar,\
  \ UChar, or typedef that resolves to char), return. Otherwise proceed.\n\n- Extract\
  \ and analyze the source argument (src):\n  - Let SrcArg = Call.getArgExpr(1).\n\
  \  - Try to compute a definite-safe case first:\n    - If SrcArg is a StringLiteral\
  \ (use getStringSize utility on SrcArg):\n      - Let SL = string length (without\
  \ null terminator).\n      - Required = SL + 1 (for the null terminator).\n    \
  \  - If Required <= DestSize, then it\u2019s provably safe; return without reporting.\n\
  \      - Else, report a definite overflow (see Reporting below).\n  - If not a StringLiteral,\
  \ try to get an upper-bound estimate from a fixed array source:\n    - Attempt to\
  \ find MemberExpr for SrcArg: ME2 = findSpecificTypeInChildren<MemberExpr>(SrcArg).\n\
  \      - If ME2 exists and refers to a FieldDecl whose type is ConstantArrayType,\
  \ extract SrcSize = CAT2->getSize().\n      - If SrcSize > DestSize, report (likely\
  \ overflow).\n    - Else, attempt to get a fixed size from a local/global array\
  \ source:\n      - Use getArraySizeFromExpr on SrcArg. If it returns a size SrcSize\
  \ and SrcSize > DestSize, report (likely overflow).\n  - If the source is neither\
  \ a fitting StringLiteral nor a fixed array with known size:\n    - It is an unbounded/unknown-length\
  \ source copied into a fixed-size struct field with strcpy. Report a potential overflow\
  \ and suggest bounded copy.\n\n- Reporting\n  - Create a BugType once (e.g., in\
  \ the checker constructor or lazily) named \"Unbounded string copy to fixed-size\
  \ buffer\".\n  - Generate a non-fatal error node via C.generateNonFatalErrorNode().\n\
  \  - Build a PathSensitiveBugReport:\n    - Message:\n      - If StringLiteral too\
  \ long: \"strcpy overflows fixed-size field\".\n      - Else: \"strcpy into fixed-size\
  \ struct field may overflow; use strscpy(..., sizeof(dest))\".\n    - Add the source\
  \ range of the call, and optionally the dest argument range, as the report location.\n\
  \  - Emit report via C.emitReport(...).\n\n4) Helper routines (internal to the checker)\n\
  - bool isStrcpyCall(const CallEvent &Call):\n  - Return true if Call.getCalleeIdentifier()\
  \ exists and name equals \"strcpy\".\n- bool getFixedArraySizeFromStructField(const\
  \ Expr *E, llvm::APInt &Size, QualType &ElemTy):\n  - Use findSpecificTypeInChildren<MemberExpr>(E).\n\
  \  - If found and FieldDecl type is ConstantArrayType, set Size and ElemTy and return\
  \ true. Else return false.\n- bool isCharArrayType(QualType ElemTy):\n  - Return\
  \ true if ElemTy is (canonical) character type: Char_S, Char_U, SChar, UChar, or\
  \ typedef resolving to these.\n- Optional: bool getConstArraySizeFromExpr(const\
  \ Expr *E, llvm::APInt &Size):\n  - First try getArraySizeFromExpr(Size, E) using\
  \ the provided utility (works for DeclRefExpr to arrays).\n  - If that fails, try\
  \ MemberExpr path similarly to the destination.\n\n5) Heuristics to reduce false\
  \ positives\n- Only report when destination is a struct/union field of fixed-size\
  \ char array (matches the target pattern).\n- Suppress reports if source is a StringLiteral\
  \ that fits (stringLen + 1 <= destSize).\n- Otherwise, conservatively report when\
  \ the source is unknown or has a known larger bound.\n\n6) Chosen callbacks summary\n\
  - checkPreCall:\n  - Detect calls to strcpy.\n  - Determine if dest is a fixed-size\
  \ struct field array.\n  - If so, assess source length/upper bound (StringLiteral\
  \ or array bound).\n  - Report if overflow is definite or possible.\n- No other\
  \ callbacks are required."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states are needed for this pattern.\n\nnamespace {\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unbounded string\
  \ copy to fixed-size buffer\", \"Security\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n      bool isStrcpyCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n      // Extract fixed array size\
  \ and element type from a struct/union field used as expression E.\n      bool getFixedArraySizeFromStructField(const\
  \ Expr *E, CheckerContext &C,\n                                            llvm::APInt\
  \ &Size, QualType &ElemTy) const;\n\n      // Returns true if the element type is\
  \ char/signed char/unsigned char (after canonicalization).\n      bool isCharLikeType(QualType\
  \ T) const;\n\n      // Try to get a constant array size from an arbitrary expression\
  \ (decl ref or member expr).\n      bool getConstArraySizeFromExpr(const Expr *E,\
  \ CheckerContext &C, llvm::APInt &Size) const;\n\n      void reportStrcpyOverflow(const\
  \ CallEvent &Call, CheckerContext &C, bool Definite) const;\n};\n\nbool SAGenTestChecker::isStrcpyCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n  // Use the provided helper to match the\
  \ callee name.\n  return ExprHasName(OriginExpr, \"strcpy\", C);\n}\n\nbool SAGenTestChecker::isCharLikeType(QualType\
  \ T) const {\n  QualType CT = T.getCanonicalType().getUnqualifiedType();\n  if (const\
  \ auto *BTy = dyn_cast<BuiltinType>(CT.getTypePtr())) {\n    switch (BTy->getKind())\
  \ {\n    case BuiltinType::Char_S:\n    case BuiltinType::Char_U:\n    case BuiltinType::SChar:\n\
  \    case BuiltinType::UChar:\n      return true;\n    default:\n      break;\n\
  \    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getFixedArraySizeFromStructField(const\
  \ Expr *E, CheckerContext &C,\n                                                \
  \        llvm::APInt &Size, QualType &ElemTy) const {\n  if (!E)\n    return false;\n\
  \n  // Find the underlying MemberExpr (e.g., di.name) in the expression.\n  const\
  \ MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(E);\n  if (!ME)\n    return\
  \ false;\n\n  const ValueDecl *VD = ME->getMemberDecl();\n  const FieldDecl *FD\
  \ = dyn_cast<FieldDecl>(VD);\n  if (!FD)\n    return false;\n\n  QualType FT = FD->getType();\n\
  \  const ConstantArrayType *CAT = C.getASTContext().getAsConstantArrayType(FT);\n\
  \  if (!CAT)\n    return false;\n\n  ElemTy = CAT->getElementType();\n  Size = CAT->getSize();\n\
  \  return true;\n}\n\nbool SAGenTestChecker::getConstArraySizeFromExpr(const Expr\
  \ *E, CheckerContext &C, llvm::APInt &Size) const {\n  if (!E)\n    return false;\n\
  \n  // First try the helper for DeclRefExpr-based arrays.\n  if (getArraySizeFromExpr(Size,\
  \ E))\n    return true;\n\n  // If that fails, try to see if it's a struct/union\
  \ field with constant array type.\n  const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(E);\n\
  \  if (!ME)\n    return false;\n\n  const ValueDecl *VD = ME->getMemberDecl();\n\
  \  const FieldDecl *FD = dyn_cast<FieldDecl>(VD);\n  if (!FD)\n    return false;\n\
  \n  const ConstantArrayType *CAT = C.getASTContext().getAsConstantArrayType(FD->getType());\n\
  \  if (!CAT)\n    return false;\n\n  Size = CAT->getSize();\n  return true;\n}\n\
  \nvoid SAGenTestChecker::reportStrcpyOverflow(const CallEvent &Call, CheckerContext\
  \ &C, bool Definite) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  const char *Msg = Definite\n                      \
  \  ? \"strcpy overflows fixed-size field\"\n                        : \"strcpy into\
  \ fixed-size struct field may overflow; use strscpy(..., sizeof(dest))\";\n\n  auto\
  \ R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n  R->addRange(Call.getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  if (!isStrcpyCall(Call, C))\n    return;\n\
  \n  if (Call.getNumArgs() < 2)\n    return;\n\n  const Expr *DestArg = Call.getArgExpr(0);\n\
  \  const Expr *SrcArg  = Call.getArgExpr(1);\n  if (!DestArg || !SrcArg)\n    return;\n\
  \n  // Destination must be a struct/union field that is a constant-size char array.\n\
  \  llvm::APInt DestSize;\n  QualType DestElemTy;\n  if (!getFixedArraySizeFromStructField(DestArg,\
  \ C, DestSize, DestElemTy))\n    return;\n\n  if (!isCharLikeType(DestElemTy))\n\
  \    return;\n\n  // Analyze source.\n  // 1) If it's a string literal, check if\
  \ it fits (including NUL terminator).\n  llvm::APInt StrLen;\n  if (getStringSize(StrLen,\
  \ SrcArg)) {\n    uint64_t Required = StrLen.getZExtValue() + 1; // include NUL\n\
  \    uint64_t DstCap = DestSize.getZExtValue();\n    if (Required > DstCap) {\n\
  \      // Definite overflow\n      reportStrcpyOverflow(Call, C, /*Definite=*/true);\n\
  \    }\n    return; // Literal fits or overflow already reported.\n  }\n\n  // 2)\
  \ If source has a known constant array bound and it's larger than dest, report possible\
  \ overflow.\n  llvm::APInt SrcSize;\n  if (getConstArraySizeFromExpr(SrcArg, C,\
  \ SrcSize)) {\n    uint64_t SrcCap = SrcSize.getZExtValue();\n    uint64_t DstCap\
  \ = DestSize.getZExtValue();\n    if (SrcCap > DstCap) {\n      // Likely overflow\
  \ because src capacity exceeds dest capacity.\n      reportStrcpyOverflow(Call,\
  \ C, /*Definite=*/false);\n    }\n    return;\n  }\n\n  // 3) Otherwise, unknown/unbounded\
  \ source copied via strcpy into fixed-size field: report possible overflow.\n  reportStrcpyOverflow(Call,\
  \ C, /*Definite=*/false);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects strcpy into fixed-size struct\
  \ field; suggest using strscpy with sizeof(dest)\",\n      \"\");\n}\n\nextern \"\
  C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
