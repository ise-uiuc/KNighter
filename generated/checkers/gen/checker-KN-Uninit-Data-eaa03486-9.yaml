_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: eaa03486d932572dfd1c5f64f9dfebe572ad88c0
commit_type: Uninit-Data
index: 9
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include <string>\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// Program state map to track whether\
  \ a local \"status\" variable has been initialized.\nREGISTER_MAP_WITH_PROGRAMSTATE(StatusVarInitMap,\
  \ const VarDecl *, bool)\n\nnamespace {\n\nclass SAGenTestChecker\n    : public\
  \ Checker<\n          check::PostStmt<DeclStmt>, // Seed tracking on local declarations\n\
  \          check::Bind,               // Mark as initialized on assignments\n  \
  \        check::PreStmt<ReturnStmt> // Warn on returning uninitialized var\n   \
  \       > {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n\
  \      : BT(new BugType(this, \"Uninitialized status return\", \"Logic error\"))\
  \ {}\n\n  void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;\n  void\
  \ checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n  void\
  \ checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;\n\nprivate:\n  static\
  \ bool shouldTrackVar(const VarDecl *VD);\n};\n\nbool SAGenTestChecker::shouldTrackVar(const\
  \ VarDecl *VD) {\n  if (!VD)\n    return false;\n\n  // Only track automatic local\
  \ non-static variables.\n  if (!VD->hasLocalStorage() || VD->isStaticLocal())\n\
  \    return false;\n\n  QualType T = VD->getType();\n  // Restrict to integer-like\
  \ scalar \"status\" candidates.\n  if (!(T->isIntegerType() || T->isEnumeralType()\
  \ || T->isBooleanType()))\n    return false;\n\n  return true;\n}\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  for (const Decl *D : DS->decls()) {\n    const auto *VD = dyn_cast<VarDecl>(D);\n\
  \    if (!VD)\n      continue;\n\n    if (!shouldTrackVar(VD))\n      continue;\n\
  \n    // Initialize tracking: true if it has an initializer, otherwise false.\n\
  \    bool IsInitialized = VD->hasInit();\n    State = State->set<StatusVarInitMap>(VD,\
  \ IsInitialized);\n  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal /*Val*/, const Stmt * /*S*/,\n                                 CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *MR\
  \ = Loc.getAsRegion();\n  if (!MR)\n    return;\n\n  MR = MR->getBaseRegion();\n\
  \  if (!MR)\n    return;\n\n  const auto *VR = dyn_cast<VarRegion>(MR);\n  if (!VR)\n\
  \    return;\n\n  const VarDecl *VD = VR->getDecl();\n  if (!VD)\n    return;\n\n\
  \  // If we are tracking this variable, mark it as initialized on this path.\n \
  \ if (State->contains<StatusVarInitMap>(VD)) {\n    State = State->set<StatusVarInitMap>(VD,\
  \ true);\n    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::checkPreStmt(const\
  \ ReturnStmt *RS, CheckerContext &C) const {\n  const Expr *RetE = RS->getRetValue();\n\
  \  if (!RetE)\n    return;\n\n  RetE = RetE->IgnoreParenImpCasts();\n\n  const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(RetE);\n  if (!DRE)\n    return;\n\n  const auto\
  \ *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n    return;\n\n  // Only\
  \ consider tracked variables.\n  ProgramStateRef State = C.getState();\n  const\
  \ bool *IsInit = State->get<StatusVarInitMap>(VD);\n  if (!IsInit)\n    return;\n\
  \n  if (!*IsInit) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n    if\
  \ (!N)\n      return;\n\n    std::string VarName = VD->getNameAsString();\n    if\
  \ (VarName.empty())\n      VarName = \"<status>\";\n\n    auto Report = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Returning uninitialized status variable '\" + VarName + \"'.\",\
  \ N);\n    Report->addRange(RetE->getSourceRange());\n    C.emitReport(std::move(Report));\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects returning an uninitialized local status variable (e.g., 'int\
  \ ret;')\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nregmap: maple: Fix uninitialized symbol 'ret' warnings\n\
  \nFix warnings reported by smatch by initializing local 'ret' variable\nto 0.\n\n\
  drivers/base/regmap/regcache-maple.c:186 regcache_maple_drop()\nerror: uninitialized\
  \ symbol 'ret'.\ndrivers/base/regmap/regcache-maple.c:290 regcache_maple_sync()\n\
  error: uninitialized symbol 'ret'.\n\nSigned-off-by: Richard Fitzgerald <rf@opensource.cirrus.com>\n\
  Fixes: f033c26de5a5 (\"regmap: Add maple tree based register cache\")\nLink: https://lore.kernel.org/r/20240329144630.1965159-1-rf@opensource.cirrus.com\n\
  Signed-off-by: Mark Brown <broonie@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ regcache_maple_drop in drivers/base/regmap/regcache-maple.c\nstatic int regcache_maple_drop(struct\
  \ regmap *map, unsigned int min,\n\t\t\t       unsigned int max)\n{\n\tstruct maple_tree\
  \ *mt = map->cache;\n\tMA_STATE(mas, mt, min, max);\n\tunsigned long *entry, *lower,\
  \ *upper;\n\tunsigned long lower_index, lower_last;\n\tunsigned long upper_index,\
  \ upper_last;\n\tint ret;\n\n\tlower = NULL;\n\tupper = NULL;\n\n\tmas_lock(&mas);\n\
  \n\tmas_for_each(&mas, entry, max) {\n\t\t/*\n\t\t * This is safe because the regmap\
  \ lock means the\n\t\t * Maple lock is redundant, but we need to take it due\n\t\
  \t * to lockdep asserts in the maple tree code.\n\t\t */\n\t\tmas_unlock(&mas);\n\
  \n\t\t/* Do we need to save any of this entry? */\n\t\tif (mas.index < min) {\n\t\
  \t\tlower_index = mas.index;\n\t\t\tlower_last = min -1;\n\n\t\t\tlower = kmemdup(entry,\
  \ ((min - mas.index) *\n\t\t\t\t\t\tsizeof(unsigned long)),\n\t\t\t\t\tmap->alloc_flags);\n\
  \t\t\tif (!lower) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_unlocked;\n\t\t\t\
  }\n\t\t}\n\n\t\tif (mas.last > max) {\n\t\t\tupper_index = max + 1;\n\t\t\tupper_last\
  \ = mas.last;\n\n\t\t\tupper = kmemdup(&entry[max - mas.index + 1],\n\t\t\t\t\t\
  ((mas.last - max) *\n\t\t\t\t\t sizeof(unsigned long)),\n\t\t\t\t\tmap->alloc_flags);\n\
  \t\t\tif (!upper) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_unlocked;\n\t\t\t\
  }\n\t\t}\n\n\t\tkfree(entry);\n\t\tmas_lock(&mas);\n\t\tmas_erase(&mas);\n\n\t\t\
  /* Insert new nodes with the saved data */\n\t\tif (lower) {\n\t\t\tmas_set_range(&mas,\
  \ lower_index, lower_last);\n\t\t\tret = mas_store_gfp(&mas, lower, map->alloc_flags);\n\
  \t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tlower = NULL;\n\t\t}\n\n\t\tif (upper)\
  \ {\n\t\t\tmas_set_range(&mas, upper_index, upper_last);\n\t\t\tret = mas_store_gfp(&mas,\
  \ upper, map->alloc_flags);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tupper\
  \ = NULL;\n\t\t}\n\t}\n\nout:\n\tmas_unlock(&mas);\nout_unlocked:\n\tkfree(lower);\n\
  \tkfree(upper);\n\n\treturn ret;\n}\n```\n\n```c\n// Function: regcache_maple_sync\
  \ in drivers/base/regmap/regcache-maple.c\nstatic int regcache_maple_sync(struct\
  \ regmap *map, unsigned int min,\n\t\t\t       unsigned int max)\n{\n\tstruct maple_tree\
  \ *mt = map->cache;\n\tunsigned long *entry;\n\tMA_STATE(mas, mt, min, max);\n\t\
  unsigned long lmin = min;\n\tunsigned long lmax = max;\n\tunsigned int r, v, sync_start;\n\
  \tint ret;\n\tbool sync_needed = false;\n\n\tmap->cache_bypass = true;\n\n\trcu_read_lock();\n\
  \n\tmas_for_each(&mas, entry, max) {\n\t\tfor (r = max(mas.index, lmin); r <= min(mas.last,\
  \ lmax); r++) {\n\t\t\tv = entry[r - mas.index];\n\n\t\t\tif (regcache_reg_needs_sync(map,\
  \ r, v)) {\n\t\t\t\tif (!sync_needed) {\n\t\t\t\t\tsync_start = r;\n\t\t\t\t\tsync_needed\
  \ = true;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!sync_needed)\n\t\t\
  \t\tcontinue;\n\n\t\t\tret = regcache_maple_sync_block(map, entry, &mas,\n\t\t\t\
  \t\t\t\tsync_start, r);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tsync_needed\
  \ = false;\n\t\t}\n\n\t\tif (sync_needed) {\n\t\t\tret = regcache_maple_sync_block(map,\
  \ entry, &mas,\n\t\t\t\t\t\t\tsync_start, r);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto\
  \ out;\n\t\t\tsync_needed = false;\n\t\t}\n\t}\n\nout:\n\trcu_read_unlock();\n\n\
  \tmap->cache_bypass = false;\n\n\treturn ret;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/base/regmap/regcache-maple.c b/drivers/base/regmap/regcache-maple.c\n\
  index c1776127a572..55999a50ccc0 100644\n--- a/drivers/base/regmap/regcache-maple.c\n\
  +++ b/drivers/base/regmap/regcache-maple.c\n@@ -112,7 +112,7 @@ static int regcache_maple_drop(struct\
  \ regmap *map, unsigned int min,\n \tunsigned long *entry, *lower, *upper;\n \t\
  unsigned long lower_index, lower_last;\n \tunsigned long upper_index, upper_last;\n\
  -\tint ret;\n+\tint ret = 0;\n \n \tlower = NULL;\n \tupper = NULL;\n@@ -244,7 +244,7\
  \ @@ static int regcache_maple_sync(struct regmap *map, unsigned int min,\n \tunsigned\
  \ long lmin = min;\n \tunsigned long lmax = max;\n \tunsigned int r, v, sync_start;\n\
  -\tint ret;\n+\tint ret = 0;\n \tbool sync_needed = false;\n \n \tmap->cache_bypass\
  \ = true;\n```\n"
pattern: "## Bug Pattern\n\nReturning an uninitialized status variable.\n\nPattern:\n\
  - A local variable (e.g., `int ret;`) is declared to carry the return status.\n\
  - It is only assigned inside conditional/error branches or within loops.\n- On valid/no-op\
  \ paths (e.g., when no iterations or no errors occur), control reaches a common\
  \ cleanup/return label and returns `ret` without ever initializing it.\n\nExample\
  \ shape:\nint ret;           // not initialized\n...\nif (cond) {\n    ret = -ERR;\
  \    // only set in some branches\n    goto out;\n}\n...\nout:\nreturn ret;    \
  \    // may return garbage if no branch set ret\n\nFix: initialize `ret` (e.g.,\
  \ `int ret = 0;`) or ensure it is assigned on all paths before return."
plan: "Plan\n\n1) Program state customization\n- REGISTER_MAP_WITH_PROGRAMSTATE(StatusVarInitMap,\
  \ const VarDecl *, bool)\n  - Key: local status-like VarDecl.\n  - Value: whether\
  \ this variable is definitely initialized on the current path (true) or not (false).\n\
  - No other traits or maps are required.\n\n2) Callback selection and implementation\
  \ details\n\nA) checkPostStmt(const DeclStmt *DS)\n- Goal: Seed and initialize our\
  \ tracking for local \u201Cstatus\u201D variables when they are declared.\n- Steps:\n\
  \  - Iterate all DeclGroup contents and dyn_cast<VarDecl>.\n  - Only track:\n  \
  \  - Automatic local variables (VD->hasLocalStorage() && !VD->isStaticLocal()).\n\
  \    - Scalar integral-like candidates (VD->getType()->isIntegerType() || VD->getType()->isEnumeralType()\
  \ || VD->getType()->isBooleanType()).\n  - Initialize map entry:\n    - If VD has\
  \ an initializer (VD->hasInit()), set StatusVarInitMap[VD] = true.\n    - Else set\
  \ StatusVarInitMap[VD] = false.\n  - Do not track ParmVarDecl or globals.\n\nB)\
  \ checkBind(SVal Loc, SVal Val, const Stmt *S)\n- Goal: Mark a tracked variable\
  \ as initialized when it is assigned any value.\n- Steps:\n  - If Loc is a MemRegionVal\
  \ to a VarRegion, extract the VarDecl* VD.\n  - Lookup VD in StatusVarInitMap; if\
  \ present, set to true (the variable is now initialized on this path).\n  - This\
  \ covers simple, compound, and most unary-modify assignments that bind back to the\
  \ variable.\n  - Do not attempt to handle writes through pointers to the tracked\
  \ variable; keep the logic simple.\n\nC) checkPostStmt(const DeclStmt *DS) [second\
  \ responsibility: handle init from the same DeclStmt]\n- Note: Already covered in\
  \ A). If the DeclStmt has an initializer (e.g., int ret = 0;), we set initialized\
  \ to true. No extra work is needed beyond A).\n\nD) checkPreStmt(const ReturnStmt\
  \ *RS)\n- Goal: Warn when returning an uninitialized local status variable.\n- Steps:\n\
  \  - If RS->getRetValue() is null, return (void return).\n  - Get the returned expression\
  \ E = RS->getRetValue()->IgnoreParenImpCasts().\n  - Detect if the return value\
  \ is exactly a local variable we track:\n    - If E is a DeclRefExpr and refers\
  \ to a VarDecl* VD we track in StatusVarInitMap:\n      - Query the current state\
  \ value = StatusVarInitMap[VD].\n      - If value is false, this path reaches the\
  \ return with the variable not definitely initialized:\n        - Create a non-fatal\
  \ error node with generateNonFatalErrorNode().\n        - Emit a PathSensitiveBugReport\
  \ with a short message like:\n          \"Returning uninitialized status variable\
  \ 'ret'.\"\n        - Add the source range of E to the report.\n  - Optional small\
  \ extension (if desired): If E is not a direct DeclRefExpr, but you want to catch\
  \ simple aliases like parentheses or unary plus, the IgnoreParenImpCasts already\
  \ covers that. Keep it simple and avoid scanning arbitrary expressions to reduce\
  \ false positives.\n\nE) checkBeginFunction / checkEndFunction\n- Not required.\
  \ The analyzer\u2019s state is per-function; the StatusVarInitMap will be naturally\
  \ scoped to the function being analyzed.\n- If you prefer being explicit, you can\
  \ ensure the map is empty in checkBeginFunction.\n\n3) Heuristics to reduce false\
  \ positives (kept simple)\n- Only warn when the return expression is exactly a single\
  \ tracked local variable (after IgnoreParenImpCasts). This targets the canonical\
  \ \u201Cstatus ret\u201D pattern (as in the provided patch).\n- Restrict tracked\
  \ variables to integer-like scalars (int, bool, enums). This avoids noise from structs/pointers.\n\
  \n4) Notes on why this catches the target patch\n- In the buggy code, ret is declared\
  \ without an initializer. On paths where the loop never iterates or no error occurs,\
  \ there is no assignment to ret before the common return. Our map holds ret=false\
  \ on those paths. When visiting return ret; we detect ret is not initialized and\
  \ warn.\n- The fix (int ret = 0;) causes the DeclStmt handler to set ret as initialized\
  \ immediately, preventing the warning.\n\n5) Bug report\n- Use a single BugType\
  \ instance, e.g., \"Uninitialized status return\".\n- Message: \"Returning uninitialized\
  \ status variable 'ret'.\"\n- Prefer PathSensitiveBugReport with the return expression\
  \ range to help pinpoint the issue.\n\n6) Summary of callbacks used\n- checkPostStmt(DeclStmt):\
  \ seed tracked locals and mark initial init state.\n- checkBind: mark tracked locals\
  \ as initialized upon assignments.\n- checkPreStmt(ReturnStmt): detect and report\
  \ returning an uninitialized tracked local."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include <string>\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// Program state map to track whether\
  \ a local \"status\" variable has been initialized.\nREGISTER_MAP_WITH_PROGRAMSTATE(StatusVarInitMap,\
  \ const VarDecl *, bool)\n\nnamespace {\n\nclass SAGenTestChecker\n    : public\
  \ Checker<\n          check::PostStmt<DeclStmt>, // Seed tracking on local declarations\n\
  \          check::Bind,               // Mark as initialized on assignments\n  \
  \        check::PreStmt<ReturnStmt> // Warn on returning uninitialized var\n   \
  \       > {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n\
  \      : BT(new BugType(this, \"Uninitialized status return\", \"Logic error\"))\
  \ {}\n\n  void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;\n  void\
  \ checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n  void\
  \ checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;\n\nprivate:\n  static\
  \ bool shouldTrackVar(const VarDecl *VD);\n};\n\nbool SAGenTestChecker::shouldTrackVar(const\
  \ VarDecl *VD) {\n  if (!VD)\n    return false;\n\n  // Only track automatic local\
  \ non-static variables.\n  if (!VD->hasLocalStorage() || VD->isStaticLocal())\n\
  \    return false;\n\n  QualType T = VD->getType();\n  // Restrict to integer-like\
  \ scalar \"status\" candidates.\n  if (!(T->isIntegerType() || T->isEnumeralType()\
  \ || T->isBooleanType()))\n    return false;\n\n  return true;\n}\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  for (const Decl *D : DS->decls()) {\n    const auto *VD = dyn_cast<VarDecl>(D);\n\
  \    if (!VD)\n      continue;\n\n    if (!shouldTrackVar(VD))\n      continue;\n\
  \n    // Initialize tracking: true if it has an initializer, otherwise false.\n\
  \    bool IsInitialized = VD->hasInit();\n    State = State->set<StatusVarInitMap>(VD,\
  \ IsInitialized);\n  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal /*Val*/, const Stmt * /*S*/,\n                                 CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *MR\
  \ = Loc.getAsRegion();\n  if (!MR)\n    return;\n\n  MR = MR->getBaseRegion();\n\
  \  if (!MR)\n    return;\n\n  const auto *VR = dyn_cast<VarRegion>(MR);\n  if (!VR)\n\
  \    return;\n\n  const VarDecl *VD = VR->getDecl();\n  if (!VD)\n    return;\n\n\
  \  // If we are tracking this variable, mark it as initialized on this path.\n \
  \ if (State->contains<StatusVarInitMap>(VD)) {\n    State = State->set<StatusVarInitMap>(VD,\
  \ true);\n    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::checkPreStmt(const\
  \ ReturnStmt *RS, CheckerContext &C) const {\n  const Expr *RetE = RS->getRetValue();\n\
  \  if (!RetE)\n    return;\n\n  RetE = RetE->IgnoreParenImpCasts();\n\n  const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(RetE);\n  if (!DRE)\n    return;\n\n  const auto\
  \ *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n    return;\n\n  // Only\
  \ consider tracked variables.\n  ProgramStateRef State = C.getState();\n  const\
  \ bool *IsInit = State->get<StatusVarInitMap>(VD);\n  if (!IsInit)\n    return;\n\
  \n  if (!*IsInit) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n    if\
  \ (!N)\n      return;\n\n    std::string VarName = VD->getNameAsString();\n    if\
  \ (VarName.empty())\n      VarName = \"<status>\";\n\n    auto Report = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Returning uninitialized status variable '\" + VarName + \"'.\",\
  \ N);\n    Report->addRange(RetE->getSourceRange());\n    C.emitReport(std::move(Report));\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects returning an uninitialized local status variable (e.g., 'int\
  \ ret;')\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
