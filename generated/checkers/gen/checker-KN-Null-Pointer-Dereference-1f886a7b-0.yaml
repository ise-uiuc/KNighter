_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 1f886a7bfb3faf4c1021e73f045538008ce7634e
commit_type: Null-Pointer-Dereference
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// Track the \"checked\" state of pointers that originate from devm_*\
  \ allocators.\n// Keyed by the pointee MemRegion (the region returned by devm_*),\
  \ value:\n//   0 = Unchecked (may be NULL)\n//   1 = Checked   (has been NULL-checked\
  \ on this path)\nREGISTER_MAP_WITH_PROGRAMSTATE(DevmPtrState, const MemRegion*,\
  \ unsigned)\n\n// Optional alias map placeholder (not strictly needed when we key\
  \ by pointee),\n// but kept for extensibility and to follow the suggested pattern.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*, const MemRegion*)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n\
  \        check::PreCall,\n        check::BranchCondition,\n        check::Location,\n\
  \        check::Bind> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n\
  \      SAGenTestChecker() : BT(new BugType(this, \"Unchecked devm allocation dereference\"\
  , \"Null pointer dereference\")) {}\n\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      void checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n      void checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const;\n      void checkLocation(SVal Loc, bool IsLoad, const\
  \ Stmt *S, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const;\n\n   private:\n      // Helpers\n      static\
  \ bool isKnownDevmAllocatorName(StringRef Name);\n      static bool isDevmAllocatorExpr(const\
  \ Expr *E, CheckerContext &C);\n      static const MemRegion *getPtrRegionFromExpr(const\
  \ Expr *E, CheckerContext &C);\n      static ProgramStateRef setChecked(ProgramStateRef\
  \ State, const MemRegion *R);\n      static ProgramStateRef setUnchecked(ProgramStateRef\
  \ State, const MemRegion *R);\n      void reportDerefUnchecked(const Stmt *S, const\
  \ Expr *BaseE, CheckerContext &C) const;\n      void reportPassToDerefUnchecked(const\
  \ CallEvent &Call, unsigned ArgIdx, CheckerContext &C) const;\n\n      template\
  \ <typename T>\n      const T* findInParents(const Stmt *S, CheckerContext &C) const\
  \ {\n        return findSpecificTypeInParents<T>(S, C);\n      }\n};\n\n// Determine\
  \ if the given function name is a devm_* allocator we want to track.\nbool SAGenTestChecker::isKnownDevmAllocatorName(StringRef\
  \ Name) {\n  return Name.equals(\"devm_kzalloc\") ||\n         Name.equals(\"devm_kmalloc\"\
  ) ||\n         Name.equals(\"devm_kcalloc\") ||\n         Name.equals(\"devm_kmalloc_array\"\
  ) ||\n         Name.equals(\"devm_kstrdup\");\n}\n\n// Check if an expression is\
  \ a call to a known devm_* allocator.\nbool SAGenTestChecker::isDevmAllocatorExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return false;\n  // Try each known devm\
  \ allocator via source text matching.\n  return ExprHasName(E, \"devm_kzalloc\"\
  , C) ||\n         ExprHasName(E, \"devm_kmalloc\", C) ||\n         ExprHasName(E,\
  \ \"devm_kcalloc\", C) ||\n         ExprHasName(E, \"devm_kmalloc_array\", C) ||\n\
  \         ExprHasName(E, \"devm_kstrdup\", C);\n}\n\n// Get the pointee MemRegion\
  \ from an expression representing a pointer value.\nconst MemRegion *SAGenTestChecker::getPtrRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return nullptr;\n  const MemRegion *MR\
  \ = getMemRegionFromExpr(E, C);\n  if (!MR) return nullptr;\n  MR = MR->getBaseRegion();\n\
  \  return MR;\n}\n\nProgramStateRef SAGenTestChecker::setChecked(ProgramStateRef\
  \ State, const MemRegion *R) {\n  if (!R) return State;\n  const unsigned *Cur =\
  \ State->get<DevmPtrState>(R);\n  if (Cur && *Cur == 0)\n    State = State->set<DevmPtrState>(R,\
  \ 1);\n  return State;\n}\n\nProgramStateRef SAGenTestChecker::setUnchecked(ProgramStateRef\
  \ State, const MemRegion *R) {\n  if (!R) return State;\n  State = State->set<DevmPtrState>(R,\
  \ 0);\n  return State;\n}\n\nvoid SAGenTestChecker::reportDerefUnchecked(const Stmt\
  \ *S, const Expr *BaseE, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n   \
  \   *BT, \"Unchecked devm allocation may be NULL and is dereferenced\", N);\n  if\
  \ (S)\n    R->addRange(S->getSourceRange());\n  if (BaseE)\n    R->addRange(BaseE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::reportPassToDerefUnchecked(const\
  \ CallEvent &Call, unsigned ArgIdx, CheckerContext &C) const {\n  ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Unchecked devm allocation may be NULL and is passed to a function\
  \ that dereferences it\", N);\n  if (const Expr *OE = Call.getOriginExpr())\n  \
  \  R->addRange(OE->getSourceRange());\n  if (ArgIdx < Call.getNumArgs())\n    if\
  \ (const Expr *AE = Call.getArgExpr(ArgIdx))\n      R->addRange(AE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n// After a call: if it is a devm_* allocator,\
  \ mark the returned region as Unchecked.\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE) return;\n\n  // Only track known devm_* allocators.\n  bool IsDevmAlloc\
  \ = false;\n  // Prefer ExprHasName for robust matching.\n  for (const char *Name\
  \ : {\"devm_kzalloc\", \"devm_kmalloc\", \"devm_kcalloc\", \"devm_kmalloc_array\"\
  , \"devm_kstrdup\"}) {\n    if (ExprHasName(OE, Name, C)) {\n      IsDevmAlloc =\
  \ true;\n      break;\n    }\n  }\n  if (!IsDevmAlloc) return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  const MemRegion *RetR = Call.getReturnValue().getAsRegion();\n\
  \  if (!RetR) return;\n  RetR = RetR->getBaseRegion();\n  if (!RetR) return;\n\n\
  \  State = setUnchecked(State, RetR);\n  C.addTransition(State);\n}\n\n// Before\
  \ a call: if a known-dereference function is called with an unchecked devm pointer,\
  \ report.\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  llvm::SmallVector<unsigned, 4> DerefParams;\n  if (!functionKnownToDeref(Call,\
  \ DerefParams))\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  for\
  \ (unsigned Idx : DerefParams) {\n    if (Idx >= Call.getNumArgs())\n      continue;\n\
  \n    const Expr *ArgE = Call.getArgExpr(Idx);\n    const MemRegion *MR = getPtrRegionFromExpr(ArgE,\
  \ C);\n    if (!MR)\n      continue;\n\n    const unsigned *St = State->get<DevmPtrState>(MR);\n\
  \    if (St && *St == 0) {\n      reportPassToDerefUnchecked(Call, Idx, C);\n  \
  \    // Do not early return; report for all problematic args.\n    }\n  }\n}\n\n\
  // Observe branch conditions to mark devm pointers as \"Checked\" once they appear\
  \ in NULL tests.\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const {\n  if (!Condition) return;\n  ProgramStateRef State\
  \ = C.getState();\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\
  \ {\n    C.addTransition(State);\n    return;\n  }\n  CondE = CondE->IgnoreParenCasts();\n\
  \n  auto MarkPtrExprChecked = [&](const Expr *PtrE) {\n    const MemRegion *MR =\
  \ getPtrRegionFromExpr(PtrE, C);\n    if (!MR) return;\n    const unsigned *St =\
  \ State->get<DevmPtrState>(MR);\n    if (St) {\n      State = setChecked(State,\
  \ MR);\n    }\n  };\n\n  // if (!p)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      MarkPtrExprChecked(UO->getSubExpr()->IgnoreParenCasts());\n\
  \    }\n  }\n  // if (p == NULL) or if (p != NULL)\n  else if (const auto *BO =\
  \ dyn_cast<BinaryOperator>(CondE)) {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n\
  \    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \      const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n      bool LHSIsNull\
  \ = LHS->isNullPointerConstant(C.getASTContext(), Expr::NPC_ValueDependentIsNull);\n\
  \      bool RHSIsNull = RHS->isNullPointerConstant(C.getASTContext(), Expr::NPC_ValueDependentIsNull);\n\
  \      const Expr *PtrE = nullptr;\n      if (LHSIsNull && !RHSIsNull)\n       \
  \ PtrE = RHS;\n      else if (RHSIsNull && !LHSIsNull)\n        PtrE = LHS;\n\n\
  \      if (PtrE)\n        MarkPtrExprChecked(PtrE);\n    }\n  }\n  // if (p)\n \
  \ else {\n    // If condition is a raw pointer expression.\n    if (CondE->getType()->isPointerType())\n\
  \      MarkPtrExprChecked(CondE);\n  }\n\n  C.addTransition(State);\n}\n\n// Detect\
  \ dereferences of unchecked devm pointers via ->, *ptr, or ptr[index].\nvoid SAGenTestChecker::checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef\
  \ State = C.getState();\n\n  const Expr *BaseE = nullptr;\n  const MemRegion *BaseMR\
  \ = nullptr;\n\n  // 1) Look for MemberExpr with '->'\n  if (const auto *ME = findInParents<MemberExpr>(S,\
  \ C)) {\n    if (ME->isArrow()) {\n      BaseE = ME->getBase()->IgnoreParenCasts();\n\
  \      BaseMR = getPtrRegionFromExpr(BaseE, C);\n    }\n  }\n\n  // 2) If not found,\
  \ check UnaryOperator '*'\n  if (!BaseMR) {\n    if (const auto *UO = findInParents<UnaryOperator>(S,\
  \ C)) {\n      if (UO->getOpcode() == UO_Deref) {\n        BaseE = UO->getSubExpr()->IgnoreParenCasts();\n\
  \        BaseMR = getPtrRegionFromExpr(BaseE, C);\n      }\n    }\n  }\n\n  // 3)\
  \ ArraySubscriptExpr: ptr[i]\n  if (!BaseMR) {\n    if (const auto *ASE = findInParents<ArraySubscriptExpr>(S,\
  \ C)) {\n      BaseE = ASE->getBase()->IgnoreParenCasts();\n      BaseMR = getPtrRegionFromExpr(BaseE,\
  \ C);\n    }\n  }\n\n  if (!BaseMR)\n    return;\n\n  const unsigned *St = State->get<DevmPtrState>(BaseMR);\n\
  \  if (St && *St == 0) {\n    // Unchecked devm allocation is being dereferenced.\n\
  \    reportDerefUnchecked(S, BaseE, C);\n  }\n}\n\n// Observe binds to optionally\
  \ track devm allocation in direct assignments as well.\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  // If RHS is a devm_* call, mark its return region as Unchecked.\n\
  \  if (S) {\n    if (const auto *CE = findSpecificTypeInChildren<CallExpr>(S)) {\n\
  \      if (isDevmAllocatorExpr(CE, C)) {\n        const MemRegion *MR = getPtrRegionFromExpr(CE,\
  \ C);\n        if (MR) {\n          State = setUnchecked(State, MR);\n         \
  \ C.addTransition(State);\n          return;\n        }\n      }\n    }\n  }\n\n\
  \  // We do not need to explicitly propagate aliasing because the map is keyed\n\
  \  // by the pointee region. Any alias to the same pointee uses the same key.\n\
  \  // Still, if RHS is not a region (e.g., NULL literal or integer), nothing to\
  \ track.\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects dereference of devm_* allocation without NULL check\",\n    \
  \  \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n   \
  \ CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nspi: mchp-pci1xxx: Fix a possible null pointer dereference\
  \ in pci1xxx_spi_probe\n\nIn function pci1xxxx_spi_probe, there is a potential null\
  \ pointer that\nmay be caused by a failed memory allocation by the function devm_kzalloc.\n\
  Hence, a null pointer check needs to be added to prevent null pointer\ndereferencing\
  \ later in the code.\n\nTo fix this issue, spi_bus->spi_int[iter] should be checked.\
  \ The memory\nallocated by devm_kzalloc will be automatically released, so just\
  \ directly\nreturn -ENOMEM without worrying about memory leaks.\n\nFixes: 1cc0cbea7167\
  \ (\"spi: microchip: pci1xxxx: Add driver for SPI controller of PCI1XXXX PCIe switch\"\
  )\nSigned-off-by: Huai-Yuan Liu <qq810974084@gmail.com>\nLink: https://msgid.link/r/20240403014221.969801-1-qq810974084@gmail.com\n\
  Signed-off-by: Mark Brown <broonie@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ pci1xxxx_spi_probe in drivers/spi/spi-pci1xxxx.c\nstatic int pci1xxxx_spi_probe(struct\
  \ pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tu8 hw_inst_cnt, iter, start,\
  \ only_sec_inst;\n\tstruct pci1xxxx_spi_internal *spi_sub_ptr;\n\tstruct device\
  \ *dev = &pdev->dev;\n\tstruct pci1xxxx_spi *spi_bus;\n\tstruct spi_controller *spi_host;\n\
  \tu32 regval;\n\tint ret;\n\n\thw_inst_cnt = ent->driver_data & 0x0f;\n\tstart =\
  \ (ent->driver_data & 0xf0) >> 4;\n\tif (start == 1)\n\t\tonly_sec_inst = 1;\n\t\
  else\n\t\tonly_sec_inst = 0;\n\n\tspi_bus = devm_kzalloc(&pdev->dev,\n\t\t\t   \
  \    struct_size(spi_bus, spi_int, hw_inst_cnt),\n\t\t\t       GFP_KERNEL);\n\t\
  if (!spi_bus)\n\t\treturn -ENOMEM;\n\n\tspi_bus->dev = pdev;\n\tspi_bus->total_hw_instances\
  \ = hw_inst_cnt;\n\tpci_set_master(pdev);\n\n\tfor (iter = 0; iter < hw_inst_cnt;\
  \ iter++) {\n\t\tspi_bus->spi_int[iter] = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t\t\
  \      sizeof(struct pci1xxxx_spi_internal),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\
  \tspi_sub_ptr = spi_bus->spi_int[iter];\n\t\tspi_sub_ptr->spi_host = devm_spi_alloc_host(dev,\
  \ sizeof(struct spi_controller));\n\t\tif (!spi_sub_ptr->spi_host)\n\t\t\treturn\
  \ -ENOMEM;\n\n\t\tspi_sub_ptr->parent = spi_bus;\n\t\tspi_sub_ptr->spi_xfer_in_progress\
  \ = false;\n\n\t\tif (!iter) {\n\t\t\tret = pcim_enable_device(pdev);\n\t\t\tif\
  \ (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tret = pci_request_regions(pdev, DRV_NAME);\n\
  \t\t\tif (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tspi_bus->reg_base = pcim_iomap(pdev,\
  \ 0, pci_resource_len(pdev, 0));\n\t\t\tif (!spi_bus->reg_base) {\n\t\t\t\tret =\
  \ -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret = pci_alloc_irq_vectors(pdev,\
  \ hw_inst_cnt, hw_inst_cnt,\n\t\t\t\t\t\t    PCI_IRQ_ALL_TYPES);\n\t\t\tif (ret\
  \ < 0) {\n\t\t\t\tdev_err(&pdev->dev, \"Error allocating MSI vectors\\n\");\n\t\t\
  \t\tgoto error;\n\t\t\t}\n\n\t\t\tinit_completion(&spi_sub_ptr->spi_xfer_done);\n\
  \t\t\t/* Initialize Interrupts - SPI_INT */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ +\n\t\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\t\
  regval &= ~SPI_INTR;\n\t\t\twritel(regval, spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\
  \t\t\tspi_sub_ptr->irq = pci_irq_vector(pdev, 0);\n\n\t\t\tret = devm_request_irq(&pdev->dev,\
  \ spi_sub_ptr->irq,\n\t\t\t\t\t       pci1xxxx_spi_isr, PCI1XXXX_IRQ_FLAGS,\n\t\t\
  \t\t\t       pci_name(pdev), spi_sub_ptr);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev,\
  \ \"Unable to request irq : %d\",\n\t\t\t\t\tspi_sub_ptr->irq);\n\t\t\t\tret = -ENODEV;\n\
  \t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret = pci1xxxx_spi_dma_init(spi_bus, spi_sub_ptr->irq);\n\
  \t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\tgoto error;\n\n\t\t\t/* This register\
  \ is only applicable for 1st instance */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ + SPI_PCI_CTRL_REG_OFFSET(0));\n\t\t\tif (!only_sec_inst)\n\t\t\t\tregval |= (BIT(4));\n\
  \t\t\telse\n\t\t\t\tregval &= ~(BIT(4));\n\n\t\t\twritel(regval, spi_bus->reg_base\
  \ + SPI_PCI_CTRL_REG_OFFSET(0));\n\t\t}\n\n\t\tspi_sub_ptr->hw_inst = start++;\n\
  \n\t\tif (iter == 1) {\n\t\t\tinit_completion(&spi_sub_ptr->spi_xfer_done);\n\t\t\
  \t/* Initialize Interrupts - SPI_INT */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\t\
  regval &= ~SPI_INTR;\n\t\t\twritel(regval, spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\
  \t\t\tspi_sub_ptr->irq = pci_irq_vector(pdev, iter);\n\t\t\tret = devm_request_irq(&pdev->dev,\
  \ spi_sub_ptr->irq,\n\t\t\t\t\t       pci1xxxx_spi_isr, PCI1XXXX_IRQ_FLAGS,\n\t\t\
  \t\t\t       pci_name(pdev), spi_sub_ptr);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev,\
  \ \"Unable to request irq : %d\",\n\t\t\t\t\tspi_sub_ptr->irq);\n\t\t\t\tret = -ENODEV;\n\
  \t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tspi_host = spi_sub_ptr->spi_host;\n\t\
  \tspi_host->num_chipselect = SPI_CHIP_SEL_COUNT;\n\t\tspi_host->mode_bits = SPI_MODE_0\
  \ | SPI_MODE_3 | SPI_RX_DUAL |\n\t\t\t\t      SPI_TX_DUAL | SPI_LOOP;\n\t\tspi_host->can_dma\
  \ = pci1xxxx_spi_can_dma;\n\t\tspi_host->transfer_one = pci1xxxx_spi_transfer_one;\n\
  \n\t\tspi_host->set_cs = pci1xxxx_spi_set_cs;\n\t\tspi_host->bits_per_word_mask\
  \ = SPI_BPW_MASK(8);\n\t\tspi_host->max_speed_hz = PCI1XXXX_SPI_MAX_CLOCK_HZ;\n\t\
  \tspi_host->min_speed_hz = PCI1XXXX_SPI_MIN_CLOCK_HZ;\n\t\tspi_host->flags = SPI_CONTROLLER_MUST_TX;\n\
  \t\tspi_controller_set_devdata(spi_host, spi_sub_ptr);\n\t\tret = devm_spi_register_controller(dev,\
  \ spi_host);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\tpci_set_drvdata(pdev, spi_bus);\n\
  \n\treturn 0;\n\nerror:\n\tpci_release_regions(pdev);\n\treturn ret;\n}\n```\n\n\
  ## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/spi/spi-pci1xxxx.c b/drivers/spi/spi-pci1xxxx.c\n\
  index 969965d7bc98..cc18d320370f 100644\n--- a/drivers/spi/spi-pci1xxxx.c\n+++ b/drivers/spi/spi-pci1xxxx.c\n\
  @@ -725,6 +725,8 @@ static int pci1xxxx_spi_probe(struct pci_dev *pdev, const struct\
  \ pci_device_id *\n \t\tspi_bus->spi_int[iter] = devm_kzalloc(&pdev->dev,\n \t\t\
  \t\t\t\t      sizeof(struct pci1xxxx_spi_internal),\n \t\t\t\t\t\t      GFP_KERNEL);\n\
  +\t\tif (!spi_bus->spi_int[iter])\n+\t\t\treturn -ENOMEM;\n \t\tspi_sub_ptr = spi_bus->spi_int[iter];\n\
  \ \t\tspi_sub_ptr->spi_host = devm_spi_alloc_host(dev, sizeof(struct spi_controller));\n\
  \ \t\tif (!spi_sub_ptr->spi_host)\n```\n"
pattern: '## Bug Pattern


  Dereferencing the result of a devm_* allocation without checking for NULL.


  Pattern:

  - Allocate a sub-structure with devm_kzalloc (or similar devm_* allocator) and immediately
  use it (e.g., via a local alias) without validating the allocation succeeded.


  Example pattern:

  ```

  p = devm_kzalloc(dev, size, GFP_KERNEL);

  q = p;                  // alias

  q->field = ...;         // NULL dereference if allocation failed

  ```


  This commonly appears in probe paths or loops allocating per-instance objects (e.g.,
  array elements) where the pointer (spi_bus->spi_int[iter]) is used before an explicit
  NULL check.'
plan: "Plan\n\n1) Program state customization\n- Register two maps:\n  - REGISTER_MAP_WITH_PROGRAMSTATE(DevmPtrState,\
  \ const MemRegion *, unsigned)\n    - 0 = Unchecked (may be NULL), 1 = Checked (proven\
  \ non-NULL on this path).\n  - REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const\
  \ MemRegion *, const MemRegion *)\n    - Maps an alias region to a canonical/source\
  \ region. Use it to propagate the Checked/Unchecked state across assignments and\
  \ indirections.\n\n- Helpers:\n  - canonical(const MemRegion *R, ProgramStateRef\
  \ S): Follow PtrAliasMap chains until a region with no parent to find the root.\n\
  \  - setStateForRegionAndAliases(State, Root, NewState): Iterate PtrAliasMap to\
  \ set the same state for all aliases of Root.\n  - isKnownDevmAllocatorName(StringRef\
  \ Fn): return true if Fn \u2208 {\"devm_kzalloc\",\"devm_kmalloc\",\"devm_kcalloc\"\
  ,\"devm_kmalloc_array\",\"devm_kstrdup\"} (extendable).\n  - getPtrRegionFromExpr(const\
  \ Expr *E, CheckerContext &C): return canonical(getMemRegionFromExpr(E)), if any.\n\
  \n2) Callback functions and implementation details\n\nA) checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const\n- Goal: Track devm_* allocation\
  \ results assigned to storage and propagate aliasing.\n- Steps:\n  1) Extract the\
  \ destination region:\n     - If auto MR = Loc.getAsRegion(), canonicalize it (RootDst\
  \ = canonical(MR, C.getState())). If null, return.\n  2) Case 1: Binding a devm_*\
  \ call result.\n     - Try to find the call producing the bound value: const CallExpr\
  \ *CE = findSpecificTypeInChildren<CallExpr>(S).\n     - If CE and callee name is\
  \ a known devm allocator (isKnownDevmAllocatorName), then:\n       - State = State->set<DevmPtrState>(RootDst,\
  \ 0 /*Unchecked*/).\n       - State = State->remove<PtrAliasMap>(RootDst) to make\
  \ RootDst canonical.\n       - C.addTransition(State).\n       - return.\n  3) Case\
  \ 2: Binding from another pointer (aliasing).\n     - If const MemRegion *SrcR =\
  \ Val.getAsRegion():\n       - RootSrc = canonical(SrcR, State).\n       - If RootSrc\
  \ has an entry in DevmPtrState:\n         - Copy state: unsigned St = State->get<DevmPtrState>(RootSrc);\
  \ State = State->set<DevmPtrState>(RootDst, St).\n         - Record alias: State\
  \ = State->set<PtrAliasMap>(RootDst, RootSrc).\n         - C.addTransition(State);\
  \ return.\n     - Otherwise, if RHS is not tracked (e.g., integer constant, non-devm\
  \ pointer):\n       - Clear destination from maps to avoid stale state: State =\
  \ State->remove<DevmPtrState>(RootDst); State = State->remove<PtrAliasMap>(RootDst).\n\
  \       - C.addTransition(State).\n\nB) checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const\n- Goal: Mark pointers as \u201CChecked\u201D when they\
  \ are used in a NULL-test.\n- Recognize the following patterns (ignore implicit\
  \ casts):\n  1) UnaryOperator \u2018!\u2019 on a pointer expression: if (!p)\n \
  \    - Extract region R = getPtrRegionFromExpr(UO->getSubExpr()).\n     - If R is\
  \ tracked in DevmPtrState, set it to Checked (1), and also update all its aliases\
  \ via setStateForRegionAndAliases.\n  2) BinaryOperator \u2018==\u2019 or \u2018\
  !=\u2019 with one operand a tracked pointer and the other a null literal/0:\n  \
  \   - Identify the pointer operand\u2019s region R.\n     - When operator is \u2018\
  !=\u2019 or \u2018==\u2019, conservatively mark R as Checked (1), since typical\
  \ code returns on the NULL branch and dereferences on the non-NULL path. This heuristic\
  \ keeps the checker simple and effective for probe-style code.\n- Implementation\
  \ details:\n  - Use dyn_cast to UnaryOperator/BinaryOperator, strip implicit casts.\n\
  \  - Use getPtrRegionFromExpr(E, C) for the pointer side.\n  - Update state: State\
  \ = State->set<DevmPtrState>(Root, 1) and for aliases.\n  - C.addTransition(State).\n\
  \nC) checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const\n\
  - Goal: Detect dereferences of unchecked devm_* pointers.\n- Determine whether the\
  \ current access dereferences a tracked pointer:\n  1) Try to locate a MemberExpr\
  \ in the parents: const MemberExpr *ME = findSpecificTypeInParents<MemberExpr>(S,\
  \ C).\n     - If ME && ME->isArrow(): the base is a pointer dereference.\n     -\
  \ Base region: R = getPtrRegionFromExpr(ME->getBase(), C).\n  2) If not a MemberExpr,\
  \ check for UnaryOperator \u2018*\u2019:\n     - const UnaryOperator *UO = findSpecificTypeInParents<UnaryOperator>(S,\
  \ C).\n     - If UO && UO->getOpcode() == UO_Deref: R = getPtrRegionFromExpr(UO->getSubExpr(),\
  \ C).\n  3) Also check ArraySubscriptExpr: const ArraySubscriptExpr *ASE = findSpecificTypeInParents<ArraySubscriptExpr>(S,\
  \ C).\n     - If ASE: R = getPtrRegionFromExpr(ASE->getBase(), C).\n- If a base\
  \ region R was found:\n  - Root = canonical(R, State).\n  - If DevmPtrState contains\
  \ Root with value 0 (Unchecked), report a bug:\n    - Node = C.generateNonFatalErrorNode();\
  \ if (!Node) return;\n    - Emit PathSensitiveBugReport with a short message like:\
  \ \u201CUnchecked devm allocation may be NULL and is dereferenced.\u201D\n    -\
  \ Optionally, add source ranges for the dereference expression for better diagnostics.\n\
  - Optional noise reduction: If the analyzer already proves the pointer non-NULL\
  \ on this path, it won\u2019t typically store Unchecked in our map due to BranchCondition\
  \ marking; keeping the check simple is sufficient for this pattern.\n\nD) checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const\n- Goal: Catch passing an unchecked\
  \ devm pointer to functions known to dereference their parameters.\n- Steps:\n \
  \ 1) Use functionKnownToDeref(Call, DerefParams). If true, iterate indices in DerefParams:\n\
  \     - For each i, get Expr *ArgE = Call.getArgExpr(i); find R = getPtrRegionFromExpr(ArgE,\
  \ C); Root = canonical(R).\n     - If Root is in DevmPtrState with value 0 (Unchecked),\
  \ report:\n       - Node = C.generateNonFatalErrorNode(); if (Node) emit report:\
  \ \u201CUnchecked devm allocation may be NULL and is passed to a function that dereferences\
  \ it.\u201D\n\nE) checkPostCall(const CallEvent &Call, CheckerContext &C) const\n\
  - Not strictly required if checkBind handles devm allocations; keep empty or use\
  \ it only to extend support for cases where the return is directly used without\
  \ assignment:\n  - If the return value of a known devm allocator is immediately\
  \ dereferenced (rare), the engine will invoke checkLocation for that dereference;\
  \ no extra work is necessary here.\n\n3) Additional practical notes\n- Canonicalization\
  \ and alias updates:\n  - Implement canonical by following PtrAliasMap until no\
  \ parent exists.\n  - setStateForRegionAndAliases should scan PtrAliasMap\u2019\
  s entries to propagate Checked/Unchecked consistently among aliases. For performance,\
  \ you can limit propagation to the small number of aliases typically seen in driver\
  \ probe paths.\n- State cleanup on overwrites:\n  - In checkBind, if destination\
  \ is overwritten with non-tracked sources (e.g., constants, other pointers not from\
  \ devm), remove destination from both maps to avoid stale warnings.\n- Targeted\
  \ function names:\n  - Start with the common allocators: devm_kzalloc, devm_kmalloc,\
  \ devm_kcalloc, devm_kmalloc_array, devm_kstrdup.\n  - This is easily extendable\
  \ by adding to the name list or using a prefix \u201Cdevm_k\u201D if desired.\n\n\
  4) What this catches in the target patch\n- spi_bus->spi_int[iter] is assigned from\
  \ devm_kzalloc(...) in a bind event: we store it as Unchecked.\n- Immediately after,\
  \ spi_sub_ptr = spi_bus->spi_int[iter]; in bind: we propagate Unchecked to spi_sub_ptr\
  \ via alias map.\n- Next, spi_sub_ptr->spi_host = ... triggers checkLocation; base\
  \ region is spi_sub_ptr, which is Unchecked, so we emit a report: \u201CUnchecked\
  \ devm allocation may be NULL and is dereferenced.\u201D\n- If an explicit check\
  \ \u201Cif (!spi_bus->spi_int[iter]) return -ENOMEM;\u201D is added, BranchCondition\
  \ marks it Checked, and no warning is emitted."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// Track the \"checked\" state of pointers that originate from devm_*\
  \ allocators.\n// Keyed by the pointee MemRegion (the region returned by devm_*),\
  \ value:\n//   0 = Unchecked (may be NULL)\n//   1 = Checked   (has been NULL-checked\
  \ on this path)\nREGISTER_MAP_WITH_PROGRAMSTATE(DevmPtrState, const MemRegion*,\
  \ unsigned)\n\n// Optional alias map placeholder (not strictly needed when we key\
  \ by pointee),\n// but kept for extensibility and to follow the suggested pattern.\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*, const MemRegion*)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n\
  \        check::PreCall,\n        check::BranchCondition,\n        check::Location,\n\
  \        check::Bind> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n\
  \      SAGenTestChecker() : BT(new BugType(this, \"Unchecked devm allocation dereference\"\
  , \"Null pointer dereference\")) {}\n\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      void checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n      void checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const;\n      void checkLocation(SVal Loc, bool IsLoad, const\
  \ Stmt *S, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const;\n\n   private:\n      // Helpers\n      static\
  \ bool isKnownDevmAllocatorName(StringRef Name);\n      static bool isDevmAllocatorExpr(const\
  \ Expr *E, CheckerContext &C);\n      static const MemRegion *getPtrRegionFromExpr(const\
  \ Expr *E, CheckerContext &C);\n      static ProgramStateRef setChecked(ProgramStateRef\
  \ State, const MemRegion *R);\n      static ProgramStateRef setUnchecked(ProgramStateRef\
  \ State, const MemRegion *R);\n      void reportDerefUnchecked(const Stmt *S, const\
  \ Expr *BaseE, CheckerContext &C) const;\n      void reportPassToDerefUnchecked(const\
  \ CallEvent &Call, unsigned ArgIdx, CheckerContext &C) const;\n\n      template\
  \ <typename T>\n      const T* findInParents(const Stmt *S, CheckerContext &C) const\
  \ {\n        return findSpecificTypeInParents<T>(S, C);\n      }\n};\n\n// Determine\
  \ if the given function name is a devm_* allocator we want to track.\nbool SAGenTestChecker::isKnownDevmAllocatorName(StringRef\
  \ Name) {\n  return Name.equals(\"devm_kzalloc\") ||\n         Name.equals(\"devm_kmalloc\"\
  ) ||\n         Name.equals(\"devm_kcalloc\") ||\n         Name.equals(\"devm_kmalloc_array\"\
  ) ||\n         Name.equals(\"devm_kstrdup\");\n}\n\n// Check if an expression is\
  \ a call to a known devm_* allocator.\nbool SAGenTestChecker::isDevmAllocatorExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return false;\n  // Try each known devm\
  \ allocator via source text matching.\n  return ExprHasName(E, \"devm_kzalloc\"\
  , C) ||\n         ExprHasName(E, \"devm_kmalloc\", C) ||\n         ExprHasName(E,\
  \ \"devm_kcalloc\", C) ||\n         ExprHasName(E, \"devm_kmalloc_array\", C) ||\n\
  \         ExprHasName(E, \"devm_kstrdup\", C);\n}\n\n// Get the pointee MemRegion\
  \ from an expression representing a pointer value.\nconst MemRegion *SAGenTestChecker::getPtrRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return nullptr;\n  const MemRegion *MR\
  \ = getMemRegionFromExpr(E, C);\n  if (!MR) return nullptr;\n  MR = MR->getBaseRegion();\n\
  \  return MR;\n}\n\nProgramStateRef SAGenTestChecker::setChecked(ProgramStateRef\
  \ State, const MemRegion *R) {\n  if (!R) return State;\n  const unsigned *Cur =\
  \ State->get<DevmPtrState>(R);\n  if (Cur && *Cur == 0)\n    State = State->set<DevmPtrState>(R,\
  \ 1);\n  return State;\n}\n\nProgramStateRef SAGenTestChecker::setUnchecked(ProgramStateRef\
  \ State, const MemRegion *R) {\n  if (!R) return State;\n  State = State->set<DevmPtrState>(R,\
  \ 0);\n  return State;\n}\n\nvoid SAGenTestChecker::reportDerefUnchecked(const Stmt\
  \ *S, const Expr *BaseE, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n   \
  \   *BT, \"Unchecked devm allocation may be NULL and is dereferenced\", N);\n  if\
  \ (S)\n    R->addRange(S->getSourceRange());\n  if (BaseE)\n    R->addRange(BaseE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::reportPassToDerefUnchecked(const\
  \ CallEvent &Call, unsigned ArgIdx, CheckerContext &C) const {\n  ExplodedNode *N\
  \ = C.generateNonFatalErrorNode();\n  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Unchecked devm allocation may be NULL and is passed to a function\
  \ that dereferences it\", N);\n  if (const Expr *OE = Call.getOriginExpr())\n  \
  \  R->addRange(OE->getSourceRange());\n  if (ArgIdx < Call.getNumArgs())\n    if\
  \ (const Expr *AE = Call.getArgExpr(ArgIdx))\n      R->addRange(AE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n// After a call: if it is a devm_* allocator,\
  \ mark the returned region as Unchecked.\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE) return;\n\n  // Only track known devm_* allocators.\n  bool IsDevmAlloc\
  \ = false;\n  // Prefer ExprHasName for robust matching.\n  for (const char *Name\
  \ : {\"devm_kzalloc\", \"devm_kmalloc\", \"devm_kcalloc\", \"devm_kmalloc_array\"\
  , \"devm_kstrdup\"}) {\n    if (ExprHasName(OE, Name, C)) {\n      IsDevmAlloc =\
  \ true;\n      break;\n    }\n  }\n  if (!IsDevmAlloc) return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  const MemRegion *RetR = Call.getReturnValue().getAsRegion();\n\
  \  if (!RetR) return;\n  RetR = RetR->getBaseRegion();\n  if (!RetR) return;\n\n\
  \  State = setUnchecked(State, RetR);\n  C.addTransition(State);\n}\n\n// Before\
  \ a call: if a known-dereference function is called with an unchecked devm pointer,\
  \ report.\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  llvm::SmallVector<unsigned, 4> DerefParams;\n  if (!functionKnownToDeref(Call,\
  \ DerefParams))\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  for\
  \ (unsigned Idx : DerefParams) {\n    if (Idx >= Call.getNumArgs())\n      continue;\n\
  \n    const Expr *ArgE = Call.getArgExpr(Idx);\n    const MemRegion *MR = getPtrRegionFromExpr(ArgE,\
  \ C);\n    if (!MR)\n      continue;\n\n    const unsigned *St = State->get<DevmPtrState>(MR);\n\
  \    if (St && *St == 0) {\n      reportPassToDerefUnchecked(Call, Idx, C);\n  \
  \    // Do not early return; report for all problematic args.\n    }\n  }\n}\n\n\
  // Observe branch conditions to mark devm pointers as \"Checked\" once they appear\
  \ in NULL tests.\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const {\n  if (!Condition) return;\n  ProgramStateRef State\
  \ = C.getState();\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\
  \ {\n    C.addTransition(State);\n    return;\n  }\n  CondE = CondE->IgnoreParenCasts();\n\
  \n  auto MarkPtrExprChecked = [&](const Expr *PtrE) {\n    const MemRegion *MR =\
  \ getPtrRegionFromExpr(PtrE, C);\n    if (!MR) return;\n    const unsigned *St =\
  \ State->get<DevmPtrState>(MR);\n    if (St) {\n      State = setChecked(State,\
  \ MR);\n    }\n  };\n\n  // if (!p)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      MarkPtrExprChecked(UO->getSubExpr()->IgnoreParenCasts());\n\
  \    }\n  }\n  // if (p == NULL) or if (p != NULL)\n  else if (const auto *BO =\
  \ dyn_cast<BinaryOperator>(CondE)) {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n\
  \    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \      const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n      bool LHSIsNull\
  \ = LHS->isNullPointerConstant(C.getASTContext(), Expr::NPC_ValueDependentIsNull);\n\
  \      bool RHSIsNull = RHS->isNullPointerConstant(C.getASTContext(), Expr::NPC_ValueDependentIsNull);\n\
  \      const Expr *PtrE = nullptr;\n      if (LHSIsNull && !RHSIsNull)\n       \
  \ PtrE = RHS;\n      else if (RHSIsNull && !LHSIsNull)\n        PtrE = LHS;\n\n\
  \      if (PtrE)\n        MarkPtrExprChecked(PtrE);\n    }\n  }\n  // if (p)\n \
  \ else {\n    // If condition is a raw pointer expression.\n    if (CondE->getType()->isPointerType())\n\
  \      MarkPtrExprChecked(CondE);\n  }\n\n  C.addTransition(State);\n}\n\n// Detect\
  \ dereferences of unchecked devm pointers via ->, *ptr, or ptr[index].\nvoid SAGenTestChecker::checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef\
  \ State = C.getState();\n\n  const Expr *BaseE = nullptr;\n  const MemRegion *BaseMR\
  \ = nullptr;\n\n  // 1) Look for MemberExpr with '->'\n  if (const auto *ME = findInParents<MemberExpr>(S,\
  \ C)) {\n    if (ME->isArrow()) {\n      BaseE = ME->getBase()->IgnoreParenCasts();\n\
  \      BaseMR = getPtrRegionFromExpr(BaseE, C);\n    }\n  }\n\n  // 2) If not found,\
  \ check UnaryOperator '*'\n  if (!BaseMR) {\n    if (const auto *UO = findInParents<UnaryOperator>(S,\
  \ C)) {\n      if (UO->getOpcode() == UO_Deref) {\n        BaseE = UO->getSubExpr()->IgnoreParenCasts();\n\
  \        BaseMR = getPtrRegionFromExpr(BaseE, C);\n      }\n    }\n  }\n\n  // 3)\
  \ ArraySubscriptExpr: ptr[i]\n  if (!BaseMR) {\n    if (const auto *ASE = findInParents<ArraySubscriptExpr>(S,\
  \ C)) {\n      BaseE = ASE->getBase()->IgnoreParenCasts();\n      BaseMR = getPtrRegionFromExpr(BaseE,\
  \ C);\n    }\n  }\n\n  if (!BaseMR)\n    return;\n\n  const unsigned *St = State->get<DevmPtrState>(BaseMR);\n\
  \  if (St && *St == 0) {\n    // Unchecked devm allocation is being dereferenced.\n\
  \    reportDerefUnchecked(S, BaseE, C);\n  }\n}\n\n// Observe binds to optionally\
  \ track devm allocation in direct assignments as well.\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  // If RHS is a devm_* call, mark its return region as Unchecked.\n\
  \  if (S) {\n    if (const auto *CE = findSpecificTypeInChildren<CallExpr>(S)) {\n\
  \      if (isDevmAllocatorExpr(CE, C)) {\n        const MemRegion *MR = getPtrRegionFromExpr(CE,\
  \ C);\n        if (MR) {\n          State = setUnchecked(State, MR);\n         \
  \ C.addTransition(State);\n          return;\n        }\n      }\n    }\n  }\n\n\
  \  // We do not need to explicitly propagate aliasing because the map is keyed\n\
  \  // by the pointee region. Any alias to the same pointee uses the same key.\n\
  \  // Still, if RHS is not a region (e.g., NULL literal or integer), nothing to\
  \ track.\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects dereference of devm_* allocation without NULL check\",\n    \
  \  \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n   \
  \ CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
