_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: b0b0d811eac6b4c52cb9ad632fa6384cf48869e7
commit_type: Integer-Overflow
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// No program state traits required\
  \ for this checker.\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::Bind,\n        check::PostStmt<DeclStmt>> {\n\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(std::make_unique<BugType>(this,\n\
  \                                     \"Mixed-width multiplication may overflow\
  \ before widening\",\n                                     \"Integer\")) {}\n\n\
  \  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \  void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;\n\nprivate:\n\
  \  // Helpers\n  static unsigned getTypeBitWidth(QualType QT, CheckerContext &C);\n\
  \  static bool isIntegerLike(QualType QT);\n  static bool isWideTargetType(QualType\
  \ QT, CheckerContext &C);\n  static bool isConstantFolded(const Expr *E, CheckerContext\
  \ &C);\n\n  static bool findFirstSuspiciousMul(const Stmt *S, unsigned TargetBits,\n\
  \                                     const BinaryOperator *&OutMul,\n         \
  \                            CheckerContext &C);\n\n  void emitReport(const BinaryOperator\
  \ *MulBO, QualType LHSType,\n                  CheckerContext &C) const;\n};\n\n\
  // Return bit width of a type.\nunsigned SAGenTestChecker::getTypeBitWidth(QualType\
  \ QT, CheckerContext &C) {\n  return C.getASTContext().getTypeSize(QT);\n}\n\n//\
  \ Check for integer-like types (integers and enums), ignoring typedefs/quals.\n\
  bool SAGenTestChecker::isIntegerLike(QualType QT) {\n  QT = QT.getCanonicalType();\n\
  \  return QT->isIntegerType() || QT->isEnumeralType();\n}\n\n// Wide target: integer-like\
  \ and width >= 64 bits (covers u64, dma_addr_t on 64-bit).\nbool SAGenTestChecker::isWideTargetType(QualType\
  \ QT, CheckerContext &C) {\n  if (!isIntegerLike(QT))\n    return false;\n\n  //\
  \ Special-case typedef names like dma_addr_t, but still rely on bit-width.\n  unsigned\
  \ Bits = getTypeBitWidth(QT, C);\n  return Bits >= 64;\n}\n\n// Try to fold expression\
  \ to constant integer. If succeeds, skip reporting.\nbool SAGenTestChecker::isConstantFolded(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E)\n    return false;\n  llvm::APSInt EvalRes;\n\
  \  return EvaluateExprToInt(EvalRes, E, C);\n}\n\n// DFS to find first multiply\
  \ whose resulting type is narrower than target.\nbool SAGenTestChecker::findFirstSuspiciousMul(const\
  \ Stmt *S, unsigned TargetBits,\n                                              const\
  \ BinaryOperator *&OutMul,\n                                              CheckerContext\
  \ &C) {\n  if (!S)\n    return false;\n\n  // Normalize expression nodes.\n  if\
  \ (const auto *E = dyn_cast<Expr>(S)) {\n    const Expr *NormE = E->IgnoreParenImpCasts();\n\
  \    if (NormE != E)\n      return findFirstSuspiciousMul(NormE, TargetBits, OutMul,\
  \ C);\n\n    if (const auto *BO = dyn_cast<BinaryOperator>(NormE)) {\n      if (BO->getOpcode()\
  \ == BO_Mul) {\n        // Only consider integer-like multiplication.\n        QualType\
  \ ResT = BO->getType();\n        if (isIntegerLike(ResT)) {\n          unsigned\
  \ MulBits = getTypeBitWidth(ResT, C);\n          if (MulBits < TargetBits) {\n \
  \           OutMul = BO;\n            return true;\n          }\n        }\n   \
  \   }\n      // Recurse into operands\n      if (findFirstSuspiciousMul(BO->getLHS(),\
  \ TargetBits, OutMul, C))\n        return true;\n      if (findFirstSuspiciousMul(BO->getRHS(),\
  \ TargetBits, OutMul, C))\n        return true;\n      return false;\n    }\n\n\
  \    // Generic recursion: traverse children.\n    for (const Stmt *Child : NormE->children())\
  \ {\n      if (findFirstSuspiciousMul(Child, TargetBits, OutMul, C))\n        return\
  \ true;\n    }\n    return false;\n  }\n\n  // For non-Expr statements, traverse\
  \ children.\n  for (const Stmt *Child : S->children()) {\n    if (findFirstSuspiciousMul(Child,\
  \ TargetBits, OutMul, C))\n      return true;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::emitReport(const\
  \ BinaryOperator *MulBO, QualType LHSType,\n                                  CheckerContext\
  \ &C) const {\n  if (!MulBO)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  SmallString<128> Msg;\n  Msg += \"Multiplication occurs\
  \ in a narrower type and is widened after; \";\n  Msg += \"possible overflow before\
  \ assignment/addition to wide type\";\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  R->addRange(MulBO->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// Handle assignments and compound assignments that bind values to wide targets.\n\
  void SAGenTestChecker::checkBind(SVal, SVal, const Stmt *S, CheckerContext &C) const\
  \ {\n  if (!S)\n    return;\n\n  // Prefer detecting compound assignments first\
  \ (e.g., +=)\n  if (const auto *CAO = findSpecificTypeInParents<CompoundAssignOperator>(S,\
  \ C)) {\n    BinaryOperatorKind Op = CAO->getOpcode();\n    // We care about adding/subtracting\
  \ a product into a wide accumulator.\n    if (Op == BO_AddAssign || Op == BO_SubAssign)\
  \ {\n      const Expr *LHS = CAO->getLHS()->IgnoreParenImpCasts();\n      if (!LHS)\n\
  \        return;\n      QualType LT = LHS->getType();\n      if (!isWideTargetType(LT,\
  \ C))\n        return;\n\n      const BinaryOperator *MulBO = nullptr;\n      if\
  \ (findFirstSuspiciousMul(CAO->getRHS(), getTypeBitWidth(LT, C), MulBO, C)) {\n\
  \        // Skip fully constant folded cases.\n        if (MulBO && !isConstantFolded(MulBO,\
  \ C))\n          emitReport(MulBO, LT, C);\n      }\n    }\n    return;\n  }\n\n\
  \  // Handle simple assignments: T_wide lhs = <expr with mul>;\n  if (const auto\
  \ *BO = findSpecificTypeInParents<BinaryOperator>(S, C)) {\n    if (BO->getOpcode()\
  \ != BO_Assign)\n      return;\n\n    const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \    if (!LHS)\n      return;\n    QualType LT = LHS->getType();\n    if (!isWideTargetType(LT,\
  \ C))\n      return;\n\n    const Expr *RHS = BO->getRHS();\n    const BinaryOperator\
  \ *MulBO = nullptr;\n    if (findFirstSuspiciousMul(RHS, getTypeBitWidth(LT, C),\
  \ MulBO, C)) {\n      if (MulBO && !isConstantFolded(MulBO, C))\n        emitReport(MulBO,\
  \ LT, C);\n    }\n  }\n}\n\n// Handle variable initializations: wide_var = <expr\
  \ with mul>;\nvoid SAGenTestChecker::checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C) const {\n  if (!DS)\n    return;\n\n  for (const Decl *D : DS->decls()) {\n\
  \    const auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      continue;\n   \
  \ if (!VD->hasInit())\n      continue;\n\n    QualType T = VD->getType();\n    if\
  \ (!isWideTargetType(T, C))\n      continue;\n\n    const Expr *Init = VD->getInit();\n\
  \    const BinaryOperator *MulBO = nullptr;\n    if (findFirstSuspiciousMul(Init,\
  \ getTypeBitWidth(T, C), MulBO, C)) {\n      if (MulBO && !isConstantFolded(MulBO,\
  \ C))\n        emitReport(MulBO, T, C);\n    }\n  }\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects narrow or mixed-width multiplication\
  \ that may overflow before being assigned/added to a wide integer\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/mediatek: Fix coverity issue with unintentional\
  \ integer overflow\n\n1. Instead of multiplying 2 variable of different types. Change\
  \ to\nassign a value of one variable and then multiply the other variable.\n\n2.\
  \ Add a int variable for multiplier calculation instead of calculating\ndifferent\
  \ types multiplier with dma_addr_t variable directly.\n\nFixes: 1a64a7aff8da (\"\
  drm/mediatek: Fix cursor plane no update\")\nSigned-off-by: Jason-JH.Lin <jason-jh.lin@mediatek.com>\n\
  Reviewed-by: Alexandre Mergnat <amergnat@baylibre.com>\nReviewed-by: AngeloGioacchino\
  \ Del Regno <angelogioacchino.delregno@collabora.com>\nLink: https://patchwork.kernel.org/project/dri-devel/patch/20230907091425.9526-1-jason-jh.lin@mediatek.com/\n\
  Signed-off-by: Chun-Kuang Hu <chunkuang.hu@kernel.org>\n\n## Buggy Code\n\n```c\n\
  // Function: mtk_plane_update_new_state in drivers/gpu/drm/mediatek/mtk_drm_plane.c\n\
  static void mtk_plane_update_new_state(struct drm_plane_state *new_state,\n\t\t\t\
  \t       struct mtk_plane_state *mtk_plane_state)\n{\n\tstruct drm_framebuffer *fb\
  \ = new_state->fb;\n\tstruct drm_gem_object *gem;\n\tstruct mtk_drm_gem_obj *mtk_gem;\n\
  \tunsigned int pitch, format;\n\tu64 modifier;\n\tdma_addr_t addr;\n\tdma_addr_t\
  \ hdr_addr = 0;\n\tunsigned int hdr_pitch = 0;\n\n\tgem = fb->obj[0];\n\tmtk_gem\
  \ = to_mtk_gem_obj(gem);\n\taddr = mtk_gem->dma_addr;\n\tpitch = fb->pitches[0];\n\
  \tformat = fb->format->format;\n\tmodifier = fb->modifier;\n\n\tif (modifier ==\
  \ DRM_FORMAT_MOD_LINEAR) {\n\t\taddr += (new_state->src.x1 >> 16) * fb->format->cpp[0];\n\
  \t\taddr += (new_state->src.y1 >> 16) * pitch;\n\t} else {\n\t\tint width_in_blocks\
  \ = ALIGN(fb->width, AFBC_DATA_BLOCK_WIDTH)\n\t\t\t\t      / AFBC_DATA_BLOCK_WIDTH;\n\
  \t\tint height_in_blocks = ALIGN(fb->height, AFBC_DATA_BLOCK_HEIGHT)\n\t\t\t\t \
  \      / AFBC_DATA_BLOCK_HEIGHT;\n\t\tint x_offset_in_blocks = (new_state->src.x1\
  \ >> 16) / AFBC_DATA_BLOCK_WIDTH;\n\t\tint y_offset_in_blocks = (new_state->src.y1\
  \ >> 16) / AFBC_DATA_BLOCK_HEIGHT;\n\t\tint hdr_size;\n\n\t\thdr_pitch = width_in_blocks\
  \ * AFBC_HEADER_BLOCK_SIZE;\n\t\tpitch = width_in_blocks * AFBC_DATA_BLOCK_WIDTH\
  \ *\n\t\t\tAFBC_DATA_BLOCK_HEIGHT * fb->format->cpp[0];\n\n\t\thdr_size = ALIGN(hdr_pitch\
  \ * height_in_blocks, AFBC_HEADER_ALIGNMENT);\n\n\t\thdr_addr = addr + hdr_pitch\
  \ * y_offset_in_blocks +\n\t\t\t   AFBC_HEADER_BLOCK_SIZE * x_offset_in_blocks;\n\
  \t\t/* The data plane is offset by 1 additional block. */\n\t\taddr = addr + hdr_size\
  \ +\n\t\t       pitch * y_offset_in_blocks +\n\t\t       AFBC_DATA_BLOCK_WIDTH *\
  \ AFBC_DATA_BLOCK_HEIGHT *\n\t\t       fb->format->cpp[0] * (x_offset_in_blocks\
  \ + 1);\n\t}\n\n\tmtk_plane_state->pending.enable = true;\n\tmtk_plane_state->pending.pitch\
  \ = pitch;\n\tmtk_plane_state->pending.hdr_pitch = hdr_pitch;\n\tmtk_plane_state->pending.format\
  \ = format;\n\tmtk_plane_state->pending.modifier = modifier;\n\tmtk_plane_state->pending.addr\
  \ = addr;\n\tmtk_plane_state->pending.hdr_addr = hdr_addr;\n\tmtk_plane_state->pending.x\
  \ = new_state->dst.x1;\n\tmtk_plane_state->pending.y = new_state->dst.y1;\n\tmtk_plane_state->pending.width\
  \ = drm_rect_width(&new_state->dst);\n\tmtk_plane_state->pending.height = drm_rect_height(&new_state->dst);\n\
  \tmtk_plane_state->pending.rotation = new_state->rotation;\n\tmtk_plane_state->pending.color_encoding\
  \ = new_state->color_encoding;\n}\n```\n\n```c\n// Function: mtk_drm_gem_dumb_create\
  \ in drivers/gpu/drm/mediatek/mtk_drm_gem.c\nint mtk_drm_gem_dumb_create(struct\
  \ drm_file *file_priv, struct drm_device *dev,\n\t\t\t    struct drm_mode_create_dumb\
  \ *args)\n{\n\tstruct mtk_drm_gem_obj *mtk_gem;\n\tint ret;\n\n\targs->pitch = DIV_ROUND_UP(args->width\
  \ * args->bpp, 8);\n\targs->size = args->pitch * args->height;\n\n\tmtk_gem = mtk_drm_gem_create(dev,\
  \ args->size, false);\n\tif (IS_ERR(mtk_gem))\n\t\treturn PTR_ERR(mtk_gem);\n\n\t\
  /*\n\t * allocate a id of idr table where the obj is registered\n\t * and handle\
  \ has the id what user can see.\n\t */\n\tret = drm_gem_handle_create(file_priv,\
  \ &mtk_gem->base, &args->handle);\n\tif (ret)\n\t\tgoto err_handle_create;\n\n\t\
  /* drop reference from allocate - handle holds it now. */\n\tdrm_gem_object_put(&mtk_gem->base);\n\
  \n\treturn 0;\n\nerr_handle_create:\n\tmtk_drm_gem_free_object(&mtk_gem->base);\n\
  \treturn ret;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/mediatek/mtk_drm_gem.c\
  \ b/drivers/gpu/drm/mediatek/mtk_drm_gem.c\nindex 9f364df52478..f6632a0fe509 100644\n\
  --- a/drivers/gpu/drm/mediatek/mtk_drm_gem.c\n+++ b/drivers/gpu/drm/mediatek/mtk_drm_gem.c\n\
  @@ -121,7 +121,14 @@ int mtk_drm_gem_dumb_create(struct drm_file *file_priv, struct\
  \ drm_device *dev,\n \tint ret;\n \n \targs->pitch = DIV_ROUND_UP(args->width *\
  \ args->bpp, 8);\n-\targs->size = args->pitch * args->height;\n+\n+\t/*\n+\t * Multiply\
  \ 2 variables of different types,\n+\t * for example: args->size = args->spacing\
  \ * args->height;\n+\t * may cause coverity issue with unintentional overflow.\n\
  +\t */\n+\targs->size = args->pitch;\n+\targs->size *= args->height;\n \n \tmtk_gem\
  \ = mtk_drm_gem_create(dev, args->size, false);\n \tif (IS_ERR(mtk_gem))\ndiff --git\
  \ a/drivers/gpu/drm/mediatek/mtk_drm_plane.c b/drivers/gpu/drm/mediatek/mtk_drm_plane.c\n\
  index db2f70ae060d..5acb03b7c6fe 100644\n--- a/drivers/gpu/drm/mediatek/mtk_drm_plane.c\n\
  +++ b/drivers/gpu/drm/mediatek/mtk_drm_plane.c\n@@ -141,6 +141,7 @@ static void\
  \ mtk_plane_update_new_state(struct drm_plane_state *new_state,\n \tdma_addr_t addr;\n\
  \ \tdma_addr_t hdr_addr = 0;\n \tunsigned int hdr_pitch = 0;\n+\tint offset;\n \n\
  \ \tgem = fb->obj[0];\n \tmtk_gem = to_mtk_gem_obj(gem);\n@@ -150,8 +151,15 @@ static\
  \ void mtk_plane_update_new_state(struct drm_plane_state *new_state,\n \tmodifier\
  \ = fb->modifier;\n \n \tif (modifier == DRM_FORMAT_MOD_LINEAR) {\n-\t\taddr +=\
  \ (new_state->src.x1 >> 16) * fb->format->cpp[0];\n-\t\taddr += (new_state->src.y1\
  \ >> 16) * pitch;\n+\t\t/*\n+\t\t * Using dma_addr_t variable to calculate with\
  \ multiplier of different types,\n+\t\t * for example: addr += (new_state->src.x1\
  \ >> 16) * fb->format->cpp[0];\n+\t\t * may cause coverity issue with unintentional\
  \ overflow.\n+\t\t */\n+\t\toffset = (new_state->src.x1 >> 16) * fb->format->cpp[0];\n\
  +\t\taddr += offset;\n+\t\toffset = (new_state->src.y1 >> 16) * pitch;\n+\t\taddr\
  \ += offset;\n \t} else {\n \t\tint width_in_blocks = ALIGN(fb->width, AFBC_DATA_BLOCK_WIDTH)\n\
  \ \t\t\t\t      / AFBC_DATA_BLOCK_WIDTH;\n@@ -159,21 +167,34 @@ static void mtk_plane_update_new_state(struct\
  \ drm_plane_state *new_state,\n \t\t\t\t       / AFBC_DATA_BLOCK_HEIGHT;\n \t\t\
  int x_offset_in_blocks = (new_state->src.x1 >> 16) / AFBC_DATA_BLOCK_WIDTH;\n \t\
  \tint y_offset_in_blocks = (new_state->src.y1 >> 16) / AFBC_DATA_BLOCK_HEIGHT;\n\
  -\t\tint hdr_size;\n+\t\tint hdr_size, hdr_offset;\n \n \t\thdr_pitch = width_in_blocks\
  \ * AFBC_HEADER_BLOCK_SIZE;\n \t\tpitch = width_in_blocks * AFBC_DATA_BLOCK_WIDTH\
  \ *\n \t\t\tAFBC_DATA_BLOCK_HEIGHT * fb->format->cpp[0];\n \n \t\thdr_size = ALIGN(hdr_pitch\
  \ * height_in_blocks, AFBC_HEADER_ALIGNMENT);\n+\t\thdr_offset = hdr_pitch * y_offset_in_blocks\
  \ +\n+\t\t\tAFBC_HEADER_BLOCK_SIZE * x_offset_in_blocks;\n+\n+\t\t/*\n+\t\t * Using\
  \ dma_addr_t variable to calculate with multiplier of different types,\n+\t\t *\
  \ for example: addr += hdr_pitch * y_offset_in_blocks;\n+\t\t * may cause coverity\
  \ issue with unintentional overflow.\n+\t\t */\n+\t\thdr_addr = addr + hdr_offset;\n\
  \ \n-\t\thdr_addr = addr + hdr_pitch * y_offset_in_blocks +\n-\t\t\t   AFBC_HEADER_BLOCK_SIZE\
  \ * x_offset_in_blocks;\n \t\t/* The data plane is offset by 1 additional block.\
  \ */\n-\t\taddr = addr + hdr_size +\n-\t\t       pitch * y_offset_in_blocks +\n\
  -\t\t       AFBC_DATA_BLOCK_WIDTH * AFBC_DATA_BLOCK_HEIGHT *\n-\t\t       fb->format->cpp[0]\
  \ * (x_offset_in_blocks + 1);\n+\t\toffset = pitch * y_offset_in_blocks +\n+\t\t\
  \t AFBC_DATA_BLOCK_WIDTH * AFBC_DATA_BLOCK_HEIGHT *\n+\t\t\t fb->format->cpp[0]\
  \ * (x_offset_in_blocks + 1);\n+\n+\t\t/*\n+\t\t * Using dma_addr_t variable to\
  \ calculate with multiplier of different types,\n+\t\t * for example: addr += pitch\
  \ * y_offset_in_blocks;\n+\t\t * may cause coverity issue with unintentional overflow.\n\
  +\t\t */\n+\t\taddr = addr + hdr_size + offset;\n \t}\n \n \tmtk_plane_state->pending.enable\
  \ = true;\n```\n"
pattern: "## Bug Pattern\n\nPerforming a multiplication on operands of narrower or\
  \ mixed integer types (e.g., u32 \xD7 u32, int \xD7 unsigned int) and then assigning/adding\
  \ the result to a wider type (u64/dma_addr_t) without first promoting an operand\
  \ to the wider type. This causes the multiplication to occur in the narrower type\
  \ and potentially overflow before being widened, e.g.:\n\n- args->size = args->pitch\
  \ * args->height;        // u32 * u32 -> overflow before storing in u64\n- addr\
  \ += (src_x >> 16) * cpp;                     // int * u8/u32 -> overflow before\
  \ adding to dma_addr_t\n- addr += pitch * y_offset_in_blocks;              // u32\
  \ * int -> overflow before adding to dma_addr_t\n\nFix by ensuring the multiplication\
  \ is done in a wide enough type (cast one operand or use a wide-typed accumulator\
  \ first), e.g., size64 = (u64)pitch32 * height32; or size64 = pitch32; size64 *=\
  \ height32."
plan: "Plan: Detect narrow or mixed-width multiplication whose result is later widened\
  \ when assigned/added to a wider integer (e.g., u64/dma_addr_t), potentially overflowing\
  \ before widening.\n\n1) No custom program state\n- Do not register any ProgramState\
  \ traits or maps. This checker is purely syntactic/type-based and path-insensitive\
  \ for this pattern.\n\n2) Chosen callbacks\n- checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const\n  Purpose: Catch assignments and compound assignments\
  \ when a value is bound to a location. Inspect the LHS type (target) and the RHS\
  \ expression to see if the RHS contains a multiplication performed in a narrower\
  \ type than the target type.\n- checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C) const\n  Purpose: Catch variable initializations that assign a multiplication\
  \ result into a wide integer (e.g., u64, dma_addr_t).\n\n3) Shared helpers (internal\
  \ to the checker)\n- getTypeBitWidth(QualType QT, CheckerContext &C):\n  - Return\
  \ C.getASTContext().getTypeSize(QT) in bits.\n- isIntegerLike(QualType QT):\n  -\
  \ Return true if QT is an integer type or an enum type (IgnoreParens/Typedefs/Qualifiers).\n\
  - isWideTargetType(QualType QT, CheckerContext &C):\n  - Return true if isIntegerLike(QT)\
  \ and getTypeBitWidth(QT, C) >= 64.\n  - Also allow typedef-name checks: if QT is\
  \ a TypedefType whose decl name equals \"dma_addr_t\", still use bit width; only\
  \ report when width >= 64 (avoids false positives on 32-bit builds).\n- findFirstSuspiciousMul(const\
  \ Expr *E, unsigned TargetBits, const BinaryOperator *&OutMul, CheckerContext &C):\n\
  \  - Recursively traverse E (ignore parens and implicit casts).\n  - If node is\
  \ BinaryOperator with opcode BO_Mul:\n    - Let MulBits = getTypeBitWidth(MulExpr->getType(),\
  \ C).\n    - If MulBits < TargetBits, record this BinaryOperator in OutMul and stop.\n\
  \  - Otherwise, recurse into child expressions until a match is found or tree ends.\n\
  \  - This flags cases like:\n    - size64 = pitch32 * height32;\n    - addr64 +=\
  \ (src_x >> 16) * cpp8/32;\n    - addr64 += pitch32 * yoff32;\n    - addr64 = addr64\
  \ + (pitch32 * yoff32) + ...;\n- isConstantFolded(const Expr *E, CheckerContext\
  \ &C):\n  - Try EvaluateExprToInt(APSInt, E, C); return true if evaluation succeeds.\n\
  \  - If the multiplication expression is a fully constant expression (no runtime\
  \ multiplication), skip reporting to reduce noise.\n- emitReport(const BinaryOperator\
  \ *MulBO, QualType LHSType, CheckerContext &C):\n  - Create or reuse a BugType like\
  \ \"Mixed-width multiplication overflow\".\n  - Use generateNonFatalErrorNode and\
  \ emit a PathSensitiveBugReport at MulBO->getOperatorLoc().\n  - Message: \"Multiplication\
  \ occurs in narrower type then widened; possible overflow before assignment/addition\
  \ to wide type.\"\n  - Optionally include a short note: \"Cast an operand to 64-bit\
  \ or use a wide accumulator before multiply.\"\n\n4) checkBind implementation\n\
  - From S, find the syntactic context using parents:\n  - Try findSpecificTypeInParents<BinaryOperator>(S,\
  \ C) to capture simple assignment (=).\n  - Try findSpecificTypeInParents<CompoundAssignOperator>(S,\
  \ C) for +=, -=, etc.\n  - If neither found, return.\n- For BinaryOperator (simple\
  \ assignment):\n  - If not BO_Assign, return.\n  - Get LHS = BO->getLHS()->IgnoreParenImpCasts(),\
  \ RHS = BO->getRHS().\n  - Get LHSType = LHS->getType(). If !isWideTargetType(LHSType,\
  \ C), return.\n  - Search RHS for suspicious multiply:\n    - const BinaryOperator\
  \ *MulBO = nullptr;\n    - findFirstSuspiciousMul(RHS, getTypeBitWidth(LHSType,\
  \ C), MulBO, C).\n    - If no MulBO, return.\n    - If isConstantFolded(MulBO, C),\
  \ return.\n    - Otherwise, emitReport(MulBO, LHSType, C).\n- For CompoundAssignOperator\
  \ (e.g., +=):\n  - If the operator is not one of BO_AddAssign or BO_SubAssign, return.\
  \ (We care about adding/subtracting a product into wide accumulator; for BO_MulAssign,\
  \ the calculation already uses LHS' type, so it\u2019s generally safe.)\n  - Get\
  \ LHS = CAO->getLHS()->IgnoreParenImpCasts(), RHS = CAO->getRHS().\n  - If !isWideTargetType(LHSType,\
  \ C), return.\n  - Search RHS for suspicious multiply (same as above).\n  - If found\
  \ and not constant-folded, emit report.\n\n5) checkPostStmt(DeclStmt) implementation\n\
  - For each VarDecl in DS:\n  - If it has no initializer, continue.\n  - Let QT =\
  \ VD->getType(); if !isWideTargetType(QT, C), continue.\n  - Let Init = VD->getInit();\
  \ search for suspicious multiply:\n    - const BinaryOperator *MulBO = nullptr;\n\
  \    - findFirstSuspiciousMul(Init, getTypeBitWidth(QT, C), MulBO, C).\n  - If found\
  \ and not constant-folded, emit report.\n\n6) What this catches (examples aligned\
  \ with the patch)\n- args->size = args->pitch * args->height; where size is u64\
  \ and pitch/height are 32-bit.\n- addr += (new_state->src.x1 >> 16) * fb->format->cpp[0];\
  \ where addr is dma_addr_t (64-bit) and operands are 32-bit or smaller.\n- addr\
  \ += pitch * y_offset_in_blocks; where addr is 64-bit and both operands are 32-bit.\n\
  - Also handles longer chains where a multiplication subexpression is part of a larger\
  \ RHS used in assignment/addition to a wide integer.\n\n7) What is considered safe\
  \ (no report)\n- Either operand of the multiplication is explicitly widened (e.g.,\
  \ (u64)pitch * height), because the result type of '*' becomes >= target width;\
  \ getTypeBitWidth(MulExpr) >= TargetBits.\n- The multiplication is fully constant-evaluable\
  \ (optional suppression via isConstantFolded).\n- LHS target type < 64 bits (no\
  \ widening risk).\n- Compound multiply-assign like u64_acc *= u32_x; (computation\
  \ is done in LHS\u2019 wide type).\n\n8) Notes to keep implementation simple and\
  \ precise\n- Use getTypeSize in bits to compare operand/result vs target widths;\
  \ avoid architecture assumptions.\n- Rely on the result type of the '*' BinaryOperator:\
  \ if it\u2019s already >= target width, don\u2019t warn (covers correct fixes via\
  \ explicit casts/wide accumulators).\n- Deduplication is typically not necessary;\
  \ the AST node for '*' is unique at a location. If needed, key by SourceLocation\
  \ of '*'.\n\nThis minimal two-callback approach (checkBind and checkPostStmt) is\
  \ sufficient to detect the mixed-width multiplication overflow pattern described\
  \ in the target patch."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// No program state traits required\
  \ for this checker.\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::Bind,\n        check::PostStmt<DeclStmt>> {\n\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(std::make_unique<BugType>(this,\n\
  \                                     \"Mixed-width multiplication may overflow\
  \ before widening\",\n                                     \"Integer\")) {}\n\n\
  \  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \  void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;\n\nprivate:\n\
  \  // Helpers\n  static unsigned getTypeBitWidth(QualType QT, CheckerContext &C);\n\
  \  static bool isIntegerLike(QualType QT);\n  static bool isWideTargetType(QualType\
  \ QT, CheckerContext &C);\n  static bool isConstantFolded(const Expr *E, CheckerContext\
  \ &C);\n\n  static bool findFirstSuspiciousMul(const Stmt *S, unsigned TargetBits,\n\
  \                                     const BinaryOperator *&OutMul,\n         \
  \                            CheckerContext &C);\n\n  void emitReport(const BinaryOperator\
  \ *MulBO, QualType LHSType,\n                  CheckerContext &C) const;\n};\n\n\
  // Return bit width of a type.\nunsigned SAGenTestChecker::getTypeBitWidth(QualType\
  \ QT, CheckerContext &C) {\n  return C.getASTContext().getTypeSize(QT);\n}\n\n//\
  \ Check for integer-like types (integers and enums), ignoring typedefs/quals.\n\
  bool SAGenTestChecker::isIntegerLike(QualType QT) {\n  QT = QT.getCanonicalType();\n\
  \  return QT->isIntegerType() || QT->isEnumeralType();\n}\n\n// Wide target: integer-like\
  \ and width >= 64 bits (covers u64, dma_addr_t on 64-bit).\nbool SAGenTestChecker::isWideTargetType(QualType\
  \ QT, CheckerContext &C) {\n  if (!isIntegerLike(QT))\n    return false;\n\n  //\
  \ Special-case typedef names like dma_addr_t, but still rely on bit-width.\n  unsigned\
  \ Bits = getTypeBitWidth(QT, C);\n  return Bits >= 64;\n}\n\n// Try to fold expression\
  \ to constant integer. If succeeds, skip reporting.\nbool SAGenTestChecker::isConstantFolded(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E)\n    return false;\n  llvm::APSInt EvalRes;\n\
  \  return EvaluateExprToInt(EvalRes, E, C);\n}\n\n// DFS to find first multiply\
  \ whose resulting type is narrower than target.\nbool SAGenTestChecker::findFirstSuspiciousMul(const\
  \ Stmt *S, unsigned TargetBits,\n                                              const\
  \ BinaryOperator *&OutMul,\n                                              CheckerContext\
  \ &C) {\n  if (!S)\n    return false;\n\n  // Normalize expression nodes.\n  if\
  \ (const auto *E = dyn_cast<Expr>(S)) {\n    const Expr *NormE = E->IgnoreParenImpCasts();\n\
  \    if (NormE != E)\n      return findFirstSuspiciousMul(NormE, TargetBits, OutMul,\
  \ C);\n\n    if (const auto *BO = dyn_cast<BinaryOperator>(NormE)) {\n      if (BO->getOpcode()\
  \ == BO_Mul) {\n        // Only consider integer-like multiplication.\n        QualType\
  \ ResT = BO->getType();\n        if (isIntegerLike(ResT)) {\n          unsigned\
  \ MulBits = getTypeBitWidth(ResT, C);\n          if (MulBits < TargetBits) {\n \
  \           OutMul = BO;\n            return true;\n          }\n        }\n   \
  \   }\n      // Recurse into operands\n      if (findFirstSuspiciousMul(BO->getLHS(),\
  \ TargetBits, OutMul, C))\n        return true;\n      if (findFirstSuspiciousMul(BO->getRHS(),\
  \ TargetBits, OutMul, C))\n        return true;\n      return false;\n    }\n\n\
  \    // Generic recursion: traverse children.\n    for (const Stmt *Child : NormE->children())\
  \ {\n      if (findFirstSuspiciousMul(Child, TargetBits, OutMul, C))\n        return\
  \ true;\n    }\n    return false;\n  }\n\n  // For non-Expr statements, traverse\
  \ children.\n  for (const Stmt *Child : S->children()) {\n    if (findFirstSuspiciousMul(Child,\
  \ TargetBits, OutMul, C))\n      return true;\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::emitReport(const\
  \ BinaryOperator *MulBO, QualType LHSType,\n                                  CheckerContext\
  \ &C) const {\n  if (!MulBO)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  SmallString<128> Msg;\n  Msg += \"Multiplication occurs\
  \ in a narrower type and is widened after; \";\n  Msg += \"possible overflow before\
  \ assignment/addition to wide type\";\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  R->addRange(MulBO->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// Handle assignments and compound assignments that bind values to wide targets.\n\
  void SAGenTestChecker::checkBind(SVal, SVal, const Stmt *S, CheckerContext &C) const\
  \ {\n  if (!S)\n    return;\n\n  // Prefer detecting compound assignments first\
  \ (e.g., +=)\n  if (const auto *CAO = findSpecificTypeInParents<CompoundAssignOperator>(S,\
  \ C)) {\n    BinaryOperatorKind Op = CAO->getOpcode();\n    // We care about adding/subtracting\
  \ a product into a wide accumulator.\n    if (Op == BO_AddAssign || Op == BO_SubAssign)\
  \ {\n      const Expr *LHS = CAO->getLHS()->IgnoreParenImpCasts();\n      if (!LHS)\n\
  \        return;\n      QualType LT = LHS->getType();\n      if (!isWideTargetType(LT,\
  \ C))\n        return;\n\n      const BinaryOperator *MulBO = nullptr;\n      if\
  \ (findFirstSuspiciousMul(CAO->getRHS(), getTypeBitWidth(LT, C), MulBO, C)) {\n\
  \        // Skip fully constant folded cases.\n        if (MulBO && !isConstantFolded(MulBO,\
  \ C))\n          emitReport(MulBO, LT, C);\n      }\n    }\n    return;\n  }\n\n\
  \  // Handle simple assignments: T_wide lhs = <expr with mul>;\n  if (const auto\
  \ *BO = findSpecificTypeInParents<BinaryOperator>(S, C)) {\n    if (BO->getOpcode()\
  \ != BO_Assign)\n      return;\n\n    const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \    if (!LHS)\n      return;\n    QualType LT = LHS->getType();\n    if (!isWideTargetType(LT,\
  \ C))\n      return;\n\n    const Expr *RHS = BO->getRHS();\n    const BinaryOperator\
  \ *MulBO = nullptr;\n    if (findFirstSuspiciousMul(RHS, getTypeBitWidth(LT, C),\
  \ MulBO, C)) {\n      if (MulBO && !isConstantFolded(MulBO, C))\n        emitReport(MulBO,\
  \ LT, C);\n    }\n  }\n}\n\n// Handle variable initializations: wide_var = <expr\
  \ with mul>;\nvoid SAGenTestChecker::checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C) const {\n  if (!DS)\n    return;\n\n  for (const Decl *D : DS->decls()) {\n\
  \    const auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      continue;\n   \
  \ if (!VD->hasInit())\n      continue;\n\n    QualType T = VD->getType();\n    if\
  \ (!isWideTargetType(T, C))\n      continue;\n\n    const Expr *Init = VD->getInit();\n\
  \    const BinaryOperator *MulBO = nullptr;\n    if (findFirstSuspiciousMul(Init,\
  \ getTypeBitWidth(T, C), MulBO, C)) {\n      if (MulBO && !isConstantFolded(MulBO,\
  \ C))\n        emitReport(MulBO, T, C);\n    }\n  }\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects narrow or mixed-width multiplication\
  \ that may overflow before being assigned/added to a wide integer\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 2
tp_score: 2
