_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3f7d9c1964fcd16d02a8a9d4fd6f6cb60c4cc530
commit_type: Out-of-Bound
index: 4
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program state sets\
  \ for tracking device-provided lengths and validations.\nREGISTER_SET_WITH_PROGRAMSTATE(DeviceLenRegions,\
  \ const MemRegion*)\nREGISTER_SET_WITH_PROGRAMSTATE(DeviceLenSyms, SymbolRef)\n\
  REGISTER_SET_WITH_PROGRAMSTATE(ValidatedRegions, const MemRegion*)\nREGISTER_SET_WITH_PROGRAMSTATE(ValidatedSyms,\
  \ SymbolRef)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n   \
  \     check::BeginFunction,\n        check::PostCall,\n        check::PreCall,\n\
  \        check::Bind,\n        check::BranchCondition> {\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Unvalidated\
  \ device-provided length\", \"Memory Safety\")) {}\n\n  void checkBeginFunction(CheckerContext\
  \ &C) const;\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n  void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n  void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  bool isVirtioConfigRead(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  bool isCopySizeCall(const CallEvent\
  \ &Call, unsigned &LenIndex, CheckerContext &C) const;\n  void markLenRegionAsDeviceProvided(const\
  \ MemRegion *MR, CheckerContext &C) const;\n  void markLenSymbolAsDeviceProvided(SymbolRef\
  \ Sym, CheckerContext &C) const;\n  void markValidatedRegion(const MemRegion *MR,\
  \ CheckerContext &C) const;\n  void markValidatedSymbol(SymbolRef Sym, CheckerContext\
  \ &C) const;\n  bool isRegionDeviceLen(const MemRegion *MR, ProgramStateRef State)\
  \ const;\n  bool isSymbolDeviceLen(SymbolRef Sym, ProgramStateRef State) const;\n\
  \  bool isRegionValidated(const MemRegion *MR, ProgramStateRef State) const;\n \
  \ bool isSymbolValidated(SymbolRef Sym, ProgramStateRef State) const;\n  void tryRecordAssignmentLHSForCallResult(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void reportUnvalidatedLenUse(const\
  \ CallEvent &Call, const Expr *LenE, CheckerContext &C) const;\n};\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  // ProgramState maps/sets are empty by default for each function\
  \ context.\n  // Nothing to do here; kept for completeness per plan.\n}\n\nbool\
  \ SAGenTestChecker::isVirtioConfigRead(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n\
  \    return false;\n\n  // Only track these specific virtio config read helpers.\n\
  \  if (ExprHasName(OriginExpr, \"virtio_cread8\", C) ||\n      ExprHasName(OriginExpr,\
  \ \"virtio_cread16\", C) ||\n      ExprHasName(OriginExpr, \"virtio_cread32\", C))\n\
  \    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::isCopySizeCall(const\
  \ CallEvent &Call, unsigned &LenIndex, CheckerContext &C) const {\n  LenIndex =\
  \ 0;\n  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n   \
  \ return false;\n\n  // memcpy(void *dst, const void *src, size_t n)\n  if (ExprHasName(OriginExpr,\
  \ \"memcpy\", C)) {\n    LenIndex = 2;\n    return (Call.getNumArgs() > LenIndex);\n\
  \  }\n\n  // memmove(void *dst, const void *src, size_t n)\n  if (ExprHasName(OriginExpr,\
  \ \"memmove\", C)) {\n    LenIndex = 2;\n    return (Call.getNumArgs() > LenIndex);\n\
  \  }\n\n  // sg_init_one(struct scatterlist *sg, const void *buf, unsigned int buflen)\n\
  \  if (ExprHasName(OriginExpr, \"sg_init_one\", C)) {\n    LenIndex = 2;\n    return\
  \ (Call.getNumArgs() > LenIndex);\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::markLenRegionAsDeviceProvided(const\
  \ MemRegion *MR, CheckerContext &C) const {\n  if (!MR) return;\n  MR = MR->getBaseRegion();\n\
  \  if (!MR) return;\n\n  ProgramStateRef State = C.getState();\n  if (!State->contains<DeviceLenRegions>(MR))\
  \ {\n    State = State->add<DeviceLenRegions>(MR);\n    // If it was previously\
  \ validated spuriously, drop validation for conservativeness\n    if (State->contains<ValidatedRegions>(MR))\n\
  \      State = State->remove<ValidatedRegions>(MR);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::markLenSymbolAsDeviceProvided(SymbolRef Sym, CheckerContext\
  \ &C) const {\n  if (!Sym) return;\n  ProgramStateRef State = C.getState();\n  if\
  \ (!State->contains<DeviceLenSyms>(Sym)) {\n    State = State->add<DeviceLenSyms>(Sym);\n\
  \    if (State->contains<ValidatedSyms>(Sym))\n      State = State->remove<ValidatedSyms>(Sym);\n\
  \    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::markValidatedRegion(const\
  \ MemRegion *MR, CheckerContext &C) const {\n  if (!MR) return;\n  MR = MR->getBaseRegion();\n\
  \  if (!MR) return;\n  ProgramStateRef State = C.getState();\n  if (!State->contains<ValidatedRegions>(MR))\
  \ {\n    State = State->add<ValidatedRegions>(MR);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::markValidatedSymbol(SymbolRef Sym, CheckerContext\
  \ &C) const {\n  if (!Sym) return;\n  ProgramStateRef State = C.getState();\n  if\
  \ (!State->contains<ValidatedSyms>(Sym)) {\n    State = State->add<ValidatedSyms>(Sym);\n\
  \    C.addTransition(State);\n  }\n}\n\nbool SAGenTestChecker::isRegionDeviceLen(const\
  \ MemRegion *MR, ProgramStateRef State) const {\n  if (!MR) return false;\n  MR\
  \ = MR->getBaseRegion();\n  if (!MR) return false;\n  return State->contains<DeviceLenRegions>(MR);\n\
  }\n\nbool SAGenTestChecker::isSymbolDeviceLen(SymbolRef Sym, ProgramStateRef State)\
  \ const {\n  if (!Sym) return false;\n  return State->contains<DeviceLenSyms>(Sym);\n\
  }\n\nbool SAGenTestChecker::isRegionValidated(const MemRegion *MR, ProgramStateRef\
  \ State) const {\n  if (!MR) return false;\n  MR = MR->getBaseRegion();\n  if (!MR)\
  \ return false;\n  return State->contains<ValidatedRegions>(MR);\n}\n\nbool SAGenTestChecker::isSymbolValidated(SymbolRef\
  \ Sym, ProgramStateRef State) const {\n  if (!Sym) return false;\n  return State->contains<ValidatedSyms>(Sym);\n\
  }\n\n// When a virtio_cread* call is used in an assignment or initialization,\n\
  // try to identify and record the LHS region as a device-provided length.\nvoid\
  \ SAGenTestChecker::tryRecordAssignmentLHSForCallResult(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  const Expr *CallE = dyn_cast_or_null<Expr>(Call.getOriginExpr());\n\
  \  if (!CallE)\n    return;\n\n  // Case 1: Parent assignment 'LHS = virtio_cread*()'\n\
  \  if (const auto *BO = findSpecificTypeInParents<BinaryOperator>(CallE, C)) {\n\
  \    if (BO->isAssignmentOp()) {\n      const Expr *LHS = BO->getLHS();\n      if\
  \ (LHS) {\n        const MemRegion *MR = getMemRegionFromExpr(LHS, C);\n       \
  \ if (MR) {\n          MR = MR->getBaseRegion();\n          markLenRegionAsDeviceProvided(MR,\
  \ C);\n        }\n      }\n    }\n  }\n\n  // Case 2: Declaration with init 'u8\
  \ len = virtio_cread*()'\n  if (const auto *DS = findSpecificTypeInParents<DeclStmt>(CallE,\
  \ C)) {\n    for (const Decl *D : DS->decls()) {\n      if (const auto *VD = dyn_cast<VarDecl>(D))\
  \ {\n        if (const Expr *Init = VD->getInit()) {\n          // Ensure this var\
  \ is initialized from this exact call.\n          const CallExpr *InnerCall = findSpecificTypeInChildren<CallExpr>(Init);\n\
  \          if (!InnerCall || InnerCall != CallE)\n            continue;\n      \
  \    const MemRegion *MR = getMemRegionFromExpr(Init, C);\n          if (!MR) {\n\
  \            // If Init region retrieval fails, try region of the Var itself.\n\
  \            SVal LVal = C.getSValBuilder().getLValue(VD, C.getLocationContext());\n\
  \            MR = LVal.getAsRegion();\n          }\n          if (MR) {\n      \
  \      MR = MR->getBaseRegion();\n            markLenRegionAsDeviceProvided(MR,\
  \ C);\n          }\n        }\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isVirtioConfigRead(Call, C))\n\
  \    return;\n\n  // Mark the return symbol (if any) as device-provided length.\n\
  \  SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\n  if (RetSym)\n    markLenSymbolAsDeviceProvided(RetSym,\
  \ C);\n\n  // Try to find the LHS region into which the result is stored and mark\
  \ it.\n  tryRecordAssignmentLHSForCallResult(Call, C);\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n  const MemRegion *DestR = Loc.getAsRegion();\n  if (!DestR)\n\
  \    return;\n  DestR = DestR->getBaseRegion();\n  if (!DestR)\n    return;\n\n\
  \  const MemRegion *SrcR = Val.getAsRegion();\n  if (SrcR)\n    SrcR = SrcR->getBaseRegion();\n\
  \n  SymbolRef SrcSym = Val.getAsSymbol();\n\n  bool PropagateDevice = false;\n \
  \ bool PropagateValidated = false;\n\n  if (SrcR && isRegionDeviceLen(SrcR, State))\n\
  \    PropagateDevice = true;\n  if (SrcSym && isSymbolDeviceLen(SrcSym, State))\n\
  \    PropagateDevice = true;\n\n  if (SrcR && isRegionValidated(SrcR, State))\n\
  \    PropagateValidated = true;\n  if (SrcSym && isSymbolValidated(SrcSym, State))\n\
  \    PropagateValidated = true;\n\n  if (PropagateDevice) {\n    State = State->add<DeviceLenRegions>(DestR);\n\
  \    // Do not automatically clear validation state here; use separate logic.\n\
  \  }\n  if (PropagateValidated) {\n    State = State->add<ValidatedRegions>(DestR);\n\
  \  }\n\n  if (State != C.getState())\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!Condition)\n    return;\n\n\
  \  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n    return;\n\n\
  \  // Look for any comparison involving the macro VIRTIO_NET_RSS_MAX_KEY_SIZE\n\
  \  // and a device-provided length region/symbol.\n  const BinaryOperator *BO =\
  \ dyn_cast<BinaryOperator>(CondE->IgnoreParenCasts());\n  if (!BO)\n    BO = findSpecificTypeInChildren<BinaryOperator>(Condition);\n\
  \  if (!BO)\n    return;\n\n  BinaryOperator::Opcode Op = BO->getOpcode();\n  switch\
  \ (Op) {\n    case BO_GT: case BO_GE:\n    case BO_LT: case BO_LE:\n    case BO_EQ:\
  \ case BO_NE:\n      break;\n    default:\n      return;\n  }\n\n  const Expr *LHS\
  \ = BO->getLHS();\n  const Expr *RHS = BO->getRHS();\n  if (!LHS || !RHS)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n\n  // Helper lambda to attempt marking\
  \ validated if one side is device-len and the other mentions the macro.\n  auto\
  \ TryValidate = [&](const Expr *LenSide, const Expr *MacroSide) {\n    bool MacroMentioned\
  \ = ExprHasName(MacroSide, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\", C);\n    if (!MacroMentioned)\n\
  \      return false;\n\n    const MemRegion *MR = getMemRegionFromExpr(LenSide,\
  \ C);\n    if (MR)\n      MR = MR->getBaseRegion();\n    SymbolRef Sym = State->getSVal(LenSide,\
  \ C.getLocationContext()).getAsSymbol();\n\n    bool IsDev = (MR && isRegionDeviceLen(MR,\
  \ State)) || (Sym && isSymbolDeviceLen(Sym, State));\n    if (!IsDev)\n      return\
  \ false;\n\n    if (MR)\n      markValidatedRegion(MR, C);\n    if (Sym)\n     \
  \ markValidatedSymbol(Sym, C);\n    return true;\n  };\n\n  bool Changed = false;\n\
  \  Changed |= TryValidate(LHS, RHS);\n  Changed |= TryValidate(RHS, LHS);\n\n  if\
  \ (Changed)\n    return; // Transitions already added by markValidated*\n}\n\nvoid\
  \ SAGenTestChecker::reportUnvalidatedLenUse(const CallEvent &Call, const Expr *LenE,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Unvalidated device-provided length used as copy size (possible OOB).\"\
  , N);\n  if (LenE)\n    R->addRange(LenE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  unsigned LenIndex = 0;\n  if (!isCopySizeCall(Call, LenIndex, C))\n\
  \    return;\n\n  if (Call.getNumArgs() <= LenIndex)\n    return;\n\n  const Expr\
  \ *LenE = Call.getArgExpr(LenIndex);\n  if (!LenE)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n\n  const MemRegion *LenR = getMemRegionFromExpr(LenE,\
  \ C);\n  if (LenR)\n    LenR = LenR->getBaseRegion();\n  SymbolRef LenSym = State->getSVal(LenE,\
  \ C.getLocationContext()).getAsSymbol();\n\n  bool IsDevLen = (LenR && isRegionDeviceLen(LenR,\
  \ State)) ||\n                  (LenSym && isSymbolDeviceLen(LenSym, State));\n\n\
  \  if (!IsDevLen)\n    return;\n\n  bool IsValidated = (LenR && isRegionValidated(LenR,\
  \ State)) ||\n                     (LenSym && isSymbolValidated(LenSym, State));\n\
  \n  if (!IsValidated) {\n    reportUnvalidatedLenUse(Call, LenE, C);\n  }\n}\n\n\
  } // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects using device-provided length without validating against VIRTIO_NET_RSS_MAX_KEY_SIZE\
  \ in size-sensitive calls\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nvirtio_net: Add hash_key_length check\n\nAdd hash_key_length\
  \ check in virtnet_probe() to avoid possible out of\nbound errors when setting/reading\
  \ the hash key.\n\nFixes: c7114b1249fa (\"drivers/net/virtio_net: Added basic RSS\
  \ support.\")\nSigned-off-by: Philo Lu <lulie@linux.alibaba.com>\nSigned-off-by:\
  \ Xuan Zhuo <xuanzhuo@linux.alibaba.com>\nAcked-by: Joe Damato <jdamato@fastly.com>\n\
  Acked-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: virtnet_probe in drivers/net/virtio_net.c\n\
  static int virtnet_probe(struct virtio_device *vdev)\n{\n\tint i, err = -ENOMEM;\n\
  \tstruct net_device *dev;\n\tstruct virtnet_info *vi;\n\tu16 max_queue_pairs;\n\t\
  int mtu = 0;\n\n\t/* Find if host supports multiqueue/rss virtio_net device */\n\
  \tmax_queue_pairs = 1;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MQ) || virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_RSS))\n\t\tmax_queue_pairs =\n\t\t     virtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config, max_virtqueue_pairs));\n\n\t/* We need at least 2 queue's */\n\
  \tif (max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||\n\t    max_queue_pairs\
  \ > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||\n\t    !virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\
  \t\tmax_queue_pairs = 1;\n\n\t/* Allocate ourselves a network device with room for\
  \ our info */\n\tdev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);\n\
  \tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* Set up network device as normal. */\n\t\
  dev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE |\n\t\t\t   IFF_TX_SKB_NO_LINEAR;\n\
  \tdev->netdev_ops = &virtnet_netdev;\n\tdev->stat_ops = &virtnet_stat_ops;\n\tdev->features\
  \ = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev,\
  \ &vdev->dev);\n\n\t/* Do we support \"hardware\" checksums? */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_CSUM)) {\n\t\t/* This opens up the world of extra features. */\n\t\
  \tdev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\t\tif (csum)\n\t\t\tdev->features\
  \ |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO))\
  \ {\n\t\t\tdev->hw_features |= NETIF_F_TSO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\
  \t\t}\n\t\t/* Individual feature bits: what can host handle? */\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_ECN))\n\t\t\tdev->hw_features |= NETIF_F_TSO_ECN;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_USO))\n\t\t\tdev->hw_features |= NETIF_F_GSO_UDP_L4;\n\n\t\t\
  dev->features |= NETIF_F_GSO_ROBUST;\n\n\t\tif (gso)\n\t\t\tdev->features |= dev->hw_features\
  \ & NETIF_F_ALL_TSO;\n\t\t/* (!csum && gso) case will be fixed by register_netdev()\
  \ */\n\t}\n\n\t/* 1. With VIRTIO_NET_F_GUEST_CSUM negotiation, the driver doesn't\n\
  \t * need to calculate checksums for partially checksummed packets,\n\t * as they're\
  \ considered valid by the upper layer.\n\t * 2. Without VIRTIO_NET_F_GUEST_CSUM\
  \ negotiation, the driver only\n\t * receives fully checksummed packets. The device\
  \ may assist in\n\t * validating these packets' checksums, so the driver won't have\
  \ to.\n\t */\n\tdev->features |= NETIF_F_RXCSUM;\n\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_GUEST_TSO4) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6))\n\
  \t\tdev->features |= NETIF_F_GRO_HW;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS))\n\
  \t\tdev->hw_features |= NETIF_F_GRO_HW;\n\n\tdev->vlan_features = dev->features;\n\
  \tdev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT;\n\n\t/* MTU\
  \ range: 68 - 65535 */\n\tdev->min_mtu = MIN_MTU;\n\tdev->max_mtu = MAX_MTU;\n\n\
  \t/* Configuration may specify what MAC to use.  Otherwise random. */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MAC)) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tvirtio_cread_bytes(vdev,\n\
  \t\t\t\t   offsetof(struct virtio_net_config, mac),\n\t\t\t\t   addr, ETH_ALEN);\n\
  \t\teth_hw_addr_set(dev, addr);\n\t} else {\n\t\teth_hw_addr_random(dev);\n\t\t\
  dev_info(&vdev->dev, \"Assigned random MAC address %pM\\n\",\n\t\t\t dev->dev_addr);\n\
  \t}\n\n\t/* Set up our device-specific information */\n\tvi = netdev_priv(dev);\n\
  \tvi->dev = dev;\n\tvi->vdev = vdev;\n\tvdev->priv = vi;\n\n\tINIT_WORK(&vi->config_work,\
  \ virtnet_config_changed_work);\n\tINIT_WORK(&vi->rx_mode_work, virtnet_rx_mode_work);\n\
  \tspin_lock_init(&vi->refill_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))\
  \ {\n\t\tvi->mergeable_rx_bufs = true;\n\t\tdev->xdp_features |= NETDEV_XDP_ACT_RX_SG;\n\
  \t}\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HASH_REPORT))\n\t\tvi->has_rss_hash_report\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_RSS)) {\n\t\tvi->has_rss\
  \ = true;\n\n\t\tvi->rss_indir_table_size =\n\t\t\tvirtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config,\n\t\t\t\trss_max_indirection_table_length));\n\t}\n\terr =\
  \ rss_indirection_table_alloc(&vi->rss, vi->rss_indir_table_size);\n\tif (err)\n\
  \t\tgoto free;\n\n\tif (vi->has_rss || vi->has_rss_hash_report) {\n\t\tvi->rss_key_size\
  \ =\n\t\t\tvirtio_cread8(vdev, offsetof(struct virtio_net_config, rss_max_key_size));\n\
  \n\t\tvi->rss_hash_types_supported =\n\t\t    virtio_cread32(vdev, offsetof(struct\
  \ virtio_net_config, supported_hash_types));\n\t\tvi->rss_hash_types_supported &=\n\
  \t\t\t\t~(VIRTIO_NET_RSS_HASH_TYPE_IP_EX |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_TCP_EX\
  \ |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_UDP_EX);\n\n\t\tdev->hw_features |= NETIF_F_RXHASH;\n\
  \t\tdev->xdp_metadata_ops = &virtnet_xdp_metadata_ops;\n\t}\n\n\tif (vi->has_rss_hash_report)\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_v1_hash);\n\telse if (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MRG_RXBUF) ||\n\t\t virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\telse\n\t\tvi->hdr_len\
  \ = sizeof(struct virtio_net_hdr);\n\n\tif (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT)\
  \ ||\n\t    virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\tvi->any_header_sg\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\t\tvi->has_cvq\
  \ = true;\n\n\tmutex_init(&vi->cvq_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MTU))\
  \ {\n\t\tmtu = virtio_cread16(vdev,\n\t\t\t\t     offsetof(struct virtio_net_config,\n\
  \t\t\t\t\t      mtu));\n\t\tif (mtu < dev->min_mtu) {\n\t\t\t/* Should never trigger:\
  \ MTU was previously validated\n\t\t\t * in virtnet_validate.\n\t\t\t */\n\t\t\t\
  dev_err(&vdev->dev,\n\t\t\t\t\"device MTU appears to have changed it is now %d <\
  \ %d\",\n\t\t\t\tmtu, dev->min_mtu);\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\
  \t}\n\n\t\tdev->mtu = mtu;\n\t\tdev->max_mtu = mtu;\n\t}\n\n\tvirtnet_set_big_packets(vi,\
  \ mtu);\n\n\tif (vi->any_header_sg)\n\t\tdev->needed_headroom = vi->hdr_len;\n\n\
  \t/* Enable multiqueue by default */\n\tif (num_online_cpus() >= max_queue_pairs)\n\
  \t\tvi->curr_queue_pairs = max_queue_pairs;\n\telse\n\t\tvi->curr_queue_pairs =\
  \ num_online_cpus();\n\tvi->max_queue_pairs = max_queue_pairs;\n\n\t/* Allocate/initialize\
  \ the rx/tx queues, and invoke find_vqs */\n\terr = init_vqs(vi);\n\tif (err)\n\t\
  \tgoto free;\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_NOTF_COAL)) {\n\t\
  \tvi->intr_coal_rx.max_usecs = 0;\n\t\tvi->intr_coal_tx.max_usecs = 0;\n\t\tvi->intr_coal_rx.max_packets\
  \ = 0;\n\n\t\t/* Keep the default values of the coalescing parameters\n\t\t * aligned\
  \ with the default napi_tx state.\n\t\t */\n\t\tif (vi->sq[0].napi.weight)\n\t\t\
  \tvi->intr_coal_tx.max_packets = 1;\n\t\telse\n\t\t\tvi->intr_coal_tx.max_packets\
  \ = 0;\n\t}\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_VQ_NOTF_COAL)) {\n\
  \t\t/* The reason is the same as VIRTIO_NET_F_NOTF_COAL. */\n\t\tfor (i = 0; i <\
  \ vi->max_queue_pairs; i++)\n\t\t\tif (vi->sq[i].napi.weight)\n\t\t\t\tvi->sq[i].intr_coal.max_packets\
  \ = 1;\n\n\t\terr = virtnet_init_irq_moder(vi);\n\t\tif (err)\n\t\t\tgoto free;\n\
  \t}\n\n#ifdef CONFIG_SYSFS\n\tif (vi->mergeable_rx_bufs)\n\t\tdev->sysfs_rx_queue_group\
  \ = &virtio_net_mrg_rx_group;\n#endif\n\tnetif_set_real_num_tx_queues(dev, vi->curr_queue_pairs);\n\
  \tnetif_set_real_num_rx_queues(dev, vi->curr_queue_pairs);\n\n\tvirtnet_init_settings(dev);\n\
  \n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_STANDBY)) {\n\t\tvi->failover = net_failover_create(vi->dev);\n\
  \t\tif (IS_ERR(vi->failover)) {\n\t\t\terr = PTR_ERR(vi->failover);\n\t\t\tgoto\
  \ free_vqs;\n\t\t}\n\t}\n\n\tif (vi->has_rss || vi->has_rss_hash_report)\n\t\tvirtnet_init_default_rss(vi);\n\
  \n\tenable_rx_mode_work(vi);\n\n\t/* serialize netdev register + virtio_device_ready()\
  \ with ndo_open() */\n\trtnl_lock();\n\n\terr = register_netdevice(dev);\n\tif (err)\
  \ {\n\t\tpr_debug(\"virtio_net: registering device failed\\n\");\n\t\trtnl_unlock();\n\
  \t\tgoto free_failover;\n\t}\n\n\t/* Disable config change notification until ndo_open.\
  \ */\n\tvirtio_config_driver_disable(vi->vdev);\n\n\tvirtio_device_ready(vdev);\n\
  \n\tvirtnet_set_queues(vi, vi->curr_queue_pairs);\n\n\t/* a random MAC address has\
  \ been assigned, notify the device.\n\t * We don't fail probe if VIRTIO_NET_F_CTRL_MAC_ADDR\
  \ is not there\n\t * because many devices work fine without getting MAC explicitly\n\
  \t */\n\tif (!virtio_has_feature(vdev, VIRTIO_NET_F_MAC) &&\n\t    virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_CTRL_MAC_ADDR)) {\n\t\tstruct scatterlist sg;\n\n\t\tsg_init_one(&sg,\
  \ dev->dev_addr, dev->addr_len);\n\t\tif (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MAC,\n\
  \t\t\t\t\t  VIRTIO_NET_CTRL_MAC_ADDR_SET, &sg)) {\n\t\t\tpr_debug(\"virtio_net:\
  \ setting MAC address failed\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr = -EINVAL;\n\
  \t\t\tgoto free_unregister_netdev;\n\t\t}\n\t}\n\n\tif (virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_DEVICE_STATS)) {\n\t\tstruct virtio_net_stats_capabilities *stats_cap\
  \  __free(kfree) = NULL;\n\t\tstruct scatterlist sg;\n\t\t__le64 v;\n\n\t\tstats_cap\
  \ = kzalloc(sizeof(*stats_cap), GFP_KERNEL);\n\t\tif (!stats_cap) {\n\t\t\trtnl_unlock();\n\
  \t\t\terr = -ENOMEM;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tsg_init_one(&sg,\
  \ stats_cap, sizeof(*stats_cap));\n\n\t\tif (!virtnet_send_command_reply(vi, VIRTIO_NET_CTRL_STATS,\n\
  \t\t\t\t\t\tVIRTIO_NET_CTRL_STATS_QUERY,\n\t\t\t\t\t\tNULL, &sg)) {\n\t\t\tpr_debug(\"\
  virtio_net: fail to get stats capability\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr\
  \ = -EINVAL;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tv = stats_cap->supported_stats_types[0];\n\
  \t\tvi->device_stats_cap = le64_to_cpu(v);\n\t}\n\n\t/* Assume link up if device\
  \ can't report link status,\n\t   otherwise get link status from config. */\n\t\
  netif_carrier_off(dev);\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS))\
  \ {\n\t\tvirtnet_config_changed_work(&vi->config_work);\n\t} else {\n\t\tvi->status\
  \ = VIRTIO_NET_S_LINK_UP;\n\t\tvirtnet_update_settings(vi);\n\t\tnetif_carrier_on(dev);\n\
  \t}\n\n\tfor (i = 0; i < ARRAY_SIZE(guest_offloads); i++)\n\t\tif (virtio_has_feature(vi->vdev,\
  \ guest_offloads[i]))\n\t\t\tset_bit(guest_offloads[i], &vi->guest_offloads);\n\t\
  vi->guest_offloads_capable = vi->guest_offloads;\n\n\trtnl_unlock();\n\n\terr =\
  \ virtnet_cpu_notif_add(vi);\n\tif (err) {\n\t\tpr_debug(\"virtio_net: registering\
  \ cpu notifier failed\\n\");\n\t\tgoto free_unregister_netdev;\n\t}\n\n\tpr_debug(\"\
  virtnet: registered device %s with %d RX and TX vq's\\n\",\n\t\t dev->name, max_queue_pairs);\n\
  \n\treturn 0;\n\nfree_unregister_netdev:\n\tunregister_netdev(dev);\nfree_failover:\n\
  \tnet_failover_destroy(vi->failover);\nfree_vqs:\n\tvirtio_reset_device(vdev);\n\
  \tcancel_delayed_work_sync(&vi->refill);\n\tfree_receive_page_frags(vi);\n\tvirtnet_del_vqs(vi);\n\
  free:\n\tfree_netdev(dev);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c\nindex 4b507007d242..545dda8ec077\
  \ 100644\n--- a/drivers/net/virtio_net.c\n+++ b/drivers/net/virtio_net.c\n@@ -6451,6\
  \ +6451,12 @@ static int virtnet_probe(struct virtio_device *vdev)\n \tif (vi->has_rss\
  \ || vi->has_rss_hash_report) {\n \t\tvi->rss_key_size =\n \t\t\tvirtio_cread8(vdev,\
  \ offsetof(struct virtio_net_config, rss_max_key_size));\n+\t\tif (vi->rss_key_size\
  \ > VIRTIO_NET_RSS_MAX_KEY_SIZE) {\n+\t\t\tdev_err(&vdev->dev, \"rss_max_key_size=%u\
  \ exceeds the limit %u.\\n\",\n+\t\t\t\tvi->rss_key_size, VIRTIO_NET_RSS_MAX_KEY_SIZE);\n\
  +\t\t\terr = -EINVAL;\n+\t\t\tgoto free;\n+\t\t}\n \n \t\tvi->rss_hash_types_supported\
  \ =\n \t\t    virtio_cread32(vdev, offsetof(struct virtio_net_config, supported_hash_types));\n\
  ```\n"
pattern: "## Bug Pattern\n\nUsing a device\u2011provided length field directly to\
  \ size/copy into a fixed\u2011size buffer without validating it against the driver\u2019\
  s maximum, leading to potential out\u2011of\u2011bounds access.\n\nExample pattern:\n\
  - size = read_from_device(...);  // untrusted length (e.g., rss_max_key_size)\n\
  - // missing: if (size > MAX_ALLOWED) error\n- memcpy(fixed_buf, src, size);   //\
  \ OOB if size > sizeof(fixed_buf)\n\nIn this patch, rss_max_key_size from virtio\
  \ config was used without checking it against VIRTIO_NET_RSS_MAX_KEY_SIZE, risking\
  \ OOB when setting/reading the RSS hash key."
plan: "1) Program state customizations\n- REGISTER_SET_WITH_PROGRAMSTATE(DeviceLenRegions,\
  \ const MemRegion*)\n  - Regions that hold device-provided length values (e.g.,\
  \ vi->rss_key_size) that currently have no proven upper-bound check.\n- REGISTER_SET_WITH_PROGRAMSTATE(DeviceLenSyms,\
  \ SymbolRef)\n  - Symbols produced by device-config read calls that are used as\
  \ \u201Clength\u201D before being stored to a region.\n- REGISTER_SET_WITH_PROGRAMSTATE(ValidatedRegions,\
  \ const MemRegion*)\n  - Regions proven to have been validated against the required\
  \ max bound.\n- REGISTER_SET_WITH_PROGRAMSTATE(ValidatedSyms, SymbolRef)\n  - Symbols\
  \ proven to have been validated against the required max bound.\n\n2) Helper configuration/constants\n\
  - Known device-config read functions (exact-name match):\n  - virtio_cread8, virtio_cread16,\
  \ virtio_cread32\n- Known (ptr,len) style calls to flag if len is device-provided\
  \ and unvalidated:\n  - memcpy (len index = 2), memmove (len index = 2), sg_init_one\
  \ (len index = 2)\n- The specific macro name we want to see in a validation check:\n\
  \  - \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\n- Use provided utilities:\n  - findSpecificTypeInParents/findSpecificTypeInChildren\n\
  \  - getMemRegionFromExpr\n  - ExprHasName\n\n3) Callbacks and detailed steps\n\n\
  A) checkBeginFunction\n- Clear all four sets (DeviceLenRegions, DeviceLenSyms, ValidatedRegions,\
  \ ValidatedSyms) for a fresh, per-function analysis state.\n\nB) checkPostCall \u2014\
  \ identify device-provided length on assignment/initialization\n- If callee name\
  \ is one of virtio_cread8/16/32:\n  - Record the call's return SymbolRef (if any)\
  \ into DeviceLenSyms.\n  - Also attempt to map the call result to a destination\
  \ region:\n    - Find a parent BinaryOperator of kind \u201C=\u201D containing this\
  \ call (RHS). If found:\n      - Extract LHS, get its MemRegion via getMemRegionFromExpr;\
  \ if present:\n        - Add region to DeviceLenRegions; remove it from ValidatedRegions\
  \ if present.\n    - Else, find a parent DeclStmt (initialization like \"u8 len\
  \ = virtio_cread8(...)\"):\n      - For each initialized VarDecl whose init contains\
  \ the call, get its MemRegion; add it to DeviceLenRegions; remove it from ValidatedRegions\
  \ if present.\n\nC) checkBind \u2014 propagate device-length and validation across\
  \ assignments\n- When binding a value to a location:\n  - Let DestR be the MemRegion\
  \ of LHS; get MemRegion from LHS expression (if any).\n  - If RHS is:\n    - A MemRegion\
  \ that is in DeviceLenRegions OR\n    - A SymbolRef that is in DeviceLenSyms\n \
  \   then add DestR to DeviceLenRegions.\n  - If RHS is:\n    - A MemRegion in ValidatedRegions\
  \ OR\n    - A SymbolRef in ValidatedSyms\n    then also add DestR to ValidatedRegions\
  \ (propagate validated-ness).\n  - Do not remove validated if RHS is not validated;\
  \ only add.\n\nD) checkBranchCondition \u2014 detect the required validation pattern\n\
  - Goal: mark the device-provided len as validated if compared against VIRTIO_NET_RSS_MAX_KEY_SIZE.\n\
  - Inspect the condition expression:\n  - Try dyn_cast to BinaryOperator; if not,\
  \ use findSpecificTypeInChildren<BinaryOperator>(Condition).\n  - If a BinaryOperator\
  \ with comparison opcode (>, >=, <, <=, ==, !=) is found:\n    - For each side L\
  \ and R:\n      - Extract MemRegion of subexpr (getMemRegionFromExpr). Also try\
  \ extracting SymbolRef by querying SVal from the subexpr.\n      - The other side\
  \ (counterpart) is checked for macro text: use ExprHasName(otherSideExpr, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C).\n      - If either a region in DeviceLenRegions or a symbol in DeviceLenSyms\
  \ is found on one side, and the other side textually contains \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  :\n        - Mark that region/symbol as validated: add to ValidatedRegions/ValidatedSyms.\n\
  - Rationale: This mirrors the added patch \"if (vi->rss_key_size > VIRTIO_NET_RSS_MAX_KEY_SIZE)\
  \ { ... }\".\n\nE) checkPreCall \u2014 flag unvalidated use of device-provided length\
  \ as size\n- If call is one of the known (ptr,len) style functions:\n  - Identify\
  \ \u201Clength\u201D argument index (2 for memcpy/memmove/sg_init_one).\n  - Let\
  \ LenE be the length arg Expr; obtain:\n    - MemRegion RLen via getMemRegionFromExpr(LenE).\n\
  \    - SymbolRef SLen from C.getSVal(LenE, ...).getAsSymbol().\n  - Consider the\
  \ length \u201Ctainted by device\u201D if RLen \u2208 DeviceLenRegions OR SLen \u2208\
  \ DeviceLenSyms.\n  - Consider the length \u201Cvalidated\u201D if RLen \u2208 ValidatedRegions\
  \ OR SLen \u2208 ValidatedSyms.\n  - If device-tainted and not validated:\n    -\
  \ Emit a bug.\n    - Message: \"Unvalidated device-provided length used as copy\
  \ size (possible OOB).\"\n- Note: We intentionally do not require confirming the\
  \ destination fixed-size buffer at this step; the pattern\u2019s essence is using\
  \ untrusted device length directly as a size in a dereferencing call. This keeps\
  \ the rule simple and aligned with the patch motivation.\n\n4) Reporting\n- Use\
  \ generateNonFatalErrorNode; if node is null, return.\n- Use std::make_unique<PathSensitiveBugReport>\
  \ with a concise message:\n  - Title: \"Unvalidated device-provided length\"\n \
  \ - Description: \"Unvalidated device-provided length used as copy size (possible\
  \ OOB).\"\n- Optionally add a note at the source of the device-length assignment\
  \ (if tracked via parent BinaryOperator/DeclStmt) to help navigation.\n\n5) False-positive\
  \ controls and refinements\n- Only treat lengths coming from the exact virtio_cread8/16/32\
  \ functions to minimize noise.\n- Only set \u201Cvalidated\u201D if the comparison\
  \ condition textually mentions \"VIRTIO_NET_RSS_MAX_KEY_SIZE\".\n- Do not attempt\
  \ generic MAX detection or value inference to keep the rule precise for the target\
  \ pattern.\n\n6) Optional minor enhancements (if desired later)\n- Also recognize\
  \ additional data movement APIs frequently used with (ptr,len), like memcpy_toio/memcpy_fromio,\
  \ skb_put_data, or other scatterlist initializers (keep indices similarly defined).\n\
  - Use inferSymbolMaxVal(Sym, C) to suppress warnings if the solver has already constrained\
  \ the symbol to be \u2264 a known bound (if obtainable). This is optional and not\
  \ necessary for the core pattern detection.\n- For validations, also recognize \u201C\
  if (len > MAX) return -EINVAL;\u201D patterns by treating any branch comparison\
  \ (regardless of taken direction) as a validation event for the symbol/region on\
  \ both successors. This keeps path-sensitivity low while being practical.\n\n7)\
  \ Summary of minimal flow to catch the given patch\n- PostCall of virtio_cread8\
  \ \u2192 mark LHS (vi->rss_key_size) as DeviceLenRegion.\n- If BranchCondition compares\
  \ vi->rss_key_size against VIRTIO_NET_RSS_MAX_KEY_SIZE \u2192 mark as validated.\n\
  - PreCall of sg_init_one (or memcpy) where length arg is vi->rss_key_size:\n  -\
  \ If not validated \u2192 report."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program state sets for tracking device-provided lengths and validations.\nREGISTER_SET_WITH_PROGRAMSTATE(DeviceLenRegions,\
  \ const MemRegion*)\nREGISTER_SET_WITH_PROGRAMSTATE(DeviceLenSyms, SymbolRef)\n\
  REGISTER_SET_WITH_PROGRAMSTATE(ValidatedRegions, const MemRegion*)\nREGISTER_SET_WITH_PROGRAMSTATE(ValidatedSyms,\
  \ SymbolRef)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n   \
  \     check::BeginFunction,\n        check::PostCall,\n        check::PreCall,\n\
  \        check::Bind,\n        check::BranchCondition> {\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Unvalidated\
  \ device-provided length\", \"Memory Safety\")) {}\n\n  void checkBeginFunction(CheckerContext\
  \ &C) const;\n  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n  void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n  void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  bool isVirtioConfigRead(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  bool isCopySizeCall(const CallEvent\
  \ &Call, unsigned &LenIndex, CheckerContext &C) const;\n  void markLenRegionAsDeviceProvided(const\
  \ MemRegion *MR, CheckerContext &C) const;\n  void markLenSymbolAsDeviceProvided(SymbolRef\
  \ Sym, CheckerContext &C) const;\n  void markValidatedRegion(const MemRegion *MR,\
  \ CheckerContext &C) const;\n  void markValidatedSymbol(SymbolRef Sym, CheckerContext\
  \ &C) const;\n  bool isRegionDeviceLen(const MemRegion *MR, ProgramStateRef State)\
  \ const;\n  bool isSymbolDeviceLen(SymbolRef Sym, ProgramStateRef State) const;\n\
  \  bool isRegionValidated(const MemRegion *MR, ProgramStateRef State) const;\n \
  \ bool isSymbolValidated(SymbolRef Sym, ProgramStateRef State) const;\n  void tryRecordAssignmentLHSForCallResult(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void reportUnvalidatedLenUse(const\
  \ CallEvent &Call, const Expr *LenE, CheckerContext &C) const;\n};\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  // ProgramState maps/sets are empty by default for each function\
  \ context.\n  // Nothing to do here; kept for completeness per plan.\n}\n\nbool\
  \ SAGenTestChecker::isVirtioConfigRead(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n\
  \    return false;\n\n  // Only track these specific virtio config read helpers.\n\
  \  if (ExprHasName(OriginExpr, \"virtio_cread8\", C) ||\n      ExprHasName(OriginExpr,\
  \ \"virtio_cread16\", C) ||\n      ExprHasName(OriginExpr, \"virtio_cread32\", C))\n\
  \    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::isCopySizeCall(const\
  \ CallEvent &Call, unsigned &LenIndex, CheckerContext &C) const {\n  LenIndex =\
  \ 0;\n  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n   \
  \ return false;\n\n  // memcpy(void *dst, const void *src, size_t n)\n  if (ExprHasName(OriginExpr,\
  \ \"memcpy\", C)) {\n    LenIndex = 2;\n    return (Call.getNumArgs() > LenIndex);\n\
  \  }\n\n  // memmove(void *dst, const void *src, size_t n)\n  if (ExprHasName(OriginExpr,\
  \ \"memmove\", C)) {\n    LenIndex = 2;\n    return (Call.getNumArgs() > LenIndex);\n\
  \  }\n\n  // sg_init_one(struct scatterlist *sg, const void *buf, unsigned int buflen)\n\
  \  if (ExprHasName(OriginExpr, \"sg_init_one\", C)) {\n    LenIndex = 2;\n    return\
  \ (Call.getNumArgs() > LenIndex);\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::markLenRegionAsDeviceProvided(const\
  \ MemRegion *MR, CheckerContext &C) const {\n  if (!MR) return;\n  MR = MR->getBaseRegion();\n\
  \  if (!MR) return;\n\n  ProgramStateRef State = C.getState();\n  if (!State->contains<DeviceLenRegions>(MR))\
  \ {\n    State = State->add<DeviceLenRegions>(MR);\n    // If it was previously\
  \ validated spuriously, drop validation for conservativeness\n    if (State->contains<ValidatedRegions>(MR))\n\
  \      State = State->remove<ValidatedRegions>(MR);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::markLenSymbolAsDeviceProvided(SymbolRef Sym, CheckerContext\
  \ &C) const {\n  if (!Sym) return;\n  ProgramStateRef State = C.getState();\n  if\
  \ (!State->contains<DeviceLenSyms>(Sym)) {\n    State = State->add<DeviceLenSyms>(Sym);\n\
  \    if (State->contains<ValidatedSyms>(Sym))\n      State = State->remove<ValidatedSyms>(Sym);\n\
  \    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::markValidatedRegion(const\
  \ MemRegion *MR, CheckerContext &C) const {\n  if (!MR) return;\n  MR = MR->getBaseRegion();\n\
  \  if (!MR) return;\n  ProgramStateRef State = C.getState();\n  if (!State->contains<ValidatedRegions>(MR))\
  \ {\n    State = State->add<ValidatedRegions>(MR);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::markValidatedSymbol(SymbolRef Sym, CheckerContext\
  \ &C) const {\n  if (!Sym) return;\n  ProgramStateRef State = C.getState();\n  if\
  \ (!State->contains<ValidatedSyms>(Sym)) {\n    State = State->add<ValidatedSyms>(Sym);\n\
  \    C.addTransition(State);\n  }\n}\n\nbool SAGenTestChecker::isRegionDeviceLen(const\
  \ MemRegion *MR, ProgramStateRef State) const {\n  if (!MR) return false;\n  MR\
  \ = MR->getBaseRegion();\n  if (!MR) return false;\n  return State->contains<DeviceLenRegions>(MR);\n\
  }\n\nbool SAGenTestChecker::isSymbolDeviceLen(SymbolRef Sym, ProgramStateRef State)\
  \ const {\n  if (!Sym) return false;\n  return State->contains<DeviceLenSyms>(Sym);\n\
  }\n\nbool SAGenTestChecker::isRegionValidated(const MemRegion *MR, ProgramStateRef\
  \ State) const {\n  if (!MR) return false;\n  MR = MR->getBaseRegion();\n  if (!MR)\
  \ return false;\n  return State->contains<ValidatedRegions>(MR);\n}\n\nbool SAGenTestChecker::isSymbolValidated(SymbolRef\
  \ Sym, ProgramStateRef State) const {\n  if (!Sym) return false;\n  return State->contains<ValidatedSyms>(Sym);\n\
  }\n\n// When a virtio_cread* call is used in an assignment or initialization,\n\
  // try to identify and record the LHS region as a device-provided length.\nvoid\
  \ SAGenTestChecker::tryRecordAssignmentLHSForCallResult(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  const Expr *CallE = dyn_cast_or_null<Expr>(Call.getOriginExpr());\n\
  \  if (!CallE)\n    return;\n\n  // Case 1: Parent assignment 'LHS = virtio_cread*()'\n\
  \  if (const auto *BO = findSpecificTypeInParents<BinaryOperator>(CallE, C)) {\n\
  \    if (BO->isAssignmentOp()) {\n      const Expr *LHS = BO->getLHS();\n      if\
  \ (LHS) {\n        const MemRegion *MR = getMemRegionFromExpr(LHS, C);\n       \
  \ if (MR) {\n          MR = MR->getBaseRegion();\n          markLenRegionAsDeviceProvided(MR,\
  \ C);\n        }\n      }\n    }\n  }\n\n  // Case 2: Declaration with init 'u8\
  \ len = virtio_cread*()'\n  if (const auto *DS = findSpecificTypeInParents<DeclStmt>(CallE,\
  \ C)) {\n    for (const Decl *D : DS->decls()) {\n      if (const auto *VD = dyn_cast<VarDecl>(D))\
  \ {\n        if (const Expr *Init = VD->getInit()) {\n          // Ensure this var\
  \ is initialized from this exact call.\n          const CallExpr *InnerCall = findSpecificTypeInChildren<CallExpr>(Init);\n\
  \          if (!InnerCall || InnerCall != CallE)\n            continue;\n      \
  \    const MemRegion *MR = getMemRegionFromExpr(Init, C);\n          if (!MR) {\n\
  \            // If Init region retrieval fails, use the region of the Var itself.\n\
  \            const MemRegion *VarR =\n                C.getStoreManager().getRegionManager().getVarRegion(VD,\
  \ C.getLocationContext());\n            MR = VarR;\n          }\n          if (MR)\
  \ {\n            MR = MR->getBaseRegion();\n            markLenRegionAsDeviceProvided(MR,\
  \ C);\n          }\n        }\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isVirtioConfigRead(Call, C))\n\
  \    return;\n\n  // Mark the return symbol (if any) as device-provided length.\n\
  \  SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\n  if (RetSym)\n    markLenSymbolAsDeviceProvided(RetSym,\
  \ C);\n\n  // Try to find the LHS region into which the result is stored and mark\
  \ it.\n  tryRecordAssignmentLHSForCallResult(Call, C);\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n  const MemRegion *DestR = Loc.getAsRegion();\n  if (!DestR)\n\
  \    return;\n  DestR = DestR->getBaseRegion();\n  if (!DestR)\n    return;\n\n\
  \  const MemRegion *SrcR = Val.getAsRegion();\n  if (SrcR)\n    SrcR = SrcR->getBaseRegion();\n\
  \n  SymbolRef SrcSym = Val.getAsSymbol();\n\n  bool PropagateDevice = false;\n \
  \ bool PropagateValidated = false;\n\n  if (SrcR && isRegionDeviceLen(SrcR, State))\n\
  \    PropagateDevice = true;\n  if (SrcSym && isSymbolDeviceLen(SrcSym, State))\n\
  \    PropagateDevice = true;\n\n  if (SrcR && isRegionValidated(SrcR, State))\n\
  \    PropagateValidated = true;\n  if (SrcSym && isSymbolValidated(SrcSym, State))\n\
  \    PropagateValidated = true;\n\n  if (PropagateDevice) {\n    State = State->add<DeviceLenRegions>(DestR);\n\
  \    // Do not automatically clear validation state here; use separate logic.\n\
  \  }\n  if (PropagateValidated) {\n    State = State->add<ValidatedRegions>(DestR);\n\
  \  }\n\n  if (State != C.getState())\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!Condition)\n    return;\n\n\
  \  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n    return;\n\n\
  \  // Look for any comparison involving the macro VIRTIO_NET_RSS_MAX_KEY_SIZE\n\
  \  // and a device-provided length region/symbol.\n  const BinaryOperator *BO =\
  \ dyn_cast<BinaryOperator>(CondE->IgnoreParenCasts());\n  if (!BO)\n    BO = findSpecificTypeInChildren<BinaryOperator>(Condition);\n\
  \  if (!BO)\n    return;\n\n  BinaryOperator::Opcode Op = BO->getOpcode();\n  switch\
  \ (Op) {\n    case BO_GT: case BO_GE:\n    case BO_LT: case BO_LE:\n    case BO_EQ:\
  \ case BO_NE:\n      break;\n    default:\n      return;\n  }\n\n  const Expr *LHS\
  \ = BO->getLHS();\n  const Expr *RHS = BO->getRHS();\n  if (!LHS || !RHS)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n\n  // Helper lambda to attempt marking\
  \ validated if one side is device-len and the other mentions the macro.\n  auto\
  \ TryValidate = [&](const Expr *LenSide, const Expr *MacroSide) {\n    bool MacroMentioned\
  \ = ExprHasName(MacroSide, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\", C);\n    if (!MacroMentioned)\n\
  \      return false;\n\n    const MemRegion *MR = getMemRegionFromExpr(LenSide,\
  \ C);\n    if (MR)\n      MR = MR->getBaseRegion();\n    SymbolRef Sym = State->getSVal(LenSide,\
  \ C.getLocationContext()).getAsSymbol();\n\n    bool IsDev = (MR && isRegionDeviceLen(MR,\
  \ State)) || (Sym && isSymbolDeviceLen(Sym, State));\n    if (!IsDev)\n      return\
  \ false;\n\n    if (MR)\n      markValidatedRegion(MR, C);\n    if (Sym)\n     \
  \ markValidatedSymbol(Sym, C);\n    return true;\n  };\n\n  bool Changed = false;\n\
  \  Changed |= TryValidate(LHS, RHS);\n  Changed |= TryValidate(RHS, LHS);\n\n  if\
  \ (Changed)\n    return; // Transitions already added by markValidated*\n}\n\nvoid\
  \ SAGenTestChecker::reportUnvalidatedLenUse(const CallEvent &Call, const Expr *LenE,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Unvalidated device-provided length used as copy size (possible OOB).\"\
  , N);\n  if (LenE)\n    R->addRange(LenE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  unsigned LenIndex = 0;\n  if (!isCopySizeCall(Call, LenIndex, C))\n\
  \    return;\n\n  if (Call.getNumArgs() <= LenIndex)\n    return;\n\n  const Expr\
  \ *LenE = Call.getArgExpr(LenIndex);\n  if (!LenE)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n\n  const MemRegion *LenR = getMemRegionFromExpr(LenE,\
  \ C);\n  if (LenR)\n    LenR = LenR->getBaseRegion();\n  SymbolRef LenSym = State->getSVal(LenE,\
  \ C.getLocationContext()).getAsSymbol();\n\n  bool IsDevLen = (LenR && isRegionDeviceLen(LenR,\
  \ State)) ||\n                  (LenSym && isSymbolDeviceLen(LenSym, State));\n\n\
  \  if (!IsDevLen)\n    return;\n\n  bool IsValidated = (LenR && isRegionValidated(LenR,\
  \ State)) ||\n                     (LenSym && isSymbolValidated(LenSym, State));\n\
  \n  if (!IsValidated) {\n    reportUnvalidatedLenUse(Call, LenE, C);\n  }\n}\n\n\
  } // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects using device-provided length without validating against VIRTIO_NET_RSS_MAX_KEY_SIZE\
  \ in size-sensitive calls\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
