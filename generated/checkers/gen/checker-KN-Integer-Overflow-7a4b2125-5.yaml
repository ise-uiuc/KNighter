_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 7a4b21250bf79eef26543d35bd390448646c536b
commit_type: Integer-Overflow
index: 5
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Track variables that currently hold the result of roundup_pow_of_two(...)\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion *, bool)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public\
  \ Checker<\n        check::PostStmt<DeclStmt>,\n        check::Bind,\n        check::BranchCondition>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\n\
  \        : BT(new BugType(this,\n                         \"Unreliable overflow\
  \ check with roundup_pow_of_two\",\n                         \"API Misuse\")) {}\n\
  \n      void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;\n     \
  \ void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \      void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \n   private:\n      // Helpers\n      static bool isRoundupPowOfTwoExpr(const Expr\
  \ *E, CheckerContext &C);\n      static bool isZeroIntExpr(const Expr *E, CheckerContext\
  \ &C);\n      static bool is32BitUnsignedLong(ASTContext &ACtx);\n      static const\
  \ MemRegion *getVarRegion(const Expr *E, CheckerContext &C);\n\n      void markRegionAsRoundup(ProgramStateRef\
  \ &State, const MemRegion *MR) const;\n      void unmarkRegion(ProgramStateRef &State,\
  \ const MemRegion *MR) const;\n      void reportUnreliableZeroCheck(const Stmt *Condition,\
  \ CheckerContext &C) const;\n};\n\n// ---- Helper implementations ----\n\nbool SAGenTestChecker::isRoundupPowOfTwoExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return false;\n  // Check by source name\
  \ occurrence for robustness (works with macros/inlines).\n  return ExprHasName(E,\
  \ \"roundup_pow_of_two\", C);\n}\n\nbool SAGenTestChecker::isZeroIntExpr(const Expr\
  \ *E, CheckerContext &C) {\n  if (!E) return false;\n  llvm::APSInt Res;\n  if (EvaluateExprToInt(Res,\
  \ E, C)) {\n    return Res == 0;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::is32BitUnsignedLong(ASTContext\
  \ &ACtx) {\n  return ACtx.getTypeSize(ACtx.UnsignedLongTy) == 32;\n}\n\nconst MemRegion\
  \ *SAGenTestChecker::getVarRegion(const Expr *E, CheckerContext &C) {\n  if (!E)\
  \ return nullptr;\n  // Do not IgnoreImplicit() before getMemRegionFromExpr per\
  \ guidance.\n  const MemRegion *MR = getMemRegionFromExpr(E, C);\n  if (!MR) return\
  \ nullptr;\n  MR = MR->getBaseRegion();\n  return MR;\n}\n\nvoid SAGenTestChecker::markRegionAsRoundup(ProgramStateRef\
  \ &State, const MemRegion *MR) const {\n  if (!MR) return;\n  State = State->set<RoundupResMap>(MR,\
  \ true);\n}\n\nvoid SAGenTestChecker::unmarkRegion(ProgramStateRef &State, const\
  \ MemRegion *MR) const {\n  if (!MR) return;\n  State = State->remove<RoundupResMap>(MR);\n\
  }\n\nvoid SAGenTestChecker::reportUnreliableZeroCheck(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n      \"Unreliable\
  \ overflow check: testing result of roundup_pow_of_two() against 0 on 32-bit\",\n\
  \      N);\n  R->addRange(Condition->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// ---- Checker callbacks ----\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  for (const Decl *D : DS->decls()) {\n    const auto *VD = dyn_cast<VarDecl>(D);\n\
  \    if (!VD) continue;\n\n    const Expr *Init = VD->getInit();\n    // Get the\
  \ region of the declared variable\n    SValBuilder &SVB = C.getSValBuilder();\n\
  \    SVal LVal = SVB.getLValue(VD, C.getLocationContext());\n    const MemRegion\
  \ *MR = LVal.getAsRegion();\n    if (MR) MR = MR->getBaseRegion();\n\n    if (!MR)\n\
  \      continue;\n\n    if (!Init) {\n      // No initializer: variable does not\
  \ hold roundup result at this point.\n      unmarkRegion(State, MR);\n      continue;\n\
  \    }\n\n    bool Mark = false;\n    // Direct use of roundup_pow_of_two in initializer\n\
  \    if (isRoundupPowOfTwoExpr(Init, C)) {\n      Mark = true;\n    } else {\n \
  \     // Propagate from another variable that already marked\n      if (const MemRegion\
  \ *RHSReg = getVarRegion(Init, C)) {\n        if (State->get<RoundupResMap>(RHSReg))\n\
  \          Mark = true;\n      }\n    }\n\n    if (Mark)\n      markRegionAsRoundup(State,\
  \ MR);\n    else\n      unmarkRegion(State, MR);\n  }\n\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *LHSReg\
  \ = Loc.getAsRegion();\n  if (LHSReg) LHSReg = LHSReg->getBaseRegion();\n  if (!LHSReg)\
  \ {\n    // Nothing to do without a region\n    return;\n  }\n\n  // We only care\
  \ about explicit assignments here.\n  const BinaryOperator *BO = dyn_cast_or_null<BinaryOperator>(S);\n\
  \  if (!BO) {\n    BO = findSpecificTypeInParents<BinaryOperator>(S, C);\n  }\n\
  \  if (!BO || !BO->isAssignmentOp() || BO->getOpcode() != BO_Assign) {\n    // Not\
  \ a simple assignment; conservatively unmark if value is not a direct propagate\n\
  \    // but to avoid noise, just return.\n    return;\n  }\n\n  const Expr *RHS\
  \ = BO->getRHS();\n  bool Mark = false;\n\n  if (isRoundupPowOfTwoExpr(RHS, C))\
  \ {\n    Mark = true;\n  } else {\n    // Propagate marker if RHS is a variable\
  \ already marked\n    if (const MemRegion *RHSReg = getVarRegion(RHS, C)) {\n  \
  \    if (State->get<RoundupResMap>(RHSReg))\n        Mark = true;\n    }\n  }\n\n\
  \  if (Mark)\n    markRegionAsRoundup(State, LHSReg);\n  else\n    unmarkRegion(State,\
  \ LHSReg);\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  if (!Condition) return;\n\n  //\
  \ Only warn on targets where unsigned long is 32-bit,\n  // which is where roundup_pow_of_two\
  \ can hit UB via 1UL << 32.\n  if (!is32BitUnsignedLong(C.getASTContext()))\n  \
  \  return;\n\n  ProgramStateRef State = C.getState();\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n\
  \  if (!CondE)\n    return;\n\n  // A) if (!X)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE->IgnoreParens()))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *InnerRaw = UO->getSubExpr();\
  \ // do not strip casts before region query\n      // Case A1: variable or lvalue\
  \ expr that refers to a region we track\n      if (const MemRegion *MR = getVarRegion(InnerRaw,\
  \ C)) {\n        if (MR->getBaseRegion() && State->get<RoundupResMap>(MR->getBaseRegion()))\
  \ {\n          reportUnreliableZeroCheck(Condition, C);\n          return;\n   \
  \     }\n      }\n      // Case A2: direct call to roundup_pow_of_two(...)\n   \
  \   if (const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(InnerRaw)) {\n\
  \        if (ExprHasName(CE, \"roundup_pow_of_two\", C)) {\n          reportUnreliableZeroCheck(Condition,\
  \ C);\n          return;\n        }\n      }\n    }\n  }\n\n  // B) if (X == 0)\
  \ or if (0 == X)\n  if (const auto *BO = dyn_cast<BinaryOperator>(CondE->IgnoreParens()))\
  \ {\n    if (BO->getOpcode() == BO_EQ) {\n      const Expr *L = BO->getLHS();\n\
  \      const Expr *R = BO->getRHS();\n\n      if (isZeroIntExpr(L, C)) {\n     \
  \   // Check RHS either variable marked or direct call\n        if (const MemRegion\
  \ *MR = getVarRegion(R, C)) {\n          if (MR->getBaseRegion() && State->get<RoundupResMap>(MR->getBaseRegion()))\
  \ {\n            reportUnreliableZeroCheck(Condition, C);\n            return;\n\
  \          }\n        }\n        if (const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(R))\
  \ {\n          if (ExprHasName(CE, \"roundup_pow_of_two\", C)) {\n            reportUnreliableZeroCheck(Condition,\
  \ C);\n            return;\n          }\n        }\n      } else if (isZeroIntExpr(R,\
  \ C)) {\n        // Mirror for LHS\n        if (const MemRegion *MR = getVarRegion(L,\
  \ C)) {\n          if (MR->getBaseRegion() && State->get<RoundupResMap>(MR->getBaseRegion()))\
  \ {\n            reportUnreliableZeroCheck(Condition, C);\n            return;\n\
  \          }\n        }\n        if (const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(L))\
  \ {\n          if (ExprHasName(CE, \"roundup_pow_of_two\", C)) {\n            reportUnreliableZeroCheck(Condition,\
  \ C);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  //\
  \ No changes to state necessary if nothing detected.\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects unreliable zero-checks on results\
  \ of roundup_pow_of_two() on 32-bit targets\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbpf: Fix stackmap overflow check on 32-bit arches\n\
  \nThe stackmap code relies on roundup_pow_of_two() to compute the number\nof hash\
  \ buckets, and contains an overflow check by checking if the\nresulting value is\
  \ 0. However, on 32-bit arches, the roundup code itself\ncan overflow by doing a\
  \ 32-bit left-shift of an unsigned long value,\nwhich is undefined behaviour, so\
  \ it is not guaranteed to truncate\nneatly. This was triggered by syzbot on the\
  \ DEVMAP_HASH type, which\ncontains the same check, copied from the hashtab code.\n\
  \nThe commit in the fixes tag actually attempted to fix this, but the fix\ndid not\
  \ account for the UB, so the fix only works on CPUs where an\noverflow does result\
  \ in a neat truncation to zero, which is not\nguaranteed. Checking the value before\
  \ rounding does not have this\nproblem.\n\nFixes: 6183f4d3a0a2 (\"bpf: Check for\
  \ integer overflow when using roundup_pow_of_two()\")\nSigned-off-by: Toke H\xF8\
  iland-J\xF8rgensen <toke@redhat.com>\nReviewed-by: Bui Quang Minh <minhquangbui99@gmail.com>\n\
  Message-ID: <20240307120340.99577-4-toke@redhat.com>\nSigned-off-by: Alexei Starovoitov\
  \ <ast@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: stack_map_alloc in kernel/bpf/stackmap.c\n\
  static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n{\n\tu32 value_size\
  \ = attr->value_size;\n\tstruct bpf_stack_map *smap;\n\tu64 cost, n_buckets;\n\t\
  int err;\n\n\tif (attr->map_flags & ~STACK_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size\
  \ != 4 ||\n\t    value_size < 8 || value_size % 8)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\tBUILD_BUG_ON(sizeof(struct bpf_stack_build_id) % sizeof(u64));\n\tif (attr->map_flags\
  \ & BPF_F_STACK_BUILD_ID) {\n\t\tif (value_size % sizeof(struct bpf_stack_build_id)\
  \ ||\n\t\t    value_size / sizeof(struct bpf_stack_build_id)\n\t\t    > sysctl_perf_event_max_stack)\n\
  \t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n\
  \t\treturn ERR_PTR(-EINVAL);\n\n\t/* hash table size must be power of 2 */\n\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n\tif (!n_buckets)\n\t\treturn ERR_PTR(-E2BIG);\n\
  \n\tcost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);\n\tsmap\
  \ = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\tif (!smap)\n\t\t\
  return ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&smap->map, attr);\n\tsmap->n_buckets\
  \ = n_buckets;\n\n\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\t\
  if (err)\n\t\tgoto free_smap;\n\n\terr = prealloc_elems_and_freelist(smap);\n\t\
  if (err)\n\t\tgoto put_buffers;\n\n\treturn &smap->map;\n\nput_buffers:\n\tput_callchain_buffers();\n\
  free_smap:\n\tbpf_map_area_free(smap);\n\treturn ERR_PTR(err);\n}\n```\n\n## Bug\
  \ Fix Patch\n\n```diff\ndiff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c\n\
  index dff7ba539701..c99f8e5234ac 100644\n--- a/kernel/bpf/stackmap.c\n+++ b/kernel/bpf/stackmap.c\n\
  @@ -91,11 +91,14 @@ static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n\
  \ \t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n \t\treturn ERR_PTR(-EINVAL);\n\
  \ \n-\t/* hash table size must be power of 2 */\n-\tn_buckets = roundup_pow_of_two(attr->max_entries);\n\
  -\tif (!n_buckets)\n+\t/* hash table size must be power of 2; roundup_pow_of_two()\
  \ can overflow\n+\t * into UB on 32-bit arches, so check that first\n+\t */\n+\t\
  if (attr->max_entries > 1UL << 31)\n \t\treturn ERR_PTR(-E2BIG);\n \n+\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n+\n \tcost = n_buckets * sizeof(struct\
  \ stack_map_bucket *) + sizeof(*smap);\n \tsmap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\
  \ \tif (!smap)\n```\n"
pattern: '## Bug Pattern


  Using roundup_pow_of_two(x) on a potentially large 32-bit unsigned long without
  first bounding x, and then relying on (result == 0) to detect overflow. On 32-bit
  arches, the internal left shift (e.g., 1UL << 32) in roundup_pow_of_two() invokes
  undefined behavior, so overflow may not produce zero, making the post-call zero
  check unreliable.'
plan: "1) Program state\n- REGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap, const MemRegion\
  \ *, bool)\n  - Key: the region of a variable that currently holds the result of\
  \ roundup_pow_of_two(...).\n  - Value: a dummy bool (always true). Presence in the\
  \ map indicates \u201Cthis var is the result of roundup_pow_of_two()\u201D.\n- No\
  \ other traits/maps are necessary.\n\n2) Helper utilities\n- bool isRoundupPowOfTwoExpr(const\
  \ Expr *E, CheckerContext &C)\n  - Return ExprHasName(E, \"roundup_pow_of_two\"\
  , C).\n- bool isZeroIntExpr(const Expr *E, CheckerContext &C)\n  - Use EvaluateExprToInt;\
  \ return true if constant and equal to 0.\n- bool is32BitUnsignedLong(ASTContext\
  \ &ACtx)\n  - return ACtx.getTypeSize(ACtx.UnsignedLongTy) == 32;\n- const MemRegion\
  \ *getVarRegion(const Expr *E, CheckerContext &C)\n  - Return getMemRegionFromExpr(E,\
  \ C) (works for DeclRefExpr, MemberExpr to lvalues, etc.).\n\n3) Hook variable initializations\
  \ (checkPostStmt(const DeclStmt *DS))\n- Goal: mark a variable as holding the result\
  \ of roundup_pow_of_two when initialized from it.\n- For each VarDecl in DS:\n \
  \ - If it has an initializer Init:\n    - If isRoundupPowOfTwoExpr(Init, C):\n \
  \     - Region = getMemRegionFromExpr(DRE to the VarDecl; use State->getLValue or\
  \ simply getMemRegionFromExpr on the DeclRef of the VarDecl if available; alternatively\
  \ use getMemRegionFromExpr on the initialized VarDecl via C.getSVal).\n      - If\
  \ Region != nullptr: add it to RoundupResMap with true.\n    - Else:\n      - If\
  \ Region already in RoundupResMap, remove it (the variable no longer stores the\
  \ result).\n\n4) Track assignments (checkBind(SVal Loc, SVal Val, const Stmt *S))\n\
  - Goal: update RoundupResMap when a variable is assigned from roundup_pow_of_two.\n\
  - Obtain the target region: const MemRegion *R = Loc.getAsRegion(); if !R return.\n\
  - Find the assignment node and RHS:\n  - Try: if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S))\
  \ and BO->getOpcode() == BO_Assign:\n    - const Expr *RHS = BO->getRHS();\n  -\
  \ Else: fallback to findSpecificTypeInParents<BinaryOperator>(S, C) and check if\
  \ assign; set RHS accordingly. If not found, return (not an assignment bind we care\
  \ about).\n- If RHS and isRoundupPowOfTwoExpr(RHS, C): add R->true to RoundupResMap.\n\
  - Else: remove R from RoundupResMap (the variable has been overwritten with a non-roundup\
  \ value).\n\n5) Detect the unreliable zero-check in if/condition (checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C))\n- If not is32BitUnsignedLong(C.getASTContext()),\
  \ return (only warn on 32-bit unsigned long targets).\n- Analyze typical forms:\n\
  \  A) Logical negation: if (const auto *UO = dyn_cast<UnaryOperator>(Condition))\n\
  \     - If UO->getOpcode() == UO_LNot:\n       - const Expr *Inner = UO->getSubExpr()->IgnoreParenImpCasts();\n\
  \       - Case A1: Inner is a variable-like expr:\n         - const MemRegion *R\
  \ = getVarRegion(Inner, C); if R and RoundupResMap contains R -> report bug.\n \
  \      - Case A2: Inner contains a direct call:\n         - If findSpecificTypeInChildren<CallExpr>(Inner)\
  \ returns CE and ExprHasName(CE->getCallee(), \"roundup_pow_of_two\", C) -> report\
  \ bug.\n  B) Equality to zero: if (const auto *BO = dyn_cast<BinaryOperator>(Condition))\n\
  \     - If BO->getOpcode() == BO_EQ:\n       - const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \       - const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n       - If isZeroIntExpr(L,\
  \ C):\n         - Check right side:\n           - Case B1: variable side: MemRegion\
  \ *MR = getVarRegion(R, C); if MR in RoundupResMap -> report bug.\n           -\
  \ Case B2: call side: if findSpecificTypeInChildren<CallExpr>(R) is CE and ExprHasName(CE->getCallee(),\
  \ \"roundup_pow_of_two\", C) -> report bug.\n       - Else if isZeroIntExpr(R, C):\
  \ mirror above for LHS.\n- Notes:\n  - This covers both patterns:\n    - v = roundup_pow_of_two(x);\
  \ if (!v) ...\n    - if (!roundup_pow_of_two(x)) ...\n  - We do not require adjacency;\
  \ as long as the variable still maps to a roundup result at the branch, we warn.\n\
  - Reporting:\n  - Create a non-fatal error node and emit a PathSensitiveBugReport.\n\
  \  - Message: \"Unreliable overflow check: testing result of roundup_pow_of_two()\
  \ against 0 on 32-bit. Pre-check the input bound before calling.\"\n  - Location:\
  \ the condition expression node.\n\n6) Optional robustness and pruning\n- When the\
  \ analyzer sees an assignment of a variable previously in RoundupResMap to any non-call\
  \ expression, remove it from the map (already covered in checkBind).\n- We do not\
  \ attempt to prove/disprove presence of a prior proper bound check on the input;\
  \ keep the checker simple and pattern-based as requested.\n\n7) Chosen callbacks\
  \ summary\n- checkPostStmt(DeclStmt): mark variables initialized from roundup_pow_of_two;\
  \ unmark when initialized from something else.\n- checkBind: track assignments that\
  \ set/unset the roundup_pow_of_two marker.\n- checkBranchCondition: detect zero\
  \ checks of either the variable marked as roundup result or a direct call expression;\
  \ warn only if unsigned long is 32-bit.\n\n8) Utility functions used\n- ExprHasName\
  \ to detect \"roundup_pow_of_two\" in expressions reliably (macro or inline).\n\
  - findSpecificTypeInChildren to find CallExprs under conditions.\n- EvaluateExprToInt\
  \ to detect integer zero in comparisons.\n- getMemRegionFromExpr to map condition\
  \ variable expressions to their memory region keys.\n\n9) Bug report text\n- Title/message:\
  \ \"Unreliable overflow check: testing result of roundup_pow_of_two() against 0\
  \ on 32-bit.\"\n- Short explanation in description: \"roundup_pow_of_two() may overflow\
  \ with undefined behavior; check the input bound before calling instead of testing\
  \ the result for zero.\""
refined_plan: null
repaired_checker_code: "#include <memory>\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Track variables that currently hold the result of roundup_pow_of_two(...)\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion *, bool)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public\
  \ Checker<\n        check::PostStmt<DeclStmt>,\n        check::Bind,\n        check::BranchCondition>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\n\
  \        : BT(new BugType(this,\n                         \"Unreliable overflow\
  \ check with roundup_pow_of_two\",\n                         \"API Misuse\")) {}\n\
  \n      void checkPostStmt(const DeclStmt *DS, CheckerContext &C) const;\n     \
  \ void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \      void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \n   private:\n      // Helpers\n      static bool isRoundupPowOfTwoExpr(const Expr\
  \ *E, CheckerContext &C);\n      static bool isZeroIntExpr(const Expr *E, CheckerContext\
  \ &C);\n      static bool is32BitUnsignedLong(ASTContext &ACtx);\n      static const\
  \ MemRegion *getVarRegion(const Expr *E, CheckerContext &C);\n\n      void markRegionAsRoundup(ProgramStateRef\
  \ &State, const MemRegion *MR) const;\n      void unmarkRegion(ProgramStateRef &State,\
  \ const MemRegion *MR) const;\n      void reportUnreliableZeroCheck(const Stmt *Condition,\
  \ CheckerContext &C) const;\n};\n\n// ---- Helper implementations ----\n\nbool SAGenTestChecker::isRoundupPowOfTwoExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return false;\n  // Check by source name\
  \ occurrence for robustness (works with macros/inlines).\n  return ExprHasName(E,\
  \ \"roundup_pow_of_two\", C);\n}\n\nbool SAGenTestChecker::isZeroIntExpr(const Expr\
  \ *E, CheckerContext &C) {\n  if (!E) return false;\n  llvm::APSInt Res;\n  if (EvaluateExprToInt(Res,\
  \ E, C)) {\n    return Res == 0;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::is32BitUnsignedLong(ASTContext\
  \ &ACtx) {\n  return ACtx.getTypeSize(ACtx.UnsignedLongTy) == 32;\n}\n\nconst MemRegion\
  \ *SAGenTestChecker::getVarRegion(const Expr *E, CheckerContext &C) {\n  if (!E)\
  \ return nullptr;\n  // Do not IgnoreImplicit() before getMemRegionFromExpr per\
  \ guidance.\n  const MemRegion *MR = getMemRegionFromExpr(E, C);\n  if (!MR) return\
  \ nullptr;\n  MR = MR->getBaseRegion();\n  return MR;\n}\n\nvoid SAGenTestChecker::markRegionAsRoundup(ProgramStateRef\
  \ &State, const MemRegion *MR) const {\n  if (!MR) return;\n  State = State->set<RoundupResMap>(MR,\
  \ true);\n}\n\nvoid SAGenTestChecker::unmarkRegion(ProgramStateRef &State, const\
  \ MemRegion *MR) const {\n  if (!MR) return;\n  State = State->remove<RoundupResMap>(MR);\n\
  }\n\nvoid SAGenTestChecker::reportUnreliableZeroCheck(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\n      \"Unreliable\
  \ overflow check: testing result of roundup_pow_of_two() against 0 on 32-bit\",\n\
  \      N);\n  R->addRange(Condition->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// ---- Checker callbacks ----\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  for (const Decl *D : DS->decls()) {\n    const auto *VD = dyn_cast<VarDecl>(D);\n\
  \    if (!VD) continue;\n\n    const Expr *Init = VD->getInit();\n    // Get the\
  \ region of the declared variable\n    MemRegionManager &MRMgr = C.getSValBuilder().getRegionManager();\n\
  \    const MemRegion *MR = MRMgr.getVarRegion(VD, C.getLocationContext());\n   \
  \ if (MR) MR = MR->getBaseRegion();\n\n    if (!MR)\n      continue;\n\n    if (!Init)\
  \ {\n      // No initializer: variable does not hold roundup result at this point.\n\
  \      unmarkRegion(State, MR);\n      continue;\n    }\n\n    bool Mark = false;\n\
  \    // Direct use of roundup_pow_of_two in initializer\n    if (isRoundupPowOfTwoExpr(Init,\
  \ C)) {\n      Mark = true;\n    } else {\n      // Propagate from another variable\
  \ that already marked\n      if (const MemRegion *RHSReg = getVarRegion(Init, C))\
  \ {\n        if (State->get<RoundupResMap>(RHSReg))\n          Mark = true;\n  \
  \    }\n    }\n\n    if (Mark)\n      markRegionAsRoundup(State, MR);\n    else\n\
  \      unmarkRegion(State, MR);\n  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (LHSReg)\
  \ LHSReg = LHSReg->getBaseRegion();\n  if (!LHSReg) {\n    // Nothing to do without\
  \ a region\n    return;\n  }\n\n  // We only care about explicit assignments here.\n\
  \  const BinaryOperator *BO = dyn_cast_or_null<BinaryOperator>(S);\n  if (!BO) {\n\
  \    BO = findSpecificTypeInParents<BinaryOperator>(S, C);\n  }\n  if (!BO || !BO->isAssignmentOp()\
  \ || BO->getOpcode() != BO_Assign) {\n    // Not a simple assignment; conservatively\
  \ unmark if value is not a direct propagate\n    // but to avoid noise, just return.\n\
  \    return;\n  }\n\n  const Expr *RHS = BO->getRHS();\n  bool Mark = false;\n\n\
  \  if (isRoundupPowOfTwoExpr(RHS, C)) {\n    Mark = true;\n  } else {\n    // Propagate\
  \ marker if RHS is a variable already marked\n    if (const MemRegion *RHSReg =\
  \ getVarRegion(RHS, C)) {\n      if (State->get<RoundupResMap>(RHSReg))\n      \
  \  Mark = true;\n    }\n  }\n\n  if (Mark)\n    markRegionAsRoundup(State, LHSReg);\n\
  \  else\n    unmarkRegion(State, LHSReg);\n\n  C.addTransition(State);\n}\n\nvoid\
  \ SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext &C)\
  \ const {\n  if (!Condition) return;\n\n  // Only warn on targets where unsigned\
  \ long is 32-bit,\n  // which is where roundup_pow_of_two can hit UB via 1UL <<\
  \ 32.\n  if (!is32BitUnsignedLong(C.getASTContext()))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if\
  \ (!CondE)\n    return;\n\n  // A) if (!X)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE->IgnoreParens()))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *InnerRaw = UO->getSubExpr();\
  \ // do not strip casts before region query\n      // Case A1: variable or lvalue\
  \ expr that refers to a region we track\n      if (const MemRegion *MR = getVarRegion(InnerRaw,\
  \ C)) {\n        if (MR->getBaseRegion() && State->get<RoundupResMap>(MR->getBaseRegion()))\
  \ {\n          reportUnreliableZeroCheck(Condition, C);\n          return;\n   \
  \     }\n      }\n      // Case A2: direct call to roundup_pow_of_two(...)\n   \
  \   if (const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(InnerRaw)) {\n\
  \        if (ExprHasName(CE, \"roundup_pow_of_two\", C)) {\n          reportUnreliableZeroCheck(Condition,\
  \ C);\n          return;\n        }\n      }\n    }\n  }\n\n  // B) if (X == 0)\
  \ or if (0 == X)\n  if (const auto *BO = dyn_cast<BinaryOperator>(CondE->IgnoreParens()))\
  \ {\n    if (BO->getOpcode() == BO_EQ) {\n      const Expr *L = BO->getLHS();\n\
  \      const Expr *R = BO->getRHS();\n\n      if (isZeroIntExpr(L, C)) {\n     \
  \   // Check RHS either variable marked or direct call\n        if (const MemRegion\
  \ *MR = getVarRegion(R, C)) {\n          if (MR->getBaseRegion() && State->get<RoundupResMap>(MR->getBaseRegion()))\
  \ {\n            reportUnreliableZeroCheck(Condition, C);\n            return;\n\
  \          }\n        }\n        if (const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(R))\
  \ {\n          if (ExprHasName(CE, \"roundup_pow_of_two\", C)) {\n            reportUnreliableZeroCheck(Condition,\
  \ C);\n            return;\n          }\n        }\n      } else if (isZeroIntExpr(R,\
  \ C)) {\n        // Mirror for LHS\n        if (const MemRegion *MR = getVarRegion(L,\
  \ C)) {\n          if (MR->getBaseRegion() && State->get<RoundupResMap>(MR->getBaseRegion()))\
  \ {\n            reportUnreliableZeroCheck(Condition, C);\n            return;\n\
  \          }\n        }\n        if (const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(L))\
  \ {\n          if (ExprHasName(CE, \"roundup_pow_of_two\", C)) {\n            reportUnreliableZeroCheck(Condition,\
  \ C);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  //\
  \ No changes to state necessary if nothing detected.\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects unreliable zero-checks on results\
  \ of roundup_pow_of_two() on 32-bit targets\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
