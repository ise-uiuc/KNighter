_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 63ae548f1054a0b71678d0349c7dc9628ddd42ca
commit_type: Out-of-Bound
index: 6
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\
  \n#include <string>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\nnamespace {\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\
  \ : public Checker<check::PostStmt<ArraySubscriptExpr>> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"LUT index\
  \ may exceed bound\", \"Array bounds\")) {}\n\n      void checkPostStmt(const ArraySubscriptExpr\
  \ *ASE, CheckerContext &C) const;\n\n   private:\n\n      // Check if base expression\
  \ of array subscript matches (...)->tf_pts.{red|green|blue}\n      static bool matchTfPtsColorChain(const\
  \ Expr *BaseE,\n                                       std::string &ColorName,\n\
  \                                       const FieldDecl *&ColorFD,\n           \
  \                            const ConstantArrayType *&ArrTy);\n\n      // Collect\
  \ VarDecls referenced in an expression.\n      static void collectReferencedVars(const\
  \ Expr *E,\n                                        llvm::SmallPtrSet<const VarDecl\
  \ *, 4> &Vars);\n\n      // Check if an expression references any of the given variables.\n\
  \      static bool exprReferencesAnyVar(const Expr *E,\n                       \
  \                const llvm::SmallPtrSet<const VarDecl *, 4> &Vars);\n\n      //\
  \ Check whether the given condition provides a guard ensuring idx < ArrSize (or\
  \ <= ArrSize-1).\n      static bool conditionGuardsIndex(const Expr *CondE,\n  \
  \                                     const llvm::SmallPtrSet<const VarDecl *, 4>\
  \ &IndexVars,\n                                       uint64_t ArrSize,\n      \
  \                                 CheckerContext &C);\n\n      // Try to find an\
  \ enclosing condition that guards the index.\n      static bool hasGuardingAncestorCondition(const\
  \ Stmt *Site,\n                                               const llvm::SmallPtrSet<const\
  \ VarDecl *, 4> &IndexVars,\n                                               uint64_t\
  \ ArrSize,\n                                               CheckerContext &C);\n\
  \n      void reportOOB(const ArraySubscriptExpr *ASE, StringRef Color, CheckerContext\
  \ &C) const;\n};\n\nbool SAGenTestChecker::matchTfPtsColorChain(const Expr *BaseE,\n\
  \                                            std::string &ColorName,\n         \
  \                                   const FieldDecl *&ColorFD,\n               \
  \                             const ConstantArrayType *&ArrTy) {\n  if (!BaseE)\n\
  \    return false;\n\n  const Expr *E = BaseE->IgnoreParenImpCasts();\n\n  const\
  \ auto *MEColor = dyn_cast<MemberExpr>(E);\n  if (!MEColor)\n    return false;\n\
  \n  const auto *FDColor = dyn_cast<FieldDecl>(MEColor->getMemberDecl());\n  if (!FDColor)\n\
  \    return false;\n\n  StringRef Name = FDColor->getName();\n  if (!(Name == \"\
  red\" || Name == \"green\" || Name == \"blue\"))\n    return false;\n\n  const Expr\
  \ *TfBase = MEColor->getBase();\n  if (!TfBase)\n    return false;\n\n  TfBase =\
  \ TfBase->IgnoreParenImpCasts();\n  const auto *METf = dyn_cast<MemberExpr>(TfBase);\n\
  \  if (!METf)\n    return false;\n\n  const auto *FDTf = dyn_cast<FieldDecl>(METf->getMemberDecl());\n\
  \  if (!FDTf)\n    return false;\n\n  if (FDTf->getName() != \"tf_pts\")\n    return\
  \ false;\n\n  // Extract the array type of color field: should be a ConstantArrayType\n\
  \  QualType FT = FDColor->getType();\n  const Type *Ty = FT.getTypePtrOrNull();\n\
  \  if (!Ty)\n    return false;\n\n  const auto *CAT = dyn_cast<ConstantArrayType>(Ty);\n\
  \  if (!CAT)\n    return false;\n\n  ColorName = Name.str();\n  ColorFD = FDColor;\n\
  \  ArrTy = CAT;\n  return true;\n}\n\nvoid SAGenTestChecker::collectReferencedVars(const\
  \ Expr *E,\n                                             llvm::SmallPtrSet<const\
  \ VarDecl *, 4> &Vars) {\n  if (!E)\n    return;\n\n  E = E->IgnoreParenImpCasts();\n\
  \n  if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {\n    if (const auto *VD =\
  \ dyn_cast<VarDecl>(DRE->getDecl()))\n      Vars.insert(VD);\n    return;\n  }\n\
  \n  // Recurse into children\n  for (const Stmt *Child : E->children()) {\n    if\
  \ (const auto *CE = dyn_cast_or_null<Expr>(Child))\n      collectReferencedVars(CE,\
  \ Vars);\n  }\n}\n\nbool SAGenTestChecker::exprReferencesAnyVar(const Expr *E,\n\
  \                                            const llvm::SmallPtrSet<const VarDecl\
  \ *, 4> &Vars) {\n  if (!E)\n    return false;\n\n  E = E->IgnoreParenImpCasts();\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n\
  \      return Vars.count(VD);\n    return false;\n  }\n\n  for (const Stmt *Child\
  \ : E->children()) {\n    if (const auto *CE = dyn_cast_or_null<Expr>(Child)) {\n\
  \      if (exprReferencesAnyVar(CE, Vars))\n        return true;\n    }\n  }\n \
  \ return false;\n}\n\nstatic bool evalToUInt64(const Expr *E, CheckerContext &C,\
  \ uint64_t &Out) {\n  if (!E)\n    return false;\n  llvm::APSInt Res;\n  if (!EvaluateExprToInt(Res,\
  \ E, C))\n    return false;\n  if (Res.isSigned()) {\n    if (Res.isNegative())\n\
  \      return false;\n    Out = static_cast<uint64_t>(Res.getSExtValue());\n  }\
  \ else {\n    Out = Res.getZExtValue();\n  }\n  return true;\n}\n\nbool SAGenTestChecker::conditionGuardsIndex(const\
  \ Expr *CondE,\n                                            const llvm::SmallPtrSet<const\
  \ VarDecl *, 4> &IndexVars,\n                                            uint64_t\
  \ ArrSize,\n                                            CheckerContext &C) {\n \
  \ if (!CondE)\n    return false;\n\n  const Expr *E = CondE->IgnoreParenCasts();\n\
  \n  // Direct binary operator\n  if (const auto *BO = dyn_cast<BinaryOperator>(E))\
  \ {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n    const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \    const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n    // Case 1: var <\
  \ N or var <= N\n    if (exprReferencesAnyVar(LHS, IndexVars)) {\n      uint64_t\
  \ N;\n      if (evalToUInt64(RHS, C, N)) {\n        if (Op == BO_LT && N == ArrSize)\n\
  \          return true;\n        if (Op == BO_LE && N == (ArrSize - (ArrSize ? 1\
  \ : 0)))\n          return ArrSize > 0;\n      }\n    }\n\n    // Case 2: N > var\
  \ or N >= var\n    if (exprReferencesAnyVar(RHS, IndexVars)) {\n      uint64_t N;\n\
  \      if (evalToUInt64(LHS, C, N)) {\n        if (Op == BO_GT && N == ArrSize)\n\
  \          return true;\n        if (Op == BO_GE && N == (ArrSize - (ArrSize ? 1\
  \ : 0)))\n          return ArrSize > 0;\n      }\n    }\n\n    // Recurse deeper\
  \ for compound conditions: (A && B) etc.\n    if (conditionGuardsIndex(LHS, IndexVars,\
  \ ArrSize, C))\n      return true;\n    if (conditionGuardsIndex(RHS, IndexVars,\
  \ ArrSize, C))\n      return true;\n\n    return false;\n  }\n\n  // Fallback: if\
  \ the condition references both the index var and TRANSFER_FUNC_POINTS, consider\
  \ it guarded.\n  if (exprReferencesAnyVar(E, IndexVars) && ExprHasName(E, \"TRANSFER_FUNC_POINTS\"\
  , C))\n    return true;\n\n  // Recurse into subexpressions\n  for (const Stmt *Child\
  \ : E->children()) {\n    if (const auto *CE = dyn_cast_or_null<Expr>(Child)) {\n\
  \      if (conditionGuardsIndex(CE, IndexVars, ArrSize, C))\n        return true;\n\
  \    }\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::hasGuardingAncestorCondition(const\
  \ Stmt *Site,\n                                                    const llvm::SmallPtrSet<const\
  \ VarDecl *, 4> &IndexVars,\n                                                  \
  \  uint64_t ArrSize,\n                                                    CheckerContext\
  \ &C) {\n  // ForStmt\n  if (const auto *FS = findSpecificTypeInParents<ForStmt>(Site,\
  \ C)) {\n    if (conditionGuardsIndex(FS->getCond(), IndexVars, ArrSize, C))\n \
  \     return true;\n  }\n\n  // WhileStmt\n  if (const auto *WS = findSpecificTypeInParents<WhileStmt>(Site,\
  \ C)) {\n    if (conditionGuardsIndex(WS->getCond(), IndexVars, ArrSize, C))\n \
  \     return true;\n  }\n\n  // DoStmt\n  if (const auto *DS = findSpecificTypeInParents<DoStmt>(Site,\
  \ C)) {\n    if (conditionGuardsIndex(DS->getCond(), IndexVars, ArrSize, C))\n \
  \     return true;\n  }\n\n  // IfStmt\n  if (const auto *IS = findSpecificTypeInParents<IfStmt>(Site,\
  \ C)) {\n    if (conditionGuardsIndex(IS->getCond(), IndexVars, ArrSize, C))\n \
  \     return true;\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::reportOOB(const\
  \ ArraySubscriptExpr *ASE, StringRef Color, CheckerContext &C) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  SmallString<128>\
  \ Msg;\n  Msg += \"Index may exceed LUT bound when accessing tf_pts.\";\n  Msg +=\
  \ Color;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n\
  \  R->addRange(ASE->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\nvoid\
  \ SAGenTestChecker::checkPostStmt(const ArraySubscriptExpr *ASE, CheckerContext\
  \ &C) const {\n  if (!ASE)\n    return;\n\n  // Match output_tf->tf_pts.{red|green|blue}[idx]\n\
  \  std::string ColorName;\n  const FieldDecl *ColorFD = nullptr;\n  const ConstantArrayType\
  \ *ArrTy = nullptr;\n  if (!matchTfPtsColorChain(ASE->getBase(), ColorName, ColorFD,\
  \ ArrTy))\n    return;\n\n  // Obtain array size\n  llvm::APInt SizeAP = ArrTy->getSize();\n\
  \  uint64_t ArrSize = SizeAP.getLimitedValue(UINT64_MAX);\n  if (ArrSize == 0)\n\
  \    return;\n\n  const Expr *IdxE = ASE->getIdx();\n  if (!IdxE)\n    return;\n\
  \  IdxE = IdxE->IgnoreParenImpCasts();\n\n  // 1) Try constant evaluation\n  llvm::APSInt\
  \ IdxConst;\n  if (EvaluateExprToInt(IdxConst, IdxE, C)) {\n    int64_t IdxS = IdxConst.isSigned()\
  \ ? IdxConst.getSExtValue()\n                                       : static_cast<int64_t>(IdxConst.getZExtValue());\n\
  \    if (IdxS >= 0 && static_cast<uint64_t>(IdxS) >= ArrSize) {\n      reportOOB(ASE,\
  \ ColorName, C);\n      return;\n    }\n    // If constant and clearly within bound,\
  \ consider safe.\n    return;\n  }\n\n  // 2) Try to infer symbolic upper bound\n\
  \  ProgramStateRef State = C.getState();\n  SVal IdxSV = State->getSVal(IdxE, C.getLocationContext());\n\
  \  if (SymbolRef Sym = IdxSV.getAsSymbol()) {\n    if (const llvm::APSInt *MaxVal\
  \ = inferSymbolMaxVal(Sym, C)) {\n      uint64_t MaxU = MaxVal->isSigned()\n   \
  \                       ? (MaxVal->isNegative() ? 0ULL\n                       \
  \                           : static_cast<uint64_t>(MaxVal->getSExtValue()))\n \
  \                         : MaxVal->getZExtValue();\n      if (MaxU >= ArrSize)\
  \ {\n        reportOOB(ASE, ColorName, C);\n        return;\n      } else {\n  \
  \      // Max strictly less than ArrSize -> safe\n        return;\n      }\n   \
  \ }\n  }\n\n  // 3) Heuristic: attempt to find guarding ancestor conditions comparing\
  \ index vs TRANSFER_FUNC_POINTS / array size.\n  llvm::SmallPtrSet<const VarDecl\
  \ *, 4> IndexVars;\n  collectReferencedVars(IdxE, IndexVars);\n  if (hasGuardingAncestorCondition(ASE,\
  \ IndexVars, ArrSize, C)) {\n    // Consider guarded; do not warn.\n    return;\n\
  \  }\n\n  // 4) Could not prove bounded and no guard found: warn.\n  reportOOB(ASE,\
  \ ColorName, C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects missing bounds check when indexing tf_pts.{red,green,blue} LUT\
  \ with derived loop index\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Fix potential index out of bounds\
  \ in color transformation function\n\nFixes index out of bounds issue in the color\
  \ transformation function.\nThe issue could occur when the index 'i' exceeds the\
  \ number of transfer\nfunction points (TRANSFER_FUNC_POINTS).\n\nThe fix adds a\
  \ check to ensure 'i' is within bounds before accessing the\ntransfer function points.\
  \ If 'i' is out of bounds, an error message is\nlogged and the function returns\
  \ false to indicate an error.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:405\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.red'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:406\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.green'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:407\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.blue'\
  \ 1025 <= s32max\n\nFixes: b629596072e5 (\"drm/amd/display: Build unity lut for\
  \ shaper\")\nCc: Vitaly Prosyak <vitaly.prosyak@amd.com>\nCc: Charlene Liu <Charlene.Liu@amd.com>\n\
  Cc: Harry Wentland <harry.wentland@amd.com>\nCc: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>\n\
  Cc: Roman Li <roman.li@amd.com>\nCc: Aurabindo Pillai <aurabindo.pillai@amd.com>\n\
  Cc: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Srinivasan Shanmugam <srinivasan.shanmugam@amd.com>\n\
  Reviewed-by: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Alex Deucher <alexander.deucher@amd.com>\n\
  \n## Buggy Code\n\n```c\n// Function: cm_helper_translate_curve_to_hw_format in\
  \ drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nbool cm_helper_translate_curve_to_hw_format(struct\
  \ dc_context *ctx,\n\t\t\t\tconst struct dc_transfer_func *output_tf,\n\t\t\t\t\
  struct pwl_params *lut_params, bool fixpoint)\n{\n\tstruct curve_points3 *corner_points;\n\
  \tstruct pwl_result_data *rgb_resulted;\n\tstruct pwl_result_data *rgb;\n\tstruct\
  \ pwl_result_data *rgb_plus_1;\n\tstruct pwl_result_data *rgb_minus_1;\n\n\tint32_t\
  \ region_start, region_end;\n\tint32_t i;\n\tuint32_t j, k, seg_distr[MAX_REGIONS_NUMBER],\
  \ increment, start_index, hw_points;\n\n\tif (output_tf == NULL || lut_params ==\
  \ NULL || output_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\tcorner_points\
  \ = lut_params->corner_points;\n\trgb_resulted = lut_params->rgb_resulted;\n\thw_points\
  \ = 0;\n\n\tmemset(lut_params, 0, sizeof(struct pwl_params));\n\tmemset(seg_distr,\
  \ 0, sizeof(seg_distr));\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ || output_tf->tf\
  \ == TRANSFER_FUNCTION_GAMMA22) {\n\t\t/* 32 segments\n\t\t * segments are from\
  \ 2^-25 to 2^7\n\t\t */\n\t\tfor (i = 0; i < NUMBER_REGIONS ; i++)\n\t\t\tseg_distr[i]\
  \ = 3;\n\n\t\tregion_start = -MAX_LOW_POINT;\n\t\tregion_end   = NUMBER_REGIONS\
  \ - MAX_LOW_POINT;\n\t} else {\n\t\t/* 11 segments\n\t\t * segment is from 2^-10\
  \ to 2^1\n\t\t * There are less than 256 points, for optimization\n\t\t */\n\t\t\
  seg_distr[0] = 3;\n\t\tseg_distr[1] = 4;\n\t\tseg_distr[2] = 4;\n\t\tseg_distr[3]\
  \ = 4;\n\t\tseg_distr[4] = 4;\n\t\tseg_distr[5] = 4;\n\t\tseg_distr[6] = 4;\n\t\t\
  seg_distr[7] = 4;\n\t\tseg_distr[8] = 4;\n\t\tseg_distr[9] = 4;\n\t\tseg_distr[10]\
  \ = 1;\n\n\t\tregion_start = -10;\n\t\tregion_end = 1;\n\t}\n\n\tfor (i = region_end\
  \ - region_start; i < MAX_REGIONS_NUMBER ; i++)\n\t\tseg_distr[i] = -1;\n\n\tfor\
  \ (k = 0; k < MAX_REGIONS_NUMBER; k++) {\n\t\tif (seg_distr[k] != -1)\n\t\t\thw_points\
  \ += (1 << seg_distr[k]);\n\t}\n\n\tj = 0;\n\tfor (k = 0; k < (region_end - region_start);\
  \ k++) {\n\t\tincrement = NUMBER_SW_SEGMENTS / (1 << seg_distr[k]);\n\t\tstart_index\
  \ = (region_start + k + MAX_LOW_POINT) *\n\t\t\t\tNUMBER_SW_SEGMENTS;\n\t\tfor (i\
  \ = start_index; i < start_index + NUMBER_SW_SEGMENTS;\n\t\t\t\ti += increment)\
  \ {\n\t\t\tif (j == hw_points - 1)\n\t\t\t\tbreak;\n\t\t\trgb_resulted[j].red =\
  \ output_tf->tf_pts.red[i];\n\t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n\
  \t\t\trgb_resulted[j].blue = output_tf->tf_pts.blue[i];\n\t\t\tj++;\n\t\t}\n\t}\n\
  \n\t/* last point */\n\tstart_index = (region_end + MAX_LOW_POINT) * NUMBER_SW_SEGMENTS;\n\
  \trgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];\n\trgb_resulted[hw_points\
  \ - 1].green = output_tf->tf_pts.green[start_index];\n\trgb_resulted[hw_points -\
  \ 1].blue = output_tf->tf_pts.blue[start_index];\n\n\trgb_resulted[hw_points].red\
  \ = rgb_resulted[hw_points - 1].red;\n\trgb_resulted[hw_points].green = rgb_resulted[hw_points\
  \ - 1].green;\n\trgb_resulted[hw_points].blue = rgb_resulted[hw_points - 1].blue;\n\
  \n\t// All 3 color channels have same x\n\tcorner_points[0].red.x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\
  \t\t\t\t\t     dc_fixpt_from_int(region_start));\n\tcorner_points[0].green.x = corner_points[0].red.x;\n\
  \tcorner_points[0].blue.x = corner_points[0].red.x;\n\n\tcorner_points[1].red.x\
  \ = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_end));\n\
  \tcorner_points[1].green.x = corner_points[1].red.x;\n\tcorner_points[1].blue.x\
  \ = corner_points[1].red.x;\n\n\tcorner_points[0].red.y = rgb_resulted[0].red;\n\
  \tcorner_points[0].green.y = rgb_resulted[0].green;\n\tcorner_points[0].blue.y =\
  \ rgb_resulted[0].blue;\n\n\tcorner_points[0].red.slope = dc_fixpt_div(corner_points[0].red.y,\n\
  \t\t\tcorner_points[0].red.x);\n\tcorner_points[0].green.slope = dc_fixpt_div(corner_points[0].green.y,\n\
  \t\t\tcorner_points[0].green.x);\n\tcorner_points[0].blue.slope = dc_fixpt_div(corner_points[0].blue.y,\n\
  \t\t\tcorner_points[0].blue.x);\n\n\t/* see comment above, m_arrPoints[1].y should\
  \ be the Y value for the\n\t * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints\
  \ - 1)\n\t */\n\tcorner_points[1].red.y = rgb_resulted[hw_points - 1].red;\n\tcorner_points[1].green.y\
  \ = rgb_resulted[hw_points - 1].green;\n\tcorner_points[1].blue.y = rgb_resulted[hw_points\
  \ - 1].blue;\n\tcorner_points[1].red.slope = dc_fixpt_zero;\n\tcorner_points[1].green.slope\
  \ = dc_fixpt_zero;\n\tcorner_points[1].blue.slope = dc_fixpt_zero;\n\n\tif (output_tf->tf\
  \ == TRANSFER_FUNCTION_PQ) {\n\t\t/* for PQ, we want to have a straight line from\
  \ last HW X point,\n\t\t * and the slope to be such that we hit 1.0 at 10000 nits.\n\
  \t\t */\n\t\tconst struct fixed31_32 end_value =\n\t\t\t\tdc_fixpt_from_int(125);\n\
  \n\t\tcorner_points[1].red.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].red.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].red.x));\n\
  \t\tcorner_points[1].green.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].green.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].green.x));\n\
  \t\tcorner_points[1].blue.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].blue.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].blue.x));\n\
  \t}\n\n\tlut_params->hw_points_num = hw_points;\n\n\tk = 0;\n\tfor (i = 1; i < MAX_REGIONS_NUMBER;\
  \ i++) {\n\t\tif (seg_distr[k] != -1) {\n\t\t\tlut_params->arr_curve_points[k].segments_num\
  \ =\n\t\t\t\t\tseg_distr[k];\n\t\t\tlut_params->arr_curve_points[i].offset =\n\t\
  \t\t\t\tlut_params->arr_curve_points[k].offset + (1 << seg_distr[k]);\n\t\t}\n\t\
  \tk++;\n\t}\n\n\tif (seg_distr[k] != -1)\n\t\tlut_params->arr_curve_points[k].segments_num\
  \ = seg_distr[k];\n\n\trgb = rgb_resulted;\n\trgb_plus_1 = rgb_resulted + 1;\n\t\
  rgb_minus_1 = rgb;\n\n\ti = 1;\n\twhile (i != hw_points + 1) {\n\n\t\tif (i >= hw_points\
  \ - 1) {\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->red, rgb->red))\n\t\t\t\trgb_plus_1->red\
  \ = dc_fixpt_add(rgb->red, rgb_minus_1->delta_red);\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->green,\
  \ rgb->green))\n\t\t\t\trgb_plus_1->green = dc_fixpt_add(rgb->green, rgb_minus_1->delta_green);\n\
  \t\t\tif (dc_fixpt_lt(rgb_plus_1->blue, rgb->blue))\n\t\t\t\trgb_plus_1->blue =\
  \ dc_fixpt_add(rgb->blue, rgb_minus_1->delta_blue);\n\t\t}\n\n\t\trgb->delta_red\
  \   = dc_fixpt_sub(rgb_plus_1->red,   rgb->red);\n\t\trgb->delta_green = dc_fixpt_sub(rgb_plus_1->green,\
  \ rgb->green);\n\t\trgb->delta_blue  = dc_fixpt_sub(rgb_plus_1->blue,  rgb->blue);\n\
  \n\n\t\tif (fixpoint == true) {\n\t\t\tuint32_t red_clamp = dc_fixpt_clamp_u0d14(rgb->delta_red);\n\
  \t\t\tuint32_t green_clamp = dc_fixpt_clamp_u0d14(rgb->delta_green);\n\t\t\tuint32_t\
  \ blue_clamp = dc_fixpt_clamp_u0d14(rgb->delta_blue);\n\n\t\t\tif (red_clamp >>\
  \ 10 || green_clamp >> 10 || blue_clamp >> 10)\n\t\t\t\tDC_LOG_WARNING(\"Losing\
  \ delta precision while programming shaper LUT.\");\n\n\t\t\trgb->delta_red_reg\
  \   = red_clamp & 0x3ff;\n\t\t\trgb->delta_green_reg = green_clamp & 0x3ff;\n\t\t\
  \trgb->delta_blue_reg  = blue_clamp & 0x3ff;\n\t\t\trgb->red_reg         = dc_fixpt_clamp_u0d14(rgb->red);\n\
  \t\t\trgb->green_reg       = dc_fixpt_clamp_u0d14(rgb->green);\n\t\t\trgb->blue_reg\
  \        = dc_fixpt_clamp_u0d14(rgb->blue);\n\t\t}\n\n\t\t++rgb_plus_1;\n\t\trgb_minus_1\
  \ = rgb;\n\t\t++rgb;\n\t\t++i;\n\t}\n\tcm_helper_convert_to_custom_float(rgb_resulted,\n\
  \t\t\t\t\t\tlut_params->corner_points,\n\t\t\t\t\t\thw_points, fixpoint);\n\n\t\
  return true;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\
  \ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nindex b7e57aa27361..b0d192c6e63e\
  \ 100644\n--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n\
  @@ -402,6 +402,11 @@ bool cm_helper_translate_curve_to_hw_format(struct dc_context\
  \ *ctx,\n \t\t\t\ti += increment) {\n \t\t\tif (j == hw_points - 1)\n \t\t\t\tbreak;\n\
  +\t\t\tif (i >= TRANSFER_FUNC_POINTS) {\n+\t\t\t\tDC_LOG_ERROR(\"Index out of bounds:\
  \ i=%d, TRANSFER_FUNC_POINTS=%d\\n\",\n+\t\t\t\t\t     i, TRANSFER_FUNC_POINTS);\n\
  +\t\t\t\treturn false;\n+\t\t\t}\n \t\t\trgb_resulted[j].red = output_tf->tf_pts.red[i];\n\
  \ \t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n \t\t\trgb_resulted[j].blue\
  \ = output_tf->tf_pts.blue[i];\n```\n"
pattern: "## Bug Pattern\n\nIndexing a fixed-size LUT with a derived loop index without\
  \ validating it against the LUT\u2019s bound. Specifically, using:\n- output_tf->tf_pts.{red,\
  \ green, blue}[i]\nwhere i is computed from region/segment arithmetic (start_index,\
  \ increment) and the loop is controlled by j/hw_points rather than by the array\
  \ bound TRANSFER_FUNC_POINTS. This missing check allows i to reach/exceed TRANSFER_FUNC_POINTS,\
  \ causing out-of-bounds access."
plan: "Plan\n\n1. Program state\n- No custom program state maps or traits are required.\
  \ This checker can be implemented with localized (per-visit) reasoning aided by\
  \ constant evaluation and simple ancestor-condition inspection.\n\n2. Callback functions\n\
  - checkPostStmt<ArraySubscriptExpr>\n  - Goal: Detect array indexing into output_tf->tf_pts.{red,\
  \ green, blue}[idx] where idx is not proven to be within the array\u2019s bound\
  \ (TRANSFER_FUNC_POINTS).\n  - Steps:\n    1) Filter to the target arrays:\n   \
  \    - Get the base expression of the ArraySubscriptExpr (ASE->getBase()->IgnoreParenImpCasts()).\n\
  \       - Ensure it is a MemberExpr (ME) chain that matches the shape \u201C(...)->tf_pts.red\u201D\
  \ or \u201C(...).tf_pts.red\u201D (and analogously for green, blue).\n         -\
  \ Walk the MemberExpr chain upward:\n           - The final member name must be\
  \ one of: \"red\", \"green\", \"blue\".\n           - The immediate parent member\
  \ name in the chain must be \"tf_pts\".\n         - If this does not hold, ignore\
  \ the access.\n    2) Retrieve the array bound (TRANSFER_FUNC_POINTS) from the type:\n\
  \       - From the MemberExpr\u2019s member declaration (FieldDecl) corresponding\
  \ to \"red\"/\"green\"/\"blue\", obtain FieldDecl->getType().\n       - If the type\
  \ is a ConstantArrayType, read its size via getSize() into an APInt ArrSize.\n \
  \      - If it is not a ConstantArrayType (e.g., decayed to pointer or unknown),\
  \ stop (do not warn).\n    3) Analyze the index expression:\n       - Let IdxE =\
  \ ASE->getIdx()->IgnoreParenImpCasts().\n       - Try to evaluate IdxE to a constant\
  \ integer:\n         - Use EvaluateExprToInt. If success and IdxVal >= ArrSize,\
  \ report a bug.\n       - Otherwise, try a symbolic upper bound:\n         - Obtain\
  \ SVal for IdxE via C.getState()->getSVal(IdxE, C.getLocationContext()) and extract\
  \ SymbolRef if available.\n         - Call inferSymbolMaxVal(Sym, C). If it returns\
  \ a max value and maxVal >= ArrSize, report a bug.\n       - If neither constant\
  \ nor bounded symbol info is available, conservatively check for a guarding condition\
  \ nearby:\n         - Attempt to locate an enclosing loop/condition that bounds\
  \ the index:\n           - Search ancestors using findSpecificTypeInParents for\
  \ the nearest ForStmt, WhileStmt, DoStmt, or IfStmt (examine each in nearest-to-farthest\
  \ order).\n           - For each found condition expression CondE:\n           \
  \  - Determine if CondE references the same index variable(s) as in IdxE:\n    \
  \           - Collect DeclRefExprs inside IdxE; record their VarDecls (e.g., variable\
  \ \u201Ci\u201D).\n               - Check if CondE contains any of these variables\
  \ (by comparing VarDecl identity).\n             - If yes, try to confirm a bound\
  \ against the array size:\n               - Prefer structural comparison: if CondE\
  \ is/contains a BinaryOperator with opcode < or <= comparing the index variable\
  \ vs a constant expression that EvaluateExprToInt returns ArrSize, or ArrSize -\
  \ 1 (for <=).\n               - Otherwise, textual fallback:\n                 -\
  \ If ExprHasName(CondE, \"TRANSFER_FUNC_POINTS\", C) is true and CondE also references\
  \ the index variable, consider it guarded; do not warn.\n           - If any such\
  \ guarding comparison is found, do not warn.\n         - If no guard is found, and\
  \ we couldn\u2019t prove a safe upper bound, emit a warning (heuristic).\n    4)\
  \ Bug reporting:\n       - If a violation is found, create a non-fatal error node\
  \ with generateNonFatalErrorNode().\n       - Emit a PathSensitiveBugReport with\
  \ a short message, e.g.:\n         - \"Index may exceed LUT bound when accessing\
  \ tf_pts.[red|green|blue].\"\n       - Optionally include a note with the computed/known\
  \ bound (ArrSize) when available.\n\n3. Implementation details and guidance\n- Member\
  \ array bound extraction:\n  - For the base expression MemberExpr ME of \"red\"\
  /\"green\"/\"blue\":\n    - auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());\n\
  \    - QualType FT = FD->getType();\n    - const auto *CAT = dyn_cast<ConstantArrayType>(FT.getTypePtr());\n\
  \    - If CAT is null, bail out (do not warn).\n    - Else, ArrSize = CAT->getSize().\n\
  - Determine the specific array name for the report:\n  - From the terminal MemberExpr,\
  \ retrieve its member name string (\"red\", \"green\", \"blue\") for the message.\n\
  - Index variable extraction:\n  - Traverse IdxE to collect DeclRefExpr that refer\
  \ to VarDecls; you primarily care when there is a simple variable index like \u201C\
  i\u201D or derived arithmetic of \u201Ci\u201D.\n- Guard condition matching:\n \
  \ - For nearest ForStmt, inspect its condition ForStmt->getCond().\n  - For WhileStmt/DoStmt,\
  \ inspect their condition expressions.\n  - For IfStmt, inspect its condition.\n\
  \  - In the condition, first try to structurally match BinaryOperator with opcodes:\
  \ BO_LT, BO_LE, and check:\n    - If LHS/RHS is the index variable DeclRefExpr,\n\
  \    - And the comparator side EvaluateExprToInt equals ArrSize (or ArrSize - 1\
  \ for <=),\n    - Then treat as guarded.\n  - As a fallback, if ExprHasName(cond,\
  \ \"TRANSFER_FUNC_POINTS\", C) and the condition references the same variable(s),\
  \ treat as guarded.\n- False positive control:\n  - Only report when:\n    - The\
  \ index is a provable constant >= ArrSize, or\n    - Symbolic max is known and >=\
  \ ArrSize, or\n    - We cannot infer a bound and we cannot find any guard; in this\
  \ last case, report at most once per array expression site to reduce noise.\n- Scope\
  \ of checker:\n  - This checker is tailored to the AMD DC \u201Ctf_pts\u201D LUT\
  \ pattern and is limited to the member arrays named red/green/blue under tf_pts\
  \ to avoid broader noise, matching the target bug pattern precisely.\n- No other\
  \ callbacks are necessary:\n  - Do not use checkBranchCondition or checkBind unless\
  \ you want to enhance guard tracking. The parent-condition search is enough and\
  \ keeps the checker simple."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\
  \n#include <string>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\nnamespace {\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\
  \ : public Checker<check::PostStmt<ArraySubscriptExpr>> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"LUT index\
  \ may exceed bound\", \"Array bounds\")) {}\n\n      void checkPostStmt(const ArraySubscriptExpr\
  \ *ASE, CheckerContext &C) const;\n\n   private:\n\n      // Check if base expression\
  \ of array subscript matches (...)->tf_pts.{red|green|blue}\n      static bool matchTfPtsColorChain(const\
  \ Expr *BaseE,\n                                       std::string &ColorName,\n\
  \                                       const FieldDecl *&ColorFD,\n           \
  \                            const ConstantArrayType *&ArrTy);\n\n      // Collect\
  \ VarDecls referenced in an expression.\n      static void collectReferencedVars(const\
  \ Expr *E,\n                                        llvm::SmallPtrSet<const VarDecl\
  \ *, 4> &Vars);\n\n      // Check if an expression references any of the given variables.\n\
  \      static bool exprReferencesAnyVar(const Expr *E,\n                       \
  \                const llvm::SmallPtrSet<const VarDecl *, 4> &Vars);\n\n      //\
  \ Check whether the given condition provides a guard ensuring idx < ArrSize (or\
  \ <= ArrSize-1).\n      static bool conditionGuardsIndex(const Expr *CondE,\n  \
  \                                     const llvm::SmallPtrSet<const VarDecl *, 4>\
  \ &IndexVars,\n                                       uint64_t ArrSize,\n      \
  \                                 CheckerContext &C);\n\n      // Try to find an\
  \ enclosing condition that guards the index.\n      static bool hasGuardingAncestorCondition(const\
  \ Stmt *Site,\n                                               const llvm::SmallPtrSet<const\
  \ VarDecl *, 4> &IndexVars,\n                                               uint64_t\
  \ ArrSize,\n                                               CheckerContext &C);\n\
  \n      void reportOOB(const ArraySubscriptExpr *ASE, StringRef Color, CheckerContext\
  \ &C) const;\n};\n\nbool SAGenTestChecker::matchTfPtsColorChain(const Expr *BaseE,\n\
  \                                            std::string &ColorName,\n         \
  \                                   const FieldDecl *&ColorFD,\n               \
  \                             const ConstantArrayType *&ArrTy) {\n  if (!BaseE)\n\
  \    return false;\n\n  const Expr *E = BaseE->IgnoreParenImpCasts();\n\n  const\
  \ auto *MEColor = dyn_cast<MemberExpr>(E);\n  if (!MEColor)\n    return false;\n\
  \n  const auto *FDColor = dyn_cast<FieldDecl>(MEColor->getMemberDecl());\n  if (!FDColor)\n\
  \    return false;\n\n  StringRef Name = FDColor->getName();\n  if (!(Name == \"\
  red\" || Name == \"green\" || Name == \"blue\"))\n    return false;\n\n  const Expr\
  \ *TfBase = MEColor->getBase();\n  if (!TfBase)\n    return false;\n\n  TfBase =\
  \ TfBase->IgnoreParenImpCasts();\n  const auto *METf = dyn_cast<MemberExpr>(TfBase);\n\
  \  if (!METf)\n    return false;\n\n  const auto *FDTf = dyn_cast<FieldDecl>(METf->getMemberDecl());\n\
  \  if (!FDTf)\n    return false;\n\n  if (FDTf->getName() != \"tf_pts\")\n    return\
  \ false;\n\n  // Extract the array type of color field: should be a ConstantArrayType\n\
  \  QualType FT = FDColor->getType();\n  const Type *Ty = FT.getTypePtrOrNull();\n\
  \  if (!Ty)\n    return false;\n\n  const auto *CAT = dyn_cast<ConstantArrayType>(Ty);\n\
  \  if (!CAT)\n    return false;\n\n  ColorName = Name.str();\n  ColorFD = FDColor;\n\
  \  ArrTy = CAT;\n  return true;\n}\n\nvoid SAGenTestChecker::collectReferencedVars(const\
  \ Expr *E,\n                                             llvm::SmallPtrSet<const\
  \ VarDecl *, 4> &Vars) {\n  if (!E)\n    return;\n\n  E = E->IgnoreParenImpCasts();\n\
  \n  if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {\n    if (const auto *VD =\
  \ dyn_cast<VarDecl>(DRE->getDecl()))\n      Vars.insert(VD);\n    return;\n  }\n\
  \n  // Recurse into children\n  for (const Stmt *Child : E->children()) {\n    if\
  \ (const auto *CE = dyn_cast_or_null<Expr>(Child))\n      collectReferencedVars(CE,\
  \ Vars);\n  }\n}\n\nbool SAGenTestChecker::exprReferencesAnyVar(const Expr *E,\n\
  \                                            const llvm::SmallPtrSet<const VarDecl\
  \ *, 4> &Vars) {\n  if (!E)\n    return false;\n\n  E = E->IgnoreParenImpCasts();\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(E)) {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n\
  \      return Vars.count(VD);\n    return false;\n  }\n\n  for (const Stmt *Child\
  \ : E->children()) {\n    if (const auto *CE = dyn_cast_or_null<Expr>(Child)) {\n\
  \      if (exprReferencesAnyVar(CE, Vars))\n        return true;\n    }\n  }\n \
  \ return false;\n}\n\nstatic bool evalToUInt64(const Expr *E, CheckerContext &C,\
  \ uint64_t &Out) {\n  if (!E)\n    return false;\n  llvm::APSInt Res;\n  if (!EvaluateExprToInt(Res,\
  \ E, C))\n    return false;\n  if (Res.isSigned()) {\n    if (Res.isNegative())\n\
  \      return false;\n    Out = static_cast<uint64_t>(Res.getSExtValue());\n  }\
  \ else {\n    Out = Res.getZExtValue();\n  }\n  return true;\n}\n\nbool SAGenTestChecker::conditionGuardsIndex(const\
  \ Expr *CondE,\n                                            const llvm::SmallPtrSet<const\
  \ VarDecl *, 4> &IndexVars,\n                                            uint64_t\
  \ ArrSize,\n                                            CheckerContext &C) {\n \
  \ if (!CondE)\n    return false;\n\n  const Expr *E = CondE->IgnoreParenCasts();\n\
  \n  // Direct binary operator\n  if (const auto *BO = dyn_cast<BinaryOperator>(E))\
  \ {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n    const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \    const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n    // Case 1: var <\
  \ N or var <= N\n    if (exprReferencesAnyVar(LHS, IndexVars)) {\n      uint64_t\
  \ N;\n      if (evalToUInt64(RHS, C, N)) {\n        if (Op == BO_LT && N == ArrSize)\n\
  \          return true;\n        if (Op == BO_LE && N == (ArrSize - (ArrSize ? 1\
  \ : 0)))\n          return ArrSize > 0;\n      }\n    }\n\n    // Case 2: N > var\
  \ or N >= var\n    if (exprReferencesAnyVar(RHS, IndexVars)) {\n      uint64_t N;\n\
  \      if (evalToUInt64(LHS, C, N)) {\n        if (Op == BO_GT && N == ArrSize)\n\
  \          return true;\n        if (Op == BO_GE && N == (ArrSize - (ArrSize ? 1\
  \ : 0)))\n          return ArrSize > 0;\n      }\n    }\n\n    // Recurse deeper\
  \ for compound conditions: (A && B) etc.\n    if (conditionGuardsIndex(LHS, IndexVars,\
  \ ArrSize, C))\n      return true;\n    if (conditionGuardsIndex(RHS, IndexVars,\
  \ ArrSize, C))\n      return true;\n\n    return false;\n  }\n\n  // Fallback: if\
  \ the condition references both the index var and TRANSFER_FUNC_POINTS, consider\
  \ it guarded.\n  if (exprReferencesAnyVar(E, IndexVars) && ExprHasName(E, \"TRANSFER_FUNC_POINTS\"\
  , C))\n    return true;\n\n  // Recurse into subexpressions\n  for (const Stmt *Child\
  \ : E->children()) {\n    if (const auto *CE = dyn_cast_or_null<Expr>(Child)) {\n\
  \      if (conditionGuardsIndex(CE, IndexVars, ArrSize, C))\n        return true;\n\
  \    }\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::hasGuardingAncestorCondition(const\
  \ Stmt *Site,\n                                                    const llvm::SmallPtrSet<const\
  \ VarDecl *, 4> &IndexVars,\n                                                  \
  \  uint64_t ArrSize,\n                                                    CheckerContext\
  \ &C) {\n  // ForStmt\n  if (const auto *FS = findSpecificTypeInParents<ForStmt>(Site,\
  \ C)) {\n    if (conditionGuardsIndex(FS->getCond(), IndexVars, ArrSize, C))\n \
  \     return true;\n  }\n\n  // WhileStmt\n  if (const auto *WS = findSpecificTypeInParents<WhileStmt>(Site,\
  \ C)) {\n    if (conditionGuardsIndex(WS->getCond(), IndexVars, ArrSize, C))\n \
  \     return true;\n  }\n\n  // DoStmt\n  if (const auto *DS = findSpecificTypeInParents<DoStmt>(Site,\
  \ C)) {\n    if (conditionGuardsIndex(DS->getCond(), IndexVars, ArrSize, C))\n \
  \     return true;\n  }\n\n  // IfStmt\n  if (const auto *IS = findSpecificTypeInParents<IfStmt>(Site,\
  \ C)) {\n    if (conditionGuardsIndex(IS->getCond(), IndexVars, ArrSize, C))\n \
  \     return true;\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::reportOOB(const\
  \ ArraySubscriptExpr *ASE, StringRef Color, CheckerContext &C) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  SmallString<128>\
  \ Msg;\n  Msg += \"Index may exceed LUT bound when accessing tf_pts.\";\n  Msg +=\
  \ Color;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n\
  \  R->addRange(ASE->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\nvoid\
  \ SAGenTestChecker::checkPostStmt(const ArraySubscriptExpr *ASE, CheckerContext\
  \ &C) const {\n  if (!ASE)\n    return;\n\n  // Match output_tf->tf_pts.{red|green|blue}[idx]\n\
  \  std::string ColorName;\n  const FieldDecl *ColorFD = nullptr;\n  const ConstantArrayType\
  \ *ArrTy = nullptr;\n  if (!matchTfPtsColorChain(ASE->getBase(), ColorName, ColorFD,\
  \ ArrTy))\n    return;\n\n  // Obtain array size\n  llvm::APInt SizeAP = ArrTy->getSize();\n\
  \  uint64_t ArrSize = SizeAP.getLimitedValue(UINT64_MAX);\n  if (ArrSize == 0)\n\
  \    return;\n\n  const Expr *IdxE = ASE->getIdx();\n  if (!IdxE)\n    return;\n\
  \  IdxE = IdxE->IgnoreParenImpCasts();\n\n  // 1) Try constant evaluation\n  llvm::APSInt\
  \ IdxConst;\n  if (EvaluateExprToInt(IdxConst, IdxE, C)) {\n    int64_t IdxS = IdxConst.isSigned()\
  \ ? IdxConst.getSExtValue()\n                                       : static_cast<int64_t>(IdxConst.getZExtValue());\n\
  \    if (IdxS >= 0 && static_cast<uint64_t>(IdxS) >= ArrSize) {\n      reportOOB(ASE,\
  \ ColorName, C);\n      return;\n    }\n    // If constant and clearly within bound,\
  \ consider safe.\n    return;\n  }\n\n  // 2) Try to infer symbolic upper bound\n\
  \  ProgramStateRef State = C.getState();\n  SVal IdxSV = State->getSVal(IdxE, C.getLocationContext());\n\
  \  if (SymbolRef Sym = IdxSV.getAsSymbol()) {\n    if (const llvm::APSInt *MaxVal\
  \ = inferSymbolMaxVal(Sym, C)) {\n      uint64_t MaxU = MaxVal->isSigned()\n   \
  \                       ? (MaxVal->isNegative() ? 0ULL\n                       \
  \                           : static_cast<uint64_t>(MaxVal->getSExtValue()))\n \
  \                         : MaxVal->getZExtValue();\n      if (MaxU >= ArrSize)\
  \ {\n        reportOOB(ASE, ColorName, C);\n        return;\n      } else {\n  \
  \      // Max strictly less than ArrSize -> safe\n        return;\n      }\n   \
  \ }\n  }\n\n  // 3) Heuristic: attempt to find guarding ancestor conditions comparing\
  \ index vs TRANSFER_FUNC_POINTS / array size.\n  llvm::SmallPtrSet<const VarDecl\
  \ *, 4> IndexVars;\n  collectReferencedVars(IdxE, IndexVars);\n  if (hasGuardingAncestorCondition(ASE,\
  \ IndexVars, ArrSize, C)) {\n    // Consider guarded; do not warn.\n    return;\n\
  \  }\n\n  // 4) Could not prove bounded and no guard found: warn.\n  reportOOB(ASE,\
  \ ColorName, C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects missing bounds check when indexing tf_pts.{red,green,blue} LUT\
  \ with derived loop index\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
