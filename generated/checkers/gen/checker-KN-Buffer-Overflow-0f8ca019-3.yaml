_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 0f8ca019544a252d1afb468ce840c6dcbac73af4
commit_type: Buffer-Overflow
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include <string>\n#include <sstream>\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// No custom program states are necessary.\n\n\
  namespace {\n\nclass SAGenTestChecker : public Checker<check::Location> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"Index may exceed array size\", \"Buffer Overflow\")) {}\n\n  \
  \    void checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C)\
  \ const;\n\n   private:\n\n      // Helper: Try to obtain constant array size from\
  \ the base expression of an array subscript.\n      bool getConstantArraySizeFromBase(const\
  \ Expr *Base, llvm::APInt &Size, CheckerContext &C) const;\n\n      // Helper: Obtain\
  \ a maximum possible value for an index expression along the current path.\n   \
  \   // KnownKind: 0 = exact constant; 1 = path-constrained max.\n      bool getIndexMax(const\
  \ Expr *IdxE, CheckerContext &C, llvm::APSInt &MaxIdx, unsigned &KnownKind) const;\n\
  \n      // Helper: If within a for-loop, extract a constant loop upper bound for\
  \ the index variable.\n      bool getLoopUpperBoundIfApplicable(const ArraySubscriptExpr\
  \ *ASE, const Expr *IdxE,\n                                         CheckerContext\
  \ &C, llvm::APSInt &LoopMaxIdx) const;\n\n      void report(const ArraySubscriptExpr\
  \ *ASE, uint64_t ArrSize, uint64_t MaxIdxVal,\n                  CheckerContext\
  \ &C) const;\n};\n\n// Implementation\n\nbool SAGenTestChecker::getConstantArraySizeFromBase(const\
  \ Expr *Base, llvm::APInt &Size,\n                                             \
  \       CheckerContext &C) const {\n  if (!Base)\n    return false;\n\n  const Expr\
  \ *E = Base;\n\n  // If there is an ArrayToPointerDecay, strip it to reach the array-typed\
  \ expr.\n  if (const auto *ICE = dyn_cast<ImplicitCastExpr>(E)) {\n    if (ICE->getCastKind()\
  \ == CK_ArrayToPointerDecay)\n      E = ICE->getSubExpr();\n  }\n\n  // Try direct:\
  \ if expression type is a constant array type.\n  QualType QT = E->getType();\n\
  \  if (!QT.isNull()) {\n    if (const auto *CAT = dyn_cast_or_null<ConstantArrayType>(QT.getTypePtrOrNull()))\
  \ {\n      Size = CAT->getSize();\n      return true;\n    }\n  }\n\n  // Strip\
  \ parens/casts after checking for decay, to find DeclRefExpr/MemberExpr.\n  E =\
  \ E->IgnoreParenCasts();\n\n  // DeclRefExpr (global/local arrays)\n  if (getArraySizeFromExpr(Size,\
  \ E))\n    return true;\n\n  // MemberExpr (array field in struct/union)\n  if (const\
  \ auto *ME = dyn_cast<MemberExpr>(E)) {\n    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl()))\
  \ {\n      QualType FT = FD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(FT.getTypePtr()))\
  \ {\n        Size = CAT->getSize();\n        return true;\n      }\n    }\n  }\n\
  \n  return false;\n}\n\nbool SAGenTestChecker::getIndexMax(const Expr *IdxE, CheckerContext\
  \ &C,\n                                   llvm::APSInt &MaxIdx, unsigned &KnownKind)\
  \ const {\n  if (!IdxE)\n    return false;\n\n  // First: try to evaluate as constant.\n\
  \  llvm::APSInt EvalRes;\n  if (EvaluateExprToInt(EvalRes, IdxE, C)) {\n    MaxIdx\
  \ = EvalRes;\n    KnownKind = 0; // exact\n    return true;\n  }\n\n  // Otherwise,\
  \ try to obtain a symbol and infer maximal value along current path.\n  ProgramStateRef\
  \ State = C.getState();\n  SVal SV = State->getSVal(IdxE, C.getLocationContext());\n\
  \  if (SymbolRef Sym = SV.getAsSymbol()) {\n    if (const llvm::APSInt *maxVal =\
  \ inferSymbolMaxVal(Sym, C)) {\n      MaxIdx = *maxVal;\n      KnownKind = 1; //\
  \ path-constrained max\n      return true;\n    }\n  }\n  return false;\n}\n\nstatic\
  \ const DeclRefExpr *getAsDeclRef(const Expr *E) {\n  if (!E) return nullptr;\n\
  \  return dyn_cast<DeclRefExpr>(E->IgnoreParenCasts());\n}\n\nbool SAGenTestChecker::getLoopUpperBoundIfApplicable(const\
  \ ArraySubscriptExpr *ASE,\n                                                   \
  \  const Expr *IdxE,\n                                                     CheckerContext\
  \ &C,\n                                                     llvm::APSInt &LoopMaxIdx)\
  \ const {\n  if (!ASE || !IdxE)\n    return false;\n\n  const DeclRefExpr *IdxDRE\
  \ = getAsDeclRef(IdxE);\n  if (!IdxDRE)\n    return false;\n\n  const auto *VD =\
  \ dyn_cast<VarDecl>(IdxDRE->getDecl());\n  if (!VD)\n    return false;\n\n  const\
  \ ForStmt *FS = findSpecificTypeInParents<ForStmt>(ASE, C);\n  if (!FS)\n    return\
  \ false;\n\n  const Stmt *CondS = FS->getCond();\n  if (!CondS)\n    return false;\n\
  \n  const auto *CondBO = dyn_cast<BinaryOperator>(const_cast<Stmt*>(CondS)->IgnoreParenCasts());\n\
  \  if (!CondBO)\n    return false;\n\n  BinaryOperator::Opcode Opc = CondBO->getOpcode();\n\
  \  if (Opc != BO_LT && Opc != BO_LE)\n    return false;\n\n  const Expr *LHS = CondBO->getLHS()->IgnoreParenCasts();\n\
  \  const Expr *RHS = CondBO->getRHS()->IgnoreParenCasts();\n\n  const DeclRefExpr\
  \ *LHSVar = getAsDeclRef(LHS);\n  const DeclRefExpr *RHSVar = getAsDeclRef(RHS);\n\
  \n  const Expr *BoundExpr = nullptr;\n\n  if (LHSVar && LHSVar->getDecl() == VD)\
  \ {\n    BoundExpr = RHS;\n  } else if (RHSVar && RHSVar->getDecl() == VD) {\n \
  \   BoundExpr = LHS;\n  } else {\n    return false;\n  }\n\n  llvm::APSInt UB;\n\
  \  if (!EvaluateExprToInt(UB, BoundExpr, C))\n    return false;\n\n  // Convert\
  \ to an appropriate index maximum (for i < UB, max is UB-1; for i <= UB, max is\
  \ UB).\n  if (Opc == BO_LT) {\n    // UB - 1\n    if (UB == 0) {\n      // i < 0\
  \ is empty, but be conservative.\n      LoopMaxIdx = UB;\n    } else {\n      LoopMaxIdx\
  \ = UB - 1;\n    }\n  } else {\n    LoopMaxIdx = UB;\n  }\n\n  return true;\n}\n\
  \nvoid SAGenTestChecker::report(const ArraySubscriptExpr *ASE, uint64_t ArrSize,\n\
  \                              uint64_t MaxIdxVal, CheckerContext &C) const {\n\
  \  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n\
  \  std::string Msg = \"Index may exceed array size (size=\" + std::to_string(ArrSize)\
  \ +\n                    \", max=\" + std::to_string(MaxIdxVal) + \")\";\n  auto\
  \ R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n\n  // Highlight the\
  \ indexing expression.\n  R->addRange(ASE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\
  \ CheckerContext &C) const {\n  if (!S)\n    return;\n\n  // Try to find an ArraySubscriptExpr\
  \ related to this memory access.\n  const ArraySubscriptExpr *ASE = dyn_cast<ArraySubscriptExpr>(S);\n\
  \  if (!ASE)\n    ASE = findSpecificTypeInChildren<ArraySubscriptExpr>(S);\n  if\
  \ (!ASE)\n    return;\n\n  // Get constant array size from the base expression (compile-time\
  \ known arrays only).\n  llvm::APInt ArraySizeAP;\n  if (!getConstantArraySizeFromBase(ASE->getBase(),\
  \ ArraySizeAP, C))\n    return;\n\n  uint64_t ArrSize = ArraySizeAP.getZExtValue();\n\
  \n  // Analyze the index expression to get a max bound.\n  const Expr *IdxE = ASE->getIdx()->IgnoreParenImpCasts();\n\
  \n  llvm::APSInt MaxIdx;\n  unsigned KnownKind = 2; // unknown\n  if (getIndexMax(IdxE,\
  \ C, MaxIdx, KnownKind)) {\n    // Prepare a comparable APSInt for array size using\
  \ MaxIdx's bitwidth/sign.\n    llvm::APInt ArrSizeAsAPInt(MaxIdx.getBitWidth(),\
  \ ArrSize);\n    llvm::APSInt ArrSizeAPS(ArrSizeAsAPInt, MaxIdx.isUnsigned());\n\
  \n    if (MaxIdx >= ArrSizeAPS) {\n      // Form a reasonable max value for message.\n\
  \      uint64_t MaxIdxVal = MaxIdx.isUnsigned()\n                              \
  \ ? MaxIdx.getZExtValue()\n                               : (MaxIdx.isNegative()\
  \ ? 0ULL\n                                                      : static_cast<uint64_t>(MaxIdx.getSExtValue()));\n\
  \      report(ASE, ArrSize, MaxIdxVal, C);\n    }\n    return; // If we have path-constrained\
  \ info, do not fallback to loop bound.\n  }\n\n  // Fallback: Extract loop upper\
  \ bound if applicable (common pattern i < CONST).\n  llvm::APSInt LoopMaxIdx;\n\
  \  if (getLoopUpperBoundIfApplicable(ASE, IdxE, C, LoopMaxIdx)) {\n    llvm::APInt\
  \ ArrSizeAsAPInt(LoopMaxIdx.getBitWidth(), ArrSize);\n    llvm::APSInt ArrSizeAPS(ArrSizeAsAPInt,\
  \ LoopMaxIdx.isUnsigned());\n    if (LoopMaxIdx >= ArrSizeAPS) {\n      uint64_t\
  \ MaxIdxVal = LoopMaxIdx.isUnsigned()\n                               ? LoopMaxIdx.getZExtValue()\n\
  \                               : (LoopMaxIdx.isNegative() ? 0ULL\n            \
  \                                              : static_cast<uint64_t>(LoopMaxIdx.getSExtValue()));\n\
  \      report(ASE, ArrSize, MaxIdxVal, C);\n    }\n  }\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects array indexing where loop bound constant may exceed the array's\
  \ compile-time size\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Prevent potential buffer overflow\
  \ in map_hw_resources\n\nAdds a check in the map_hw_resources function to prevent\
  \ a potential\nbuffer overflow. The function was accessing arrays using an index\
  \ that\ncould potentially be greater than the size of the arrays, leading to a\n\
  buffer overflow.\n\nAdds a check to ensure that the index is within the bounds of\
  \ the\narrays. If the index is out of bounds, an error message is printed and\n\
  break it will continue execution with just ignoring extra data early to\nprevent\
  \ the buffer overflow.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dml2/dml2_wrapper.c:79\
  \ map_hw_resources() error: buffer overflow 'dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_stream_id'\
  \ 6 <= 7\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dml2/dml2_wrapper.c:81 map_hw_resources()\
  \ error: buffer overflow 'dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_plane_id'\
  \ 6 <= 7\n\nFixes: 7966f319c66d (\"drm/amd/display: Introduce DML2\")\nCc: Rodrigo\
  \ Siqueira <Rodrigo.Siqueira@amd.com>\nCc: Roman Li <roman.li@amd.com>\nCc: Qingqing\
  \ Zhuo <Qingqing.Zhuo@amd.com>\nCc: Aurabindo Pillai <aurabindo.pillai@amd.com>\n\
  Cc: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Srinivasan Shanmugam <srinivasan.shanmugam@amd.com>\n\
  Suggested-by: Roman Li <roman.li@amd.com>\nReviewed-by: Roman Li <roman.li@amd.com>\n\
  Reviewed-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>\nSigned-off-by: Alex Deucher\
  \ <alexander.deucher@amd.com>\n\n## Buggy Code\n\n```c\n// Function: map_hw_resources\
  \ in drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c\nstatic void map_hw_resources(struct\
  \ dml2_context *dml2,\n\t\tstruct dml_display_cfg_st *in_out_display_cfg, struct\
  \ dml_mode_support_info_st *mode_support_info)\n{\n\tunsigned int num_pipes = 0;\n\
  \tint i, j;\n\n\tfor (i = 0; i < __DML_NUM_PLANES__; i++) {\n\t\tin_out_display_cfg->hw.ODMMode[i]\
  \ = mode_support_info->ODMMode[i];\n\t\tin_out_display_cfg->hw.DPPPerSurface[i]\
  \ = mode_support_info->DPPPerSurface[i];\n\t\tin_out_display_cfg->hw.DSCEnabled[i]\
  \ = mode_support_info->DSCEnabled[i];\n\t\tin_out_display_cfg->hw.NumberOfDSCSlices[i]\
  \ = mode_support_info->NumberOfDSCSlices[i];\n\t\tin_out_display_cfg->hw.DLGRefClkFreqMHz\
  \ = 24;\n\t\tif (dml2->v20.dml_core_ctx.project != dml_project_dcn35 &&\n\t\t\t\
  dml2->v20.dml_core_ctx.project != dml_project_dcn351) {\n\t\t\t/*dGPU default as\
  \ 50Mhz*/\n\t\t\tin_out_display_cfg->hw.DLGRefClkFreqMHz = 50;\n\t\t}\n\t\tfor (j\
  \ = 0; j < mode_support_info->DPPPerSurface[i]; j++) {\n\t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_stream_id[num_pipes]\
  \ = dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_stream_id[i];\n\t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_stream_id_valid[num_pipes]\
  \ = true;\n\t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_plane_id[num_pipes]\
  \ = dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_plane_id[i];\n\t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_plane_id_valid[num_pipes]\
  \ = true;\n\t\t\tnum_pipes++;\n\t\t}\n\t}\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c\n\
  index 26307e599614..2a58a7687bdb 100644\n--- a/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c\n\
  +++ b/drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c\n@@ -76,6 +76,11 @@ static\
  \ void map_hw_resources(struct dml2_context *dml2,\n \t\t\tin_out_display_cfg->hw.DLGRefClkFreqMHz\
  \ = 50;\n \t\t}\n \t\tfor (j = 0; j < mode_support_info->DPPPerSurface[i]; j++)\
  \ {\n+\t\t\tif (i >= __DML2_WRAPPER_MAX_STREAMS_PLANES__) {\n+\t\t\t\tdml_print(\"\
  DML::%s: Index out of bounds: i=%d, __DML2_WRAPPER_MAX_STREAMS_PLANES__=%d\\n\"\
  ,\n+\t\t\t\t\t  __func__, i, __DML2_WRAPPER_MAX_STREAMS_PLANES__);\n+\t\t\t\tbreak;\n\
  +\t\t\t}\n \t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_stream_id[num_pipes]\
  \ = dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_stream_id[i];\n \t\t\t\
  dml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_stream_id_valid[num_pipes]\
  \ = true;\n \t\t\tdml2->v20.scratch.dml_to_dc_pipe_mapping.dml_pipe_idx_to_plane_id[num_pipes]\
  \ = dml2->v20.scratch.dml_to_dc_pipe_mapping.disp_cfg_to_plane_id[i];\n```\n"
pattern: "## Bug Pattern\n\nIndexing an array using a loop bound defined by a different\
  \ (larger) compile-time constant than the array\u2019s actual size. Specifically:\n\
  - Loop iterates with i < __DML_NUM_PLANES__, but accesses arrays sized to __DML2_WRAPPER_MAX_STREAMS_PLANES__:\n\
  \  disp_cfg_to_stream_id[i] and disp_cfg_to_plane_id[i].\n- Missing bounds check\
  \ allows i to exceed the arrays\u2019 capacity, causing out-of-bounds access (buffer\
  \ overflow)."
plan: "1) Program state\n- No custom program state is necessary. This bug can be detected\
  \ at the array-subscript access site using current path constraints.\n- We will\
  \ only use the existing constraint system via inferSymbolMaxVal and simple AST evaluation\
  \ via EvaluateExprToInt.\n\n2) Callbacks\n- Use only checkLocation (primary) and\
  \ optionally check::BranchCondition (no state changes, just to allow future suppression).\
  \ The core detection is in checkLocation.\n\n3) Detailed steps\n\nStep A. Helper\
  \ utilities (internal to the checker)\n- getConstantArraySizeFromBase(const Expr\
  \ *Base, llvm::APInt &Size, CheckerContext &C):\n  - Strip casts/decay: Base = Base->IgnoreParenImpCasts().\n\
  \  - Handle DeclRefExpr (global/local arrays):\n    - Reuse provided getArraySizeFromExpr(Size,\
  \ Base). If true, return true.\n  - Handle MemberExpr (struct/class arrays):\n \
  \   - If Base is a MemberExpr, fetch FieldDecl = dyn_cast<FieldDecl>(ME->getMemberDecl()).\n\
  \    - From FieldDecl->getType(), dyn_cast<ConstantArrayType> and extract Size.\
  \ Return true if found.\n  - Handle nested cases like array fields under multiple\
  \ MemberExprs:\n    - Recurse on ME->getBase() until the last MemberExpr that is\
  \ the array field, but the target array field is the \u201Clast\u201D member in\
  \ the access chain for the ArraySubscriptExpr\u2019s base. Usually, ArraySubscriptExpr\
  \ base points directly to the array-typed member (pre-decay). If the immediate type\
  \ is already pointer-decayed, inspect the referenced FieldDecl as above.\n  - If\
  \ none of the above obtains a ConstantArrayType, return false.\n\n- getIndexMax(const\
  \ Expr *IdxE, CheckerContext &C, llvm::APSInt &MaxIdx, unsigned &KnownKind):\n \
  \ - Try constant evaluation:\n    - If EvaluateExprToInt(MaxIdx, IdxE, C) succeeds,\
  \ set KnownKind=0 (ExactConst) and return true.\n  - Otherwise get the SVal for\
  \ IdxE: SVal SV = C.getState()->getSVal(IdxE, C.getLocationContext()).\n    - If\
  \ SymbolRef Sym = SV.getAsSymbol(), call inferSymbolMaxVal(Sym, C). If non-null,\
  \ assign to MaxIdx and set KnownKind=1 (PathMax) and return true.\n  - If both fail,\
  \ return false.\n\n- getLoopUpperBoundIfApplicable(const ArraySubscriptExpr *ASE,\
  \ const Expr *IdxE, CheckerContext &C, llvm::APSInt &LoopMaxIdx, bool &IsLe):\n\
  \  - Parent-search: const ForStmt *FS = findSpecificTypeInParents<ForStmt>(ASE,\
  \ C).\n  - If no FS, return false.\n  - Check FS->getCond() is a BinaryOperator\
  \ with op < or <=.\n    - Find the \u201Cloop var\u201D DeclRefExpr on one side\
  \ of Cond and check it refers to the same VarDecl as IdxE (if IdxE is a DeclRefExpr).\
  \ If not a simple DeclRefExpr index, return false.\n    - Extract RHS bound expression\
  \ (the side that is not the loop var).\n    - Evaluate RHS via EvaluateExprToInt\
  \ to an integer UB; if not evaluable, return false.\n    - If op is \u2018<\u2019\
  , set LoopMaxIdx = UB - 1; IsLe=false.\n      If op is \u2018<=\u2019, set LoopMaxIdx\
  \ = UB; IsLe=true.\n    - Return true.\n  - Otherwise, return false.\n\nNote: getLoopUpperBoundIfApplicable\
  \ is a fallback to produce a more specific message if inferSymbolMaxVal fails.\n\
  \nStep B. Detection in checkLocation\n- Trigger condition: if S (the statement passed\
  \ to checkLocation) is an ArraySubscriptExpr ASE.\n- Compute the array bound N:\n\
  \  - llvm::APInt ArraySize; if !getConstantArraySizeFromBase(ASE->getBase(), ArraySize,\
  \ C), bail out (we only warn for known compile-time array sizes).\n  - Let N = ArraySize.getZExtValue().\n\
  \n- Analyze the index:\n  - const Expr *IdxE = ASE->getIdx()->IgnoreParenImpCasts().\n\
  \  - First, try path-sensitive bound:\n    - llvm::APSInt MaxIdx; unsigned KnownKind;\n\
  \    - If getIndexMax(IdxE, C, MaxIdx, KnownKind) succeeds:\n      - If MaxIdx.uge(N)\
  \ then report a potential overflow:\n        - Rationale: along current path, the\
  \ analyzer permits the index to be as large as MaxIdx, and if MaxIdx >= N, there\
  \ exists a feasible state where index >= N (unless further guards exist; those guards\
  \ would have already refined constraints and reduced MaxIdx).\n        - Create\
  \ a non-fatal error node and emit a short bug report:\n          - Title: \u201C\
  Loop bound exceeds array size\u201D\n          - Message: \u201CIndex may exceed\
  \ array size (max index >= size).\u201D\n          - Optionally add notes:\n   \
  \         - \u201CArray size: N\u201D\n            - If KnownKind==0: \u201CIndex\
  \ is constant K\u201D\n            - If KnownKind==1: \u201CMax index under current\
  \ constraints: MaxIdx\u201D\n        - Return (avoid duplicate reports).\n    -\
  \ If getIndexMax failed (no constraints available), try to pull a loop bound to\
  \ compare:\n      - llvm::APSInt LoopMaxIdx; bool IsLe;\n      - If getLoopUpperBoundIfApplicable(ASE,\
  \ IdxE, C, LoopMaxIdx, IsLe) succeeds and LoopMaxIdx.uge(N):\n        - Report \u201C\
  Loop bound exceeds array size\u201D.\n        - Optional macro-based hint (to make\
  \ it precise for the target pattern):\n          - If ExprHasName(FS->getCond(),\
  \ \u201C__DML_NUM_PLANES__\u201D, C) and ExprHasName(ASE->getBase(), \u201Cdisp_cfg_to_\u201D\
  , C), include in the message: \u201CBound uses __DML_NUM_PLANES__ while array is\
  \ smaller.\u201D\n        - Return.\n\n- Heuristic to avoid false positives:\n \
  \ - If the current path contains a dominating guard like \u201Cif (idx >= N) break/return/continue\u201D\
  \ before ASE, the path constraints will refine MaxIdx < N and the check above will\
  \ not trigger; no extra work is needed.\n  - If MaxIdx is not available and no evaluable\
  \ loop bound exists, do not warn.\n\nStep C. Optional refinement in check::BranchCondition\
  \ (not required)\n- You do not need to modify program state. This is only for future\
  \ precision if needed:\n  - When seeing a branch condition that compares the index\
  \ with an array size (e.g., i < N or i >= N), the analyzer already records constraints.\
  \ No custom work required; thus, you can skip implementing this callback for the\
  \ first version.\n\n4) Reporting\n- Use a single BugType shared across reports (e.g.,\
  \ static std::unique_ptr<BugType> BT).\n- Create the node with generateNonFatalErrorNode\
  \ and emit a PathSensitiveBugReport.\n- Keep messages short:\n  - Primary: \u201C\
  Index may exceed array size.\u201D\n  - Add concise notes (array size N, max index\
  \ bound, and optionally the macro name if available via ExprHasName).\n\n5) How\
  \ this catches the target patch pattern\n- The loop condition i < __DML_NUM_PLANES__\
  \ gives the analyzer a max i of (__DML_NUM_PLANES__ - 1).\n- The array fields disp_cfg_to_stream_id[]\
  \ and disp_cfg_to_plane_id[] have a smaller compile-time size (e.g., __DML2_WRAPPER_MAX_STREAMS_PLANES__).\n\
  - Without the added guard (i >= __DML2_WRAPPER_MAX_STREAMS_PLANES__), inferSymbolMaxVal\
  \ will yield MaxIdx >= N, and the checker reports.\n- With the guard present (as\
  \ in the fix), path constraints at the array access enforce i < N; thus MaxIdx <\
  \ N and no report is emitted."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include <string>\n#include <sstream>\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// No custom program states are necessary.\n\n\
  namespace {\n\nclass SAGenTestChecker : public Checker<check::Location> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker() : BT(new\
  \ BugType(this, \"Index may exceed array size\", \"Buffer Overflow\")) {}\n\n  \
  \    void checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C)\
  \ const;\n\n   private:\n\n      // Helper: Try to obtain constant array size from\
  \ the base expression of an array subscript.\n      bool getConstantArraySizeFromBase(const\
  \ Expr *Base, llvm::APInt &Size, CheckerContext &C) const;\n\n      // Helper: Obtain\
  \ a maximum possible value for an index expression along the current path.\n   \
  \   // KnownKind: 0 = exact constant; 1 = path-constrained max.\n      bool getIndexMax(const\
  \ Expr *IdxE, CheckerContext &C, llvm::APSInt &MaxIdx, unsigned &KnownKind) const;\n\
  \n      // Helper: If within a for-loop, extract a constant loop upper bound for\
  \ the index variable.\n      bool getLoopUpperBoundIfApplicable(const ArraySubscriptExpr\
  \ *ASE, const Expr *IdxE,\n                                         CheckerContext\
  \ &C, llvm::APSInt &LoopMaxIdx) const;\n\n      void report(const ArraySubscriptExpr\
  \ *ASE, uint64_t ArrSize, uint64_t MaxIdxVal,\n                  CheckerContext\
  \ &C) const;\n};\n\n// Implementation\n\nbool SAGenTestChecker::getConstantArraySizeFromBase(const\
  \ Expr *Base, llvm::APInt &Size,\n                                             \
  \       CheckerContext &C) const {\n  if (!Base)\n    return false;\n\n  const Expr\
  \ *E = Base;\n\n  // If there is an ArrayToPointerDecay, strip it to reach the array-typed\
  \ expr.\n  if (const auto *ICE = dyn_cast<ImplicitCastExpr>(E)) {\n    if (ICE->getCastKind()\
  \ == CK_ArrayToPointerDecay)\n      E = ICE->getSubExpr();\n  }\n\n  // Try direct:\
  \ if expression type is a constant array type.\n  QualType QT = E->getType();\n\
  \  if (!QT.isNull()) {\n    if (const auto *CAT = dyn_cast_or_null<ConstantArrayType>(QT.getTypePtrOrNull()))\
  \ {\n      Size = CAT->getSize();\n      return true;\n    }\n  }\n\n  // Strip\
  \ parens/casts after checking for decay, to find DeclRefExpr/MemberExpr.\n  E =\
  \ E->IgnoreParenCasts();\n\n  // DeclRefExpr (global/local arrays)\n  if (getArraySizeFromExpr(Size,\
  \ E))\n    return true;\n\n  // MemberExpr (array field in struct/union)\n  if (const\
  \ auto *ME = dyn_cast<MemberExpr>(E)) {\n    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl()))\
  \ {\n      QualType FT = FD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(FT.getTypePtr()))\
  \ {\n        Size = CAT->getSize();\n        return true;\n      }\n    }\n  }\n\
  \n  return false;\n}\n\nbool SAGenTestChecker::getIndexMax(const Expr *IdxE, CheckerContext\
  \ &C,\n                                   llvm::APSInt &MaxIdx, unsigned &KnownKind)\
  \ const {\n  if (!IdxE)\n    return false;\n\n  // First: try to evaluate as constant.\n\
  \  llvm::APSInt EvalRes;\n  if (EvaluateExprToInt(EvalRes, IdxE, C)) {\n    MaxIdx\
  \ = EvalRes;\n    KnownKind = 0; // exact\n    return true;\n  }\n\n  // Otherwise,\
  \ try to obtain a symbol and infer maximal value along current path.\n  ProgramStateRef\
  \ State = C.getState();\n  SVal SV = State->getSVal(IdxE, C.getLocationContext());\n\
  \  if (SymbolRef Sym = SV.getAsSymbol()) {\n    if (const llvm::APSInt *maxVal =\
  \ inferSymbolMaxVal(Sym, C)) {\n      MaxIdx = *maxVal;\n      KnownKind = 1; //\
  \ path-constrained max\n      return true;\n    }\n  }\n  return false;\n}\n\nstatic\
  \ const DeclRefExpr *getAsDeclRef(const Expr *E) {\n  if (!E) return nullptr;\n\
  \  return dyn_cast<DeclRefExpr>(E->IgnoreParenCasts());\n}\n\nbool SAGenTestChecker::getLoopUpperBoundIfApplicable(const\
  \ ArraySubscriptExpr *ASE,\n                                                   \
  \  const Expr *IdxE,\n                                                     CheckerContext\
  \ &C,\n                                                     llvm::APSInt &LoopMaxIdx)\
  \ const {\n  if (!ASE || !IdxE)\n    return false;\n\n  const DeclRefExpr *IdxDRE\
  \ = getAsDeclRef(IdxE);\n  if (!IdxDRE)\n    return false;\n\n  const auto *VD =\
  \ dyn_cast<VarDecl>(IdxDRE->getDecl());\n  if (!VD)\n    return false;\n\n  const\
  \ ForStmt *FS = findSpecificTypeInParents<ForStmt>(ASE, C);\n  if (!FS)\n    return\
  \ false;\n\n  const Expr *CondE = FS->getCond();\n  if (!CondE)\n    return false;\n\
  \n  const auto *CondBO = dyn_cast<BinaryOperator>(CondE->IgnoreParenCasts());\n\
  \  if (!CondBO)\n    return false;\n\n  BinaryOperator::Opcode Opc = CondBO->getOpcode();\n\
  \  if (Opc != BO_LT && Opc != BO_LE)\n    return false;\n\n  const Expr *LHS = CondBO->getLHS()->IgnoreParenCasts();\n\
  \  const Expr *RHS = CondBO->getRHS()->IgnoreParenCasts();\n\n  const DeclRefExpr\
  \ *LHSVar = getAsDeclRef(LHS);\n  const DeclRefExpr *RHSVar = getAsDeclRef(RHS);\n\
  \n  const Expr *BoundExpr = nullptr;\n\n  if (LHSVar && LHSVar->getDecl() == VD)\
  \ {\n    BoundExpr = RHS;\n  } else if (RHSVar && RHSVar->getDecl() == VD) {\n \
  \   BoundExpr = LHS;\n  } else {\n    return false;\n  }\n\n  llvm::APSInt UB;\n\
  \  if (!EvaluateExprToInt(UB, BoundExpr, C))\n    return false;\n\n  // Convert\
  \ to an appropriate index maximum (for i < UB, max is UB-1; for i <= UB, max is\
  \ UB).\n  if (Opc == BO_LT) {\n    // UB - 1\n    if (UB == 0) {\n      // i < 0\
  \ is empty, but be conservative.\n      LoopMaxIdx = UB;\n    } else {\n      LoopMaxIdx\
  \ = UB - 1;\n    }\n  } else {\n    LoopMaxIdx = UB;\n  }\n\n  return true;\n}\n\
  \nvoid SAGenTestChecker::report(const ArraySubscriptExpr *ASE, uint64_t ArrSize,\n\
  \                              uint64_t MaxIdxVal, CheckerContext &C) const {\n\
  \  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n\
  \  std::string Msg = \"Index may exceed array size (size=\" + std::to_string(ArrSize)\
  \ +\n                    \", max=\" + std::to_string(MaxIdxVal) + \")\";\n  auto\
  \ R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n\n  // Highlight the\
  \ indexing expression.\n  R->addRange(ASE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\
  \ CheckerContext &C) const {\n  if (!S)\n    return;\n\n  // Try to find an ArraySubscriptExpr\
  \ related to this memory access.\n  const ArraySubscriptExpr *ASE = dyn_cast<ArraySubscriptExpr>(S);\n\
  \  if (!ASE)\n    ASE = findSpecificTypeInChildren<ArraySubscriptExpr>(S);\n  if\
  \ (!ASE)\n    return;\n\n  // Get constant array size from the base expression (compile-time\
  \ known arrays only).\n  llvm::APInt ArraySizeAP;\n  if (!getConstantArraySizeFromBase(ASE->getBase(),\
  \ ArraySizeAP, C))\n    return;\n\n  uint64_t ArrSize = ArraySizeAP.getZExtValue();\n\
  \n  // Analyze the index expression to get a max bound.\n  const Expr *IdxE = ASE->getIdx()->IgnoreParenImpCasts();\n\
  \n  llvm::APSInt MaxIdx;\n  unsigned KnownKind = 2; // unknown\n  if (getIndexMax(IdxE,\
  \ C, MaxIdx, KnownKind)) {\n    // Prepare a comparable APSInt for array size using\
  \ MaxIdx's bitwidth/sign.\n    llvm::APInt ArrSizeAsAPInt(MaxIdx.getBitWidth(),\
  \ ArrSize);\n    llvm::APSInt ArrSizeAPS(ArrSizeAsAPInt, MaxIdx.isUnsigned());\n\
  \n    if (MaxIdx >= ArrSizeAPS) {\n      // Form a reasonable max value for message.\n\
  \      uint64_t MaxIdxVal = MaxIdx.isUnsigned()\n                              \
  \ ? MaxIdx.getZExtValue()\n                               : (MaxIdx.isNegative()\
  \ ? 0ULL\n                                                      : static_cast<uint64_t>(MaxIdx.getSExtValue()));\n\
  \      report(ASE, ArrSize, MaxIdxVal, C);\n    }\n    return; // If we have path-constrained\
  \ info, do not fallback to loop bound.\n  }\n\n  // Fallback: Extract loop upper\
  \ bound if applicable (common pattern i < CONST).\n  llvm::APSInt LoopMaxIdx;\n\
  \  if (getLoopUpperBoundIfApplicable(ASE, IdxE, C, LoopMaxIdx)) {\n    llvm::APInt\
  \ ArrSizeAsAPInt(LoopMaxIdx.getBitWidth(), ArrSize);\n    llvm::APSInt ArrSizeAPS(ArrSizeAsAPInt,\
  \ LoopMaxIdx.isUnsigned());\n    if (LoopMaxIdx >= ArrSizeAPS) {\n      uint64_t\
  \ MaxIdxVal = LoopMaxIdx.isUnsigned()\n                               ? LoopMaxIdx.getZExtValue()\n\
  \                               : (LoopMaxIdx.isNegative() ? 0ULL\n            \
  \                                              : static_cast<uint64_t>(LoopMaxIdx.getSExtValue()));\n\
  \      report(ASE, ArrSize, MaxIdxVal, C);\n    }\n  }\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects array indexing where loop bound constant may exceed the array's\
  \ compile-time size\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
