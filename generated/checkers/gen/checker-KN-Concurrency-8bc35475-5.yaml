_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 8bc35475ef1a23b0e224f3242eb11c76cab0ea88
commit_type: Concurrency
index: 5
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/StringRef.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states are required.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::ASTCodeBody> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Unconditional read\
  \ before guard\", \"Concurrency\")) {}\n\n  void checkASTCodeBody(const Decl *D,\
  \ AnalysisManager &Mgr,\n                        BugReporter &BR) const;\n\nprivate:\n\
  \  // Helpers to scan blocks and statements\n  void scanStmt(const Stmt *S, const\
  \ Decl *D, AnalysisManager &Mgr,\n                BugReporter &BR) const;\n\n  void\
  \ scanCompound(const CompoundStmt *CS, const Decl *D, AnalysisManager &Mgr,\n  \
  \                  BugReporter &BR) const;\n\n  // Helpers to classify statements\n\
  \  static bool getAssignmentFromDeclStmt(const Stmt *S, const VarDecl *&LHSVD,\n\
  \                                        const Expr *&RHS);\n  static bool getAssignmentFromBinOp(const\
  \ Stmt *S, const VarDecl *&LHSVD,\n                                     const Expr\
  \ *&RHS);\n\n  // Pattern recognizers\n  static bool isSuspiciousSharedRead(const\
  \ Expr *RHS, const Expr *&Spot);\n  static bool matchWorkDataBitsCall(const Expr\
  \ *E, const Expr *&Spot);\n  static bool matchWorkArrowData(const Expr *E, const\
  \ Expr *&Spot);\n\n  // Condition analysis\n  static bool condMentionsVar(const\
  \ Expr *Cond, const VarDecl *VD);\n  static bool condMentionsName(const Expr *Cond,\
  \ StringRef Name);\n};\n\nbool SAGenTestChecker::getAssignmentFromDeclStmt(const\
  \ Stmt *S,\n                                                 const VarDecl *&LHSVD,\n\
  \                                                 const Expr *&RHS) {\n  LHSVD =\
  \ nullptr;\n  RHS = nullptr;\n  const auto *DS = dyn_cast<DeclStmt>(S);\n  if (!DS\
  \ || !DS->isSingleDecl())\n    return false;\n\n  const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());\n\
  \  if (!VD)\n    return false;\n\n  if (!VD->hasInit())\n    return false;\n\n \
  \ // Prefer local or function scope vars\n  if (!VD->hasLocalStorage())\n    return\
  \ false;\n\n  LHSVD = VD;\n  RHS = VD->getInit();\n  return true;\n}\n\nbool SAGenTestChecker::getAssignmentFromBinOp(const\
  \ Stmt *S,\n                                              const VarDecl *&LHSVD,\n\
  \                                              const Expr *&RHS) {\n  LHSVD = nullptr;\n\
  \  RHS = nullptr;\n\n  const auto *BO = dyn_cast<BinaryOperator>(S);\n  if (!BO\
  \ || !BO->isAssignmentOp())\n    return false;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \  const auto *DRE = dyn_cast<DeclRefExpr>(LHS);\n  if (!DRE)\n    return false;\n\
  \n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n    return\
  \ false;\n\n  if (!VD->hasLocalStorage())\n    return false;\n\n  LHSVD = VD;\n\
  \  RHS = BO->getRHS();\n  return true;\n}\n\nstatic const FunctionDecl *getDirectCallee(const\
  \ CallExpr *CE) {\n  if (const FunctionDecl *FD = CE->getDirectCallee())\n    return\
  \ FD;\n\n  const Expr *CalleeE = CE->getCallee()->IgnoreParenImpCasts();\n  if (const\
  \ auto *DRE = dyn_cast<DeclRefExpr>(CalleeE))\n    return dyn_cast<FunctionDecl>(DRE->getDecl());\n\
  \  return nullptr;\n}\n\nbool SAGenTestChecker::matchWorkDataBitsCall(const Expr\
  \ *E,\n                                             const Expr *&Spot) {\n  Spot\
  \ = nullptr;\n  const Expr *X = E ? E->IgnoreParenCasts() : nullptr;\n  if (!X)\n\
  \    return false;\n\n  // Allow unary '*' on top of the call\n  if (const auto\
  \ *UO = dyn_cast<UnaryOperator>(X)) {\n    if (UO->getOpcode() == UO_Deref)\n  \
  \    X = UO->getSubExpr()->IgnoreParenImpCasts();\n  }\n\n  const CallExpr *CE =\
  \ dyn_cast<CallExpr>(X);\n  if (!CE) {\n    // Try to locate a CallExpr somewhere\
  \ inside the expression tree\n    CE = findSpecificTypeInChildren<CallExpr>(E);\n\
  \    if (!CE)\n      return false;\n  }\n\n  const FunctionDecl *FD = getDirectCallee(CE);\n\
  \  if (!FD)\n    return false;\n\n  if (FD->getIdentifier() && FD->getName() ==\
  \ \"work_data_bits\") {\n    // Also ensure the first argument is 'work' to be precise\n\
  \    if (CE->getNumArgs() >= 1) {\n      const Expr *Arg0 = CE->getArg(0)->IgnoreParenImpCasts();\n\
  \      if (const auto *DRE = dyn_cast<DeclRefExpr>(Arg0)) {\n        if (const auto\
  \ *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n          if (VD->getName() == \"\
  work\") {\n            Spot = CE;\n            return true;\n          }\n     \
  \   }\n      }\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::matchWorkArrowData(const\
  \ Expr *E, const Expr *&Spot) {\n  Spot = nullptr;\n  const Expr *X = E ? E->IgnoreParenImpCasts()\
  \ : nullptr;\n  if (!X)\n    return false;\n\n  const auto *ME = dyn_cast<MemberExpr>(X);\n\
  \  if (!ME)\n    return false;\n\n  if (!ME->isArrow())\n    return false;\n\n \
  \ const ValueDecl *MD = ME->getMemberDecl();\n  if (!MD || !MD->getIdentifier()\
  \ || MD->getName() != \"data\")\n    return false;\n\n  const Expr *Base = ME->getBase()->IgnoreParenImpCasts();\n\
  \  const auto *DRE = dyn_cast<DeclRefExpr>(Base);\n  if (!DRE)\n    return false;\n\
  \n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n    return\
  \ false;\n\n  if (VD->getName() != \"work\")\n    return false;\n\n  Spot = ME;\n\
  \  return true;\n}\n\nbool SAGenTestChecker::isSuspiciousSharedRead(const Expr *RHS,\n\
  \                                              const Expr *&Spot) {\n  Spot = nullptr;\n\
  \  if (!RHS)\n    return false;\n\n  // Pattern A: *work_data_bits(work)\n  if (matchWorkDataBitsCall(RHS,\
  \ Spot))\n    return true;\n\n  // Pattern B: work->data\n  if (matchWorkArrowData(RHS,\
  \ Spot))\n    return true;\n\n  return false;\n}\n\nstatic bool walkContainsVar(const\
  \ Stmt *S, const VarDecl *VD) {\n  if (!S || !VD)\n    return false;\n\n  for (const\
  \ Stmt *Child : S->children()) {\n    if (!Child)\n      continue;\n    if (const\
  \ auto *DRE = dyn_cast<DeclRefExpr>(Child)) {\n      if (DRE->getDecl() == VD)\n\
  \        return true;\n    }\n    if (walkContainsVar(Child, VD))\n      return\
  \ true;\n  }\n  return false;\n}\n\nstatic bool walkContainsName(const Stmt *S,\
  \ StringRef Name) {\n  if (!S)\n    return false;\n\n  for (const Stmt *Child :\
  \ S->children()) {\n    if (!Child)\n      continue;\n    if (const auto *DRE =\
  \ dyn_cast<DeclRefExpr>(Child)) {\n      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n        if (VD->getName() == Name)\n          return true;\n      }\n    }\n\
  \    if (walkContainsName(Child, Name))\n      return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::condMentionsVar(const Expr *Cond, const VarDecl *VD)\
  \ {\n  return walkContainsVar(Cond, VD);\n}\n\nbool SAGenTestChecker::condMentionsName(const\
  \ Expr *Cond, StringRef Name) {\n  return walkContainsName(Cond, Name);\n}\n\nvoid\
  \ SAGenTestChecker::scanCompound(const CompoundStmt *CS, const Decl *D,\n      \
  \                              AnalysisManager &Mgr,\n                         \
  \           BugReporter &BR) const {\n  if (!CS)\n    return;\n\n  // Examine adjacent\
  \ pairs of statements\n  const AnalysisDeclContext *ADC = Mgr.getAnalysisDeclContext(D);\n\
  \n  auto It = CS->body_begin();\n  auto End = CS->body_end();\n  if (It == End)\n\
  \    return;\n\n  for (; It != End; ++It) {\n    const Stmt *S1 = *It;\n    auto\
  \ It2 = It;\n    ++It2;\n    if (It2 == End)\n      break;\n    const Stmt *S2 =\
  \ *It2;\n\n    const VarDecl *LHSVD = nullptr;\n    const Expr *RHS = nullptr;\n\
  \n    bool IsAssign = getAssignmentFromDeclStmt(S1, LHSVD, RHS) ||\n           \
  \         getAssignmentFromBinOp(S1, LHSVD, RHS);\n\n    if (!IsAssign || !LHSVD\
  \ || !RHS)\n      continue;\n\n    const auto *IfS = dyn_cast<IfStmt>(S2);\n   \
  \ if (!IfS)\n      continue;\n\n    const Expr *Cond = IfS->getCond();\n    if (!Cond)\n\
  \      continue;\n\n    // Check that RHS is the suspicious shared-field read\n\
  \    const Expr *Spot = nullptr;\n    if (!isSuspiciousSharedRead(RHS, Spot))\n\
  \      continue;\n\n    // Check that condition mentions both the guard and the\
  \ assigned variable\n    if (!condMentionsName(Cond, \"from_cancel\"))\n      continue;\n\
  \    if (!condMentionsVar(Cond, LHSVD))\n      continue;\n\n    // Report a bug\n\
  \    if (!Spot)\n      Spot = RHS;\n\n    PathDiagnosticLocation Loc =\n       \
  \ PathDiagnosticLocation::createBegin(Spot, BR.getSourceManager(), ADC);\n\n   \
  \ auto R = std::make_unique<BasicBugReport>(\n        *BT,\n        \"Unconditional\
  \ read of shared field before checking guard; move the \"\n        \"read under\
  \ the 'from_cancel' check.\",\n        Loc, Spot->getSourceRange());\n    BR.emitReport(std::move(R));\n\
  \  }\n\n  // Recurse into children to find nested compound statements\n  for (const\
  \ Stmt *Child : CS->body()) {\n    scanStmt(Child, D, Mgr, BR);\n  }\n}\n\nvoid\
  \ SAGenTestChecker::scanStmt(const Stmt *S, const Decl *D,\n                   \
  \             AnalysisManager &Mgr, BugReporter &BR) const {\n  if (!S)\n    return;\n\
  \n  if (const auto *CS = dyn_cast<CompoundStmt>(S)) {\n    scanCompound(CS, D, Mgr,\
  \ BR);\n    return;\n  }\n\n  // Recurse to find nested compound statements\n  for\
  \ (const Stmt *Child : S->children()) {\n    scanStmt(Child, D, Mgr, BR);\n  }\n\
  }\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager &Mgr,\n\
  \                                        BugReporter &BR) const {\n  const auto\
  \ *FD = dyn_cast<FunctionDecl>(D);\n  if (!FD)\n    return;\n  const Stmt *Body\
  \ = FD->getBody();\n  if (!Body)\n    return;\n\n  scanStmt(Body, D, Mgr, BR);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unconditional read of shared field before guard (e.g., read of\
  \ work->data or *work_data_bits(work) before checking from_cancel)\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nworkqueue: Fix spruious data race in __flush_work()\n\
  \nWhen flushing a work item for cancellation, __flush_work() knows that it\nexclusively\
  \ owns the work item through its PENDING bit. 134874e2eee9\n(\"workqueue: Allow\
  \ cancel_work_sync() and disable_work() from atomic\ncontexts on BH work items\"\
  ) added a read of @work->data to determine whether\nto use busy wait for BH work\
  \ items that are being canceled. While the read\nis safe when @from_cancel, @work->data\
  \ was read before testing @from_cancel\nto simplify code structure:\n\n\tdata =\
  \ *work_data_bits(work);\n\tif (from_cancel &&\n\t    !WARN_ON_ONCE(data & WORK_STRUCT_PWQ)\
  \ && (data & WORK_OFFQ_BH)) {\n\nWhile the read data was never used if !@from_cancel,\
  \ this could trigger\nKCSAN data race detection spuriously:\n\n  ==================================================================\n\
  \  BUG: KCSAN: data-race in __flush_work / __flush_work\n\n  write to 0xffff8881223aa3e8\
  \ of 8 bytes by task 3998 on cpu 0:\n   instrument_write include/linux/instrumented.h:41\
  \ [inline]\n   ___set_bit include/asm-generic/bitops/instrumented-non-atomic.h:28\
  \ [inline]\n   insert_wq_barrier kernel/workqueue.c:3790 [inline]\n   start_flush_work\
  \ kernel/workqueue.c:4142 [inline]\n   __flush_work+0x30b/0x570 kernel/workqueue.c:4178\n\
  \   flush_work kernel/workqueue.c:4229 [inline]\n   ...\n\n  read to 0xffff8881223aa3e8\
  \ of 8 bytes by task 50 on cpu 1:\n   __flush_work+0x42a/0x570 kernel/workqueue.c:4188\n\
  \   flush_work kernel/workqueue.c:4229 [inline]\n   flush_delayed_work+0x66/0x70\
  \ kernel/workqueue.c:4251\n   ...\n\n  value changed: 0x0000000000400000 -> 0xffff88810006c00d\n\
  \nReorganize the code so that @from_cancel is tested before @work->data is\naccessed.\
  \ The only problem is triggering KCSAN detection spuriously. This\nshouldn't need\
  \ READ_ONCE() or other access qualifiers.\n\nNo functional changes.\n\nSigned-off-by:\
  \ Tejun Heo <tj@kernel.org>\nReported-by: syzbot+b3e4f2f51ed645fd5df2@syzkaller.appspotmail.com\n\
  Fixes: 134874e2eee9 (\"workqueue: Allow cancel_work_sync() and disable_work() from\
  \ atomic contexts on BH work items\")\nLink: http://lkml.kernel.org/r/000000000000ae429e061eea2157@google.com\n\
  Cc: Jens Axboe <axboe@kernel.dk>\n\n## Buggy Code\n\n```c\n// Function: __flush_work\
  \ in kernel/workqueue.c\nstatic bool __flush_work(struct work_struct *work, bool\
  \ from_cancel)\n{\n\tstruct wq_barrier barr;\n\tunsigned long data;\n\n\tif (WARN_ON(!wq_online))\n\
  \t\treturn false;\n\n\tif (WARN_ON(!work->func))\n\t\treturn false;\n\n\tif (!start_flush_work(work,\
  \ &barr, from_cancel))\n\t\treturn false;\n\n\t/*\n\t * start_flush_work() returned\
  \ %true. If @from_cancel is set, we know\n\t * that @work must have been executing\
  \ during start_flush_work() and\n\t * can't currently be queued. Its data must contain\
  \ OFFQ bits. If @work\n\t * was queued on a BH workqueue, we also know that it was\
  \ running in the\n\t * BH context and thus can be busy-waited.\n\t */\n\tdata =\
  \ *work_data_bits(work);\n\tif (from_cancel &&\n\t    !WARN_ON_ONCE(data & WORK_STRUCT_PWQ)\
  \ && (data & WORK_OFFQ_BH)) {\n\t\t/*\n\t\t * On RT, prevent a live lock when %current\
  \ preempted soft\n\t\t * interrupt processing or prevents ksoftirqd from running\
  \ by\n\t\t * keeping flipping BH. If the BH work item runs on a different\n\t\t\
  \ * CPU then this has no effect other than doing the BH\n\t\t * disable/enable dance\
  \ for nothing. This is copied from\n\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  \t\t */\n\t\twhile (!try_wait_for_completion(&barr.done)) {\n\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tlocal_bh_enable();\n\t\t\t} else {\n\t\
  \t\t\tcpu_relax();\n\t\t\t}\n\t\t}\n\t} else {\n\t\twait_for_completion(&barr.done);\n\
  \t}\n\n\tdestroy_work_on_stack(&barr.work);\n\treturn true;\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/kernel/workqueue.c b/kernel/workqueue.c\nindex\
  \ d56bd2277e58..ef174d8c1f63 100644\n--- a/kernel/workqueue.c\n+++ b/kernel/workqueue.c\n\
  @@ -4166,7 +4166,6 @@ static bool start_flush_work(struct work_struct *work, struct\
  \ wq_barrier *barr,\n static bool __flush_work(struct work_struct *work, bool from_cancel)\n\
  \ {\n \tstruct wq_barrier barr;\n-\tunsigned long data;\n \n \tif (WARN_ON(!wq_online))\n\
  \ \t\treturn false;\n@@ -4184,29 +4183,35 @@ static bool __flush_work(struct work_struct\
  \ *work, bool from_cancel)\n \t * was queued on a BH workqueue, we also know that\
  \ it was running in the\n \t * BH context and thus can be busy-waited.\n \t */\n\
  -\tdata = *work_data_bits(work);\n-\tif (from_cancel &&\n-\t    !WARN_ON_ONCE(data\
  \ & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_BH)) {\n-\t\t/*\n-\t\t * On RT, prevent\
  \ a live lock when %current preempted soft\n-\t\t * interrupt processing or prevents\
  \ ksoftirqd from running by\n-\t\t * keeping flipping BH. If the BH work item runs\
  \ on a different\n-\t\t * CPU then this has no effect other than doing the BH\n\
  -\t\t * disable/enable dance for nothing. This is copied from\n-\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  -\t\t */\n-\t\twhile (!try_wait_for_completion(&barr.done)) {\n-\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n-\t\t\t\tlocal_bh_disable();\n-\t\t\t\tlocal_bh_enable();\n-\t\t\t} else {\n\
  -\t\t\t\tcpu_relax();\n+\tif (from_cancel) {\n+\t\tunsigned long data = *work_data_bits(work);\n\
  +\n+\t\tif (!WARN_ON_ONCE(data & WORK_STRUCT_PWQ) &&\n+\t\t    (data & WORK_OFFQ_BH))\
  \ {\n+\t\t\t/*\n+\t\t\t * On RT, prevent a live lock when %current preempted\n+\t\
  \t\t * soft interrupt processing or prevents ksoftirqd from\n+\t\t\t * running by\
  \ keeping flipping BH. If the BH work item\n+\t\t\t * runs on a different CPU then\
  \ this has no effect other\n+\t\t\t * than doing the BH disable/enable dance for\
  \ nothing.\n+\t\t\t * This is copied from\n+\t\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  +\t\t\t */\n+\t\t\twhile (!try_wait_for_completion(&barr.done)) {\n+\t\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n+\t\t\t\t\tlocal_bh_disable();\n+\t\t\t\t\tlocal_bh_enable();\n+\t\t\t\t} else\
  \ {\n+\t\t\t\t\tcpu_relax();\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tgoto out_destroy;\n \t\
  \t}\n-\t} else {\n-\t\twait_for_completion(&barr.done);\n \t}\n \n+\twait_for_completion(&barr.done);\n\
  +\n+out_destroy:\n \tdestroy_work_on_stack(&barr.work);\n \treturn true;\n }\n```\n"
pattern: "## Bug Pattern\n\nSpeculative/unconditional read of a shared, concurrently\
  \ modified field before checking the guard that guarantees safe access. In __flush_work(),\
  \ work->data was read unconditionally:\n\n  data = *work_data_bits(work);\n  if\
  \ (from_cancel && ...) { ... }\n\nEven though the value is only relevant when from_cancel\
  \ is true, performing the read outside that guard accesses a racy field without\
  \ established ownership, triggering KCSAN data-race reports. The correct pattern\
  \ is to first check the condition that ensures exclusive access (from_cancel) and\
  \ only then read the shared field."
plan: "1) Program state\n- No custom program state is needed. This checker can be\
  \ implemented with a simple AST pattern match over adjacent statements.\n\n2) Callbacks\n\
  - Implement only checkASTCodeBody. Perform a lightweight, per-function AST scan\
  \ to find the \u201Cunconditional read before guard\u201D pattern.\n\n3) Detailed\
  \ steps\n\nA. High-level detection strategy (inside checkASTCodeBody)\n- For each\
  \ function body, visit all CompoundStmt blocks.\n- Within each CompoundStmt, examine\
  \ adjacent pairs of statements [Si, Si+1].\n- Identify Si as an assignment of a\
  \ local variable from a suspicious shared-field read.\n- Identify Si+1 as an IfStmt\
  \ whose condition tests a guard (from_cancel) and also references the assigned variable.\n\
  - If both conditions hold, report a bug: the field read must be moved under the\
  \ guard.\n\nB. Extract and classify statements (CompoundStmt scan)\n- Iterate each\
  \ CompoundStmt\u2019s children in order:\n  - Recognize assignment in Si:\n    -\
  \ Case 1: DeclStmt with exactly one VarDecl VD with an initializer Init.\n     \
  \ - LHS variable is VD, RHS is Init.\n    - Case 2: BinaryOperator BO with opcode\
  \ BO_Assign.\n      - LHS is BO->getLHS(), RHS is BO->getRHS().\n  - Recognize IfStmt\
  \ in Si+1:\n    - Succeed only if Si+1 is an IfStmt.\n    - Let Cond = IfStmt->getCond().\n\
  \nC. Heuristic to recognize a suspicious shared-field read (isSuspiciousSharedRead)\n\
  - Input: RHS Expr*.\n- Return true if RHS matches either of the following sub-patterns:\n\
  \  - Pattern A: dereference of a function returning pointer to work->data:\n   \
  \ - RHS contains a CallExpr whose callee name contains \u201Cwork_data_bits\u201D\
  .\n      - Implement by:\n        - findSpecificTypeInChildren<CallExpr>(RHS) to\
  \ get the call.\n        - If found, check callee\u2019s identifier name with getNameAsString()\
  \ or ExprHasName(RHS, \"work_data_bits\").\n    - Optionally accept the presence\
  \ of a UnaryOperator \u2018*\u2019 on top; not strictly required.\n  - Pattern B:\
  \ direct field read of work->data:\n    - RHS is a MemberExpr ME with:\n      -\
  \ ME->getMemberDecl()->getNameAsString() == \"data\".\n      - ME->isArrow() is\
  \ true (pointer field access).\n      - Additionally, base expression text contains\
  \ \u201Cwork\u201D to narrow to work_struct:\n        - ExprHasName(ME->getBase(),\
  \ \"work\").\n- Keep the heuristic narrow to reduce false positives: accept only\
  \ if either Pattern A or Pattern B matches.\n\nD. Verify the guard condition uses\
  \ the assigned variable and checks the guard\n- We need the LHS variable declared\
  \ in Si (VD or the DeclRefExpr on LHS of BO). Get its name (LHSName) and region\
  \ if needed.\n- On Si+1\u2019s IfStmt:\n  - Get Cond = IfStmt->getCond()->IgnoreParenImpCasts().\n\
  \  - Check the guard:\n    - Require that Cond contains the name \u201Cfrom_cancel\u201D\
  . Use ExprHasName(Cond, \"from_cancel\").\n  - Check the use of assigned variable:\n\
  \    - Require that Cond contains the LHS variable name: ExprHasName(Cond, LHSName).\n\
  \  - Optionally, further constrain:\n    - If Cond is a BinaryOperator with opcode\
  \ BO_LAnd (logical &&), accept it directly (typical in the buggy pattern). Otherwise,\
  \ still accept if both names appear to catch forms like if (from_cancel) { if (data\
  \ & \u2026) \u2026 } (optional).\n- For simplicity and precision, require the adjacent-statement\
  \ pattern: Si is the assignment, Si+1 is the IfStmt. This matches the kernel pattern\
  \ and avoids noise.\n\nE. Report\n- When a match is found, emit a BasicBugReport\
  \ (or PathSensitiveBugReport if convenient) with:\n  - Short message: \u201CUnconditional\
  \ read of shared field before checking guard; move the read under the \u2018from_cancel\u2019\
  \ check.\u201D\n  - Location: point to the suspicious RHS read expression (the CallExpr\
  \ or MemberExpr), or to the assignment statement Si.\n- Use generateNonFatalErrorNode\
  \ if needed to obtain a bug location node, but since this is an AST-only check in\
  \ checkASTCodeBody, BasicBugReport is sufficient.\n\n4) Utility functions usage\n\
  - findSpecificTypeInChildren<CallExpr>(RHS): to find the underlying call (e.g.,\
  \ work_data_bits).\n- ExprHasName(expr, \"from_cancel\"): to detect the guard occurrence\
  \ in the if condition.\n- ExprHasName(expr, \"work\") and checking MemberExpr name\
  \ \u201Cdata\u201D: to recognize work->data field access.\n- Optionally, ExprHasName(Cond,\
  \ LHSName): to confirm the use of the assigned temporary in the guard condition.\n\
  \n5) Notes and scope control\n- This checker is intentionally narrow:\n  - It only\
  \ warns when the suspicious read is immediately followed by an if that checks \u201C\
  from_cancel\u201D and uses the assigned temporary.\n  - It focuses on work->data\
  \ or work_data_bits(...) to match the kernel pattern and reduce false positives.\n\
  - No alias tracking or path-sensitive state is needed, as we only analyze adjacent\
  \ statements within the same basic block."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/StringRef.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states are required.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::ASTCodeBody> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Unconditional read\
  \ before guard\", \"Concurrency\")) {}\n\n  void checkASTCodeBody(const Decl *D,\
  \ AnalysisManager &Mgr,\n                        BugReporter &BR) const;\n\nprivate:\n\
  \  // Helpers to scan blocks and statements\n  void scanStmt(const Stmt *S, const\
  \ Decl *D, AnalysisManager &Mgr,\n                BugReporter &BR) const;\n\n  void\
  \ scanCompound(const CompoundStmt *CS, const Decl *D, AnalysisManager &Mgr,\n  \
  \                  BugReporter &BR) const;\n\n  // Helpers to classify statements\n\
  \  static bool getAssignmentFromDeclStmt(const Stmt *S, const VarDecl *&LHSVD,\n\
  \                                        const Expr *&RHS);\n  static bool getAssignmentFromBinOp(const\
  \ Stmt *S, const VarDecl *&LHSVD,\n                                     const Expr\
  \ *&RHS);\n\n  // Pattern recognizers\n  static bool isSuspiciousSharedRead(const\
  \ Expr *RHS, const Expr *&Spot);\n  static bool matchWorkDataBitsCall(const Expr\
  \ *E, const Expr *&Spot);\n  static bool matchWorkArrowData(const Expr *E, const\
  \ Expr *&Spot);\n\n  // Condition analysis\n  static bool condMentionsVar(const\
  \ Expr *Cond, const VarDecl *VD);\n  static bool condMentionsName(const Expr *Cond,\
  \ StringRef Name);\n};\n\nbool SAGenTestChecker::getAssignmentFromDeclStmt(const\
  \ Stmt *S,\n                                                 const VarDecl *&LHSVD,\n\
  \                                                 const Expr *&RHS) {\n  LHSVD =\
  \ nullptr;\n  RHS = nullptr;\n  const auto *DS = dyn_cast<DeclStmt>(S);\n  if (!DS\
  \ || !DS->isSingleDecl())\n    return false;\n\n  const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());\n\
  \  if (!VD)\n    return false;\n\n  if (!VD->hasInit())\n    return false;\n\n \
  \ // Prefer local or function scope vars\n  if (!VD->hasLocalStorage())\n    return\
  \ false;\n\n  LHSVD = VD;\n  RHS = VD->getInit();\n  return true;\n}\n\nbool SAGenTestChecker::getAssignmentFromBinOp(const\
  \ Stmt *S,\n                                              const VarDecl *&LHSVD,\n\
  \                                              const Expr *&RHS) {\n  LHSVD = nullptr;\n\
  \  RHS = nullptr;\n\n  const auto *BO = dyn_cast<BinaryOperator>(S);\n  if (!BO\
  \ || !BO->isAssignmentOp())\n    return false;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \  const auto *DRE = dyn_cast<DeclRefExpr>(LHS);\n  if (!DRE)\n    return false;\n\
  \n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n    return\
  \ false;\n\n  if (!VD->hasLocalStorage())\n    return false;\n\n  LHSVD = VD;\n\
  \  RHS = BO->getRHS();\n  return true;\n}\n\nstatic const FunctionDecl *getDirectCallee(const\
  \ CallExpr *CE) {\n  if (const FunctionDecl *FD = CE->getDirectCallee())\n    return\
  \ FD;\n\n  const Expr *CalleeE = CE->getCallee()->IgnoreParenImpCasts();\n  if (const\
  \ auto *DRE = dyn_cast<DeclRefExpr>(CalleeE))\n    return dyn_cast<FunctionDecl>(DRE->getDecl());\n\
  \  return nullptr;\n}\n\nbool SAGenTestChecker::matchWorkDataBitsCall(const Expr\
  \ *E,\n                                             const Expr *&Spot) {\n  Spot\
  \ = nullptr;\n  const Expr *X = E ? E->IgnoreParenCasts() : nullptr;\n  if (!X)\n\
  \    return false;\n\n  // Allow unary '*' on top of the call\n  if (const auto\
  \ *UO = dyn_cast<UnaryOperator>(X)) {\n    if (UO->getOpcode() == UO_Deref)\n  \
  \    X = UO->getSubExpr()->IgnoreParenImpCasts();\n  }\n\n  const CallExpr *CE =\
  \ dyn_cast<CallExpr>(X);\n  if (!CE) {\n    // Try to locate a CallExpr somewhere\
  \ inside the expression tree\n    CE = findSpecificTypeInChildren<CallExpr>(E);\n\
  \    if (!CE)\n      return false;\n  }\n\n  const FunctionDecl *FD = getDirectCallee(CE);\n\
  \  if (!FD)\n    return false;\n\n  if (FD->getIdentifier() && FD->getName() ==\
  \ \"work_data_bits\") {\n    // Also ensure the first argument is 'work' to be precise\n\
  \    if (CE->getNumArgs() >= 1) {\n      const Expr *Arg0 = CE->getArg(0)->IgnoreParenImpCasts();\n\
  \      if (const auto *DRE = dyn_cast<DeclRefExpr>(Arg0)) {\n        if (const auto\
  \ *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n          if (VD->getName() == \"\
  work\") {\n            Spot = CE;\n            return true;\n          }\n     \
  \   }\n      }\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::matchWorkArrowData(const\
  \ Expr *E, const Expr *&Spot) {\n  Spot = nullptr;\n  const Expr *X = E ? E->IgnoreParenImpCasts()\
  \ : nullptr;\n  if (!X)\n    return false;\n\n  const auto *ME = dyn_cast<MemberExpr>(X);\n\
  \  if (!ME)\n    return false;\n\n  if (!ME->isArrow())\n    return false;\n\n \
  \ const ValueDecl *MD = ME->getMemberDecl();\n  if (!MD || !MD->getIdentifier()\
  \ || MD->getName() != \"data\")\n    return false;\n\n  const Expr *Base = ME->getBase()->IgnoreParenImpCasts();\n\
  \  const auto *DRE = dyn_cast<DeclRefExpr>(Base);\n  if (!DRE)\n    return false;\n\
  \n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n    return\
  \ false;\n\n  if (VD->getName() != \"work\")\n    return false;\n\n  Spot = ME;\n\
  \  return true;\n}\n\nbool SAGenTestChecker::isSuspiciousSharedRead(const Expr *RHS,\n\
  \                                              const Expr *&Spot) {\n  Spot = nullptr;\n\
  \  if (!RHS)\n    return false;\n\n  // Pattern A: *work_data_bits(work)\n  if (matchWorkDataBitsCall(RHS,\
  \ Spot))\n    return true;\n\n  // Pattern B: work->data\n  if (matchWorkArrowData(RHS,\
  \ Spot))\n    return true;\n\n  return false;\n}\n\nstatic bool walkContainsVar(const\
  \ Stmt *S, const VarDecl *VD) {\n  if (!S || !VD)\n    return false;\n\n  for (const\
  \ Stmt *Child : S->children()) {\n    if (!Child)\n      continue;\n    if (const\
  \ auto *DRE = dyn_cast<DeclRefExpr>(Child)) {\n      if (DRE->getDecl() == VD)\n\
  \        return true;\n    }\n    if (walkContainsVar(Child, VD))\n      return\
  \ true;\n  }\n  return false;\n}\n\nstatic bool walkContainsName(const Stmt *S,\
  \ StringRef Name) {\n  if (!S)\n    return false;\n\n  for (const Stmt *Child :\
  \ S->children()) {\n    if (!Child)\n      continue;\n    if (const auto *DRE =\
  \ dyn_cast<DeclRefExpr>(Child)) {\n      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n        if (VD->getName() == Name)\n          return true;\n      }\n    }\n\
  \    if (walkContainsName(Child, Name))\n      return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::condMentionsVar(const Expr *Cond, const VarDecl *VD)\
  \ {\n  return walkContainsVar(Cond, VD);\n}\n\nbool SAGenTestChecker::condMentionsName(const\
  \ Expr *Cond, StringRef Name) {\n  return walkContainsName(Cond, Name);\n}\n\nvoid\
  \ SAGenTestChecker::scanCompound(const CompoundStmt *CS, const Decl *D,\n      \
  \                              AnalysisManager &Mgr,\n                         \
  \           BugReporter &BR) const {\n  if (!CS)\n    return;\n\n  // Examine adjacent\
  \ pairs of statements\n  AnalysisDeclContext *ADC = Mgr.getAnalysisDeclContext(D);\n\
  \n  auto It = CS->body_begin();\n  auto End = CS->body_end();\n  if (It == End)\n\
  \    return;\n\n  for (; It != End; ++It) {\n    const Stmt *S1 = *It;\n    auto\
  \ It2 = It;\n    ++It2;\n    if (It2 == End)\n      break;\n    const Stmt *S2 =\
  \ *It2;\n\n    const VarDecl *LHSVD = nullptr;\n    const Expr *RHS = nullptr;\n\
  \n    bool IsAssign = getAssignmentFromDeclStmt(S1, LHSVD, RHS) ||\n           \
  \         getAssignmentFromBinOp(S1, LHSVD, RHS);\n\n    if (!IsAssign || !LHSVD\
  \ || !RHS)\n      continue;\n\n    const auto *IfS = dyn_cast<IfStmt>(S2);\n   \
  \ if (!IfS)\n      continue;\n\n    const Expr *Cond = IfS->getCond();\n    if (!Cond)\n\
  \      continue;\n\n    // Check that RHS is the suspicious shared-field read\n\
  \    const Expr *Spot = nullptr;\n    if (!isSuspiciousSharedRead(RHS, Spot))\n\
  \      continue;\n\n    // Check that condition mentions both the guard and the\
  \ assigned variable\n    if (!condMentionsName(Cond, \"from_cancel\"))\n      continue;\n\
  \    if (!condMentionsVar(Cond, LHSVD))\n      continue;\n\n    // Report a bug\n\
  \    if (!Spot)\n      Spot = RHS;\n\n    PathDiagnosticLocation Loc =\n       \
  \ PathDiagnosticLocation::createBegin(Spot, BR.getSourceManager(), ADC);\n\n   \
  \ auto R = std::make_unique<BasicBugReport>(\n        *BT,\n        \"Unconditional\
  \ read of shared field before checking guard; move the \"\n        \"read under\
  \ the 'from_cancel' check.\",\n        Loc);\n    BR.emitReport(std::move(R));\n\
  \  }\n\n  // Recurse into children to find nested compound statements\n  for (const\
  \ Stmt *Child : CS->body()) {\n    scanStmt(Child, D, Mgr, BR);\n  }\n}\n\nvoid\
  \ SAGenTestChecker::scanStmt(const Stmt *S, const Decl *D,\n                   \
  \             AnalysisManager &Mgr, BugReporter &BR) const {\n  if (!S)\n    return;\n\
  \n  if (const auto *CS = dyn_cast<CompoundStmt>(S)) {\n    scanCompound(CS, D, Mgr,\
  \ BR);\n    return;\n  }\n\n  // Recurse to find nested compound statements\n  for\
  \ (const Stmt *Child : S->children()) {\n    scanStmt(Child, D, Mgr, BR);\n  }\n\
  }\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager &Mgr,\n\
  \                                        BugReporter &BR) const {\n  const auto\
  \ *FD = dyn_cast<FunctionDecl>(D);\n  if (!FD)\n    return;\n  const Stmt *Body\
  \ = FD->getBody();\n  if (!Body)\n    return;\n\n  scanStmt(Body, D, Mgr, BR);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unconditional read of shared field before guard (e.g., read of\
  \ work->data or *work_data_bits(work) before checking from_cancel)\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
