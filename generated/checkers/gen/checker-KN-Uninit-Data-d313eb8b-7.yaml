_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: d313eb8b77557a6d5855f42d2234bd592c7b50dd
commit_type: Uninit-Data
index: 7
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"\
  clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program states\nREGISTER_MAP_WITH_PROGRAMSTATE(PartiallyInitAgg, const VarDecl*,\
  \ char)\nREGISTER_SET_WITH_PROGRAMSTATE(ZeroCleared, const VarDecl*)\n\nnamespace\
  \ {\n\nclass SAGenTestChecker : public Checker<\n    check::PostStmt<DeclStmt>,\n\
  \    check::PostCall,\n    check::PreCall> {\n\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Kernel info\
  \ leak\", \"Security\")) {}\n\n      void checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C) const;\n      void checkPostCall(const CallEvent &Call, CheckerContext &C)\
  \ const;\n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \n   private:\n      // Helpers\n      static const VarDecl *getLocalStructVarFromAddrArg(const\
  \ Expr *ArgE);\n      static bool isZeroBraceInit(const InitListExpr *ILE);\n  \
  \    static bool isNonZeroingInitList(const InitListExpr *ILE);\n      static bool\
  \ sizeofCoversVar(const VarDecl *VD, const Expr *LenExpr, CheckerContext &C);\n\
  \      static bool isNetlinkExportCall(const CallEvent &Call, unsigned &LenIdx,\
  \ unsigned &DataIdx, CheckerContext &C);\n\n      enum ZeroKind { ZK_None = 0, ZK_Memset,\
  \ ZK_MemzeroExplicit, ZK_Bzero };\n      static ZeroKind getZeroingKind(const CallEvent\
  \ &Call, unsigned &PtrIdx, unsigned &LenIdx, CheckerContext &C);\n\n      void markZeroCleared(ProgramStateRef\
  \ &State, const VarDecl *VD) const;\n      void markPartiallyInit(ProgramStateRef\
  \ &State, const VarDecl *VD) const;\n\n      void reportLeak(const CallEvent &Call,\
  \ CheckerContext &C) const;\n};\n\n/************ Helper Implementations ************/\n\
  \nconst VarDecl *SAGenTestChecker::getLocalStructVarFromAddrArg(const Expr *ArgE)\
  \ {\n  if (!ArgE) return nullptr;\n  const Expr *E = ArgE->IgnoreParenImpCasts();\n\
  \  const auto *UO = dyn_cast<UnaryOperator>(E);\n  if (!UO || UO->getOpcode() !=\
  \ UO_AddrOf)\n    return nullptr;\n\n  const Expr *Sub = UO->getSubExpr()->IgnoreParenImpCasts();\n\
  \  const auto *DRE = dyn_cast<DeclRefExpr>(Sub);\n  if (!DRE)\n    return nullptr;\n\
  \n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n    return\
  \ nullptr;\n\n  if (!VD->hasLocalStorage())\n    return nullptr;\n\n  if (!VD->getType()->isRecordType())\n\
  \    return nullptr;\n\n  return VD;\n}\n\nbool SAGenTestChecker::isZeroBraceInit(const\
  \ InitListExpr *ILE) {\n  if (!ILE) return false;\n\n  // \"{}\"\n  if (ILE->getNumInits()\
  \ == 0)\n    return true;\n\n  if (ILE->getNumInits() == 1) {\n    const Expr *Init\
  \ = ILE->getInit(0);\n    if (!Init) return false;\n\n    // Any designated initializer\
  \ is considered non-zeroing\n    if (isa<DesignatedInitExpr>(Init))\n      return\
  \ false;\n\n    const Expr *E = Init->IgnoreParenImpCasts();\n    if (const auto\
  \ *IL = dyn_cast<IntegerLiteral>(E)) {\n      if (IL->getValue() == 0)\n       \
  \ return true;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isNonZeroingInitList(const\
  \ InitListExpr *ILE) {\n  if (!ILE) return false;\n  if (isZeroBraceInit(ILE))\n\
  \    return false;\n  return true;\n}\n\nbool SAGenTestChecker::sizeofCoversVar(const\
  \ VarDecl *VD, const Expr *LenExpr, CheckerContext &C) {\n  if (!VD || !LenExpr)\n\
  \    return false;\n\n  // First attempt: constant evaluation\n  llvm::APSInt Res;\n\
  \  if (EvaluateExprToInt(Res, LenExpr, C)) {\n    uint64_t LenVal = Res.isSigned()\
  \ ? (uint64_t)Res.getSExtValue() : Res.getZExtValue();\n    uint64_t VarSize = C.getASTContext().getTypeSizeInChars(VD->getType()).getQuantity();\n\
  \    return LenVal >= VarSize;\n  }\n\n  // Fallback: textual containment of variable\
  \ name (captures sizeof(var) pattern)\n  return ExprHasName(LenExpr, VD->getName(),\
  \ C);\n}\n\nbool SAGenTestChecker::isNetlinkExportCall(const CallEvent &Call, unsigned\
  \ &LenIdx, unsigned &DataIdx, CheckerContext &C) {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n\n  // Explicitly match known netlink export\
  \ helpers we care about\n  if (ExprHasName(OriginExpr, \"nla_put_64bit\", C)) {\n\
  \    // nla_put_64bit(skb, attrtype, len, data, padtype)\n    if (Call.getNumArgs()\
  \ >= 4) {\n      LenIdx = 2;\n      DataIdx = 3;\n      return true;\n    }\n  \
  \  return false;\n  }\n  if (ExprHasName(OriginExpr, \"nla_put\", C)) {\n    //\
  \ nla_put(skb, attrtype, len, data)\n    if (Call.getNumArgs() >= 4) {\n      LenIdx\
  \ = 2;\n      DataIdx = 3;\n      return true;\n    }\n    return false;\n  }\n\n\
  \  return false;\n}\n\nSAGenTestChecker::ZeroKind SAGenTestChecker::getZeroingKind(const\
  \ CallEvent &Call, unsigned &PtrIdx, unsigned &LenIdx, CheckerContext &C) {\n  const\
  \ Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n    return ZK_None;\n\
  \n  // memset(ptr, 0, len)\n  if (ExprHasName(OriginExpr, \"memset\", C)) {\n  \
  \  if (Call.getNumArgs() >= 3) {\n      PtrIdx = 0;\n      LenIdx = 2;\n      return\
  \ ZK_Memset;\n    }\n    return ZK_None;\n  }\n\n  // memzero_explicit(ptr, len)\n\
  \  if (ExprHasName(OriginExpr, \"memzero_explicit\", C)) {\n    if (Call.getNumArgs()\
  \ >= 2) {\n      PtrIdx = 0;\n      LenIdx = 1;\n      return ZK_MemzeroExplicit;\n\
  \    }\n    return ZK_None;\n  }\n\n  // bzero(ptr, len)\n  if (ExprHasName(OriginExpr,\
  \ \"bzero\", C)) {\n    if (Call.getNumArgs() >= 2) {\n      PtrIdx = 0;\n     \
  \ LenIdx = 1;\n      return ZK_Bzero;\n    }\n    return ZK_None;\n  }\n\n  return\
  \ ZK_None;\n}\n\nvoid SAGenTestChecker::markZeroCleared(ProgramStateRef &State,\
  \ const VarDecl *VD) const {\n  if (!VD) return;\n  State = State->add<ZeroCleared>(VD);\n\
  \  State = State->remove<PartiallyInitAgg>(VD);\n}\n\nvoid SAGenTestChecker::markPartiallyInit(ProgramStateRef\
  \ &State, const VarDecl *VD) const {\n  if (!VD) return;\n  State = State->set<PartiallyInitAgg>(VD,\
  \ 1);\n}\n\n/************ Checker Callbacks ************/\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  if (!DS) return;\n  ProgramStateRef\
  \ State = C.getState();\n  bool Changed = false;\n\n  for (const Decl *D : DS->decls())\
  \ {\n    const auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      continue;\n\
  \n    if (!VD->hasLocalStorage())\n      continue;\n\n    if (!VD->getType()->isRecordType())\n\
  \      continue;\n\n    if (!VD->hasInit())\n      continue;\n\n    const Expr *Init\
  \ = VD->getInit();\n    if (!Init)\n      continue;\n\n    const Expr *I = Init->IgnoreImplicit();\n\
  \    const auto *ILE = dyn_cast<InitListExpr>(I);\n    if (!ILE)\n      continue;\n\
  \n    if (isNonZeroingInitList(ILE)) {\n      ProgramStateRef NewState = State->set<PartiallyInitAgg>(VD,\
  \ 1);\n      if (NewState != State) {\n        State = NewState;\n        Changed\
  \ = true;\n      }\n    } else {\n      // Zero brace init like {} or {0} considered\
  \ cleared\n      ProgramStateRef NewState = State->add<ZeroCleared>(VD);\n     \
  \ if (NewState != State) {\n        State = NewState;\n        Changed = true;\n\
  \      }\n    }\n  }\n\n  if (Changed)\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  unsigned PtrIdx = 0, LenIdx = 0;\n  ZeroKind ZK = getZeroingKind(Call, PtrIdx,\
  \ LenIdx, C);\n  if (ZK == ZK_None)\n    return;\n\n  // Identify the variable being\
  \ cleared\n  const Expr *PtrE = Call.getArgExpr(PtrIdx);\n  const Expr *LenE = Call.getArgExpr(LenIdx);\n\
  \  const VarDecl *VD = getLocalStructVarFromAddrArg(PtrE);\n  if (!VD)\n    return;\n\
  \n  // For memset, the \"value\" argument must be zero\n  if (ZK == ZK_Memset) {\n\
  \    const Expr *ValE = Call.getArgExpr(1);\n    llvm::APSInt V;\n    if (!ValE\
  \ || !EvaluateExprToInt(V, ValE, C) || V != 0)\n      return;\n  }\n\n  // Ensure\
  \ len covers the entire variable\n  if (!sizeofCoversVar(VD, LenE, C))\n    return;\n\
  \n  // Mark as zero-cleared and remove partial-init flag\n  State = State->add<ZeroCleared>(VD);\n\
  \  State = State->remove<PartiallyInitAgg>(VD);\n  C.addTransition(State);\n}\n\n\
  void SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  unsigned LenIdx = 0, DataIdx = 0;\n  if (!isNetlinkExportCall(Call, LenIdx,\
  \ DataIdx, C))\n    return;\n\n  const Expr *DataE = Call.getArgExpr(DataIdx);\n\
  \  const Expr *LenE = Call.getArgExpr(LenIdx);\n  const VarDecl *VD = getLocalStructVarFromAddrArg(DataE);\n\
  \  if (!VD)\n    return;\n\n  if (!sizeofCoversVar(VD, LenE, C))\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n\n  // If explicitly zero-cleared, it's\
  \ safe\n  if (State->contains<ZeroCleared>(VD))\n    return;\n\n  // Warn only if\
  \ we have evidence of risky partial init via init-list\n  if (!State->lookup<PartiallyInitAgg>(VD))\n\
  \    return;\n\n  reportLeak(Call, C);\n}\n\nvoid SAGenTestChecker::reportLeak(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Copying partially initialized struct with padding to user; zero-initialize\
  \ before export\", N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects exporting partially initialized padded structs without zeroing\
  \ (kernel info leak)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/sched: act_skbmod: prevent kernel-infoleak\n\n\
  syzbot found that tcf_skbmod_dump() was copying four bytes\nfrom kernel stack to\
  \ user space [1].\n\nThe issue here is that 'struct tc_skbmod' has a four bytes\
  \ hole.\n\nWe need to clear the structure before filling fields.\n\n[1]\nBUG: KMSAN:\
  \ kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in copy_to_user_iter lib/iov_iter.c:24 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_and_advance2 include/linux/iov_iter.h:245\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in iterate_and_advance include/linux/iov_iter.h:271\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n  copy_to_user_iter\
  \ lib/iov_iter.c:24 [inline]\n  iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \  iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\n  iterate_and_advance\
  \ include/linux/iov_iter.h:271 [inline]\n  _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  copy_to_iter include/linux/uio.h:196 [inline]\n  simple_copy_to_iter net/core/datagram.c:532\
  \ [inline]\n  __skb_datagram_iter+0x185/0x1000 net/core/datagram.c:420\n  skb_copy_datagram_iter+0x5c/0x200\
  \ net/core/datagram.c:546\n  skb_copy_datagram_msg include/linux/skbuff.h:4050 [inline]\n\
  \  netlink_recvmsg+0x432/0x1610 net/netlink/af_netlink.c:1962\n  sock_recvmsg_nosec\
  \ net/socket.c:1046 [inline]\n  sock_recvmsg+0x2c4/0x340 net/socket.c:1068\n  __sys_recvfrom+0x35a/0x5f0\
  \ net/socket.c:2242\n  __do_sys_recvfrom net/socket.c:2260 [inline]\n  __se_sys_recvfrom\
  \ net/socket.c:2256 [inline]\n  __x64_sys_recvfrom+0x126/0x1d0 net/socket.c:2256\n\
  \ do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nUninit\
  \ was stored to memory at:\n  pskb_expand_head+0x30f/0x19d0 net/core/skbuff.c:2253\n\
  \  netlink_trim+0x2c2/0x330 net/netlink/af_netlink.c:1317\n  netlink_unicast+0x9f/0x1260\
  \ net/netlink/af_netlink.c:1351\n  nlmsg_unicast include/net/netlink.h:1144 [inline]\n\
  \  nlmsg_notify+0x21d/0x2f0 net/netlink/af_netlink.c:2610\n  rtnetlink_send+0x73/0x90\
  \ net/core/rtnetlink.c:741\n  rtnetlink_maybe_send include/linux/rtnetlink.h:17\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2048 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x146e/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nUninit was stored to memory at:\n  __nla_put lib/nlattr.c:1041 [inline]\n  nla_put+0x1c6/0x230\
  \ lib/nlattr.c:1099\n  tcf_skbmod_dump+0x23f/0xc20 net/sched/act_skbmod.c:256\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n  tcf_action_dump+0x1fd/0x460 net/sched/act_api.c:1251\n\
  \  tca_get_fill+0x519/0x7a0 net/sched/act_api.c:1628\n  tcf_add_notify_msg net/sched/act_api.c:2023\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2042 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x1365/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nLocal variable opt created at:\n  tcf_skbmod_dump+0x9d/0xc20 net/sched/act_skbmod.c:244\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n\nBytes 188-191 of 248 are uninitialized\nMemory access\
  \ of size 248 starts at ffff888117697680\nData copied to user address 00007ffe56d855f0\n\
  \nFixes: 86da71b57383 (\"net_sched: Introduce skbmod action\")\nSigned-off-by: Eric\
  \ Dumazet <edumazet@google.com>\nAcked-by: Jamal Hadi Salim <jhs@mojatatu.com>\n\
  Link: https://lore.kernel.org/r/20240403130908.93421-1-edumazet@google.com\nSigned-off-by:\
  \ Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: tcf_skbmod_dump\
  \ in net/sched/act_skbmod.c\nstatic int tcf_skbmod_dump(struct sk_buff *skb, struct\
  \ tc_action *a,\n\t\t\t   int bind, int ref)\n{\n\tstruct tcf_skbmod *d = to_skbmod(a);\n\
  \tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_skbmod_params  *p;\n\t\
  struct tc_skbmod opt = {\n\t\t.index   = d->tcf_index,\n\t\t.refcnt  = refcount_read(&d->tcf_refcnt)\
  \ - ref,\n\t\t.bindcnt = atomic_read(&d->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t\
  \ t;\n\n\tspin_lock_bh(&d->tcf_lock);\n\topt.action = d->tcf_action;\n\tp = rcu_dereference_protected(d->skbmod_p,\n\
  \t\t\t\t      lockdep_is_held(&d->tcf_lock));\n\topt.flags  = p->flags;\n\tif (nla_put(skb,\
  \ TCA_SKBMOD_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_DMAC) &&\n\t    nla_put(skb, TCA_SKBMOD_DMAC, ETH_ALEN, p->eth_dst))\n\
  \t\tgoto nla_put_failure;\n\tif ((p->flags & SKBMOD_F_SMAC) &&\n\t    nla_put(skb,\
  \ TCA_SKBMOD_SMAC, ETH_ALEN, p->eth_src))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_ETYPE) &&\n\t    nla_put_u16(skb, TCA_SKBMOD_ETYPE, ntohs(p->eth_type)))\n\
  \t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &d->tcf_tm);\n\tif (nla_put_64bit(skb,\
  \ TCA_SKBMOD_TM, sizeof(t), &t, TCA_SKBMOD_PAD))\n\t\tgoto nla_put_failure;\n\n\t\
  spin_unlock_bh(&d->tcf_lock);\n\treturn skb->len;\nnla_put_failure:\n\tspin_unlock_bh(&d->tcf_lock);\n\
  \tnlmsg_trim(skb, b);\n\treturn -1;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff\
  \ --git a/net/sched/act_skbmod.c b/net/sched/act_skbmod.c\nindex 39945b139c48..cd0accaf844a\
  \ 100644\n--- a/net/sched/act_skbmod.c\n+++ b/net/sched/act_skbmod.c\n@@ -241,13\
  \ +241,13 @@ static int tcf_skbmod_dump(struct sk_buff *skb, struct tc_action *a,\n\
  \ \tstruct tcf_skbmod *d = to_skbmod(a);\n \tunsigned char *b = skb_tail_pointer(skb);\n\
  \ \tstruct tcf_skbmod_params  *p;\n-\tstruct tc_skbmod opt = {\n-\t\t.index   =\
  \ d->tcf_index,\n-\t\t.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n-\t\t.bindcnt\
  \ = atomic_read(&d->tcf_bindcnt) - bind,\n-\t};\n+\tstruct tc_skbmod opt;\n \tstruct\
  \ tcf_t t;\n \n+\tmemset(&opt, 0, sizeof(opt));\n+\topt.index   = d->tcf_index;\n\
  +\topt.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n+\topt.bindcnt = atomic_read(&d->tcf_bindcnt)\
  \ - bind;\n \tspin_lock_bh(&d->tcf_lock);\n \topt.action = d->tcf_action;\n \tp\
  \ = rcu_dereference_protected(d->skbmod_p,\n```\n"
pattern: '## Bug Pattern


  Copying a stack-allocated struct with implicit padding/holes to user space (e.g.,
  via nla_put(..., sizeof(struct), &obj)) after only partially initializing its fields.
  The uninitialized padding bytes leak kernel stack data. Root cause: not zero-initializing
  a padded struct before exporting it.'
plan: "1) Program State\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(PartiallyInitAgg, const\
  \ VarDecl*, char)\n  - Tracks local struct variables declared with a non-zeroing\
  \ initializer list (designated or with non-zero elements). Presence in this map\
  \ means \u201Cpartially initialized aggregate that may contain uninitialized padding.\u201D\
  \n\n- REGISTER_SET_WITH_PROGRAMSTATE(ZeroCleared, const VarDecl*)\n  - Tracks local\
  \ struct variables that have been explicitly zeroed (e.g., memset(&v, 0, sizeof(v))\
  \ or memzero_explicit(&v, sizeof(v))). Presence means safe to export (padding cleared).\n\
  \n\n2) Helper Predicates / Utilities\n\n- isNetlinkExportCall(const CallEvent &Call,\
  \ unsigned &LenArgIdx, unsigned &DataArgIdx)\n  - Return true if callee is one of:\n\
  \    - nla_put: LenArgIdx = 2, DataArgIdx = 3\n    - nla_put_64bit: LenArgIdx =\
  \ 2, DataArgIdx = 3\n  - Keep the list minimal and explicit to reduce false positives.\n\
  \n- isExplicitZeroingCall(const CallEvent &Call)\n  - Return an enum/bitmask:\n\
  \    - 1: memset(ptr, 0, len) where second arg is zero and len fully covers the\
  \ variable.\n    - 2: memzero_explicit(ptr, len) where len fully covers the variable.\n\
  \    - 3: bzero(ptr, len) where len fully covers the variable.\n  - Otherwise return\
  \ 0.\n\n- getLocalStructVarFromAddrArg(const Expr *ArgE) -> const VarDecl*\n  -\
  \ Strip casts and parens. If it is UnaryOperator(UO_AddrOf) of a DeclRefExpr to\
  \ a local VarDecl of RecordType, return that VarDecl*, else nullptr.\n\n- sizeofCoversVar(const\
  \ VarDecl *VD, const Expr *LenExpr, CheckerContext &C) -> bool\n  - Try EvaluateExprToInt\
  \ on LenExpr. If success, compare to C.getASTContext().getTypeSizeInChars(VD->getType()).getQuantity();\
  \ accept if Len >= sizeof(var).\n  - If evaluation fails, fallback to ExprHasName(LenExpr,\
  \ VD->getName()) to catch sizeof(var) textual patterns.\n  - Return true only if\
  \ you\u2019re reasonably certain Len equals (or exceeds) the size of the variable.\n\
  \n- isZeroBraceInit(const InitListExpr *ILE) -> bool\n  - Return true if:\n    -\
  \ ILE->getNumInits() == 0 (i.e., \u201C= {}\u201D), or\n    - ILE->getNumInits()\
  \ == 1 and that single init is IntegerLiteral(0) without designators (i.e., \u201C\
  = {0}\u201D).\n  - Else false.\n\n- isNonZeroingInitList(const InitListExpr *ILE)\
  \ -> bool\n  - Return true if not isZeroBraceInit(ILE). Also treat any designated\
  \ initializer as non-zeroing.\n\n\n3) Callbacks and Logic\n\nA) checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C)\n- Purpose: Identify local struct variables that\
  \ are \u201Cpartially initialized aggregates.\u201D\n- For each Decl in DS:\n  -\
  \ If auto VD = dyn_cast<VarDecl>(Decl):\n    - Require VD->hasLocalStorage() and\
  \ VD->getType()->isRecordType().\n    - If VD->hasInit():\n      - If the init (IgnoreImplicit)\
  \ is an InitListExpr:\n        - If isNonZeroingInitList(ILE):\n          - State\
  \ = State->set<PartiallyInitAgg>(VD, 1).\n        - Else (zero-brace init like \u201C\
  = {}\u201D or \u201C= {0}\u201D):\n          - Consider these as fully cleared.\
  \ State = State->add<ZeroCleared>(VD).\n      - Else: do nothing here (we only flag\
  \ init-list patterns in this step).\n    - If no initializer: do nothing here (we\
  \ will only warn when exported and not ZeroCleared).\n\nRationale: We specifically\
  \ capture the patch pattern: designated/partial init which doesn\u2019t clear padding.\n\
  \nB) checkPostCall(const CallEvent &Call, CheckerContext &C)\n- Purpose: Mark variables\
  \ explicitly zero-cleared by known APIs.\n- If isExplicitZeroingCall(Call):\n  -\
  \ Extract the pointer argument (Arg0 for memset, Arg0 for memzero_explicit, Arg0\
  \ for bzero).\n  - VD = getLocalStructVarFromAddrArg(Arg0 Expr). If null, return.\n\
  \  - Ensure sizeofCoversVar(VD, LenExpr, C) is true (for memset, also ensure second\
  \ argument is const zero via EvaluateExprToInt).\n  - State = State->add<ZeroCleared>(VD)\n\
  \  - Optionally: State = State->remove<PartiallyInitAgg>(VD) to reflect it is now\
  \ safe.\n\nNotes:\n- memset(ptr, 0, len): check Arg1 == 0 and Arg2 covers size.\n\
  - memzero_explicit(ptr, len): check Arg1 covers size.\n- bzero(ptr, len): check\
  \ Arg1 covers size.\n\nC) checkPreCall(const CallEvent &Call, CheckerContext &C)\n\
  - Purpose: Detect export of a non-zeroed, padded local struct.\n- unsigned LenIdx,\
  \ DataIdx;\n- If !isNetlinkExportCall(Call, LenIdx, DataIdx) return.\n- Extract\
  \ DataVar:\n  - VD = getLocalStructVarFromAddrArg(Call.getArgExpr(DataIdx)); if\
  \ null, return.\n  - Must be local RecordType.\n- Validate length argument:\n  -\
  \ If !sizeofCoversVar(VD, Call.getArgExpr(LenIdx), C): return (not our pattern).\n\
  - Check safety:\n  - If State->contains<ZeroCleared>(VD): return (already cleared).\n\
  \  - If !State->contains<PartiallyInitAgg>(VD): return (we only warn for the known\
  \ risky init pattern).\n- Report:\n  - Node = C.generateNonFatalErrorNode();\n \
  \ - If Node:\n    - auto R = std::make_unique<PathSensitiveBugReport>(\n       \
  \ BugType(\"Kernel info leak\", \"Security\"),\n        \"Struct with padding copied\
  \ to user without clearing; use memset(0) before nla_put\",\n        Node);\n  \
  \  - R->addRange(Call.getSourceRange());\n    - C.emitReport(std::move(R));\n\n\
  Notes:\n- This keeps the checker focused and low-noise: it only warns when a struct\
  \ was created via a non-zeroing init-list and is then exported via nla_put/nla_put_64bit\
  \ with sizeof(struct) length, without an intervening explicit zeroing.\n\n\n4) Optional\
  \ Refinements (keep simple if not needed)\n\n- Accept additional export functions\
  \ if needed:\n  - e.g., copy_to_user, copy_to_user_iter, nla_put_nohdr, nla_put_string,\
  \ etc., if they take (len, data). Extend isNetlinkExportCall accordingly, setting\
  \ proper indices.\n\n- Consider clearing on \u201C= {}\u201D or \u201C= {0}\u201D\
  :\n  - The plan already treats these as ZeroCleared to reduce false positives.\n\
  \n- Handle alias of &var via local pointer:\n  - If necessary, add a simple alias\
  \ map (REGISTER_MAP_WITH_PROGRAMSTATE(PtrAlias, const VarDecl*, const VarDecl*))\
  \ and track p = &var in checkBind. Then recognize zeroing/exports that use the pointer\
  \ alias. To keep this checker minimal, skip aliasing unless noise observed.\n\n\n\
  5) Chosen Simpler Path Justification\n\n- We avoid complex whole-struct initialization\
  \ tracking. The kernel patch indicates the risky, common pattern: designated/partial\
  \ initializer for a struct with holes, followed by nla_put(..., sizeof(opt), &opt)\
  \ without a memset(0). The plan precisely captures that, while allowing explicit\
  \ zeroing (memset/memzero_explicit) to suppress the warning.\n- Using EvaluateExprToInt\
  \ and ASTContext for size comparison provides robust detection of \u201Csizeof(var)\u201D\
  \ equivalence without fragile textual heuristics; ExprHasName is used as a fallback\
  \ only when constant evaluation fails."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"\
  clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include <memory>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// Program states\nREGISTER_MAP_WITH_PROGRAMSTATE(PartiallyInitAgg,\
  \ const VarDecl*, char)\nREGISTER_SET_WITH_PROGRAMSTATE(ZeroCleared, const VarDecl*)\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<\n    check::PostStmt<DeclStmt>,\n\
  \    check::PostCall,\n    check::PreCall> {\n\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Kernel info\
  \ leak\", \"Security\")) {}\n\n      void checkPostStmt(const DeclStmt *DS, CheckerContext\
  \ &C) const;\n      void checkPostCall(const CallEvent &Call, CheckerContext &C)\
  \ const;\n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \n   private:\n      // Helpers\n      static const VarDecl *getLocalStructVarFromAddrArg(const\
  \ Expr *ArgE);\n      static bool isZeroBraceInit(const InitListExpr *ILE);\n  \
  \    static bool isNonZeroingInitList(const InitListExpr *ILE);\n      static bool\
  \ sizeofCoversVar(const VarDecl *VD, const Expr *LenExpr, CheckerContext &C);\n\
  \      static bool isNetlinkExportCall(const CallEvent &Call, unsigned &LenIdx,\
  \ unsigned &DataIdx, CheckerContext &C);\n\n      enum ZeroKind { ZK_None = 0, ZK_Memset,\
  \ ZK_MemzeroExplicit, ZK_Bzero };\n      static ZeroKind getZeroingKind(const CallEvent\
  \ &Call, unsigned &PtrIdx, unsigned &LenIdx, CheckerContext &C);\n\n      void markZeroCleared(ProgramStateRef\
  \ &State, const VarDecl *VD) const;\n      void markPartiallyInit(ProgramStateRef\
  \ &State, const VarDecl *VD) const;\n\n      void reportLeak(const CallEvent &Call,\
  \ CheckerContext &C) const;\n};\n\n/************ Helper Implementations ************/\n\
  \nconst VarDecl *SAGenTestChecker::getLocalStructVarFromAddrArg(const Expr *ArgE)\
  \ {\n  if (!ArgE) return nullptr;\n  const Expr *E = ArgE->IgnoreParenImpCasts();\n\
  \  const auto *UO = dyn_cast<UnaryOperator>(E);\n  if (!UO || UO->getOpcode() !=\
  \ UO_AddrOf)\n    return nullptr;\n\n  const Expr *Sub = UO->getSubExpr()->IgnoreParenImpCasts();\n\
  \  const auto *DRE = dyn_cast<DeclRefExpr>(Sub);\n  if (!DRE)\n    return nullptr;\n\
  \n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD)\n    return\
  \ nullptr;\n\n  if (!VD->hasLocalStorage())\n    return nullptr;\n\n  if (!VD->getType()->isRecordType())\n\
  \    return nullptr;\n\n  return VD;\n}\n\nbool SAGenTestChecker::isZeroBraceInit(const\
  \ InitListExpr *ILE) {\n  if (!ILE) return false;\n\n  // \"{}\"\n  if (ILE->getNumInits()\
  \ == 0)\n    return true;\n\n  if (ILE->getNumInits() == 1) {\n    const Expr *Init\
  \ = ILE->getInit(0);\n    if (!Init) return false;\n\n    // Any designated initializer\
  \ is considered non-zeroing\n    if (isa<DesignatedInitExpr>(Init))\n      return\
  \ false;\n\n    const Expr *E = Init->IgnoreParenImpCasts();\n    if (const auto\
  \ *IL = dyn_cast<IntegerLiteral>(E)) {\n      if (IL->getValue().isZero())\n   \
  \     return true;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isNonZeroingInitList(const\
  \ InitListExpr *ILE) {\n  if (!ILE) return false;\n  if (isZeroBraceInit(ILE))\n\
  \    return false;\n  return true;\n}\n\nbool SAGenTestChecker::sizeofCoversVar(const\
  \ VarDecl *VD, const Expr *LenExpr, CheckerContext &C) {\n  if (!VD || !LenExpr)\n\
  \    return false;\n\n  // First attempt: constant evaluation\n  llvm::APSInt Res;\n\
  \  if (EvaluateExprToInt(Res, LenExpr, C)) {\n    uint64_t LenVal = Res.isSigned()\
  \ ? (uint64_t)Res.getSExtValue() : Res.getZExtValue();\n    uint64_t VarSize = C.getASTContext().getTypeSizeInChars(VD->getType()).getQuantity();\n\
  \    return LenVal >= VarSize;\n  }\n\n  // Fallback: textual containment of variable\
  \ name (captures sizeof(var) pattern)\n  return ExprHasName(LenExpr, VD->getName(),\
  \ C);\n}\n\nbool SAGenTestChecker::isNetlinkExportCall(const CallEvent &Call, unsigned\
  \ &LenIdx, unsigned &DataIdx, CheckerContext &C) {\n  const Expr *OriginExpr = Call.getOriginExpr();\n\
  \  if (!OriginExpr)\n    return false;\n\n  // Explicitly match known netlink export\
  \ helpers we care about\n  if (ExprHasName(OriginExpr, \"nla_put_64bit\", C)) {\n\
  \    // nla_put_64bit(skb, attrtype, len, data, padtype)\n    if (Call.getNumArgs()\
  \ >= 4) {\n      LenIdx = 2;\n      DataIdx = 3;\n      return true;\n    }\n  \
  \  return false;\n  }\n  if (ExprHasName(OriginExpr, \"nla_put\", C)) {\n    //\
  \ nla_put(skb, attrtype, len, data)\n    if (Call.getNumArgs() >= 4) {\n      LenIdx\
  \ = 2;\n      DataIdx = 3;\n      return true;\n    }\n    return false;\n  }\n\n\
  \  return false;\n}\n\nSAGenTestChecker::ZeroKind SAGenTestChecker::getZeroingKind(const\
  \ CallEvent &Call, unsigned &PtrIdx, unsigned &LenIdx, CheckerContext &C) {\n  const\
  \ Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n    return ZK_None;\n\
  \n  // memset(ptr, 0, len)\n  if (ExprHasName(OriginExpr, \"memset\", C)) {\n  \
  \  if (Call.getNumArgs() >= 3) {\n      PtrIdx = 0;\n      LenIdx = 2;\n      return\
  \ ZK_Memset;\n    }\n    return ZK_None;\n  }\n\n  // memzero_explicit(ptr, len)\n\
  \  if (ExprHasName(OriginExpr, \"memzero_explicit\", C)) {\n    if (Call.getNumArgs()\
  \ >= 2) {\n      PtrIdx = 0;\n      LenIdx = 1;\n      return ZK_MemzeroExplicit;\n\
  \    }\n    return ZK_None;\n  }\n\n  // bzero(ptr, len)\n  if (ExprHasName(OriginExpr,\
  \ \"bzero\", C)) {\n    if (Call.getNumArgs() >= 2) {\n      PtrIdx = 0;\n     \
  \ LenIdx = 1;\n      return ZK_Bzero;\n    }\n    return ZK_None;\n  }\n\n  return\
  \ ZK_None;\n}\n\nvoid SAGenTestChecker::markZeroCleared(ProgramStateRef &State,\
  \ const VarDecl *VD) const {\n  if (!VD) return;\n  State = State->add<ZeroCleared>(VD);\n\
  \  State = State->remove<PartiallyInitAgg>(VD);\n}\n\nvoid SAGenTestChecker::markPartiallyInit(ProgramStateRef\
  \ &State, const VarDecl *VD) const {\n  if (!VD) return;\n  State = State->set<PartiallyInitAgg>(VD,\
  \ 1);\n}\n\n/************ Checker Callbacks ************/\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  if (!DS) return;\n  ProgramStateRef\
  \ State = C.getState();\n  bool Changed = false;\n\n  for (const Decl *D : DS->decls())\
  \ {\n    const auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      continue;\n\
  \n    if (!VD->hasLocalStorage())\n      continue;\n\n    if (!VD->getType()->isRecordType())\n\
  \      continue;\n\n    if (!VD->hasInit())\n      continue;\n\n    const Expr *Init\
  \ = VD->getInit();\n    if (!Init)\n      continue;\n\n    const Expr *I = Init->IgnoreImplicit();\n\
  \    const auto *ILE = dyn_cast<InitListExpr>(I);\n    if (!ILE)\n      continue;\n\
  \n    if (isNonZeroingInitList(ILE)) {\n      ProgramStateRef NewState = State->set<PartiallyInitAgg>(VD,\
  \ 1);\n      if (NewState != State) {\n        State = NewState;\n        Changed\
  \ = true;\n      }\n    } else {\n      // Zero brace init like {} or {0} considered\
  \ cleared\n      ProgramStateRef NewState = State->add<ZeroCleared>(VD);\n     \
  \ if (NewState != State) {\n        State = NewState;\n        Changed = true;\n\
  \      }\n    }\n  }\n\n  if (Changed)\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  unsigned PtrIdx = 0, LenIdx = 0;\n  ZeroKind ZK = getZeroingKind(Call, PtrIdx,\
  \ LenIdx, C);\n  if (ZK == ZK_None)\n    return;\n\n  // Identify the variable being\
  \ cleared\n  const Expr *PtrE = Call.getArgExpr(PtrIdx);\n  const Expr *LenE = Call.getArgExpr(LenIdx);\n\
  \  const VarDecl *VD = getLocalStructVarFromAddrArg(PtrE);\n  if (!VD)\n    return;\n\
  \n  // For memset, the \"value\" argument must be zero\n  if (ZK == ZK_Memset) {\n\
  \    const Expr *ValE = Call.getArgExpr(1);\n    llvm::APSInt V;\n    if (!ValE\
  \ || !EvaluateExprToInt(V, ValE, C) || !V.isZero())\n      return;\n  }\n\n  //\
  \ Ensure len covers the entire variable\n  if (!sizeofCoversVar(VD, LenE, C))\n\
  \    return;\n\n  // Mark as zero-cleared and remove partial-init flag\n  State\
  \ = State->add<ZeroCleared>(VD);\n  State = State->remove<PartiallyInitAgg>(VD);\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  unsigned LenIdx = 0, DataIdx = 0;\n  if (!isNetlinkExportCall(Call,\
  \ LenIdx, DataIdx, C))\n    return;\n\n  const Expr *DataE = Call.getArgExpr(DataIdx);\n\
  \  const Expr *LenE = Call.getArgExpr(LenIdx);\n  const VarDecl *VD = getLocalStructVarFromAddrArg(DataE);\n\
  \  if (!VD)\n    return;\n\n  if (!sizeofCoversVar(VD, LenE, C))\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n\n  // If explicitly zero-cleared, it's\
  \ safe\n  if (State->contains<ZeroCleared>(VD))\n    return;\n\n  // Warn only if\
  \ we have evidence of risky partial init via init-list\n  if (!State->get<PartiallyInitAgg>(VD))\n\
  \    return;\n\n  reportLeak(Call, C);\n}\n\nvoid SAGenTestChecker::reportLeak(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Copying partially initialized struct with padding to user; zero-initialize\
  \ before export\", N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects exporting partially initialized padded structs without zeroing\
  \ (kernel info leak)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
