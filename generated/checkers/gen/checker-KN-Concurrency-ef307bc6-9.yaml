_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: ef307bc6ef04e8c1ea843231db58e3afaafa9fa6
commit_type: Concurrency
index: 9
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"\
  llvm/ADT/SmallVector.h\"\n#include <utility>\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// No customized ProgramState is necessary for\
  \ this checker.\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::ASTCodeBody,\
  \ check::EndAnalysis> {\n   mutable std::unique_ptr<BugType> BT;\n\n   // Fields\
  \ that had a check-then-use under a spinlock somewhere in TU.\n   mutable llvm::DenseSet<const\
  \ FieldDecl*> LockedCTUFields;\n\n   struct UnlockedNullWrite {\n     const FieldDecl\
  \ *FD;\n     SourceRange SR;\n     const FunctionDecl *Func;\n   };\n   // All unlocked\
  \ writes of FD = NULL collected across TU.\n   mutable llvm::SmallVector<UnlockedNullWrite,\
  \ 16> UnlockedNullWrites;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this,\n\
  \                       \"Inconsistent locking: unlocked NULL write may race with\
  \ locked check-then-use\",\n                       \"Concurrency\")) {}\n\n  void\
  \ checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter &BR) const;\n\
  \  void checkEndAnalysis(ExplodedGraph &G, BugReporter &BR, ExprEngine &Eng) const;\n\
  \nprivate:\n  // Helper identification functions\n  static bool isSpinLockName(StringRef\
  \ N) {\n    return N.equals(\"spin_lock\") ||\n           N.equals(\"spin_lock_bh\"\
  ) ||\n           N.equals(\"spin_lock_irq\") ||\n           N.equals(\"spin_lock_irqsave\"\
  );\n  }\n\n  static bool isSpinUnlockName(StringRef N) {\n    return N.equals(\"\
  spin_unlock\") ||\n           N.equals(\"spin_unlock_bh\") ||\n           N.equals(\"\
  spin_unlock_irq\") ||\n           N.equals(\"spin_unlock_irqrestore\");\n  }\n\n\
  \  static StringRef getCalleeName(const CallExpr *CE) {\n    if (!CE) return \"\"\
  ;\n    if (const FunctionDecl *FD = CE->getDirectCallee()) {\n      if (const IdentifierInfo\
  \ *II = FD->getIdentifier())\n        return II->getName();\n    }\n    return \"\
  \";\n  }\n\n  static const FieldDecl* getFieldIfPointerMember(const Expr *E) {\n\
  \    if (!E) return nullptr;\n    const Expr *IE = E->IgnoreParenImpCasts();\n \
  \   if (const auto *ME = dyn_cast<MemberExpr>(IE)) {\n      if (const auto *FD =\
  \ dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n        if (ME->getType()->isPointerType())\n\
  \          return FD;\n      }\n    }\n    return nullptr;\n  }\n\n  static bool\
  \ isNullPtrConstantExpr(const Expr *E, ASTContext &Ctx) {\n    if (!E) return false;\n\
  \    if (E->isNullPointerConstant(Ctx, Expr::NPC_ValueDependentIsNull))\n      return\
  \ true;\n\n    Expr::EvalResult R;\n    if (E->EvaluateAsInt(R, Ctx)) {\n      llvm::APSInt\
  \ V = R.Val.getInt();\n      return V == 0;\n    }\n    return false;\n  }\n\n \
  \ static const FieldDecl* detectNullCheckedField(const Expr *Cond, ASTContext &Ctx)\
  \ {\n    if (!Cond) return nullptr;\n    const Expr *C = Cond->IgnoreParenImpCasts();\n\
  \n    // if (!ptr)\n    if (const auto *UO = dyn_cast<UnaryOperator>(C)) {\n   \
  \   if (UO->getOpcode() == UO_LNot) {\n        const FieldDecl *FD = getFieldIfPointerMember(UO->getSubExpr());\n\
  \        if (FD) return FD;\n      }\n    }\n\n    // if (ptr == NULL) or if (ptr\
  \ != NULL)\n    if (const auto *BO = dyn_cast<BinaryOperator>(C)) {\n      if (BO->getOpcode()\
  \ == BO_EQ || BO->getOpcode() == BO_NE) {\n        const FieldDecl *FDL = getFieldIfPointerMember(BO->getLHS());\n\
  \        const FieldDecl *FDR = getFieldIfPointerMember(BO->getRHS());\n       \
  \ if (FDL && isNullPtrConstantExpr(BO->getRHS(), Ctx))\n          return FDL;\n\
  \        if (FDR && isNullPtrConstantExpr(BO->getLHS(), Ctx))\n          return\
  \ FDR;\n      }\n    }\n\n    // if (ptr)\n    if (const FieldDecl *FD = getFieldIfPointerMember(C))\n\
  \      return FD;\n\n    return nullptr;\n  }\n\n  static bool exprContainsFieldRef(const\
  \ Expr *E, const FieldDecl *FD) {\n    if (!E || !FD) return false;\n    const Expr\
  \ *IE = E->IgnoreParenImpCasts();\n    if (const auto *ME = dyn_cast<MemberExpr>(IE))\
  \ {\n      if (const auto *MFD = dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n \
  \       if (MFD == FD)\n          return true;\n      }\n    }\n    for (const Stmt\
  \ *Child : E->children()) {\n      if (const auto *CE = dyn_cast_or_null<Expr>(Child))\
  \ {\n        if (exprContainsFieldRef(CE, FD))\n          return true;\n      }\n\
  \    }\n    return false;\n  }\n\n  void scanStmt(const Stmt *S,\n             \
  \   ASTContext &Ctx,\n                const FunctionDecl *CurFunc,\n           \
  \     int &LockDepth,\n                llvm::SmallSet<const FieldDecl*, 8> &PendingCheckedFields)\
  \ const {\n\n    if (!S) return;\n\n    if (const auto *IS = dyn_cast<IfStmt>(S))\
  \ {\n      // Under lock, see if this condition checks a pointer field.\n      if\
  \ (LockDepth > 0) {\n        const FieldDecl *FD = detectNullCheckedField(IS->getCond(),\
  \ Ctx);\n        if (FD)\n          PendingCheckedFields.insert(FD);\n      }\n\n\
  \      // Recurse into branches.\n      scanStmt(IS->getThen(), Ctx, CurFunc, LockDepth,\
  \ PendingCheckedFields);\n      scanStmt(IS->getElse(), Ctx, CurFunc, LockDepth,\
  \ PendingCheckedFields);\n      return;\n    }\n\n    if (const auto *BO = dyn_cast<BinaryOperator>(S))\
  \ {\n      // Record unlocked writes \"obj->field = NULL\"\n      if (BO->getOpcode()\
  \ == BO_Assign && LockDepth == 0) {\n        const FieldDecl *FD = getFieldIfPointerMember(BO->getLHS());\n\
  \        if (FD && isNullPtrConstantExpr(BO->getRHS(), Ctx)) {\n          UnlockedNullWrites.push_back(UnlockedNullWrite{FD,\
  \ BO->getSourceRange(), CurFunc});\n        }\n      }\n      // Continue scanning\
  \ sub-expressions.\n    }\n\n    if (const auto *CE = dyn_cast<CallExpr>(S)) {\n\
  \      // If in locked region, detect \"use\" of a previously checked field as a\
  \ call argument.\n      if (LockDepth > 0 && !PendingCheckedFields.empty()) {\n\
  \        llvm::SmallVector<const FieldDecl*, 4> ToErase;\n        for (const FieldDecl\
  \ *FD : PendingCheckedFields) {\n          for (unsigned i = 0; i < CE->getNumArgs();\
  \ ++i) {\n            const Expr *Arg = CE->getArg(i);\n            if (exprContainsFieldRef(Arg,\
  \ FD)) {\n              LockedCTUFields.insert(FD);\n              ToErase.push_back(FD);\n\
  \              break;\n            }\n          }\n        }\n        // Remove\
  \ fields that have been confirmed as used under the lock.\n        for (const FieldDecl\
  \ *FD : ToErase)\n          PendingCheckedFields.erase(FD);\n      }\n\n      //\
  \ Update lock depth based on known spinlock APIs.\n      StringRef CalleeName =\
  \ getCalleeName(CE);\n      if (isSpinLockName(CalleeName)) {\n        ++LockDepth;\n\
  \      } else if (isSpinUnlockName(CalleeName)) {\n        if (LockDepth > 0)\n\
  \          --LockDepth;\n        if (LockDepth == 0)\n          PendingCheckedFields.clear();\n\
  \      }\n      // Recurse into callee/args to discover nested calls/exprs.\n  \
  \  }\n\n    // Generic recursion for children.\n    for (const Stmt *Child : S->children())\
  \ {\n      if (Child)\n        scanStmt(Child, Ctx, CurFunc, LockDepth, PendingCheckedFields);\n\
  \    }\n  }\n};\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const {\n  const auto *FD = dyn_cast<FunctionDecl>(D);\n\
  \  if (!FD || !FD->hasBody())\n    return;\n\n  const Stmt *Body = FD->getBody();\n\
  \  ASTContext &Ctx = FD->getASTContext();\n\n  int LockDepth = 0;\n  llvm::SmallSet<const\
  \ FieldDecl*, 8> PendingCheckedFields;\n\n  scanStmt(Body, Ctx, FD, LockDepth, PendingCheckedFields);\n\
  }\n\nvoid SAGenTestChecker::checkEndAnalysis(ExplodedGraph &G, BugReporter &BR,\
  \ ExprEngine &Eng) const {\n  if (LockedCTUFields.empty() || UnlockedNullWrites.empty())\n\
  \    return;\n\n  const SourceManager &SM = BR.getSourceManager();\n\n  for (const\
  \ auto &W : UnlockedNullWrites) {\n    if (!W.FD) continue;\n    if (!LockedCTUFields.count(W.FD))\n\
  \      continue;\n\n    // Build a concise message, include field name.\n    std::string\
  \ Msg = \"Unlocked write to '\";\n    Msg += W.FD->getNameAsString();\n    Msg +=\
  \ \" = NULL' may race with locked check-then-use, causing NULL dereference\";\n\n\
  \    PathDiagnosticLocation Loc =\n        PathDiagnosticLocation::createBegin(W.SR.getBegin(),\
  \ SM, W.Func);\n\n    auto R = std::make_unique<BasicBugReport>(*BT, Msg, Loc);\n\
  \    R->addRange(W.SR);\n    BR.emitReport(std::move(R));\n  }\n}\n\n} // end anonymous\
  \ namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry)\
  \ {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect inconsistent locking: unlocked NULL write may race with locked\
  \ check-then-use\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nusb: dwc2: fix possible NULL pointer dereference caused\
  \ by driver concurrency\n\nIn _dwc2_hcd_urb_enqueue(), \"urb->hcpriv = NULL\" is\
  \ executed without\nholding the lock \"hsotg->lock\". In _dwc2_hcd_urb_dequeue():\n\
  \n    spin_lock_irqsave(&hsotg->lock, flags);\n    ...\n\tif (!urb->hcpriv) {\n\t\
  \tdev_dbg(hsotg->dev, \"## urb->hcpriv is NULL ##\\n\");\n\t\tgoto out;\n\t}\n \
  \   rc = dwc2_hcd_urb_dequeue(hsotg, urb->hcpriv); // Use urb->hcpriv\n    ...\n\
  out:\n    spin_unlock_irqrestore(&hsotg->lock, flags);\n\nWhen _dwc2_hcd_urb_enqueue()\
  \ and _dwc2_hcd_urb_dequeue() are\nconcurrently executed, the NULL check of \"urb->hcpriv\"\
  \ can be executed\nbefore \"urb->hcpriv = NULL\". After urb->hcpriv is NULL, it\
  \ can be used\nin the function call to dwc2_hcd_urb_dequeue(), which can cause a\
  \ NULL\npointer dereference.\n\nThis possible bug is found by an experimental static\
  \ analysis tool\ndeveloped by myself. This tool analyzes the locking APIs to extract\n\
  function pairs that can be concurrently executed, and then analyzes the\ninstructions\
  \ in the paired functions to identify possible concurrency\nbugs including data\
  \ races and atomicity violations. The above possible\nbug is reported, when my tool\
  \ analyzes the source code of Linux 6.5.\n\nTo fix this possible bug, \"urb->hcpriv\
  \ = NULL\" should be executed with\nholding the lock \"hsotg->lock\". After using\
  \ this patch, my tool never\nreports the possible bug, with the kernelconfiguration\
  \ allyesconfig for\nx86_64. Because I have no associated hardware, I cannot test\
  \ the patch\nin runtime testing, and just verify it according to the code logic.\n\
  \nFixes: 33ad261aa62b (\"usb: dwc2: host: spinlock urb_enqueue\")\nSigned-off-by:\
  \ Jia-Ju Bai <baijiaju@buaa.edu.cn>\nLink: https://lore.kernel.org/r/20230926024404.832096-1-baijiaju@buaa.edu.cn\n\
  Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n\n## Buggy Code\n\
  \n```c\n// Function: _dwc2_hcd_urb_enqueue in drivers/usb/dwc2/hcd.c\nstatic int\
  \ _dwc2_hcd_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\t gfp_t mem_flags)\n\
  {\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tstruct usb_host_endpoint\
  \ *ep = urb->ep;\n\tstruct dwc2_hcd_urb *dwc2_urb;\n\tint i;\n\tint retval;\n\t\
  int alloc_bandwidth = 0;\n\tu8 ep_type = 0;\n\tu32 tflags = 0;\n\tvoid *buf;\n\t\
  unsigned long flags;\n\tstruct dwc2_qh *qh;\n\tbool qh_allocated = false;\n\tstruct\
  \ dwc2_qtd *qtd;\n\tstruct dwc2_gregs_backup *gr;\n\n\tgr = &hsotg->gr_backup;\n\
  \n\tif (dbg_urb(urb)) {\n\t\tdev_vdbg(hsotg->dev, \"DWC OTG HCD URB Enqueue\\n\"\
  );\n\t\tdwc2_dump_urb_info(hcd, urb, \"urb_enqueue\");\n\t}\n\n\tif (hsotg->hibernated)\
  \ {\n\t\tif (gr->gotgctl & GOTGCTL_CURMODE_HOST)\n\t\t\tretval = dwc2_exit_hibernation(hsotg,\
  \ 0, 0, 1);\n\t\telse\n\t\t\tretval = dwc2_exit_hibernation(hsotg, 0, 0, 0);\n\n\
  \t\tif (retval)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit hibernation failed.\\\
  n\");\n\t}\n\n\tif (hsotg->in_ppd) {\n\t\tretval = dwc2_exit_partial_power_down(hsotg,\
  \ 0, true);\n\t\tif (retval)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit partial_power_down\
  \ failed\\n\");\n\t}\n\n\tif (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_NONE\
  \ &&\n\t    hsotg->bus_suspended) {\n\t\tif (dwc2_is_device_mode(hsotg))\n\t\t\t\
  dwc2_gadget_exit_clock_gating(hsotg, 0);\n\t\telse\n\t\t\tdwc2_host_exit_clock_gating(hsotg,\
  \ 0);\n\t}\n\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tif (usb_pipetype(urb->pipe) ==\
  \ PIPE_ISOCHRONOUS ||\n\t    usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {\n\t\t\
  spin_lock_irqsave(&hsotg->lock, flags);\n\t\tif (!dwc2_hcd_is_bandwidth_allocated(hsotg,\
  \ ep))\n\t\t\talloc_bandwidth = 1;\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\
  \t}\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_CONTROL:\n\t\tep_type =\
  \ USB_ENDPOINT_XFER_CONTROL;\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\t\tep_type\
  \ = USB_ENDPOINT_XFER_ISOC;\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tep_type = USB_ENDPOINT_XFER_BULK;\n\
  \t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tep_type = USB_ENDPOINT_XFER_INT;\n\t\tbreak;\n\
  \t}\n\n\tdwc2_urb = dwc2_hcd_urb_alloc(hsotg, urb->number_of_packets,\n\t\t\t\t\
  \      mem_flags);\n\tif (!dwc2_urb)\n\t\treturn -ENOMEM;\n\n\tdwc2_hcd_urb_set_pipeinfo(hsotg,\
  \ dwc2_urb, usb_pipedevice(urb->pipe),\n\t\t\t\t  usb_pipeendpoint(urb->pipe), ep_type,\n\
  \t\t\t\t  usb_pipein(urb->pipe),\n\t\t\t\t  usb_endpoint_maxp(&ep->desc),\n\t\t\t\
  \t  usb_endpoint_maxp_mult(&ep->desc));\n\n\tbuf = urb->transfer_buffer;\n\n\tif\
  \ (hcd_uses_dma(hcd)) {\n\t\tif (!buf && (urb->transfer_dma & 3)) {\n\t\t\tdev_err(hsotg->dev,\n\
  \t\t\t\t\"%s: unaligned transfer with no transfer_buffer\",\n\t\t\t\t__func__);\n\
  \t\t\tretval = -EINVAL;\n\t\t\tgoto fail0;\n\t\t}\n\t}\n\n\tif (!(urb->transfer_flags\
  \ & URB_NO_INTERRUPT))\n\t\ttflags |= URB_GIVEBACK_ASAP;\n\tif (urb->transfer_flags\
  \ & URB_ZERO_PACKET)\n\t\ttflags |= URB_SEND_ZERO_PACKET;\n\n\tdwc2_urb->priv =\
  \ urb;\n\tdwc2_urb->buf = buf;\n\tdwc2_urb->dma = urb->transfer_dma;\n\tdwc2_urb->length\
  \ = urb->transfer_buffer_length;\n\tdwc2_urb->setup_packet = urb->setup_packet;\n\
  \tdwc2_urb->setup_dma = urb->setup_dma;\n\tdwc2_urb->flags = tflags;\n\tdwc2_urb->interval\
  \ = urb->interval;\n\tdwc2_urb->status = -EINPROGRESS;\n\n\tfor (i = 0; i < urb->number_of_packets;\
  \ ++i)\n\t\tdwc2_hcd_urb_set_iso_desc_params(dwc2_urb, i,\n\t\t\t\t\t\t urb->iso_frame_desc[i].offset,\n\
  \t\t\t\t\t\t urb->iso_frame_desc[i].length);\n\n\turb->hcpriv = dwc2_urb;\n\tqh\
  \ = (struct dwc2_qh *)ep->hcpriv;\n\t/* Create QH for the endpoint if it doesn't\
  \ exist */\n\tif (!qh) {\n\t\tqh = dwc2_hcd_qh_create(hsotg, dwc2_urb, mem_flags);\n\
  \t\tif (!qh) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail0;\n\t\t}\n\t\tep->hcpriv\
  \ = qh;\n\t\tqh_allocated = true;\n\t}\n\n\tqtd = kzalloc(sizeof(*qtd), mem_flags);\n\
  \tif (!qtd) {\n\t\tretval = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tspin_lock_irqsave(&hsotg->lock,\
  \ flags);\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval)\n\t\tgoto\
  \ fail2;\n\n\tretval = dwc2_hcd_urb_enqueue(hsotg, dwc2_urb, qh, qtd);\n\tif (retval)\n\
  \t\tgoto fail3;\n\n\tif (alloc_bandwidth) {\n\t\tdwc2_allocate_bus_bandwidth(hcd,\n\
  \t\t\t\tdwc2_hcd_get_ep_bandwidth(hsotg, ep),\n\t\t\t\turb);\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock,\
  \ flags);\n\n\treturn 0;\n\nfail3:\n\tdwc2_urb->priv = NULL;\n\tusb_hcd_unlink_urb_from_ep(hcd,\
  \ urb);\n\tif (qh_allocated && qh->channel && qh->channel->qh == qh)\n\t\tqh->channel->qh\
  \ = NULL;\nfail2:\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\turb->hcpriv\
  \ = NULL;\n\tkfree(qtd);\nfail1:\n\tif (qh_allocated) {\n\t\tstruct dwc2_qtd *qtd2,\
  \ *qtd2_tmp;\n\n\t\tep->hcpriv = NULL;\n\t\tdwc2_hcd_qh_unlink(hsotg, qh);\n\t\t\
  /* Free each QTD in the QH's QTD list */\n\t\tlist_for_each_entry_safe(qtd2, qtd2_tmp,\
  \ &qh->qtd_list,\n\t\t\t\t\t qtd_list_entry)\n\t\t\tdwc2_hcd_qtd_unlink_and_free(hsotg,\
  \ qtd2, qh);\n\t\tdwc2_hcd_qh_free(hsotg, qh);\n\t}\nfail0:\n\tkfree(dwc2_urb);\n\
  \n\treturn retval;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/usb/dwc2/hcd.c\
  \ b/drivers/usb/dwc2/hcd.c\nindex 657f1f659ffa..35c7a4df8e71 100644\n--- a/drivers/usb/dwc2/hcd.c\n\
  +++ b/drivers/usb/dwc2/hcd.c\n@@ -4769,8 +4769,8 @@ static int _dwc2_hcd_urb_enqueue(struct\
  \ usb_hcd *hcd, struct urb *urb,\n \tif (qh_allocated && qh->channel && qh->channel->qh\
  \ == qh)\n \t\tqh->channel->qh = NULL;\n fail2:\n-\tspin_unlock_irqrestore(&hsotg->lock,\
  \ flags);\n \turb->hcpriv = NULL;\n+\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\
  \ \tkfree(qtd);\n fail1:\n \tif (qh_allocated) {\n```\n"
pattern: "## Bug Pattern\n\nInconsistent locking on a shared pointer used in a check-then-use\
  \ sequence:\n- One path (dequeue) checks and uses urb->hcpriv while holding hsotg->lock\
  \ (if (!urb->hcpriv) ...; use(urb->hcpriv);).\n- Another path (enqueue error path)\
  \ writes urb->hcpriv = NULL after releasing hsotg->lock.\nThis unlock-before-write\
  \ lets the writer race with the reader\u2019s locked check-then-use, allowing urb->hcpriv\
  \ to become NULL between the check and use, leading to a NULL pointer dereference."
plan: "Plan\n\n1) Program state and per-checker data\n- Do not customize ProgramState.\
  \ This checker works as an AST-level pattern detector across functions in the TU.\n\
  - Maintain small per-checker containers:\n  - DenseSet<const FieldDecl*> LockedCTUFields:\
  \ fields that are null-checked and then used while a spinlock is held.\n  - struct\
  \ UnlockedNullWrite { const FieldDecl *FD; SourceRange SR; const FunctionDecl *Func;\
  \ };\n  - SmallVector<UnlockedNullWrite, 16> UnlockedNullWrites: all assignments\
  \ Field = NULL that occur when no spinlock is held.\n\n2) Helper identification\
  \ functions (internal, AST-oriented)\n- isSpinLockName(StringRef N): return true\
  \ for {\"spin_lock\", \"spin_lock_bh\", \"spin_lock_irq\", \"spin_lock_irqsave\"\
  }.\n- isSpinUnlockName(StringRef N): return true for {\"spin_unlock\", \"spin_unlock_bh\"\
  , \"spin_unlock_irq\", \"spin_unlock_irqrestore\"}.\n- isNullPtrConstantExpr(const\
  \ Expr *E): true if E is a null pointer constant or evaluates to int 0. Use E->isNullPointerConstant(ASTContext,\
  \ NPC_ValueDependentIsNotNull) OR EvaluateExprToInt == 0.\n- getCalleeName(const\
  \ CallExpr *CE): if CE->getDirectCallee(), return getNameAsString().\n- getFieldIfPointerMember(const\
  \ Expr *E): Try to extract the FieldDecl* if E (after IgnoreParenImpCasts) is a\
  \ MemberExpr with pointer type (ME->getType()->isPointerType()) or a plain pointer\
  \ field; return nullptr otherwise.\n- exprUsesField(const Stmt *S, const FieldDecl\
  \ *FD): recursively scan S and return true if any MemberExpr in S references FD\
  \ (ME->getMemberDecl() == FD). Use findSpecificTypeInChildren<MemberExpr>() and\
  \ then check the MemberDecl.\n\n3) Function-level AST scan with a lightweight lock\
  \ context\n- Use checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter\
  \ &BR) to scan each function body.\n- For each function with a body:\n  - Walk the\
  \ body statements in a preorder (simple recursive traversal).\n  - Maintain:\n \
  \   - int LockDepth = 0 (number of held spin_locks; increment on lock, decrement\
  \ on unlock; never below 0).\n    - SmallSet<const FieldDecl*, 8> PendingCheckedFields:\
  \ fields that have been checked for null under the lock but not yet observed as\
  \ used.\n  - On every CallExpr:\n    - Fetch callee name via getCalleeName.\n  \
  \  - If isSpinLockName, ++LockDepth.\n    - If isSpinUnlockName, set LockDepth =\
  \ max(LockDepth - 1, 0).\n  - On every IfStmt when LockDepth > 0:\n    - Extract\
  \ the condition E = If->getCond()->IgnoreParenImpCasts().\n    - Try to detect a\
  \ null-check on a field:\n      - Pattern A: UnaryOperator \u2018!\u2019 on a MemberExpr:\
  \ if ( ! (MemberExpr) ) -> FD = that MemberExpr field.\n      - Pattern B: BinaryOperator\
  \ \u2018==/!=\u2018 between a MemberExpr and a null/zero constant: FD = MemberExpr\
  \ field if the other side isNullPtrConstantExpr().\n      - Pattern C: Bare pointer\
  \ truth test: if (MemberExpr) or if (!MemberExpr) after implicit cast to bool (covered\
  \ by A).\n      - Use getFieldIfPointerMember() to get FD from either side of the\
  \ condition.\n    - If FD is found (pointer field): insert FD into PendingCheckedFields.\n\
  \  - While LockDepth > 0, detect \u201Cuse\u201D after check:\n    - For every Stmt\
  \ (including CallExpr, UnaryOperator deref, ArraySubscriptExpr, etc.), if exprUsesField(S,\
  \ FD) for any FD in PendingCheckedFields, then:\n      - Consider check-then-use\
  \ under lock confirmed for that FD.\n      - Insert FD into LockedCTUFields.\n \
  \     - Remove FD from PendingCheckedFields.\n    - NOTE: It is sufficient to detect\
  \ use anywhere later in the traversal while LockDepth > 0; traversal order assures\
  \ it occurs after the If condition.\n  - When LockDepth == 0, detect unlocked null\
  \ writes:\n    - For every BinaryOperator \u2018=\u2019:\n      - If LHS is a MemberExpr\
  \ with FieldDecl* FD and RHS isNullPtrConstantExpr():\n        - Record UnlockedNullWrites.push_back({FD,\
  \ BO->getSourceRange(), CurrentFunctionDecl}).\n    - This intentionally catches\
  \ writes done after an explicit spin_unlock (as in the target patch) and also general\
  \ \u201Cno lock held\u201D stores to NULL.\n\n4) Final reporting (cross-function\
  \ correlation)\n- Use checkEndAnalysis(ExplodedGraph &G, BugReporter &BR, ExprEngine\
  \ &Eng):\n  - For each UnlockedNullWrite W in UnlockedNullWrites:\n    - If W.FD\
  \ is present in LockedCTUFields:\n      - Emit a BasicBugReport:\n        - BugType:\
  \ \u201CInconsistent locking: unlocked NULL write may race with locked check-then-use\u201D\
  \n        - Location: W.SR (point to the assignment).\n        - Message: \u201C\
  Unlocked \u2018<field-name> = NULL\u2019 may race with locked check-then-use, causing\
  \ NULL dereference.\u201D\n      - Optionally include function name W.Func->getNameAsString()\
  \ in the message to help pinpoint.\n\n5) Notes and heuristics to reduce false positives\n\
  - Only consider pointer-typed fields: ME->getType()->isPointerType().\n- Only treat\
  \ a field as \u201Cused\u201D if:\n  - It appears as an rvalue (e.g., inside a CallExpr\
  \ argument) or inside a dereference; ignore appearances where it is the LHS of an\
  \ assignment or inside another null-check condition.\n- Lock names\n  - This checker\
  \ does not attempt to prove the \u201Csame\u201D lock instance across functions;\
  \ it assumes spin_lock* protects the checked field and that writing it to NULL without\
  \ any lock can race. This matches the target bug where dequeue side is locked and\
  \ enqueue error path writes after unlock.\n- Supported lock APIs\n  - Start with\
  \ spin_lock/spin_unlock families listed above. You can extend the name lists if\
  \ needed.\n\n6) Selected callbacks and their implementation summary\n- checkASTCodeBody:\n\
  \  - Traverse each function body.\n  - Maintain LockDepth and PendingCheckedFields.\n\
  \  - Populate LockedCTUFields and UnlockedNullWrites as described.\n- checkEndAnalysis:\n\
  \  - Correlate UnlockedNullWrites with LockedCTUFields and emit BasicBugReport for\
  \ matches.\n\nThis minimal, AST-based two-phase approach reliably flags the target\
  \ pattern: a field (e.g., urb->hcpriv) that is null-checked and used under a spinlock\
  \ in one function, but written to NULL in another function path without holding\
  \ any spinlock (including after an unlock in the same function), which can lead\
  \ to a NULL pointer dereference due to a race."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"\
  llvm/ADT/SmallVector.h\"\n#include <utility>\n#include <memory>\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No customized ProgramState\
  \ is necessary for this checker.\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::ASTCodeBody, check::EndAnalysis> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   // Fields that had a check-then-use under a spinlock somewhere in TU.\n\
  \   mutable llvm::DenseSet<const FieldDecl*> LockedCTUFields;\n\n   struct UnlockedNullWrite\
  \ {\n     const FieldDecl *FD;\n     SourceRange SR;\n     const FunctionDecl *Func;\n\
  \   };\n   // All unlocked writes of FD = NULL collected across TU.\n   mutable\
  \ llvm::SmallVector<UnlockedNullWrite, 16> UnlockedNullWrites;\n\npublic:\n  SAGenTestChecker()\n\
  \      : BT(new BugType(this,\n                       \"Inconsistent locking: unlocked\
  \ NULL write may race with locked check-then-use\",\n                       \"Concurrency\"\
  )) {}\n\n  void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter\
  \ &BR) const;\n  void checkEndAnalysis(ExplodedGraph &G, BugReporter &BR, ExprEngine\
  \ &Eng) const;\n\nprivate:\n  // Helper identification functions\n  static bool\
  \ isSpinLockName(StringRef N) {\n    return N.equals(\"spin_lock\") ||\n       \
  \    N.equals(\"spin_lock_bh\") ||\n           N.equals(\"spin_lock_irq\") ||\n\
  \           N.equals(\"spin_lock_irqsave\");\n  }\n\n  static bool isSpinUnlockName(StringRef\
  \ N) {\n    return N.equals(\"spin_unlock\") ||\n           N.equals(\"spin_unlock_bh\"\
  ) ||\n           N.equals(\"spin_unlock_irq\") ||\n           N.equals(\"spin_unlock_irqrestore\"\
  );\n  }\n\n  static StringRef getCalleeName(const CallExpr *CE) {\n    if (!CE)\
  \ return \"\";\n    if (const FunctionDecl *FD = CE->getDirectCallee()) {\n    \
  \  if (const IdentifierInfo *II = FD->getIdentifier())\n        return II->getName();\n\
  \    }\n    return \"\";\n  }\n\n  static const FieldDecl* getFieldIfPointerMember(const\
  \ Expr *E) {\n    if (!E) return nullptr;\n    const Expr *IE = E->IgnoreParenImpCasts();\n\
  \    if (const auto *ME = dyn_cast<MemberExpr>(IE)) {\n      if (const auto *FD\
  \ = dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n        if (ME->getType()->isPointerType())\n\
  \          return FD;\n      }\n    }\n    return nullptr;\n  }\n\n  static bool\
  \ isNullPtrConstantExpr(const Expr *E, ASTContext &Ctx) {\n    if (!E) return false;\n\
  \    if (E->isNullPointerConstant(Ctx, Expr::NPC_ValueDependentIsNull))\n      return\
  \ true;\n\n    Expr::EvalResult R;\n    if (E->EvaluateAsInt(R, Ctx)) {\n      llvm::APSInt\
  \ V = R.Val.getInt();\n      return V == 0;\n    }\n    return false;\n  }\n\n \
  \ static const FieldDecl* detectNullCheckedField(const Expr *Cond, ASTContext &Ctx)\
  \ {\n    if (!Cond) return nullptr;\n    const Expr *C = Cond->IgnoreParenImpCasts();\n\
  \n    // if (!ptr)\n    if (const auto *UO = dyn_cast<UnaryOperator>(C)) {\n   \
  \   if (UO->getOpcode() == UO_LNot) {\n        const FieldDecl *FD = getFieldIfPointerMember(UO->getSubExpr());\n\
  \        if (FD) return FD;\n      }\n    }\n\n    // if (ptr == NULL) or if (ptr\
  \ != NULL)\n    if (const auto *BO = dyn_cast<BinaryOperator>(C)) {\n      if (BO->getOpcode()\
  \ == BO_EQ || BO->getOpcode() == BO_NE) {\n        const FieldDecl *FDL = getFieldIfPointerMember(BO->getLHS());\n\
  \        const FieldDecl *FDR = getFieldIfPointerMember(BO->getRHS());\n       \
  \ if (FDL && isNullPtrConstantExpr(BO->getRHS(), Ctx))\n          return FDL;\n\
  \        if (FDR && isNullPtrConstantExpr(BO->getLHS(), Ctx))\n          return\
  \ FDR;\n      }\n    }\n\n    // if (ptr)\n    if (const FieldDecl *FD = getFieldIfPointerMember(C))\n\
  \      return FD;\n\n    return nullptr;\n  }\n\n  static bool exprContainsFieldRef(const\
  \ Expr *E, const FieldDecl *FD) {\n    if (!E || !FD) return false;\n    const Expr\
  \ *IE = E->IgnoreParenImpCasts();\n    if (const auto *ME = dyn_cast<MemberExpr>(IE))\
  \ {\n      if (const auto *MFD = dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n \
  \       if (MFD == FD)\n          return true;\n      }\n    }\n    for (const Stmt\
  \ *Child : E->children()) {\n      if (const auto *CE = dyn_cast_or_null<Expr>(Child))\
  \ {\n        if (exprContainsFieldRef(CE, FD))\n          return true;\n      }\n\
  \    }\n    return false;\n  }\n\n  void scanStmt(const Stmt *S,\n             \
  \   ASTContext &Ctx,\n                const FunctionDecl *CurFunc,\n           \
  \     int &LockDepth,\n                llvm::SmallSet<const FieldDecl*, 8> &PendingCheckedFields)\
  \ const {\n\n    if (!S) return;\n\n    if (const auto *IS = dyn_cast<IfStmt>(S))\
  \ {\n      // Under lock, see if this condition checks a pointer field.\n      if\
  \ (LockDepth > 0) {\n        const FieldDecl *FD = detectNullCheckedField(IS->getCond(),\
  \ Ctx);\n        if (FD)\n          PendingCheckedFields.insert(FD);\n      }\n\n\
  \      // Recurse into branches.\n      scanStmt(IS->getThen(), Ctx, CurFunc, LockDepth,\
  \ PendingCheckedFields);\n      scanStmt(IS->getElse(), Ctx, CurFunc, LockDepth,\
  \ PendingCheckedFields);\n      return;\n    }\n\n    if (const auto *BO = dyn_cast<BinaryOperator>(S))\
  \ {\n      // Record unlocked writes \"obj->field = NULL\"\n      if (BO->getOpcode()\
  \ == BO_Assign && LockDepth == 0) {\n        const FieldDecl *FD = getFieldIfPointerMember(BO->getLHS());\n\
  \        if (FD && isNullPtrConstantExpr(BO->getRHS(), Ctx)) {\n          UnlockedNullWrites.push_back(UnlockedNullWrite{FD,\
  \ BO->getSourceRange(), CurFunc});\n        }\n      }\n      // Continue scanning\
  \ sub-expressions.\n    }\n\n    if (const auto *CE = dyn_cast<CallExpr>(S)) {\n\
  \      // If in locked region, detect \"use\" of a previously checked field as a\
  \ call argument.\n      if (LockDepth > 0 && !PendingCheckedFields.empty()) {\n\
  \        llvm::SmallVector<const FieldDecl*, 4> ToErase;\n        for (const FieldDecl\
  \ *FD : PendingCheckedFields) {\n          for (unsigned i = 0; i < CE->getNumArgs();\
  \ ++i) {\n            const Expr *Arg = CE->getArg(i);\n            if (exprContainsFieldRef(Arg,\
  \ FD)) {\n              LockedCTUFields.insert(FD);\n              ToErase.push_back(FD);\n\
  \              break;\n            }\n          }\n        }\n        // Remove\
  \ fields that have been confirmed as used under the lock.\n        for (const FieldDecl\
  \ *FD : ToErase)\n          PendingCheckedFields.erase(FD);\n      }\n\n      //\
  \ Update lock depth based on known spinlock APIs.\n      StringRef CalleeName =\
  \ getCalleeName(CE);\n      if (isSpinLockName(CalleeName)) {\n        ++LockDepth;\n\
  \      } else if (isSpinUnlockName(CalleeName)) {\n        if (LockDepth > 0)\n\
  \          --LockDepth;\n        if (LockDepth == 0)\n          PendingCheckedFields.clear();\n\
  \      }\n      // Recurse into callee/args to discover nested calls/exprs.\n  \
  \  }\n\n    // Generic recursion for children.\n    for (const Stmt *Child : S->children())\
  \ {\n      if (Child)\n        scanStmt(Child, Ctx, CurFunc, LockDepth, PendingCheckedFields);\n\
  \    }\n  }\n};\n\nvoid SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager\
  \ &Mgr, BugReporter &BR) const {\n  const auto *FD = dyn_cast<FunctionDecl>(D);\n\
  \  if (!FD || !FD->hasBody())\n    return;\n\n  const Stmt *Body = FD->getBody();\n\
  \  ASTContext &Ctx = FD->getASTContext();\n\n  int LockDepth = 0;\n  llvm::SmallSet<const\
  \ FieldDecl*, 8> PendingCheckedFields;\n\n  scanStmt(Body, Ctx, FD, LockDepth, PendingCheckedFields);\n\
  }\n\nvoid SAGenTestChecker::checkEndAnalysis(ExplodedGraph &G, BugReporter &BR,\
  \ ExprEngine &Eng) const {\n  if (LockedCTUFields.empty() || UnlockedNullWrites.empty())\n\
  \    return;\n\n  const SourceManager &SM = BR.getSourceManager();\n\n  for (const\
  \ auto &W : UnlockedNullWrites) {\n    if (!W.FD) continue;\n    if (!LockedCTUFields.count(W.FD))\n\
  \      continue;\n\n    // Build a concise message, include field name.\n    std::string\
  \ Msg = \"Unlocked write to '\";\n    Msg += W.FD->getNameAsString();\n    Msg +=\
  \ \" = NULL' may race with locked check-then-use, causing NULL dereference\";\n\n\
  \    PathDiagnosticLocation Loc(W.SR.getBegin(), SM);\n\n    auto R = std::make_unique<BasicBugReport>(*BT,\
  \ Msg, Loc);\n    R->addRange(W.SR);\n    BR.emitReport(std::move(R));\n  }\n}\n\
  \n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect inconsistent locking: unlocked NULL write may race with locked\
  \ check-then-use\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
