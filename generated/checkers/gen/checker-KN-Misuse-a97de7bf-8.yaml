_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: a97de7bff13b1cc825c1b1344eaed8d6c2d3e695
commit_type: Misuse
index: 8
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"\
  clang/AST/Expr.h\"\n#include \"clang/Lex/Lexer.h\"\n#include <string>\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states required.\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unsafe setsockopt copy\", \"API Misuse\")) {}\n\n   \
  \   void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\
  \      // Helpers\n      bool isCopyFromSockptrFamily(const CallEvent &Call, CheckerContext\
  \ &C,\n                                   unsigned &LenIdx) const;\n\n      bool\
  \ inSetsockoptFunctionWithParams(const CheckerContext &C,\n                    \
  \                      const FunctionDecl *&FD,\n                              \
  \            const VarDecl *&OptlenVD,\n                                       \
  \   const VarDecl *&OptvalVD) const;\n\n      void report(CheckerContext &C, const\
  \ Stmt *S, StringRef Msg) const;\n};\n\nbool SAGenTestChecker::isCopyFromSockptrFamily(const\
  \ CallEvent &Call, CheckerContext &C,\n                                        \
  \       unsigned &LenIdx) const {\n  const Expr *OE = Call.getOriginExpr();\n  if\
  \ (!OE)\n    return false;\n\n  // Exclude the correct helper.\n  if (ExprHasName(OE,\
  \ \"bt_copy_from_sockptr\", C))\n    return false;\n\n  // copy_from_sockptr_offset(dst,\
  \ optval, offset, len)\n  if (ExprHasName(OE, \"copy_from_sockptr_offset\", C))\
  \ {\n    if (Call.getNumArgs() < 4)\n      return false;\n    LenIdx = 3;\n    return\
  \ true;\n  }\n\n  // copy_from_sockptr(dst, optval, len)\n  if (ExprHasName(OE,\
  \ \"copy_from_sockptr\", C)) {\n    if (Call.getNumArgs() < 3)\n      return false;\n\
  \    LenIdx = 2;\n    return true;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::inSetsockoptFunctionWithParams(const\
  \ CheckerContext &C,\n                                                      const\
  \ FunctionDecl *&FD,\n                                                      const\
  \ VarDecl *&OptlenVD,\n                                                      const\
  \ VarDecl *&OptvalVD) const {\n  OptlenVD = nullptr;\n  OptvalVD = nullptr;\n  const\
  \ LocationContext *LCtx = C.getLocationContext();\n  if (!LCtx)\n    return false;\n\
  \n  const Decl *D = LCtx->getDecl();\n  FD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!FD)\n    return false;\n\n  std::string Name = FD->getNameAsString();\n\
  \  if (Name.find(\"setsockopt\") == std::string::npos)\n    return false;\n\n  for\
  \ (const ParmVarDecl *P : FD->parameters()) {\n    if (!P)\n      continue;\n  \
  \  StringRef PName = P->getName();\n    if (PName == \"optlen\") {\n      OptlenVD\
  \ = P;\n    } else if (PName == \"optval\") {\n      OptvalVD = P;\n    }\n  }\n\
  \n  if (!OptlenVD || !OptvalVD)\n    return false;\n\n  // Optionally ensure optlen\
  \ is an integer type.\n  if (!OptlenVD->getType()->isIntegerType())\n    return\
  \ false;\n\n  return true;\n}\n\nvoid SAGenTestChecker::report(CheckerContext &C,\
  \ const Stmt *S, StringRef Msg) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  unsigned LenIdx = 0;\n  if (!isCopyFromSockptrFamily(Call, C, LenIdx))\n\
  \    return;\n\n  const FunctionDecl *FD = nullptr;\n  const VarDecl *OptlenVD =\
  \ nullptr;\n  const VarDecl *OptvalVD = nullptr;\n  if (!inSetsockoptFunctionWithParams(C,\
  \ FD, OptlenVD, OptvalVD))\n    return;\n\n  // Get the length expression.\n  if\
  \ (LenIdx >= Call.getNumArgs())\n    return;\n\n  const Expr *LenE = Call.getArgExpr(LenIdx);\n\
  \  if (!LenE)\n    return;\n\n  // Partial-copy pattern: passing optlen directly\
  \ or via expression mentioning it.\n  if (ExprHasName(LenE, \"optlen\", C)) {\n\
  \    report(C, LenE, \"setsockopt copies partial user buffer; reject short optlen\"\
  );\n    return;\n  }\n\n  // Try to resolve length to a constant K (e.g., sizeof(u32),\
  \ sizeof(*dst)).\n  llvm::APSInt EvalRes;\n  if (!EvaluateExprToInt(EvalRes, LenE,\
  \ C)) {\n    // Not a known constant length; keep conservative and do not report.\n\
  \    return;\n  }\n\n  ProgramStateRef State = C.getState();\n  if (!State)\n  \
  \  return;\n\n  // Fetch the symbolic value of 'optlen'.\n  MemRegionManager &MRMgr\
  \ = State->getRegionManager();\n  const MemRegion *OptlenRegion = MRMgr.getVarRegion(OptlenVD,\
  \ C.getLocationContext());\n  if (!OptlenRegion)\n    return;\n\n  SVal OptlenVal\
  \ = State->getSVal(loc::MemRegionVal(OptlenRegion));\n  if (OptlenVal.isUnknownOrUndef())\n\
  \    return;\n\n  SValBuilder &SB = C.getSValBuilder();\n\n  // Create constant\
  \ K SVal.\n  SVal KVal = SB.makeIntVal(EvalRes);\n\n  // Build comparison: optlen\
  \ >= K\n  SVal Cond = SB.evalBinOp(State, BO_GE, OptlenVal, KVal, C.getASTContext().IntTy);\n\
  \  if (Cond.isUnknownOrUndef())\n    return;\n\n  DefinedOrUnknownSVal D = Cond.castAs<DefinedOrUnknownSVal>();\n\
  \  ProgramStateRef StateTrue = State->assume(D, true);\n  ProgramStateRef StateFalse\
  \ = State->assume(D, false);\n\n  // If not definitely true (i.e., StateFalse exists),\
  \ report.\n  if (StateFalse) {\n    report(C, LenE, \"copy_from_sockptr without\
  \ validating optlen\");\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects unsafe copy_from_sockptr in\
  \ setsockopt without validating optlen, or partial-copy patterns\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: RFCOMM: Fix not validating setsockopt user\
  \ input\n\nsyzbot reported rfcomm_sock_setsockopt_old() is copying data without\n\
  checking user input length.\n\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset\n\
  include/linux/sockptr.h:49 [inline]\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr\n\
  include/linux/sockptr.h:55 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt_old\n\
  net/bluetooth/rfcomm/sock.c:632 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt+0x893/0xa70\n\
  net/bluetooth/rfcomm/sock.c:673\nRead of size 4 at addr ffff8880209a8bc3 by task\
  \ syz-executor632/5064\n\nFixes: 9f2c8a03fbb3 (\"Bluetooth: Replace RFCOMM link\
  \ mode with security level\")\nFixes: bb23c0ab8246 (\"Bluetooth: Add support for\
  \ deferring RFCOMM connection setup\")\nReported-by: syzbot <syzkaller@googlegroups.com>\n\
  Signed-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Luiz Augusto von\
  \ Dentz <luiz.von.dentz@intel.com>\n\n## Buggy Code\n\n```c\n// Function: rfcomm_sock_setsockopt\
  \ in net/bluetooth/rfcomm/sock.c\nstatic int rfcomm_sock_setsockopt(struct socket\
  \ *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\
  \tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint err = 0;\n\tsize_t\
  \ len;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\
  \treturn rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level\
  \ != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname)\
  \ {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\
  \t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned\
  \ int, sizeof(sec), optlen);\n\t\tif (copy_from_sockptr(&sec, optval, len)) {\n\t\
  \t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level > BT_SECURITY_HIGH)\
  \ {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\trfcomm_pi(sk)->sec_level =\
  \ sec.level;\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND\
  \ && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\
  \t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\
  \t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\
  \t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\n\t\tbreak;\n\
  \n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\t\
  return err;\n}\n```\n\n```c\n// Function: rfcomm_sock_setsockopt_old in net/bluetooth/rfcomm/sock.c\n\
  static int rfcomm_sock_setsockopt_old(struct socket *sock, int optname,\n\t\tsockptr_t\
  \ optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\
  \tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname)\
  \ {\n\tcase RFCOMM_LM:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\
  \t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_FIPS) {\n\t\
  \t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_AUTH)\n\t\t\t\
  rfcomm_pi(sk)->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & RFCOMM_LM_ENCRYPT)\n\t\
  \t\trfcomm_pi(sk)->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & RFCOMM_LM_SECURE)\n\
  \t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_HIGH;\n\n\t\trfcomm_pi(sk)->role_switch\
  \ = (opt & RFCOMM_LM_MASTER);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\
  \t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\
  \n```diff\ndiff --git a/net/bluetooth/rfcomm/sock.c b/net/bluetooth/rfcomm/sock.c\n\
  index b54e8a530f55..29aa07e9db9d 100644\n--- a/net/bluetooth/rfcomm/sock.c\n+++\
  \ b/net/bluetooth/rfcomm/sock.c\n@@ -629,7 +629,7 @@ static int rfcomm_sock_setsockopt_old(struct\
  \ socket *sock, int optname,\n \n \tswitch (optname) {\n \tcase RFCOMM_LM:\n-\t\t\
  if (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n+\t\tif (bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen)) {\n \t\t\terr = -EFAULT;\n \t\t\tbreak;\n \t\t}\n\
  @@ -664,7 +664,6 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level,\
  \ int optname,\n \tstruct sock *sk = sock->sk;\n \tstruct bt_security sec;\n \t\
  int err = 0;\n-\tsize_t len;\n \tu32 opt;\n \n \tBT_DBG(\"sk %p\", sk);\n@@ -686,11\
  \ +685,9 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level, int\
  \ optname,\n \n \t\tsec.level = BT_SECURITY_LOW;\n \n-\t\tlen = min_t(unsigned int,\
  \ sizeof(sec), optlen);\n-\t\tif (copy_from_sockptr(&sec, optval, len)) {\n-\t\t\
  \terr = -EFAULT;\n+\t\terr = bt_copy_from_sockptr(&sec, sizeof(sec), optval, optlen);\n\
  +\t\tif (err)\n \t\t\tbreak;\n-\t\t}\n \n \t\tif (sec.level > BT_SECURITY_HIGH)\
  \ {\n \t\t\terr = -EINVAL;\n@@ -706,10 +703,9 @@ static int rfcomm_sock_setsockopt(struct\
  \ socket *sock, int level, int optname,\n \t\t\tbreak;\n \t\t}\n \n-\t\tif (copy_from_sockptr(&opt,\
  \ optval, sizeof(u32))) {\n-\t\t\terr = -EFAULT;\n+\t\terr = bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen);\n+\t\tif (err)\n \t\t\tbreak;\n-\t\t}\n \n \t\t\
  if (opt)\n \t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n```\n"
pattern: '## Bug Pattern


  Copying setsockopt() user data from a sockptr without validating optlen against
  the expected size:


  - Using copy_from_sockptr(&dst, optval, sizeof(dst)) with no check that optlen >=
  sizeof(dst), causing out-of-bounds reads when the user provides a shorter buffer.

  - For structs, copying only min(sizeof(struct), optlen) bytes and accepting partial
  input instead of rejecting short buffers, which can lead to inconsistencies or use
  of partially initialized data.


  Correct pattern: ensure optlen is sufficient (e.g., via a helper like bt_copy_from_sockptr(dst,
  sizeof(*dst), optval, optlen) or explicit optlen >= sizeof checks) before copying.'
plan: "1) Program state\n- No custom program state is required. We will leverage the\
  \ analyzer\u2019s existing path constraints and assume machinery to check whether\
  \ the current path guarantees optlen is large enough.\n\n2) Callbacks and implementation\n\
  \n- checkPreCall\n  Goal: Detect unsafe copies from sockptr in setsockopt handlers\
  \ where optlen is not validated against the destination size, and detect partial-copy\
  \ patterns (min or passing optlen directly).\n\n  Steps:\n  1. Identify target calls:\n\
  \     - Only act on calls whose callee identifier is one of:\n       - \"copy_from_sockptr\"\
  \n       - \"copy_from_sockptr_offset\"\n     - Ignore \"bt_copy_from_sockptr\"\
  \ (it is the correct helper).\n  2. Restrict the context to setsockopt-like functions:\n\
  \     - Get the current FunctionDecl from C.getLocationContext()->getDecl().\n \
  \    - Return early unless:\n       - The function name contains \"setsockopt\"\
  \ (case-sensitive substring match), and\n       - It has a parameter named \"optlen\"\
  \ of integer type, and a parameter named \"optval\" (usually sockptr_t). Prefer\
  \ exact name matches via Param->getNameAsString() == \"optlen\"/\"optval\" for robustness\
  \ in the kernel style.\n     - Record the VarDecl* for the \"optlen\" parameter.\
  \ We\u2019ll use it to fetch its SVal.\n  3. Extract the length argument:\n    \
  \ - For copy_from_sockptr, the length is argument index 2 (dst, optval, len).\n\
  \     - For copy_from_sockptr_offset, the length is argument index 3 (dst, optval,\
  \ offset, len).\n     - Obtain const Expr *LenE = Call.getArgExpr(IdxLen).\n  4.\
  \ Flag partial-copy pattern immediately:\n     - If ExprHasName(LenE, \"optlen\"\
  , C) returns true (length expression mentions optlen), report a bug:\n       - Message:\
  \ \"setsockopt copies partial user buffer; reject short optlen\"\n       - Rationale:\
  \ Passing optlen straight (or via min() macros) permits partial copies, which is\
  \ forbidden; the correct approach is to require optlen to be at least the expected\
  \ size and copy that size.\n     - Do not proceed further for this call path (we\
  \ already reported).\n  5. If not partial-copy, try to resolve a constant expected\
  \ size:\n     - Attempt EvaluateExprToInt on LenE. If it succeeds, let K be the\
  \ resulting integer (APSInt -> uint64_t).\n       - Typical examples: sizeof(u32),\
  \ sizeof(*dst), sizeof(struct xyz), etc.\n     - If EvaluateExprToInt fails, return\
  \ without a report (we keep the checker simple and only reason about known constant\
  \ sizes).\n  6. Check that the current path guarantees optlen >= K:\n     - Fetch\
  \ SVal of the \"optlen\" parameter: SVal OptlenSV = State->getSVal(DeclRefExpr constructed\
  \ from the VarDecl, LCtx). Convert it to NonLoc as needed.\n     - Build a NonLoc\
  \ constant for K using SValBuilder (e.g., makeIntVal(K, OptlenType)).\n     - Build\
  \ a comparison NonLoc CondGE = (optlen >= K) via SValBuilder.evalBinOpNN.\n    \
  \ - Query feasibility using ProgramStateRef:\n       - STrue = State->assume(CondGE,\
  \ true)\n       - SFalse = State->assume(CondGE, false)\n       - If SFalse is null,\
  \ then CondGE is definitely true on this path \u21D2 SAFE, do nothing.\n       -\
  \ Otherwise (STrue non-null and SFalse non-null, or STrue null), it is not guaranteed\
  \ that optlen >= K on this path \u21D2 report a bug:\n         - Message: \"copy_from_sockptr\
  \ without validating optlen\"\n  7. Reporting:\n     - Use generateNonFatalErrorNode\
  \ to get a node.\n     - Use std::make_unique<PathSensitiveBugReport> with a concise\
  \ message (as above).\n     - Attach LenE as the interesting location.\n\n- No other\
  \ callbacks are strictly necessary.\n\n3) Notes and heuristics\n\n- Why checkPreCall\
  \ is enough:\n  - The analyzer already maintains path constraints, so our assume-based\
  \ check will honor prior guards such as:\n    - if (optlen < sizeof(sec)) return\
  \ -EINVAL;\n    - if (optlen >= sizeof(u32)) { copy_from_sockptr(..., sizeof(u32));\
  \ }\n  - If those checks are present and effective, the optlen >= K assumption will\
  \ be provably true on the path that reaches the call, and we won\u2019t warn.\n\n\
  - What we flag:\n  - Calls to copy_from_sockptr/copy_from_sockptr_offset inside\
  \ a setsockopt handler that:\n    - Pass a constant size K but are not provably\
  \ guarded with optlen >= K on the current path.\n    - Pass any length expression\
  \ that mentions \"optlen\" (e.g., min_t(..., sizeof(*dst), optlen) or simply optlen).\n\
  \  - We do not flag calls to bt_copy_from_sockptr.\n\n- Utility functions to use:\n\
  \  - ExprHasName to quickly detect \"optlen\" presence in the length expression.\n\
  \  - EvaluateExprToInt to extract K from sizeof(...) and integer constants.\n\n\
  - Reduction of false positives:\n  - Limit to functions whose name contains \"setsockopt\"\
  \ and that have parameters named \"optval\" and \"optlen\".\n  - Require the length\
  \ expression to be either:\n    - A constant (so we can verify via assume), or\n\
  \    - An expression that explicitly involves \"optlen\" (which we treat as a bug\
  \ because it permits partial copies).\n  - Exclude bt_copy_from_sockptr calls.\n\
  \n- Messages:\n  - For missing validation: \"copy_from_sockptr without validating\
  \ optlen\"\n  - For partial copies: \"setsockopt copies partial user buffer; reject\
  \ short optlen\""
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"\
  clang/AST/Expr.h\"\n#include \"clang/Lex/Lexer.h\"\n#include <string>\n#include\
  \ <memory>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\
  \n// No custom program states required.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unsafe setsockopt\
  \ copy\", \"API Misuse\")) {}\n\n      void checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n\n   private:\n      // Helpers\n      bool isCopyFromSockptrFamily(const\
  \ CallEvent &Call, CheckerContext &C,\n                                   unsigned\
  \ &LenIdx) const;\n\n      bool inSetsockoptFunctionWithParams(const CheckerContext\
  \ &C,\n                                          const FunctionDecl *&FD,\n    \
  \                                      const VarDecl *&OptlenVD,\n             \
  \                             const VarDecl *&OptvalVD) const;\n\n      void report(CheckerContext\
  \ &C, const Stmt *S, StringRef Msg) const;\n};\n\nbool SAGenTestChecker::isCopyFromSockptrFamily(const\
  \ CallEvent &Call, CheckerContext &C,\n                                        \
  \       unsigned &LenIdx) const {\n  const Expr *OE = Call.getOriginExpr();\n  if\
  \ (!OE)\n    return false;\n\n  // Exclude the correct helper.\n  if (ExprHasName(OE,\
  \ \"bt_copy_from_sockptr\", C))\n    return false;\n\n  // copy_from_sockptr_offset(dst,\
  \ optval, offset, len)\n  if (ExprHasName(OE, \"copy_from_sockptr_offset\", C))\
  \ {\n    if (Call.getNumArgs() < 4)\n      return false;\n    LenIdx = 3;\n    return\
  \ true;\n  }\n\n  // copy_from_sockptr(dst, optval, len)\n  if (ExprHasName(OE,\
  \ \"copy_from_sockptr\", C)) {\n    if (Call.getNumArgs() < 3)\n      return false;\n\
  \    LenIdx = 2;\n    return true;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::inSetsockoptFunctionWithParams(const\
  \ CheckerContext &C,\n                                                      const\
  \ FunctionDecl *&FD,\n                                                      const\
  \ VarDecl *&OptlenVD,\n                                                      const\
  \ VarDecl *&OptvalVD) const {\n  OptlenVD = nullptr;\n  OptvalVD = nullptr;\n  const\
  \ LocationContext *LCtx = C.getLocationContext();\n  if (!LCtx)\n    return false;\n\
  \n  const Decl *D = LCtx->getDecl();\n  FD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!FD)\n    return false;\n\n  std::string Name = FD->getNameAsString();\n\
  \  if (Name.find(\"setsockopt\") == std::string::npos)\n    return false;\n\n  for\
  \ (const ParmVarDecl *P : FD->parameters()) {\n    if (!P)\n      continue;\n  \
  \  StringRef PName = P->getName();\n    if (PName == \"optlen\") {\n      OptlenVD\
  \ = P;\n    } else if (PName == \"optval\") {\n      OptvalVD = P;\n    }\n  }\n\
  \n  if (!OptlenVD || !OptvalVD)\n    return false;\n\n  // Optionally ensure optlen\
  \ is an integer type.\n  if (!OptlenVD->getType()->isIntegerType())\n    return\
  \ false;\n\n  return true;\n}\n\nvoid SAGenTestChecker::report(CheckerContext &C,\
  \ const Stmt *S, StringRef Msg) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  unsigned LenIdx = 0;\n  if (!isCopyFromSockptrFamily(Call, C, LenIdx))\n\
  \    return;\n\n  const FunctionDecl *FD = nullptr;\n  const VarDecl *OptlenVD =\
  \ nullptr;\n  const VarDecl *OptvalVD = nullptr;\n  if (!inSetsockoptFunctionWithParams(C,\
  \ FD, OptlenVD, OptvalVD))\n    return;\n\n  // Get the length expression.\n  if\
  \ (LenIdx >= Call.getNumArgs())\n    return;\n\n  const Expr *LenE = Call.getArgExpr(LenIdx);\n\
  \  if (!LenE)\n    return;\n\n  // Partial-copy pattern: passing optlen directly\
  \ or via expression mentioning it.\n  if (ExprHasName(LenE, \"optlen\", C)) {\n\
  \    report(C, LenE, \"setsockopt copies partial user buffer; reject short optlen\"\
  );\n    return;\n  }\n\n  // Try to resolve length to a constant K (e.g., sizeof(u32),\
  \ sizeof(*dst)).\n  llvm::APSInt EvalRes;\n  if (!EvaluateExprToInt(EvalRes, LenE,\
  \ C)) {\n    // Not a known constant length; keep conservative and do not report.\n\
  \    return;\n  }\n\n  ProgramStateRef State = C.getState();\n  if (!State)\n  \
  \  return;\n\n  // Fetch the symbolic value of 'optlen'.\n  MemRegionManager &MRMgr\
  \ = C.getSValBuilder().getRegionManager();\n  const MemRegion *OptlenRegion = MRMgr.getVarRegion(OptlenVD,\
  \ C.getLocationContext());\n  if (!OptlenRegion)\n    return;\n\n  SVal OptlenVal\
  \ = State->getSVal(loc::MemRegionVal(OptlenRegion));\n  if (OptlenVal.isUnknownOrUndef())\n\
  \    return;\n\n  SValBuilder &SB = C.getSValBuilder();\n\n  // Create constant\
  \ K SVal.\n  SVal KVal = SB.makeIntVal(EvalRes);\n\n  // Build comparison: optlen\
  \ >= K\n  SVal Cond = SB.evalBinOp(State, BO_GE, OptlenVal, KVal, C.getASTContext().IntTy);\n\
  \  if (Cond.isUnknownOrUndef())\n    return;\n\n  DefinedOrUnknownSVal D = Cond.castAs<DefinedOrUnknownSVal>();\n\
  \  ProgramStateRef StateTrue = State->assume(D, true);\n  ProgramStateRef StateFalse\
  \ = State->assume(D, false);\n\n  // If not definitely true (i.e., StateFalse exists),\
  \ report.\n  if (StateFalse) {\n    report(C, LenE, \"copy_from_sockptr without\
  \ validating optlen\");\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects unsafe copy_from_sockptr in\
  \ setsockopt without validating optlen, or partial-copy patterns\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
