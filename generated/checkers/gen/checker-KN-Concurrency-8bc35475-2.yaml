_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 8bc35475ef1a23b0e224f3242eb11c76cab0ea88
commit_type: Concurrency
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No custom program states\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Speculative\
  \ read before guard\", \"Concurrency\")) {}\n\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n\n      // Helper to\
  \ get the immediate previous sibling statement of an IfStmt within its enclosing\
  \ CompoundStmt.\n      const Stmt *getPrevSiblingStmt(const IfStmt *IS, CheckerContext\
  \ &C) const;\n\n      // Helper to check if guard is in acceptable simple forms.\n\
  \      bool isSimpleGuardExpr(const Expr *Guard, CheckerContext &C) const;\n\n \
  \     // Helper: whether expression references a specific VarDecl.\n      bool exprReferencesVar(const\
  \ Expr *E, const VarDecl *VD) const;\n\n      // Helper: detect risky reads (deref/array\
  \ subscript/ptr->field or kernel-specific call).\n      bool containsRiskyAccess(const\
  \ Expr *E, CheckerContext &C) const;\n\n      // Emit report\n      void reportBug(const\
  \ Expr *AssignedExpr, const IfStmt *IS, CheckerContext &C) const;\n};\n\nstatic\
  \ bool isZeroIntegerLiteral(const Expr *E) {\n  if (!E) return false;\n  E = E->IgnoreParenImpCasts();\n\
  \  if (const auto *IL = dyn_cast<IntegerLiteral>(E)) {\n    return IL->getValue()\
  \ == 0;\n  }\n  return false;\n}\n\nconst Stmt *SAGenTestChecker::getPrevSiblingStmt(const\
  \ IfStmt *IS, CheckerContext &C) const {\n  if (!IS) return nullptr;\n  const CompoundStmt\
  \ *CS = findSpecificTypeInParents<CompoundStmt>(IS, C);\n  if (!CS) return nullptr;\n\
  \n  const Stmt *Prev = nullptr;\n  for (const Stmt *S : CS->body()) {\n    if (S\
  \ == IS) {\n      return Prev;\n    }\n    Prev = S;\n  }\n  return nullptr;\n}\n\
  \nbool SAGenTestChecker::exprReferencesVar(const Expr *E, const VarDecl *VD) const\
  \ {\n  if (!E || !VD) return false;\n\n  // Check the current node after ignoring\
  \ implicit constructs\n  const Expr *EI = E->IgnoreImplicit();\n  if (const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(EI)) {\n    if (DRE->getDecl() == VD)\n      return\
  \ true;\n  }\n\n  // Recurse into children\n  for (const Stmt *Child : E->children())\
  \ {\n    const Expr *CE = dyn_cast_or_null<Expr>(Child);\n    if (CE && exprReferencesVar(CE,\
  \ VD))\n      return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::containsRiskyAccess(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E) return false;\n\n  // Heuristic:\
  \ kernel-specific helper name\n  if (ExprHasName(E, \"work_data_bits\", C))\n  \
  \  return true;\n\n  const Expr *EI = E->IgnoreImplicit();\n\n  if (const auto *UO\
  \ = dyn_cast<UnaryOperator>(EI)) {\n    if (UO->getOpcode() == UO_Deref)\n     \
  \ return true;\n  }\n\n  if (isa<ArraySubscriptExpr>(EI))\n    return true;\n\n\
  \  if (const auto *ME = dyn_cast<MemberExpr>(EI)) {\n    if (ME->isArrow())\n  \
  \    return true;\n  }\n\n  // Recurse\n  for (const Stmt *Child : EI->children())\
  \ {\n    const Expr *CE = dyn_cast_or_null<Expr>(Child);\n    if (CE && containsRiskyAccess(CE,\
  \ C))\n      return true;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isSimpleGuardExpr(const\
  \ Expr *Guard, CheckerContext &C) const {\n  if (!Guard) return false;\n  Guard\
  \ = Guard->IgnoreParenImpCasts();\n\n  // Case 1: Simple variable\n  if (isa<DeclRefExpr>(Guard))\n\
  \    return true;\n\n  // Case 2: !var\n  if (const auto *UO = dyn_cast<UnaryOperator>(Guard))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *Sub = UO->getSubExpr()->IgnoreParenImpCasts();\n\
  \      if (isa<DeclRefExpr>(Sub))\n        return true;\n    }\n  }\n\n  // Case\
  \ 3: var == 0/null or var != 0/null (also support 0 == var pattern)\n  if (const\
  \ auto *BO = dyn_cast<BinaryOperator>(Guard)) {\n    if (BO->getOpcode() == BO_EQ\
  \ || BO->getOpcode() == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n      bool LHSIsZeroOrNull\
  \ = isZeroIntegerLiteral(LHS) ||\n        LHS->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull);\n      bool RHSIsZeroOrNull = isZeroIntegerLiteral(RHS)\
  \ ||\n        RHS->isNullPointerConstant(C.getASTContext(), Expr::NPC_ValueDependentIsNull);\n\
  \n      if (LHSIsZeroOrNull && isa<DeclRefExpr>(RHS))\n        return true;\n  \
  \    if (RHSIsZeroOrNull && isa<DeclRefExpr>(LHS))\n        return true;\n    }\n\
  \  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::reportBug(const Expr *AssignedExpr,\
  \ const IfStmt *IS, CheckerContext &C) const {\n  if (!BT) return;\n\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Unconditional read occurs before guard; move the dereference under\
  \ the guarded path.\", N);\n\n  if (AssignedExpr)\n    R->addRange(AssignedExpr->getSourceRange());\n\
  \  if (IS && IS->getCond())\n    R->addRange(IS->getCond()->getSourceRange());\n\
  \n  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  // We only analyze IfStmt conditions.\n\
  \  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n    return;\n\n\
  \  const IfStmt *IS = findSpecificTypeInParents<IfStmt>(Condition, C);\n  if (!IS)\n\
  \    return;\n\n  const Expr *IfCond = IS->getCond();\n  if (!IfCond)\n    return;\n\
  \n  // Ensure this callback is for the condition expression of this IfStmt.\n  if\
  \ (IfCond->IgnoreImplicit() != CondE->IgnoreImplicit())\n    return;\n\n  // We\
  \ look for 'guard && rest'\n  const BinaryOperator *BO = dyn_cast<BinaryOperator>(CondE->IgnoreParenImpCasts());\n\
  \  if (!BO || BO->getOpcode() != BO_LAnd)\n    return;\n\n  const Expr *Guard =\
  \ BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *Rest  = BO->getRHS()->IgnoreParenImpCasts();\n\
  \n  if (!isSimpleGuardExpr(Guard, C))\n    return;\n\n  // Find the immediate previous\
  \ statement to this IfStmt\n  const Stmt *Prev = getPrevSiblingStmt(IS, C);\n  if\
  \ (!Prev)\n    return;\n\n  // Case 1: Declaration with initializer\n  const VarDecl\
  \ *DefinedVD = nullptr;\n  const Expr *AssignedExpr = nullptr;\n\n  if (const auto\
  \ *DS = dyn_cast<DeclStmt>(Prev)) {\n    if (!DS->isSingleDecl())\n      return;\n\
  \    const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());\n    if (!VD || !VD->hasInit())\n\
  \      return;\n    if (!VD->hasLocalStorage())\n      return;\n\n    DefinedVD\
  \ = VD;\n    AssignedExpr = VD->getInit();\n  } else {\n    // Case 2: Assignment\
  \ expression statement immediately preceding\n    // The child may be wrapped; use\
  \ helper to find a BinaryOperator inside\n    const BinaryOperator *AssignBO = findSpecificTypeInChildren<BinaryOperator>(Prev);\n\
  \    if (!AssignBO || AssignBO->getOpcode() != BO_Assign)\n      return;\n\n   \
  \ const Expr *LHS = AssignBO->getLHS()->IgnoreParenImpCasts();\n    const auto *LHSRef\
  \ = dyn_cast<DeclRefExpr>(LHS);\n    if (!LHSRef)\n      return;\n\n    const auto\
  \ *VD = dyn_cast<VarDecl>(LHSRef->getDecl());\n    if (!VD || !VD->hasLocalStorage())\n\
  \      return;\n\n    DefinedVD = VD;\n    AssignedExpr = AssignBO->getRHS();\n\
  \  }\n\n  if (!DefinedVD || !AssignedExpr)\n    return;\n\n  AssignedExpr = AssignedExpr->IgnoreParenImpCasts();\n\
  \n  // Ensure that the RHS of '&&' actually uses the defined variable\n  if (!exprReferencesVar(Rest,\
  \ DefinedVD))\n    return;\n\n  // The assignment should contain a risky access\
  \ (deref / arr subscript / ptr->field)\n  if (!containsRiskyAccess(AssignedExpr,\
  \ C))\n    return;\n\n  // All checks passed: report bug.\n  reportBug(AssignedExpr,\
  \ IS, C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects speculative reads placed before a guarding condition (e.g., data\
  \ race prone read before 'guard && ...')\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nworkqueue: Fix spruious data race in __flush_work()\n\
  \nWhen flushing a work item for cancellation, __flush_work() knows that it\nexclusively\
  \ owns the work item through its PENDING bit. 134874e2eee9\n(\"workqueue: Allow\
  \ cancel_work_sync() and disable_work() from atomic\ncontexts on BH work items\"\
  ) added a read of @work->data to determine whether\nto use busy wait for BH work\
  \ items that are being canceled. While the read\nis safe when @from_cancel, @work->data\
  \ was read before testing @from_cancel\nto simplify code structure:\n\n\tdata =\
  \ *work_data_bits(work);\n\tif (from_cancel &&\n\t    !WARN_ON_ONCE(data & WORK_STRUCT_PWQ)\
  \ && (data & WORK_OFFQ_BH)) {\n\nWhile the read data was never used if !@from_cancel,\
  \ this could trigger\nKCSAN data race detection spuriously:\n\n  ==================================================================\n\
  \  BUG: KCSAN: data-race in __flush_work / __flush_work\n\n  write to 0xffff8881223aa3e8\
  \ of 8 bytes by task 3998 on cpu 0:\n   instrument_write include/linux/instrumented.h:41\
  \ [inline]\n   ___set_bit include/asm-generic/bitops/instrumented-non-atomic.h:28\
  \ [inline]\n   insert_wq_barrier kernel/workqueue.c:3790 [inline]\n   start_flush_work\
  \ kernel/workqueue.c:4142 [inline]\n   __flush_work+0x30b/0x570 kernel/workqueue.c:4178\n\
  \   flush_work kernel/workqueue.c:4229 [inline]\n   ...\n\n  read to 0xffff8881223aa3e8\
  \ of 8 bytes by task 50 on cpu 1:\n   __flush_work+0x42a/0x570 kernel/workqueue.c:4188\n\
  \   flush_work kernel/workqueue.c:4229 [inline]\n   flush_delayed_work+0x66/0x70\
  \ kernel/workqueue.c:4251\n   ...\n\n  value changed: 0x0000000000400000 -> 0xffff88810006c00d\n\
  \nReorganize the code so that @from_cancel is tested before @work->data is\naccessed.\
  \ The only problem is triggering KCSAN detection spuriously. This\nshouldn't need\
  \ READ_ONCE() or other access qualifiers.\n\nNo functional changes.\n\nSigned-off-by:\
  \ Tejun Heo <tj@kernel.org>\nReported-by: syzbot+b3e4f2f51ed645fd5df2@syzkaller.appspotmail.com\n\
  Fixes: 134874e2eee9 (\"workqueue: Allow cancel_work_sync() and disable_work() from\
  \ atomic contexts on BH work items\")\nLink: http://lkml.kernel.org/r/000000000000ae429e061eea2157@google.com\n\
  Cc: Jens Axboe <axboe@kernel.dk>\n\n## Buggy Code\n\n```c\n// Function: __flush_work\
  \ in kernel/workqueue.c\nstatic bool __flush_work(struct work_struct *work, bool\
  \ from_cancel)\n{\n\tstruct wq_barrier barr;\n\tunsigned long data;\n\n\tif (WARN_ON(!wq_online))\n\
  \t\treturn false;\n\n\tif (WARN_ON(!work->func))\n\t\treturn false;\n\n\tif (!start_flush_work(work,\
  \ &barr, from_cancel))\n\t\treturn false;\n\n\t/*\n\t * start_flush_work() returned\
  \ %true. If @from_cancel is set, we know\n\t * that @work must have been executing\
  \ during start_flush_work() and\n\t * can't currently be queued. Its data must contain\
  \ OFFQ bits. If @work\n\t * was queued on a BH workqueue, we also know that it was\
  \ running in the\n\t * BH context and thus can be busy-waited.\n\t */\n\tdata =\
  \ *work_data_bits(work);\n\tif (from_cancel &&\n\t    !WARN_ON_ONCE(data & WORK_STRUCT_PWQ)\
  \ && (data & WORK_OFFQ_BH)) {\n\t\t/*\n\t\t * On RT, prevent a live lock when %current\
  \ preempted soft\n\t\t * interrupt processing or prevents ksoftirqd from running\
  \ by\n\t\t * keeping flipping BH. If the BH work item runs on a different\n\t\t\
  \ * CPU then this has no effect other than doing the BH\n\t\t * disable/enable dance\
  \ for nothing. This is copied from\n\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  \t\t */\n\t\twhile (!try_wait_for_completion(&barr.done)) {\n\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tlocal_bh_enable();\n\t\t\t} else {\n\t\
  \t\t\tcpu_relax();\n\t\t\t}\n\t\t}\n\t} else {\n\t\twait_for_completion(&barr.done);\n\
  \t}\n\n\tdestroy_work_on_stack(&barr.work);\n\treturn true;\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/kernel/workqueue.c b/kernel/workqueue.c\nindex\
  \ d56bd2277e58..ef174d8c1f63 100644\n--- a/kernel/workqueue.c\n+++ b/kernel/workqueue.c\n\
  @@ -4166,7 +4166,6 @@ static bool start_flush_work(struct work_struct *work, struct\
  \ wq_barrier *barr,\n static bool __flush_work(struct work_struct *work, bool from_cancel)\n\
  \ {\n \tstruct wq_barrier barr;\n-\tunsigned long data;\n \n \tif (WARN_ON(!wq_online))\n\
  \ \t\treturn false;\n@@ -4184,29 +4183,35 @@ static bool __flush_work(struct work_struct\
  \ *work, bool from_cancel)\n \t * was queued on a BH workqueue, we also know that\
  \ it was running in the\n \t * BH context and thus can be busy-waited.\n \t */\n\
  -\tdata = *work_data_bits(work);\n-\tif (from_cancel &&\n-\t    !WARN_ON_ONCE(data\
  \ & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_BH)) {\n-\t\t/*\n-\t\t * On RT, prevent\
  \ a live lock when %current preempted soft\n-\t\t * interrupt processing or prevents\
  \ ksoftirqd from running by\n-\t\t * keeping flipping BH. If the BH work item runs\
  \ on a different\n-\t\t * CPU then this has no effect other than doing the BH\n\
  -\t\t * disable/enable dance for nothing. This is copied from\n-\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  -\t\t */\n-\t\twhile (!try_wait_for_completion(&barr.done)) {\n-\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n-\t\t\t\tlocal_bh_disable();\n-\t\t\t\tlocal_bh_enable();\n-\t\t\t} else {\n\
  -\t\t\t\tcpu_relax();\n+\tif (from_cancel) {\n+\t\tunsigned long data = *work_data_bits(work);\n\
  +\n+\t\tif (!WARN_ON_ONCE(data & WORK_STRUCT_PWQ) &&\n+\t\t    (data & WORK_OFFQ_BH))\
  \ {\n+\t\t\t/*\n+\t\t\t * On RT, prevent a live lock when %current preempted\n+\t\
  \t\t * soft interrupt processing or prevents ksoftirqd from\n+\t\t\t * running by\
  \ keeping flipping BH. If the BH work item\n+\t\t\t * runs on a different CPU then\
  \ this has no effect other\n+\t\t\t * than doing the BH disable/enable dance for\
  \ nothing.\n+\t\t\t * This is copied from\n+\t\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  +\t\t\t */\n+\t\t\twhile (!try_wait_for_completion(&barr.done)) {\n+\t\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n+\t\t\t\t\tlocal_bh_disable();\n+\t\t\t\t\tlocal_bh_enable();\n+\t\t\t\t} else\
  \ {\n+\t\t\t\t\tcpu_relax();\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tgoto out_destroy;\n \t\
  \t}\n-\t} else {\n-\t\twait_for_completion(&barr.done);\n \t}\n \n+\twait_for_completion(&barr.done);\n\
  +\n+out_destroy:\n \tdestroy_work_on_stack(&barr.work);\n \treturn true;\n }\n```\n"
pattern: '## Bug Pattern


  Unconditional speculative read of a shared, concurrently updated field before validating
  the guard that establishes safe/exclusive access. Specifically, reading work->data
  outside the from_cancel check (i.e., before confirming the cancellation path that
  guarantees exclusive ownership) causes an unsynchronized access/data race, even
  if the value is later unused when the guard is false. The fix moves the read under
  the guarding condition.'
plan: "Plan\n\n1) Program state\n- No custom program state is needed. The pattern\
  \ is purely syntactic/structural around an if-condition and a preceding statement.\n\
  \n2) Callback functions\n- Use only checkBranchCondition. This lets us analyze every\
  \ IfStmt condition and look at its immediate syntactic context and predecessor statement.\n\
  \n3) Implementation steps in checkBranchCondition\n\nStep A: Retrieve the enclosing\
  \ IfStmt and its condition\n- From the incoming Condition, obtain the enclosing\
  \ IfStmt:\n  - const IfStmt *IS = findSpecificTypeInParents<IfStmt>(Condition, C).\n\
  \  - If null or IS->getCond()->IgnoreImplicit() != Condition->IgnoreImplicit(),\
  \ return.\n- Ensure the condition is a logical-and: BinaryOperator with opcode BO_LAnd.\n\
  \  - const BinaryOperator *BO = dyn_cast<BinaryOperator>(Condition->IgnoreImpCasts()).\n\
  \  - If not or opcode != BO_LAnd, return.\n- Extract the LHS (guard) and RHS (rest)\
  \ of the logical-and:\n  - const Expr *Guard = BO->getLHS()->IgnoreImpCasts();\n\
  \  - const Expr *Rest = BO->getRHS()->IgnoreImpCasts();\n\nStep B: Sanity-check\
  \ the guard form (reduce false positives)\n- Accept these guard forms:\n  - A boolean\
  \ DeclRefExpr to a variable or parameter (common guard pattern).\n  - A negation\
  \ or simple compare against 0/NULL on a DeclRefExpr.\n- If the guard is an arbitrary\
  \ complex expression (function calls, derefs), skip (return). This keeps the checker\
  \ focused on \u201Csimple boolean guard && uses-of-precomputed-value\u201D.\n\n\
  Step C: Find the immediate previous statement (Prev) to the IfStmt\n- Use the parent\
  \ CompoundStmt of the IfStmt to find its sibling order:\n  - const CompoundStmt\
  \ *CS = findSpecificTypeInParents<CompoundStmt>(IS, C); if null, return.\n  - Iterate\
  \ CS->body() to find IS; if found at index i, then if i == 0 return, else Prev =\
  \ body[i-1].\n- Only proceed if Prev is one of:\n  - An assignment statement: BinaryOperator\
  \ with opcode BO_Assign.\n  - A declaration with initializer: DeclStmt with exactly\
  \ one initialized VarDecl.\n\nStep D: Extract the variable defined in Prev and the\
  \ assigned expression\n- For BO_Assign:\n  - LHS must be a DeclRefExpr to a local\
  \ variable (const VarDecl *VD).\n  - AssignedExpr = BO->getRHS()->IgnoreImpCasts();\n\
  - For DeclStmt:\n  - Single VarDecl (const VarDecl *VD) with an initializer.\n \
  \ - AssignedExpr = VD->getInit()->IgnoreImpCasts();\n- If no single local VD or\
  \ no initializer, return.\n\nStep E: Check that Rest (RHS of &&) actually uses VD\n\
  - Implement a small helper bool exprReferencesVar(const Expr *E, const VarDecl *VD)\
  \ to recursively scan for DeclRefExpr nodes whose getDecl() == VD.\n  - If false,\
  \ return.\n- This ensures we are matching: if (guard && (\u2026 uses the computed\
  \ variable \u2026)).\n\nStep F: Check that AssignedExpr is a \u201Crisky read\u201D\
  \n- Implement helper bool isRiskyReadExpr(const Expr *E, CheckerContext &C):\n \
  \ - Return true if any of the following holds:\n    - E (or a subexpression) contains\
  \ a dereference: a UnaryOperator with opcode UO_Deref.\n    - E contains an ArraySubscriptExpr.\n\
  \    - E contains a MemberExpr with isArrow() (i.e., ptr->field).\n    - Heuristic:\
  \ E\u2019s source text contains \u201Cwork_data_bits\u201D (using ExprHasName(E,\
  \ \"work_data_bits\")) to catch the kernel-specific pattern even if deref appears\
  \ nested.\n  - Optional stricter heuristic to reduce false positives:\n    - If\
  \ a deref is found, inspect its base expression. If the base is (or is derived from)\
  \ a parameter (ParmVarDecl) or a global (hasGlobalStorage()), prefer reporting.\
  \ This targets \u201Cshared/concurrent\u201D objects more often than stack locals.\n\
  - If none of the risky patterns found, return.\n\nStep G: Emit the report\n- If\
  \ all checks pass, we have:\n  - An unconditional risky read computed in Prev.\n\
  \  - Immediately followed by an if (guard && \u2026 uses computed value \u2026).\n\
  \  - Report: This is exactly the anti-pattern: computing a potentially racy dereference\
  \ before ensuring the guard short-circuits the condition.\n- Create a bug type once\
  \ (e.g., in the checker constructor or lazily):\n  - std::unique_ptr<BugType> BT\
  \ = std::make_unique<BugType>(this, \"Speculative read before guard\", \"Concurrency\"\
  );\n- Generate a non-fatal error node at Prev or at AssignedExpr.\n- Emit a PathSensitiveBugReport\
  \ with a short message, for example:\n  - \u201CUnconditional read occurs before\
  \ guard; move the dereference under the guarded path.\u201D\n- Highlight the AssignedExpr\
  \ source range in the report.\n\n4) Notes on utilities and helpers\n- Use findSpecificTypeInParents\
  \ to get IfStmt, CompoundStmt.\n- Use ExprHasName to cheaply match \u201Cwork_data_bits\u201D\
  \ when present (improves catching the target kernel pattern).\n- Implement small\
  \ recursive visitors inside the checker for:\n  - exprReferencesVar(E, VD): walk\
  \ expression children to find DeclRefExpr bound to VD.\n  - isRiskyReadExpr(E, C):\
  \ walk expression to find UO_Deref, ArraySubscriptExpr, MemberExpr(isArrow), or\
  \ text match on \u201Cwork_data_bits\u201D.\n- Keep the match tight:\n  - Immediate\
  \ previous statement only.\n  - Guard must be the LHS of \u2018&&\u2019 (short-circuit\
  \ usage).\n  - Computed variable used only on RHS of \u2018&&\u2019 (via exprReferencesVar).\n\
  \n5) Optional extensions (can be added later)\n- Also flag: Prev computes from a\
  \ risky read, followed by if (guard) { \u2026 uses var \u2026 } (without \u2018\
  &&\u2019). This is a simpler but still relevant form. You can implement by:\n  -\
  \ In checkBranchCondition, when condition is a simple guard (no \u2018&&\u2019),\
  \ check if Prev defines a variable that is used only in the then-branch (scan the\
  \ Then body for use; ensure Else either absent or does not use the var).\n- Add\
  \ a small suppression if AssignedExpr clearly refers only to stack-local memory\
  \ (no globals, no parameters) to further reduce noise.\n\nThis minimal plan finds\
  \ the kernel bug pattern:\n- data = *work_data_bits(work); if (from_cancel && uses(data))\
  \ { \u2026 }\nand suggests moving the read inside the from_cancel guarded path."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No custom program states\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Speculative\
  \ read before guard\", \"Concurrency\")) {}\n\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n\n      // Helper to\
  \ get the immediate previous sibling statement of an IfStmt within its enclosing\
  \ CompoundStmt.\n      const Stmt *getPrevSiblingStmt(const IfStmt *IS, CheckerContext\
  \ &C) const;\n\n      // Helper to check if guard is in acceptable simple forms.\n\
  \      bool isSimpleGuardExpr(const Expr *Guard, CheckerContext &C) const;\n\n \
  \     // Helper: whether expression references a specific VarDecl.\n      bool exprReferencesVar(const\
  \ Expr *E, const VarDecl *VD) const;\n\n      // Helper: detect risky reads (deref/array\
  \ subscript/ptr->field or kernel-specific call).\n      bool containsRiskyAccess(const\
  \ Expr *E, CheckerContext &C) const;\n\n      // Emit report\n      void reportBug(const\
  \ Expr *AssignedExpr, const IfStmt *IS, CheckerContext &C) const;\n};\n\nstatic\
  \ bool isZeroIntegerLiteral(const Expr *E) {\n  if (!E) return false;\n  E = E->IgnoreParenImpCasts();\n\
  \  if (const auto *IL = dyn_cast<IntegerLiteral>(E)) {\n    return IL->getValue()\
  \ == 0;\n  }\n  return false;\n}\n\nconst Stmt *SAGenTestChecker::getPrevSiblingStmt(const\
  \ IfStmt *IS, CheckerContext &C) const {\n  if (!IS) return nullptr;\n  const CompoundStmt\
  \ *CS = findSpecificTypeInParents<CompoundStmt>(IS, C);\n  if (!CS) return nullptr;\n\
  \n  const Stmt *Prev = nullptr;\n  for (const Stmt *S : CS->body()) {\n    if (S\
  \ == IS) {\n      return Prev;\n    }\n    Prev = S;\n  }\n  return nullptr;\n}\n\
  \nbool SAGenTestChecker::exprReferencesVar(const Expr *E, const VarDecl *VD) const\
  \ {\n  if (!E || !VD) return false;\n\n  // Check the current node after ignoring\
  \ implicit constructs\n  const Expr *EI = E->IgnoreImplicit();\n  if (const auto\
  \ *DRE = dyn_cast<DeclRefExpr>(EI)) {\n    if (DRE->getDecl() == VD)\n      return\
  \ true;\n  }\n\n  // Recurse into children\n  for (const Stmt *Child : E->children())\
  \ {\n    const Expr *CE = dyn_cast_or_null<Expr>(Child);\n    if (CE && exprReferencesVar(CE,\
  \ VD))\n      return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::containsRiskyAccess(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E) return false;\n\n  // Heuristic:\
  \ kernel-specific helper name\n  if (ExprHasName(E, \"work_data_bits\", C))\n  \
  \  return true;\n\n  const Expr *EI = E->IgnoreImplicit();\n\n  if (const auto *UO\
  \ = dyn_cast<UnaryOperator>(EI)) {\n    if (UO->getOpcode() == UO_Deref)\n     \
  \ return true;\n  }\n\n  if (isa<ArraySubscriptExpr>(EI))\n    return true;\n\n\
  \  if (const auto *ME = dyn_cast<MemberExpr>(EI)) {\n    if (ME->isArrow())\n  \
  \    return true;\n  }\n\n  // Recurse\n  for (const Stmt *Child : EI->children())\
  \ {\n    const Expr *CE = dyn_cast_or_null<Expr>(Child);\n    if (CE && containsRiskyAccess(CE,\
  \ C))\n      return true;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isSimpleGuardExpr(const\
  \ Expr *Guard, CheckerContext &C) const {\n  if (!Guard) return false;\n  Guard\
  \ = Guard->IgnoreParenImpCasts();\n\n  // Case 1: Simple variable\n  if (isa<DeclRefExpr>(Guard))\n\
  \    return true;\n\n  // Case 2: !var\n  if (const auto *UO = dyn_cast<UnaryOperator>(Guard))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *Sub = UO->getSubExpr()->IgnoreParenImpCasts();\n\
  \      if (isa<DeclRefExpr>(Sub))\n        return true;\n    }\n  }\n\n  // Case\
  \ 3: var == 0/null or var != 0/null (also support 0 == var pattern)\n  if (const\
  \ auto *BO = dyn_cast<BinaryOperator>(Guard)) {\n    if (BO->getOpcode() == BO_EQ\
  \ || BO->getOpcode() == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n      bool LHSIsZeroOrNull\
  \ = isZeroIntegerLiteral(LHS) ||\n        LHS->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull);\n      bool RHSIsZeroOrNull = isZeroIntegerLiteral(RHS)\
  \ ||\n        RHS->isNullPointerConstant(C.getASTContext(), Expr::NPC_ValueDependentIsNull);\n\
  \n      if (LHSIsZeroOrNull && isa<DeclRefExpr>(RHS))\n        return true;\n  \
  \    if (RHSIsZeroOrNull && isa<DeclRefExpr>(LHS))\n        return true;\n    }\n\
  \  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::reportBug(const Expr *AssignedExpr,\
  \ const IfStmt *IS, CheckerContext &C) const {\n  if (!BT) return;\n\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Unconditional read occurs before guard; move the dereference under\
  \ the guarded path.\", N);\n\n  if (AssignedExpr)\n    R->addRange(AssignedExpr->getSourceRange());\n\
  \  if (IS && IS->getCond())\n    R->addRange(IS->getCond()->getSourceRange());\n\
  \n  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  // We only analyze IfStmt conditions.\n\
  \  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n    return;\n\n\
  \  const IfStmt *IS = findSpecificTypeInParents<IfStmt>(Condition, C);\n  if (!IS)\n\
  \    return;\n\n  const Expr *IfCond = IS->getCond();\n  if (!IfCond)\n    return;\n\
  \n  // Ensure this callback is for the condition expression of this IfStmt.\n  if\
  \ (IfCond->IgnoreImplicit() != CondE->IgnoreImplicit())\n    return;\n\n  // We\
  \ look for 'guard && rest'\n  const BinaryOperator *BO = dyn_cast<BinaryOperator>(CondE->IgnoreParenImpCasts());\n\
  \  if (!BO || BO->getOpcode() != BO_LAnd)\n    return;\n\n  const Expr *Guard =\
  \ BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *Rest  = BO->getRHS()->IgnoreParenImpCasts();\n\
  \n  if (!isSimpleGuardExpr(Guard, C))\n    return;\n\n  // Find the immediate previous\
  \ statement to this IfStmt\n  const Stmt *Prev = getPrevSiblingStmt(IS, C);\n  if\
  \ (!Prev)\n    return;\n\n  // Case 1: Declaration with initializer\n  const VarDecl\
  \ *DefinedVD = nullptr;\n  const Expr *AssignedExpr = nullptr;\n\n  if (const auto\
  \ *DS = dyn_cast<DeclStmt>(Prev)) {\n    if (!DS->isSingleDecl())\n      return;\n\
  \    const auto *VD = dyn_cast<VarDecl>(DS->getSingleDecl());\n    if (!VD || !VD->hasInit())\n\
  \      return;\n    if (!VD->hasLocalStorage())\n      return;\n\n    DefinedVD\
  \ = VD;\n    AssignedExpr = VD->getInit();\n  } else {\n    // Case 2: Assignment\
  \ expression statement immediately preceding\n    // The child may be wrapped; use\
  \ helper to find a BinaryOperator inside\n    const BinaryOperator *AssignBO = findSpecificTypeInChildren<BinaryOperator>(Prev);\n\
  \    if (!AssignBO || AssignBO->getOpcode() != BO_Assign)\n      return;\n\n   \
  \ const Expr *LHS = AssignBO->getLHS()->IgnoreParenImpCasts();\n    const auto *LHSRef\
  \ = dyn_cast<DeclRefExpr>(LHS);\n    if (!LHSRef)\n      return;\n\n    const auto\
  \ *VD = dyn_cast<VarDecl>(LHSRef->getDecl());\n    if (!VD || !VD->hasLocalStorage())\n\
  \      return;\n\n    DefinedVD = VD;\n    AssignedExpr = AssignBO->getRHS();\n\
  \  }\n\n  if (!DefinedVD || !AssignedExpr)\n    return;\n\n  AssignedExpr = AssignedExpr->IgnoreParenImpCasts();\n\
  \n  // Ensure that the RHS of '&&' actually uses the defined variable\n  if (!exprReferencesVar(Rest,\
  \ DefinedVD))\n    return;\n\n  // The assignment should contain a risky access\
  \ (deref / arr subscript / ptr->field)\n  if (!containsRiskyAccess(AssignedExpr,\
  \ C))\n    return;\n\n  // All checks passed: report bug.\n  reportBug(AssignedExpr,\
  \ IS, C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects speculative reads placed before a guarding condition (e.g., data\
  \ race prone read before 'guard && ...')\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
