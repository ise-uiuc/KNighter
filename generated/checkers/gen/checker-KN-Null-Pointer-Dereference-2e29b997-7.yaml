_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 2e29b9971ac54dec88baa58856a230ec2f2a2dff
commit_type: Null-Pointer-Dereference
index: 7
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program state: Remember\
  \ the lvalue region that received the latest allocation result\nREGISTER_TRAIT_WITH_PROGRAMSTATE(PendingAllocRegion,\
  \ const MemRegion*)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::PostCall,\n        check::BranchCondition,\n        check::BeginFunction,\n\
  \        check::EndFunction> {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n\
  \  SAGenTestChecker()\n      : BT(new BugType(this, \"Mismatched NULL check after\
  \ allocation\",\n                       \"Logic error\")) {}\n\n  void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n  void checkBeginFunction(CheckerContext\
  \ &C) const;\n  void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;\n\
  \nprivate:\n  // Helpers\n  static bool isAllocator(const CallEvent &Call, CheckerContext\
  \ &C);\n  const MemRegion *getAssignedLHSRegionForCall(const CallEvent &Call,\n\
  \                                               CheckerContext &C) const;\n\n  static\
  \ bool isNullCheck(const Expr *Cond, const Expr *&CheckedExpr,\n               \
  \           CheckerContext &C);\n  static bool sameRegion(const MemRegion *A, const\
  \ MemRegion *B) {\n    if (!A || !B)\n      return false;\n    A = A->getBaseRegion();\n\
  \    B = B->getBaseRegion();\n    return A == B;\n  }\n\n  void reportMismatch(const\
  \ Stmt *Condition, CheckerContext &C) const;\n};\n\n// Determine if the call is\
  \ to a known allocator.\nbool SAGenTestChecker::isAllocator(const CallEvent &Call,\
  \ CheckerContext &C) {\n  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n\
  \    return false;\n\n  // Use the provided ExprHasName helper for robust name checks.\n\
  \  static const char *Names[] = {\n      \"kzalloc\", \"kmalloc\", \"kcalloc\",\
  \ \"kmalloc_array\",\n      \"devm_kzalloc\", \"vmalloc\", \"kvzalloc\", \"kmemdup\"\
  };\n  for (const char *N : Names) {\n    if (ExprHasName(OriginExpr, N, C))\n  \
  \    return true;\n  }\n  return false;\n}\n\n// Find the lvalue region to which\
  \ the allocation result is assigned.\n// Handles patterns:\n//   - X = alloc(...);\n\
  //   - type X = alloc(...);\nconst MemRegion *SAGENTestChecker_getRegionFromVarDecl(const\
  \ VarDecl *VD,\n                                                       CheckerContext\
  \ &C) {\n  if (!VD)\n    return nullptr;\n  const LocationContext *LCtx = C.getLocationContext();\n\
  \  SVal L = C.getSValBuilder().getLValue(VD, LCtx);\n  const MemRegion *MR = L.getAsRegion();\n\
  \  if (!MR)\n    return nullptr;\n  return MR->getBaseRegion();\n}\n\nconst MemRegion\
  \ *\nSAGenTestChecker::getAssignedLHSRegionForCall(const CallEvent &Call,\n    \
  \                                          CheckerContext &C) const {\n  const Expr\
  \ *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n    return nullptr;\n\
  \n  const CallExpr *CE = dyn_cast<CallExpr>(OriginExpr);\n  if (!CE)\n    return\
  \ nullptr;\n\n  // First, try to find an assignment 'LHS = <this call>'\n  if (const\
  \ auto *BO = findSpecificTypeInParents<BinaryOperator>(CE, C)) {\n    if (BO->getOpcode()\
  \ == BO_Assign) {\n      const Expr *RHS = BO->getRHS();\n      if (!RHS)\n    \
  \    return nullptr;\n      const Expr *RHSNoC = RHS->IgnoreParenImpCasts();\n \
  \     const Expr *CENoC = CE->IgnoreParenImpCasts();\n      if (RHSNoC == CENoC)\
  \ {\n        const Expr *LHS = BO->getLHS();\n        if (!LHS)\n          return\
  \ nullptr;\n        const MemRegion *MR = getMemRegionFromExpr(LHS, C);\n      \
  \  if (!MR)\n          return nullptr;\n        return MR->getBaseRegion();\n  \
  \    }\n    }\n  }\n\n  // Next, try a variable declaration with initializer 'type\
  \ X = <this call>'\n  if (const auto *DS = findSpecificTypeInParents<DeclStmt>(CE,\
  \ C)) {\n    const Expr *CENoC = CE->IgnoreParenImpCasts();\n    for (const Decl\
  \ *D : DS->decls()) {\n      if (const auto *VD = dyn_cast<VarDecl>(D)) {\n    \
  \    if (const Expr *Init = VD->getInit()) {\n          const Expr *InitNoC = Init->IgnoreParenImpCasts();\n\
  \          if (InitNoC == CENoC) {\n            return SAGENTestChecker_getRegionFromVarDecl(VD,\
  \ C);\n          }\n        }\n      }\n    }\n  }\n\n  return nullptr;\n}\n\n//\
  \ Identify explicit NULL checks and extract the checked expression.\n// Recognizes:\
  \ !ptr, ptr == NULL/0, ptr != NULL/0.\n// Does NOT treat \"if (ptr)\" as a NULL-check\
  \ for this pattern.\nbool SAGenTestChecker::isNullCheck(const Expr *Cond, const\
  \ Expr *&CheckedExpr,\n                                   CheckerContext &C) {\n\
  \  if (!Cond)\n    return false;\n\n  const ASTContext &ACtx = C.getASTContext();\n\
  \  const Expr *E = Cond->IgnoreParenCasts();\n\n  // !ptr\n  if (const auto *UO\
  \ = dyn_cast<UnaryOperator>(E)) {\n    if (UO->getOpcode() == UO_LNot) {\n     \
  \ const Expr *Sub = UO->getSubExpr();\n      if (!Sub)\n        return false;\n\
  \      CheckedExpr = Sub->IgnoreParenImpCasts();\n      return true;\n    }\n  \
  \  return false;\n  }\n\n  // ptr == NULL/0 or ptr != NULL/0\n  if (const auto *BO\
  \ = dyn_cast<BinaryOperator>(E)) {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n\
  \    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr *LHS = BO->getLHS();\n\
  \      const Expr *RHS = BO->getRHS();\n      if (!LHS || !RHS)\n        return\
  \ false;\n\n      auto IsNullLike = [&](const Expr *X) -> bool {\n        return\
  \ X->isNullPointerConstant(ACtx, Expr::NPC_ValueDependentIsNull) ||\n          \
  \     ExprHasName(X, \"NULL\", C);\n      };\n\n      const Expr *LHSNoC = LHS->IgnoreParenImpCasts();\n\
  \      const Expr *RHSNoC = RHS->IgnoreParenImpCasts();\n\n      bool LHSIsNull\
  \ = IsNullLike(LHSNoC);\n      bool RHSIsNull = IsNullLike(RHSNoC);\n\n      if\
  \ (LHSIsNull && !RHSIsNull) {\n        CheckedExpr = RHSNoC;\n        return true;\n\
  \      }\n      if (RHSIsNull && !LHSIsNull) {\n        CheckedExpr = LHSNoC;\n\
  \        return true;\n      }\n      return false;\n    }\n    return false;\n\
  \  }\n\n  // Do not treat other truthiness checks as NULL-checks.\n  return false;\n\
  }\n\nvoid SAGenTestChecker::reportMismatch(const Stmt *Condition,\n            \
  \                          CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Mismatched NULL check: checks a different pointer than the newly \"\
  \n           \"allocated one\",\n      N);\n  if (Condition)\n    R->addRange(Condition->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call,\n                                     CheckerContext &C) const\
  \ {\n  if (!isAllocator(Call, C))\n    return;\n\n  // Only track when the allocator\
  \ return value is assigned to some lvalue.\n  const MemRegion *LHSRegion = getAssignedLHSRegionForCall(Call,\
  \ C);\n  if (!LHSRegion)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  State = State->set<PendingAllocRegion>(LHSRegion->getBaseRegion());\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\n      \
  \                                      CheckerContext &C) const {\n  ProgramStateRef\
  \ State = C.getState();\n  const MemRegion *Pending = State->get<PendingAllocRegion>();\n\
  \  if (!Pending)\n    return;\n\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE) {\n    // Not an expression; clear pending and move on.\n    State\
  \ = State->remove<PendingAllocRegion>();\n    C.addTransition(State);\n    return;\n\
  \  }\n\n  const Expr *CheckedExpr = nullptr;\n  if (!isNullCheck(CondE, CheckedExpr,\
  \ C)) {\n    // Not an explicit NULL check; clear pending to avoid stale state.\n\
  \    State = State->remove<PendingAllocRegion>();\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // Resolve the region of the checked expression.\n  const\
  \ MemRegion *CheckedReg = getMemRegionFromExpr(CheckedExpr, C);\n  if (!CheckedReg)\
  \ {\n    // Unable to map; clear pending and continue.\n    State = State->remove<PendingAllocRegion>();\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  CheckedReg = CheckedReg->getBaseRegion();\n\
  \  Pending = Pending->getBaseRegion();\n\n  if (sameRegion(CheckedReg, Pending))\
  \ {\n    // Correct NULL check on the newly allocated pointer.\n    State = State->remove<PendingAllocRegion>();\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  // Mismatch: the immediate NULL\
  \ check is on a different pointer.\n  reportMismatch(Condition, C);\n\n  // Clear\
  \ pending regardless to avoid cascading.\n  State = State->remove<PendingAllocRegion>();\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  State = State->remove<PendingAllocRegion>();\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkEndFunction(const ReturnStmt\
  \ *RS,\n                                        CheckerContext &C) const {\n  ProgramStateRef\
  \ State = C.getState();\n  State = State->remove<PendingAllocRegion>();\n  C.addTransition(State);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects mismatched NULL check immediately after allocation (checks a\
  \ different pointer than the allocated one)\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\narm64/sme: Fix NULL check after kzalloc\n\nFix following\
  \ coccicheck error:\n./arch/arm64/kernel/process.c:322:2-23: alloc with no test,\
  \ possible model on line 326\n\nHere should be dst->thread.sve_state.\n\nFixes:\
  \ 8bd7f91c03d8 (\"arm64/sme: Implement traps and syscall handling for SME\")\nSigned-off-by:\
  \ Wan Jiabing <wanjiabing@vivo.com>\nReviwed-by: Mark Brown <broonie@kernel.org>\n\
  Link: https://lore.kernel.org/r/20220426113054.630983-1-wanjiabing@vivo.com\nSigned-off-by:\
  \ Catalin Marinas <catalin.marinas@arm.com>\n\n## Buggy Code\n\n```c\n// Function:\
  \ arch_dup_task_struct in arch/arm64/kernel/process.c\nint arch_dup_task_struct(struct\
  \ task_struct *dst, struct task_struct *src)\n{\n\tif (current->mm)\n\t\tfpsimd_preserve_current_state();\n\
  \t*dst = *src;\n\n\t/* We rely on the above assignment to initialize dst's thread_flags:\
  \ */\n\tBUILD_BUG_ON(!IS_ENABLED(CONFIG_THREAD_INFO_IN_TASK));\n\n\t/*\n\t * Detach\
  \ src's sve_state (if any) from dst so that it does not\n\t * get erroneously used\
  \ or freed prematurely.  dst's copies\n\t * will be allocated on demand later on\
  \ if dst uses SVE.\n\t * For consistency, also clear TIF_SVE here: this could be\
  \ done\n\t * later in copy_process(), but to avoid tripping up future\n\t * maintainers\
  \ it is best not to leave TIF flags and buffers in\n\t * an inconsistent state,\
  \ even temporarily.\n\t */\n\tdst->thread.sve_state = NULL;\n\tclear_tsk_thread_flag(dst,\
  \ TIF_SVE);\n\n\t/*\n\t * In the unlikely event that we create a new thread with\
  \ ZA\n\t * enabled we should retain the ZA state so duplicate it here.\n\t * This\
  \ may be shortly freed if we exec() or if CLONE_SETTLS\n\t * but it's simpler to\
  \ do it here. To avoid confusing the rest\n\t * of the code ensure that we have\
  \ a sve_state allocated\n\t * whenever za_state is allocated.\n\t */\n\tif (thread_za_enabled(&src->thread))\
  \ {\n\t\tdst->thread.sve_state = kzalloc(sve_state_size(src),\n\t\t\t\t\t\tGFP_KERNEL);\n\
  \t\tif (!dst->thread.za_state)\n\t\t\treturn -ENOMEM;\n\t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n\t\t\t\t\t       za_state_size(src),\n\t\t\t\t\
  \t       GFP_KERNEL);\n\t\tif (!dst->thread.za_state) {\n\t\t\tkfree(dst->thread.sve_state);\n\
  \t\t\tdst->thread.sve_state = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\
  \tdst->thread.za_state = NULL;\n\t\tclear_tsk_thread_flag(dst, TIF_SME);\n\t}\n\n\
  \t/* clear any pending asynchronous tag fault raised by the parent */\n\tclear_tsk_thread_flag(dst,\
  \ TIF_MTE_ASYNC_FAULT);\n\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c\nindex 99c293513817..9734c9fb1a32\
  \ 100644\n--- a/arch/arm64/kernel/process.c\n+++ b/arch/arm64/kernel/process.c\n\
  @@ -321,7 +321,7 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct\
  \ *src)\n \tif (thread_za_enabled(&src->thread)) {\n \t\tdst->thread.sve_state =\
  \ kzalloc(sve_state_size(src),\n \t\t\t\t\t\tGFP_KERNEL);\n-\t\tif (!dst->thread.za_state)\n\
  +\t\tif (!dst->thread.sve_state)\n \t\t\treturn -ENOMEM;\n \t\tdst->thread.za_state\
  \ = kmemdup(src->thread.za_state,\n \t\t\t\t\t       za_state_size(src),\n```\n"
pattern: '## Bug Pattern


  After allocating one pointer, the code checks a different pointer for NULL. Specifically:

  - ptrA = kzalloc(...);

  - if (!ptrB) return -ENOMEM;  // should check ptrA


  This mismatched NULL check (verifying an unrelated field instead of the just-allocated
  one) lets allocation failures go unnoticed, leading to inconsistent state and potential
  misuse of a NULL pointer.'
plan: "Plan\n\n1) Program State\n- REGISTER_TRAIT_WITH_PROGRAMSTATE(PendingAllocRegion,\
  \ const MemRegion*)\n  - Holds the lvalue region to which the most recent allocation\
  \ return value was stored, waiting for the immediate NULL-check in the following\
  \ branch condition.\n- No alias map by default (keep it simple and reduce false\
  \ positives to the immediate pattern).\n\n2) Helper utilities\n- isAllocator(const\
  \ CallEvent &Call)\n  - Return true if callee name matches one of: { \"kzalloc\"\
  , \"kmalloc\", \"kcalloc\", \"kmalloc_array\", \"devm_kzalloc\", \"vmalloc\", \"\
  kvzalloc\", \"kmemdup\" }.\n- getAssignedLHSRegionForCall(const CallEvent &Call,\
  \ CheckerContext &C)\n  - From Call.getOriginExpr(), go upward with findSpecificTypeInParents<BinaryOperator>(...)\
  \ and:\n    - If found an assignment BinaryOperator with opcode BO_Assign and the\
  \ CallExpr is the RHS, return getMemRegionFromExpr(LHS, C).\n  - If not found, try\
  \ findSpecificTypeInParents<DeclStmt>(...) and:\n    - Walk its VarDecls; if any\
  \ has init equal to the CallExpr, return the MemRegion of that variable (use State->getLValue(VarDecl,\
  \ LCtx) or getMemRegionFromExpr on a DeclRefExpr built from VarDecl as available).\n\
  \  - If neither case works, return nullptr (skip).\n- isNullCheck(const Expr *Cond,\
  \ const Expr *&CheckedExpr, CheckerContext &C)\n  - Recognize NULL checks:\n   \
  \ - UnaryOperator \u2018!\u2019: CheckedExpr = subexpr (IgnoreParenImpCasts).\n\
  \    - BinaryOperator \u2018==\u2019 or \u2018!=\u2019: One side must be \u201C\
  null-like\u201D:\n      - IntegerLiteral 0, GNUNullExpr, CXXNullPtrLiteralExpr,\
  \ or ExprHasName(side, \"NULL\", C).\n      - The other side becomes CheckedExpr\
  \ (IgnoreParenImpCasts).\n    - A plain pointer in condition (if (ptr)): treat as\
  \ non-null check. For this pattern we only care about explicit NULL checks (!ptr\
  \ or ptr == NULL/0). Skip plain truthiness to avoid noise.\n  - Return true only\
  \ if we identified an explicit NULL check and extracted CheckedExpr.\n- sameRegion(const\
  \ MemRegion *A, const MemRegion *B)\n  - Simple pointer comparison.\n\n3) Callbacks\
  \ and logic\n\nA) checkPostCall(const CallEvent &Call, CheckerContext &C)\n- Goal:\
  \ Capture \u201Callocate into X = alloc(...);\u201D and remember X\u2019s region\
  \ for the very next NULL check.\n- Steps:\n  1. If not isAllocator(Call), return.\n\
  \  2. Determine the assigned LHS region via getAssignedLHSRegionForCall(Call, C).\n\
  \     - If no LHS region (e.g., return value not assigned), return; we only handle\
  \ the explicit assignment/init pattern.\n  3. State = C.getState(); State = State->set<PendingAllocRegion>(LHSRegion);\
  \ C.addTransition(State).\n- Rationale: We remember exactly which lvalue was assigned\
  \ the allocation result; the next explicit NULL-check must be on this region.\n\n\
  B) checkBranchCondition(const Stmt *Condition, CheckerContext &C)\n- Goal: On the\
  \ immediate next branch after an allocation, verify the NULL check is on the same\
  \ region. If it checks a different pointer, report a bug.\n- Steps:\n  1. Fetch\
  \ State and PendingRegion = State->get<PendingAllocRegion>().\n     - If PendingRegion\
  \ is null, do nothing (return).\n  2. Extract the conditional expression E = cast<Expr>(Condition).\n\
  \  3. const Expr *CheckedExpr = nullptr; if (!isNullCheck(E->IgnoreParenImpCasts(),\
  \ CheckedExpr, C)):\n     - Not an explicit NULL check. To avoid stale pending state\
  \ and false positives later, clear pending state and return.\n  4. Obtain CheckedRegion\
  \ = getMemRegionFromExpr(CheckedExpr, C).\n     - If null (can\u2019t map), clear\
  \ pending state and return.\n  5. Compare:\n     - If sameRegion(CheckedRegion,\
  \ PendingRegion):\n       - Correct NULL check for the allocated pointer. Clear\
  \ pending state (set<PendingAllocRegion>(nullptr)) and return.\n     - Else:\n \
  \      - Generate non-fatal error node and report:\n         - Short message: \"\
  Mismatched NULL check after allocation\"\n         - Optional note: \"Allocated\
  \ pointer was not checked; a different pointer is checked here.\"\n       - Clear\
  \ pending state and add transition.\n- Rationale: We constrain to the immediate,\
  \ explicit NULL check after an allocation to minimize false positives, matching\
  \ the kernel pattern in the patch.\n\nC) checkBeginFunction(CheckerContext &C)\n\
  - Clear any stale state at function entry:\n  - State = C.getState()->set<PendingAllocRegion>(nullptr);\
  \ C.addTransition(State).\n\nD) checkEndFunction(const ReturnStmt *RS, CheckerContext\
  \ &C)\n- Clear pending state to avoid state leakage across paths:\n  - State = C.getState()->set<PendingAllocRegion>(nullptr);\
  \ C.addTransition(State).\n\n4) Reporting\n- Create a BugType once (e.g., \"Mismatched\
  \ NULL check after allocation\").\n- In checkBranchCondition, upon mismatch:\n \
  \ - Use generateNonFatalErrorNode to get ErrorNode.\n  - Create a PathSensitiveBugReport\
  \ with concise message: \"Mismatched NULL check: checks a different pointer than\
  \ the newly allocated one\".\n  - Optionally add a range on the branch condition\
  \ and on the assignment LHS (if you still have access via parents; otherwise, at\
  \ least the branch range).\n  - Emit via C.emitReport.\n\n5) Notes to reduce false\
  \ positives\n- Only trigger on explicit NULL checks (!ptr, ptr == NULL, ptr == 0),\
  \ not on truthiness tests (if (ptr)).\n- Only consider the first branch condition\
  \ after the allocation call; clear state afterwards.\n- Only handle cases where\
  \ the allocation return value is assigned to a concrete lvalue (BinaryOperator assignment\
  \ or VarDecl init). Ignore other patterns to keep the checker simple and precise.\n\
  \n6) Clang Check Functions used\n- checkPostCall: capture allocator result assignment\
  \ and store the destination region.\n- checkBranchCondition: verify the immediate\
  \ explicit NULL check refers to the same region; report mismatch.\n- checkBeginFunction,\
  \ checkEndFunction: cleanup/reset state."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\n#include \"\
  clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program state: Remember\
  \ the lvalue region that received the latest allocation result\nREGISTER_TRAIT_WITH_PROGRAMSTATE(PendingAllocRegion,\
  \ const MemRegion*)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::PostCall,\n        check::BranchCondition,\n        check::BeginFunction,\n\
  \        check::EndFunction> {\n   mutable std::unique_ptr<BugType> BT;\n\npublic:\n\
  \  SAGenTestChecker()\n      : BT(new BugType(this, \"Mismatched NULL check after\
  \ allocation\",\n                       \"Logic error\")) {}\n\n  void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n  void checkBeginFunction(CheckerContext\
  \ &C) const;\n  void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;\n\
  \nprivate:\n  // Helpers\n  static bool isAllocator(const CallEvent &Call, CheckerContext\
  \ &C);\n  const MemRegion *getAssignedLHSRegionForCall(const CallEvent &Call,\n\
  \                                               CheckerContext &C) const;\n\n  static\
  \ bool isNullCheck(const Expr *Cond, const Expr *&CheckedExpr,\n               \
  \           CheckerContext &C);\n  static bool sameRegion(const MemRegion *A, const\
  \ MemRegion *B) {\n    if (!A || !B)\n      return false;\n    A = A->getBaseRegion();\n\
  \    B = B->getBaseRegion();\n    return A == B;\n  }\n\n  void reportMismatch(const\
  \ Stmt *Condition, CheckerContext &C) const;\n};\n\n// Determine if the call is\
  \ to a known allocator.\nbool SAGenTestChecker::isAllocator(const CallEvent &Call,\
  \ CheckerContext &C) {\n  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n\
  \    return false;\n\n  // Use the provided ExprHasName helper for robust name checks.\n\
  \  static const char *Names[] = {\n      \"kzalloc\", \"kmalloc\", \"kcalloc\",\
  \ \"kmalloc_array\",\n      \"devm_kzalloc\", \"vmalloc\", \"kvzalloc\", \"kmemdup\"\
  };\n  for (const char *N : Names) {\n    if (ExprHasName(OriginExpr, N, C))\n  \
  \    return true;\n  }\n  return false;\n}\n\n// Find the lvalue region to which\
  \ the allocation result is assigned.\n// Handles patterns:\n//   - X = alloc(...);\n\
  //   - type X = alloc(...);\nconst MemRegion *SAGENTestChecker_getRegionFromVarDecl(const\
  \ VarDecl *VD,\n                                                       CheckerContext\
  \ &C) {\n  if (!VD)\n    return nullptr;\n  const LocationContext *LCtx = C.getLocationContext();\n\
  \  MemRegionManager &MRMgr = C.getSValBuilder().getRegionManager();\n  const VarRegion\
  \ *VR = MRMgr.getVarRegion(VD, LCtx);\n  if (!VR)\n    return nullptr;\n  return\
  \ VR->getBaseRegion();\n}\n\nconst MemRegion *\nSAGenTestChecker::getAssignedLHSRegionForCall(const\
  \ CallEvent &Call,\n                                              CheckerContext\
  \ &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n\
  \    return nullptr;\n\n  const CallExpr *CE = dyn_cast<CallExpr>(OriginExpr);\n\
  \  if (!CE)\n    return nullptr;\n\n  // First, try to find an assignment 'LHS =\
  \ <this call>'\n  if (const auto *BO = findSpecificTypeInParents<BinaryOperator>(CE,\
  \ C)) {\n    if (BO->getOpcode() == BO_Assign) {\n      const Expr *RHS = BO->getRHS();\n\
  \      if (!RHS)\n        return nullptr;\n      const Expr *RHSNoC = RHS->IgnoreParenImpCasts();\n\
  \      const Expr *CENoC = CE->IgnoreParenImpCasts();\n      if (RHSNoC == CENoC)\
  \ {\n        const Expr *LHS = BO->getLHS();\n        if (!LHS)\n          return\
  \ nullptr;\n        const MemRegion *MR = getMemRegionFromExpr(LHS, C);\n      \
  \  if (!MR)\n          return nullptr;\n        return MR->getBaseRegion();\n  \
  \    }\n    }\n  }\n\n  // Next, try a variable declaration with initializer 'type\
  \ X = <this call>'\n  if (const auto *DS = findSpecificTypeInParents<DeclStmt>(CE,\
  \ C)) {\n    const Expr *CENoC = CE->IgnoreParenImpCasts();\n    for (const Decl\
  \ *D : DS->decls()) {\n      if (const auto *VD = dyn_cast<VarDecl>(D)) {\n    \
  \    if (const Expr *Init = VD->getInit()) {\n          const Expr *InitNoC = Init->IgnoreParenImpCasts();\n\
  \          if (InitNoC == CENoC) {\n            return SAGENTestChecker_getRegionFromVarDecl(VD,\
  \ C);\n          }\n        }\n      }\n    }\n  }\n\n  return nullptr;\n}\n\n//\
  \ Identify explicit NULL checks and extract the checked expression.\n// Recognizes:\
  \ !ptr, ptr == NULL/0, ptr != NULL/0.\n// Does NOT treat \"if (ptr)\" as a NULL-check\
  \ for this pattern.\nbool SAGenTestChecker::isNullCheck(const Expr *Cond, const\
  \ Expr *&CheckedExpr,\n                                   CheckerContext &C) {\n\
  \  if (!Cond)\n    return false;\n\n  ASTContext &ACtx = C.getASTContext();\n  const\
  \ Expr *E = Cond->IgnoreParenCasts();\n\n  // !ptr\n  if (const auto *UO = dyn_cast<UnaryOperator>(E))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *Sub = UO->getSubExpr();\n\
  \      if (!Sub)\n        return false;\n      CheckedExpr = Sub->IgnoreParenImpCasts();\n\
  \      return true;\n    }\n    return false;\n  }\n\n  // ptr == NULL/0 or ptr\
  \ != NULL/0\n  if (const auto *BO = dyn_cast<BinaryOperator>(E)) {\n    BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr\
  \ *LHS = BO->getLHS();\n      const Expr *RHS = BO->getRHS();\n      if (!LHS ||\
  \ !RHS)\n        return false;\n\n      auto IsNullLike = [&](const Expr *X) ->\
  \ bool {\n        return X->isNullPointerConstant(ACtx, Expr::NPC_ValueDependentIsNull)\
  \ ||\n               ExprHasName(X, \"NULL\", C);\n      };\n\n      const Expr\
  \ *LHSNoC = LHS->IgnoreParenImpCasts();\n      const Expr *RHSNoC = RHS->IgnoreParenImpCasts();\n\
  \n      bool LHSIsNull = IsNullLike(LHSNoC);\n      bool RHSIsNull = IsNullLike(RHSNoC);\n\
  \n      if (LHSIsNull && !RHSIsNull) {\n        CheckedExpr = RHSNoC;\n        return\
  \ true;\n      }\n      if (RHSIsNull && !LHSIsNull) {\n        CheckedExpr = LHSNoC;\n\
  \        return true;\n      }\n      return false;\n    }\n    return false;\n\
  \  }\n\n  // Do not treat other truthiness checks as NULL-checks.\n  return false;\n\
  }\n\nvoid SAGenTestChecker::reportMismatch(const Stmt *Condition,\n            \
  \                          CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Mismatched NULL check: checks a different pointer than the newly \"\
  \n           \"allocated one\",\n      N);\n  if (Condition)\n    R->addRange(Condition->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call,\n                                     CheckerContext &C) const\
  \ {\n  if (!isAllocator(Call, C))\n    return;\n\n  // Only track when the allocator\
  \ return value is assigned to some lvalue.\n  const MemRegion *LHSRegion = getAssignedLHSRegionForCall(Call,\
  \ C);\n  if (!LHSRegion)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  State = State->set<PendingAllocRegion>(LHSRegion->getBaseRegion());\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition,\n      \
  \                                      CheckerContext &C) const {\n  ProgramStateRef\
  \ State = C.getState();\n  const MemRegion *Pending = State->get<PendingAllocRegion>();\n\
  \  if (!Pending)\n    return;\n\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE) {\n    // Not an expression; clear pending and move on.\n    State\
  \ = State->remove<PendingAllocRegion>();\n    C.addTransition(State);\n    return;\n\
  \  }\n\n  const Expr *CheckedExpr = nullptr;\n  if (!isNullCheck(CondE, CheckedExpr,\
  \ C)) {\n    // Not an explicit NULL check; clear pending to avoid stale state.\n\
  \    State = State->remove<PendingAllocRegion>();\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // Resolve the region of the checked expression.\n  const\
  \ MemRegion *CheckedReg = getMemRegionFromExpr(CheckedExpr, C);\n  if (!CheckedReg)\
  \ {\n    // Unable to map; clear pending and continue.\n    State = State->remove<PendingAllocRegion>();\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  CheckedReg = CheckedReg->getBaseRegion();\n\
  \  Pending = Pending->getBaseRegion();\n\n  if (sameRegion(CheckedReg, Pending))\
  \ {\n    // Correct NULL check on the newly allocated pointer.\n    State = State->remove<PendingAllocRegion>();\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  // Mismatch: the immediate NULL\
  \ check is on a different pointer.\n  reportMismatch(Condition, C);\n\n  // Clear\
  \ pending regardless to avoid cascading.\n  State = State->remove<PendingAllocRegion>();\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  State = State->remove<PendingAllocRegion>();\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkEndFunction(const ReturnStmt\
  \ *RS,\n                                        CheckerContext &C) const {\n  ProgramStateRef\
  \ State = C.getState();\n  State = State->remove<PendingAllocRegion>();\n  C.addTransition(State);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects mismatched NULL check immediately after allocation (checks a\
  \ different pointer than the allocated one)\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
