_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: f503ae90c7355e8506e68498fe84c1357894cd5b
commit_type: Null-Pointer-Dereference
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/ExprCXX.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\nREGISTER_SET_WITH_PROGRAMSTATE(RiskySyms, SymbolRef)\nREGISTER_SET_WITH_PROGRAMSTATE(RiskyRegions,\
  \ const MemRegion*)\n\nnamespace {\nclass SAGenTestChecker\n    : public Checker<\n\
  \          check::PostCall,\n          check::Bind,\n          check::Location,\n\
  \          check::PreCall> {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n\
  \  SAGenTestChecker()\n      : BT(new BugType(this, \"Capability NULL dereference\"\
  , \"Memory Error\")) {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const;\n  void checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\n     \
  \                CheckerContext &C) const;\n  void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  bool isCapabilityHelper(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  const Expr *baseExprOfDeref(const\
  \ Stmt *S) const;\n  bool exprIsRiskyPtr(const Expr *E, CheckerContext &C) const;\n\
  \  bool ptrMayBeNull(const Expr *E, CheckerContext &C) const;\n\n  void reportPossibleNullDeref(const\
  \ Stmt *S, StringRef Msg,\n                               CheckerContext &C) const;\n\
  \  bool regionDerivedFromRiskySym(const MemRegion *R, ProgramStateRef State) const;\n\
  };\n\nbool SAGenTestChecker::isCapabilityHelper(const CallEvent &Call,\n       \
  \                                   CheckerContext &C) const {\n  const Expr *Origin\
  \ = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n  // Target helper(s)\n\
  \  if (ExprHasName(Origin, \"mt76_connac_get_he_phy_cap\", C))\n    return true;\n\
  \  return false;\n}\n\nbool SAGenTestChecker::regionDerivedFromRiskySym(const MemRegion\
  \ *R,\n                                                 ProgramStateRef State) const\
  \ {\n  if (!R)\n    return false;\n  const MemRegion *Base = R->getBaseRegion();\n\
  \  if (!Base)\n    return false;\n\n  if (const auto *SR = dyn_cast<SymbolicRegion>(Base))\
  \ {\n    SymbolRef Sym = SR->getSymbol();\n    if (Sym && State->contains<RiskySyms>(Sym))\n\
  \      return true;\n  }\n  return false;\n}\n\nconst Expr *SAGenTestChecker::baseExprOfDeref(const\
  \ Stmt *S) const {\n  if (!S)\n    return nullptr;\n\n  // Direct pointer dereference:\
  \ *ptr\n  if (const auto *UO = dyn_cast<UnaryOperator>(S)) {\n    if (UO->getOpcode()\
  \ == UO_Deref)\n      return UO->getSubExpr()->IgnoreParenCasts();\n  }\n\n  //\
  \ Member access through pointer: ptr->field\n  if (const auto *ME = dyn_cast<MemberExpr>(S))\
  \ {\n    if (ME->isArrow())\n      return ME->getBase()->IgnoreParenCasts();\n \
  \ }\n\n  // Array subscript: ptr[i] or (ptr->field)[i]\n  if (const auto *ASE =\
  \ dyn_cast<ArraySubscriptExpr>(S)) {\n    const Expr *B = ASE->getBase()->IgnoreParenCasts();\n\
  \    if (const auto *ME = dyn_cast<MemberExpr>(B)) {\n      if (ME->isArrow())\n\
  \        return ME->getBase()->IgnoreParenCasts();\n      // If it's '.', it does\
  \ not imply pointer deref (not our target).\n    }\n    // Otherwise, if B is a\
  \ pointer expression, the base pointer is B itself.\n    return B;\n  }\n\n  return\
  \ nullptr;\n}\n\nbool SAGenTestChecker::exprIsRiskyPtr(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E)\n    return false;\n\n  ProgramStateRef State = C.getState();\n\
  \  const LocationContext *LCtx = C.getLocationContext();\n\n  // Check symbol\n\
  \  SVal SV = State->getSVal(E, LCtx);\n  if (SymbolRef Sym = SV.getAsSymbol()) {\n\
  \    if (State->contains<RiskySyms>(Sym))\n      return true;\n  }\n\n  // Check\
  \ region membership or derivation\n  if (const MemRegion *MR = SV.getAsRegion())\
  \ {\n    MR = MR->getBaseRegion();\n    if (MR) {\n      if (State->contains<RiskyRegions>(MR))\n\
  \        return true;\n      if (regionDerivedFromRiskySym(MR, State))\n       \
  \ return true;\n    }\n  } else {\n    // Try direct region retrieval from expression\n\
  \    if (const MemRegion *MR2 = getMemRegionFromExpr(E, C)) {\n      MR2 = MR2->getBaseRegion();\n\
  \      if (MR2) {\n        if (State->contains<RiskyRegions>(MR2))\n          return\
  \ true;\n        if (regionDerivedFromRiskySym(MR2, State))\n          return true;\n\
  \      }\n    }\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::ptrMayBeNull(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n\n  ProgramStateRef\
  \ State = C.getState();\n  const LocationContext *LCtx = C.getLocationContext();\n\
  \n  SVal SV = State->getSVal(E, LCtx);\n  if (SV.isUnknownOrUndef())\n    return\
  \ true; // conservatively, unknown could be NULL\n\n  // Use assume on the boolean\
  \ interpretation of the pointer (NULL => false)\n  Optional<DefinedOrUnknownSVal>\
  \ DUV = SV.getAs<DefinedOrUnknownSVal>();\n  if (!DUV)\n    return true;\n\n  ProgramStateRef\
  \ NullState = State->assume(*DUV, /*Assumption=*/false);\n  return (bool)NullState;\n\
  }\n\nvoid SAGenTestChecker::reportPossibleNullDeref(const Stmt *S, StringRef Msg,\n\
  \                                               CheckerContext &C) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\n             \
  \                        CheckerContext &C) const {\n  if (!isCapabilityHelper(Call,\
  \ C))\n    return;\n\n  ProgramStateRef State = C.getState();\n  // Mark the returned\
  \ symbol as risky (may be NULL)\n  SVal Ret = Call.getReturnValue();\n  if (SymbolRef\
  \ Sym = Ret.getAsSymbol()) {\n    State = State->add<RiskySyms>(Sym);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S,\n\
  \                                 CheckerContext &C) const {\n  ProgramStateRef\
  \ State = C.getState();\n\n  const MemRegion *LHS = Loc.getAsRegion();\n  if (!LHS)\n\
  \    return;\n  LHS = LHS->getBaseRegion();\n  if (!LHS)\n    return;\n\n  bool\
  \ RHSIsRisky = false;\n\n  // Case 1: RHS carries risky symbol\n  if (SymbolRef\
  \ Sym = Val.getAsSymbol()) {\n    if (State->contains<RiskySyms>(Sym))\n      RHSIsRisky\
  \ = true;\n  }\n\n  // Case 2: RHS region is risky directly\n  if (!RHSIsRisky)\
  \ {\n    if (const MemRegion *RHSR = Val.getAsRegion()) {\n      RHSR = RHSR->getBaseRegion();\n\
  \      if (RHSR) {\n        if (State->contains<RiskyRegions>(RHSR))\n         \
  \ RHSIsRisky = true;\n        else if (regionDerivedFromRiskySym(RHSR, State))\n\
  \          RHSIsRisky = true;\n      }\n    }\n  }\n\n  if (RHSIsRisky) {\n    State\
  \ = State->add<RiskyRegions>(LHS);\n    C.addTransition(State);\n  }\n}\n\nvoid\
  \ SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\n      \
  \                               CheckerContext &C) const {\n  if (!IsLoad || !S)\n\
  \    return;\n\n  const Expr *BaseE = baseExprOfDeref(S);\n  if (!BaseE)\n    return;\n\
  \n  if (!exprIsRiskyPtr(BaseE, C))\n    return;\n\n  if (ptrMayBeNull(BaseE, C))\
  \ {\n    reportPossibleNullDeref(S, \"Possible NULL dereference of capability pointer\"\
  ,\n                            C);\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call,\n                                    CheckerContext &C) const\
  \ {\n  llvm::SmallVector<unsigned, 4> DerefParams;\n  if (!functionKnownToDeref(Call,\
  \ DerefParams))\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  for\
  \ (unsigned Idx : DerefParams) {\n    if (Idx >= Call.getNumArgs())\n      continue;\n\
  \    const Expr *ArgE = Call.getArgExpr(Idx);\n    if (!ArgE)\n      continue;\n\
  \n    if (!exprIsRiskyPtr(ArgE, C))\n      continue;\n\n    if (ptrMayBeNull(ArgE,\
  \ C)) {\n      const Expr *Origin = Call.getOriginExpr();\n      if (Origin) {\n\
  \        reportPossibleNullDeref(\n            Origin,\n            \"Possible NULL\
  \ dereference of capability pointer passed to function\",\n            C);\n   \
  \   } else {\n        reportPossibleNullDeref(\n            ArgE,\n            \"\
  Possible NULL dereference of capability pointer passed to function\",\n        \
  \    C);\n      }\n    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Warns on dereferencing capability pointers\
  \ that may be NULL (e.g., mt76_connac_get_he_phy_cap) without a NULL check\",\n\
  \      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nwifi: mt76: mt7996: fix NULL pointer dereference in\
  \ mt7996_mcu_sta_bfer_he\n\nFix the NULL pointer dereference in mt7996_mcu_sta_bfer_he\n\
  routine adding an sta interface to the mt7996 driver.\n\nFound by code review.\n\
  \nCc: stable@vger.kernel.org\nFixes: 98686cd21624 (\"wifi: mt76: mt7996: add driver\
  \ for MediaTek Wi-Fi 7 (802.11be) devices\")\nSigned-off-by: Ma Ke <make24@iscas.ac.cn>\n\
  Link: https://patch.msgid.link/20240813081242.3991814-1-make24@iscas.ac.cn\nSigned-off-by:\
  \ Felix Fietkau <nbd@nbd.name>\n\n## Buggy Code\n\n```c\n// Function: mt7996_mcu_sta_bfer_he\
  \ in drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nstatic void\nmt7996_mcu_sta_bfer_he(struct\
  \ ieee80211_sta *sta, struct ieee80211_vif *vif,\n\t\t       struct mt7996_phy *phy,\
  \ struct sta_rec_bf *bf)\n{\n\tstruct ieee80211_sta_he_cap *pc = &sta->deflink.he_cap;\n\
  \tstruct ieee80211_he_cap_elem *pe = &pc->he_cap_elem;\n\tconst struct ieee80211_sta_he_cap\
  \ *vc =\n\t\tmt76_connac_get_he_phy_cap(phy->mt76, vif);\n\tconst struct ieee80211_he_cap_elem\
  \ *ve = &vc->he_cap_elem;\n\tu16 mcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80);\n\
  \tu8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\tu8 snd_dim, sts;\n\n\tbf->tx_mode\
  \ = MT_PHY_TYPE_HE_SU;\n\n\tmt7996_mcu_sta_sounding_rate(bf);\n\n\tbf->trigger_su\
  \ = HE_PHY(CAP6_TRIG_SU_BEAMFORMING_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\tbf->trigger_mu\
  \ = HE_PHY(CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\
  \tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK,\n\t\t\t ve->phy_cap_info[5]);\n\
  \tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_MASK,\n\t\t     pe->phy_cap_info[4]);\n\
  \tbf->nrow = min_t(u8, snd_dim, sts);\n\tbf->ncol = min_t(u8, nss_mcs, bf->nrow);\n\
  \tbf->ibf_ncol = bf->ncol;\n\n\tif (sta->deflink.bandwidth != IEEE80211_STA_RX_BW_160)\n\
  \t\treturn;\n\n\t/* go over for 160MHz and 80p80 */\n\tif (pe->phy_cap_info[0] &\n\
  \t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G) {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_160);\n\
  \t\tnss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\n\t\tbf->ncol_gt_bw80 = nss_mcs;\n\
  \t}\n\n\tif (pe->phy_cap_info[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)\
  \ {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80p80);\n\t\tnss_mcs =\
  \ mt7996_mcu_get_sta_nss(mcs_map);\n\n\t\tif (bf->ncol_gt_bw80)\n\t\t\tbf->ncol_gt_bw80\
  \ = min_t(u8, bf->ncol_gt_bw80, nss_mcs);\n\t\telse\n\t\t\tbf->ncol_gt_bw80 = nss_mcs;\n\
  \t}\n\n\tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_MASK,\n\t\t\t\
  \ ve->phy_cap_info[5]);\n\tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_MASK,\n\
  \t\t     pe->phy_cap_info[4]);\n\n\tbf->nrow_gt_bw80 = min_t(int, snd_dim, sts);\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\
  \ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nindex e8d34bfbb41a..8855095fef10\
  \ 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n\
  @@ -1544,6 +1544,9 @@ mt7996_mcu_sta_bfer_he(struct ieee80211_sta *sta, struct ieee80211_vif\
  \ *vif,\n \tu8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n \tu8 snd_dim, sts;\n\
  \ \n+\tif (!vc)\n+\t\treturn;\n+\n \tbf->tx_mode = MT_PHY_TYPE_HE_SU;\n \n \tmt7996_mcu_sta_sounding_rate(bf);\n\
  ```\n"
pattern: '## Bug Pattern


  Using a pointer returned by a capability-query helper that may return NULL (here:
  vc = mt76_connac_get_he_phy_cap(...)) and immediately dereferencing it (e.g., ve
  = &vc->he_cap_elem; ve->phy_cap_info[...]) without a NULL check. This leads to a
  NULL pointer dereference when the capability is absent.'
plan: "Plan\n\n1) Program state\n\n- No complex traits beyond simple sets.\n- Register\
  \ two sets to track \u201Cpossibly NULL\u201D capability pointers and their aliases:\n\
  \  - REGISTER_SET_WITH_PROGRAMSTATE(RiskySyms, SymbolRef)\n  - REGISTER_SET_WITH_PROGRAMSTATE(RiskyRegions,\
  \ const MemRegion*)\n  Rationale:\n  - RiskySyms holds symbols that come directly\
  \ from known capability helpers (they may be NULL).\n  - RiskyRegions holds concrete\
  \ locations (variables) that received values derived from these risky symbols (aliases),\
  \ so later dereferences through those variables are caught as well.\n\n2) Known\
  \ functions and small helpers\n\n- Maintain a small list of helper functions that\
  \ may return NULL capability pointers:\n  - \"mt76_connac_get_he_phy_cap\"\n  (Keep\
  \ it extensible to add more names if needed.)\n- Helper: isCapabilityHelper(const\
  \ CallEvent &Call)\n  - Returns true if Call\u2019s callee identifier matches one\
  \ of the names above.\n- Helper: exprIsRiskyPtr(const Expr *E, CheckerContext &C)\n\
  \  - Fetch SVal SV = State->getSVal(E, LCtx)\n  - If SV has SymbolRef Sym and Sym\
  \ \u2208 RiskySyms => true\n  - Else, if getMemRegionFromExpr(E, C) returns MR and\
  \ MR \u2208 RiskyRegions => true\n  - Else false\n- Helper: ptrMayBeNull(const Expr\
  \ *E, CheckerContext &C)\n  - DefinedOrUnknownSVal PSV = State->getSVal(E, LCtx).castAs<DefinedOrUnknownSVal>()\n\
  \  - ProgramStateRef NullSt = State->assume(PSV, /*Assumption=*/false)\n  - Return\
  \ true if NullSt != nullptr (NULL is feasible), else false\n- Helper: baseExprOfDeref(const\
  \ Stmt *S)\n  - For dereference patterns, extract the base pointer expression:\n\
  \    - MemberExpr with isArrow(): return ME->getBase()\n    - UnaryOperator with\
  \ opcode UO_Deref: return UO->getSubExpr()\n    - ArraySubscriptExpr: return ASE->getBase()\n\
  \  - Otherwise, return nullptr\n\n3) checkPostCall\n\nGoal: Mark returned pointers\
  \ from capability helpers as \u201Crisky (may be NULL).\u201D\n\n- If isCapabilityHelper(Call)\
  \ is true:\n  - SVal Ret = Call.getReturnValue()\n  - If SymbolRef Sym = Ret.getAsSymbol():\
  \ add Sym to RiskySyms\n  - (Do not add regions here; the return value might be\
  \ immediately used or assigned. Assignment/aliasing will be handled in checkBind.)\n\
  \n4) checkBind\n\nGoal: Propagate \u201Crisky\u201D from RHS to LHS variables (aliases),\
  \ including cases like ve = &vc->he_cap_elem.\n\n- Get LHS region: if Loc is loc::MemRegionVal,\
  \ const MemRegion *LHS = Loc.getAsRegion()\n- Determine if RHS is risky using multiple\
  \ cues:\n  - If SymbolRef Sym = Val.getAsSymbol() and Sym \u2208 RiskySyms -> RHS\
  \ is risky\n  - Else if const MemRegion *RHSR = Val.getAsRegion() and RHSR \u2208\
  \ RiskyRegions -> RHS is risky\n  - Else if RHSR is a FieldRegion (or any region\
  \ with a super-region derived from a pointer):\n    - Let Base = RHSR->getBaseRegion()\n\
  \    - If Base is a SymbolicRegion, get BaseSym = cast<SymbolicRegion>(Base)->getSymbol()\n\
  \    - If BaseSym \u2208 RiskySyms -> RHS is risky (this covers ve = &vc->he_cap_elem)\n\
  - If RHS is risky and LHS is non-null: add LHS to RiskyRegions\n\nNotes:\n- This\
  \ \u201Ctaint-like\u201D propagation keeps the bookkeeping simple without full alias\
  \ graphs.\n- No need to remove from sets; the core solver uses constraints to decide\
  \ non-nullness in later dereferences.\n\n5) checkLocation\n\nGoal: Detect dereferences\
  \ of risky pointers that may be NULL at that point.\n\n- Only act on loads (IsLoad\
  \ == true).\n- Try to identify dereference base:\n  - Using S (the Stmt), if it\
  \ is one of:\n    - MemberExpr (ME) with ME->isArrow(): BaseE = ME->getBase()\n\
  \    - UnaryOperator with deref: BaseE = subexpr\n    - ArraySubscriptExpr: BaseE\
  \ = array/base expr\n  - If not one of these, return (we only care about pointer\
  \ derefs).\n- Risk check:\n  - If not exprIsRiskyPtr(BaseE, C), return\n- Nullability\
  \ check:\n  - If ptrMayBeNull(BaseE, C) is true:\n    - Report: \u201CPossible NULL\
  \ dereference of capability pointer\u201D\n  - Else, do nothing (the path proves\
  \ it non-NULL, e.g., guarded by if (!ptr) return;).\n\n6) checkPreCall\n\nGoal:\
  \ Also warn when a risky pointer is passed to a function known to dereference its\
  \ arguments.\n\n- Use functionKnownToDeref(Call, DerefParams) from utilities.\n\
  - If false, return.\n- For each index i in DerefParams:\n  - const Expr *ArgE =\
  \ Call.getArgExpr(i)\n  - If not exprIsRiskyPtr(ArgE, C), continue\n  - If ptrMayBeNull(ArgE,\
  \ C) is true:\n    - Report: \u201CPossible NULL dereference of capability pointer\
  \ passed to function\u201D\n\n7) Reporting\n\n- Use a single BugType (e.g., \u201C\
  Capability NULL deref\u201D) initialized lazily.\n- Create a non-fatal error node\
  \ and emit a short message:\n  - For deref sites: \u201CPossible NULL dereference\
  \ of capability pointer\u201D\n  - Optionally include callee name in message when\
  \ reporting in checkPreCall: \u201CPossible NULL dereference of capability pointer\
  \ passed to \u2018<fn>\u2019\u201D\n- Keep reports unique by site; rely on the path\
  \ constraints to avoid false positives after proper NULL checks.\n\n8) Why this\
  \ catches the target bug\n\n- The call to mt76_connac_get_he_phy_cap marks its result\
  \ symbol as risky (checkPostCall).\n- The assignment ve = &vc->he_cap_elem is captured\
  \ in checkBind by recognizing the FieldRegion base symbol (vc) is risky; ve\u2019\
  s region becomes risky too.\n- Subsequent uses like ve->phy_cap_info or vc->...\
  \ are recognized as dereferences (checkLocation). If there was no guarding if (!vc)\
  \ return; on that path, ptrMayBeNull() is true, so a report is issued.\n- If the\
  \ code adds a NULL check (as in the patch), the solver\u2019s constraints make ptrMayBeNull()\
  \ false on the dereferencing path, suppressing the warning."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/ExprCXX.h\"\n#include <optional>\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\nREGISTER_SET_WITH_PROGRAMSTATE(RiskySyms, SymbolRef)\n\
  REGISTER_SET_WITH_PROGRAMSTATE(RiskyRegions, const MemRegion*)\n\nnamespace {\n\
  class SAGenTestChecker\n    : public Checker<\n          check::PostCall,\n    \
  \      check::Bind,\n          check::Location,\n          check::PreCall> {\n \
  \ mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n      :\
  \ BT(new BugType(this, \"Capability NULL dereference\", \"Memory Error\")) {}\n\n\
  \  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n  void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n  void checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S,\n                     CheckerContext &C) const;\n\
  \  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\nprivate:\n\
  \  // Helpers\n  bool isCapabilityHelper(const CallEvent &Call, CheckerContext &C)\
  \ const;\n  const Expr *baseExprOfDeref(const Stmt *S) const;\n  bool exprIsRiskyPtr(const\
  \ Expr *E, CheckerContext &C) const;\n  bool ptrMayBeNull(const Expr *E, CheckerContext\
  \ &C) const;\n\n  void reportPossibleNullDeref(const Stmt *S, StringRef Msg,\n \
  \                              CheckerContext &C) const;\n  bool regionDerivedFromRiskySym(const\
  \ MemRegion *R, ProgramStateRef State) const;\n};\n\nbool SAGenTestChecker::isCapabilityHelper(const\
  \ CallEvent &Call,\n                                          CheckerContext &C)\
  \ const {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return\
  \ false;\n  // Target helper(s)\n  if (ExprHasName(Origin, \"mt76_connac_get_he_phy_cap\"\
  , C))\n    return true;\n  return false;\n}\n\nbool SAGenTestChecker::regionDerivedFromRiskySym(const\
  \ MemRegion *R,\n                                                 ProgramStateRef\
  \ State) const {\n  if (!R)\n    return false;\n  const MemRegion *Base = R->getBaseRegion();\n\
  \  if (!Base)\n    return false;\n\n  if (const auto *SR = dyn_cast<SymbolicRegion>(Base))\
  \ {\n    SymbolRef Sym = SR->getSymbol();\n    if (Sym && State->contains<RiskySyms>(Sym))\n\
  \      return true;\n  }\n  return false;\n}\n\nconst Expr *SAGenTestChecker::baseExprOfDeref(const\
  \ Stmt *S) const {\n  if (!S)\n    return nullptr;\n\n  // Direct pointer dereference:\
  \ *ptr\n  if (const auto *UO = dyn_cast<UnaryOperator>(S)) {\n    if (UO->getOpcode()\
  \ == UO_Deref)\n      return UO->getSubExpr()->IgnoreParenCasts();\n  }\n\n  //\
  \ Member access through pointer: ptr->field\n  if (const auto *ME = dyn_cast<MemberExpr>(S))\
  \ {\n    if (ME->isArrow())\n      return ME->getBase()->IgnoreParenCasts();\n \
  \ }\n\n  // Array subscript: ptr[i] or (ptr->field)[i]\n  if (const auto *ASE =\
  \ dyn_cast<ArraySubscriptExpr>(S)) {\n    const Expr *B = ASE->getBase()->IgnoreParenCasts();\n\
  \    if (const auto *ME = dyn_cast<MemberExpr>(B)) {\n      if (ME->isArrow())\n\
  \        return ME->getBase()->IgnoreParenCasts();\n      // If it's '.', it does\
  \ not imply pointer deref (not our target).\n    }\n    // Otherwise, if B is a\
  \ pointer expression, the base pointer is B itself.\n    return B;\n  }\n\n  return\
  \ nullptr;\n}\n\nbool SAGenTestChecker::exprIsRiskyPtr(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E)\n    return false;\n\n  ProgramStateRef State = C.getState();\n\
  \  const LocationContext *LCtx = C.getLocationContext();\n\n  // Check symbol\n\
  \  SVal SV = State->getSVal(E, LCtx);\n  if (SymbolRef Sym = SV.getAsSymbol()) {\n\
  \    if (State->contains<RiskySyms>(Sym))\n      return true;\n  }\n\n  // Check\
  \ region membership or derivation\n  if (const MemRegion *MR = SV.getAsRegion())\
  \ {\n    MR = MR->getBaseRegion();\n    if (MR) {\n      if (State->contains<RiskyRegions>(MR))\n\
  \        return true;\n      if (regionDerivedFromRiskySym(MR, State))\n       \
  \ return true;\n    }\n  } else {\n    // Try direct region retrieval from expression\n\
  \    if (const MemRegion *MR2 = getMemRegionFromExpr(E, C)) {\n      MR2 = MR2->getBaseRegion();\n\
  \      if (MR2) {\n        if (State->contains<RiskyRegions>(MR2))\n          return\
  \ true;\n        if (regionDerivedFromRiskySym(MR2, State))\n          return true;\n\
  \      }\n    }\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::ptrMayBeNull(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return false;\n\n  ProgramStateRef\
  \ State = C.getState();\n  const LocationContext *LCtx = C.getLocationContext();\n\
  \n  SVal SV = State->getSVal(E, LCtx);\n  if (SV.isUnknownOrUndef())\n    return\
  \ true; // conservatively, unknown could be NULL\n\n  // Use assume on the boolean\
  \ interpretation of the pointer (NULL => false)\n  std::optional<DefinedOrUnknownSVal>\
  \ DUV = SV.getAs<DefinedOrUnknownSVal>();\n  if (!DUV)\n    return true;\n\n  ProgramStateRef\
  \ NullState = State->assume(*DUV, /*Assumption=*/false);\n  return (bool)NullState;\n\
  }\n\nvoid SAGenTestChecker::reportPossibleNullDeref(const Stmt *S, StringRef Msg,\n\
  \                                               CheckerContext &C) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\n             \
  \                        CheckerContext &C) const {\n  if (!isCapabilityHelper(Call,\
  \ C))\n    return;\n\n  ProgramStateRef State = C.getState();\n  // Mark the returned\
  \ symbol as risky (may be NULL)\n  SVal Ret = Call.getReturnValue();\n  if (SymbolRef\
  \ Sym = Ret.getAsSymbol()) {\n    State = State->add<RiskySyms>(Sym);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S,\n\
  \                                 CheckerContext &C) const {\n  ProgramStateRef\
  \ State = C.getState();\n\n  const MemRegion *LHS = Loc.getAsRegion();\n  if (!LHS)\n\
  \    return;\n  LHS = LHS->getBaseRegion();\n  if (!LHS)\n    return;\n\n  bool\
  \ RHSIsRisky = false;\n\n  // Case 1: RHS carries risky symbol\n  if (SymbolRef\
  \ Sym = Val.getAsSymbol()) {\n    if (State->contains<RiskySyms>(Sym))\n      RHSIsRisky\
  \ = true;\n  }\n\n  // Case 2: RHS region is risky directly\n  if (!RHSIsRisky)\
  \ {\n    if (const MemRegion *RHSR = Val.getAsRegion()) {\n      RHSR = RHSR->getBaseRegion();\n\
  \      if (RHSR) {\n        if (State->contains<RiskyRegions>(RHSR))\n         \
  \ RHSIsRisky = true;\n        else if (regionDerivedFromRiskySym(RHSR, State))\n\
  \          RHSIsRisky = true;\n      }\n    }\n  }\n\n  if (RHSIsRisky) {\n    State\
  \ = State->add<RiskyRegions>(LHS);\n    C.addTransition(State);\n  }\n}\n\nvoid\
  \ SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\n      \
  \                               CheckerContext &C) const {\n  if (!IsLoad || !S)\n\
  \    return;\n\n  const Expr *BaseE = baseExprOfDeref(S);\n  if (!BaseE)\n    return;\n\
  \n  if (!exprIsRiskyPtr(BaseE, C))\n    return;\n\n  if (ptrMayBeNull(BaseE, C))\
  \ {\n    reportPossibleNullDeref(S, \"Possible NULL dereference of capability pointer\"\
  ,\n                            C);\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call,\n                                    CheckerContext &C) const\
  \ {\n  llvm::SmallVector<unsigned, 4> DerefParams;\n  if (!functionKnownToDeref(Call,\
  \ DerefParams))\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  for\
  \ (unsigned Idx : DerefParams) {\n    if (Idx >= Call.getNumArgs())\n      continue;\n\
  \    const Expr *ArgE = Call.getArgExpr(Idx);\n    if (!ArgE)\n      continue;\n\
  \n    if (!exprIsRiskyPtr(ArgE, C))\n      continue;\n\n    if (ptrMayBeNull(ArgE,\
  \ C)) {\n      const Expr *Origin = Call.getOriginExpr();\n      if (Origin) {\n\
  \        reportPossibleNullDeref(\n            Origin,\n            \"Possible NULL\
  \ dereference of capability pointer passed to function\",\n            C);\n   \
  \   } else {\n        reportPossibleNullDeref(\n            ArgE,\n            \"\
  Possible NULL dereference of capability pointer passed to function\",\n        \
  \    C);\n      }\n    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Warns on dereferencing capability pointers\
  \ that may be NULL (e.g., mt76_connac_get_he_phy_cap) without a NULL check\",\n\
  \      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
