_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: eaa03486d932572dfd1c5f64f9dfebe572ad88c0
commit_type: Uninit-Data
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"\
  clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include <memory>\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Map tracked local\
  \ integer-like status variables to their initialization state.\n// true  -> still\
  \ uninitialized on current path\n// false -> definitely initialized (written) on\
  \ current path\nREGISTER_MAP_WITH_PROGRAMSTATE(StatusInitMap, const MemRegion*,\
  \ bool)\n\nnamespace {\n\nstatic bool isIntegerLike(QualType T) {\n  if (T.isNull())\n\
  \    return false;\n  QualType CT = T.getCanonicalType();\n  return CT->isIntegerType()\
  \ || CT->isEnumeralType();\n}\n\nstatic bool isLocalAutomatic(const VarDecl *VD)\
  \ {\n  if (!VD)\n    return false;\n  // Local automatic storage (non-static local)\n\
  \  return VD->hasLocalStorage() && !VD->isStaticLocal();\n}\n\nstatic bool isStatusName(const\
  \ VarDecl *VD) {\n  if (!VD)\n    return false;\n  IdentifierInfo *II = VD->getIdentifier();\n\
  \  if (!II)\n    return false;\n  StringRef N = II->getName();\n  return N == \"\
  ret\" || N == \"rc\" || N == \"err\" || N == \"error\";\n}\n\nstatic const MemRegion\
  \ *getBaseVarRegion(const MemRegion *R) {\n  if (!R) return nullptr;\n  return R->getBaseRegion();\n\
  }\n\nstatic bool currentFunctionReturnsIntegerLike(CheckerContext &C) {\n  const\
  \ LocationContext *LC = C.getLocationContext();\n  if (!LC)\n    return false;\n\
  \  const Decl *D = LC->getDecl();\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!FD)\n    return false;\n  QualType RT = FD->getReturnType();\n  return isIntegerLike(RT);\n\
  }\n\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\n  :\
  \ public Checker<\n      check::PostStmt<DeclStmt>,\n      check::Bind,\n      check::PreStmt<ReturnStmt>\n\
  \    > {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Returning uninitialized status variable\", \"Uninitialized\
  \ Value\")) {}\n\n      void checkPostStmt(const DeclStmt *DS, CheckerContext &C)\
  \ const;\n      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const;\n      void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;\n\
  \n   private:\n      // Track all integer-like locals by default.\n      // Set\
  \ to false to only track names like ret/rc/err/error.\n      static constexpr bool\
  \ TrackAllReturnVars = true;\n\n      void reportUninitializedReturn(const VarDecl\
  \ *VD, const ReturnStmt *RS, CheckerContext &C) const;\n};\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  if (!DS)\n    return;\n\n  // Only\
  \ meaningful in functions that return integer-like types.\n  if (!currentFunctionReturnsIntegerLike(C))\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  SValBuilder &SVB = C.getSValBuilder();\n\
  \  const LocationContext *LCtx = C.getLocationContext();\n\n  for (const Decl *D\
  \ : DS->decls()) {\n    const auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n \
  \     continue;\n\n    // Only track local automatic integer-like variables declared\
  \ without initializer.\n    if (!isLocalAutomatic(VD))\n      continue;\n\n    if\
  \ (!isIntegerLike(VD->getType()))\n      continue;\n\n    if (VD->hasInit())\n \
  \     continue;\n\n    if (!TrackAllReturnVars && !isStatusName(VD))\n      continue;\n\
  \n    // Get the variable's memory region.\n    SVal LVal = SVB.getLValue(VD, LCtx);\n\
  \    const MemRegion *MR = LVal.getAsRegion();\n    if (!MR)\n      continue;\n\n\
  \    MR = getBaseVarRegion(MR);\n    if (!MR)\n      continue;\n\n    // Mark as\
  \ uninitialized on this path.\n    State = State->set<StatusInitMap>(MR, true);\n\
  \  }\n\n  if (State != C.getState())\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal /*Val*/, const Stmt * /*S*/, CheckerContext &C) const {\n  const MemRegion\
  \ *MR = Loc.getAsRegion();\n  if (!MR)\n    return;\n\n  MR = getBaseVarRegion(MR);\n\
  \  if (!MR)\n    return;\n\n  ProgramStateRef State = C.getState();\n  const bool\
  \ *Tracked = State->get<StatusInitMap>(MR);\n  if (!Tracked)\n    return;\n\n  //\
  \ Any write counts as initialization.\n  if (*Tracked) {\n    State = State->set<StatusInitMap>(MR,\
  \ false);\n    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::reportUninitializedReturn(const\
  \ VarDecl *VD, const ReturnStmt *RS, CheckerContext &C) const {\n  if (!VD || !RS)\n\
  \    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  std::string Msg = std::string(\"Returning uninitialized status\
  \ variable '\") +\n                    VD->getName().str() + \"'\";\n  auto R =\
  \ std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n  R->addRange(RS->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt\
  \ *RS, CheckerContext &C) const {\n  if (!RS)\n    return;\n\n  // Only warn in\
  \ functions returning integer-like types.\n  if (!currentFunctionReturnsIntegerLike(C))\n\
  \    return;\n\n  const Expr *RV = RS->getRetValue();\n  if (!RV)\n    return;\n\
  \n  // We only care when returning a tracked variable directly (possibly with parens/casts).\n\
  \  const Expr *E = RV->IgnoreParenImpCasts();\n  const auto *DRE = dyn_cast<DeclRefExpr>(E);\n\
  \  if (!DRE)\n    return;\n\n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n\
  \  if (!VD)\n    return;\n\n  // Must be integer-like local automatic we might have\
  \ tracked.\n  if (!isLocalAutomatic(VD) || !isIntegerLike(VD->getType()))\n    return;\n\
  \n  const MemRegion *MR = getMemRegionFromExpr(E, C);\n  if (!MR)\n    return;\n\
  \n  MR = getBaseVarRegion(MR);\n  if (!MR)\n    return;\n\n  ProgramStateRef State\
  \ = C.getState();\n  const bool *Tracked = State->get<StatusInitMap>(MR);\n  if\
  \ (!Tracked)\n    return;\n\n  // If still uninitialized on this path, report.\n\
  \  if (*Tracked) {\n    reportUninitializedReturn(VD, RS, C);\n  }\n}\n\n} // end\
  \ anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects returning an uninitialized status variable on some control-flow\
  \ paths\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nregmap: maple: Fix uninitialized symbol 'ret' warnings\n\
  \nFix warnings reported by smatch by initializing local 'ret' variable\nto 0.\n\n\
  drivers/base/regmap/regcache-maple.c:186 regcache_maple_drop()\nerror: uninitialized\
  \ symbol 'ret'.\ndrivers/base/regmap/regcache-maple.c:290 regcache_maple_sync()\n\
  error: uninitialized symbol 'ret'.\n\nSigned-off-by: Richard Fitzgerald <rf@opensource.cirrus.com>\n\
  Fixes: f033c26de5a5 (\"regmap: Add maple tree based register cache\")\nLink: https://lore.kernel.org/r/20240329144630.1965159-1-rf@opensource.cirrus.com\n\
  Signed-off-by: Mark Brown <broonie@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ regcache_maple_drop in drivers/base/regmap/regcache-maple.c\nstatic int regcache_maple_drop(struct\
  \ regmap *map, unsigned int min,\n\t\t\t       unsigned int max)\n{\n\tstruct maple_tree\
  \ *mt = map->cache;\n\tMA_STATE(mas, mt, min, max);\n\tunsigned long *entry, *lower,\
  \ *upper;\n\tunsigned long lower_index, lower_last;\n\tunsigned long upper_index,\
  \ upper_last;\n\tint ret;\n\n\tlower = NULL;\n\tupper = NULL;\n\n\tmas_lock(&mas);\n\
  \n\tmas_for_each(&mas, entry, max) {\n\t\t/*\n\t\t * This is safe because the regmap\
  \ lock means the\n\t\t * Maple lock is redundant, but we need to take it due\n\t\
  \t * to lockdep asserts in the maple tree code.\n\t\t */\n\t\tmas_unlock(&mas);\n\
  \n\t\t/* Do we need to save any of this entry? */\n\t\tif (mas.index < min) {\n\t\
  \t\tlower_index = mas.index;\n\t\t\tlower_last = min -1;\n\n\t\t\tlower = kmemdup(entry,\
  \ ((min - mas.index) *\n\t\t\t\t\t\tsizeof(unsigned long)),\n\t\t\t\t\tmap->alloc_flags);\n\
  \t\t\tif (!lower) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_unlocked;\n\t\t\t\
  }\n\t\t}\n\n\t\tif (mas.last > max) {\n\t\t\tupper_index = max + 1;\n\t\t\tupper_last\
  \ = mas.last;\n\n\t\t\tupper = kmemdup(&entry[max - mas.index + 1],\n\t\t\t\t\t\
  ((mas.last - max) *\n\t\t\t\t\t sizeof(unsigned long)),\n\t\t\t\t\tmap->alloc_flags);\n\
  \t\t\tif (!upper) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_unlocked;\n\t\t\t\
  }\n\t\t}\n\n\t\tkfree(entry);\n\t\tmas_lock(&mas);\n\t\tmas_erase(&mas);\n\n\t\t\
  /* Insert new nodes with the saved data */\n\t\tif (lower) {\n\t\t\tmas_set_range(&mas,\
  \ lower_index, lower_last);\n\t\t\tret = mas_store_gfp(&mas, lower, map->alloc_flags);\n\
  \t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tlower = NULL;\n\t\t}\n\n\t\tif (upper)\
  \ {\n\t\t\tmas_set_range(&mas, upper_index, upper_last);\n\t\t\tret = mas_store_gfp(&mas,\
  \ upper, map->alloc_flags);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tupper\
  \ = NULL;\n\t\t}\n\t}\n\nout:\n\tmas_unlock(&mas);\nout_unlocked:\n\tkfree(lower);\n\
  \tkfree(upper);\n\n\treturn ret;\n}\n```\n\n```c\n// Function: regcache_maple_sync\
  \ in drivers/base/regmap/regcache-maple.c\nstatic int regcache_maple_sync(struct\
  \ regmap *map, unsigned int min,\n\t\t\t       unsigned int max)\n{\n\tstruct maple_tree\
  \ *mt = map->cache;\n\tunsigned long *entry;\n\tMA_STATE(mas, mt, min, max);\n\t\
  unsigned long lmin = min;\n\tunsigned long lmax = max;\n\tunsigned int r, v, sync_start;\n\
  \tint ret;\n\tbool sync_needed = false;\n\n\tmap->cache_bypass = true;\n\n\trcu_read_lock();\n\
  \n\tmas_for_each(&mas, entry, max) {\n\t\tfor (r = max(mas.index, lmin); r <= min(mas.last,\
  \ lmax); r++) {\n\t\t\tv = entry[r - mas.index];\n\n\t\t\tif (regcache_reg_needs_sync(map,\
  \ r, v)) {\n\t\t\t\tif (!sync_needed) {\n\t\t\t\t\tsync_start = r;\n\t\t\t\t\tsync_needed\
  \ = true;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!sync_needed)\n\t\t\
  \t\tcontinue;\n\n\t\t\tret = regcache_maple_sync_block(map, entry, &mas,\n\t\t\t\
  \t\t\t\tsync_start, r);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t\tsync_needed\
  \ = false;\n\t\t}\n\n\t\tif (sync_needed) {\n\t\t\tret = regcache_maple_sync_block(map,\
  \ entry, &mas,\n\t\t\t\t\t\t\tsync_start, r);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto\
  \ out;\n\t\t\tsync_needed = false;\n\t\t}\n\t}\n\nout:\n\trcu_read_unlock();\n\n\
  \tmap->cache_bypass = false;\n\n\treturn ret;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/base/regmap/regcache-maple.c b/drivers/base/regmap/regcache-maple.c\n\
  index c1776127a572..55999a50ccc0 100644\n--- a/drivers/base/regmap/regcache-maple.c\n\
  +++ b/drivers/base/regmap/regcache-maple.c\n@@ -112,7 +112,7 @@ static int regcache_maple_drop(struct\
  \ regmap *map, unsigned int min,\n \tunsigned long *entry, *lower, *upper;\n \t\
  unsigned long lower_index, lower_last;\n \tunsigned long upper_index, upper_last;\n\
  -\tint ret;\n+\tint ret = 0;\n \n \tlower = NULL;\n \tupper = NULL;\n@@ -244,7 +244,7\
  \ @@ static int regcache_maple_sync(struct regmap *map, unsigned int min,\n \tunsigned\
  \ long lmin = min;\n \tunsigned long lmax = max;\n \tunsigned int r, v, sync_start;\n\
  -\tint ret;\n+\tint ret = 0;\n \tbool sync_needed = false;\n \n \tmap->cache_bypass\
  \ = true;\n```\n"
pattern: "## Bug Pattern\n\nReturning an uninitialized status variable due to cleanup/exit\
  \ paths that don\u2019t assign it on all control flows.\n\nTypical form:\n- A local\
  \ int (e.g., ret) is declared without initialization.\n- It is only set in some\
  \ branches (e.g., error paths or when work is done inside a loop).\n- The function\
  \ exits via a common label (goto out; \u2026 out:) and returns ret, but if no branch\
  \ assigned ret (e.g., loop does no work, or no errors occur), ret remains uninitialized.\n\
  \nExample pattern:\nint ret;            // not initialized\n...\nif (cond1) {\n\
  \    ret = -ENOMEM;\n    goto out;\n}\n...\n// no assignment to ret on success/no-op\
  \ paths\nout:\nreturn ret;         // ret may be uninitialized"
plan: "Plan to detect \u201Creturning an uninitialized status variable\u201D (e.g.,\
  \ ret) on some control-flow paths\n\n1. Program state\n- Register one program-state\
  \ map to track per-variable initialization.\n  - REGISTER_MAP_WITH_PROGRAMSTATE(StatusInitMap,\
  \ const MemRegion*, bool)\n  - Meaning: map[Region] = true if the variable is still\
  \ uninitialized, false if it has been definitely written at least once on the current\
  \ path.\n\n- Optional (to reduce false positives): a tiny name filter applied at\
  \ collection time:\n  - TrackAllReturnVars = true by default. If set to false, only\
  \ track variables with names commonly used for status codes: \u201Cret\u201D, \u201C\
  rc\u201D, \u201Cerr\u201D, \u201Cerror\u201D.\n  - This is only a local helper predicate;\
  \ no program state needed.\n\n2. Helper predicates\n- isIntegerLike(QualType T):\
  \ returns true if T is an integer or enumeration type (Builtin integer, Enum, typedefs\
  \ thereof).\n- isLocalAutomatic(const VarDecl *VD): true for local variables with\
  \ automatic storage duration (skip static/globals).\n- isStatusName(const VarDecl\
  \ *VD): true if VD->getName() is one of ret/rc/err/error (used only if TrackAllReturnVars\
  \ == false).\n- getBaseVarRegion(const MemRegion *R): returns R->getBaseRegion().\n\
  - Return type guard: the current function\u2019s return type is integer-like.\n\n\
  3. Collect candidate variables (checkPostStmt on DeclStmt)\n- For each VarDecl in\
  \ the DeclStmt:\n  - If isLocalAutomatic(VD) and isIntegerLike(VD->getType()) and\
  \ VD has no initializer, then:\n    - If TrackAllReturnVars is false, also require\
  \ isStatusName(VD).\n    - Obtain the variable\u2019s region:\n      - Use SVal\
  \ LVal = C.getSValBuilder().getLValue(VD, C.getLocationContext());\n      - const\
  \ MemRegion *R = LVal.getAsRegion();\n      - If R != nullptr, insert into StatusInitMap\
  \ with value true (uninitialized).\n- Rationale: We only track integer-like locals\
  \ declared without an initializer. These are the typical \u201Cret\u201D patterns.\n\
  \n4. Mark writes/initialization (checkBind)\n- When a value is bound to a location:\n\
  \  - Extract the destination region: const MemRegion *R = Loc.getAsRegion(); if\
  \ null, return.\n  - const MemRegion *Base = getBaseVarRegion(R);\n  - If Base exists\
  \ in StatusInitMap:\n    - Update StatusInitMap[Base] = false (initialized).\n-\
  \ Notes:\n  - This catches all stores (ret = ..., ret += ..., ++ret, assignments\
  \ via ternaries, etc.).\n  - We intentionally treat any write as \u201Cinitialized\u201D\
  ; we do not try to detect self-assign ret = ret.\n\n5. Detect uninitialized return\
  \ (checkPreStmt on ReturnStmt)\n- Preconditions:\n  - Current function return type\
  \ is integer-like (use the location context\u2019s Decl).\n- On each ReturnStmt:\n\
  \  - const Expr *RV = RS->getRetValue(); if null, ignore (void return).\n  - Find\
  \ if the return expression is the tracked variable:\n    - Prefer: if RV->IgnoreParenImpCasts()\
  \ is DeclRefExpr to a VarDecl VD, then:\n      - Get the MemRegion for RV using\
  \ getMemRegionFromExpr(RV, C).\n      - If Region is null, bail.\n      - Lookup\
  \ Base = getBaseVarRegion(Region) in StatusInitMap.\n        - If found and value\
  \ is true (still uninitialized on this path), report a bug.\n- Reporting:\n  - Use\
  \ generateNonFatalErrorNode() to get an error node.\n  - Emit a PathSensitiveBugReport\
  \ with a short message like:\n    - \u201CReturning uninitialized status variable\
  \ \u2018ret\u2019\u201D\n    - If name not \u201Cret\u201D, print the variable name\
  \ accordingly.\n  - Add RS range as the primary location; optionally add a note\
  \ at the declaration (DeclStmt) if convenient.\n\n6. Optional enhancements (keep\
  \ simple; not required)\n- Implicit return (checkEndFunction): If the function has\
  \ an implicit return using the last bound return value (rare for non-void in kernel),\
  \ you may add analogous logic by scanning the last returned expression. This is\
  \ typically unnecessary for this kernel pattern.\n- Reduce false positives further\
  \ by enabling the name filter (TrackAllReturnVars = false) or by checking the function\
  \ contains labels named \u201Cout\u201D, \u201Cerr\u201D, etc. (not required for\
  \ minimal solution).\n\n7. Callbacks summary and concrete behavior\n- checkPostStmt(DeclStmt):\n\
  \  - Collect integer-like local vars without initializers, map them to true (uninitialized).\n\
  - checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C):\n  - If Loc corresponds\
  \ to a tracked variable region (by base), set map entry to false (initialized).\n\
  - checkPreStmt(ReturnStmt):\n  - If the return expression is a DeclRefExpr to a\
  \ tracked var and the map value is true on the current path, emit a bug.\n\nWhy\
  \ this detects the target pattern\n- The bug arises when no writes to the status\
  \ variable happen along certain paths before a common return (often via goto labels).\
  \ The per-path map starts as uninitialized and is cleared only upon actual writes.\
  \ When a return uses the variable without any preceding write on that path, the\
  \ checker reports it. This matches the provided patches where \u201Cret\u201D was\
  \ declared without initialization and only written in specific branches, causing\
  \ returns of an indeterminate value."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\
  \n#include <memory>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// Map tracked local integer-like status variables to their initialization\
  \ state.\n// true  -> still uninitialized on current path\n// false -> definitely\
  \ initialized (written) on current path\nREGISTER_MAP_WITH_PROGRAMSTATE(StatusInitMap,\
  \ const MemRegion*, bool)\n\nnamespace {\n\nstatic bool isIntegerLike(QualType T)\
  \ {\n  if (T.isNull())\n    return false;\n  QualType CT = T.getCanonicalType();\n\
  \  return CT->isIntegerType() || CT->isEnumeralType();\n}\n\nstatic bool isLocalAutomatic(const\
  \ VarDecl *VD) {\n  if (!VD)\n    return false;\n  // Local automatic storage (non-static\
  \ local)\n  return VD->hasLocalStorage() && !VD->isStaticLocal();\n}\n\nstatic bool\
  \ isStatusName(const VarDecl *VD) {\n  if (!VD)\n    return false;\n  IdentifierInfo\
  \ *II = VD->getIdentifier();\n  if (!II)\n    return false;\n  StringRef N = II->getName();\n\
  \  return N == \"ret\" || N == \"rc\" || N == \"err\" || N == \"error\";\n}\n\n\
  static const MemRegion *getBaseVarRegion(const MemRegion *R) {\n  if (!R) return\
  \ nullptr;\n  return R->getBaseRegion();\n}\n\nstatic bool currentFunctionReturnsIntegerLike(CheckerContext\
  \ &C) {\n  const LocationContext *LC = C.getLocationContext();\n  if (!LC)\n   \
  \ return false;\n  const Decl *D = LC->getDecl();\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n\
  \  if (!FD)\n    return false;\n  QualType RT = FD->getReturnType();\n  return isIntegerLike(RT);\n\
  }\n\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\n  :\
  \ public Checker<\n      check::PostStmt<DeclStmt>,\n      check::Bind,\n      check::PreStmt<ReturnStmt>\n\
  \    > {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Returning uninitialized status variable\", \"Uninitialized\
  \ Value\")) {}\n\n      void checkPostStmt(const DeclStmt *DS, CheckerContext &C)\
  \ const;\n      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const;\n      void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;\n\
  \n   private:\n      // Track all integer-like locals by default.\n      // Set\
  \ to false to only track names like ret/rc/err/error.\n      static constexpr bool\
  \ TrackAllReturnVars = true;\n\n      void reportUninitializedReturn(const VarDecl\
  \ *VD, const ReturnStmt *RS, CheckerContext &C) const;\n};\n\nvoid SAGenTestChecker::checkPostStmt(const\
  \ DeclStmt *DS, CheckerContext &C) const {\n  if (!DS)\n    return;\n\n  // Only\
  \ meaningful in functions that return integer-like types.\n  if (!currentFunctionReturnsIntegerLike(C))\n\
  \    return;\n\n  ProgramStateRef State = C.getState();\n  SValBuilder &SVB = C.getSValBuilder();\n\
  \  const LocationContext *LCtx = C.getLocationContext();\n\n  for (const Decl *D\
  \ : DS->decls()) {\n    const auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n \
  \     continue;\n\n    // Only track local automatic integer-like variables declared\
  \ without initializer.\n    if (!isLocalAutomatic(VD))\n      continue;\n\n    if\
  \ (!isIntegerLike(VD->getType()))\n      continue;\n\n    if (VD->hasInit())\n \
  \     continue;\n\n    if (!TrackAllReturnVars && !isStatusName(VD))\n      continue;\n\
  \n    // Get the variable's memory region.\n    auto &MRMgr = SVB.getRegionManager();\n\
  \    const MemRegion *MR = MRMgr.getVarRegion(VD, LCtx);\n    if (!MR)\n      continue;\n\
  \n    MR = getBaseVarRegion(MR);\n    if (!MR)\n      continue;\n\n    // Mark as\
  \ uninitialized on this path.\n    State = State->set<StatusInitMap>(MR, true);\n\
  \  }\n\n  if (State != C.getState())\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal /*Val*/, const Stmt * /*S*/, CheckerContext &C) const {\n  const MemRegion\
  \ *MR = Loc.getAsRegion();\n  if (!MR)\n    return;\n\n  MR = getBaseVarRegion(MR);\n\
  \  if (!MR)\n    return;\n\n  ProgramStateRef State = C.getState();\n  const bool\
  \ *Tracked = State->get<StatusInitMap>(MR);\n  if (!Tracked)\n    return;\n\n  //\
  \ Any write counts as initialization.\n  if (*Tracked) {\n    State = State->set<StatusInitMap>(MR,\
  \ false);\n    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::reportUninitializedReturn(const\
  \ VarDecl *VD, const ReturnStmt *RS, CheckerContext &C) const {\n  if (!VD || !RS)\n\
  \    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  std::string Msg = std::string(\"Returning uninitialized status\
  \ variable '\") +\n                    VD->getName().str() + \"'\";\n  auto R =\
  \ std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n  R->addRange(RS->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt\
  \ *RS, CheckerContext &C) const {\n  if (!RS)\n    return;\n\n  // Only warn in\
  \ functions returning integer-like types.\n  if (!currentFunctionReturnsIntegerLike(C))\n\
  \    return;\n\n  const Expr *RV = RS->getRetValue();\n  if (!RV)\n    return;\n\
  \n  // We only care when returning a tracked variable directly (possibly with parens/casts).\n\
  \  const Expr *E = RV->IgnoreParenImpCasts();\n  const auto *DRE = dyn_cast<DeclRefExpr>(E);\n\
  \  if (!DRE)\n    return;\n\n  const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n\
  \  if (!VD)\n    return;\n\n  // Must be integer-like local automatic we might have\
  \ tracked.\n  if (!isLocalAutomatic(VD) || !isIntegerLike(VD->getType()))\n    return;\n\
  \n  // Get the region of the returned variable.\n  SValBuilder &SVB = C.getSValBuilder();\n\
  \  const LocationContext *LCtx = C.getLocationContext();\n  auto &MRMgr = SVB.getRegionManager();\n\
  \  const MemRegion *MR = MRMgr.getVarRegion(VD, LCtx);\n  if (!MR)\n    return;\n\
  \n  MR = getBaseVarRegion(MR);\n  if (!MR)\n    return;\n\n  ProgramStateRef State\
  \ = C.getState();\n  const bool *Tracked = State->get<StatusInitMap>(MR);\n  if\
  \ (!Tracked)\n    return;\n\n  // If still uninitialized on this path, report.\n\
  \  if (*Tracked) {\n    reportUninitializedReturn(VD, RS, C);\n  }\n}\n\n} // end\
  \ anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects returning an uninitialized status variable on some control-flow\
  \ paths\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
