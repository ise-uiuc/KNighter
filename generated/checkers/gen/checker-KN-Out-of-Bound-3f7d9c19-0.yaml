_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3f7d9c1964fcd16d02a8a9d4fd6f6cb60c4cc530
commit_type: Out-of-Bound
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Track variables/fields that hold a device-provided size (rss_max_key_size).\n\
  REGISTER_SET_WITH_PROGRAMSTATE(DeviceSizeSet, const MemRegion*)\n\nnamespace {\n\
  /* The checker callbacks are to be decided. */\nclass SAGenTestChecker : public\
  \ Checker< check::Bind, check::PreCall > {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unbounded\
  \ device-provided RSS key length used\", \"Memory Safety\")) {}\n\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\n      // Helpers\n\
  \      bool isVirtioCreadOfRssKeySize(const CallEvent &Call, CheckerContext &C)\
  \ const;\n      bool isVirtioCreadOfRssKeySize(const CallExpr *CE, CheckerContext\
  \ &C) const;\n\n      bool isKnownCopyLenSink(const CallEvent &Call, unsigned &DestIdx,\
  \ unsigned &LenIdx, CheckerContext &C) const;\n\n      const MemRegion* resolveExprRegion(const\
  \ Expr *E, CheckerContext &C) const;\n\n      bool lenComesFromDeviceSize(const\
  \ Expr *LenE, CheckerContext &C) const;\n\n      bool getConstArraySizeOfExpr(llvm::APInt\
  \ &ArraySize, const Expr *DestE, CheckerContext &C) const;\n\n      bool lengthIsProvablyBounded(CheckerContext\
  \ &C, const Expr *LenE, uint64_t Limit) const;\n\n      void report(const CallEvent\
  \ &Call, const Expr *LenE, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isVirtioCreadOfRssKeySize(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Match function name virtio_cread8/16/32\n\
  \  bool IsCread =\n      ExprHasName(Origin, \"virtio_cread8\", C) ||\n      ExprHasName(Origin,\
  \ \"virtio_cread16\", C) ||\n      ExprHasName(Origin, \"virtio_cread32\", C);\n\
  \  if (!IsCread)\n    return false;\n\n  if (Call.getNumArgs() < 2)\n    return\
  \ false;\n\n  const Expr *OffsetExpr = Call.getArgExpr(1);\n  if (!OffsetExpr)\n\
  \    return false;\n\n  // The offset expression should contain \"rss_max_key_size\"\
  \n  return ExprHasName(OffsetExpr, \"rss_max_key_size\", C);\n}\n\nbool SAGenTestChecker::isVirtioCreadOfRssKeySize(const\
  \ CallExpr *CE, CheckerContext &C) const {\n  if (!CE)\n    return false;\n\n  //\
  \ Check callee name using source text\n  if (!(ExprHasName(CE, \"virtio_cread8\"\
  , C) ||\n        ExprHasName(CE, \"virtio_cread16\", C) ||\n        ExprHasName(CE,\
  \ \"virtio_cread32\", C)))\n    return false;\n\n  if (CE->getNumArgs() < 2)\n \
  \   return false;\n\n  const Expr *OffsetExpr = CE->getArg(1);\n  if (!OffsetExpr)\n\
  \    return false;\n\n  return ExprHasName(OffsetExpr, \"rss_max_key_size\", C);\n\
  }\n\nbool SAGenTestChecker::isKnownCopyLenSink(const CallEvent &Call, unsigned &DestIdx,\
  \ unsigned &LenIdx, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // memcpy(dest, src, len)\n  if (ExprHasName(Origin,\
  \ \"memcpy\", C)) {\n    if (Call.getNumArgs() >= 3) {\n      DestIdx = 0;\n   \
  \   LenIdx = 2;\n      return true;\n    }\n    return false;\n  }\n\n  // memmove(dest,\
  \ src, len)\n  if (ExprHasName(Origin, \"memmove\", C)) {\n    if (Call.getNumArgs()\
  \ >= 3) {\n      DestIdx = 0;\n      LenIdx = 2;\n      return true;\n    }\n  \
  \  return false;\n  }\n\n  // virtio_cread_bytes(dev, off, buf, len)\n  if (ExprHasName(Origin,\
  \ \"virtio_cread_bytes\", C)) {\n    if (Call.getNumArgs() >= 4) {\n      DestIdx\
  \ = 2;\n      LenIdx = 3;\n      return true;\n    }\n    return false;\n  }\n\n\
  \  return false;\n}\n\nconst MemRegion* SAGenTestChecker::resolveExprRegion(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return nullptr;\n\n  const\
  \ MemRegion *MR = getMemRegionFromExpr(E, C);\n  if (MR) {\n    MR = MR->getBaseRegion();\n\
  \    return MR;\n  }\n\n  // Try find a DeclRefExpr child\n  if (const auto *DRE\
  \ = findSpecificTypeInChildren<DeclRefExpr>(E)) {\n    MR = getMemRegionFromExpr(DRE,\
  \ C);\n    if (MR) {\n      MR = MR->getBaseRegion();\n      return MR;\n    }\n\
  \  }\n\n  // Try find a MemberExpr child\n  if (const auto *ME = findSpecificTypeInChildren<MemberExpr>(E))\
  \ {\n    MR = getMemRegionFromExpr(ME, C);\n    if (MR) {\n      MR = MR->getBaseRegion();\n\
  \      return MR;\n    }\n  }\n\n  return nullptr;\n}\n\nbool SAGenTestChecker::lenComesFromDeviceSize(const\
  \ Expr *LenE, CheckerContext &C) const {\n  if (!LenE)\n    return false;\n\n  //\
  \ Case 1: direct call to virtio_creadX(..., rss_max_key_size)\n  if (const auto\
  \ *CE = dyn_cast<CallExpr>(LenE->IgnoreParenCasts())) {\n    if (isVirtioCreadOfRssKeySize(CE,\
  \ C))\n      return true;\n  }\n\n  // Case 2: variable/field previously marked\
  \ as device size\n  if (const MemRegion *MR = resolveExprRegion(LenE, C)) {\n  \
  \  ProgramStateRef State = C.getState();\n    if (State->contains<DeviceSizeSet>(MR))\n\
  \      return true;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::getConstArraySizeOfExpr(llvm::APInt\
  \ &ArraySize, const Expr *DestE, CheckerContext &C) const {\n  if (!DestE)\n   \
  \ return false;\n\n  // First try the provided helper on the expression directly.\n\
  \  if (getArraySizeFromExpr(ArraySize, DestE))\n    return true;\n\n  // Check if\
  \ the expression type itself is a constant array.\n  QualType QT = DestE->getType();\n\
  \  if (!QT.isNull()) {\n    if (const auto *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr()))\
  \ {\n      ArraySize = CAT->getSize();\n      return true;\n    }\n  }\n\n  // Try\
  \ DeclRefExpr child\n  if (const auto *DRE = findSpecificTypeInChildren<DeclRefExpr>(DestE))\
  \ {\n    if (getArraySizeFromExpr(ArraySize, DRE))\n      return true;\n\n    //\
  \ Also try type of the referenced declaration\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n      QualType VDTy = VD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(VDTy.getTypePtr()))\
  \ {\n        ArraySize = CAT->getSize();\n        return true;\n      }\n    }\n\
  \  }\n\n  // Try MemberExpr child: get the FieldDecl type\n  if (const auto *ME\
  \ = findSpecificTypeInChildren<MemberExpr>(DestE)) {\n    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl()))\
  \ {\n      QualType FTy = FD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(FTy.getTypePtr()))\
  \ {\n        ArraySize = CAT->getSize();\n        return true;\n      }\n    }\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::lengthIsProvablyBounded(CheckerContext\
  \ &C, const Expr *LenE, uint64_t Limit) const {\n  if (!LenE)\n    return false;\n\
  \n  ProgramStateRef State = C.getState();\n  SVal LenSVal = State->getSVal(LenE,\
  \ C.getLocationContext());\n  if (SymbolRef Sym = LenSVal.getAsSymbol()) {\n   \
  \ if (const llvm::APSInt *Max = inferSymbolMaxVal(Sym, C)) {\n      // If we can\
  \ infer a maximum and it's <= Limit, it's safe\n      uint64_t MaxZ = Max->getZExtValue();\n\
  \      return MaxZ <= Limit;\n    }\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::report(const\
  \ CallEvent &Call, const Expr *LenE, CheckerContext &C) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Unbounded device-provided RSS key length used\", N);\n\n  if (LenE)\n\
  \    R->addRange(LenE->getSourceRange());\n  if (const Expr *OE = Call.getOriginExpr())\n\
  \    R->addRange(OE->getSourceRange());\n\n  C.emitReport(std::move(R));\n}\n\n\
  void SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *LHSReg\
  \ = Loc.getAsRegion();\n  if (LHSReg)\n    LHSReg = LHSReg->getBaseRegion();\n\n\
  \  // Propagate tag on simple assignments: if RHS region is in set, add LHS\n  if\
  \ (LHSReg) {\n    if (const MemRegion *RHSReg = Val.getAsRegion()) {\n      RHSReg\
  \ = RHSReg->getBaseRegion();\n      if (RHSReg && State->contains<DeviceSizeSet>(RHSReg))\
  \ {\n        State = State->add<DeviceSizeSet>(LHSReg);\n        C.addTransition(State);\n\
  \        return;\n      }\n    }\n  }\n\n  // If RHS is a call to virtio_cread{8,16,32}(...,\
  \ rss_max_key_size), mark LHS\n  if (LHSReg && S) {\n    // Find a CallExpr under\
  \ this statement (assignment RHS)\n    if (const auto *CE = findSpecificTypeInChildren<CallExpr>(S))\
  \ {\n      if (isVirtioCreadOfRssKeySize(CE, C)) {\n        State = State->add<DeviceSizeSet>(LHSReg);\n\
  \        C.addTransition(State);\n        return;\n      }\n    }\n  }\n}\n\nvoid\
  \ SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  unsigned DestIdx = 0, LenIdx = 0;\n  if (!isKnownCopyLenSink(Call, DestIdx,\
  \ LenIdx, C))\n    return;\n\n  const Expr *LenE = Call.getArgExpr(LenIdx);\n  if\
  \ (!lenComesFromDeviceSize(LenE, C))\n    return;\n\n  // Determine destination\
  \ capacity\n  const Expr *DestE = Call.getArgExpr(DestIdx);\n  llvm::APInt ArrSize;\n\
  \  if (!getConstArraySizeOfExpr(ArrSize, DestE, C))\n    return; // Can't prove\
  \ destination capacity; avoid false positives\n\n  uint64_t Capacity = ArrSize.getZExtValue();\n\
  \  if (lengthIsProvablyBounded(C, LenE, Capacity))\n    return; // Proved safe on\
  \ this path\n\n  // Report: device-provided rss key length used without bound check\n\
  \  report(Call, LenE, C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects unbounded device-provided RSS\
  \ key length usage in copy-like APIs\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nvirtio_net: Add hash_key_length check\n\nAdd hash_key_length\
  \ check in virtnet_probe() to avoid possible out of\nbound errors when setting/reading\
  \ the hash key.\n\nFixes: c7114b1249fa (\"drivers/net/virtio_net: Added basic RSS\
  \ support.\")\nSigned-off-by: Philo Lu <lulie@linux.alibaba.com>\nSigned-off-by:\
  \ Xuan Zhuo <xuanzhuo@linux.alibaba.com>\nAcked-by: Joe Damato <jdamato@fastly.com>\n\
  Acked-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: virtnet_probe in drivers/net/virtio_net.c\n\
  static int virtnet_probe(struct virtio_device *vdev)\n{\n\tint i, err = -ENOMEM;\n\
  \tstruct net_device *dev;\n\tstruct virtnet_info *vi;\n\tu16 max_queue_pairs;\n\t\
  int mtu = 0;\n\n\t/* Find if host supports multiqueue/rss virtio_net device */\n\
  \tmax_queue_pairs = 1;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MQ) || virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_RSS))\n\t\tmax_queue_pairs =\n\t\t     virtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config, max_virtqueue_pairs));\n\n\t/* We need at least 2 queue's */\n\
  \tif (max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||\n\t    max_queue_pairs\
  \ > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||\n\t    !virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\
  \t\tmax_queue_pairs = 1;\n\n\t/* Allocate ourselves a network device with room for\
  \ our info */\n\tdev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);\n\
  \tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* Set up network device as normal. */\n\t\
  dev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE |\n\t\t\t   IFF_TX_SKB_NO_LINEAR;\n\
  \tdev->netdev_ops = &virtnet_netdev;\n\tdev->stat_ops = &virtnet_stat_ops;\n\tdev->features\
  \ = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev,\
  \ &vdev->dev);\n\n\t/* Do we support \"hardware\" checksums? */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_CSUM)) {\n\t\t/* This opens up the world of extra features. */\n\t\
  \tdev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\t\tif (csum)\n\t\t\tdev->features\
  \ |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO))\
  \ {\n\t\t\tdev->hw_features |= NETIF_F_TSO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\
  \t\t}\n\t\t/* Individual feature bits: what can host handle? */\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_ECN))\n\t\t\tdev->hw_features |= NETIF_F_TSO_ECN;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_USO))\n\t\t\tdev->hw_features |= NETIF_F_GSO_UDP_L4;\n\n\t\t\
  dev->features |= NETIF_F_GSO_ROBUST;\n\n\t\tif (gso)\n\t\t\tdev->features |= dev->hw_features\
  \ & NETIF_F_ALL_TSO;\n\t\t/* (!csum && gso) case will be fixed by register_netdev()\
  \ */\n\t}\n\n\t/* 1. With VIRTIO_NET_F_GUEST_CSUM negotiation, the driver doesn't\n\
  \t * need to calculate checksums for partially checksummed packets,\n\t * as they're\
  \ considered valid by the upper layer.\n\t * 2. Without VIRTIO_NET_F_GUEST_CSUM\
  \ negotiation, the driver only\n\t * receives fully checksummed packets. The device\
  \ may assist in\n\t * validating these packets' checksums, so the driver won't have\
  \ to.\n\t */\n\tdev->features |= NETIF_F_RXCSUM;\n\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_GUEST_TSO4) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6))\n\
  \t\tdev->features |= NETIF_F_GRO_HW;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS))\n\
  \t\tdev->hw_features |= NETIF_F_GRO_HW;\n\n\tdev->vlan_features = dev->features;\n\
  \tdev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT;\n\n\t/* MTU\
  \ range: 68 - 65535 */\n\tdev->min_mtu = MIN_MTU;\n\tdev->max_mtu = MAX_MTU;\n\n\
  \t/* Configuration may specify what MAC to use.  Otherwise random. */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MAC)) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tvirtio_cread_bytes(vdev,\n\
  \t\t\t\t   offsetof(struct virtio_net_config, mac),\n\t\t\t\t   addr, ETH_ALEN);\n\
  \t\teth_hw_addr_set(dev, addr);\n\t} else {\n\t\teth_hw_addr_random(dev);\n\t\t\
  dev_info(&vdev->dev, \"Assigned random MAC address %pM\\n\",\n\t\t\t dev->dev_addr);\n\
  \t}\n\n\t/* Set up our device-specific information */\n\tvi = netdev_priv(dev);\n\
  \tvi->dev = dev;\n\tvi->vdev = vdev;\n\tvdev->priv = vi;\n\n\tINIT_WORK(&vi->config_work,\
  \ virtnet_config_changed_work);\n\tINIT_WORK(&vi->rx_mode_work, virtnet_rx_mode_work);\n\
  \tspin_lock_init(&vi->refill_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))\
  \ {\n\t\tvi->mergeable_rx_bufs = true;\n\t\tdev->xdp_features |= NETDEV_XDP_ACT_RX_SG;\n\
  \t}\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HASH_REPORT))\n\t\tvi->has_rss_hash_report\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_RSS)) {\n\t\tvi->has_rss\
  \ = true;\n\n\t\tvi->rss_indir_table_size =\n\t\t\tvirtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config,\n\t\t\t\trss_max_indirection_table_length));\n\t}\n\terr =\
  \ rss_indirection_table_alloc(&vi->rss, vi->rss_indir_table_size);\n\tif (err)\n\
  \t\tgoto free;\n\n\tif (vi->has_rss || vi->has_rss_hash_report) {\n\t\tvi->rss_key_size\
  \ =\n\t\t\tvirtio_cread8(vdev, offsetof(struct virtio_net_config, rss_max_key_size));\n\
  \n\t\tvi->rss_hash_types_supported =\n\t\t    virtio_cread32(vdev, offsetof(struct\
  \ virtio_net_config, supported_hash_types));\n\t\tvi->rss_hash_types_supported &=\n\
  \t\t\t\t~(VIRTIO_NET_RSS_HASH_TYPE_IP_EX |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_TCP_EX\
  \ |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_UDP_EX);\n\n\t\tdev->hw_features |= NETIF_F_RXHASH;\n\
  \t\tdev->xdp_metadata_ops = &virtnet_xdp_metadata_ops;\n\t}\n\n\tif (vi->has_rss_hash_report)\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_v1_hash);\n\telse if (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MRG_RXBUF) ||\n\t\t virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\telse\n\t\tvi->hdr_len\
  \ = sizeof(struct virtio_net_hdr);\n\n\tif (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT)\
  \ ||\n\t    virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\tvi->any_header_sg\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\t\tvi->has_cvq\
  \ = true;\n\n\tmutex_init(&vi->cvq_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MTU))\
  \ {\n\t\tmtu = virtio_cread16(vdev,\n\t\t\t\t     offsetof(struct virtio_net_config,\n\
  \t\t\t\t\t      mtu));\n\t\tif (mtu < dev->min_mtu) {\n\t\t\t/* Should never trigger:\
  \ MTU was previously validated\n\t\t\t * in virtnet_validate.\n\t\t\t */\n\t\t\t\
  dev_err(&vdev->dev,\n\t\t\t\t\"device MTU appears to have changed it is now %d <\
  \ %d\",\n\t\t\t\tmtu, dev->min_mtu);\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\
  \t}\n\n\t\tdev->mtu = mtu;\n\t\tdev->max_mtu = mtu;\n\t}\n\n\tvirtnet_set_big_packets(vi,\
  \ mtu);\n\n\tif (vi->any_header_sg)\n\t\tdev->needed_headroom = vi->hdr_len;\n\n\
  \t/* Enable multiqueue by default */\n\tif (num_online_cpus() >= max_queue_pairs)\n\
  \t\tvi->curr_queue_pairs = max_queue_pairs;\n\telse\n\t\tvi->curr_queue_pairs =\
  \ num_online_cpus();\n\tvi->max_queue_pairs = max_queue_pairs;\n\n\t/* Allocate/initialize\
  \ the rx/tx queues, and invoke find_vqs */\n\terr = init_vqs(vi);\n\tif (err)\n\t\
  \tgoto free;\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_NOTF_COAL)) {\n\t\
  \tvi->intr_coal_rx.max_usecs = 0;\n\t\tvi->intr_coal_tx.max_usecs = 0;\n\t\tvi->intr_coal_rx.max_packets\
  \ = 0;\n\n\t\t/* Keep the default values of the coalescing parameters\n\t\t * aligned\
  \ with the default napi_tx state.\n\t\t */\n\t\tif (vi->sq[0].napi.weight)\n\t\t\
  \tvi->intr_coal_tx.max_packets = 1;\n\t\telse\n\t\t\tvi->intr_coal_tx.max_packets\
  \ = 0;\n\t}\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_VQ_NOTF_COAL)) {\n\
  \t\t/* The reason is the same as VIRTIO_NET_F_NOTF_COAL. */\n\t\tfor (i = 0; i <\
  \ vi->max_queue_pairs; i++)\n\t\t\tif (vi->sq[i].napi.weight)\n\t\t\t\tvi->sq[i].intr_coal.max_packets\
  \ = 1;\n\n\t\terr = virtnet_init_irq_moder(vi);\n\t\tif (err)\n\t\t\tgoto free;\n\
  \t}\n\n#ifdef CONFIG_SYSFS\n\tif (vi->mergeable_rx_bufs)\n\t\tdev->sysfs_rx_queue_group\
  \ = &virtio_net_mrg_rx_group;\n#endif\n\tnetif_set_real_num_tx_queues(dev, vi->curr_queue_pairs);\n\
  \tnetif_set_real_num_rx_queues(dev, vi->curr_queue_pairs);\n\n\tvirtnet_init_settings(dev);\n\
  \n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_STANDBY)) {\n\t\tvi->failover = net_failover_create(vi->dev);\n\
  \t\tif (IS_ERR(vi->failover)) {\n\t\t\terr = PTR_ERR(vi->failover);\n\t\t\tgoto\
  \ free_vqs;\n\t\t}\n\t}\n\n\tif (vi->has_rss || vi->has_rss_hash_report)\n\t\tvirtnet_init_default_rss(vi);\n\
  \n\tenable_rx_mode_work(vi);\n\n\t/* serialize netdev register + virtio_device_ready()\
  \ with ndo_open() */\n\trtnl_lock();\n\n\terr = register_netdevice(dev);\n\tif (err)\
  \ {\n\t\tpr_debug(\"virtio_net: registering device failed\\n\");\n\t\trtnl_unlock();\n\
  \t\tgoto free_failover;\n\t}\n\n\t/* Disable config change notification until ndo_open.\
  \ */\n\tvirtio_config_driver_disable(vi->vdev);\n\n\tvirtio_device_ready(vdev);\n\
  \n\tvirtnet_set_queues(vi, vi->curr_queue_pairs);\n\n\t/* a random MAC address has\
  \ been assigned, notify the device.\n\t * We don't fail probe if VIRTIO_NET_F_CTRL_MAC_ADDR\
  \ is not there\n\t * because many devices work fine without getting MAC explicitly\n\
  \t */\n\tif (!virtio_has_feature(vdev, VIRTIO_NET_F_MAC) &&\n\t    virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_CTRL_MAC_ADDR)) {\n\t\tstruct scatterlist sg;\n\n\t\tsg_init_one(&sg,\
  \ dev->dev_addr, dev->addr_len);\n\t\tif (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MAC,\n\
  \t\t\t\t\t  VIRTIO_NET_CTRL_MAC_ADDR_SET, &sg)) {\n\t\t\tpr_debug(\"virtio_net:\
  \ setting MAC address failed\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr = -EINVAL;\n\
  \t\t\tgoto free_unregister_netdev;\n\t\t}\n\t}\n\n\tif (virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_DEVICE_STATS)) {\n\t\tstruct virtio_net_stats_capabilities *stats_cap\
  \  __free(kfree) = NULL;\n\t\tstruct scatterlist sg;\n\t\t__le64 v;\n\n\t\tstats_cap\
  \ = kzalloc(sizeof(*stats_cap), GFP_KERNEL);\n\t\tif (!stats_cap) {\n\t\t\trtnl_unlock();\n\
  \t\t\terr = -ENOMEM;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tsg_init_one(&sg,\
  \ stats_cap, sizeof(*stats_cap));\n\n\t\tif (!virtnet_send_command_reply(vi, VIRTIO_NET_CTRL_STATS,\n\
  \t\t\t\t\t\tVIRTIO_NET_CTRL_STATS_QUERY,\n\t\t\t\t\t\tNULL, &sg)) {\n\t\t\tpr_debug(\"\
  virtio_net: fail to get stats capability\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr\
  \ = -EINVAL;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tv = stats_cap->supported_stats_types[0];\n\
  \t\tvi->device_stats_cap = le64_to_cpu(v);\n\t}\n\n\t/* Assume link up if device\
  \ can't report link status,\n\t   otherwise get link status from config. */\n\t\
  netif_carrier_off(dev);\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS))\
  \ {\n\t\tvirtnet_config_changed_work(&vi->config_work);\n\t} else {\n\t\tvi->status\
  \ = VIRTIO_NET_S_LINK_UP;\n\t\tvirtnet_update_settings(vi);\n\t\tnetif_carrier_on(dev);\n\
  \t}\n\n\tfor (i = 0; i < ARRAY_SIZE(guest_offloads); i++)\n\t\tif (virtio_has_feature(vi->vdev,\
  \ guest_offloads[i]))\n\t\t\tset_bit(guest_offloads[i], &vi->guest_offloads);\n\t\
  vi->guest_offloads_capable = vi->guest_offloads;\n\n\trtnl_unlock();\n\n\terr =\
  \ virtnet_cpu_notif_add(vi);\n\tif (err) {\n\t\tpr_debug(\"virtio_net: registering\
  \ cpu notifier failed\\n\");\n\t\tgoto free_unregister_netdev;\n\t}\n\n\tpr_debug(\"\
  virtnet: registered device %s with %d RX and TX vq's\\n\",\n\t\t dev->name, max_queue_pairs);\n\
  \n\treturn 0;\n\nfree_unregister_netdev:\n\tunregister_netdev(dev);\nfree_failover:\n\
  \tnet_failover_destroy(vi->failover);\nfree_vqs:\n\tvirtio_reset_device(vdev);\n\
  \tcancel_delayed_work_sync(&vi->refill);\n\tfree_receive_page_frags(vi);\n\tvirtnet_del_vqs(vi);\n\
  free:\n\tfree_netdev(dev);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c\nindex 4b507007d242..545dda8ec077\
  \ 100644\n--- a/drivers/net/virtio_net.c\n+++ b/drivers/net/virtio_net.c\n@@ -6451,6\
  \ +6451,12 @@ static int virtnet_probe(struct virtio_device *vdev)\n \tif (vi->has_rss\
  \ || vi->has_rss_hash_report) {\n \t\tvi->rss_key_size =\n \t\t\tvirtio_cread8(vdev,\
  \ offsetof(struct virtio_net_config, rss_max_key_size));\n+\t\tif (vi->rss_key_size\
  \ > VIRTIO_NET_RSS_MAX_KEY_SIZE) {\n+\t\t\tdev_err(&vdev->dev, \"rss_max_key_size=%u\
  \ exceeds the limit %u.\\n\",\n+\t\t\t\tvi->rss_key_size, VIRTIO_NET_RSS_MAX_KEY_SIZE);\n\
  +\t\t\terr = -EINVAL;\n+\t\t\tgoto free;\n+\t\t}\n \n \t\tvi->rss_hash_types_supported\
  \ =\n \t\t    virtio_cread32(vdev, offsetof(struct virtio_net_config, supported_hash_types));\n\
  ```\n"
pattern: "## Bug Pattern\n\nTrusting a device-provided size field without validation\
  \ against a driver-defined maximum and then using it to size/copy into fixed-size\
  \ buffers. Specifically, reading rss_max_key_size from the virtio config and using\
  \ it as the RSS key length without checking it is \u2264 VIRTIO_NET_RSS_MAX_KEY_SIZE\
  \ can lead to out-of-bounds reads/writes when setting/reading the hash key."
plan: "Plan\n\n1) Program state\n\n- REGISTER_SET_WITH_PROGRAMSTATE(DeviceSizeSet,\
  \ const MemRegion*)\n  - Purpose: Track variables/fields that hold a device-provided\
  \ size (rss_max_key_size) so we can recognize their later uses as \u201Cuntrusted\
  \ length\u201D values.\n\n- No extra alias map is strictly necessary. We will propagate\
  \ the tag on simple assignments in checkBind (destination becomes \u201Cdevice-size\u201D\
  \ if the source is \u201Cdevice-size\u201D).\n\n2) Helper predicates and utilities\n\
  \n- bool isVirtioCreadOfRssKeySize(const CallEvent &Call, CheckerContext &C)\n \
  \ - Return true if Call is to virtio_cread8, virtio_cread16, or virtio_cread32 and:\n\
  \    - The 2nd argument (offset) expression source text contains \u201Crss_max_key_size\u201D\
  \ using ExprHasName.\n  - This catches the specific device-provided size field we\
  \ care about.\n\n- bool isKnownCopyLenSink(const CallEvent &Call, unsigned &DestIdx,\
  \ unsigned &LenIdx)\n  - Recognize and return the destination and length argument\
  \ indices for known copy-like APIs:\n    - memcpy(dest, src, len): DestIdx=0, LenIdx=2\n\
  \    - memmove(dest, src, len): DestIdx=0, LenIdx=2\n    - virtio_cread_bytes(dev,\
  \ off, buf, len): DestIdx=2, LenIdx=3\n  - Extendable if you need more sinks later.\n\
  \n- const MemRegion* resolveExprRegion(const Expr *E, CheckerContext &C)\n  - Use\
  \ getMemRegionFromExpr(E, C) first.\n  - If null, try to find a DeclRefExpr or MemberExpr\
  \ inside E:\n    - Use findSpecificTypeInChildren<DeclRefExpr>(E) or findSpecificTypeInChildren<MemberExpr>(E)\
  \ and call getMemRegionFromExpr on that child expression.\n  - Return the first\
  \ non-null region.\n\n- bool lenComesFromDeviceSize(const Expr *LenE, CheckerContext\
  \ &C)\n  - True if:\n    - LenE is a CallExpr that satisfies isVirtioCreadOfRssKeySize,\
  \ or\n    - resolveExprRegion(LenE, C) returns a region that is in DeviceSizeSet.\n\
  \n- bool getConstArraySizeOfExpr(llvm::APInt &ArraySize, const Expr *DestE)\n  -\
  \ Attempt getArraySizeFromExpr(DestE) directly.\n  - If that fails, try to find\
  \ a DeclRefExpr/MemberExpr child of DestE and call getArraySizeFromExpr on that\
  \ child expression.\n  - Return true only if a constant array size is recovered.\n\
  \n- bool lengthIsProvablyBounded(CheckerContext &C, const Expr *LenE, uint64_t Limit)\n\
  \  - Get SVal of Len argument: SVal LenSVal = C.getState()->getSVal(LenE, C.getLocationContext()).\n\
  \  - If SymbolRef Sym = LenSVal.getAsSymbol() exists, use inferSymbolMaxVal(Sym,\
  \ C). If maxVal exists and maxVal <= Limit, return true. Otherwise false.\n  - If\
  \ no symbol, return false (be conservative).\n\n3) Callbacks and logic\n\nA) checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const\n\n- Goal 1: Mark LHS as\
  \ \u201Cdevice size\u201D when assigned from virtio_creadX reading rss_max_key_size.\n\
  \  - If Loc.getAsRegion() is non-null and S contains a CallExpr RHS that is a call\
  \ to virtio_cread8/16/32 with arg1 containing \u201Crss_max_key_size\u201D (via\
  \ isVirtioCreadOfRssKeySize), then:\n    - State\u2019 = State.add(DeviceSizeSet,\
  \ LHSRegion)\n    - C.addTransition(State\u2019)\n\n- Goal 2: Propagate the tag\
  \ on assignments.\n  - If both LHSRegion and RHSRegion exist (RHS from Val.getAsRegion())\
  \ and RHSRegion is in DeviceSizeSet, then add LHSRegion to DeviceSizeSet.\n  - This\
  \ covers scalar copies like: local_len = vi->rss_key_size; or vi->rss_key_size =\
  \ local_len;\n\nNotes:\n- The Stmt* S in checkBind is enough to find the CallExpr\
  \ on the RHS using findSpecificTypeInChildren<CallExpr>(S).\n- Always ignore implicit\
  \ casts on expressions when searching.\n\nB) checkPreCall(const CallEvent &Call,\
  \ CheckerContext &C) const\n\n- Step 1: Identify sink calls.\n  - If !isKnownCopyLenSink(Call,\
  \ DestIdx, LenIdx) then return.\n\n- Step 2: Determine if the length comes from\
  \ device-provided rss_max_key_size.\n  - const Expr *LenE = Call.getArgExpr(LenIdx);\n\
  \  - If !lenComesFromDeviceSize(LenE, C) then return.\n\n- Step 3: Try to recover\
  \ destination buffer constant capacity.\n  - const Expr *DestE = Call.getArgExpr(DestIdx);\n\
  \  - llvm::APInt ArrSize; if (!getConstArraySizeOfExpr(ArrSize, DestE)) return;\
  \  // If we don\u2019t know the capacity, be silent to avoid FPs.\n\n- Step 4: Check\
  \ if the analyzer can prove Len <= capacity.\n  - uint64_t Limit = ArrSize.getZExtValue();\n\
  \  - If lengthIsProvablyBounded(C, LenE, Limit) return;  // Safe on this path.\n\
  \n- Step 5: Report bug.\n  - Generate a non-fatal error node on the call expression.\n\
  \  - Message: \u201CUnbounded device-provided RSS key length used\u201D\n  - Optionally\
  \ attach source ranges: the len argument\u2019s range, and if available, the assignment\
  \ site where we first tagged the device size.\n  - Emit a PathSensitiveBugReport.\n\
  \nRationale:\n- If there is a prior bound check like \u201Cif (len > VIRTIO_NET_RSS_MAX_KEY_SIZE)\
  \ goto error;\u201D the analyzer will constrain len on the normal path, inferSymbolMaxVal(...)\
  \ will return a value \u2264 Limit and no warning will be emitted. This mirrors\
  \ the bug fix pattern.\n- If no bound check is present, the maxVal is typically\
  \ the full width (e.g., 255 for an 8-bit read), which exceeds the array capacity\
  \ and we report a warning.\n\n4) Optional callback\n\n- No need to implement checkBranchCondition\
  \ explicitly. The analyzer\u2019s built-in constraint tracking is sufficient; inferSymbolMaxVal\
  \ reflects prior \u201Cif\u201D checks.\n- No need for evalAssume or extra state\
  \ for \u201Cchecked\u201D flags.\n\n5) Targeting the patch pattern precisely\n\n\
  - The checker is tailored to flag uses where:\n  - The length originates from virtio_creadX\
  \ of rss_max_key_size, and\n  - The length is used as a copy length into a fixed-size\
  \ array (capacity derivable), and\n  - There is no dominating constraint that makes\
  \ length \u2264 capacity.\n- This directly matches the need to add \u201Cif (rss_key_size\
  \ > VIRTIO_NET_RSS_MAX_KEY_SIZE) goto error;\u201D before using the size to set/read\
  \ the key.\n\n6) Reporting\n\n- Keep it short and clear:\n  - Title: \u201CUnbounded\
  \ device-provided RSS key length used\u201D\n  - Brief description in bug report\
  \ text:\n    - \u201Crss_max_key_size is used without validating against maximum\
  \ key size; potential out-of-bounds.\u201D\n- Use std::make_unique<PathSensitiveBugReport>\
  \ with generateNonFatalErrorNode.\n\n7) Notes to reduce false positives\n\n- Only\
  \ flag when:\n  - The len argument is directly or indirectly derived from a virtio_creadX\
  \ call of rss_max_key_size, and\n  - The destination\u2019s compile-time capacity\
  \ can be recovered (constant array size), and\n  - The analyzer cannot prove len\
  \ \u2264 capacity on the current path.\n- This keeps the checker focused and aligns\
  \ with the exact bug pattern in the target patch."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Track variables/fields that hold a device-provided size (rss_max_key_size).\n\
  REGISTER_SET_WITH_PROGRAMSTATE(DeviceSizeSet, const MemRegion*)\n\nnamespace {\n\
  /* The checker callbacks are to be decided. */\nclass SAGenTestChecker : public\
  \ Checker< check::Bind, check::PreCall > {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unbounded\
  \ device-provided RSS key length used\", \"Memory Safety\")) {}\n\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n\n      // Helpers\n\
  \      bool isVirtioCreadOfRssKeySize(const CallEvent &Call, CheckerContext &C)\
  \ const;\n      bool isVirtioCreadOfRssKeySize(const CallExpr *CE, CheckerContext\
  \ &C) const;\n\n      bool isKnownCopyLenSink(const CallEvent &Call, unsigned &DestIdx,\
  \ unsigned &LenIdx, CheckerContext &C) const;\n\n      const MemRegion* resolveExprRegion(const\
  \ Expr *E, CheckerContext &C) const;\n\n      bool lenComesFromDeviceSize(const\
  \ Expr *LenE, CheckerContext &C) const;\n\n      bool getConstArraySizeOfExpr(llvm::APInt\
  \ &ArraySize, const Expr *DestE, CheckerContext &C) const;\n\n      bool lengthIsProvablyBounded(CheckerContext\
  \ &C, const Expr *LenE, uint64_t Limit) const;\n\n      void report(const CallEvent\
  \ &Call, const Expr *LenE, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isVirtioCreadOfRssKeySize(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Match function name virtio_cread8/16/32\n\
  \  bool IsCread =\n      ExprHasName(Origin, \"virtio_cread8\", C) ||\n      ExprHasName(Origin,\
  \ \"virtio_cread16\", C) ||\n      ExprHasName(Origin, \"virtio_cread32\", C);\n\
  \  if (!IsCread)\n    return false;\n\n  if (Call.getNumArgs() < 2)\n    return\
  \ false;\n\n  const Expr *OffsetExpr = Call.getArgExpr(1);\n  if (!OffsetExpr)\n\
  \    return false;\n\n  // The offset expression should contain \"rss_max_key_size\"\
  \n  return ExprHasName(OffsetExpr, \"rss_max_key_size\", C);\n}\n\nbool SAGenTestChecker::isVirtioCreadOfRssKeySize(const\
  \ CallExpr *CE, CheckerContext &C) const {\n  if (!CE)\n    return false;\n\n  //\
  \ Check callee name using source text\n  if (!(ExprHasName(CE, \"virtio_cread8\"\
  , C) ||\n        ExprHasName(CE, \"virtio_cread16\", C) ||\n        ExprHasName(CE,\
  \ \"virtio_cread32\", C)))\n    return false;\n\n  if (CE->getNumArgs() < 2)\n \
  \   return false;\n\n  const Expr *OffsetExpr = CE->getArg(1);\n  if (!OffsetExpr)\n\
  \    return false;\n\n  return ExprHasName(OffsetExpr, \"rss_max_key_size\", C);\n\
  }\n\nbool SAGenTestChecker::isKnownCopyLenSink(const CallEvent &Call, unsigned &DestIdx,\
  \ unsigned &LenIdx, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // memcpy(dest, src, len)\n  if (ExprHasName(Origin,\
  \ \"memcpy\", C)) {\n    if (Call.getNumArgs() >= 3) {\n      DestIdx = 0;\n   \
  \   LenIdx = 2;\n      return true;\n    }\n    return false;\n  }\n\n  // memmove(dest,\
  \ src, len)\n  if (ExprHasName(Origin, \"memmove\", C)) {\n    if (Call.getNumArgs()\
  \ >= 3) {\n      DestIdx = 0;\n      LenIdx = 2;\n      return true;\n    }\n  \
  \  return false;\n  }\n\n  // virtio_cread_bytes(dev, off, buf, len)\n  if (ExprHasName(Origin,\
  \ \"virtio_cread_bytes\", C)) {\n    if (Call.getNumArgs() >= 4) {\n      DestIdx\
  \ = 2;\n      LenIdx = 3;\n      return true;\n    }\n    return false;\n  }\n\n\
  \  return false;\n}\n\nconst MemRegion* SAGenTestChecker::resolveExprRegion(const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E)\n    return nullptr;\n\n  const\
  \ MemRegion *MR = getMemRegionFromExpr(E, C);\n  if (MR) {\n    MR = MR->getBaseRegion();\n\
  \    return MR;\n  }\n\n  // Try find a DeclRefExpr child\n  if (const auto *DRE\
  \ = findSpecificTypeInChildren<DeclRefExpr>(E)) {\n    MR = getMemRegionFromExpr(DRE,\
  \ C);\n    if (MR) {\n      MR = MR->getBaseRegion();\n      return MR;\n    }\n\
  \  }\n\n  // Try find a MemberExpr child\n  if (const auto *ME = findSpecificTypeInChildren<MemberExpr>(E))\
  \ {\n    MR = getMemRegionFromExpr(ME, C);\n    if (MR) {\n      MR = MR->getBaseRegion();\n\
  \      return MR;\n    }\n  }\n\n  return nullptr;\n}\n\nbool SAGenTestChecker::lenComesFromDeviceSize(const\
  \ Expr *LenE, CheckerContext &C) const {\n  if (!LenE)\n    return false;\n\n  //\
  \ Case 1: direct call to virtio_creadX(..., rss_max_key_size)\n  if (const auto\
  \ *CE = dyn_cast<CallExpr>(LenE->IgnoreParenCasts())) {\n    if (isVirtioCreadOfRssKeySize(CE,\
  \ C))\n      return true;\n  }\n\n  // Case 2: variable/field previously marked\
  \ as device size\n  if (const MemRegion *MR = resolveExprRegion(LenE, C)) {\n  \
  \  ProgramStateRef State = C.getState();\n    if (State->contains<DeviceSizeSet>(MR))\n\
  \      return true;\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::getConstArraySizeOfExpr(llvm::APInt\
  \ &ArraySize, const Expr *DestE, CheckerContext &C) const {\n  if (!DestE)\n   \
  \ return false;\n\n  // First try the provided helper on the expression directly.\n\
  \  if (getArraySizeFromExpr(ArraySize, DestE))\n    return true;\n\n  // Check if\
  \ the expression type itself is a constant array.\n  QualType QT = DestE->getType();\n\
  \  if (!QT.isNull()) {\n    if (const auto *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr()))\
  \ {\n      ArraySize = CAT->getSize();\n      return true;\n    }\n  }\n\n  // Try\
  \ DeclRefExpr child\n  if (const auto *DRE = findSpecificTypeInChildren<DeclRefExpr>(DestE))\
  \ {\n    if (getArraySizeFromExpr(ArraySize, DRE))\n      return true;\n\n    //\
  \ Also try type of the referenced declaration\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n      QualType VDTy = VD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(VDTy.getTypePtr()))\
  \ {\n        ArraySize = CAT->getSize();\n        return true;\n      }\n    }\n\
  \  }\n\n  // Try MemberExpr child: get the FieldDecl type\n  if (const auto *ME\
  \ = findSpecificTypeInChildren<MemberExpr>(DestE)) {\n    if (const auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl()))\
  \ {\n      QualType FTy = FD->getType();\n      if (const auto *CAT = dyn_cast<ConstantArrayType>(FTy.getTypePtr()))\
  \ {\n        ArraySize = CAT->getSize();\n        return true;\n      }\n    }\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::lengthIsProvablyBounded(CheckerContext\
  \ &C, const Expr *LenE, uint64_t Limit) const {\n  if (!LenE)\n    return false;\n\
  \n  ProgramStateRef State = C.getState();\n  SVal LenSVal = State->getSVal(LenE,\
  \ C.getLocationContext());\n  if (SymbolRef Sym = LenSVal.getAsSymbol()) {\n   \
  \ if (const llvm::APSInt *Max = inferSymbolMaxVal(Sym, C)) {\n      // If we can\
  \ infer a maximum and it's <= Limit, it's safe\n      uint64_t MaxZ = Max->getZExtValue();\n\
  \      return MaxZ <= Limit;\n    }\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::report(const\
  \ CallEvent &Call, const Expr *LenE, CheckerContext &C) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Unbounded device-provided RSS key length used\", N);\n\n  if (LenE)\n\
  \    R->addRange(LenE->getSourceRange());\n  if (const Expr *OE = Call.getOriginExpr())\n\
  \    R->addRange(OE->getSourceRange());\n\n  C.emitReport(std::move(R));\n}\n\n\
  void SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *LHSReg\
  \ = Loc.getAsRegion();\n  if (LHSReg)\n    LHSReg = LHSReg->getBaseRegion();\n\n\
  \  // Propagate tag on simple assignments: if RHS region is in set, add LHS\n  if\
  \ (LHSReg) {\n    if (const MemRegion *RHSReg = Val.getAsRegion()) {\n      RHSReg\
  \ = RHSReg->getBaseRegion();\n      if (RHSReg && State->contains<DeviceSizeSet>(RHSReg))\
  \ {\n        State = State->add<DeviceSizeSet>(LHSReg);\n        C.addTransition(State);\n\
  \        return;\n      }\n    }\n  }\n\n  // If RHS is a call to virtio_cread{8,16,32}(...,\
  \ rss_max_key_size), mark LHS\n  if (LHSReg && S) {\n    // Find a CallExpr under\
  \ this statement (assignment RHS)\n    if (const auto *CE = findSpecificTypeInChildren<CallExpr>(S))\
  \ {\n      if (isVirtioCreadOfRssKeySize(CE, C)) {\n        State = State->add<DeviceSizeSet>(LHSReg);\n\
  \        C.addTransition(State);\n        return;\n      }\n    }\n  }\n}\n\nvoid\
  \ SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  unsigned DestIdx = 0, LenIdx = 0;\n  if (!isKnownCopyLenSink(Call, DestIdx,\
  \ LenIdx, C))\n    return;\n\n  const Expr *LenE = Call.getArgExpr(LenIdx);\n  if\
  \ (!lenComesFromDeviceSize(LenE, C))\n    return;\n\n  // Determine destination\
  \ capacity\n  const Expr *DestE = Call.getArgExpr(DestIdx);\n  llvm::APInt ArrSize;\n\
  \  if (!getConstArraySizeOfExpr(ArrSize, DestE, C))\n    return; // Can't prove\
  \ destination capacity; avoid false positives\n\n  uint64_t Capacity = ArrSize.getZExtValue();\n\
  \  if (lengthIsProvablyBounded(C, LenE, Capacity))\n    return; // Proved safe on\
  \ this path\n\n  // Report: device-provided rss key length used without bound check\n\
  \  report(Call, LenE, C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects unbounded device-provided RSS\
  \ key length usage in copy-like APIs\",\n      \"\");\n}\n\nextern \"C\" const char\
  \ clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
