_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: d8c561741ef83980114b3f7f95ffac54600f3f16
commit_type: Double-Free
index: 7
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Track variables that currently hold the return value of a known \"set_ready\"\
  \ call.\n// Map: VarRegion -> Resource pattern index (unsigned).\nREGISTER_MAP_WITH_PROGRAMSTATE(ReadyErrVarMap,\
  \ const MemRegion *, unsigned)\n\nnamespace {\n\n// Knowledge base for the target\
  \ pattern.\nstruct ResourcePattern {\n  const char *ReadySetter;\n  const char *const\
  \ *CompositeCloses;   // functions that close/free too much (bad here)\n  unsigned\
  \ NumCompositeCloses;\n  const char *const *AllowedDestroys;   // correct functions\
  \ to call in error path\n  unsigned NumAllowedDestroys;\n};\n\n// Pattern 0: mlx5\
  \ SQ ready/set + close/destroy names.\nstatic const char *const Pattern0CompositeCloses[]\
  \ = {\n  \"hws_send_ring_close_sq\"\n};\nstatic const char *const Pattern0AllowedDestroys[]\
  \ = {\n  \"mlx5_core_destroy_sq\",\n  \"hws_send_ring_destroy_sq\"\n};\nstatic const\
  \ ResourcePattern Patterns[] = {\n  {\n    \"hws_send_ring_set_sq_rdy\",\n    Pattern0CompositeCloses,\
  \ sizeof(Pattern0CompositeCloses) / sizeof(const char *),\n    Pattern0AllowedDestroys,\
  \ sizeof(Pattern0AllowedDestroys) / sizeof(const char *)\n  }\n};\nstatic constexpr\
  \ unsigned NumPatterns = sizeof(Patterns) / sizeof(ResourcePattern);\n\n// Helper:\
  \ extract direct callee name if possible.\nstatic StringRef getDirectCalleeName(const\
  \ CallExpr *CE) {\n  if (!CE)\n    return StringRef();\n  if (const FunctionDecl\
  \ *FD = CE->getDirectCallee()) {\n    if (const IdentifierInfo *II = FD->getIdentifier())\n\
  \      return II->getName();\n  }\n  return StringRef();\n}\n\n// Helper: Does CE\
  \ match any of the provided names? Prefer direct name, fallback to source-text search\
  \ via ExprHasName.\nstatic bool callMatchesAny(const CallExpr *CE, ArrayRef<const\
  \ char *> Names, CheckerContext &C) {\n  StringRef DirectName = getDirectCalleeName(CE);\n\
  \  if (!DirectName.empty()) {\n    for (const char *N : Names) {\n      if (DirectName.equals(N))\n\
  \        return true;\n    }\n  }\n  for (const char *N : Names) {\n    if (ExprHasName(CE,\
  \ N, C))\n      return true;\n  }\n  return false;\n}\n\nstatic int findReadySetterIndexByName(StringRef\
  \ Name) {\n  for (unsigned i = 0; i < NumPatterns; ++i) {\n    if (Name.equals(Patterns[i].ReadySetter))\n\
  \      return static_cast<int>(i);\n  }\n  return -1;\n}\n\nstatic int findReadySetterIndexByCall(const\
  \ CallExpr *CE, CheckerContext &C) {\n  // First try direct callee name.\n  StringRef\
  \ Direct = getDirectCalleeName(CE);\n  if (!Direct.empty()) {\n    int Idx = findReadySetterIndexByName(Direct);\n\
  \    if (Idx >= 0)\n      return Idx;\n  }\n  // Fallback: check by ExprHasName\
  \ against all patterns.\n  for (unsigned i = 0; i < NumPatterns; ++i) {\n    if\
  \ (ExprHasName(CE, Patterns[i].ReadySetter, C))\n      return static_cast<int>(i);\n\
  \  }\n  return -1;\n}\n\nstatic bool isCompositeCloseCall(unsigned Idx, const CallExpr\
  \ *CE, CheckerContext &C) {\n  if (Idx >= NumPatterns) return false;\n  ArrayRef<const\
  \ char *> Names(Patterns[Idx].CompositeCloses, Patterns[Idx].NumCompositeCloses);\n\
  \  return callMatchesAny(CE, Names, C);\n}\n\nstatic bool isAllowedDestroyCall(unsigned\
  \ Idx, const CallExpr *CE, CheckerContext &C) {\n  if (Idx >= NumPatterns) return\
  \ false;\n  ArrayRef<const char *> Names(Patterns[Idx].AllowedDestroys, Patterns[Idx].NumAllowedDestroys);\n\
  \  return callMatchesAny(CE, Names, C);\n}\n\n// Collect all CallExpr nodes under\
  \ a given statement.\nstruct CallCollector : public RecursiveASTVisitor<CallCollector>\
  \ {\n  llvm::SmallVector<const CallExpr *, 16> Calls;\n  bool VisitCallExpr(const\
  \ CallExpr *CE) {\n    Calls.push_back(CE);\n    return true;\n  }\n};\n\nstatic\
  \ void collectCallExprs(const Stmt *S, llvm::SmallVectorImpl<const CallExpr *> &Out)\
  \ {\n  if (!S) return;\n  CallCollector V;\n  // TraverseStmt expects non-const\
  \ pointer, cast away const for traversal only.\n  V.TraverseStmt(const_cast<Stmt\
  \ *>(S));\n  Out.append(V.Calls.begin(), V.Calls.end());\n}\n\nclass SAGenTestChecker\
  \ : public Checker<check::Bind, check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Composite\
  \ close in set_ready() error path\", \"Resource Management\")) {}\n\n      void\
  \ checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n     \
  \ void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\n\
  \   private:\n      void reportCompositeClose(const CallExpr *BadCall, CheckerContext\
  \ &C) const;\n};\n\nvoid SAGenTestChecker::reportCompositeClose(const CallExpr *BadCall,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Composite close in set_ready() error path; call destroy() to avoid\
  \ double free.\", N);\n  if (BadCall)\n    R->addRange(BadCall->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc,\
  \ SVal /*Val*/, const Stmt *S, CheckerContext &C) const {\n  if (!S)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n\n  // Get LHS region from the store\
  \ location.\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\n  \
  \  return;\n  LHSReg = LHSReg->getBaseRegion();\n  if (!LHSReg)\n    return;\n\n\
  \  // Ensure it's a typed variable region with integral type (like \"int err\").\n\
  \  const auto *TVR = dyn_cast<TypedValueRegion>(LHSReg);\n  if (!TVR)\n    return;\n\
  \  QualType LTy = TVR->getValueType();\n  if (LTy.isNull() || !LTy->isIntegerType())\n\
  \    return;\n\n  // Attempt to find a CallExpr on the RHS within this statement.\n\
  \  const CallExpr *RHSCall = findSpecificTypeInChildren<CallExpr>(S);\n  if (!RHSCall)\
  \ {\n    // No call on RHS; clear any previous mapping for this variable.\n    State\
  \ = State->remove<ReadyErrVarMap>(LHSReg);\n    C.addTransition(State);\n    return;\n\
  \  }\n\n  // Determine if this is a known ReadySetter call.\n  int Idx = findReadySetterIndexByCall(RHSCall,\
  \ C);\n  if (Idx >= 0) {\n    State = State->set<ReadyErrVarMap>(LHSReg, static_cast<unsigned>(Idx));\n\
  \  } else {\n    State = State->remove<ReadyErrVarMap>(LHSReg);\n  }\n\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!Condition)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \n  // Step A: Determine if condition checks a known set_ready() failure.\n\n  //\
  \ Case A1: inline call in condition.\n  unsigned Idx = static_cast<unsigned>(-1);\n\
  \  bool FromVar = false;\n  const MemRegion *CondVarReg = nullptr;\n\n  const CallExpr\
  \ *CondCall = findSpecificTypeInChildren<CallExpr>(Condition);\n  if (CondCall)\
  \ {\n    int Tmp = findReadySetterIndexByCall(CondCall, C);\n    if (Tmp >= 0)\n\
  \      Idx = static_cast<unsigned>(Tmp);\n  }\n\n  // Case A2: variable in condition\
  \ (err, err != 0, err < 0, etc.).\n  if (Idx == static_cast<unsigned>(-1)) {\n \
  \   const DeclRefExpr *DRE = findSpecificTypeInChildren<DeclRefExpr>(Condition);\n\
  \    if (DRE) {\n      const MemRegion *MR = getMemRegionFromExpr(DRE, C);\n   \
  \   if (MR) {\n        MR = MR->getBaseRegion();\n        if (MR) {\n          if\
  \ (const unsigned *SavedIdx = State->get<ReadyErrVarMap>(MR)) {\n            Idx\
  \ = *SavedIdx;\n            FromVar = true;\n            CondVarReg = MR;\n    \
  \      }\n        }\n      }\n    }\n  }\n\n  if (Idx == static_cast<unsigned>(-1))\n\
  \    return; // Not a set_ready guarded condition.\n\n  // Step B: Find the containing\
  \ IfStmt and its then-branch.\n  const IfStmt *IS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IS)\n    return;\n\n  const Stmt *Then = IS->getThen();\n  if (!Then)\n\
  \    return;\n\n  // Step C: Search the then-body for a composite close call.\n\
  \  llvm::SmallVector<const CallExpr *, 16> Calls;\n  collectCallExprs(Then, Calls);\n\
  \n  for (const CallExpr *CE : Calls) {\n    if (isCompositeCloseCall(Idx, CE, C))\
  \ {\n      // Found the problematic composite close call.\n      reportCompositeClose(CE,\
  \ C);\n      break;\n    }\n  }\n\n  // Step D: Cleanup transient mapping for condition\
  \ variable if used.\n  if (FromVar && CondVarReg) {\n    State = State->remove<ReadyErrVarMap>(CondVarReg);\n\
  \    C.addTransition(State);\n  }\n}\n\n} // end anonymous namespace\n\nextern \"\
  C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects composite close/cleanup in\
  \ set_ready() error path which may cause double free; use destroy()\",\n      \"\
  \");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/mlx5: HWS, fixed double-free in error flow of\
  \ creating SQ\n\nWhen SQ creation fails, call the appropriate mlx5_core destroy\
  \ function.\n\nThis fixes the following smatch warnings:\n  divers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c:739\n\
  \    hws_send_ring_open_sq() warn: 'sq->dep_wqe' double freed\n    hws_send_ring_open_sq()\
  \ warn: 'sq->wq_ctrl.buf.frags' double freed\n    hws_send_ring_open_sq() warn:\
  \ 'sq->wr_priv' double freed\n\nFixes: 2ca62599aa0b (\"net/mlx5: HWS, added send\
  \ engine and context handling\")\nReported-by: Dan Carpenter <dan.carpenter@linaro.org>\n\
  Closes: https://lore.kernel.org/all/e4ebc227-4b25-49bf-9e4c-14b7ea5c6a07@stanley.mountain/\n\
  Signed-off-by: Yevgeny Kliteynik <kliteyn@nvidia.com>\nSigned-off-by: Saeed Mahameed\
  \ <saeedm@nvidia.com>\n\n## Buggy Code\n\n```c\n// Function: hws_send_ring_create_sq\
  \ in drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\nstatic\
  \ int hws_send_ring_create_sq(struct mlx5_core_dev *mdev, u32 pdn,\n\t\t\t\t   void\
  \ *sqc_data,\n\t\t\t\t   struct mlx5hws_send_engine *queue,\n\t\t\t\t   struct mlx5hws_send_ring_sq\
  \ *sq,\n\t\t\t\t   struct mlx5hws_send_ring_cq *cq)\n{\n\tvoid *in, *sqc, *wq;\n\
  \tint inlen, err;\n\tu8 ts_format;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_sq_in) +\n\
  \t\tsizeof(u64) * sq->wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\
  \tif (!in)\n\t\treturn -ENOMEM;\n\n\tsqc = MLX5_ADDR_OF(create_sq_in, in, ctx);\n\
  \twq = MLX5_ADDR_OF(sqc, sqc, wq);\n\n\tmemcpy(sqc, sqc_data, MLX5_ST_SZ_BYTES(sqc));\n\
  \tMLX5_SET(sqc, sqc, cqn, cq->mcq.cqn);\n\n\tMLX5_SET(sqc, sqc, state, MLX5_SQC_STATE_RST);\n\
  \tMLX5_SET(sqc, sqc, flush_in_error_en, 1);\n\n\tts_format = mlx5_is_real_time_sq(mdev)\
  \ ? MLX5_TIMESTAMP_FORMAT_REAL_TIME :\n\t\t\t\t\t\t MLX5_TIMESTAMP_FORMAT_FREE_RUNNING;\n\
  \tMLX5_SET(sqc, sqc, ts_format, ts_format);\n\n\tMLX5_SET(wq, wq, wq_type, MLX5_WQ_TYPE_CYCLIC);\n\
  \tMLX5_SET(wq, wq, uar_page, mdev->mlx5e_res.hw_objs.bfreg.index);\n\tMLX5_SET(wq,\
  \ wq, log_wq_pg_sz, sq->wq_ctrl.buf.page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(wq,\
  \ wq, dbr_addr, sq->wq_ctrl.db.dma);\n\n\tmlx5_fill_page_frag_array(&sq->wq_ctrl.buf,\n\
  \t\t\t\t  (__be64 *)MLX5_ADDR_OF(wq, wq, pas));\n\n\terr = mlx5_core_create_sq(mdev,\
  \ in, inlen, &sq->sqn);\n\n\tkvfree(in);\n\n\treturn err;\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\
  \ b/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\nindex a1adbb48735c..0c7989184c30\
  \ 100644\n--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\n\
  +++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/hws/mlx5hws_send.c\n@@ -653,6\
  \ +653,12 @@ static int hws_send_ring_create_sq(struct mlx5_core_dev *mdev, u32\
  \ pdn,\n \treturn err;\n }\n \n+static void hws_send_ring_destroy_sq(struct mlx5_core_dev\
  \ *mdev,\n+\t\t\t\t     struct mlx5hws_send_ring_sq *sq)\n+{\n+\tmlx5_core_destroy_sq(mdev,\
  \ sq->sqn);\n+}\n+\n static int hws_send_ring_set_sq_rdy(struct mlx5_core_dev *mdev,\
  \ u32 sqn)\n {\n \tvoid *in, *sqc;\n@@ -696,7 +702,7 @@ static int hws_send_ring_create_sq_rdy(struct\
  \ mlx5_core_dev *mdev, u32 pdn,\n \n \terr = hws_send_ring_set_sq_rdy(mdev, sq->sqn);\n\
  \ \tif (err)\n-\t\thws_send_ring_close_sq(sq);\n+\t\thws_send_ring_destroy_sq(mdev,\
  \ sq);\n \n \treturn err;\n }\n```\n"
pattern: "## Bug Pattern\n\nUsing a full \u201Cclose\u201D/composite cleanup helper\
  \ on a partially initialized object in an error path, instead of the stage-matched\
  \ low-level destroy routine, causing resources to be freed twice.\n\nConcretely:\
  \ after successfully creating an SQ (mlx5_core_create_sq) but failing to set it\
  \ Ready, the code called hws_send_ring_close_sq(sq), which tears down both HW and\
  \ SW allocations (dep_wqe, wq_ctrl.buf.frags, wr_priv) that are also freed by the\
  \ higher-level error unwinder. The correct pattern is to call only mlx5_core_destroy_sq()\
  \ at that stage, matching what has been allocated so far, and leave the rest to\
  \ the outer cleanup to avoid double-free."
plan: "Plan\n\n1. Program state\n- REGISTER_MAP_WITH_PROGRAMSTATE(ReadyErrVarMap,\
  \ const MemRegion *, unsigned)\n  - Maps an integer variable\u2019s region (e.g.,\
  \ \u201Cerr\u201D) to a resource-pattern index indicating \u201Cthis variable currently\
  \ holds the return of a known set_ready()-like call\u201D. The unsigned is the index\
  \ into our static knowledge base (see Step 2).\n\n2. Knowledge base (hard-coded\
  \ names for this pattern)\n- Define a small static table of resource patterns:\n\
  \  - Entry 0 (mlx5 sq):\n    - ReadySetter: \"hws_send_ring_set_sq_rdy\"\n    -\
  \ CompositeCloses: {\"hws_send_ring_close_sq\"}\n    - AllowedDestroys: {\"mlx5_core_destroy_sq\"\
  , \"hws_send_ring_destroy_sq\"}\n- Provide helpers:\n  - int findReadySetterIndex(StringRef\
  \ Name): returns the index for a name in ReadySetter, or -1 if not found.\n  - bool\
  \ isCompositeCloseName(unsigned Idx, StringRef Name)\n  - bool isAllowedDestroyName(unsigned\
  \ Idx, StringRef Name)\n\n3. Callbacks to use and how to implement\n\n3.1 checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const\n- Goal: Track variables\
  \ assigned from a ReadySetter call.\n- Only proceed if S is a BinaryOperator with\
  \ opcode BO_Assign.\n- Extract LHS and RHS expressions:\n  - LHS: use getMemRegionFromExpr(LHS,\
  \ C). If not a VarRegion (or not integral type), ignore.\n  - RHS: use findSpecificTypeInChildren<CallExpr>(S)\
  \ to locate the call on the RHS.\n    - If no CallExpr, erase any existing mapping\
  \ for this LHS VarRegion in ReadyErrVarMap and return.\n- From the found CallExpr:\n\
  \  - Get callee Identifier and its name.\n  - If findReadySetterIndex(Name) returns\
  \ Idx >= 0:\n    - State = State->set<ReadyErrVarMap>(LHSRegion, (unsigned)Idx)\n\
  \  - Else:\n    - Remove any prior mapping for this LHSRegion (the error variable\
  \ no longer corresponds to a set_ready result).\n- Rationale: This lets us later\
  \ recognize conditions like \u201Cif (err)\u201D or \u201Cif (err != 0)\u201D as\
  \ guarding an error path right after a specific set_ready() call.\n\n3.2 checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const\n- Goal: Detect \u201Cif (set_ready\
  \ fails) then composite-close()\u201D pattern.\n- Step A: Determine if this condition\
  \ is about a known ReadySetter failure.\n  - Case A1 (inline call in condition):\n\
  \    - Look for a CallExpr within Condition using findSpecificTypeInChildren<CallExpr>(Condition).\n\
  \    - If found, get the callee name and look up the ReadySetter index Idx with\
  \ findReadySetterIndex.\n    - If Idx < 0, continue to Case A2; else we consider\
  \ this a guarded set_ready error path.\n  - Case A2 (variable in condition):\n \
  \   - Collect DeclRefExpr (possibly via walk or just use findSpecificTypeInChildren<DeclRefExpr>(Condition)).\
  \ If found:\n      - Resolve its MemRegion via getMemRegionFromExpr on the DeclRefExpr.\n\
  \      - Lookup ReadyErrVarMap for this region; if present, retrieve Idx (resource-pattern\
  \ index). If not present, we do not consider it a guarded set_ready error path.\n\
  - If neither A1 nor A2 succeeds, return (this if-condition is not a set_ready error\
  \ check).\n- Step B: Find the containing IfStmt.\n  - Use findSpecificTypeInParents<IfStmt>(Condition,\
  \ C) to get the IfStmt.\n  - If null, return.\n  - Let Then = IfStmt->getThen().\n\
  - Step C: Search Then-body for a call to a composite close\n  - Walk the Then subtree\
  \ to find CallExprs (either write a small recursive visitor or reuse findSpecificTypeInChildren<CallExpr>(Then)\
  \ once; simplest: check the first CallExpr with findSpecificTypeInChildren and validate\
  \ callee name; if you implement a trivial loop, stop after you detect the first\
  \ composite close).\n  - For each CallExpr found, get the callee name:\n    - If\
  \ isCompositeCloseName(Idx, Name) is true:\n      - (Optional) If Then also contains\
  \ an AllowedDestroy call (isAllowedDestroyName), you may still report since the\
  \ composite close is present in the guarded error path.\n      - Emit a bug report\
  \ at this call site (see Reporting in Step 5).\n      - Break to avoid duplicate\
  \ reports for the same IfStmt.\n- Step D: Cleanup transient mapping\n  - If Case\
  \ A2 applied (condition variable was mapped in ReadyErrVarMap), consider removing\
  \ that mapping (State->remove<ReadyErrVarMap>(VarRegion)) to avoid repeated alerts\
  \ on subsequent unrelated branches.\n\n3.3 Optional: checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const\n- Not strictly needed. We handle inline call-in-condition\
  \ via BranchCondition by searching for a CallExpr child. If desired, you can implement\
  \ a lightweight detection cache here, but keep it simple as per requirements.\n\n\
  4. Utility details and matching logic\n- Getting callee names:\n  - From CallExpr:\
  \ CE->getDirectCallee() and then getIdentifier()->getName() (guard nulls).\n- Recognizing\
  \ condition forms:\n  - We don\u2019t evaluate the truth value; we only require\
  \ the condition to reference either:\n    - a direct call to a known ReadySetter;\
  \ or\n    - a variable previously recorded in ReadyErrVarMap.\n  - This covers common\
  \ forms:\n    - if (set_ready(...)) { ... }\n    - if (err) { ... }\n    - if (err\
  \ != 0) { ... }\n    - if (err < 0) { ... }\n- Region retrieval:\n  - Use getMemRegionFromExpr\
  \ on LHS of assignment and DeclRefExprs in conditions.\n- Child/parent navigation:\n\
  \  - Use provided findSpecificTypeInChildren and findSpecificTypeInParents for local,\
  \ simple matching.\n\n5. Reporting\n- When a composite close is found in the then-branch\
  \ of a set_ready error path:\n  - Create a non-fatal error node with C.generateNonFatalErrorNode().\n\
  \  - Emit a PathSensitiveBugReport with a short message:\n    - \u201CComposite\
  \ close in set_ready() error path; call destroy() to avoid double free.\u201D\n\
  \  - Attach the CallExpr of the composite close as the primary location.\n- Category:\
  \ \u201CMemory Error\u201D or \u201CResource Management\u201D.\n- Do not suggest\
  \ fix-its; just the short and clear message.\n\n6. Notes and limitations (accepted\
  \ for simplicity)\n- Heuristic, name-based matching using a small knowledge base\
  \ (hws_send_ring_set_sq_rdy vs hws_send_ring_close_sq).\n- Object identity is not\
  \ enforced (set_ready takes sqn, close takes sq*), which is okay for this targeted\
  \ checker.\n- Only checks direct then-body; if the body uses goto to a label with\
  \ the close call, this simple plan will not catch it (kept simple by design).\n\
  - Only the first found CallExpr in the then-body is checked if you use the provided\
  \ child-finder; you may implement a trivial recursive walk to check all calls if\
  \ desired."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Track variables that currently hold the return value of a known \"set_ready\"\
  \ call.\n// Map: VarRegion -> Resource pattern index (unsigned).\nREGISTER_MAP_WITH_PROGRAMSTATE(ReadyErrVarMap,\
  \ const MemRegion *, unsigned)\n\nnamespace {\n\n// Knowledge base for the target\
  \ pattern.\nstruct ResourcePattern {\n  const char *ReadySetter;\n  const char *const\
  \ *CompositeCloses;   // functions that close/free too much (bad here)\n  unsigned\
  \ NumCompositeCloses;\n  const char *const *AllowedDestroys;   // correct functions\
  \ to call in error path\n  unsigned NumAllowedDestroys;\n};\n\n// Pattern 0: mlx5\
  \ SQ ready/set + close/destroy names.\nstatic const char *const Pattern0CompositeCloses[]\
  \ = {\n  \"hws_send_ring_close_sq\"\n};\nstatic const char *const Pattern0AllowedDestroys[]\
  \ = {\n  \"mlx5_core_destroy_sq\",\n  \"hws_send_ring_destroy_sq\"\n};\nstatic const\
  \ ResourcePattern Patterns[] = {\n  {\n    \"hws_send_ring_set_sq_rdy\",\n    Pattern0CompositeCloses,\
  \ sizeof(Pattern0CompositeCloses) / sizeof(const char *),\n    Pattern0AllowedDestroys,\
  \ sizeof(Pattern0AllowedDestroys) / sizeof(const char *)\n  }\n};\nstatic constexpr\
  \ unsigned NumPatterns = sizeof(Patterns) / sizeof(ResourcePattern);\n\n// Helper:\
  \ extract direct callee name if possible.\nstatic StringRef getDirectCalleeName(const\
  \ CallExpr *CE) {\n  if (!CE)\n    return StringRef();\n  if (const FunctionDecl\
  \ *FD = CE->getDirectCallee()) {\n    if (const IdentifierInfo *II = FD->getIdentifier())\n\
  \      return II->getName();\n  }\n  return StringRef();\n}\n\n// Helper: Does CE\
  \ match any of the provided names? Prefer direct name, fallback to source-text search\
  \ via ExprHasName.\nstatic bool callMatchesAny(const CallExpr *CE, ArrayRef<const\
  \ char *> Names, CheckerContext &C) {\n  StringRef DirectName = getDirectCalleeName(CE);\n\
  \  if (!DirectName.empty()) {\n    for (const char *N : Names) {\n      if (DirectName.equals(N))\n\
  \        return true;\n    }\n  }\n  for (const char *N : Names) {\n    if (ExprHasName(CE,\
  \ N, C))\n      return true;\n  }\n  return false;\n}\n\nstatic int findReadySetterIndexByName(StringRef\
  \ Name) {\n  for (unsigned i = 0; i < NumPatterns; ++i) {\n    if (Name.equals(Patterns[i].ReadySetter))\n\
  \      return static_cast<int>(i);\n  }\n  return -1;\n}\n\nstatic int findReadySetterIndexByCall(const\
  \ CallExpr *CE, CheckerContext &C) {\n  // First try direct callee name.\n  StringRef\
  \ Direct = getDirectCalleeName(CE);\n  if (!Direct.empty()) {\n    int Idx = findReadySetterIndexByName(Direct);\n\
  \    if (Idx >= 0)\n      return Idx;\n  }\n  // Fallback: check by ExprHasName\
  \ against all patterns.\n  for (unsigned i = 0; i < NumPatterns; ++i) {\n    if\
  \ (ExprHasName(CE, Patterns[i].ReadySetter, C))\n      return static_cast<int>(i);\n\
  \  }\n  return -1;\n}\n\nstatic bool isCompositeCloseCall(unsigned Idx, const CallExpr\
  \ *CE, CheckerContext &C) {\n  if (Idx >= NumPatterns) return false;\n  ArrayRef<const\
  \ char *> Names(Patterns[Idx].CompositeCloses, Patterns[Idx].NumCompositeCloses);\n\
  \  return callMatchesAny(CE, Names, C);\n}\n\nstatic bool isAllowedDestroyCall(unsigned\
  \ Idx, const CallExpr *CE, CheckerContext &C) {\n  if (Idx >= NumPatterns) return\
  \ false;\n  ArrayRef<const char *> Names(Patterns[Idx].AllowedDestroys, Patterns[Idx].NumAllowedDestroys);\n\
  \  return callMatchesAny(CE, Names, C);\n}\n\n// Collect all CallExpr nodes under\
  \ a given statement.\nstruct CallCollector : public RecursiveASTVisitor<CallCollector>\
  \ {\n  llvm::SmallVector<const CallExpr *, 16> Calls;\n  bool VisitCallExpr(const\
  \ CallExpr *CE) {\n    Calls.push_back(CE);\n    return true;\n  }\n};\n\nstatic\
  \ void collectCallExprs(const Stmt *S, llvm::SmallVectorImpl<const CallExpr *> &Out)\
  \ {\n  if (!S) return;\n  CallCollector V;\n  // TraverseStmt expects non-const\
  \ pointer, cast away const for traversal only.\n  V.TraverseStmt(const_cast<Stmt\
  \ *>(S));\n  Out.append(V.Calls.begin(), V.Calls.end());\n}\n\nclass SAGenTestChecker\
  \ : public Checker<check::Bind, check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Composite\
  \ close in set_ready() error path\", \"Resource Management\")) {}\n\n      void\
  \ checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n     \
  \ void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\n\
  \   private:\n      void reportCompositeClose(const CallExpr *BadCall, CheckerContext\
  \ &C) const;\n};\n\nvoid SAGenTestChecker::reportCompositeClose(const CallExpr *BadCall,\
  \ CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Composite close in set_ready() error path; call destroy() to avoid\
  \ double free.\", N);\n  if (BadCall)\n    R->addRange(BadCall->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc,\
  \ SVal /*Val*/, const Stmt *S, CheckerContext &C) const {\n  if (!S)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n\n  // Get LHS region from the store\
  \ location.\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\n  \
  \  return;\n  LHSReg = LHSReg->getBaseRegion();\n  if (!LHSReg)\n    return;\n\n\
  \  // Ensure it's a typed variable region with integral type (like \"int err\").\n\
  \  const auto *TVR = dyn_cast<TypedValueRegion>(LHSReg);\n  if (!TVR)\n    return;\n\
  \  QualType LTy = TVR->getValueType();\n  if (LTy.isNull() || !LTy->isIntegerType())\n\
  \    return;\n\n  // Attempt to find a CallExpr on the RHS within this statement.\n\
  \  const CallExpr *RHSCall = findSpecificTypeInChildren<CallExpr>(S);\n  if (!RHSCall)\
  \ {\n    // No call on RHS; clear any previous mapping for this variable.\n    State\
  \ = State->remove<ReadyErrVarMap>(LHSReg);\n    C.addTransition(State);\n    return;\n\
  \  }\n\n  // Determine if this is a known ReadySetter call.\n  int Idx = findReadySetterIndexByCall(RHSCall,\
  \ C);\n  if (Idx >= 0) {\n    State = State->set<ReadyErrVarMap>(LHSReg, static_cast<unsigned>(Idx));\n\
  \  } else {\n    State = State->remove<ReadyErrVarMap>(LHSReg);\n  }\n\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!Condition)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \n  // Step A: Determine if condition checks a known set_ready() failure.\n\n  //\
  \ Case A1: inline call in condition.\n  unsigned Idx = static_cast<unsigned>(-1);\n\
  \  bool FromVar = false;\n  const MemRegion *CondVarReg = nullptr;\n\n  const CallExpr\
  \ *CondCall = findSpecificTypeInChildren<CallExpr>(Condition);\n  if (CondCall)\
  \ {\n    int Tmp = findReadySetterIndexByCall(CondCall, C);\n    if (Tmp >= 0)\n\
  \      Idx = static_cast<unsigned>(Tmp);\n  }\n\n  // Case A2: variable in condition\
  \ (err, err != 0, err < 0, etc.).\n  if (Idx == static_cast<unsigned>(-1)) {\n \
  \   const DeclRefExpr *DRE = findSpecificTypeInChildren<DeclRefExpr>(Condition);\n\
  \    if (DRE) {\n      const MemRegion *MR = getMemRegionFromExpr(DRE, C);\n   \
  \   if (MR) {\n        MR = MR->getBaseRegion();\n        if (MR) {\n          if\
  \ (const unsigned *SavedIdx = State->get<ReadyErrVarMap>(MR)) {\n            Idx\
  \ = *SavedIdx;\n            FromVar = true;\n            CondVarReg = MR;\n    \
  \      }\n        }\n      }\n    }\n  }\n\n  if (Idx == static_cast<unsigned>(-1))\n\
  \    return; // Not a set_ready guarded condition.\n\n  // Step B: Find the containing\
  \ IfStmt and its then-branch.\n  const IfStmt *IS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IS)\n    return;\n\n  const Stmt *Then = IS->getThen();\n  if (!Then)\n\
  \    return;\n\n  // Step C: Search the then-body for a composite close call.\n\
  \  llvm::SmallVector<const CallExpr *, 16> Calls;\n  collectCallExprs(Then, Calls);\n\
  \n  for (const CallExpr *CE : Calls) {\n    if (isCompositeCloseCall(Idx, CE, C))\
  \ {\n      // Found the problematic composite close call.\n      reportCompositeClose(CE,\
  \ C);\n      break;\n    }\n  }\n\n  // Step D: Cleanup transient mapping for condition\
  \ variable if used.\n  if (FromVar && CondVarReg) {\n    State = State->remove<ReadyErrVarMap>(CondVarReg);\n\
  \    C.addTransition(State);\n  }\n}\n\n} // end anonymous namespace\n\nextern \"\
  C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects composite close/cleanup in\
  \ set_ready() error path which may cause double free; use destroy()\",\n      \"\
  \");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
