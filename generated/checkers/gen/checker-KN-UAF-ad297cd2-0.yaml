_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: ad297cd2db8953e2202970e9504cab247b6c7cb4
commit_type: UAF
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program state customization\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(PrivToNetdev, SymbolRef, SymbolRef)\nREGISTER_SET_WITH_PROGRAMSTATE(FreedNetdevSet,\
  \ SymbolRef)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n   \
  \     check::PostCall,\n        check::PreCall,\n        check::Location> {\n  mutable\
  \ std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new\
  \ BugType(this,\n                       \"Use-after-free (netdev_priv after free_netdev)\"\
  ,\n                       \"Memory Management\")) {}\n\n  void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  void checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  bool isCallNamed(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) const;\n  bool getBasePointerSymbolFromExpr(const\
  \ Expr *E, CheckerContext &C, SymbolRef &OutSym) const;\n  bool getBasePointerSymbolFromStmt(const\
  \ Stmt *S, CheckerContext &C, SymbolRef &OutSym) const;\n  void reportUAF(CheckerContext\
  \ &C, const Stmt *S) const;\n\n  bool isNetdevFreedForPriv(SymbolRef PrivSym, ProgramStateRef\
  \ State) const;\n};\n\nbool SAGenTestChecker::isCallNamed(const CallEvent &Call,\
  \ StringRef Name,\n                                   CheckerContext &C) const {\n\
  \  const Expr *OE = Call.getOriginExpr();\n  if (!OE)\n    return false;\n  return\
  \ ExprHasName(OE, Name, C);\n}\n\nbool SAGenTestChecker::getBasePointerSymbolFromExpr(const\
  \ Expr *E,\n                                                    CheckerContext &C,\n\
  \                                                    SymbolRef &OutSym) const {\n\
  \  if (!E)\n    return false;\n\n  // Search for patterns that imply dereference\
  \ of a pointer:\n  // 1) MemberExpr with '->'\n  if (const auto *ME = findSpecificTypeInChildren<MemberExpr>(E))\
  \ {\n    if (ME->isArrow()) {\n      const Expr *Base = ME->getBase();\n      if\
  \ (!Base)\n        return false;\n      ProgramStateRef State = C.getState();\n\
  \      SVal V = State->getSVal(Base, C.getLocationContext());\n      if (SymbolRef\
  \ S = V.getAsSymbol()) {\n        OutSym = S;\n        return true;\n      }\n \
  \   }\n  }\n\n  // 2) UnaryOperator '*' (dereference)\n  if (const auto *UO = findSpecificTypeInChildren<UnaryOperator>(E))\
  \ {\n    if (UO->getOpcode() == UO_Deref) {\n      const Expr *Sub = UO->getSubExpr();\n\
  \      if (!Sub)\n        return false;\n      ProgramStateRef State = C.getState();\n\
  \      SVal V = State->getSVal(Sub, C.getLocationContext());\n      if (SymbolRef\
  \ S = V.getAsSymbol()) {\n        OutSym = S;\n        return true;\n      }\n \
  \   }\n  }\n\n  // 3) ArraySubscript 'ptr[i]'\n  if (const auto *ASE = findSpecificTypeInChildren<ArraySubscriptExpr>(E))\
  \ {\n    const Expr *Base = ASE->getBase();\n    if (!Base)\n      return false;\n\
  \    ProgramStateRef State = C.getState();\n    SVal V = State->getSVal(Base, C.getLocationContext());\n\
  \    if (SymbolRef S = V.getAsSymbol()) {\n      OutSym = S;\n      return true;\n\
  \    }\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::getBasePointerSymbolFromStmt(const\
  \ Stmt *S,\n                                                    CheckerContext &C,\n\
  \                                                    SymbolRef &OutSym) const {\n\
  \  if (!S)\n    return false;\n\n  if (const auto *E = dyn_cast<Expr>(S)) {\n  \
  \  return getBasePointerSymbolFromExpr(E, C, OutSym);\n  }\n\n  // If not an expression,\
  \ try to find an expression child and analyze it.\n  if (const auto *ChildME = findSpecificTypeInChildren<MemberExpr>(S))\
  \ {\n    if (ChildME->isArrow()) {\n      const Expr *Base = ChildME->getBase();\n\
  \      if (Base) {\n        return getBasePointerSymbolFromExpr(Base, C, OutSym);\n\
  \      }\n    }\n  }\n  if (const auto *ChildUO = findSpecificTypeInChildren<UnaryOperator>(S))\
  \ {\n    if (ChildUO->getOpcode() == UO_Deref) {\n      const Expr *Sub = ChildUO->getSubExpr();\n\
  \      if (Sub) {\n        ProgramStateRef State = C.getState();\n        SVal V\
  \ = State->getSVal(Sub, C.getLocationContext());\n        if (SymbolRef S = V.getAsSymbol())\
  \ {\n          OutSym = S;\n          return true;\n        }\n      }\n    }\n\
  \  }\n  if (const auto *ChildASE = findSpecificTypeInChildren<ArraySubscriptExpr>(S))\
  \ {\n    const Expr *Base = ChildASE->getBase();\n    if (Base)\n      return getBasePointerSymbolFromExpr(Base,\
  \ C, OutSym);\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isNetdevFreedForPriv(SymbolRef\
  \ PrivSym,\n                                            ProgramStateRef State) const\
  \ {\n  if (!PrivSym || !State)\n    return false;\n\n  const SymbolRef *NetSym =\
  \ State->get<PrivToNetdev>(PrivSym);\n  if (!NetSym || !*NetSym)\n    return false;\n\
  \n  return State->contains<FreedNetdevSet>(*NetSym);\n}\n\nvoid SAGenTestChecker::reportUAF(CheckerContext\
  \ &C, const Stmt *S) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Use of netdev_priv() data after free_netdev()\", N);\n  if (S)\n \
  \   R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call,\n                     \
  \                CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  if (!State)\n    return;\n\n  // Track netdev_priv(): map return symbol (private)\
  \ -> net_device symbol (arg0)\n  if (isCallNamed(Call, \"netdev_priv\", C)) {\n\
  \    SymbolRef PrivSym = Call.getReturnValue().getAsSymbol();\n    if (!PrivSym)\n\
  \      return;\n\n    SVal Arg0Val = Call.getArgSVal(0);\n    SymbolRef NetSym =\
  \ Arg0Val.getAsSymbol();\n    if (!NetSym)\n      return;\n\n    State = State->set<PrivToNetdev>(PrivSym,\
  \ NetSym);\n    C.addTransition(State);\n    return;\n  }\n\n  // Track free_netdev():\
  \ mark the net_device symbol as freed\n  if (isCallNamed(Call, \"free_netdev\",\
  \ C)) {\n    SVal Arg0Val = Call.getArgSVal(0);\n    SymbolRef NetSym = Arg0Val.getAsSymbol();\n\
  \    if (!NetSym)\n      return;\n\n    State = State->add<FreedNetdevSet>(NetSym);\n\
  \    C.addTransition(State);\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  if (!State)\n    return;\n\n  // First, for each argument, detect if its evaluation\
  \ implicitly dereferences a private pointer\n  for (unsigned I = 0; I < Call.getNumArgs();\
  \ ++I) {\n    const Expr *ArgE = Call.getArgExpr(I);\n    if (!ArgE)\n      continue;\n\
  \n    SymbolRef BasePtrSym = nullptr;\n    if (getBasePointerSymbolFromExpr(ArgE,\
  \ C, BasePtrSym)) {\n      if (isNetdevFreedForPriv(BasePtrSym, State)) {\n    \
  \    reportUAF(C, Call.getOriginExpr());\n        return;\n      }\n    }\n  }\n\
  \n  // Next, if the callee is known to dereference certain pointer params, check\
  \ them\n  llvm::SmallVector<unsigned, 4> DerefParams;\n  if (functionKnownToDeref(Call,\
  \ DerefParams)) {\n    for (unsigned Idx : DerefParams) {\n      if (Idx >= Call.getNumArgs())\n\
  \        continue;\n      SVal ArgV = Call.getArgSVal(Idx);\n      SymbolRef ArgSym\
  \ = ArgV.getAsSymbol();\n      if (!ArgSym)\n        continue;\n\n      if (isNetdevFreedForPriv(ArgSym,\
  \ State)) {\n        reportUAF(C, Call.getOriginExpr());\n        return;\n    \
  \  }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S,\n                                     CheckerContext &C) const\
  \ {\n  ProgramStateRef State = C.getState();\n  if (!State || !S)\n    return;\n\
  \n  // Attempt to extract the base pointer being dereferenced from the statement\n\
  \  SymbolRef BasePtrSym = nullptr;\n  if (!getBasePointerSymbolFromStmt(S, C, BasePtrSym))\n\
  \    return;\n\n  if (isNetdevFreedForPriv(BasePtrSym, State)) {\n    reportUAF(C,\
  \ S);\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects use-after-free: using netdev_priv() data after free_netdev()\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet: qcom/emac: fix UAF in emac_remove\n\nadpt is\
  \ netdev private data and it cannot be\nused after free_netdev() call. Using adpt\
  \ after free_netdev()\ncan cause UAF bug. Fix it by moving free_netdev() at the\
  \ end of the\nfunction.\n\nFixes: 54e19bc74f33 (\"net: qcom/emac: do not use devm\
  \ on internal phy pdev\")\nSigned-off-by: Pavel Skripkin <paskripkin@gmail.com>\n\
  Signed-off-by: David S. Miller <davem@davemloft.net>\n\n## Buggy Code\n\n```c\n\
  // Function: emac_remove in drivers/net/ethernet/qualcomm/emac/emac.c\nstatic int\
  \ emac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(&pdev->dev);\n\
  \tstruct emac_adapter *adpt = netdev_priv(netdev);\n\n\tunregister_netdev(netdev);\n\
  \tnetif_napi_del(&adpt->rx_q.napi);\n\n\temac_clks_teardown(adpt);\n\n\tput_device(&adpt->phydev->mdio.dev);\n\
  \tmdiobus_unregister(adpt->mii_bus);\n\tfree_netdev(netdev);\n\n\tif (adpt->phy.digital)\n\
  \t\tiounmap(adpt->phy.digital);\n\tiounmap(adpt->phy.base);\n\n\treturn 0;\n}\n\
  ```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/net/ethernet/qualcomm/emac/emac.c\
  \ b/drivers/net/ethernet/qualcomm/emac/emac.c\nindex 8543bf3c3484..ad655f0a4965\
  \ 100644\n--- a/drivers/net/ethernet/qualcomm/emac/emac.c\n+++ b/drivers/net/ethernet/qualcomm/emac/emac.c\n\
  @@ -735,12 +735,13 @@ static int emac_remove(struct platform_device *pdev)\n \n\
  \ \tput_device(&adpt->phydev->mdio.dev);\n \tmdiobus_unregister(adpt->mii_bus);\n\
  -\tfree_netdev(netdev);\n \n \tif (adpt->phy.digital)\n \t\tiounmap(adpt->phy.digital);\n\
  \ \tiounmap(adpt->phy.base);\n \n+\tfree_netdev(netdev);\n+\n \treturn 0;\n }\n\
  \ \n```\n"
pattern: "## Bug Pattern\n\nCalling free_netdev(netdev) before all cleanup that still\
  \ dereferences the driver\u2019s private data (netdev_priv(netdev)). After free_netdev()\
  \ the private area is freed, so any subsequent use like adpt->... (iounmap, put/unregister,\
  \ etc.) is a use-after-free."
plan: "1) Program state customization\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(PrivToNetdev,\
  \ SymbolRef, SymbolRef)\n  - Key: SymbolRef of the pointer returned by netdev_priv().\n\
  \  - Value: SymbolRef of the net_device pointer passed to netdev_priv().\n  - Purpose:\
  \ Link a private-data pointer to its parent net_device.\n\n- REGISTER_SET_WITH_PROGRAMSTATE(FreedNetdevSet,\
  \ SymbolRef)\n  - Elements: SymbolRef of net_device pointers passed to free_netdev().\n\
  \  - Purpose: Record which net_device objects have been freed, so all their associated\
  \ netdev_priv() pointers become invalid.\n\nNo additional traits/aliases are strictly\
  \ necessary. We rely on SymbolRef flow through bindings, keeping the checker simple.\n\
  \n\n2) Callbacks and how to implement them\n\nA) checkPostCall\n- Goal: Track netdev_priv()\
  \ results and free_netdev() calls.\n\n- Detect netdev_priv():\n  - If callee identifier\
  \ is \"netdev_priv\":\n    - SymPriv = Call.getReturnValue().getAsSymbol(). If null,\
  \ bail.\n    - SymNet = State->getSVal(Call.getArgExpr(0), C.getLocationContext()).getAsSymbol().\
  \ If null, bail.\n    - State = State->set<PrivToNetdev>(SymPriv, SymNet);\n   \
  \ - C.addTransition(State).\n\n- Detect free_netdev():\n  - If callee identifier\
  \ is \"free_netdev\":\n    - SymNet = State->getSVal(Call.getArgExpr(0), C.getLocationContext()).getAsSymbol().\
  \ If null, bail.\n    - State = State->add<FreedNetdevSet>(SymNet);\n    - C.addTransition(State).\n\
  \nRationale: By recording private-pointer-to-net_device mapping on netdev_priv and\
  \ marking the net_device symbol as freed on free_netdev, we can check later uses\
  \ easily.\n\nB) checkLocation\n- Goal: Flag dereferences of private-data pointers\
  \ after free_netdev().\n\n- Extract the pointer being dereferenced from the accessing\
  \ statement:\n  - Use findSpecificTypeInChildren to look for one of:\n    - MemberExpr\
  \ ME where ME->isArrow() == true. Let Base = ME->getBase().\n    - UnaryOperator\
  \ UO where UO->getOpcode()==UO_Deref. Let Base = UO->getSubExpr().\n    - ArraySubscriptExpr\
  \ ASE. Let Base = ASE->getBase().\n  - If none found, return.\n  - Compute SymP\
  \ = State->getSVal(Base, C.getLocationContext()).getAsSymbol(). If null, return.\n\
  \n- Check use-after-free condition:\n  - Look up NetSym = State->get<PrivToNetdev>(SymP).\
  \ If not found, return.\n  - If NetSym \u2208 State->get<FreedNetdevSet>(), report\
  \ a bug at S (see Reporting).\n\nNotes:\n- This catches typical patterns like adpt->field\
  \ (MemberExpr with ->), *adpt (UO_Deref), and adpt[i] (ArraySubscriptExpr). Passing\
  \ &adpt->field to functions also contains a MemberExpr as a child of a UO_AddrOf;\
  \ findSpecificTypeInChildren will still find the MemberExpr.\n\nC) checkPreCall\n\
  - Goal: Catch dereferences that occur as part of call argument evaluation or inside\
  \ known deref callees.\n\n- For each argument Arg at index i:\n  - Detect implicit\
  \ deref in argument expression:\n    - Use findSpecificTypeInChildren to search\
  \ within Arg:\n      - MemberExpr with isArrow()==true:\n        - SymP = State->getSVal(ME->getBase(),\
  \ LCtx).getAsSymbol().\n      - UnaryOperator with UO_Deref, use its subexpr as\
  \ the pointer.\n      - ArraySubscriptExpr, use its base.\n    - If a SymP is obtained:\n\
  \      - NetSym = State->get<PrivToNetdev>(SymP). If present and NetSym \u2208 FreedNetdevSet,\
  \ report bug on Call.getOriginExpr().\n\n  - Detect deref in known functions:\n\
  \    - Use functionKnownToDeref(Call, DerefParams). If returns true and i \u2208\
  \ DerefParams:\n      - SymPArg = State->getSVal(Arg, LCtx).getAsSymbol(). If null,\
  \ continue.\n      - NetSym = State->get<PrivToNetdev>(SymPArg). If present and\
  \ NetSym \u2208 FreedNetdevSet, report.\n\nRationale: Some derefs happen during\
  \ argument evaluation (e.g., &adpt->field) or inside helper functions that always\
  \ dereference the pointer parameters.\n\nD) Other callbacks\n- checkBind: Not required\
  \ for the simplest working solution. Symbol flow typically preserves the same underlying\
  \ SymbolRef for pointer value copies, so PrivToNetdev keyed by SymbolRef remains\
  \ valid across simple assignments.\n- No need to implement evalCall, evalAssume,\
  \ region changes, or AST-wide checks for this pattern.\n\n\n3) Helper routines to\
  \ keep code simple\n\n- bool isCallNamed(const CallEvent &Call, StringRef Name)\n\
  \  - Compare callee identifier name.\n\n- Optional: getBasePointerSymbolFromStmt(const\
  \ Stmt *S, CheckerContext &C, SymbolRef &OutSym)\n  - Use findSpecificTypeInChildren<MemberExpr>,\
  \ findSpecificTypeInChildren<UnaryOperator>, findSpecificTypeInChildren<ArraySubscriptExpr>\
  \ as described in checkLocation to DRY code.\n\n- Optional: getBasePointerSymbolFromExpr(const\
  \ Expr *E, CheckerContext &C, SymbolRef &OutSym)\n  - Same logic but starting from\
  \ an expression (used in checkPreCall per-argument analysis).\n\n\n4) Bug reporting\n\
  \n- Create a single BugType: \"Use-after-free (netdev_priv after free_netdev)\"\
  .\n\n- When the condition triggers (in checkLocation or checkPreCall):\n  - Node\
  \ = C.generateNonFatalErrorNode().\n  - If !Node return.\n  - Create PathSensitiveBugReport\
  \ with a short message:\n    - \"Use of netdev_priv() data after free_netdev()\"\
  \n  - Attach the statement that caused the dereference (S in checkLocation, or Call.getOriginExpr()\
  \ / Arg in checkPreCall) as the location.\n  - C.emitReport(std::move(R)).\n\n\n\
  5) Summary of detection flow\n\n- netdev_priv(ndev) => record map[PrivSym] = NdevSym.\n\
  - free_netdev(ndev) => mark NdevSym freed in FreedNetdevSet.\n- Any deref that uses\
  \ a pointer symbol PrivSym such that map[PrivSym] = NdevSym and NdevSym is freed\
  \ => report UAF.\n\nThis matches the patch\u2019s root cause: adpt returned from\
  \ netdev_priv(netdev) is used after free_netdev(netdev)."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program state customization\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(PrivToNetdev, SymbolRef, SymbolRef)\nREGISTER_SET_WITH_PROGRAMSTATE(FreedNetdevSet,\
  \ SymbolRef)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n   \
  \     check::PostCall,\n        check::PreCall,\n        check::Location> {\n  mutable\
  \ std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new\
  \ BugType(this,\n                       \"Use-after-free (netdev_priv after free_netdev)\"\
  ,\n                       \"Memory Management\")) {}\n\n  void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  void checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  bool isCallNamed(const\
  \ CallEvent &Call, StringRef Name, CheckerContext &C) const;\n  bool getBasePointerSymbolFromExpr(const\
  \ Expr *E, CheckerContext &C, SymbolRef &OutSym) const;\n  bool getBasePointerSymbolFromStmt(const\
  \ Stmt *S, CheckerContext &C, SymbolRef &OutSym) const;\n  void reportUAF(CheckerContext\
  \ &C, const Stmt *S) const;\n\n  bool isNetdevFreedForPriv(SymbolRef PrivSym, ProgramStateRef\
  \ State) const;\n};\n\nbool SAGenTestChecker::isCallNamed(const CallEvent &Call,\
  \ StringRef Name,\n                                   CheckerContext &C) const {\n\
  \  const Expr *OE = Call.getOriginExpr();\n  if (!OE)\n    return false;\n  return\
  \ ExprHasName(OE, Name, C);\n}\n\nbool SAGenTestChecker::getBasePointerSymbolFromExpr(const\
  \ Expr *E,\n                                                    CheckerContext &C,\n\
  \                                                    SymbolRef &OutSym) const {\n\
  \  if (!E)\n    return false;\n\n  // Search for patterns that imply dereference\
  \ of a pointer:\n  // 1) MemberExpr with '->'\n  if (const auto *ME = findSpecificTypeInChildren<MemberExpr>(E))\
  \ {\n    if (ME->isArrow()) {\n      const Expr *Base = ME->getBase();\n      if\
  \ (!Base)\n        return false;\n      ProgramStateRef State = C.getState();\n\
  \      SVal V = State->getSVal(Base, C.getLocationContext());\n      if (SymbolRef\
  \ S = V.getAsSymbol()) {\n        OutSym = S;\n        return true;\n      }\n \
  \   }\n  }\n\n  // 2) UnaryOperator '*' (dereference)\n  if (const auto *UO = findSpecificTypeInChildren<UnaryOperator>(E))\
  \ {\n    if (UO->getOpcode() == UO_Deref) {\n      const Expr *Sub = UO->getSubExpr();\n\
  \      if (!Sub)\n        return false;\n      ProgramStateRef State = C.getState();\n\
  \      SVal V = State->getSVal(Sub, C.getLocationContext());\n      if (SymbolRef\
  \ S = V.getAsSymbol()) {\n        OutSym = S;\n        return true;\n      }\n \
  \   }\n  }\n\n  // 3) ArraySubscript 'ptr[i]'\n  if (const auto *ASE = findSpecificTypeInChildren<ArraySubscriptExpr>(E))\
  \ {\n    const Expr *Base = ASE->getBase();\n    if (!Base)\n      return false;\n\
  \    ProgramStateRef State = C.getState();\n    SVal V = State->getSVal(Base, C.getLocationContext());\n\
  \    if (SymbolRef S = V.getAsSymbol()) {\n      OutSym = S;\n      return true;\n\
  \    }\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::getBasePointerSymbolFromStmt(const\
  \ Stmt *S,\n                                                    CheckerContext &C,\n\
  \                                                    SymbolRef &OutSym) const {\n\
  \  if (!S)\n    return false;\n\n  if (const auto *E = dyn_cast<Expr>(S)) {\n  \
  \  return getBasePointerSymbolFromExpr(E, C, OutSym);\n  }\n\n  // If not an expression,\
  \ try to find an expression child and analyze it.\n  if (const auto *ChildME = findSpecificTypeInChildren<MemberExpr>(S))\
  \ {\n    if (ChildME->isArrow()) {\n      const Expr *Base = ChildME->getBase();\n\
  \      if (Base) {\n        return getBasePointerSymbolFromExpr(Base, C, OutSym);\n\
  \      }\n    }\n  }\n  if (const auto *ChildUO = findSpecificTypeInChildren<UnaryOperator>(S))\
  \ {\n    if (ChildUO->getOpcode() == UO_Deref) {\n      const Expr *Sub = ChildUO->getSubExpr();\n\
  \      if (Sub) {\n        ProgramStateRef State = C.getState();\n        SVal V\
  \ = State->getSVal(Sub, C.getLocationContext());\n        if (SymbolRef S = V.getAsSymbol())\
  \ {\n          OutSym = S;\n          return true;\n        }\n      }\n    }\n\
  \  }\n  if (const auto *ChildASE = findSpecificTypeInChildren<ArraySubscriptExpr>(S))\
  \ {\n    const Expr *Base = ChildASE->getBase();\n    if (Base)\n      return getBasePointerSymbolFromExpr(Base,\
  \ C, OutSym);\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::isNetdevFreedForPriv(SymbolRef\
  \ PrivSym,\n                                            ProgramStateRef State) const\
  \ {\n  if (!PrivSym || !State)\n    return false;\n\n  const SymbolRef *NetSym =\
  \ State->get<PrivToNetdev>(PrivSym);\n  if (!NetSym || !*NetSym)\n    return false;\n\
  \n  return State->contains<FreedNetdevSet>(*NetSym);\n}\n\nvoid SAGenTestChecker::reportUAF(CheckerContext\
  \ &C, const Stmt *S) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Use of netdev_priv() data after free_netdev()\", N);\n  if (S)\n \
  \   R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call,\n                     \
  \                CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  if (!State)\n    return;\n\n  // Track netdev_priv(): map return symbol (private)\
  \ -> net_device symbol (arg0)\n  if (isCallNamed(Call, \"netdev_priv\", C)) {\n\
  \    SymbolRef PrivSym = Call.getReturnValue().getAsSymbol();\n    if (!PrivSym)\n\
  \      return;\n\n    SVal Arg0Val = Call.getArgSVal(0);\n    SymbolRef NetSym =\
  \ Arg0Val.getAsSymbol();\n    if (!NetSym)\n      return;\n\n    State = State->set<PrivToNetdev>(PrivSym,\
  \ NetSym);\n    C.addTransition(State);\n    return;\n  }\n\n  // Track free_netdev():\
  \ mark the net_device symbol as freed\n  if (isCallNamed(Call, \"free_netdev\",\
  \ C)) {\n    SVal Arg0Val = Call.getArgSVal(0);\n    SymbolRef NetSym = Arg0Val.getAsSymbol();\n\
  \    if (!NetSym)\n      return;\n\n    State = State->add<FreedNetdevSet>(NetSym);\n\
  \    C.addTransition(State);\n    return;\n  }\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  if (!State)\n    return;\n\n  // First, for each argument, detect if its evaluation\
  \ implicitly dereferences a private pointer\n  for (unsigned I = 0; I < Call.getNumArgs();\
  \ ++I) {\n    const Expr *ArgE = Call.getArgExpr(I);\n    if (!ArgE)\n      continue;\n\
  \n    SymbolRef BasePtrSym = nullptr;\n    if (getBasePointerSymbolFromExpr(ArgE,\
  \ C, BasePtrSym)) {\n      if (isNetdevFreedForPriv(BasePtrSym, State)) {\n    \
  \    reportUAF(C, Call.getOriginExpr());\n        return;\n      }\n    }\n  }\n\
  \n  // Next, if the callee is known to dereference certain pointer params, check\
  \ them\n  llvm::SmallVector<unsigned, 4> DerefParams;\n  if (functionKnownToDeref(Call,\
  \ DerefParams)) {\n    for (unsigned Idx : DerefParams) {\n      if (Idx >= Call.getNumArgs())\n\
  \        continue;\n      SVal ArgV = Call.getArgSVal(Idx);\n      SymbolRef ArgSym\
  \ = ArgV.getAsSymbol();\n      if (!ArgSym)\n        continue;\n\n      if (isNetdevFreedForPriv(ArgSym,\
  \ State)) {\n        reportUAF(C, Call.getOriginExpr());\n        return;\n    \
  \  }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad,\
  \ const Stmt *S,\n                                     CheckerContext &C) const\
  \ {\n  ProgramStateRef State = C.getState();\n  if (!State || !S)\n    return;\n\
  \n  // Attempt to extract the base pointer being dereferenced from the statement\n\
  \  SymbolRef BasePtrSym = nullptr;\n  if (!getBasePointerSymbolFromStmt(S, C, BasePtrSym))\n\
  \    return;\n\n  if (isNetdevFreedForPriv(BasePtrSym, State)) {\n    reportUAF(C,\
  \ S);\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects use-after-free: using netdev_priv() data after free_netdev()\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
