_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 63ae548f1054a0b71678d0349c7dc9628ddd42ca
commit_type: Out-of-Bound
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states are necessary.\n\nnamespace\
  \ {\n\nclass SAGenTestChecker : public Checker<check::Location> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Transfer-function\
  \ LUT index out-of-bounds\", \"Array bounds\")) {}\n\n      void checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\n   private:\n  \
  \    // Return true if Base is of the form \"...->tf_pts.red\" (or green/blue),\
  \ and\n      // ArrTy is the constant array type of the color channel.\n      bool\
  \ isTFLutColorArray(const Expr *Base,\n                             StringRef &ColorOut,\n\
  \                             const ConstantArrayType *&ArrTy) const;\n\n      //\
  \ Extract index info: either a constant APSInt or a SymbolRef.\n      void getIndexInfo(const\
  \ Expr *Idx, CheckerContext &C, bool &IsConst,\n                        llvm::APSInt\
  \ &ConstVal, SymbolRef &Sym) const;\n\n      // Best-effort suppression if a nearby\
  \ condition guards \"idx < TRANSFER_FUNC_POINTS\".\n      bool guardedByTransferPointsCondition(const\
  \ Expr *Idx,\n                                            const Stmt *AccessSite,\n\
  \                                            CheckerContext &C) const;\n\n     \
  \ void reportOOB(const ArraySubscriptExpr *AE, StringRef ColorName,\n          \
  \           CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isTFLutColorArray(const\
  \ Expr *Base,\n                                         StringRef &ColorOut,\n \
  \                                        const ConstantArrayType *&ArrTy) const\
  \ {\n  if (!Base)\n    return false;\n\n  Base = Base->IgnoreParenImpCasts();\n\
  \  const auto *ME1 = dyn_cast<MemberExpr>(Base);\n  if (!ME1)\n    return false;\n\
  \n  const auto *FD1 = dyn_cast<FieldDecl>(ME1->getMemberDecl());\n  if (!FD1)\n\
  \    return false;\n\n  StringRef Color = FD1->getName();\n  if (!(Color == \"red\"\
  \ || Color == \"green\" || Color == \"blue\"))\n    return false;\n\n  const Expr\
  \ *ME1BaseExpr = ME1->getBase();\n  if (!ME1BaseExpr)\n    return false;\n\n  ME1BaseExpr\
  \ = ME1BaseExpr->IgnoreParenImpCasts();\n  const auto *ME2 = dyn_cast<MemberExpr>(ME1BaseExpr);\n\
  \  if (!ME2)\n    return false;\n\n  const auto *FD2 = dyn_cast<FieldDecl>(ME2->getMemberDecl());\n\
  \  if (!FD2)\n    return false;\n\n  if (FD2->getName() != \"tf_pts\")\n    return\
  \ false;\n\n  // Get red/green/blue array type bound.\n  QualType QT = FD1->getType();\n\
  \  const auto *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr());\n  if (!CAT)\n\
  \    return false;\n\n  ColorOut = Color;\n  ArrTy = CAT;\n  return true;\n}\n\n\
  void SAGenTestChecker::getIndexInfo(const Expr *Idx, CheckerContext &C,\n      \
  \                              bool &IsConst, llvm::APSInt &ConstVal,\n        \
  \                            SymbolRef &Sym) const {\n  IsConst = false;\n  Sym\
  \ = nullptr;\n  if (!Idx)\n    return;\n\n  // Try to evaluate as constant.\n  if\
  \ (EvaluateExprToInt(ConstVal, Idx, C)) {\n    IsConst = true;\n    return;\n  }\n\
  \n  // Otherwise, try to obtain a symbol for the index.\n  ProgramStateRef State\
  \ = C.getState();\n  SVal SV = State->getSVal(Idx, C.getLocationContext());\n  Sym\
  \ = SV.getAsSymbol();\n}\n\nbool SAGenTestChecker::guardedByTransferPointsCondition(const\
  \ Expr *Idx,\n                                                        const Stmt\
  \ *AccessSite,\n                                                        CheckerContext\
  \ &C) const {\n  // We look for If/For/While/Do conditions that mention both the\
  \ index name\n  // and TRANSFER_FUNC_POINTS.\n  const DeclRefExpr *IdxDRE = dyn_cast<DeclRefExpr>(Idx->IgnoreParenImpCasts());\n\
  \  if (!IdxDRE)\n    return false;\n\n  const auto *VD = dyn_cast<VarDecl>(IdxDRE->getDecl());\n\
  \  if (!VD)\n    return false;\n\n  StringRef IdxName = VD->getName();\n\n  // Check\
  \ an enclosing if\n  if (const IfStmt *IS = findSpecificTypeInParents<IfStmt>(AccessSite,\
  \ C)) {\n    if (const Expr *CondE = IS->getCond()) {\n      if (ExprHasName(CondE,\
  \ IdxName, C) && ExprHasName(CondE, \"TRANSFER_FUNC_POINTS\", C))\n        return\
  \ true;\n    }\n  }\n  // Check an enclosing for\n  if (const ForStmt *FS = findSpecificTypeInParents<ForStmt>(AccessSite,\
  \ C)) {\n    if (const Expr *CondE = FS->getCond()) {\n      if (ExprHasName(CondE,\
  \ IdxName, C) && ExprHasName(CondE, \"TRANSFER_FUNC_POINTS\", C))\n        return\
  \ true;\n    }\n  }\n  // Check an enclosing while\n  if (const WhileStmt *WS =\
  \ findSpecificTypeInParents<WhileStmt>(AccessSite, C)) {\n    if (const Expr *CondE\
  \ = WS->getCond()) {\n      if (ExprHasName(CondE, IdxName, C) && ExprHasName(CondE,\
  \ \"TRANSFER_FUNC_POINTS\", C))\n        return true;\n    }\n  }\n  // Check an\
  \ enclosing do-while\n  if (const DoStmt *DS = findSpecificTypeInParents<DoStmt>(AccessSite,\
  \ C)) {\n    if (const Expr *CondE = DS->getCond()) {\n      if (ExprHasName(CondE,\
  \ IdxName, C) && ExprHasName(CondE, \"TRANSFER_FUNC_POINTS\", C))\n        return\
  \ true;\n    }\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::reportOOB(const\
  \ ArraySubscriptExpr *AE, StringRef ColorName,\n                               \
  \  CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  SmallString<128> Msg;\n  Msg += \"Possible out-of-bounds\
  \ read from tf_pts.\";\n  Msg += ColorName;\n  Msg += \"; missing index < TRANSFER_FUNC_POINTS\
  \ check\";\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n\
  \  if (AE)\n    R->addRange(AE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\
  \ CheckerContext &C) const {\n  if (!IsLoad || !S)\n    return;\n\n  const auto\
  \ *AE = dyn_cast<ArraySubscriptExpr>(S);\n  if (!AE)\n    return;\n\n  const Expr\
  \ *Base = AE->getBase();\n  StringRef ColorName;\n  const ConstantArrayType *ArrTy\
  \ = nullptr;\n\n  if (!isTFLutColorArray(Base, ColorName, ArrTy))\n    return;\n\
  \n  // Get the array bound (TRANSFER_FUNC_POINTS after preprocessing).\n  llvm::APInt\
  \ ArrSize = ArrTy->getSize();\n\n  // Analyze the index.\n  const Expr *IdxE = AE->getIdx();\n\
  \  if (!IdxE)\n    return;\n\n  bool IsConst = false;\n  llvm::APSInt ConstVal;\n\
  \  SymbolRef Sym = nullptr;\n  getIndexInfo(IdxE, C, IsConst, ConstVal, Sym);\n\n\
  \  // If constant index: report if negative or >= bound.\n  if (IsConst) {\n   \
  \ // Negative index is OOB.\n    if (ConstVal.isSigned() && ConstVal.isNegative())\
  \ {\n      reportOOB(AE, ColorName, C);\n      return;\n    }\n    // Compare against\
  \ bound using consistent bitwidth/signedness.\n    llvm::APSInt BoundAPS(ArrSize.zextOrTrunc(ConstVal.getBitWidth()),\n\
  \                          ConstVal.isUnsigned());\n    if (ConstVal >= BoundAPS)\
  \ {\n      reportOOB(AE, ColorName, C);\n    }\n    return;\n  }\n\n  // If symbolic\
  \ index: try to prove safe using max value.\n  if (Sym) {\n    const llvm::APSInt\
  \ *MaxV = inferSymbolMaxVal(Sym, C);\n    if (MaxV) {\n      llvm::APSInt BoundAPS(ArrSize.zextOrTrunc(MaxV->getBitWidth()),\n\
  \                            MaxV->isUnsigned());\n      // If we can prove max\
  \ < bound, it's safe.\n      if (MaxV->ult(BoundAPS))\n        return;\n      //\
  \ Otherwise, continue to optional guard check and potentially report.\n    }\n \
  \ }\n\n  // Optional guard suppression: look for condition mentioning index and\
  \ TRANSFER_FUNC_POINTS.\n  if (guardedByTransferPointsCondition(IdxE, S, C))\n \
  \   return;\n\n  // Not proven safe and not guarded; report.\n  reportOOB(AE, ColorName,\
  \ C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects missing bounds checks when indexing tf_pts.{red,green,blue} arrays\
  \ (TRANSFER_FUNC_POINTS)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Fix potential index out of bounds\
  \ in color transformation function\n\nFixes index out of bounds issue in the color\
  \ transformation function.\nThe issue could occur when the index 'i' exceeds the\
  \ number of transfer\nfunction points (TRANSFER_FUNC_POINTS).\n\nThe fix adds a\
  \ check to ensure 'i' is within bounds before accessing the\ntransfer function points.\
  \ If 'i' is out of bounds, an error message is\nlogged and the function returns\
  \ false to indicate an error.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:405\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.red'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:406\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.green'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:407\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.blue'\
  \ 1025 <= s32max\n\nFixes: b629596072e5 (\"drm/amd/display: Build unity lut for\
  \ shaper\")\nCc: Vitaly Prosyak <vitaly.prosyak@amd.com>\nCc: Charlene Liu <Charlene.Liu@amd.com>\n\
  Cc: Harry Wentland <harry.wentland@amd.com>\nCc: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>\n\
  Cc: Roman Li <roman.li@amd.com>\nCc: Aurabindo Pillai <aurabindo.pillai@amd.com>\n\
  Cc: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Srinivasan Shanmugam <srinivasan.shanmugam@amd.com>\n\
  Reviewed-by: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Alex Deucher <alexander.deucher@amd.com>\n\
  \n## Buggy Code\n\n```c\n// Function: cm_helper_translate_curve_to_hw_format in\
  \ drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nbool cm_helper_translate_curve_to_hw_format(struct\
  \ dc_context *ctx,\n\t\t\t\tconst struct dc_transfer_func *output_tf,\n\t\t\t\t\
  struct pwl_params *lut_params, bool fixpoint)\n{\n\tstruct curve_points3 *corner_points;\n\
  \tstruct pwl_result_data *rgb_resulted;\n\tstruct pwl_result_data *rgb;\n\tstruct\
  \ pwl_result_data *rgb_plus_1;\n\tstruct pwl_result_data *rgb_minus_1;\n\n\tint32_t\
  \ region_start, region_end;\n\tint32_t i;\n\tuint32_t j, k, seg_distr[MAX_REGIONS_NUMBER],\
  \ increment, start_index, hw_points;\n\n\tif (output_tf == NULL || lut_params ==\
  \ NULL || output_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\tcorner_points\
  \ = lut_params->corner_points;\n\trgb_resulted = lut_params->rgb_resulted;\n\thw_points\
  \ = 0;\n\n\tmemset(lut_params, 0, sizeof(struct pwl_params));\n\tmemset(seg_distr,\
  \ 0, sizeof(seg_distr));\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ || output_tf->tf\
  \ == TRANSFER_FUNCTION_GAMMA22) {\n\t\t/* 32 segments\n\t\t * segments are from\
  \ 2^-25 to 2^7\n\t\t */\n\t\tfor (i = 0; i < NUMBER_REGIONS ; i++)\n\t\t\tseg_distr[i]\
  \ = 3;\n\n\t\tregion_start = -MAX_LOW_POINT;\n\t\tregion_end   = NUMBER_REGIONS\
  \ - MAX_LOW_POINT;\n\t} else {\n\t\t/* 11 segments\n\t\t * segment is from 2^-10\
  \ to 2^1\n\t\t * There are less than 256 points, for optimization\n\t\t */\n\t\t\
  seg_distr[0] = 3;\n\t\tseg_distr[1] = 4;\n\t\tseg_distr[2] = 4;\n\t\tseg_distr[3]\
  \ = 4;\n\t\tseg_distr[4] = 4;\n\t\tseg_distr[5] = 4;\n\t\tseg_distr[6] = 4;\n\t\t\
  seg_distr[7] = 4;\n\t\tseg_distr[8] = 4;\n\t\tseg_distr[9] = 4;\n\t\tseg_distr[10]\
  \ = 1;\n\n\t\tregion_start = -10;\n\t\tregion_end = 1;\n\t}\n\n\tfor (i = region_end\
  \ - region_start; i < MAX_REGIONS_NUMBER ; i++)\n\t\tseg_distr[i] = -1;\n\n\tfor\
  \ (k = 0; k < MAX_REGIONS_NUMBER; k++) {\n\t\tif (seg_distr[k] != -1)\n\t\t\thw_points\
  \ += (1 << seg_distr[k]);\n\t}\n\n\tj = 0;\n\tfor (k = 0; k < (region_end - region_start);\
  \ k++) {\n\t\tincrement = NUMBER_SW_SEGMENTS / (1 << seg_distr[k]);\n\t\tstart_index\
  \ = (region_start + k + MAX_LOW_POINT) *\n\t\t\t\tNUMBER_SW_SEGMENTS;\n\t\tfor (i\
  \ = start_index; i < start_index + NUMBER_SW_SEGMENTS;\n\t\t\t\ti += increment)\
  \ {\n\t\t\tif (j == hw_points - 1)\n\t\t\t\tbreak;\n\t\t\trgb_resulted[j].red =\
  \ output_tf->tf_pts.red[i];\n\t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n\
  \t\t\trgb_resulted[j].blue = output_tf->tf_pts.blue[i];\n\t\t\tj++;\n\t\t}\n\t}\n\
  \n\t/* last point */\n\tstart_index = (region_end + MAX_LOW_POINT) * NUMBER_SW_SEGMENTS;\n\
  \trgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];\n\trgb_resulted[hw_points\
  \ - 1].green = output_tf->tf_pts.green[start_index];\n\trgb_resulted[hw_points -\
  \ 1].blue = output_tf->tf_pts.blue[start_index];\n\n\trgb_resulted[hw_points].red\
  \ = rgb_resulted[hw_points - 1].red;\n\trgb_resulted[hw_points].green = rgb_resulted[hw_points\
  \ - 1].green;\n\trgb_resulted[hw_points].blue = rgb_resulted[hw_points - 1].blue;\n\
  \n\t// All 3 color channels have same x\n\tcorner_points[0].red.x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\
  \t\t\t\t\t     dc_fixpt_from_int(region_start));\n\tcorner_points[0].green.x = corner_points[0].red.x;\n\
  \tcorner_points[0].blue.x = corner_points[0].red.x;\n\n\tcorner_points[1].red.x\
  \ = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_end));\n\
  \tcorner_points[1].green.x = corner_points[1].red.x;\n\tcorner_points[1].blue.x\
  \ = corner_points[1].red.x;\n\n\tcorner_points[0].red.y = rgb_resulted[0].red;\n\
  \tcorner_points[0].green.y = rgb_resulted[0].green;\n\tcorner_points[0].blue.y =\
  \ rgb_resulted[0].blue;\n\n\tcorner_points[0].red.slope = dc_fixpt_div(corner_points[0].red.y,\n\
  \t\t\tcorner_points[0].red.x);\n\tcorner_points[0].green.slope = dc_fixpt_div(corner_points[0].green.y,\n\
  \t\t\tcorner_points[0].green.x);\n\tcorner_points[0].blue.slope = dc_fixpt_div(corner_points[0].blue.y,\n\
  \t\t\tcorner_points[0].blue.x);\n\n\t/* see comment above, m_arrPoints[1].y should\
  \ be the Y value for the\n\t * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints\
  \ - 1)\n\t */\n\tcorner_points[1].red.y = rgb_resulted[hw_points - 1].red;\n\tcorner_points[1].green.y\
  \ = rgb_resulted[hw_points - 1].green;\n\tcorner_points[1].blue.y = rgb_resulted[hw_points\
  \ - 1].blue;\n\tcorner_points[1].red.slope = dc_fixpt_zero;\n\tcorner_points[1].green.slope\
  \ = dc_fixpt_zero;\n\tcorner_points[1].blue.slope = dc_fixpt_zero;\n\n\tif (output_tf->tf\
  \ == TRANSFER_FUNCTION_PQ) {\n\t\t/* for PQ, we want to have a straight line from\
  \ last HW X point,\n\t\t * and the slope to be such that we hit 1.0 at 10000 nits.\n\
  \t\t */\n\t\tconst struct fixed31_32 end_value =\n\t\t\t\tdc_fixpt_from_int(125);\n\
  \n\t\tcorner_points[1].red.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].red.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].red.x));\n\
  \t\tcorner_points[1].green.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].green.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].green.x));\n\
  \t\tcorner_points[1].blue.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].blue.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].blue.x));\n\
  \t}\n\n\tlut_params->hw_points_num = hw_points;\n\n\tk = 0;\n\tfor (i = 1; i < MAX_REGIONS_NUMBER;\
  \ i++) {\n\t\tif (seg_distr[k] != -1) {\n\t\t\tlut_params->arr_curve_points[k].segments_num\
  \ =\n\t\t\t\t\tseg_distr[k];\n\t\t\tlut_params->arr_curve_points[i].offset =\n\t\
  \t\t\t\tlut_params->arr_curve_points[k].offset + (1 << seg_distr[k]);\n\t\t}\n\t\
  \tk++;\n\t}\n\n\tif (seg_distr[k] != -1)\n\t\tlut_params->arr_curve_points[k].segments_num\
  \ = seg_distr[k];\n\n\trgb = rgb_resulted;\n\trgb_plus_1 = rgb_resulted + 1;\n\t\
  rgb_minus_1 = rgb;\n\n\ti = 1;\n\twhile (i != hw_points + 1) {\n\n\t\tif (i >= hw_points\
  \ - 1) {\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->red, rgb->red))\n\t\t\t\trgb_plus_1->red\
  \ = dc_fixpt_add(rgb->red, rgb_minus_1->delta_red);\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->green,\
  \ rgb->green))\n\t\t\t\trgb_plus_1->green = dc_fixpt_add(rgb->green, rgb_minus_1->delta_green);\n\
  \t\t\tif (dc_fixpt_lt(rgb_plus_1->blue, rgb->blue))\n\t\t\t\trgb_plus_1->blue =\
  \ dc_fixpt_add(rgb->blue, rgb_minus_1->delta_blue);\n\t\t}\n\n\t\trgb->delta_red\
  \   = dc_fixpt_sub(rgb_plus_1->red,   rgb->red);\n\t\trgb->delta_green = dc_fixpt_sub(rgb_plus_1->green,\
  \ rgb->green);\n\t\trgb->delta_blue  = dc_fixpt_sub(rgb_plus_1->blue,  rgb->blue);\n\
  \n\n\t\tif (fixpoint == true) {\n\t\t\tuint32_t red_clamp = dc_fixpt_clamp_u0d14(rgb->delta_red);\n\
  \t\t\tuint32_t green_clamp = dc_fixpt_clamp_u0d14(rgb->delta_green);\n\t\t\tuint32_t\
  \ blue_clamp = dc_fixpt_clamp_u0d14(rgb->delta_blue);\n\n\t\t\tif (red_clamp >>\
  \ 10 || green_clamp >> 10 || blue_clamp >> 10)\n\t\t\t\tDC_LOG_WARNING(\"Losing\
  \ delta precision while programming shaper LUT.\");\n\n\t\t\trgb->delta_red_reg\
  \   = red_clamp & 0x3ff;\n\t\t\trgb->delta_green_reg = green_clamp & 0x3ff;\n\t\t\
  \trgb->delta_blue_reg  = blue_clamp & 0x3ff;\n\t\t\trgb->red_reg         = dc_fixpt_clamp_u0d14(rgb->red);\n\
  \t\t\trgb->green_reg       = dc_fixpt_clamp_u0d14(rgb->green);\n\t\t\trgb->blue_reg\
  \        = dc_fixpt_clamp_u0d14(rgb->blue);\n\t\t}\n\n\t\t++rgb_plus_1;\n\t\trgb_minus_1\
  \ = rgb;\n\t\t++rgb;\n\t\t++i;\n\t}\n\tcm_helper_convert_to_custom_float(rgb_resulted,\n\
  \t\t\t\t\t\tlut_params->corner_points,\n\t\t\t\t\t\thw_points, fixpoint);\n\n\t\
  return true;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\
  \ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nindex b7e57aa27361..b0d192c6e63e\
  \ 100644\n--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n\
  @@ -402,6 +402,11 @@ bool cm_helper_translate_curve_to_hw_format(struct dc_context\
  \ *ctx,\n \t\t\t\ti += increment) {\n \t\t\tif (j == hw_points - 1)\n \t\t\t\tbreak;\n\
  +\t\t\tif (i >= TRANSFER_FUNC_POINTS) {\n+\t\t\t\tDC_LOG_ERROR(\"Index out of bounds:\
  \ i=%d, TRANSFER_FUNC_POINTS=%d\\n\",\n+\t\t\t\t\t     i, TRANSFER_FUNC_POINTS);\n\
  +\t\t\t\treturn false;\n+\t\t\t}\n \t\t\trgb_resulted[j].red = output_tf->tf_pts.red[i];\n\
  \ \t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n \t\t\trgb_resulted[j].blue\
  \ = output_tf->tf_pts.blue[i];\n```\n"
pattern: "## Bug Pattern\n\nIndexing fixed-size transfer-function LUT arrays with\
  \ a computed index derived from region/segment arithmetic without validating the\
  \ index against the array bound (TRANSFER_FUNC_POINTS), e.g.:\n\nfor (...) {\n \
  \   // i computed from region/segment math\n    // Missing: if (i >= TRANSFER_FUNC_POINTS)\
  \ error/return\n    val_r = output_tf->tf_pts.red[i];\n    val_g = output_tf->tf_pts.green[i];\n\
  \    val_b = output_tf->tf_pts.blue[i];\n}\n\nThis lack of bounds checking can lead\
  \ to out-of-bounds reads when i (or start_index) exceeds TRANSFER_FUNC_POINTS."
plan: "Plan\n\n1) Program state\n- No custom program state is necessary. We will rely\
  \ on:\n  - The analyzer\u2019s existing constraint manager to reason about the index\
  \ range.\n  - The provided helper inferSymbolMaxVal to query an index\u2019s maximum\
  \ feasible value.\n  - A small amount of local AST inspection to identify the specific\
  \ LUT arrays and their compile-time size.\n\n2) Helper routines (internal to the\
  \ checker)\n- isTFLutColorArray(const Expr *Base, StringRef &ColorOut, const ConstantArrayType\
  \ *&ArrTy):\n  - Input: the ArraySubscriptExpr base (after IgnoreParenImpCasts()).\n\
  \  - Return true if Base is a MemberExpr chain of the form \u201C...->tf_pts.red\u201D\
  \ (or green/blue).\n    - Steps:\n      - dyn_cast<MemberExpr>(Base) => ME1, ensure\
  \ its member is a FieldDecl named in {\"red\",\"green\",\"blue\"}. Save ColorOut.\n\
  \      - Get ME1->getBase()->IgnoreParenImpCasts() => ME2Expr; dyn_cast<MemberExpr>(ME2Expr)\
  \ => ME2; ensure ME2 member is a FieldDecl named \"tf_pts\".\n      - For ME1\u2019\
  s FieldDecl FD1, fetch FD1->getType(). dyn_cast<ConstantArrayType> to ArrTy. If\
  \ not ConstantArrayType, return false (we can\u2019t know the bound reliably).\n\
  \  - If all checks pass, return true and output ArrTy (contains the constant array\
  \ bound) and ColorOut.\n\n- getIndexInfo(const Expr *Idx, CheckerContext &C, bool\
  \ &IsConst, llvm::APSInt &ConstVal, SymbolRef &Sym):\n  - Idx = AE->getIdx()->IgnoreParenImpCasts().\n\
  \  - If EvaluateExprToInt(ConstVal, Idx, C) returns true, set IsConst = true and\
  \ Sym = nullptr.\n  - Else, IsConst = false, try to get the symbol with: Sym = C.getState()->getSVal(Idx,\
  \ C.getLocationContext()).getAsSymbol(); (if null, we will be conservative).\n\n\
  - guardedByTransferPointsCondition(const Expr *Idx, const Stmt *AccessSite, CheckerContext\
  \ &C):\n  - Best-effort suppression to avoid FPs when there is an obvious nearby\
  \ guard.\n  - Find a nearest enclosing IfStmt or loop condition using findSpecificTypeInParents<IfStmt>(AccessSite,\
  \ C) (or ForStmt/WhileStmt similarly).\n  - If found, take its condition expression\
  \ CondE and:\n    - Extract index name text (use ExprHasName(CondE, \"<index-name>\"\
  , C)).\n    - Check also ExprHasName(CondE, \"TRANSFER_FUNC_POINTS\", C).\n    -\
  \ If both are present, return true (assume guarded). Otherwise false.\n  - This\
  \ function is optional; we will call it only when constraints are inconclusive and\
  \ we would otherwise warn.\n\n3) Callback selection and implementation details\n\
  \nA) checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const\n\
  - Why: This is invoked on loads/stores. The problematic access is a read from output_tf->tf_pts.{red,green,blue}[i],\
  \ so it naturally passes through here as a load.\n- Steps:\n  1) Process only loads\
  \ (IsLoad == true).\n  2) Cast S to ArraySubscriptExpr: const auto *AE = dyn_cast_or_null<ArraySubscriptExpr>(S).\
  \ If not AE, return.\n  3) Identify the TF LUT array:\n     - Base = AE->getBase()->IgnoreParenImpCasts().\n\
  \     - Call isTFLutColorArray(Base, ColorName, ArrTy). If false, return (we only\
  \ flag indexing into tf_pts.{red,green,blue}).\n  4) Obtain the array bound:\n \
  \    - From ArrTy, get size: llvm::APInt ArrSize = ArrTy->getSize(). (Use ArrSize.getLimitedValue()\
  \ for comparisons.)\n  5) Analyze the index:\n     - Idx = AE->getIdx()->IgnoreParenImpCasts().\n\
  \     - Use getIndexInfo(Idx, C, IsConst, ConstVal, Sym).\n  6) Decide safety:\n\
  \     - If IsConst == true:\n       - If ConstVal.uge(ArrSize) => definite OOB;\
  \ report.\n       - Else return (safe).\n     - Else (symbolic or unknown):\n  \
  \     - If Sym != nullptr:\n         - const llvm::APSInt *MaxV = inferSymbolMaxVal(Sym,\
  \ C).\n         - If MaxV is not null AND MaxV->ult(ArrSize) => proven safe; return.\n\
  \         - Else (unknown OR MaxV >= ArrSize) => not proven safe; continue to 7).\n\
  \       - If Sym == nullptr: not proven safe; continue to 7).\n  7) Optional guard\
  \ suppression:\n     - If guardedByTransferPointsCondition(Idx, S, C) returns true,\
  \ return (assume guarded).\n  8) Report bug:\n     - generateNonFatalErrorNode()\
  \ and emit a PathSensitiveBugReport with a short message, e.g.:\n       - \"Possible\
  \ out-of-bounds read from tf_pts.[red|green|blue]; missing index < TRANSFER_FUNC_POINTS\
  \ check.\"\n     - Optionally include a note with the array bound and the index\
  \ expression textual dump for clarity.\n\nB) No other callbacks are strictly necessary\n\
  - We do not need checkBranchCondition or a custom program state map because:\n \
  \ - The constraint manager and inferSymbolMaxVal suffice to conclude when an index\
  \ is definitely within bounds.\n  - The optional guard detection step uses findSpecificTypeInParents\
  \ and ExprHasName to avoid FPs without maintaining state.\n\n4) Bug reporting details\n\
  - Create a checker-local BugType, e.g., BugType BT(\"Transfer-function LUT index\
  \ OOB\", \"API Misuse\").\n- Use std::make_unique<PathSensitiveBugReport>(BT, Msg,\
  \ Node).\n- Keep the message short and clear, per instruction.\n\n5) Notes and tuning\n\
  - We only analyze subscript expressions where the array is a field named in {\"\
  red\",\"green\",\"blue\"} coming from a parent field named \"tf_pts\"; this makes\
  \ the checker targeted and reduces false positives.\n- We rely on the array field\u2019\
  s ConstantArrayType to get the true bound (which is the macro TRANSFER_FUNC_POINTS\
  \ after preprocessing), so we do not need to evaluate the macro explicitly.\n- If\
  \ needed, we can expand the checker in the future to track additional LUTs or allow\
  \ a configurable whitelist of field names."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program states are necessary.\n\nnamespace\
  \ {\n\nclass SAGenTestChecker : public Checker<check::Location> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Transfer-function\
  \ LUT index out-of-bounds\", \"Array bounds\")) {}\n\n      void checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\n   private:\n  \
  \    // Return true if Base is of the form \"...->tf_pts.red\" (or green/blue),\
  \ and\n      // ArrTy is the constant array type of the color channel.\n      bool\
  \ isTFLutColorArray(const Expr *Base,\n                             StringRef &ColorOut,\n\
  \                             const ConstantArrayType *&ArrTy) const;\n\n      //\
  \ Extract index info: either a constant APSInt or a SymbolRef.\n      void getIndexInfo(const\
  \ Expr *Idx, CheckerContext &C, bool &IsConst,\n                        llvm::APSInt\
  \ &ConstVal, SymbolRef &Sym) const;\n\n      // Best-effort suppression if a nearby\
  \ condition guards \"idx < TRANSFER_FUNC_POINTS\".\n      bool guardedByTransferPointsCondition(const\
  \ Expr *Idx,\n                                            const Stmt *AccessSite,\n\
  \                                            CheckerContext &C) const;\n\n     \
  \ void reportOOB(const ArraySubscriptExpr *AE, StringRef ColorName,\n          \
  \           CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isTFLutColorArray(const\
  \ Expr *Base,\n                                         StringRef &ColorOut,\n \
  \                                        const ConstantArrayType *&ArrTy) const\
  \ {\n  if (!Base)\n    return false;\n\n  Base = Base->IgnoreParenImpCasts();\n\
  \  const auto *ME1 = dyn_cast<MemberExpr>(Base);\n  if (!ME1)\n    return false;\n\
  \n  const auto *FD1 = dyn_cast<FieldDecl>(ME1->getMemberDecl());\n  if (!FD1)\n\
  \    return false;\n\n  StringRef Color = FD1->getName();\n  if (!(Color == \"red\"\
  \ || Color == \"green\" || Color == \"blue\"))\n    return false;\n\n  const Expr\
  \ *ME1BaseExpr = ME1->getBase();\n  if (!ME1BaseExpr)\n    return false;\n\n  ME1BaseExpr\
  \ = ME1BaseExpr->IgnoreParenImpCasts();\n  const auto *ME2 = dyn_cast<MemberExpr>(ME1BaseExpr);\n\
  \  if (!ME2)\n    return false;\n\n  const auto *FD2 = dyn_cast<FieldDecl>(ME2->getMemberDecl());\n\
  \  if (!FD2)\n    return false;\n\n  if (FD2->getName() != \"tf_pts\")\n    return\
  \ false;\n\n  // Get red/green/blue array type bound.\n  QualType QT = FD1->getType();\n\
  \  const auto *CAT = dyn_cast<ConstantArrayType>(QT.getTypePtr());\n  if (!CAT)\n\
  \    return false;\n\n  ColorOut = Color;\n  ArrTy = CAT;\n  return true;\n}\n\n\
  void SAGenTestChecker::getIndexInfo(const Expr *Idx, CheckerContext &C,\n      \
  \                              bool &IsConst, llvm::APSInt &ConstVal,\n        \
  \                            SymbolRef &Sym) const {\n  IsConst = false;\n  Sym\
  \ = nullptr;\n  if (!Idx)\n    return;\n\n  // Try to evaluate as constant.\n  if\
  \ (EvaluateExprToInt(ConstVal, Idx, C)) {\n    IsConst = true;\n    return;\n  }\n\
  \n  // Otherwise, try to obtain a symbol for the index.\n  ProgramStateRef State\
  \ = C.getState();\n  SVal SV = State->getSVal(Idx, C.getLocationContext());\n  Sym\
  \ = SV.getAsSymbol();\n}\n\nbool SAGenTestChecker::guardedByTransferPointsCondition(const\
  \ Expr *Idx,\n                                                        const Stmt\
  \ *AccessSite,\n                                                        CheckerContext\
  \ &C) const {\n  // We look for If/For/While/Do conditions that mention both the\
  \ index name\n  // and TRANSFER_FUNC_POINTS.\n  const DeclRefExpr *IdxDRE = dyn_cast<DeclRefExpr>(Idx->IgnoreParenImpCasts());\n\
  \  if (!IdxDRE)\n    return false;\n\n  const auto *VD = dyn_cast<VarDecl>(IdxDRE->getDecl());\n\
  \  if (!VD)\n    return false;\n\n  StringRef IdxName = VD->getName();\n\n  // Check\
  \ an enclosing if\n  if (const IfStmt *IS = findSpecificTypeInParents<IfStmt>(AccessSite,\
  \ C)) {\n    if (const Expr *CondE = IS->getCond()) {\n      if (ExprHasName(CondE,\
  \ IdxName, C) && ExprHasName(CondE, \"TRANSFER_FUNC_POINTS\", C))\n        return\
  \ true;\n    }\n  }\n  // Check an enclosing for\n  if (const ForStmt *FS = findSpecificTypeInParents<ForStmt>(AccessSite,\
  \ C)) {\n    if (const Expr *CondE = FS->getCond()) {\n      if (ExprHasName(CondE,\
  \ IdxName, C) && ExprHasName(CondE, \"TRANSFER_FUNC_POINTS\", C))\n        return\
  \ true;\n    }\n  }\n  // Check an enclosing while\n  if (const WhileStmt *WS =\
  \ findSpecificTypeInParents<WhileStmt>(AccessSite, C)) {\n    if (const Expr *CondE\
  \ = WS->getCond()) {\n      if (ExprHasName(CondE, IdxName, C) && ExprHasName(CondE,\
  \ \"TRANSFER_FUNC_POINTS\", C))\n        return true;\n    }\n  }\n  // Check an\
  \ enclosing do-while\n  if (const DoStmt *DS = findSpecificTypeInParents<DoStmt>(AccessSite,\
  \ C)) {\n    if (const Expr *CondE = DS->getCond()) {\n      if (ExprHasName(CondE,\
  \ IdxName, C) && ExprHasName(CondE, \"TRANSFER_FUNC_POINTS\", C))\n        return\
  \ true;\n    }\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::reportOOB(const\
  \ ArraySubscriptExpr *AE, StringRef ColorName,\n                               \
  \  CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  SmallString<128> Msg;\n  Msg += \"Possible out-of-bounds\
  \ read from tf_pts.\";\n  Msg += ColorName;\n  Msg += \"; missing index < TRANSFER_FUNC_POINTS\
  \ check\";\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n\
  \  if (AE)\n    R->addRange(AE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt *S,\
  \ CheckerContext &C) const {\n  if (!IsLoad || !S)\n    return;\n\n  const auto\
  \ *AE = dyn_cast<ArraySubscriptExpr>(S);\n  if (!AE)\n    return;\n\n  const Expr\
  \ *Base = AE->getBase();\n  StringRef ColorName;\n  const ConstantArrayType *ArrTy\
  \ = nullptr;\n\n  if (!isTFLutColorArray(Base, ColorName, ArrTy))\n    return;\n\
  \n  // Get the array bound (TRANSFER_FUNC_POINTS after preprocessing).\n  llvm::APInt\
  \ ArrSize = ArrTy->getSize();\n\n  // Analyze the index.\n  const Expr *IdxE = AE->getIdx();\n\
  \  if (!IdxE)\n    return;\n\n  bool IsConst = false;\n  llvm::APSInt ConstVal;\n\
  \  SymbolRef Sym = nullptr;\n  getIndexInfo(IdxE, C, IsConst, ConstVal, Sym);\n\n\
  \  // If constant index: report if negative or >= bound.\n  if (IsConst) {\n   \
  \ // Negative index is OOB.\n    if (ConstVal.isSigned() && ConstVal.isNegative())\
  \ {\n      reportOOB(AE, ColorName, C);\n      return;\n    }\n    // Compare against\
  \ bound using consistent bitwidth/signedness.\n    llvm::APSInt BoundAPS(ArrSize.zextOrTrunc(ConstVal.getBitWidth()),\n\
  \                          ConstVal.isUnsigned());\n    if (ConstVal >= BoundAPS)\
  \ {\n      reportOOB(AE, ColorName, C);\n    }\n    return;\n  }\n\n  // If symbolic\
  \ index: try to prove safe using max value.\n  if (Sym) {\n    const llvm::APSInt\
  \ *MaxV = inferSymbolMaxVal(Sym, C);\n    if (MaxV) {\n      llvm::APSInt BoundAPS(ArrSize.zextOrTrunc(MaxV->getBitWidth()),\n\
  \                            MaxV->isUnsigned());\n      // If we can prove max\
  \ < bound, it's safe.\n      if (MaxV->ult(BoundAPS))\n        return;\n      //\
  \ Otherwise, continue to optional guard check and potentially report.\n    }\n \
  \ }\n\n  // Optional guard suppression: look for condition mentioning index and\
  \ TRANSFER_FUNC_POINTS.\n  if (guardedByTransferPointsCondition(IdxE, S, C))\n \
  \   return;\n\n  // Not proven safe and not guarded; report.\n  reportOOB(AE, ColorName,\
  \ C);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects missing bounds checks when indexing tf_pts.{red,green,blue} arrays\
  \ (TRANSFER_FUNC_POINTS)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
