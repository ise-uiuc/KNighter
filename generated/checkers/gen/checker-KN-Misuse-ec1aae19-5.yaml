_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: ec1aae190c7729ffdd3603de311dc00f7ff988f9
commit_type: Misuse
index: 5
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Attr.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/AST/Decl.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program-state: regions\
  \ known to be zero-initialized (e.g., kzalloc/kcalloc)\nREGISTER_SET_WITH_PROGRAMSTATE(ZeroInitObjs,\
  \ const MemRegion*)\n// Program-state: counter field regions that have been written\
  \ at least once\nREGISTER_SET_WITH_PROGRAMSTATE(InitializedCounterFieldRegions,\
  \ const MemRegion*)\n\nnamespace {\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::PostCall,\n        check::PreCall,\n        check::Bind> {\n\n \
  \ mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker() : BT(new\
  \ BugType(this, \"Flexible array misuse\", \"Memory Safety\")) {}\n\n  void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  void checkBind(SVal Loc, SVal Val, const Stmt\
  \ *S, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  bool isZeroInitAlloc(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  bool isCopyFunction(const CallEvent\
  \ &Call, unsigned &DestArgIndex, CheckerContext &C) const;\n\n  const MemberExpr\
  \ *getFlexArrayMemberExpr(const Expr *Dest, CheckerContext &C) const;\n  bool isFlexibleArrayField(const\
  \ FieldDecl *FD) const;\n\n  bool fieldHasCountedBy(const FieldDecl *FD, CheckerContext\
  \ &C) const;\n  const FieldDecl *getCountedByCounterFD(const FieldDecl *FlexArrayFD,\
  \ CheckerContext &C) const;\n  bool isCounterFieldForAnyCountedBy(const FieldDecl\
  \ *FD, CheckerContext &C) const;\n\n  const MemRegion *getBaseObjectRegionFromMemberExpr(const\
  \ MemberExpr *ME, CheckerContext &C) const;\n  const MemRegion *getFieldRegionForCounter(const\
  \ MemRegion *BaseObj, const FieldDecl *CounterFD, CheckerContext &C) const;\n\n\
  \  void reportFlexibleArrayBeforeCounter(const Expr *DestE, CheckerContext &C) const;\n\
  \n  // Small text utilities\n  bool getDeclSourceText(StringRef &Out, const Decl\
  \ *D, CheckerContext &C) const;\n  static StringRef trimParensAndSpaces(StringRef\
  \ S);\n};\n\nbool SAGenTestChecker::isZeroInitAlloc(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n\
  \    return false;\n\n  // Known zero-initializing allocators\n  static const char\
  \ *Names[] = {\n      \"kzalloc\", \"kcalloc\", \"kvzalloc\",\n      \"devm_kzalloc\"\
  , \"devm_kcalloc\",\n      \"kzalloc_node\", \"kcalloc_node\"\n  };\n\n  for (const\
  \ char *N : Names) {\n    if (ExprHasName(OriginExpr, N, C))\n      return true;\n\
  \  }\n  return false;\n}\n\nbool SAGenTestChecker::isCopyFunction(const CallEvent\
  \ &Call, unsigned &DestArgIndex, CheckerContext &C) const {\n  DestArgIndex = 0;\n\
  \  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n    return\
  \ false;\n\n  static const char *Names[] = {\n      \"memcpy\", \"__memcpy\", \"\
  __builtin_memcpy\",\n      \"memmove\", \"__memmove\", \"__builtin_memmove\"\n \
  \ };\n\n  for (const char *N : Names) {\n    if (ExprHasName(OriginExpr, N, C))\n\
  \      return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isFlexibleArrayField(const\
  \ FieldDecl *FD) const {\n  if (!FD)\n    return false;\n\n  if (FD->isFlexibleArrayMember())\n\
  \    return true;\n\n  QualType QT = FD->getType();\n  if (QT.isNull())\n    return\
  \ false;\n\n  const Type *Ty = QT.getTypePtrOrNull();\n  if (!Ty)\n    return false;\n\
  \n  if (isa<IncompleteArrayType>(Ty))\n    return true;\n\n  return false;\n}\n\n\
  const MemberExpr *SAGenTestChecker::getFlexArrayMemberExpr(const Expr *Dest, CheckerContext\
  \ &C) const {\n  if (!Dest)\n    return nullptr;\n\n  // Try to find a MemberExpr\
  \ in the destination expression tree\n  const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(Dest);\n\
  \  if (!ME)\n    return nullptr;\n\n  const ValueDecl *VD = ME->getMemberDecl();\n\
  \  const FieldDecl *FD = dyn_cast_or_null<FieldDecl>(VD);\n  if (!FD)\n    return\
  \ nullptr;\n\n  if (!isFlexibleArrayField(FD))\n    return nullptr;\n\n  // Must\
  \ have counted_by annotation as well\n  if (!fieldHasCountedBy(FD, C))\n    return\
  \ nullptr;\n\n  return ME;\n}\n\nbool SAGenTestChecker::fieldHasCountedBy(const\
  \ FieldDecl *FD, CheckerContext &C) const {\n  if (!FD)\n    return false;\n\n \
  \ // Prefer the real attribute when available\n  if (FD->hasAttr<CountedByAttr>())\n\
  \    return true;\n\n  // Fallback: look for \"__counted_by(\" or \"counted_by(\"\
  \ spelling in the declaration source\n  StringRef Text;\n  if (getDeclSourceText(Text,\
  \ FD, C)) {\n    if (Text.contains(\"__counted_by(\") || Text.contains(\"counted_by(\"\
  ))\n      return true;\n  }\n  return false;\n}\n\nconst FieldDecl *SAGenTestChecker::getCountedByCounterFD(const\
  \ FieldDecl *FlexArrayFD, CheckerContext &C) const {\n  if (!FlexArrayFD)\n    return\
  \ nullptr;\n\n  // If Clang provides the attribute, try to get the counter directly\n\
  \  if (auto *A = FlexArrayFD->getAttr<CountedByAttr>()) {\n    // Newer Clang versions\
  \ expose the referenced field; try known accessors if available.\n    // Use a conservative\
  \ approach if API details differ: try to retrieve the field by name from attr spelling.\n\
  \    // Fall through to text parsing if we cannot retrieve it directly.\n    //\
  \ (We do not rely on undefined methods; keep this guarded by fallback below.)\n\
  \  }\n\n  // Fallback path: parse the attribute argument to get the counter's field\
  \ name\n  StringRef Text;\n  if (!getDeclSourceText(Text, FlexArrayFD, C))\n   \
  \ return nullptr;\n\n  size_t Pos = Text.find(\"counted_by\");\n  if (Pos == StringRef::npos)\n\
  \    Pos = Text.find(\"__counted_by\");\n  if (Pos == StringRef::npos)\n    return\
  \ nullptr;\n\n  size_t L = Text.find('(', Pos);\n  size_t R = (L == StringRef::npos)\
  \ ? StringRef::npos : Text.find(')', L + 1);\n  if (L == StringRef::npos || R ==\
  \ StringRef::npos || R <= L + 1)\n    return nullptr;\n\n  StringRef Param = Text.slice(L\
  \ + 1, R);\n  Param = trimParensAndSpaces(Param);\n  if (Param.empty())\n    return\
  \ nullptr;\n\n  const RecordDecl *RD = dyn_cast<RecordDecl>(FlexArrayFD->getParent());\n\
  \  if (!RD)\n    return nullptr;\n\n  for (const FieldDecl *F : RD->fields()) {\n\
  \    if (F->getName() == Param)\n      return F;\n  }\n  return nullptr;\n}\n\n\
  bool SAGenTestChecker::isCounterFieldForAnyCountedBy(const FieldDecl *FD, CheckerContext\
  \ &C) const {\n  if (!FD)\n    return false;\n\n  const RecordDecl *RD = dyn_cast<RecordDecl>(FD->getParent());\n\
  \  if (!RD)\n    return false;\n\n  for (const FieldDecl *F : RD->fields()) {\n\
  \    if (!isFlexibleArrayField(F))\n      continue;\n    if (!fieldHasCountedBy(F,\
  \ C))\n      continue;\n\n    const FieldDecl *Counter = getCountedByCounterFD(F,\
  \ C);\n    if (Counter == FD)\n      return true;\n  }\n  return false;\n}\n\nconst\
  \ MemRegion *SAGenTestChecker::getBaseObjectRegionFromMemberExpr(const MemberExpr\
  \ *ME, CheckerContext &C) const {\n  if (!ME)\n    return nullptr;\n  const Expr\
  \ *BaseE = ME->getBase();\n  if (!BaseE)\n    return nullptr;\n\n  const MemRegion\
  \ *Reg = getMemRegionFromExpr(BaseE, C);\n  if (!Reg)\n    return nullptr;\n\n \
  \ Reg = Reg->getBaseRegion();\n  return Reg;\n}\n\nconst MemRegion *SAGenTestChecker::getFieldRegionForCounter(const\
  \ MemRegion *BaseObj, const FieldDecl *CounterFD, CheckerContext &C) const {\n \
  \ if (!BaseObj || !CounterFD)\n    return nullptr;\n  const MemRegion *FR = C.getStoreManager().getRegionManager().getFieldRegion(CounterFD,\
  \ BaseObj);\n  return FR;\n}\n\nbool SAGenTestChecker::getDeclSourceText(StringRef\
  \ &Out, const Decl *D, CheckerContext &C) const {\n  if (!D)\n    return false;\n\
  \  SourceRange SR = D->getSourceRange();\n  if (SR.isInvalid())\n    return false;\n\
  \n  CharSourceRange CR = CharSourceRange::getTokenRange(SR);\n  Out = Lexer::getSourceText(CR,\
  \ C.getSourceManager(), C.getLangOpts());\n  return !Out.empty();\n}\n\nStringRef\
  \ SAGenTestChecker::trimParensAndSpaces(StringRef S) {\n  S = S.trim();\n  while\
  \ (!S.empty() && (S.front() == '(' || S.front() == ' ' || S.front() == '\\t'))\n\
  \    S = S.drop_front();\n  while (!S.empty() && (S.back() == ')' || S.back() ==\
  \ ' ' || S.back() == '\\t'))\n    S = S.drop_back();\n  return S.trim();\n}\n\n\
  void SAGenTestChecker::reportFlexibleArrayBeforeCounter(const Expr *DestE, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Flexible array accessed before setting its __counted_by counter\", N);\n  if\
  \ (DestE)\n    R->addRange(DestE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// Callbacks\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const {\n  if (!isZeroInitAlloc(Call, C))\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n  SVal Ret = Call.getReturnValue();\n\
  \  const MemRegion *R = Ret.getAsRegion();\n  if (!R)\n    return;\n  R = R->getBaseRegion();\n\
  \  if (!R)\n    return;\n\n  State = State->add<ZeroInitObjs>(R);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  unsigned DestIdx = 0;\n  if (!isCopyFunction(Call, DestIdx, C))\n \
  \   return;\n\n  if (DestIdx >= Call.getNumArgs())\n    return;\n\n  const Expr\
  \ *DestE = Call.getArgExpr(DestIdx);\n  if (!DestE)\n    return;\n\n  const MemberExpr\
  \ *ME = getFlexArrayMemberExpr(DestE, C);\n  if (!ME)\n    return;\n\n  const FieldDecl\
  \ *FlexFD = dyn_cast_or_null<FieldDecl>(ME->getMemberDecl());\n  if (!FlexFD)\n\
  \    return;\n\n  const FieldDecl *CounterFD = getCountedByCounterFD(FlexFD, C);\n\
  \  if (!CounterFD)\n    return;\n\n  const MemRegion *BaseObj = getBaseObjectRegionFromMemberExpr(ME,\
  \ C);\n  if (!BaseObj)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \n  // Only warn for known zero-initialized objects (e.g., kzalloc)\n  if (!State->contains<ZeroInitObjs>(BaseObj))\n\
  \    return;\n\n  const MemRegion *CounterFR = getFieldRegionForCounter(BaseObj,\
  \ CounterFD, C);\n  if (!CounterFR)\n    return;\n\n  // If counter was already\
  \ initialized, no bug.\n  if (State->contains<InitializedCounterFieldRegions>(CounterFR))\n\
  \    return;\n\n  // Report: accessing flexible array before setting its counted_by\
  \ counter.\n  reportFlexibleArrayBeforeCounter(DestE, C);\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  const MemRegion *R\
  \ = Loc.getAsRegion();\n  if (!R)\n    return;\n\n  R = R->getBaseRegion();\n  if\
  \ (!R)\n    return;\n\n  const FieldRegion *FR = dyn_cast<FieldRegion>(R);\n  if\
  \ (!FR)\n    return;\n\n  const FieldDecl *FD = FR->getDecl();\n  if (!FD)\n   \
  \ return;\n\n  // Only track writes to fields that are counters for __counted_by\
  \ flex arrays.\n  if (!isCounterFieldForAnyCountedBy(FD, C))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  State = State->add<InitializedCounterFieldRegions>(FR);\n\
  \  C.addTransition(State);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects memcpy/memmove into __counted_by\
  \ flexible-array before its counter is set\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nwifi: brcmfmac: fweh: Fix boot crash on Raspberry\
  \ Pi 4\n\nFix boot crash on Raspberry Pi by moving the update to `event->datalen`\n\
  before data is copied into flexible-array member `data` via `memcpy()`.\n\nFlexible-array\
  \ member `data` was annotated with `__counted_by(datalen)`\nin commit 62d19b358088\
  \ (\"wifi: brcmfmac: fweh: Add __counted_by for\nstruct brcmf_fweh_queue_item and\
  \ use struct_size()\"). The intention of\nthis is to gain visibility into the size\
  \ of `data` at run-time through\nits _counter_ (in this case `datalen`), and with\
  \ this have its accesses\nbounds-checked at run-time via CONFIG_FORTIFY_SOURCE and\n\
  CONFIG_UBSAN_BOUNDS.\n\nTo effectively accomplish the above, we shall update the\
  \ counter\n(`datalen`), before the first access to the flexible array (`data`),\n\
  which was also done in the mentioned commit.\n\nHowever, commit edec42821911 (\"\
  wifi: brcmfmac: allow per-vendor event\nhandling\") inadvertently caused a buffer\
  \ overflow, detected by\nFORTIFY_SOURCE. It moved the `event->datalen = datalen;`\
  \ update to after\nthe first `data` access, at which point `event->datalen` was\
  \ not yet\nupdated from zero (after calling `kzalloc()`), leading to the overflow\n\
  issue.\n\nThis fix repositions the `event->datalen = datalen;` update before\naccessing\
  \ `data`, restoring the intended buffer overflow protection. :)\n\nFixes: edec42821911\
  \ (\"wifi: brcmfmac: allow per-vendor event handling\")\nReported-by: Nathan Chancellor\
  \ <nathan@kernel.org>\nCloses: https://gist.github.com/nathanchance/e22f681f3bfc467f15cdf6605021aaa6\n\
  Tested-by: Nathan Chancellor <nathan@kernel.org>\nSigned-off-by: Gustavo A. R. Silva\
  \ <gustavoars@kernel.org>\nReviewed-by: Kees Cook <keescook@chromium.org>\nAcked-by:\
  \ Arend van Spriel <arend.vanspriel@broadcom.com>\nSigned-off-by: Kalle Valo <kvalo@kernel.org>\n\
  Link: https://msgid.link/Zc+3PFCUvLoVlpg8@neat\n\n## Buggy Code\n\n```c\n// Function:\
  \ brcmf_fweh_process_event in drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c\n\
  void brcmf_fweh_process_event(struct brcmf_pub *drvr,\n\t\t\t      struct brcmf_event\
  \ *event_packet,\n\t\t\t      u32 packet_len, gfp_t gfp)\n{\n\tu32 fwevt_idx;\n\t\
  struct brcmf_fweh_info *fweh = drvr->fweh;\n\tstruct brcmf_fweh_queue_item *event;\n\
  \tvoid *data;\n\tu32 datalen;\n\n\t/* get event info */\n\tfwevt_idx = get_unaligned_be32(&event_packet->msg.event_type);\n\
  \tdatalen = get_unaligned_be32(&event_packet->msg.datalen);\n\tdata = &event_packet[1];\n\
  \n\tif (fwevt_idx >= fweh->num_event_codes)\n\t\treturn;\n\n\tif (fwevt_idx != BRCMF_E_IF\
  \ && !fweh->evt_handler[fwevt_idx])\n\t\treturn;\n\n\tif (datalen > BRCMF_DCMD_MAXLEN\
  \ ||\n\t    datalen + sizeof(*event_packet) > packet_len)\n\t\treturn;\n\n\tevent\
  \ = kzalloc(struct_size(event, data, datalen), gfp);\n\tif (!event)\n\t\treturn;\n\
  \n\tevent->code = fwevt_idx;\n\tevent->ifidx = event_packet->msg.ifidx;\n\n\t/*\
  \ use memcpy to get aligned event message */\n\tmemcpy(&event->emsg, &event_packet->msg,\
  \ sizeof(event->emsg));\n\tmemcpy(event->data, data, datalen);\n\tevent->datalen\
  \ = datalen;\n\tmemcpy(event->ifaddr, event_packet->eth.h_dest, ETH_ALEN);\n\n\t\
  brcmf_fweh_queue_event(fweh, event);\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff\
  \ --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c\n\
  index 0774f6c59226..f0b6a7607f16 100644\n--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c\n\
  +++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c\n@@ -497,12 +497,12\
  \ @@ void brcmf_fweh_process_event(struct brcmf_pub *drvr,\n \t\treturn;\n \n \t\
  event->code = fwevt_idx;\n+\tevent->datalen = datalen;\n \tevent->ifidx = event_packet->msg.ifidx;\n\
  \ \n \t/* use memcpy to get aligned event message */\n \tmemcpy(&event->emsg, &event_packet->msg,\
  \ sizeof(event->emsg));\n \tmemcpy(event->data, data, datalen);\n-\tevent->datalen\
  \ = datalen;\n \tmemcpy(event->ifaddr, event_packet->eth.h_dest, ETH_ALEN);\n \n\
  \ \tbrcmf_fweh_queue_event(fweh, event);\n```\n"
pattern: "## Bug Pattern\n\nAccessing (e.g., memcpy into) a flexible-array member\
  \ annotated with __counted_by(counter) before initializing its counter field. Example:\n\
  \nstruct item {\n\tu32 datalen;\n\tu8 data[] __counted_by(datalen);\n};\n\nitem\
  \ *e = kzalloc(struct_size(e, data, len), GFP_KERNEL);\n/* BUG: e->datalen is 0/uninitialized\
  \ here, but e->data is accessed */\nmemcpy(e->data, src, len);\ne->datalen = len;\n\
  \nThis order-of-operations causes FORTIFY/UBSAN bounds checks to see a zero-sized\
  \ array and report/trigger an overflow. The counter must be set before any access\
  \ to the flexible array."
plan: "Plan\n\n1) Program state customizations\n- REGISTER_SET_WITH_PROGRAMSTATE(ZeroInitObjs,\
  \ const MemRegion*)\n  - Tracks heap/object regions known to be zero-initialized\
  \ (e.g., returned by kzalloc/devm_kzalloc/kcalloc/\u2026).\n\n- REGISTER_SET_WITH_PROGRAMSTATE(InitializedCounterFieldRegions,\
  \ const MemRegion*)\n  - Tracks specific counter fields (as FieldRegion) that have\
  \ been written to at least once. This lets us know that the __counted_by counter\
  \ was set before using the flexible array.\n\nRationale:\n- We only warn when:\n\
  \  - The object was zero-initialized (datalen is certainly 0).\n  - The particular\
  \ counter for the accessed flexible array has not yet been written.\n\nThis keeps\
  \ the checker simple and precise enough for the bug pattern.\n\n2) Helper utilities\n\
  - isZeroInitAlloc(const CallEvent &Call)\n  - Returns true for known zero-initializing\
  \ allocators:\n    - \"kzalloc\", \"kcalloc\", \"kvzalloc\", \"devm_kzalloc\", \"\
  devm_kcalloc\", \"kzalloc_node\", \"kcalloc_node\"\n  - Use Call.getCalleeIdentifier()\
  \ and getName() to match names.\n\n- isCopyFunction(const CallEvent &Call, unsigned\
  \ &DestArgIndex)\n  - Returns true for copying APIs that may write into the flexible\
  \ array:\n    - \"memcpy\", \"__memcpy\", \"__builtin_memcpy\", \"memmove\", \"\
  __memmove\", \"__builtin_memmove\"\n  - On success, set DestArgIndex = 0.\n\n- getFlexArrayMemberExpr(const\
  \ Expr *Dest, CheckerContext &C)\n  - From the destination expression of memcpy/memmove,\
  \ find a MemberExpr that refers to the flexible array member:\n    - Use findSpecificTypeInChildren<MemberExpr>(Dest)\
  \ to locate a MemberExpr.\n    - Confirm the referenced FieldDecl is a flexible\
  \ array (FieldDecl::isFlexibleArrayMember() or type is IncompleteArrayType).\n \
  \   - Confirm the FieldDecl has the counted_by attribute (CountedByAttr) or, if\
  \ attribute API is unavailable, conservatively check its source text using ExprHasName\
  \ on the field\u2019s declaration source to look for \"__counted_by\".\n  - Return\
  \ the MemberExpr if both conditions hold; otherwise return nullptr.\n\n- getCountedByCounterFD(const\
  \ FieldDecl *FlexArrayFD)\n  - Given a flexible-array FieldDecl with the counted_by\
  \ attribute, retrieve the FieldDecl that is the counter (the attribute\u2019s referenced\
  \ field).\n  - If Clang\u2019s CountedByAttr is available, query it directly. Otherwise,\
  \ use the RecordDecl context and the attribute\u2019s spelling (if available) to\
  \ resolve the named counter field. If the attribute API isn\u2019t accessible, fallback\
  \ to best-effort:\n    - Iterate fields of the RecordDecl to find a field with name\
  \ matching the counted_by argument, extracted from attribute spelling (string parsing).\n\
  \  - Return the counter FieldDecl (or nullptr on failure).\n\n- isCounterFieldForAnyCountedBy(const\
  \ FieldDecl *FD)\n  - Determine if FD serves as a counted_by counter for any flexible-array\
  \ member in its parent RecordDecl:\n    - Iterate the RecordDecl\u2019s fields;\
  \ for flexible-array fields with counted_by, check if the referenced counter equals\
  \ FD.\n  - Return true if FD is a counted_by counter.\n\n- getBaseObjectRegionFromMemberExpr(const\
  \ MemberExpr *ME, CheckerContext &C)\n  - Return the pointee object region for ME->getBase():\n\
  \    - Use getMemRegionFromExpr(ME->getBase(), C) to obtain the MemRegion that the\
  \ base pointer points to (Symbolic/heap region).\n\n- getFieldRegionForCounter(const\
  \ MemRegion *BaseObj, const FieldDecl *CounterFD, CheckerContext &C)\n  - Construct\
  \ the MemRegion for the counter field on this object:\n    - Use C.getStoreManager().getRegionManager().getFieldRegion(CounterFD,\
  \ BaseObj).\n  - Return that FieldRegion pointer.\n\n3) Callback selection and implementation\n\
  \nA) checkPostCall(const CallEvent &Call, CheckerContext &C) const\n- Goal: mark\
  \ zero-initialized heap object regions returned by zeroing allocators.\n- Steps:\n\
  \  1. If !isZeroInitAlloc(Call), return.\n  2. Get the return SVal: SVal Ret = Call.getReturnValue().\n\
  \  3. Get MemRegion: if const MemRegion *R = Ret.getAsRegion(); if not, return.\n\
  \  4. State := C.getState(); State = State->add<ZeroInitObjs>(R).\n  5. C.addTransition(State).\n\
  \nB) checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const\n- Goal:\
  \ learn when the counted_by counter field has been initialized (written).\n- Steps:\n\
  \  1. If Loc is not a loc::MemRegionVal, return.\n  2. Get MemRegion *R = Loc.getAsRegion().\
  \ If !R, return.\n  3. If R is not a FieldRegion, return.\n  4. Let FR = cast<FieldRegion>(R);\
  \ get FieldDecl *FD = FR->getDecl().\n  5. If !isCounterFieldForAnyCountedBy(FD),\
  \ return.\n  6. This is a write to the counted_by counter. Record it:\n     - State\
  \ = State->add<InitializedCounterFieldRegions>(FR).\n     - C.addTransition(State).\n\
  \nNotes:\n- We do not require Val to be non-zero; any assignment counts as \u201C\
  initialized\u201D since the bug is about a missing initialization before access.\n\
  - This is path-sensitive and will only mark the field as initialized along that\
  \ path.\n\nC) checkPreCall(const CallEvent &Call, CheckerContext &C) const\n- Goal:\
  \ warn when a flexible array annotated with counted_by is passed as dest to memcpy/memmove\
  \ before its counter is initialized for a zeroed object.\n- Steps:\n  1. unsigned\
  \ DestIdx; if (!isCopyFunction(Call, DestIdx)) return.\n  2. const Expr *DestE =\
  \ Call.getArgExpr(DestIdx);\n  3. const MemberExpr *ME = getFlexArrayMemberExpr(DestE,\
  \ C). If !ME, return.\n  4. const FieldDecl *FlexFD = cast<FieldDecl>(ME->getMemberDecl()).\n\
  \  5. Obtain the counter FieldDecl: const FieldDecl *CounterFD = getCountedByCounterFD(FlexFD).\
  \ If !CounterFD, return (can\u2019t reason).\n  6. Get Base object region: const\
  \ MemRegion *BaseObj = getBaseObjectRegionFromMemberExpr(ME, C). If !BaseObj, return.\n\
  \  7. Check if BaseObj is in ZeroInitObjs:\n     - If not, return (we only warn\
  \ for known-zero initialized objects to reduce false positives).\n  8. Build the\
  \ counter field region for this base object: const MemRegion *CounterFR = getFieldRegionForCounter(BaseObj,\
  \ CounterFD, C). If !CounterFR, return.\n  9. Check if CounterFR is in InitializedCounterFieldRegions:\n\
  \     - If yes, return (counter already set).\n     - If no, report a bug:\n   \
  \    - Node = C.generateNonFatalErrorNode();\n       - if (!Node) return;\n    \
  \   - Create a PathSensitiveBugReport with a short message:\n         \"Flexible\
  \ array accessed before setting its __counted_by counter\"\n       - Highlight the\
  \ dest argument range (DestE->getSourceRange()).\n       - C.emitReport(std::make_unique<PathSensitiveBugReport>(...)).\n\
  \n4) Notes on precision and scope\n- This checker focuses on the specific order-of-operations\
  \ bug:\n  - Object zero-initialized by kzalloc-like allocator.\n  - memcpy/memmove\
  \ into a flexible array annotated with __counted_by.\n  - Counter field has not\
  \ yet been written on that path.\n- It does not attempt to track:\n  - Indirect\
  \ aliases to the flexible array destination (e.g., storing event->data into a local\
  \ pointer before memcpy). This simplified version triggers on direct uses like memcpy(event->data,\
  \ ...).\n  - Non-zero-initialized objects or other copy-like APIs beyond memcpy/memmove.\n\
  - These constraints match the target pattern and keep the checker simple and robust.\n\
  \n5) Use of provided utility functions\n- findSpecificTypeInChildren<MemberExpr>(DestE):\
  \ to find the MemberExpr for the flexible array inside the memcpy destination expression\
  \ (handles array-to-pointer decay).\n- getMemRegionFromExpr(ME->getBase(), C): to\
  \ get the base object region of the structure instance.\n- ExprHasName can be used\
  \ as a fallback to check the attribute presence if direct attribute-querying is\
  \ not available in your Clang version."
refined_plan: null
repaired_checker_code: null
tn_score: -10
tp_score: -10
