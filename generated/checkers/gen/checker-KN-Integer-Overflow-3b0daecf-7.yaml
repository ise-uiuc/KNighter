_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3b0daecfeac0103aba8b293df07a0cbaf8b43f29
commit_type: Integer-Overflow
index: 7
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include\
  \ \"clang/Lex/Lexer.h\"\n#include <string>\n#include <vector>\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states are necessary.\n\nnamespace {\n\nstruct AllocFnInfo {\n  const char *Name;\n\
  \  unsigned SizeIndex;\n  const char *Recommendation;\n};\n\nstatic const AllocFnInfo\
  \ AllocFns[] = {\n    {\"kmalloc\", 0, \"kcalloc() or kmalloc_array()\"},\n    {\"\
  kzalloc\", 0, \"kcalloc()\"},\n    {\"__kmalloc\", 0, \"kcalloc() or kmalloc_array()\"\
  },\n    {\"kvmalloc\", 0, \"kcalloc() or kmalloc_array()\"},\n    {\"kvzalloc\"\
  , 0, \"kcalloc()\"},\n    {\"devm_kmalloc\", 1, \"devm_kcalloc() or kmalloc_array()\"\
  },\n    {\"devm_kzalloc\", 1, \"devm_kcalloc()\"},\n};\n\n// Helper: strip parentheses\
  \ and implicit casts\nstatic const Expr *strip(const Expr *E) {\n  return E ? E->IgnoreParenImpCasts()\
  \ : nullptr;\n}\n\n// Helper: recursively flatten a multiplication expression into\
  \ factors.\nstatic void flattenMulFactors(const Expr *E, llvm::SmallVector<const\
  \ Expr *, 8> &Out) {\n  E = strip(E);\n  if (!E) {\n    return;\n  }\n  if (const\
  \ auto *BO = dyn_cast<BinaryOperator>(E)) {\n    if (BO->getOpcode() == BO_Mul)\
  \ {\n      flattenMulFactors(BO->getLHS(), Out);\n      flattenMulFactors(BO->getRHS(),\
  \ Out);\n      return;\n    }\n  }\n  Out.push_back(E);\n}\n\n// Helper: check if\
  \ any factor is a sizeof(...) expression.\nstatic bool hasSizeofFactor(llvm::ArrayRef<const\
  \ Expr *> Factors) {\n  for (const Expr *F : Factors) {\n    if (const auto *UETT\
  \ = dyn_cast<UnaryExprOrTypeTraitExpr>(strip(F))) {\n      if (UETT->getKind() ==\
  \ UETT_SizeOf)\n        return true;\n    }\n  }\n  return false;\n}\n\n// Helper:\
  \ suppress known safe macros that already perform checked sizing.\nstatic bool containsSafeMacro(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E)\n    return false;\n\n  // Conservatively\
  \ suppress some well-known safe helpers/macros.\n  if (ExprHasName(E, \"struct_size\"\
  , C))\n    return true;\n  if (ExprHasName(E, \"array_size\", C))\n    return true;\n\
  \  if (ExprHasName(E, \"size_mul\", C))\n    return true;\n\n  return false;\n}\n\
  \n// Determine if the expression is a manual array size computation like sizeof(T)\
  \ * n.\nstatic bool isManualArraySizeExpr(const Expr *E, CheckerContext &C) {\n\
  \  E = strip(E);\n  if (!E)\n    return false;\n\n  if (containsSafeMacro(E, C))\n\
  \    return false;\n\n  const auto *BO = dyn_cast<BinaryOperator>(E);\n  if (!BO\
  \ || BO->getOpcode() != BO_Mul)\n    return false;\n\n  llvm::SmallVector<const\
  \ Expr *, 8> Factors;\n  flattenMulFactors(E, Factors);\n  if (Factors.size() <\
  \ 2)\n    return false;\n\n  if (!hasSizeofFactor(Factors))\n    return false;\n\
  \n  return true;\n}\n\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Array allocation\
  \ via kmalloc/kzalloc may overflow\", \"Memory\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n      // No additional\
  \ stateful helpers needed.\n};\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return;\n\n  // Identify if this call is one of the tracked\
  \ allocation APIs using ExprHasName.\n  const AllocFnInfo *Matched = nullptr;\n\
  \  for (const auto &Info : AllocFns) {\n    if (ExprHasName(Origin, Info.Name, C))\
  \ {\n      Matched = &Info;\n      break;\n    }\n  }\n  if (!Matched)\n    return;\n\
  \n  if (Call.getNumArgs() <= Matched->SizeIndex)\n    return;\n\n  const Expr *SizeArg\
  \ = Call.getArgExpr(Matched->SizeIndex);\n  if (!SizeArg)\n    return;\n\n  if (!isManualArraySizeExpr(SizeArg,\
  \ C))\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  std::string Msg = std::string(\"Use \") + Matched->Recommendation\
  \ +\n                    \" for array allocations; manual size multiplication can\
  \ overflow\";\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n\
  \  R->addRange(SizeArg->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n\
  } // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect manual sizeof(...) * count in kmalloc/kzalloc and suggest kcalloc/kmalloc_array\
  \ to avoid overflow\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\namdkfd: use calloc instead of kzalloc to avoid integer\
  \ overflow\n\nThis uses calloc instead of doing the multiplication which might\n\
  overflow.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: kfd_ioctl_get_process_apertures_new in drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\t\t\t\tstruct\
  \ kfd_process *p, void *data)\n{\n\tstruct kfd_ioctl_get_process_apertures_new_args\
  \ *args = data;\n\tstruct kfd_process_device_apertures *pa;\n\tint ret;\n\tint i;\n\
  \n\tdev_dbg(kfd_device, \"get apertures for PASID 0x%x\", p->pasid);\n\n\tif (args->num_of_nodes\
  \ == 0) {\n\t\t/* Return number of nodes, so that user space can alloacate\n\t\t\
  \ * sufficient memory\n\t\t */\n\t\tmutex_lock(&p->mutex);\n\t\targs->num_of_nodes\
  \ = p->n_pdds;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Fill in process-aperture information\
  \ for all available\n\t * nodes, but not more than args->num_of_nodes as that is\n\
  \t * the amount of memory allocated by user\n\t */\n\tpa = kzalloc((sizeof(struct\
  \ kfd_process_device_apertures) *\n\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n\t\
  if (!pa)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&p->mutex);\n\n\tif (!p->n_pdds) {\n\
  \t\targs->num_of_nodes = 0;\n\t\tkfree(pa);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Run\
  \ over all pdd of the process */\n\tfor (i = 0; i < min(p->n_pdds, args->num_of_nodes);\
  \ i++) {\n\t\tstruct kfd_process_device *pdd = p->pdds[i];\n\n\t\tpa[i].gpu_id =\
  \ pdd->dev->id;\n\t\tpa[i].lds_base = pdd->lds_base;\n\t\tpa[i].lds_limit = pdd->lds_limit;\n\
  \t\tpa[i].gpuvm_base = pdd->gpuvm_base;\n\t\tpa[i].gpuvm_limit = pdd->gpuvm_limit;\n\
  \t\tpa[i].scratch_base = pdd->scratch_base;\n\t\tpa[i].scratch_limit = pdd->scratch_limit;\n\
  \n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpu id %u\\n\", pdd->dev->id);\n\t\tdev_dbg(kfd_device,\n\
  \t\t\t\"lds_base %llX\\n\", pdd->lds_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"lds_limit\
  \ %llX\\n\", pdd->lds_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_base %llX\\\
  n\", pdd->gpuvm_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_limit %llX\\n\",\
  \ pdd->gpuvm_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_base %llX\\n\", pdd->scratch_base);\n\
  \t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_limit %llX\\n\", pdd->scratch_limit);\n\
  \t}\n\tmutex_unlock(&p->mutex);\n\n\targs->num_of_nodes = i;\n\tret = copy_to_user(\n\
  \t\t\t(void __user *)args->kfd_process_device_apertures_ptr,\n\t\t\tpa,\n\t\t\t\
  (i * sizeof(struct kfd_process_device_apertures)));\n\tkfree(pa);\n\treturn ret\
  \ ? -EFAULT : 0;\n\nout_unlock:\n\tmutex_unlock(&p->mutex);\n\treturn 0;\n}\n```\n\
  \n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\
  \ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\nindex f9631f4b1a02..55aa74cbc532 100644\n\
  --- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  @@ -779,8 +779,8 @@ static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\
  \ \t * nodes, but not more than args->num_of_nodes as that is\n \t * the amount\
  \ of memory allocated by user\n \t */\n-\tpa = kzalloc((sizeof(struct kfd_process_device_apertures)\
  \ *\n-\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n+\tpa = kcalloc(args->num_of_nodes,\
  \ sizeof(struct kfd_process_device_apertures),\n+\t\t     GFP_KERNEL);\n \tif (!pa)\n\
  \ \t\treturn -ENOMEM;\n \n```\n"
pattern: '## Bug Pattern


  Allocating an array with kmalloc/kzalloc by manually multiplying element size and
  count, e.g.:


  pa = kzalloc(sizeof(struct elem) * n, GFP_KERNEL);


  This manual size calculation can overflow (especially when n is user-controlled),
  resulting in an undersized allocation and potential out-of-bounds writes. The correct
  pattern is to use kcalloc(n, sizeof(struct elem), GFP_KERNEL), which performs overflow-checked
  multiplication.'
plan: "1) Program state\n- No custom program state is necessary. This is a syntactic/semantic\
  \ pattern check on call arguments. We only need to inspect function calls and the\
  \ size argument\u2019s AST.\n\n2) Callbacks to use\n- checkPreCall: Inspect calls\
  \ to allocation APIs and analyze the size argument to detect manual size multiplications.\n\
  - (No other callbacks are required.)\n\n3) Detailed implementation steps\n\nA. Define\
  \ a small, static table of allocation APIs to check\n- Create a table mapping function\
  \ names to:\n  - The index of the size argument.\n  - The recommended alternative\
  \ function name (for a succinct diagnostic).\n- Suggested entries:\n  - {\"kmalloc\"\
  , 0, \"kcalloc or kmalloc_array\"}\n  - {\"kzalloc\", 0, \"kcalloc\"}\n  - {\"__kmalloc\"\
  , 0, \"kcalloc or kmalloc_array\"}\n  - {\"kvmalloc\", 0, \"kcalloc or kmalloc_array\"\
  }\n  - {\"kvzalloc\", 0, \"kcalloc\"}\n  - {\"devm_kmalloc\", 1, \"devm_kcalloc\
  \ or kmalloc_array\"}\n  - {\"devm_kzalloc\", 1, \"devm_kcalloc\"}\n  - Optionally\
  \ add others where the \u201Csize\u201D parameter is first or known (e.g., dma_alloc_coherent\
  \ is not relevant here).\n\nB. Helper routines (local to the checker)\n- strip(E):\
  \ return E->IgnoreParenImpCasts().\n- flattenMulFactors(E, OutVec):\n  - Recursively\
  \ flatten a multiplicative expression: if E is a BinaryOperator with opcode BO_Mul,\
  \ call flattenMulFactors on LHS and RHS; otherwise push_back(E).\n- hasSizeofFactor(Factors):\n\
  \  - Return true if any factor is a UnaryExprOrTypeTraitExpr with UETT_SizeOf.\n\
  - containsSafeMacro(E, C):\n  - Use ExprHasName(E, \"struct_size\", C) or ExprHasName(E,\
  \ \"array_size\", C) or ExprHasName(E, \"size_mul\", C) to optionally suppress well-known\
  \ overflow-guarded macro patterns. Keep this small and conservative.\n- isManualArraySizeExpr(E,\
  \ C):\n  - E = strip(E).\n  - If E is not a BinaryOperator(BO_Mul) (after stripping),\
  \ return false.\n  - Build a vector<const Expr*> Factors via flattenMulFactors(E).\n\
  \  - If hasSizeofFactor(Factors) and Factors.size() >= 2, return true; else false.\n\
  \  - Optionally: if containsSafeMacro(E, C) return false (suppression).\n\nC. checkPreCall\
  \ implementation\n- Extract callee identifier: if no identifier, return.\n- Look\
  \ up in the allocation table. If not found, return.\n- Retrieve the size argument\
  \ expression via the recorded index.\n- If isManualArraySizeExpr(SizeArg, C) is\
  \ true:\n  - Prepare a short diagnostic message. Use the table\u2019s recommended\
  \ alternative:\n    - Example: For kzalloc/kmalloc variants: \"Use kcalloc() for\
  \ array allocation; multiplication may overflow\"\n    - For devm_kmalloc/kzalloc:\
  \ \"Use devm_kcalloc() for array allocation; multiplication may overflow\"\n   \
  \ - You can also mention \u201Cor kmalloc_array()\u201D when appropriate.\n  - Create\
  \ a non-fatal error node and emit a BasicBugReport or PathSensitiveBugReport:\n\
  \    - BugType: \"Array allocation via kmalloc/kzalloc may overflow\"\n    - Message\
  \ (short and clear): \"Use kcalloc() for array allocations; manual size multiplication\
  \ can overflow\"\n    - Add the size argument source range to the report.\n- Do\
  \ nothing if not matched or suppressed.\n\nD. Notes and rationale\n- We warn whenever\
  \ the size parameter is formed by multiplying sizeof(...) with a count expression.\
  \ This directly captures the unsafe idiom pa = kzalloc(sizeof(struct elem) * n,\
  \ GFP_KERNEL).\n- We intentionally avoid complex flow analysis (no program state).\
  \ This keeps the checker simple and robust.\n- Minimal suppression is included to\
  \ reduce noise for common safe macros (struct_size/array_size/size_mul). Keep the\
  \ suppression conservative and string-based via ExprHasName.\n\n4) Reporting\n-\
  \ Use generateNonFatalErrorNode and emit a concise report via:\n  - std::make_unique<BasicBugReport>(BugType,\
  \ Message, Location)\n  - Or PathSensitiveBugReport if you prefer path integration.\n\
  - Example messages:\n  - \"Use kcalloc() for array allocations; manual size multiplication\
  \ can overflow\"\n  - For devm_*: \"Use devm_kcalloc() for array allocations; manual\
  \ size multiplication can overflow\"\n\n5) Summary of the minimal checker flow\n\
  - In checkPreCall:\n  - If callee in {kmalloc, kzalloc, kvmalloc, kvzalloc, __kmalloc,\
  \ devm_kmalloc, devm_kzalloc}\n  - Identify the size parameter by index.\n  - If\
  \ it is a multiplication chain containing sizeof(...), and not within a known safe\
  \ macro:\n    - Report the issue, recommending kcalloc (or devm_kcalloc / kmalloc_array)."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include\
  \ \"clang/Lex/Lexer.h\"\n#include <string>\n#include <vector>\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states are necessary.\n\nnamespace {\n\nstruct AllocFnInfo {\n  const char *Name;\n\
  \  unsigned SizeIndex;\n  const char *Recommendation;\n};\n\nstatic const AllocFnInfo\
  \ AllocFns[] = {\n    {\"kmalloc\", 0, \"kcalloc() or kmalloc_array()\"},\n    {\"\
  kzalloc\", 0, \"kcalloc()\"},\n    {\"__kmalloc\", 0, \"kcalloc() or kmalloc_array()\"\
  },\n    {\"kvmalloc\", 0, \"kcalloc() or kmalloc_array()\"},\n    {\"kvzalloc\"\
  , 0, \"kcalloc()\"},\n    {\"devm_kmalloc\", 1, \"devm_kcalloc() or kmalloc_array()\"\
  },\n    {\"devm_kzalloc\", 1, \"devm_kcalloc()\"},\n};\n\n// Helper: strip parentheses\
  \ and implicit casts\nstatic const Expr *strip(const Expr *E) {\n  return E ? E->IgnoreParenImpCasts()\
  \ : nullptr;\n}\n\n// Helper: recursively flatten a multiplication expression into\
  \ factors.\nstatic void flattenMulFactors(const Expr *E, llvm::SmallVector<const\
  \ Expr *, 8> &Out) {\n  E = strip(E);\n  if (!E) {\n    return;\n  }\n  if (const\
  \ auto *BO = dyn_cast<BinaryOperator>(E)) {\n    if (BO->getOpcode() == BO_Mul)\
  \ {\n      flattenMulFactors(BO->getLHS(), Out);\n      flattenMulFactors(BO->getRHS(),\
  \ Out);\n      return;\n    }\n  }\n  Out.push_back(E);\n}\n\n// Helper: check if\
  \ any factor is a sizeof(...) expression.\nstatic bool hasSizeofFactor(llvm::ArrayRef<const\
  \ Expr *> Factors) {\n  for (const Expr *F : Factors) {\n    if (const auto *UETT\
  \ = dyn_cast<UnaryExprOrTypeTraitExpr>(strip(F))) {\n      if (UETT->getKind() ==\
  \ UETT_SizeOf)\n        return true;\n    }\n  }\n  return false;\n}\n\n// Helper:\
  \ suppress known safe macros that already perform checked sizing.\nstatic bool containsSafeMacro(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E)\n    return false;\n\n  // Conservatively\
  \ suppress some well-known safe helpers/macros.\n  if (ExprHasName(E, \"struct_size\"\
  , C))\n    return true;\n  if (ExprHasName(E, \"array_size\", C))\n    return true;\n\
  \  if (ExprHasName(E, \"size_mul\", C))\n    return true;\n\n  return false;\n}\n\
  \n// Determine if the expression is a manual array size computation like sizeof(T)\
  \ * n.\nstatic bool isManualArraySizeExpr(const Expr *E, CheckerContext &C) {\n\
  \  E = strip(E);\n  if (!E)\n    return false;\n\n  if (containsSafeMacro(E, C))\n\
  \    return false;\n\n  const auto *BO = dyn_cast<BinaryOperator>(E);\n  if (!BO\
  \ || BO->getOpcode() != BO_Mul)\n    return false;\n\n  llvm::SmallVector<const\
  \ Expr *, 8> Factors;\n  flattenMulFactors(E, Factors);\n  if (Factors.size() <\
  \ 2)\n    return false;\n\n  if (!hasSizeofFactor(Factors))\n    return false;\n\
  \n  return true;\n}\n\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\
  \ : public Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n\
  \   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Array allocation\
  \ via kmalloc/kzalloc may overflow\", \"Memory\")) {}\n\n      void checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n\n   private:\n      // No additional\
  \ stateful helpers needed.\n};\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return;\n\n  // Identify if this call is one of the tracked\
  \ allocation APIs using ExprHasName.\n  const AllocFnInfo *Matched = nullptr;\n\
  \  for (const auto &Info : AllocFns) {\n    if (ExprHasName(Origin, Info.Name, C))\
  \ {\n      Matched = &Info;\n      break;\n    }\n  }\n  if (!Matched)\n    return;\n\
  \n  if (Call.getNumArgs() <= Matched->SizeIndex)\n    return;\n\n  const Expr *SizeArg\
  \ = Call.getArgExpr(Matched->SizeIndex);\n  if (!SizeArg)\n    return;\n\n  if (!isManualArraySizeExpr(SizeArg,\
  \ C))\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  std::string Msg = std::string(\"Use \") + Matched->Recommendation\
  \ +\n                    \" for array allocations; manual size multiplication can\
  \ overflow\";\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n\
  \  R->addRange(SizeArg->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n\
  } // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect manual sizeof(...) * count in kmalloc/kzalloc and suggest kcalloc/kmalloc_array\
  \ to avoid overflow\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
