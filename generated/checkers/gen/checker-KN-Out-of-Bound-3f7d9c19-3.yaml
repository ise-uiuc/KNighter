_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3f7d9c1964fcd16d02a8a9d4fd6f6cb60c4cc530
commit_type: Out-of-Bound
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"llvm/ADT/SmallVector.h\"\
  \n#include \"llvm/ADT/StringRef.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(UntrustedLenMap, const\
  \ MemRegion*, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*,\
  \ const MemRegion*)\n\nnamespace {\nclass SAGenTestChecker\n  : public Checker<\n\
  \      check::Bind,\n      check::PreCall,\n      check::BranchCondition\n    >\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unvalidated RSS length\", \"Memory Safety\")) {}\n\n\
  \      void checkBind(SVal Loc, SVal Val, const Stmt *StoreE, CheckerContext &C)\
  \ const;\n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \n   private:\n      // Helpers\n      static const Expr* getRHSOfStore(const Stmt\
  \ *S);\n      static const CallExpr* getAnyCallInStmt(const Stmt *S);\n      static\
  \ bool isVirtioCreadRssMaxKey(const CallExpr *CE, CheckerContext &C);\n      static\
  \ bool isMinOrClampWithMax(const CallExpr *CE, CheckerContext &C);\n      static\
  \ bool isLenAPICall(const Expr *Origin, StringRef &NameOut, unsigned &LenIdx, unsigned\
  \ ArgCount);\n      static bool isLenAPICandidate(const Expr *Origin, StringRef\
  \ &NameOut, unsigned &LenIdx);\n\n      static ProgramStateRef markChecked(ProgramStateRef\
  \ State, const MemRegion *R);\n      static ProgramStateRef copyStatusAndAlias(ProgramStateRef\
  \ State,\n                                                const MemRegion *DstR,\n\
  \                                                const MemRegion *SrcR);\n     \
  \ static const MemRegion* getBaseRegionFromExpr(const Expr *E, CheckerContext &C);\n\
  \n      static void collectTrackedRegionsInExpr(const Expr *E, CheckerContext &C,\n\
  \                                              ProgramStateRef State,\n        \
  \                                      llvm::SmallVectorImpl<const MemRegion*> &Out);\n\
  \      void reportUnvalidatedUse(const CallEvent &Call, const Expr *ArgE, CheckerContext\
  \ &C) const;\n};\n\nconst Expr* SAGenTestChecker::getRHSOfStore(const Stmt *S) {\n\
  \  if (!S) return nullptr;\n  if (const auto *BO = dyn_cast<BinaryOperator>(S))\
  \ {\n    if (BO->isAssignmentOp())\n      return BO->getRHS();\n  }\n  if (const\
  \ auto *DS = dyn_cast<DeclStmt>(S)) {\n    for (const auto *D : DS->decls()) {\n\
  \      if (const auto *VD = dyn_cast<VarDecl>(D)) {\n        if (const Expr *Init\
  \ = VD->getInit())\n          return Init;\n      }\n    }\n  }\n  // Fallback:\
  \ try to find any expression child\n  if (const auto *E = dyn_cast<Expr>(S))\n \
  \   return E;\n  return nullptr;\n}\n\nconst CallExpr* SAGenTestChecker::getAnyCallInStmt(const\
  \ Stmt *S) {\n  if (!S) return nullptr;\n  return findSpecificTypeInChildren<const\
  \ CallExpr>(S);\n}\n\nbool SAGenTestChecker::isVirtioCreadRssMaxKey(const CallExpr\
  \ *CE, CheckerContext &C) {\n  if (!CE) return false;\n  const Expr *O = CE;\n \
  \ // Match virtio_cread8/16/32 and the field rss_max_key_size in args.\n  if (!(ExprHasName(O,\
  \ \"virtio_cread8\", C) ||\n        ExprHasName(O, \"virtio_cread16\", C) ||\n \
  \       ExprHasName(O, \"virtio_cread32\", C) ||\n        ExprHasName(O, \"virtio_cread_bytes\"\
  , C)))\n    return false;\n\n  if (!ExprHasName(O, \"rss_max_key_size\", C))\n \
  \   return false;\n\n  return true;\n}\n\nbool SAGenTestChecker::isMinOrClampWithMax(const\
  \ CallExpr *CE, CheckerContext &C) {\n  if (!CE) return false;\n  const Expr *O\
  \ = CE;\n  if (!(ExprHasName(O, \"min\", C) ||\n        ExprHasName(O, \"min_t\"\
  , C) ||\n        ExprHasName(O, \"clamp\", C) ||\n        ExprHasName(O, \"clamp_t\"\
  , C)))\n    return false;\n\n  // Must involve the maximum macro in any arg.\n \
  \ for (const Expr *Arg : CE->arguments()) {\n    if (ExprHasName(Arg, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C))\n      return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isLenAPICall(const\
  \ Expr *Origin, StringRef &NameOut, unsigned &LenIdx, unsigned ArgCount) {\n  if\
  \ (!Origin) return false;\n\n  // Length index for typical C memory functions: last\
  \ parameter index = 2 for 3-arg functions.\n  struct Entry { const char *Name; unsigned\
  \ LenIndex; unsigned MinArgs; };\n  static const Entry Table[] = {\n    {\"sg_init_one\"\
  , 2, 3},\n    {\"sg_set_buf\",  2, 3},\n    {\"memcpy\",      2, 3},\n    {\"memmove\"\
  ,     2, 3},\n    {\"memset\",      2, 3},\n    {\"memcpy_toio\", 2, 3},\n    {\"\
  memcpy_fromio\", 2, 3},\n    {\"strncpy\",     2, 3},\n    {\"strscpy\",     2,\
  \ 3},\n  };\n\n  for (const auto &E : Table) {\n    if (ExprHasName(Origin, E.Name,\
  \ *(const CheckerContext*)nullptr)) {\n      // We cannot use CheckerContext here.\
  \ The caller should verify with real Ctx if needed.\n      (void)ArgCount; // origin\
  \ check only\n    }\n  }\n  // Since ExprHasName requires a CheckerContext, we move\
  \ matching into isLenAPICandidate.\n  return false;\n}\n\nbool SAGenTestChecker::isLenAPICandidate(const\
  \ Expr *Origin, StringRef &NameOut, unsigned &LenIdx) {\n  if (!Origin) return false;\n\
  \  struct Entry { const char *Name; unsigned LenIndex; };\n  static const Entry\
  \ Table[] = {\n    {\"sg_init_one\", 2},\n    {\"sg_set_buf\",  2},\n    {\"memcpy\"\
  ,      2},\n    {\"memmove\",     2},\n    {\"memset\",      2},\n    {\"memcpy_toio\"\
  , 2},\n    {\"memcpy_fromio\", 2},\n    {\"strncpy\",     2},\n    {\"strscpy\"\
  ,     2},\n  };\n\n  for (const auto &E : Table) {\n    if (ExprHasName(Origin,\
  \ E.Name, *(const CheckerContext*)nullptr)) {\n      // This path won't work; provide\
  \ a version using CheckerContext directly.\n      (void)E;\n    }\n  }\n  // Proper\
  \ implementation with CheckerContext is below in checkPreCall directly.\n  return\
  \ false;\n}\n\nProgramStateRef SAGenTestChecker::markChecked(ProgramStateRef State,\
  \ const MemRegion *R) {\n  if (!R) return State;\n  const MemRegion *Base = R->getBaseRegion();\n\
  \  if (!Base) return State;\n\n  const bool *Tracked = State->get<UntrustedLenMap>(Base);\n\
  \  if (Tracked && *Tracked == false) {\n    State = State->set<UntrustedLenMap>(Base,\
  \ true);\n  }\n\n  // If we have an alias, mark it checked too.\n  if (const MemRegion\
  \ *Alias = State->get<PtrAliasMap>(Base)) {\n    const bool *AliasTracked = State->get<UntrustedLenMap>(Alias);\n\
  \    if (AliasTracked && *AliasTracked == false) {\n      State = State->set<UntrustedLenMap>(Alias,\
  \ true);\n    }\n  }\n  return State;\n}\n\nProgramStateRef SAGenTestChecker::copyStatusAndAlias(ProgramStateRef\
  \ State,\n                                                     const MemRegion *DstR,\n\
  \                                                     const MemRegion *SrcR) {\n\
  \  if (!DstR || !SrcR) return State;\n  DstR = DstR->getBaseRegion();\n  SrcR =\
  \ SrcR->getBaseRegion();\n  if (!DstR || !SrcR) return State;\n\n  // Copy status\
  \ if any\n  if (const bool *Tracked = State->get<UntrustedLenMap>(SrcR)) {\n   \
  \ State = State->set<UntrustedLenMap>(DstR, *Tracked);\n  }\n  // Record alias both\
  \ ways\n  State = State->set<PtrAliasMap>(DstR, SrcR);\n  State = State->set<PtrAliasMap>(SrcR,\
  \ DstR);\n\n  return State;\n}\n\nconst MemRegion* SAGenTestChecker::getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return nullptr;\n  const MemRegion *MR\
  \ = getMemRegionFromExpr(E, C);\n  if (!MR) return nullptr;\n  return MR->getBaseRegion();\n\
  }\n\nvoid SAGenTestChecker::collectTrackedRegionsInExpr(const Expr *E, CheckerContext\
  \ &C,\n                                                   ProgramStateRef State,\n\
  \                                                   llvm::SmallVectorImpl<const\
  \ MemRegion*> &Out) {\n  if (!E) return;\n  // Try current node\n  if (const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C)) {\n    MR = MR->getBaseRegion();\n    if (MR)\
  \ {\n      if (const bool *Tracked = State->get<UntrustedLenMap>(MR)) {\n      \
  \  if (*Tracked == false) {\n          Out.push_back(MR);\n        }\n      }\n\
  \    }\n  }\n  // Recurse into children\n  for (const Stmt *Child : E->children())\
  \ {\n    if (const auto *CE = dyn_cast_or_null<Expr>(Child)) {\n      collectTrackedRegionsInExpr(CE,\
  \ C, State, Out);\n    }\n  }\n}\n\nvoid SAGenTestChecker::reportUnvalidatedUse(const\
  \ CallEvent &Call, const Expr *ArgE, CheckerContext &C) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Unvalidated device length used for buffer size (RSS key)\", N);\n\
  \  if (ArgE)\n    R->addRange(ArgE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *StoreE, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *DstR\
  \ = Loc.getAsRegion();\n  if (!DstR) return;\n  DstR = DstR->getBaseRegion();\n\
  \  if (!DstR) return;\n\n  bool StateChanged = false;\n  const Expr *RHS = getRHSOfStore(StoreE);\n\
  \n  // 1) Detect assignment from virtio_cread* reading rss_max_key_size\n  if (const\
  \ CallExpr *CE = getAnyCallInStmt(StoreE)) {\n    if (isVirtioCreadRssMaxKey(CE,\
  \ C)) {\n      // Mark destination as untrusted/unchecked.\n      State = State->set<UntrustedLenMap>(DstR,\
  \ false);\n      StateChanged = true;\n      // Clear any previous alias pointing\
  \ somewhere irrelevant\n      // We don't remove here; keep simple.\n    } else\
  \ if (isMinOrClampWithMax(CE, C)) {\n      // If this is min/clamp involving the\
  \ macro, and one operand is tracked,\n      // mark DstR as checked.\n      // Check\
  \ if any arg is tracked\n      bool TrackedOperand = false;\n      for (const Expr\
  \ *Arg : CE->arguments()) {\n        const MemRegion *OpR = getBaseRegionFromExpr(Arg,\
  \ C);\n        if (!OpR) continue;\n        if (const bool *Tracked = State->get<UntrustedLenMap>(OpR))\
  \ {\n          if (*Tracked == false) {\n            TrackedOperand = true;\n  \
  \          break;\n          }\n        }\n      }\n      if (TrackedOperand) {\n\
  \        State = State->set<UntrustedLenMap>(DstR, true);\n        StateChanged\
  \ = true;\n      }\n    }\n  }\n\n  // 2) Alias/status propagation for simple copies\
  \ (len = vi->rss_key_size;)\n  if (RHS && !StateChanged) {\n    if (const MemRegion\
  \ *SrcR = getBaseRegionFromExpr(RHS, C)) {\n      const bool *Tracked = State->get<UntrustedLenMap>(SrcR);\n\
  \      if (Tracked) {\n        State = copyStatusAndAlias(State, DstR, SrcR);\n\
  \        StateChanged = true;\n      }\n    }\n  }\n\n  // 3) Overwrite handling:\
  \ if DstR was tracked but RHS isn't from device or alias,\n  //    then remove DstR\
  \ from tracking.\n  if (!StateChanged) {\n    if (const bool *WasTracked = State->get<UntrustedLenMap>(DstR))\
  \ {\n      (void)WasTracked;\n      // Remove from UntrustedLenMap and alias map\n\
  \      if (const MemRegion *Alias = State->get<PtrAliasMap>(DstR)) {\n        State\
  \ = State->remove<PtrAliasMap>(Alias);\n      }\n      State = State->remove<PtrAliasMap>(DstR);\n\
  \      State = State->remove<UntrustedLenMap>(DstR);\n      StateChanged = true;\n\
  \    }\n  }\n\n  if (StateChanged)\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE) {\n   \
  \ C.addTransition(State);\n    return;\n  }\n\n  // Only care when the condition\
  \ involves the macro VIRTIO_NET_RSS_MAX_KEY_SIZE\n  if (!ExprHasName(CondE, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C)) {\n    C.addTransition(State);\n    return;\n  }\n\n  // Collect tracked regions\
  \ referenced in this condition and mark them checked.\n  llvm::SmallVector<const\
  \ MemRegion*, 4> Regions;\n  collectTrackedRegionsInExpr(CondE, C, State, Regions);\n\
  \n  bool Changed = false;\n  for (const MemRegion *R : Regions) {\n    ProgramStateRef\
  \ NewState = markChecked(State, R);\n    if (NewState != State) {\n      State =\
  \ NewState;\n      Changed = true;\n    }\n  }\n\n  if (Changed)\n    C.addTransition(State);\n\
  \  else\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return;\n\n  // Identify candidate functions and their 'length'\
  \ argument index.\n  // Use ExprHasName for robustness as suggested.\n  unsigned\
  \ LenIdx = UINT_MAX;\n  if (ExprHasName(Origin, \"sg_init_one\", C)) {\n    if (Call.getNumArgs()\
  \ >= 3) LenIdx = 2;\n  } else if (ExprHasName(Origin, \"sg_set_buf\", C)) {\n  \
  \  if (Call.getNumArgs() >= 3) LenIdx = 2;\n  } else if (ExprHasName(Origin, \"\
  memcpy\", C) ||\n             ExprHasName(Origin, \"memmove\", C) ||\n         \
  \    ExprHasName(Origin, \"memset\", C) ||\n             ExprHasName(Origin, \"\
  memcpy_toio\", C) ||\n             ExprHasName(Origin, \"memcpy_fromio\", C) ||\n\
  \             ExprHasName(Origin, \"strncpy\", C) ||\n             ExprHasName(Origin,\
  \ \"strscpy\", C)) {\n    if (Call.getNumArgs() >= 3) LenIdx = 2;\n  } else {\n\
  \    return;\n  }\n\n  if (LenIdx == UINT_MAX || LenIdx >= Call.getNumArgs())\n\
  \    return;\n\n  const Expr *ArgE = Call.getArgExpr(LenIdx);\n  if (!ArgE)\n  \
  \  return;\n\n  ProgramStateRef State = C.getState();\n\n  // First, check by region\n\
  \  const MemRegion *LenR = getBaseRegionFromExpr(ArgE, C);\n  if (LenR) {\n    if\
  \ (const bool *Tracked = State->get<UntrustedLenMap>(LenR)) {\n      if (*Tracked\
  \ == false) {\n        reportUnvalidatedUse(Call, ArgE, C);\n        return;\n \
  \     }\n    }\n    // Alias fallback\n    if (const MemRegion *Alias = State->get<PtrAliasMap>(LenR))\
  \ {\n      if (const bool *AliasTracked = State->get<UntrustedLenMap>(Alias)) {\n\
  \        if (*AliasTracked == false) {\n          reportUnvalidatedUse(Call, ArgE,\
  \ C);\n          return;\n        }\n      }\n    }\n  }\n\n  // Textual fallback:\
  \ if the expression contains rss_key_size, but we don't\n  // have region info,\
  \ do not report unless we are certain; per suggestion,\n  // avoid reporting if\
  \ unsure. So we skip here.\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects use of unvalidated device-provided\
  \ RSS length for buffer sizing\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nvirtio_net: Add hash_key_length check\n\nAdd hash_key_length\
  \ check in virtnet_probe() to avoid possible out of\nbound errors when setting/reading\
  \ the hash key.\n\nFixes: c7114b1249fa (\"drivers/net/virtio_net: Added basic RSS\
  \ support.\")\nSigned-off-by: Philo Lu <lulie@linux.alibaba.com>\nSigned-off-by:\
  \ Xuan Zhuo <xuanzhuo@linux.alibaba.com>\nAcked-by: Joe Damato <jdamato@fastly.com>\n\
  Acked-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: virtnet_probe in drivers/net/virtio_net.c\n\
  static int virtnet_probe(struct virtio_device *vdev)\n{\n\tint i, err = -ENOMEM;\n\
  \tstruct net_device *dev;\n\tstruct virtnet_info *vi;\n\tu16 max_queue_pairs;\n\t\
  int mtu = 0;\n\n\t/* Find if host supports multiqueue/rss virtio_net device */\n\
  \tmax_queue_pairs = 1;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MQ) || virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_RSS))\n\t\tmax_queue_pairs =\n\t\t     virtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config, max_virtqueue_pairs));\n\n\t/* We need at least 2 queue's */\n\
  \tif (max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||\n\t    max_queue_pairs\
  \ > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||\n\t    !virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\
  \t\tmax_queue_pairs = 1;\n\n\t/* Allocate ourselves a network device with room for\
  \ our info */\n\tdev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);\n\
  \tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* Set up network device as normal. */\n\t\
  dev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE |\n\t\t\t   IFF_TX_SKB_NO_LINEAR;\n\
  \tdev->netdev_ops = &virtnet_netdev;\n\tdev->stat_ops = &virtnet_stat_ops;\n\tdev->features\
  \ = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev,\
  \ &vdev->dev);\n\n\t/* Do we support \"hardware\" checksums? */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_CSUM)) {\n\t\t/* This opens up the world of extra features. */\n\t\
  \tdev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\t\tif (csum)\n\t\t\tdev->features\
  \ |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO))\
  \ {\n\t\t\tdev->hw_features |= NETIF_F_TSO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\
  \t\t}\n\t\t/* Individual feature bits: what can host handle? */\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_ECN))\n\t\t\tdev->hw_features |= NETIF_F_TSO_ECN;\n\t\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_HOST_USO))\n\t\t\tdev->hw_features |= NETIF_F_GSO_UDP_L4;\n\n\t\t\
  dev->features |= NETIF_F_GSO_ROBUST;\n\n\t\tif (gso)\n\t\t\tdev->features |= dev->hw_features\
  \ & NETIF_F_ALL_TSO;\n\t\t/* (!csum && gso) case will be fixed by register_netdev()\
  \ */\n\t}\n\n\t/* 1. With VIRTIO_NET_F_GUEST_CSUM negotiation, the driver doesn't\n\
  \t * need to calculate checksums for partially checksummed packets,\n\t * as they're\
  \ considered valid by the upper layer.\n\t * 2. Without VIRTIO_NET_F_GUEST_CSUM\
  \ negotiation, the driver only\n\t * receives fully checksummed packets. The device\
  \ may assist in\n\t * validating these packets' checksums, so the driver won't have\
  \ to.\n\t */\n\tdev->features |= NETIF_F_RXCSUM;\n\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_GUEST_TSO4) ||\n\t    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6))\n\
  \t\tdev->features |= NETIF_F_GRO_HW;\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS))\n\
  \t\tdev->hw_features |= NETIF_F_GRO_HW;\n\n\tdev->vlan_features = dev->features;\n\
  \tdev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT;\n\n\t/* MTU\
  \ range: 68 - 65535 */\n\tdev->min_mtu = MIN_MTU;\n\tdev->max_mtu = MAX_MTU;\n\n\
  \t/* Configuration may specify what MAC to use.  Otherwise random. */\n\tif (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MAC)) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tvirtio_cread_bytes(vdev,\n\
  \t\t\t\t   offsetof(struct virtio_net_config, mac),\n\t\t\t\t   addr, ETH_ALEN);\n\
  \t\teth_hw_addr_set(dev, addr);\n\t} else {\n\t\teth_hw_addr_random(dev);\n\t\t\
  dev_info(&vdev->dev, \"Assigned random MAC address %pM\\n\",\n\t\t\t dev->dev_addr);\n\
  \t}\n\n\t/* Set up our device-specific information */\n\tvi = netdev_priv(dev);\n\
  \tvi->dev = dev;\n\tvi->vdev = vdev;\n\tvdev->priv = vi;\n\n\tINIT_WORK(&vi->config_work,\
  \ virtnet_config_changed_work);\n\tINIT_WORK(&vi->rx_mode_work, virtnet_rx_mode_work);\n\
  \tspin_lock_init(&vi->refill_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))\
  \ {\n\t\tvi->mergeable_rx_bufs = true;\n\t\tdev->xdp_features |= NETDEV_XDP_ACT_RX_SG;\n\
  \t}\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HASH_REPORT))\n\t\tvi->has_rss_hash_report\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_RSS)) {\n\t\tvi->has_rss\
  \ = true;\n\n\t\tvi->rss_indir_table_size =\n\t\t\tvirtio_cread16(vdev, offsetof(struct\
  \ virtio_net_config,\n\t\t\t\trss_max_indirection_table_length));\n\t}\n\terr =\
  \ rss_indirection_table_alloc(&vi->rss, vi->rss_indir_table_size);\n\tif (err)\n\
  \t\tgoto free;\n\n\tif (vi->has_rss || vi->has_rss_hash_report) {\n\t\tvi->rss_key_size\
  \ =\n\t\t\tvirtio_cread8(vdev, offsetof(struct virtio_net_config, rss_max_key_size));\n\
  \n\t\tvi->rss_hash_types_supported =\n\t\t    virtio_cread32(vdev, offsetof(struct\
  \ virtio_net_config, supported_hash_types));\n\t\tvi->rss_hash_types_supported &=\n\
  \t\t\t\t~(VIRTIO_NET_RSS_HASH_TYPE_IP_EX |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_TCP_EX\
  \ |\n\t\t\t\t  VIRTIO_NET_RSS_HASH_TYPE_UDP_EX);\n\n\t\tdev->hw_features |= NETIF_F_RXHASH;\n\
  \t\tdev->xdp_metadata_ops = &virtnet_xdp_metadata_ops;\n\t}\n\n\tif (vi->has_rss_hash_report)\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_v1_hash);\n\telse if (virtio_has_feature(vdev,\
  \ VIRTIO_NET_F_MRG_RXBUF) ||\n\t\t virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\
  \t\tvi->hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\telse\n\t\tvi->hdr_len\
  \ = sizeof(struct virtio_net_hdr);\n\n\tif (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT)\
  \ ||\n\t    virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\tvi->any_header_sg\
  \ = true;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))\n\t\tvi->has_cvq\
  \ = true;\n\n\tmutex_init(&vi->cvq_lock);\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_MTU))\
  \ {\n\t\tmtu = virtio_cread16(vdev,\n\t\t\t\t     offsetof(struct virtio_net_config,\n\
  \t\t\t\t\t      mtu));\n\t\tif (mtu < dev->min_mtu) {\n\t\t\t/* Should never trigger:\
  \ MTU was previously validated\n\t\t\t * in virtnet_validate.\n\t\t\t */\n\t\t\t\
  dev_err(&vdev->dev,\n\t\t\t\t\"device MTU appears to have changed it is now %d <\
  \ %d\",\n\t\t\t\tmtu, dev->min_mtu);\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\
  \t}\n\n\t\tdev->mtu = mtu;\n\t\tdev->max_mtu = mtu;\n\t}\n\n\tvirtnet_set_big_packets(vi,\
  \ mtu);\n\n\tif (vi->any_header_sg)\n\t\tdev->needed_headroom = vi->hdr_len;\n\n\
  \t/* Enable multiqueue by default */\n\tif (num_online_cpus() >= max_queue_pairs)\n\
  \t\tvi->curr_queue_pairs = max_queue_pairs;\n\telse\n\t\tvi->curr_queue_pairs =\
  \ num_online_cpus();\n\tvi->max_queue_pairs = max_queue_pairs;\n\n\t/* Allocate/initialize\
  \ the rx/tx queues, and invoke find_vqs */\n\terr = init_vqs(vi);\n\tif (err)\n\t\
  \tgoto free;\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_NOTF_COAL)) {\n\t\
  \tvi->intr_coal_rx.max_usecs = 0;\n\t\tvi->intr_coal_tx.max_usecs = 0;\n\t\tvi->intr_coal_rx.max_packets\
  \ = 0;\n\n\t\t/* Keep the default values of the coalescing parameters\n\t\t * aligned\
  \ with the default napi_tx state.\n\t\t */\n\t\tif (vi->sq[0].napi.weight)\n\t\t\
  \tvi->intr_coal_tx.max_packets = 1;\n\t\telse\n\t\t\tvi->intr_coal_tx.max_packets\
  \ = 0;\n\t}\n\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_VQ_NOTF_COAL)) {\n\
  \t\t/* The reason is the same as VIRTIO_NET_F_NOTF_COAL. */\n\t\tfor (i = 0; i <\
  \ vi->max_queue_pairs; i++)\n\t\t\tif (vi->sq[i].napi.weight)\n\t\t\t\tvi->sq[i].intr_coal.max_packets\
  \ = 1;\n\n\t\terr = virtnet_init_irq_moder(vi);\n\t\tif (err)\n\t\t\tgoto free;\n\
  \t}\n\n#ifdef CONFIG_SYSFS\n\tif (vi->mergeable_rx_bufs)\n\t\tdev->sysfs_rx_queue_group\
  \ = &virtio_net_mrg_rx_group;\n#endif\n\tnetif_set_real_num_tx_queues(dev, vi->curr_queue_pairs);\n\
  \tnetif_set_real_num_rx_queues(dev, vi->curr_queue_pairs);\n\n\tvirtnet_init_settings(dev);\n\
  \n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_STANDBY)) {\n\t\tvi->failover = net_failover_create(vi->dev);\n\
  \t\tif (IS_ERR(vi->failover)) {\n\t\t\terr = PTR_ERR(vi->failover);\n\t\t\tgoto\
  \ free_vqs;\n\t\t}\n\t}\n\n\tif (vi->has_rss || vi->has_rss_hash_report)\n\t\tvirtnet_init_default_rss(vi);\n\
  \n\tenable_rx_mode_work(vi);\n\n\t/* serialize netdev register + virtio_device_ready()\
  \ with ndo_open() */\n\trtnl_lock();\n\n\terr = register_netdevice(dev);\n\tif (err)\
  \ {\n\t\tpr_debug(\"virtio_net: registering device failed\\n\");\n\t\trtnl_unlock();\n\
  \t\tgoto free_failover;\n\t}\n\n\t/* Disable config change notification until ndo_open.\
  \ */\n\tvirtio_config_driver_disable(vi->vdev);\n\n\tvirtio_device_ready(vdev);\n\
  \n\tvirtnet_set_queues(vi, vi->curr_queue_pairs);\n\n\t/* a random MAC address has\
  \ been assigned, notify the device.\n\t * We don't fail probe if VIRTIO_NET_F_CTRL_MAC_ADDR\
  \ is not there\n\t * because many devices work fine without getting MAC explicitly\n\
  \t */\n\tif (!virtio_has_feature(vdev, VIRTIO_NET_F_MAC) &&\n\t    virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_CTRL_MAC_ADDR)) {\n\t\tstruct scatterlist sg;\n\n\t\tsg_init_one(&sg,\
  \ dev->dev_addr, dev->addr_len);\n\t\tif (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MAC,\n\
  \t\t\t\t\t  VIRTIO_NET_CTRL_MAC_ADDR_SET, &sg)) {\n\t\t\tpr_debug(\"virtio_net:\
  \ setting MAC address failed\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr = -EINVAL;\n\
  \t\t\tgoto free_unregister_netdev;\n\t\t}\n\t}\n\n\tif (virtio_has_feature(vi->vdev,\
  \ VIRTIO_NET_F_DEVICE_STATS)) {\n\t\tstruct virtio_net_stats_capabilities *stats_cap\
  \  __free(kfree) = NULL;\n\t\tstruct scatterlist sg;\n\t\t__le64 v;\n\n\t\tstats_cap\
  \ = kzalloc(sizeof(*stats_cap), GFP_KERNEL);\n\t\tif (!stats_cap) {\n\t\t\trtnl_unlock();\n\
  \t\t\terr = -ENOMEM;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tsg_init_one(&sg,\
  \ stats_cap, sizeof(*stats_cap));\n\n\t\tif (!virtnet_send_command_reply(vi, VIRTIO_NET_CTRL_STATS,\n\
  \t\t\t\t\t\tVIRTIO_NET_CTRL_STATS_QUERY,\n\t\t\t\t\t\tNULL, &sg)) {\n\t\t\tpr_debug(\"\
  virtio_net: fail to get stats capability\\n\");\n\t\t\trtnl_unlock();\n\t\t\terr\
  \ = -EINVAL;\n\t\t\tgoto free_unregister_netdev;\n\t\t}\n\n\t\tv = stats_cap->supported_stats_types[0];\n\
  \t\tvi->device_stats_cap = le64_to_cpu(v);\n\t}\n\n\t/* Assume link up if device\
  \ can't report link status,\n\t   otherwise get link status from config. */\n\t\
  netif_carrier_off(dev);\n\tif (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS))\
  \ {\n\t\tvirtnet_config_changed_work(&vi->config_work);\n\t} else {\n\t\tvi->status\
  \ = VIRTIO_NET_S_LINK_UP;\n\t\tvirtnet_update_settings(vi);\n\t\tnetif_carrier_on(dev);\n\
  \t}\n\n\tfor (i = 0; i < ARRAY_SIZE(guest_offloads); i++)\n\t\tif (virtio_has_feature(vi->vdev,\
  \ guest_offloads[i]))\n\t\t\tset_bit(guest_offloads[i], &vi->guest_offloads);\n\t\
  vi->guest_offloads_capable = vi->guest_offloads;\n\n\trtnl_unlock();\n\n\terr =\
  \ virtnet_cpu_notif_add(vi);\n\tif (err) {\n\t\tpr_debug(\"virtio_net: registering\
  \ cpu notifier failed\\n\");\n\t\tgoto free_unregister_netdev;\n\t}\n\n\tpr_debug(\"\
  virtnet: registered device %s with %d RX and TX vq's\\n\",\n\t\t dev->name, max_queue_pairs);\n\
  \n\treturn 0;\n\nfree_unregister_netdev:\n\tunregister_netdev(dev);\nfree_failover:\n\
  \tnet_failover_destroy(vi->failover);\nfree_vqs:\n\tvirtio_reset_device(vdev);\n\
  \tcancel_delayed_work_sync(&vi->refill);\n\tfree_receive_page_frags(vi);\n\tvirtnet_del_vqs(vi);\n\
  free:\n\tfree_netdev(dev);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c\nindex 4b507007d242..545dda8ec077\
  \ 100644\n--- a/drivers/net/virtio_net.c\n+++ b/drivers/net/virtio_net.c\n@@ -6451,6\
  \ +6451,12 @@ static int virtnet_probe(struct virtio_device *vdev)\n \tif (vi->has_rss\
  \ || vi->has_rss_hash_report) {\n \t\tvi->rss_key_size =\n \t\t\tvirtio_cread8(vdev,\
  \ offsetof(struct virtio_net_config, rss_max_key_size));\n+\t\tif (vi->rss_key_size\
  \ > VIRTIO_NET_RSS_MAX_KEY_SIZE) {\n+\t\t\tdev_err(&vdev->dev, \"rss_max_key_size=%u\
  \ exceeds the limit %u.\\n\",\n+\t\t\t\tvi->rss_key_size, VIRTIO_NET_RSS_MAX_KEY_SIZE);\n\
  +\t\t\terr = -EINVAL;\n+\t\t\tgoto free;\n+\t\t}\n \n \t\tvi->rss_hash_types_supported\
  \ =\n \t\t    virtio_cread32(vdev, offsetof(struct virtio_net_config, supported_hash_types));\n\
  ```\n"
pattern: "## Bug Pattern\n\nUsing a length value read from an untrusted device configuration\
  \ (rss_max_key_size) directly to size memory operations on a fixed-size buffer,\
  \ without first validating it against the implementation\u2019s maximum (VIRTIO_NET_RSS_MAX_KEY_SIZE).\
  \ This missing bounds check allows a device to advertise an oversized RSS key length,\
  \ leading to out-of-bounds access when setting/reading the RSS hash key."
plan: "1) Program State\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(UntrustedLenMap, const\
  \ MemRegion*, bool)\n  - Tracks integer variables/fields that hold the device-provided\
  \ RSS key length.\n  - Value false: untrusted and not yet validated against VIRTIO_NET_RSS_MAX_KEY_SIZE.\n\
  \  - Value true: validated (bounded).\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap,\
  \ const MemRegion*, const MemRegion*)\n  - Tracks simple aliases of these integer\
  \ variables (e.g., len = vi->rss_key_size;).\n  - Used to propagate the checked/unchecked\
  \ status across assignments.\n\n\n2) Callbacks and Core Logic\n\nA. checkBind (capture\
  \ and propagate \u201Cuntrusted RSS length\u201D)\n\n- Goal:\n  - Identify assignments\
  \ that load rss_max_key_size from the device.\n  - Mark the destination as untrusted\
  \ (unchecked).\n  - Track aliases among integer variables holding the untrusted\
  \ length.\n  - Recognize \u201Cchecked\u201D rewrites (e.g., min(len, MAX)).\n\n\
  - Implementation:\n  - Given (Loc, Val, S, C):\n    1) Identify the left-hand side\
  \ region:\n       - const MemRegion *DstR = Loc.getAsRegion(); If null, return.\n\
  \    2) Extract the RHS expression from S:\n       - Use findSpecificTypeInChildren<const\
  \ CallExpr>(S) to see if RHS contains a call.\n       - If RHS contains a call whose\
  \ callee is virtio_cread8/virtio_cread16/virtio_cread32 AND ExprHasName(RHS, \"\
  rss_max_key_size\", C):\n         - State = State.set<UntrustedLenMap>(DstR, false)\
  \  // mark as untrusted and unchecked.\n    3) Alias propagation:\n       - If the\
  \ RHS expression denotes another region SrcR (getMemRegionFromExpr(RHS, C)), and\
  \ that region is in UntrustedLenMap:\n         - State = State.set<PtrAliasMap>(DstR,\
  \ SrcR)\n         - Also copy the checked/unchecked boolean from SrcR to DstR: State\
  \ = State.set<UntrustedLenMap>(DstR, Checked(SrcR))\n       - If not found by region,\
  \ still handle textual propagation:\n         - If ExprHasName(RHS, \"rss_key_size\"\
  , C) and any region already tracked for a MemberExpr/DRE in RHS:\n           - Treat\
  \ similarly as above (alias and copy).\n    4) Recognize \u201Cchecked via min()/clamp\u201D\
  \ idioms:\n       - If RHS is a CallExpr with callee name in {\"min\", \"min_t\"\
  , \"clamp\", \"clamp_t\"} AND\n         one operand refers to a tracked region and\
  \ the other contains \"VIRTIO_NET_RSS_MAX_KEY_SIZE\" via ExprHasName:\n        \
  \ - Mark DstR as checked: State = State.set<UntrustedLenMap>(DstR, true)\n     \
  \  - Otherwise, if RHS is a ConditionalOperator where either branch uses min()/clamp\
  \ with the macro as above, mark as checked as well.\n    5) Overwrite handling:\n\
  \       - If DstR already in UntrustedLenMap and RHS does not come from device length\
  \ or alias:\n         - Remove DstR from UntrustedLenMap and PtrAliasMap (the variable\
  \ is no longer the untrusted length).\n\n- Notes:\n  - This is intentionally specific\
  \ to \"rss_max_key_size\"; we only taint from expressions that read this device\
  \ field.\n\nB. checkBranchCondition (mark as validated when compared against the\
  \ maximum macro)\n\n- Goal:\n  - Mark an untrusted RSS length as \u201Cchecked\u201D\
  \ once it\u2019s compared against VIRTIO_NET_RSS_MAX_KEY_SIZE (<=, <, >=, >).\n\
  \  - We keep the implementation simple and conservative.\n\n- Implementation:\n\
  \  - Given (Condition, C):\n    1) If not ExprHasName(ConditionExpr, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C), return (we only care about checks involving the macro).\n    2) Try to get\
  \ the MemRegion of the length being compared:\n       - For the left and right children\
  \ of a BinaryOperator (use findSpecificTypeInChildren<BinaryOperator>(Condition)\
  \ or directly walk children):\n         - For each child expr EVar, try getMemRegionFromExpr(EVar,\
  \ C). If R = non-null and R exists in UntrustedLenMap:\n           - Mark as checked:\
  \ State = State.set<UntrustedLenMap>(R, true)\n           - If PtrAliasMap shows\
  \ aliases pointing to/from R, mark those as checked too.\n    3) If getMemRegionFromExpr\
  \ fails (rvalue), fall back to textual: if ExprHasName(Condition, \"rss_key_size\"\
  , C):\n       - Iterate over all entries of UntrustedLenMap you added earlier (store/remember\
  \ their regions for the current function scope, or simply try to retrieve region\
  \ from a MemberExpr child of Condition if present) and mark the matching one as\
  \ checked if present.\n  - Simplicity trade-off:\n    - We mark as checked regardless\
  \ of branch direction (this may slightly over-approximate, but is sufficient to\
  \ prevent OOB usage warnings when a guard exists).\n\nC. checkPreCall (report uses\
  \ of unvalidated device-provided length)\n\n- Goal:\n  - When an untrusted/unchecked\
  \ length is used as a length argument to common memory-size-using APIs, report a\
  \ bug.\n  - Keep the function list small but relevant.\n\n- Implementation:\n  -\
  \ Given (Call, C):\n    1) Filter callee names to known \u201Clength-usage\u201D\
  \ APIs:\n       - sg_init_one(sg, buf, buflen)\n       - memcpy, memmove, memset,\
  \ memcpy_toio, memcpy_fromio, strncpy, strscpy (all with length as last param)\n\
  \       - You can extend this list if needed, but keep it small and focused.\n \
  \   2) Identify the length parameter index:\n       - sg_init_one: index 2\n   \
  \    - memcpy/memmove/memset/strncpy/strscpy/memcpy_toio/memcpy_fromio: index 2\n\
  \    3) Retrieve the length argument expression ArgLenE = Call.getArgExpr(IdxLen).\n\
  \       - First try: const MemRegion *R = getMemRegionFromExpr(ArgLenE, C).\n  \
  \       - If R in UntrustedLenMap and value is false (unchecked), report.\n    \
  \   - Otherwise fallback textual:\n         - If ExprHasName(ArgLenE, \"rss_key_size\"\
  , C) and there exists a tracked region (any entry in UntrustedLenMap with false),\
  \ report.\n       - Otherwise alias:\n         - If R not tracked but PtrAliasMap\
  \ maps R to Rsrc and Rsrc tracked as unchecked, report.\n    4) Report:\n      \
  \ - auto N = C.generateNonFatalErrorNode();\n       - Create a bug type (\u201C\
  RSS length out-of-bounds risk\u201D) once and reuse.\n       - Emit a PathSensitiveBugReport\
  \ with message:\n         - \"Unvalidated device length used for buffer size (RSS\
  \ key).\"\n       - Optionally, add a note to the assignment site if you recorded\
  \ it (not required).\n\n- Notes:\n  - We do not need to compute the destination\
  \ buffer size; we only enforce that the untrusted device length must be validated\
  \ before being used in size-driven calls.\n  - This mirrors the upstream fix that\
  \ validates rss_key_size against VIRTIO_NET_RSS_MAX_KEY_SIZE early.\n\nD. Optional:\
  \ checkPostCall (no-op)\n\n- Not strictly necessary; all tracking happens in checkBind\
  \ and checkPreCall.\n\n\n3) Heuristics and Edge-Case Handling\n\n- Assignment chains:\n\
  \  - If a series of assignments propagate the length (len = vi->rss_key_size; size\
  \ = len;), checkBind\u2019s alias propagation ensures len/size remain tracked and\
  \ share checked status.\n\n- Validation via guards:\n  - Any branch condition containing\
  \ both the tracked variable and VIRTIO_NET_RSS_MAX_KEY_SIZE marks it checked.\n\
  \  - Also accept min()/clamp() writes as checked in checkBind.\n\n- Reset on overwrite:\n\
  \  - If a tracked variable is overwritten by a value not derived from the device\
  \ length, remove it from tracking maps.\n\n- Macro handling:\n  - Use ExprHasName(E,\
  \ \"VIRTIO_NET_RSS_MAX_KEY_SIZE\", C) to detect comparisons with the macro per Suggestions.\n\
  \n\n4) Minimal Utility Use\n\n- Use ExprHasName for:\n  - Detecting \"rss_max_key_size\"\
  \ at the device read points.\n  - Detecting \"VIRTIO_NET_RSS_MAX_KEY_SIZE\" in bound\
  \ checks.\n  - Fallback detection of \"rss_key_size\" in length arguments and conditions.\n\
  \n- Use getMemRegionFromExpr to:\n  - Identify regions on assignments and comparisons.\n\
  \  - Lookup tracked/alias regions in maps for precise matching.\n\n- Use findSpecificTypeInChildren\
  \ to:\n  - Pull out CallExpr or BinaryOperator from the binding/condition statement\
  \ when needed.\n\n\n5) Summary of Detection Flow\n\n- Source: vi->rss_key_size =\
  \ virtio_cread8(...rss_max_key_size...) \u2192 mark region unchecked.\n- Check:\
  \ if (vi->rss_key_size <= VIRTIO_NET_RSS_MAX_KEY_SIZE) or len = min(vi->rss_key_size,\
  \ VIRTIO_NET_RSS_MAX_KEY_SIZE) \u2192 mark checked.\n- Sink: sg_init_one(..., ...,\
  \ vi->rss_key_size) or memcpy(..., ..., len) where len is tracked unchecked \u2192\
  \ report:\n  - \"Unvalidated device length used for buffer size (RSS key).\""
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/AST/Decl.h\"\n#include \"llvm/ADT/SmallVector.h\"\
  \n#include \"llvm/ADT/StringRef.h\"\n#include <memory>\n#include <climits>\n\nusing\
  \ namespace clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(UntrustedLenMap,\
  \ const MemRegion*, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*,\
  \ const MemRegion*)\n\nnamespace {\nclass SAGenTestChecker\n  : public Checker<\n\
  \      check::Bind,\n      check::PreCall,\n      check::BranchCondition\n    >\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unvalidated RSS length\", \"Memory Safety\")) {}\n\n\
  \      void checkBind(SVal Loc, SVal Val, const Stmt *StoreE, CheckerContext &C)\
  \ const;\n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \n   private:\n      // Helpers\n      static const Expr* getRHSOfStore(const Stmt\
  \ *S);\n      static const CallExpr* getAnyCallInStmt(const Stmt *S);\n      static\
  \ bool isVirtioCreadRssMaxKey(const CallExpr *CE, CheckerContext &C);\n      static\
  \ bool isMinOrClampWithMax(const CallExpr *CE, CheckerContext &C);\n      static\
  \ bool isLenAPICall(const Expr *Origin, StringRef &NameOut, unsigned &LenIdx, unsigned\
  \ ArgCount);\n      static bool isLenAPICandidate(const Expr *Origin, StringRef\
  \ &NameOut, unsigned &LenIdx);\n\n      static ProgramStateRef markChecked(ProgramStateRef\
  \ State, const MemRegion *R);\n      static ProgramStateRef copyStatusAndAlias(ProgramStateRef\
  \ State,\n                                                const MemRegion *DstR,\n\
  \                                                const MemRegion *SrcR);\n     \
  \ static const MemRegion* getBaseRegionFromExpr(const Expr *E, CheckerContext &C);\n\
  \n      static void collectTrackedRegionsInExpr(const Expr *E, CheckerContext &C,\n\
  \                                              ProgramStateRef State,\n        \
  \                                      llvm::SmallVectorImpl<const MemRegion*> &Out);\n\
  \      void reportUnvalidatedUse(const CallEvent &Call, const Expr *ArgE, CheckerContext\
  \ &C) const;\n};\n\nconst Expr* SAGenTestChecker::getRHSOfStore(const Stmt *S) {\n\
  \  if (!S) return nullptr;\n  if (const auto *BO = dyn_cast<BinaryOperator>(S))\
  \ {\n    if (BO->isAssignmentOp())\n      return BO->getRHS();\n  }\n  if (const\
  \ auto *DS = dyn_cast<DeclStmt>(S)) {\n    for (const auto *D : DS->decls()) {\n\
  \      if (const auto *VD = dyn_cast<VarDecl>(D)) {\n        if (const Expr *Init\
  \ = VD->getInit())\n          return Init;\n      }\n    }\n  }\n  // Fallback:\
  \ try to find any expression child\n  if (const auto *E = dyn_cast<Expr>(S))\n \
  \   return E;\n  return nullptr;\n}\n\nconst CallExpr* SAGenTestChecker::getAnyCallInStmt(const\
  \ Stmt *S) {\n  if (!S) return nullptr;\n  return findSpecificTypeInChildren<const\
  \ CallExpr>(S);\n}\n\nbool SAGenTestChecker::isVirtioCreadRssMaxKey(const CallExpr\
  \ *CE, CheckerContext &C) {\n  if (!CE) return false;\n  const Expr *O = CE;\n \
  \ // Match virtio_cread8/16/32 and the field rss_max_key_size in args.\n  if (!(ExprHasName(O,\
  \ \"virtio_cread8\", C) ||\n        ExprHasName(O, \"virtio_cread16\", C) ||\n \
  \       ExprHasName(O, \"virtio_cread32\", C) ||\n        ExprHasName(O, \"virtio_cread_bytes\"\
  , C)))\n    return false;\n\n  if (!ExprHasName(O, \"rss_max_key_size\", C))\n \
  \   return false;\n\n  return true;\n}\n\nbool SAGenTestChecker::isMinOrClampWithMax(const\
  \ CallExpr *CE, CheckerContext &C) {\n  if (!CE) return false;\n  const Expr *O\
  \ = CE;\n  if (!(ExprHasName(O, \"min\", C) ||\n        ExprHasName(O, \"min_t\"\
  , C) ||\n        ExprHasName(O, \"clamp\", C) ||\n        ExprHasName(O, \"clamp_t\"\
  , C)))\n    return false;\n\n  // Must involve the maximum macro in any arg.\n \
  \ for (const Expr *Arg : CE->arguments()) {\n    if (ExprHasName(Arg, \"VIRTIO_NET_RSS_MAX_KEY_SIZE\"\
  , C))\n      return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::isLenAPICall(const\
  \ Expr *Origin, StringRef &NameOut, unsigned &LenIdx, unsigned ArgCount) {\n  (void)Origin;\n\
  \  (void)NameOut;\n  (void)LenIdx;\n  (void)ArgCount;\n  // Not used in this checker.\
  \ Keep as stub for compatibility.\n  return false;\n}\n\nbool SAGenTestChecker::isLenAPICandidate(const\
  \ Expr *Origin, StringRef &NameOut, unsigned &LenIdx) {\n  (void)Origin;\n  (void)NameOut;\n\
  \  (void)LenIdx;\n  // Not used in this checker. Keep as stub for compatibility.\n\
  \  return false;\n}\n\nProgramStateRef SAGenTestChecker::markChecked(ProgramStateRef\
  \ State, const MemRegion *R) {\n  if (!R) return State;\n  const MemRegion *Base\
  \ = R->getBaseRegion();\n  if (!Base) return State;\n\n  const bool *Tracked = State->get<UntrustedLenMap>(Base);\n\
  \  if (Tracked && *Tracked == false) {\n    State = State->set<UntrustedLenMap>(Base,\
  \ true);\n  }\n\n  // If we have an alias, mark it checked too.\n  if (const MemRegion\
  \ *const *AliasPtr = State->get<PtrAliasMap>(Base)) {\n    const MemRegion *Alias\
  \ = *AliasPtr;\n    const bool *AliasTracked = State->get<UntrustedLenMap>(Alias);\n\
  \    if (AliasTracked && *AliasTracked == false) {\n      State = State->set<UntrustedLenMap>(Alias,\
  \ true);\n    }\n  }\n  return State;\n}\n\nProgramStateRef SAGenTestChecker::copyStatusAndAlias(ProgramStateRef\
  \ State,\n                                                     const MemRegion *DstR,\n\
  \                                                     const MemRegion *SrcR) {\n\
  \  if (!DstR || !SrcR) return State;\n  DstR = DstR->getBaseRegion();\n  SrcR =\
  \ SrcR->getBaseRegion();\n  if (!DstR || !SrcR) return State;\n\n  // Copy status\
  \ if any\n  if (const bool *Tracked = State->get<UntrustedLenMap>(SrcR)) {\n   \
  \ State = State->set<UntrustedLenMap>(DstR, *Tracked);\n  }\n  // Record alias both\
  \ ways\n  State = State->set<PtrAliasMap>(DstR, SrcR);\n  State = State->set<PtrAliasMap>(SrcR,\
  \ DstR);\n\n  return State;\n}\n\nconst MemRegion* SAGenTestChecker::getBaseRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return nullptr;\n  const MemRegion *MR\
  \ = getMemRegionFromExpr(E, C);\n  if (!MR) return nullptr;\n  return MR->getBaseRegion();\n\
  }\n\nvoid SAGenTestChecker::collectTrackedRegionsInExpr(const Expr *E, CheckerContext\
  \ &C,\n                                                   ProgramStateRef State,\n\
  \                                                   llvm::SmallVectorImpl<const\
  \ MemRegion*> &Out) {\n  if (!E) return;\n  // Try current node\n  if (const MemRegion\
  \ *MR = getMemRegionFromExpr(E, C)) {\n    MR = MR->getBaseRegion();\n    if (MR)\
  \ {\n      if (const bool *Tracked = State->get<UntrustedLenMap>(MR)) {\n      \
  \  if (*Tracked == false) {\n          Out.push_back(MR);\n        }\n      }\n\
  \    }\n  }\n  // Recurse into children\n  for (const Stmt *Child : E->children())\
  \ {\n    if (const auto *CE = dyn_cast_or_null<Expr>(Child)) {\n      collectTrackedRegionsInExpr(CE,\
  \ C, State, Out);\n    }\n  }\n}\n\nvoid SAGenTestChecker::reportUnvalidatedUse(const\
  \ CallEvent &Call, const Expr *ArgE, CheckerContext &C) const {\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Unvalidated device length used for buffer size (RSS key)\", N);\n\
  \  if (ArgE)\n    R->addRange(ArgE->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *StoreE, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *DstR\
  \ = Loc.getAsRegion();\n  if (!DstR) return;\n  DstR = DstR->getBaseRegion();\n\
  \  if (!DstR) return;\n\n  bool StateChanged = false;\n  const Expr *RHS = getRHSOfStore(StoreE);\n\
  \n  // 1) Detect assignment from virtio_cread* reading rss_max_key_size\n  if (const\
  \ CallExpr *CE = getAnyCallInStmt(StoreE)) {\n    if (isVirtioCreadRssMaxKey(CE,\
  \ C)) {\n      // Mark destination as untrusted/unchecked.\n      State = State->set<UntrustedLenMap>(DstR,\
  \ false);\n      StateChanged = true;\n      // Clear any previous alias pointing\
  \ somewhere irrelevant\n      // We don't remove here; keep simple.\n    } else\
  \ if (isMinOrClampWithMax(CE, C)) {\n      // If this is min/clamp involving the\
  \ macro, and one operand is tracked,\n      // mark DstR as checked.\n      // Check\
  \ if any arg is tracked\n      bool TrackedOperand = false;\n      for (const Expr\
  \ *Arg : CE->arguments()) {\n        const MemRegion *OpR = getBaseRegionFromExpr(Arg,\
  \ C);\n        if (!OpR) continue;\n        if (const bool *Tracked = State->get<UntrustedLenMap>(OpR))\
  \ {\n          if (*Tracked == false) {\n            TrackedOperand = true;\n  \
  \          break;\n          }\n        }\n      }\n      if (TrackedOperand) {\n\
  \        State = State->set<UntrustedLenMap>(DstR, true);\n        StateChanged\
  \ = true;\n      }\n    }\n  }\n\n  // 2) Alias/status propagation for simple copies\
  \ (len = vi->rss_key_size;)\n  if (RHS && !StateChanged) {\n    if (const MemRegion\
  \ *SrcR = getBaseRegionFromExpr(RHS, C)) {\n      const bool *Tracked = State->get<UntrustedLenMap>(SrcR);\n\
  \      if (Tracked) {\n        State = copyStatusAndAlias(State, DstR, SrcR);\n\
  \        StateChanged = true;\n      }\n    }\n  }\n\n  // 3) Overwrite handling:\
  \ if DstR was tracked but RHS isn't from device or alias,\n  //    then remove DstR\
  \ from tracking.\n  if (!StateChanged) {\n    if (const bool *WasTracked = State->get<UntrustedLenMap>(DstR))\
  \ {\n      (void)WasTracked;\n      // Remove from UntrustedLenMap and alias map\n\
  \      if (const MemRegion *const *AliasPtr = State->get<PtrAliasMap>(DstR)) {\n\
  \        const MemRegion *Alias = *AliasPtr;\n        State = State->remove<PtrAliasMap>(Alias);\n\
  \      }\n      State = State->remove<PtrAliasMap>(DstR);\n      State = State->remove<UntrustedLenMap>(DstR);\n\
  \      StateChanged = true;\n    }\n  }\n\n  if (StateChanged)\n    C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE) {\n    C.addTransition(State);\n    return;\n  }\n\n  // Only care\
  \ when the condition involves the macro VIRTIO_NET_RSS_MAX_KEY_SIZE\n  if (!ExprHasName(CondE,\
  \ \"VIRTIO_NET_RSS_MAX_KEY_SIZE\", C)) {\n    C.addTransition(State);\n    return;\n\
  \  }\n\n  // Collect tracked regions referenced in this condition and mark them\
  \ checked.\n  llvm::SmallVector<const MemRegion*, 4> Regions;\n  collectTrackedRegionsInExpr(CondE,\
  \ C, State, Regions);\n\n  bool Changed = false;\n  for (const MemRegion *R : Regions)\
  \ {\n    ProgramStateRef NewState = markChecked(State, R);\n    if (NewState !=\
  \ State) {\n      State = NewState;\n      Changed = true;\n    }\n  }\n\n  if (Changed)\n\
  \    C.addTransition(State);\n  else\n    C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return;\n\n  // Identify candidate functions and their 'length'\
  \ argument index.\n  // Use ExprHasName for robustness as suggested.\n  unsigned\
  \ LenIdx = UINT_MAX;\n  if (ExprHasName(Origin, \"sg_init_one\", C)) {\n    if (Call.getNumArgs()\
  \ >= 3) LenIdx = 2;\n  } else if (ExprHasName(Origin, \"sg_set_buf\", C)) {\n  \
  \  if (Call.getNumArgs() >= 3) LenIdx = 2;\n  } else if (ExprHasName(Origin, \"\
  memcpy\", C) ||\n             ExprHasName(Origin, \"memmove\", C) ||\n         \
  \    ExprHasName(Origin, \"memset\", C) ||\n             ExprHasName(Origin, \"\
  memcpy_toio\", C) ||\n             ExprHasName(Origin, \"memcpy_fromio\", C) ||\n\
  \             ExprHasName(Origin, \"strncpy\", C) ||\n             ExprHasName(Origin,\
  \ \"strscpy\", C)) {\n    if (Call.getNumArgs() >= 3) LenIdx = 2;\n  } else {\n\
  \    return;\n  }\n\n  if (LenIdx == UINT_MAX || LenIdx >= Call.getNumArgs())\n\
  \    return;\n\n  const Expr *ArgE = Call.getArgExpr(LenIdx);\n  if (!ArgE)\n  \
  \  return;\n\n  ProgramStateRef State = C.getState();\n\n  // First, check by region\n\
  \  const MemRegion *LenR = getBaseRegionFromExpr(ArgE, C);\n  if (LenR) {\n    if\
  \ (const bool *Tracked = State->get<UntrustedLenMap>(LenR)) {\n      if (*Tracked\
  \ == false) {\n        reportUnvalidatedUse(Call, ArgE, C);\n        return;\n \
  \     }\n    }\n    // Alias fallback\n    if (const MemRegion *const *AliasPtr\
  \ = State->get<PtrAliasMap>(LenR)) {\n      const MemRegion *Alias = *AliasPtr;\n\
  \      if (const bool *AliasTracked = State->get<UntrustedLenMap>(Alias)) {\n  \
  \      if (*AliasTracked == false) {\n          reportUnvalidatedUse(Call, ArgE,\
  \ C);\n          return;\n        }\n      }\n    }\n  }\n\n  // Textual fallback:\
  \ if the expression contains rss_key_size, but we don't\n  // have region info,\
  \ do not report unless we are certain; per suggestion,\n  // avoid reporting if\
  \ unsure. So we skip here.\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects use of unvalidated device-provided\
  \ RSS length for buffer sizing\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
