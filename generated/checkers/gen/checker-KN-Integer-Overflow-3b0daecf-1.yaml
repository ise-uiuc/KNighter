_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3b0daecfeac0103aba8b293df07a0cbaf8b43f29
commit_type: Integer-Overflow
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program state needed.\n\nnamespace {\n/*\
  \ The checker callbacks are to be decided. */\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Overflow-prone allocation size (use kcalloc)\", \"API\
  \ Misuse\")) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\n   private:\n\n      // Return true if Call is one of the array-aware\
  \ allocators that should be ignored.\n      bool isArrayAwareAllocator(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n      // If Call is a target allocator that\
  \ takes a single total size parameter,\n      // set Idx to the index of that size\
  \ argument and return true.\n      bool getAllocatorSizeArgIndex(const CallEvent\
  \ &Call, unsigned &Idx, CheckerContext &C) const;\n\n      // Returns true if expression\
  \ subtree contains a sizeof(...) (UnaryExprOrTypeTraitExpr of kind SizeOf).\n  \
  \    static bool exprContainsSizeof(const Expr *E);\n\n      // Report helper\n\
  \      void reportMulPattern(const BinaryOperator *Mul, CheckerContext &C) const;\n\
  };\n\nbool SAGenTestChecker::isArrayAwareAllocator(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  const Expr *Orig = Call.getOriginExpr();\n  if (!Orig)\n    return\
  \ false;\n\n  // Ignore calls that already use overflow-safe array helpers.\n  static\
  \ const char *ArrayAware[] = {\n      \"kcalloc\",\n      \"kvcalloc\",\n      \"\
  kmalloc_array\",\n      \"kvmalloc_array\",\n      \"devm_kcalloc\"\n  };\n\n  for\
  \ (const char *Name : ArrayAware) {\n    if (ExprHasName(Orig, Name, C))\n     \
  \ return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getAllocatorSizeArgIndex(const\
  \ CallEvent &Call, unsigned &Idx, CheckerContext &C) const {\n  const Expr *Orig\
  \ = Call.getOriginExpr();\n  if (!Orig)\n    return false;\n\n  // Order matters\
  \ where names can be substrings of others. Keep more specific first.\n  struct Entry\
  \ { const char *Name; unsigned SizeIdx; };\n  static const Entry Targets[] = {\n\
  \      {\"devm_kzalloc\", 1},\n      {\"devm_kmalloc\", 1},\n      {\"kvzalloc\"\
  , 0},\n      {\"kvmalloc\", 0},\n      {\"kzalloc\", 0},\n      {\"kmalloc\", 0},\n\
  \      {\"vzalloc\", 0},\n  };\n\n  for (const auto &E : Targets) {\n    if (ExprHasName(Orig,\
  \ E.Name, C)) {\n      Idx = E.SizeIdx;\n      return true;\n    }\n  }\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::exprContainsSizeof(const Expr *E) {\n  if\
  \ (!E) return false;\n  const Stmt *S = dyn_cast<Stmt>(E);\n  if (!S) return false;\n\
  \n  const auto *UETT = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(S);\n\
  \  if (!UETT) return false;\n  return UETT->getKind() == UETT_SizeOf;\n}\n\nvoid\
  \ SAGenTestChecker::reportMulPattern(const BinaryOperator *Mul, CheckerContext &C)\
  \ const {\n  if (!Mul) return;\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n   \
  \   *BT,\n      \"Use kcalloc(count, size, ...) instead of count*sizeof in allocation\
  \ to avoid integer overflow\",\n      N);\n  R->addRange(Mul->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  // Ignore non-interesting calls first.\n\
  \  if (isArrayAwareAllocator(Call, C))\n    return;\n\n  unsigned SizeIdx = 0;\n\
  \  if (!getAllocatorSizeArgIndex(Call, SizeIdx, C))\n    return;\n\n  if (Call.getNumArgs()\
  \ <= SizeIdx)\n    return;\n\n  const Expr *SizeE = Call.getArgExpr(SizeIdx);\n\
  \  if (!SizeE)\n    return;\n\n  // Suppress safe helpers used inside size expression.\n\
  \  if (ExprHasName(SizeE, \"array_size\", C) ||\n      ExprHasName(SizeE, \"struct_size\"\
  , C) ||\n      ExprHasName(SizeE, \"flex_array_size\", C))\n    return;\n\n  SizeE\
  \ = SizeE->IgnoreParenImpCasts();\n  const auto *BO = dyn_cast<BinaryOperator>(SizeE);\n\
  \  if (!BO || BO->getOpcode() != BO_Mul)\n    return;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \  const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n  // Look for sizeof(...)\
  \ on either side to match \"count * sizeof(T)\" or \"sizeof(T) * count\"\n  bool\
  \ HasSizeof = exprContainsSizeof(LHS) || exprContainsSizeof(RHS);\n  if (!HasSizeof)\n\
  \    return;\n\n  reportMulPattern(BO, C);\n}\n\n} // end anonymous namespace\n\n\
  extern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects kmalloc/kzalloc-style allocations\
  \ that multiply count by sizeof; suggest kcalloc to avoid overflow\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\namdkfd: use calloc instead of kzalloc to avoid integer\
  \ overflow\n\nThis uses calloc instead of doing the multiplication which might\n\
  overflow.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: kfd_ioctl_get_process_apertures_new in drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\t\t\t\tstruct\
  \ kfd_process *p, void *data)\n{\n\tstruct kfd_ioctl_get_process_apertures_new_args\
  \ *args = data;\n\tstruct kfd_process_device_apertures *pa;\n\tint ret;\n\tint i;\n\
  \n\tdev_dbg(kfd_device, \"get apertures for PASID 0x%x\", p->pasid);\n\n\tif (args->num_of_nodes\
  \ == 0) {\n\t\t/* Return number of nodes, so that user space can alloacate\n\t\t\
  \ * sufficient memory\n\t\t */\n\t\tmutex_lock(&p->mutex);\n\t\targs->num_of_nodes\
  \ = p->n_pdds;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Fill in process-aperture information\
  \ for all available\n\t * nodes, but not more than args->num_of_nodes as that is\n\
  \t * the amount of memory allocated by user\n\t */\n\tpa = kzalloc((sizeof(struct\
  \ kfd_process_device_apertures) *\n\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n\t\
  if (!pa)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&p->mutex);\n\n\tif (!p->n_pdds) {\n\
  \t\targs->num_of_nodes = 0;\n\t\tkfree(pa);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Run\
  \ over all pdd of the process */\n\tfor (i = 0; i < min(p->n_pdds, args->num_of_nodes);\
  \ i++) {\n\t\tstruct kfd_process_device *pdd = p->pdds[i];\n\n\t\tpa[i].gpu_id =\
  \ pdd->dev->id;\n\t\tpa[i].lds_base = pdd->lds_base;\n\t\tpa[i].lds_limit = pdd->lds_limit;\n\
  \t\tpa[i].gpuvm_base = pdd->gpuvm_base;\n\t\tpa[i].gpuvm_limit = pdd->gpuvm_limit;\n\
  \t\tpa[i].scratch_base = pdd->scratch_base;\n\t\tpa[i].scratch_limit = pdd->scratch_limit;\n\
  \n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpu id %u\\n\", pdd->dev->id);\n\t\tdev_dbg(kfd_device,\n\
  \t\t\t\"lds_base %llX\\n\", pdd->lds_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"lds_limit\
  \ %llX\\n\", pdd->lds_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_base %llX\\\
  n\", pdd->gpuvm_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_limit %llX\\n\",\
  \ pdd->gpuvm_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_base %llX\\n\", pdd->scratch_base);\n\
  \t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_limit %llX\\n\", pdd->scratch_limit);\n\
  \t}\n\tmutex_unlock(&p->mutex);\n\n\targs->num_of_nodes = i;\n\tret = copy_to_user(\n\
  \t\t\t(void __user *)args->kfd_process_device_apertures_ptr,\n\t\t\tpa,\n\t\t\t\
  (i * sizeof(struct kfd_process_device_apertures)));\n\tkfree(pa);\n\treturn ret\
  \ ? -EFAULT : 0;\n\nout_unlock:\n\tmutex_unlock(&p->mutex);\n\treturn 0;\n}\n```\n\
  \n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\
  \ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\nindex f9631f4b1a02..55aa74cbc532 100644\n\
  --- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  @@ -779,8 +779,8 @@ static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\
  \ \t * nodes, but not more than args->num_of_nodes as that is\n \t * the amount\
  \ of memory allocated by user\n \t */\n-\tpa = kzalloc((sizeof(struct kfd_process_device_apertures)\
  \ *\n-\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n+\tpa = kcalloc(args->num_of_nodes,\
  \ sizeof(struct kfd_process_device_apertures),\n+\t\t     GFP_KERNEL);\n \tif (!pa)\n\
  \ \t\treturn -ENOMEM;\n \n```\n"
pattern: '## Bug Pattern


  Manually multiplying count by element size when allocating an array with kmalloc/kzalloc:

  ptr = kzalloc(count * sizeof(*ptr), GFP_KERNEL);

  This risks integer overflow in the size calculation, leading to undersized allocations
  and subsequent out-of-bounds writes/reads. Use kcalloc(count, sizeof(*ptr), GFP_KERNEL)
  which performs overflow checking.'
plan: "Plan\n\n1. Program state\n- No custom program state is needed. This checker\
  \ is a local syntactic/semantic pattern match on allocator calls.\n\n2. Callback\
  \ selection\n- Use checkPreCall as the single entry point. We only need to inspect\
  \ the allocator calls\u2019 arguments before evaluating the call.\n\n3. Detect target\
  \ allocators and their size-argument index\n- In checkPreCall:\n  - Identify calls\
  \ to allocators that accept a single \u201Ctotal size\u201D parameter and are commonly\
  \ used to allocate arrays:\n    - kmalloc(size, gfp)  -> size index 0\n    - kzalloc(size,\
  \ gfp)  -> size index 0\n    - kvmalloc(size, gfp) -> size index 0\n    - kvzalloc(size,\
  \ gfp) -> size index 0\n    - devm_kmalloc(dev, size, gfp)  -> size index 1\n  \
  \  - devm_kzalloc(dev, size, gfp)  -> size index 1\n    - vzalloc(size) -> size\
  \ index 0\n  - Ignore calls that already use array-aware APIs (do not warn):\n \
  \   - kcalloc, kvcalloc, kmalloc_array, kvmalloc_array, devm_kcalloc\n  - Implement\
  \ a small helper getAllocatorSizeArgIndex(const CallEvent &Call, unsigned &Idx)\
  \ returning true if the callee is one of the above and setting Idx; return false\
  \ otherwise.\n  - If not a target allocator, return.\n\n4. Decide if the size argument\
  \ is a risky \u201Ccount * sizeof\u201D multiplication\n- Fetch the size expression\
  \ E = Call.getArgExpr(SizeIdx).\n- Quickly filter out safe size-building helpers\
  \ using source text:\n  - If ExprHasName(E, \"array_size\", C) or ExprHasName(E,\
  \ \"struct_size\", C) or ExprHasName(E, \"flex_array_size\", C), return (these helpers\
  \ include overflow checks).\n- Strip implicit casts and parentheses: E = E->IgnoreParenImpCasts().\n\
  - Identify multiplication:\n  - If E is a BinaryOperator with opcode BO_Mul, proceed;\
  \ else return.\n  - Let BO = cast<BinaryOperator>(E). For BO->getLHS() and BO->getRHS():\n\
  \    - Determine if either subtree contains a sizeof expression:\n      - Use findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(SideExpr)\
  \ and check UETT->getKind() == UETT_SizeOf.\n    - If neither side contains sizeof,\
  \ return (we only warn for count * sizeof(...) forms).\n- Optional refinement (keep\
  \ simple):\n  - Do not attempt to evaluate constants or prove overflow; this checker\
  \ flags the risky pattern, not concrete overflow.\n\n5. Report the issue\n- If the\
  \ pattern is found, emit a warning before the call executes:\n  - Create a non-fatal\
  \ error node with generateNonFatalErrorNode().\n  - Use a PathSensitiveBugReport\
  \ (or BasicBugReport) with a concise message, e.g.:\n    - \"Prefer kcalloc(count,\
  \ size, ...) over count*sizeof in kmalloc/kzalloc to avoid overflow.\"\n  - Highlight\
  \ the multiplication expression\u2019s source range (the BinaryOperator E).\n  -\
  \ Only one report per call site.\n\n6. Implementation details and utilities usage\n\
  - Utilities:\n  - findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr> to detect\
  \ sizeof anywhere under an operand.\n  - ExprHasName(E, \"array_size\", C) and similar\
  \ to suppress false positives where overflow-checked helpers are used.\n- Robustness:\n\
  \  - Handle implicit casts and parentheses via IgnoreParenImpCasts().\n  - Accept\
  \ both operand orders: sizeof(...) * count and count * sizeof(...).\n  - The same\
  \ logic applies to kmalloc/kzalloc and their devm_*/kv*/vzalloc variants listed\
  \ above; size argument index differs for devm_*.\n\n7. Scope and limitations\n-\
  \ This checker warns on the risky pattern regardless of whether overflow is provably\
  \ possible on a given path. The goal is API misuse (prefer kcalloc/kmalloc_array/kvcalloc).\n\
  - Suppression: If the size expression already uses array_size/struct_size/flex_array_size\
  \ helpers, do not warn."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// No custom program state needed.\n\nnamespace {\n/*\
  \ The checker callbacks are to be decided. */\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Overflow-prone allocation size (use kcalloc)\", \"API\
  \ Misuse\")) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\n   private:\n\n      // Return true if Call is one of the array-aware\
  \ allocators that should be ignored.\n      bool isArrayAwareAllocator(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n      // If Call is a target allocator that\
  \ takes a single total size parameter,\n      // set Idx to the index of that size\
  \ argument and return true.\n      bool getAllocatorSizeArgIndex(const CallEvent\
  \ &Call, unsigned &Idx, CheckerContext &C) const;\n\n      // Returns true if expression\
  \ subtree contains a sizeof(...) (UnaryExprOrTypeTraitExpr of kind SizeOf).\n  \
  \    static bool exprContainsSizeof(const Expr *E);\n\n      // Report helper\n\
  \      void reportMulPattern(const BinaryOperator *Mul, CheckerContext &C) const;\n\
  };\n\nbool SAGenTestChecker::isArrayAwareAllocator(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  const Expr *Orig = Call.getOriginExpr();\n  if (!Orig)\n    return\
  \ false;\n\n  // Ignore calls that already use overflow-safe array helpers.\n  static\
  \ const char *ArrayAware[] = {\n      \"kcalloc\",\n      \"kvcalloc\",\n      \"\
  kmalloc_array\",\n      \"kvmalloc_array\",\n      \"devm_kcalloc\"\n  };\n\n  for\
  \ (const char *Name : ArrayAware) {\n    if (ExprHasName(Orig, Name, C))\n     \
  \ return true;\n  }\n  return false;\n}\n\nbool SAGenTestChecker::getAllocatorSizeArgIndex(const\
  \ CallEvent &Call, unsigned &Idx, CheckerContext &C) const {\n  const Expr *Orig\
  \ = Call.getOriginExpr();\n  if (!Orig)\n    return false;\n\n  // Order matters\
  \ where names can be substrings of others. Keep more specific first.\n  struct Entry\
  \ { const char *Name; unsigned SizeIdx; };\n  static const Entry Targets[] = {\n\
  \      {\"devm_kzalloc\", 1},\n      {\"devm_kmalloc\", 1},\n      {\"kvzalloc\"\
  , 0},\n      {\"kvmalloc\", 0},\n      {\"kzalloc\", 0},\n      {\"kmalloc\", 0},\n\
  \      {\"vzalloc\", 0},\n  };\n\n  for (const auto &E : Targets) {\n    if (ExprHasName(Orig,\
  \ E.Name, C)) {\n      Idx = E.SizeIdx;\n      return true;\n    }\n  }\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::exprContainsSizeof(const Expr *E) {\n  if\
  \ (!E) return false;\n  const Stmt *S = dyn_cast<Stmt>(E);\n  if (!S) return false;\n\
  \n  const auto *UETT = findSpecificTypeInChildren<UnaryExprOrTypeTraitExpr>(S);\n\
  \  if (!UETT) return false;\n  return UETT->getKind() == UETT_SizeOf;\n}\n\nvoid\
  \ SAGenTestChecker::reportMulPattern(const BinaryOperator *Mul, CheckerContext &C)\
  \ const {\n  if (!Mul) return;\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N) return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n   \
  \   *BT,\n      \"Use kcalloc(count, size, ...) instead of count*sizeof in allocation\
  \ to avoid integer overflow\",\n      N);\n  R->addRange(Mul->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  // Ignore non-interesting calls first.\n\
  \  if (isArrayAwareAllocator(Call, C))\n    return;\n\n  unsigned SizeIdx = 0;\n\
  \  if (!getAllocatorSizeArgIndex(Call, SizeIdx, C))\n    return;\n\n  if (Call.getNumArgs()\
  \ <= SizeIdx)\n    return;\n\n  const Expr *SizeE = Call.getArgExpr(SizeIdx);\n\
  \  if (!SizeE)\n    return;\n\n  // Suppress safe helpers used inside size expression.\n\
  \  if (ExprHasName(SizeE, \"array_size\", C) ||\n      ExprHasName(SizeE, \"struct_size\"\
  , C) ||\n      ExprHasName(SizeE, \"flex_array_size\", C))\n    return;\n\n  SizeE\
  \ = SizeE->IgnoreParenImpCasts();\n  const auto *BO = dyn_cast<BinaryOperator>(SizeE);\n\
  \  if (!BO || BO->getOpcode() != BO_Mul)\n    return;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \  const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n  // Look for sizeof(...)\
  \ on either side to match \"count * sizeof(T)\" or \"sizeof(T) * count\"\n  bool\
  \ HasSizeof = exprContainsSizeof(LHS) || exprContainsSizeof(RHS);\n  if (!HasSizeof)\n\
  \    return;\n\n  reportMulPattern(BO, C);\n}\n\n} // end anonymous namespace\n\n\
  extern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects kmalloc/kzalloc-style allocations\
  \ that multiply count by sizeof; suggest kcalloc to avoid overflow\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
