_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: a97de7bff13b1cc825c1b1344eaed8d6c2d3e695
commit_type: Misuse
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include <string>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\nnamespace {\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\
  \ : public Checker<check::PostCall> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Missing optlen validation\
  \ in setsockopt\", \"API Misuse\")) {}\n\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n   private:\n\n      // Returns true if Call\
  \ is a target \"copy_from_sockptr\"-like function that does NOT\n      // enforce/validate\
  \ optlen itself. If true, fills in indices for size and sockptr args.\n      bool\
  \ isCopyFromSockptrLike(const CallEvent &Call, CheckerContext &C,\n            \
  \                     unsigned &SizeArgIdx, unsigned &SockptrArgIdx) const;\n\n\
  \      // Heuristically identify setsockopt-like handlers and optionally locate\
  \ the sockptr and optlen params.\n      bool inSetsockoptContext(const FunctionDecl\
  \ *FD,\n                               const ParmVarDecl *&SockptrParam,\n     \
  \                          const ParmVarDecl *&OptlenParam) const;\n\n      void\
  \ report(const CallEvent &Call, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isCopyFromSockptrLike(const\
  \ CallEvent &Call, CheckerContext &C,\n                                        \
  \     unsigned &SizeArgIdx, unsigned &SockptrArgIdx) const {\n  SizeArgIdx = SockptrArgIdx\
  \ = (unsigned)-1;\n\n  const Expr *Origin = Call.getOriginExpr();\n  // Skip helper\
  \ that enforces optlen\n  if (Origin && ExprHasName(Origin, \"bt_copy_from_sockptr\"\
  , C))\n    return false;\n\n  // Positive matches by origin expr text\n  if (Origin\
  \ && ExprHasName(Origin, \"copy_from_sockptr_offset\", C)) {\n    SockptrArgIdx\
  \ = 1;\n    SizeArgIdx = 3;\n    return true;\n  }\n  if (Origin && ExprHasName(Origin,\
  \ \"copy_from_sockptr\", C)) {\n    SockptrArgIdx = 1;\n    SizeArgIdx = 2;\n  \
  \  return true;\n  }\n\n  // Fallback to callee identifier (in case macro/text is\
  \ transformed)\n  if (const IdentifierInfo *ID = Call.getCalleeIdentifier()) {\n\
  \    StringRef Name = ID->getName();\n    if (Name == \"bt_copy_from_sockptr\")\n\
  \      return false;\n    if (Name == \"copy_from_sockptr_offset\") {\n      SockptrArgIdx\
  \ = 1;\n      SizeArgIdx = 3;\n      return true;\n    }\n    if (Name == \"copy_from_sockptr\"\
  ) {\n      SockptrArgIdx = 1;\n      SizeArgIdx = 2;\n      return true;\n    }\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::inSetsockoptContext(const FunctionDecl\
  \ *FD,\n                                           const ParmVarDecl *&SockptrParam,\n\
  \                                           const ParmVarDecl *&OptlenParam) const\
  \ {\n  SockptrParam = nullptr;\n  OptlenParam = nullptr;\n  if (!FD)\n    return\
  \ false;\n\n  // Name-based heuristic\n  std::string FnName = FD->getNameAsString();\n\
  \  std::string Lower = llvm::StringRef(FnName).lower();\n  bool NameSuggests = (Lower.find(\"\
  setsockopt\") != std::string::npos);\n\n  // Parameter-based heuristic: find sockptr_t\
  \ param and optlen integer param named \"optlen\".\n  for (const ParmVarDecl *P\
  \ : FD->parameters()) {\n    QualType PT = P->getType();\n    std::string TyStr\
  \ = PT.getAsString();\n    if (!SockptrParam && TyStr.find(\"sockptr_t\") != std::string::npos)\
  \ {\n      SockptrParam = P;\n    }\n    if (!OptlenParam && P->getName() == \"\
  optlen\" && PT->isIntegerType()) {\n      OptlenParam = P;\n    }\n  }\n\n  bool\
  \ ParamSuggests = (SockptrParam != nullptr && OptlenParam != nullptr);\n  return\
  \ NameSuggests || ParamSuggests;\n}\n\nvoid SAGenTestChecker::report(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"copy_from_sockptr uses fixed size without validating optlen\"\
  ,\n      N);\n  if (const Stmt *S = Call.getOriginExpr())\n    R->addRange(S->getSourceRange());\n\
  \  R->addNote(\"Use bt_copy_from_sockptr(..., sizeof(obj), optval, optlen) or validate\
  \ optlen == sizeof(obj).\",\n             PathDiagnosticLocation::createBegin(Call.getSourceRange().getBegin(),\
  \ C.getSourceManager()));\n  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  unsigned SizeIdx = 0, SockptrIdx\
  \ = 0;\n  if (!isCopyFromSockptrLike(Call, C, SizeIdx, SockptrIdx))\n    return;\n\
  \n  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());\n\
  \  const ParmVarDecl *SockptrParam = nullptr;\n  const ParmVarDecl *OptlenParam\
  \ = nullptr;\n  if (!inSetsockoptContext(FD, SockptrParam, OptlenParam))\n    return;\n\
  \n  // Argument bounds\n  if (SizeIdx >= Call.getNumArgs() || SockptrIdx >= Call.getNumArgs())\n\
  \    return;\n\n  const Expr *SizeE = Call.getArgExpr(SizeIdx);\n  const Expr *SockptrE\
  \ = Call.getArgExpr(SockptrIdx);\n  if (!SizeE || !SockptrE)\n    return;\n\n  //\
  \ Ensure the source sockptr corresponds to the API's sockptr parameter when we can\
  \ identify it.\n  if (SockptrParam) {\n    if (!ExprHasName(SockptrE, SockptrParam->getName(),\
  \ C))\n      return;\n  }\n\n  // If size mentions optlen directly, consider validated\
  \ and skip.\n  if (OptlenParam) {\n    if (ExprHasName(SizeE, OptlenParam->getName(),\
  \ C))\n      return;\n  }\n\n  // Check for fixed-size usage (constant or sizeof\
  \ in the size expression).\n  llvm::APSInt Dummy;\n  bool IsConst = EvaluateExprToInt(Dummy,\
  \ SizeE, C);\n  bool MentionsSizeof = ExprHasName(SizeE, \"sizeof\", C);\n\n  if\
  \ (!IsConst && !MentionsSizeof)\n    return;\n\n  // All checks indicate a likely\
  \ missing optlen validation.\n  report(Call, C);\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect fixed-size copy_from_sockptr\
  \ in setsockopt without validating optlen\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nBluetooth: RFCOMM: Fix not validating setsockopt user\
  \ input\n\nsyzbot reported rfcomm_sock_setsockopt_old() is copying data without\n\
  checking user input length.\n\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset\n\
  include/linux/sockptr.h:49 [inline]\nBUG: KASAN: slab-out-of-bounds in copy_from_sockptr\n\
  include/linux/sockptr.h:55 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt_old\n\
  net/bluetooth/rfcomm/sock.c:632 [inline]\nBUG: KASAN: slab-out-of-bounds in rfcomm_sock_setsockopt+0x893/0xa70\n\
  net/bluetooth/rfcomm/sock.c:673\nRead of size 4 at addr ffff8880209a8bc3 by task\
  \ syz-executor632/5064\n\nFixes: 9f2c8a03fbb3 (\"Bluetooth: Replace RFCOMM link\
  \ mode with security level\")\nFixes: bb23c0ab8246 (\"Bluetooth: Add support for\
  \ deferring RFCOMM connection setup\")\nReported-by: syzbot <syzkaller@googlegroups.com>\n\
  Signed-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Luiz Augusto von\
  \ Dentz <luiz.von.dentz@intel.com>\n\n## Buggy Code\n\n```c\n// Function: rfcomm_sock_setsockopt\
  \ in net/bluetooth/rfcomm/sock.c\nstatic int rfcomm_sock_setsockopt(struct socket\
  \ *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\
  \tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint err = 0;\n\tsize_t\
  \ len;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\
  \treturn rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level\
  \ != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname)\
  \ {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\
  \t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned\
  \ int, sizeof(sec), optlen);\n\t\tif (copy_from_sockptr(&sec, optval, len)) {\n\t\
  \t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level > BT_SECURITY_HIGH)\
  \ {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\trfcomm_pi(sk)->sec_level =\
  \ sec.level;\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND\
  \ && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\
  \t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\
  \t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\
  \t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\n\t\tbreak;\n\
  \n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\t\
  return err;\n}\n```\n\n```c\n// Function: rfcomm_sock_setsockopt_old in net/bluetooth/rfcomm/sock.c\n\
  static int rfcomm_sock_setsockopt_old(struct socket *sock, int optname,\n\t\tsockptr_t\
  \ optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\
  \tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname)\
  \ {\n\tcase RFCOMM_LM:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\
  \t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_FIPS) {\n\t\
  \t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_AUTH)\n\t\t\t\
  rfcomm_pi(sk)->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & RFCOMM_LM_ENCRYPT)\n\t\
  \t\trfcomm_pi(sk)->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & RFCOMM_LM_SECURE)\n\
  \t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_HIGH;\n\n\t\trfcomm_pi(sk)->role_switch\
  \ = (opt & RFCOMM_LM_MASTER);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\
  \t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n```\n\n## Bug Fix Patch\n\
  \n```diff\ndiff --git a/net/bluetooth/rfcomm/sock.c b/net/bluetooth/rfcomm/sock.c\n\
  index b54e8a530f55..29aa07e9db9d 100644\n--- a/net/bluetooth/rfcomm/sock.c\n+++\
  \ b/net/bluetooth/rfcomm/sock.c\n@@ -629,7 +629,7 @@ static int rfcomm_sock_setsockopt_old(struct\
  \ socket *sock, int optname,\n \n \tswitch (optname) {\n \tcase RFCOMM_LM:\n-\t\t\
  if (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n+\t\tif (bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen)) {\n \t\t\terr = -EFAULT;\n \t\t\tbreak;\n \t\t}\n\
  @@ -664,7 +664,6 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level,\
  \ int optname,\n \tstruct sock *sk = sock->sk;\n \tstruct bt_security sec;\n \t\
  int err = 0;\n-\tsize_t len;\n \tu32 opt;\n \n \tBT_DBG(\"sk %p\", sk);\n@@ -686,11\
  \ +685,9 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level, int\
  \ optname,\n \n \t\tsec.level = BT_SECURITY_LOW;\n \n-\t\tlen = min_t(unsigned int,\
  \ sizeof(sec), optlen);\n-\t\tif (copy_from_sockptr(&sec, optval, len)) {\n-\t\t\
  \terr = -EFAULT;\n+\t\terr = bt_copy_from_sockptr(&sec, sizeof(sec), optval, optlen);\n\
  +\t\tif (err)\n \t\t\tbreak;\n-\t\t}\n \n \t\tif (sec.level > BT_SECURITY_HIGH)\
  \ {\n \t\t\terr = -EINVAL;\n@@ -706,10 +703,9 @@ static int rfcomm_sock_setsockopt(struct\
  \ socket *sock, int level, int optname,\n \t\t\tbreak;\n \t\t}\n \n-\t\tif (copy_from_sockptr(&opt,\
  \ optval, sizeof(u32))) {\n-\t\t\terr = -EFAULT;\n+\t\terr = bt_copy_from_sockptr(&opt,\
  \ sizeof(opt), optval, optlen);\n+\t\tif (err)\n \t\t\tbreak;\n-\t\t}\n \n \t\t\
  if (opt)\n \t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n```\n"
pattern: '## Bug Pattern


  Using copy_from_sockptr() (or similar) with a fixed sizeof(type) in a setsockopt
  handler without validating the provided optlen, leading to reads beyond the caller-provided
  buffer (especially when sockptr is a kernel pointer).


  Anti-pattern:

  - copy_from_sockptr(&obj, optval, sizeof(obj));  // no optlen check


  Correct pattern:

  - if (optlen != sizeof(obj)) return -EINVAL;

  - or use a helper that enforces/validates optlen, e.g. bt_copy_from_sockptr(&obj,
  sizeof(obj), optval, optlen)


  This missing optlen validation can cause slab-out-of-bounds reads or partial/unchecked
  struct copies.'
plan: "1) Program state\n- No custom program states are needed. This checker is a\
  \ local call-site pattern match; we avoid alias/flow tracking to keep it simple\
  \ and robust.\n\n2) Callbacks and implementation steps\n\nA) checkPostCall\nGoal:\
  \ Detect calls to copy_from_sockptr-like APIs in setsockopt handlers where the size\
  \ argument is a fixed sizeof(...) (or other constant) and is not validated against\
  \ the function\u2019s optlen.\n\nImplementation details:\n1. Filter relevant callees:\n\
  \   - Obtain the callee identifier: if it\u2019s not one of:\n     - \"copy_from_sockptr\"\
  \n     - \"copy_from_sockptr_offset\"\n     then return.\n   - If the callee is\
  \ \"bt_copy_from_sockptr\" (or other helper enforcing optlen), return since that\u2019\
  s the correct pattern.\n\n2. Identify the setsockopt-like context:\n   - Get the\
  \ containing function: const FunctionDecl *FD = dyn_cast<FunctionDecl>(C.getLocationContext()->getDecl()).\n\
  \   - If FD is null, return.\n   - Heuristically consider it a setsockopt handler\
  \ if either:\n     - The function name contains \"setsockopt\" (case-insensitive\
  \ compare on FD->getNameAsString()).\n     - OR the function has:\n       - A parameter\
  \ whose type name contains \"sockptr_t\" (use QT.getAsString() or Type printing),\
  \ remember this parameter (SockptrParam).\n       - A parameter named exactly \"\
  optlen\" of integer type (remember this parameter, OptlenParam).\n   - If neither\
  \ heuristic matches, return. We only want to warn in setsockopt-like contexts.\n\
  \n3. Determine argument positions:\n   - For \"copy_from_sockptr\": sizeArgIdx =\
  \ 2, sockptrArgIdx = 1.\n   - For \"copy_from_sockptr_offset\": sizeArgIdx = 3,\
  \ sockptrArgIdx = 1.\n   - Bounds check the indices against Call.getNumArgs(); if\
  \ out of range, return.\n\n4. Extract key expressions:\n   - const Expr *SizeE =\
  \ Call.getArgExpr(sizeArgIdx).\n   - const Expr *SockptrE = Call.getArgExpr(sockptrArgIdx).\n\
  \n5. Ensure we are copying from the externally provided sockptr argument:\n   -\
  \ If SockptrParam was identified in step 2:\n     - If ExprHasName(SockptrE, SockptrParam->getName())\
  \ == false, return.\n       (This avoids warning on internal/local sockptr sources\
  \ not tied to the API parameter.)\n\n6. Check whether size is tied to optlen:\n\
  \   - If OptlenParam was identified in step 2:\n     - If ExprHasName(SizeE, OptlenParam->getName())\
  \ is true, return.\n       (The size calculation mentions optlen; accept as validated.\
  \ This also allows patterns like min(optlen, ...).)\n\n7. Check for fixed-size anti-pattern:\n\
  \   - Use the helper EvaluateExprToInt to see if the size is a compile-time constant:\n\
  \     - llvm::APSInt Dummy; bool IsConst = EvaluateExprToInt(Dummy, SizeE, C).\n\
  \   - Or syntactically detect sizeof usage:\n     - bool MentionsSizeof = ExprHasName(SizeE,\
  \ \"sizeof\").\n   - If neither IsConst nor MentionsSizeof is true, return.\n  \
  \   - This restriction minimizes false positives (e.g., \u201Clen\u201D computed\
  \ elsewhere).\n\n8. Emit a bug report:\n   - Create a BugType once (e.g., \"Missing\
  \ optlen validation in setsockopt\") and reuse it.\n   - Generate a non-fatal error\
  \ node (auto N = C.generateNonFatalErrorNode()).\n   - If N is null, return.\n \
  \  - Create and emit a PathSensitiveBugReport:\n     - Title: \"copy_from_sockptr\
  \ without optlen validation\"\n     - Message: \"Fixed-size copy_from_sockptr not\
  \ checked against optlen; may read past the provided buffer\"\n     - Location:\
  \ at the call expression.\n   - This clearly points the developer to the problematic\
  \ call.\n\nNotes/heuristics applied:\n- We only warn when:\n  - The call is to copy_from_sockptr/copy_from_sockptr_offset.\n\
  \  - The function looks like a setsockopt handler (by name or parameters).\n  -\
  \ The source sockptr argument is the API\u2019s sockptr parameter (e.g., \u2018\
  optval\u2019).\n  - The size argument is a fixed constant/sizeof and does not mention\
  \ optlen.\n- We do not warn when:\n  - bt_copy_from_sockptr() is used.\n  - The\
  \ size argument mentions optlen.\n  - The call is not in a setsockopt-like context.\n\
  \n3) Optional helper utilities (internal to the checker)\n- isCopyFromSockptrLike(const\
  \ CallEvent &Call):\n  - Returns true/false and provides the size argument index\
  \ and the sockptr argument index based on the callee name.\n- inSetsockoptContext(const\
  \ FunctionDecl *FD, ParmVarDecl* &SockptrParam, ParmVarDecl* &OptlenParam):\n  -\
  \ Applies the heuristics described above (function name contains \"setsockopt\"\
  \ OR has both sockptr_t parameter and an integer parameter named \"optlen\").\n\
  - Uses provided utilities:\n  - ExprHasName(...) to check whether the size expression\
  \ mentions \"optlen\" and whether the sockptr argument mentions the sockptr parameter\
  \ name.\n  - EvaluateExprToInt(...) to detect constant sizes.\n\n4) No other callbacks\
  \ needed\n- Do not use checkBranchCondition, checkBind, or states; the checker intentionally\
  \ avoids flow/alias complexity to keep it simple and precise to the target pattern.\n\
  \n5) Reporting message\n- Keep it short and clear:\n  - \"copy_from_sockptr uses\
  \ fixed size without validating optlen\"\n  - Optionally add a short guidance sentence\
  \ in the same message: \"Use bt_copy_from_sockptr(..., sizeof(obj), optval, optlen)\
  \ or validate optlen == sizeof(obj).\""
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include <string>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\nnamespace {\n/* The checker callbacks are to be decided. */\nclass SAGenTestChecker\
  \ : public Checker<check::PostCall> {\n   mutable std::unique_ptr<BugType> BT;\n\
  \n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Missing optlen validation\
  \ in setsockopt\", \"API Misuse\")) {}\n\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n   private:\n\n      // Returns true if Call\
  \ is a target \"copy_from_sockptr\"-like function that does NOT\n      // enforce/validate\
  \ optlen itself. If true, fills in indices for size and sockptr args.\n      bool\
  \ isCopyFromSockptrLike(const CallEvent &Call, CheckerContext &C,\n            \
  \                     unsigned &SizeArgIdx, unsigned &SockptrArgIdx) const;\n\n\
  \      // Heuristically identify setsockopt-like handlers and optionally locate\
  \ the sockptr and optlen params.\n      bool inSetsockoptContext(const FunctionDecl\
  \ *FD,\n                               const ParmVarDecl *&SockptrParam,\n     \
  \                          const ParmVarDecl *&OptlenParam) const;\n\n      void\
  \ report(const CallEvent &Call, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isCopyFromSockptrLike(const\
  \ CallEvent &Call, CheckerContext &C,\n                                        \
  \     unsigned &SizeArgIdx, unsigned &SockptrArgIdx) const {\n  SizeArgIdx = SockptrArgIdx\
  \ = (unsigned)-1;\n\n  const Expr *Origin = Call.getOriginExpr();\n  // Skip helper\
  \ that enforces optlen\n  if (Origin && ExprHasName(Origin, \"bt_copy_from_sockptr\"\
  , C))\n    return false;\n\n  // Positive matches by origin expr text\n  if (Origin\
  \ && ExprHasName(Origin, \"copy_from_sockptr_offset\", C)) {\n    SockptrArgIdx\
  \ = 1;\n    SizeArgIdx = 3;\n    return true;\n  }\n  if (Origin && ExprHasName(Origin,\
  \ \"copy_from_sockptr\", C)) {\n    SockptrArgIdx = 1;\n    SizeArgIdx = 2;\n  \
  \  return true;\n  }\n\n  // Fallback to callee identifier (in case macro/text is\
  \ transformed)\n  if (const IdentifierInfo *ID = Call.getCalleeIdentifier()) {\n\
  \    StringRef Name = ID->getName();\n    if (Name == \"bt_copy_from_sockptr\")\n\
  \      return false;\n    if (Name == \"copy_from_sockptr_offset\") {\n      SockptrArgIdx\
  \ = 1;\n      SizeArgIdx = 3;\n      return true;\n    }\n    if (Name == \"copy_from_sockptr\"\
  ) {\n      SockptrArgIdx = 1;\n      SizeArgIdx = 2;\n      return true;\n    }\n\
  \  }\n\n  return false;\n}\n\nbool SAGenTestChecker::inSetsockoptContext(const FunctionDecl\
  \ *FD,\n                                           const ParmVarDecl *&SockptrParam,\n\
  \                                           const ParmVarDecl *&OptlenParam) const\
  \ {\n  SockptrParam = nullptr;\n  OptlenParam = nullptr;\n  if (!FD)\n    return\
  \ false;\n\n  // Name-based heuristic\n  std::string FnName = FD->getNameAsString();\n\
  \  std::string Lower = llvm::StringRef(FnName).lower();\n  bool NameSuggests = (Lower.find(\"\
  setsockopt\") != std::string::npos);\n\n  // Parameter-based heuristic: find sockptr_t\
  \ param and optlen integer param named \"optlen\".\n  for (const ParmVarDecl *P\
  \ : FD->parameters()) {\n    QualType PT = P->getType();\n    std::string TyStr\
  \ = PT.getAsString();\n    if (!SockptrParam && TyStr.find(\"sockptr_t\") != std::string::npos)\
  \ {\n      SockptrParam = P;\n    }\n    if (!OptlenParam && P->getName() == \"\
  optlen\" && PT->isIntegerType()) {\n      OptlenParam = P;\n    }\n  }\n\n  bool\
  \ ParamSuggests = (SockptrParam != nullptr && OptlenParam != nullptr);\n  return\
  \ NameSuggests || ParamSuggests;\n}\n\nvoid SAGenTestChecker::report(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"copy_from_sockptr uses fixed size without validating optlen\"\
  ,\n      N);\n  if (const Stmt *S = Call.getOriginExpr())\n    R->addRange(S->getSourceRange());\n\
  \n  const SourceManager &SM = C.getSourceManager();\n  const LocationContext *LC\
  \ = C.getLocationContext();\n  const Stmt *SLoc = Call.getOriginExpr();\n  PathDiagnosticLocation\
  \ PDL = SLoc ? PathDiagnosticLocation::createBegin(SLoc, SM, LC)\n             \
  \                       : PathDiagnosticLocation::createBegin(LC->getDecl(), SM);\n\
  \n  R->addNote(\"Use bt_copy_from_sockptr(..., sizeof(obj), optval, optlen) or validate\
  \ optlen == sizeof(obj).\",\n             PDL);\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  unsigned SizeIdx = 0, SockptrIdx = 0;\n  if (!isCopyFromSockptrLike(Call,\
  \ C, SizeIdx, SockptrIdx))\n    return;\n\n  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(C.getLocationContext()->getDecl());\n\
  \  const ParmVarDecl *SockptrParam = nullptr;\n  const ParmVarDecl *OptlenParam\
  \ = nullptr;\n  if (!inSetsockoptContext(FD, SockptrParam, OptlenParam))\n    return;\n\
  \n  // Argument bounds\n  if (SizeIdx >= Call.getNumArgs() || SockptrIdx >= Call.getNumArgs())\n\
  \    return;\n\n  const Expr *SizeE = Call.getArgExpr(SizeIdx);\n  const Expr *SockptrE\
  \ = Call.getArgExpr(SockptrIdx);\n  if (!SizeE || !SockptrE)\n    return;\n\n  //\
  \ Ensure the source sockptr corresponds to the API's sockptr parameter when we can\
  \ identify it.\n  if (SockptrParam) {\n    if (!ExprHasName(SockptrE, SockptrParam->getName(),\
  \ C))\n      return;\n  }\n\n  // If size mentions optlen directly, consider validated\
  \ and skip.\n  if (OptlenParam) {\n    if (ExprHasName(SizeE, OptlenParam->getName(),\
  \ C))\n      return;\n  }\n\n  // Check for fixed-size usage (constant or sizeof\
  \ in the size expression).\n  llvm::APSInt Dummy;\n  bool IsConst = EvaluateExprToInt(Dummy,\
  \ SizeE, C);\n  bool MentionsSizeof = ExprHasName(SizeE, \"sizeof\", C);\n\n  if\
  \ (!IsConst && !MentionsSizeof)\n    return;\n\n  // All checks indicate a likely\
  \ missing optlen validation.\n  report(Call, C);\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect fixed-size copy_from_sockptr\
  \ in setsockopt without validating optlen\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
