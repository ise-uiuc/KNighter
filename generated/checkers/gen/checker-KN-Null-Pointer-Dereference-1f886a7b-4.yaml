_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 1f886a7bfb3faf4c1021e73f045538008ce7634e
commit_type: Null-Pointer-Dereference
index: 4
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// Track unchecked symbols returned\
  \ by devm_kzalloc.\nREGISTER_SET_WITH_PROGRAMSTATE(UncheckedDevmPtrSyms, SymbolRef)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n      check::PostCall,\n\
  \      check::BranchCondition,\n      check::Location\n    > {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"Possible NULL dereference\"\
  , \"Memory Error\")) {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  void checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const;\n  void checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext\
  \ &C) const;\n\nprivate:\n  // Extract the base pointer symbol that is being dereferenced\
  \ by statement S.\n  SymbolRef getDereferencedBaseSymbol(const Stmt *S, SVal Loc,\
  \ CheckerContext &C) const;\n\n  void reportBug(CheckerContext &C, const Stmt *S)\
  \ const;\n};\n\nSymbolRef SAGenTestChecker::getDereferencedBaseSymbol(const Stmt\
  \ *S, SVal Loc,\n                                                      CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  const LocationContext\
  \ *LCtx = C.getLocationContext();\n\n  // Case 1: p->field\n  if (const auto *ME\
  \ = dyn_cast_or_null<MemberExpr>(S)) {\n    if (ME->isArrow()) {\n      const Expr\
  \ *BaseE = ME->getBase();\n      if (BaseE) {\n        SVal BaseV = State->getSVal(BaseE,\
  \ LCtx);\n        if (SymbolRef Sym = BaseV.getAsSymbol())\n          return Sym;\n\
  \        if (const MemRegion *MR = BaseV.getAsRegion()) {\n          MR = MR->getBaseRegion();\n\
  \          if (const auto *SR = dyn_cast<SymbolicRegion>(MR))\n            return\
  \ SR->getSymbol();\n        }\n      }\n    }\n  }\n\n  // Case 2: *p\n  if (const\
  \ auto *UO = dyn_cast_or_null<UnaryOperator>(S)) {\n    if (UO->getOpcode() == UO_Deref)\
  \ {\n      const Expr *BaseE = UO->getSubExpr();\n      if (BaseE) {\n        SVal\
  \ BaseV = State->getSVal(BaseE, LCtx);\n        if (SymbolRef Sym = BaseV.getAsSymbol())\n\
  \          return Sym;\n        if (const MemRegion *MR = BaseV.getAsRegion()) {\n\
  \          MR = MR->getBaseRegion();\n          if (const auto *SR = dyn_cast<SymbolicRegion>(MR))\n\
  \            return SR->getSymbol();\n        }\n      }\n    }\n  }\n\n  // Fallback:\
  \ derive from location region.\n  if (const MemRegion *MR = Loc.getAsRegion()) {\n\
  \    MR = MR->getBaseRegion();\n    if (const auto *SR = dyn_cast<SymbolicRegion>(MR))\n\
  \      return SR->getSymbol();\n  }\n\n  return nullptr;\n}\n\nvoid SAGenTestChecker::reportBug(CheckerContext\
  \ &C, const Stmt *S) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"devm_kzalloc() result may be NULL and is dereferenced without check\"\
  , N);\n  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n\
  \    return;\n\n  // Only track devm_kzalloc results.\n  if (!ExprHasName(OriginExpr,\
  \ \"devm_kzalloc\", C))\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  SVal Ret = Call.getReturnValue();\n  if (SymbolRef Sym = Ret.getAsSymbol()) {\n\
  \    State = State->add<UncheckedDevmPtrSyms>(Sym);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE)\
  \ {\n    return;\n  }\n\n  ProgramStateRef State = C.getState();\n  const LocationContext\
  \ *LCtx = C.getLocationContext();\n  SymbolRef TargetSym = nullptr;\n\n  // Handle:\
  \ if (!ptr)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if (UO->getOpcode()\
  \ == UO_LNot) {\n      const Expr *SubE = UO->getSubExpr();\n      if (SubE) {\n\
  \        SVal SV = State->getSVal(SubE, LCtx);\n        TargetSym = SV.getAsSymbol();\n\
  \      }\n    }\n  }\n  // Handle: if (ptr == NULL) or if (ptr != NULL)\n  else\
  \ if (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr\
  \ *LHS = BO->getLHS();\n      const Expr *RHS = BO->getRHS();\n      if (LHS &&\
  \ RHS) {\n        bool LHSIsNull = LHS->IgnoreParenImpCasts()->isNullPointerConstant(C.getASTContext(),\n\
  \                                         Expr::NPC_ValueDependentIsNull);\n   \
  \     bool RHSIsNull = RHS->IgnoreParenImpCasts()->isNullPointerConstant(C.getASTContext(),\n\
  \                                         Expr::NPC_ValueDependentIsNull);\n   \
  \     const Expr *PtrExpr = nullptr;\n        if (LHSIsNull && !RHSIsNull)\n   \
  \       PtrExpr = RHS;\n        else if (RHSIsNull && !LHSIsNull)\n          PtrExpr\
  \ = LHS;\n\n        if (PtrExpr) {\n          SVal SV = State->getSVal(PtrExpr,\
  \ LCtx);\n          TargetSym = SV.getAsSymbol();\n        }\n      }\n    }\n \
  \ }\n  // Handle: if (ptr)\n  else {\n    SVal SV = State->getSVal(CondE, LCtx);\n\
  \    TargetSym = SV.getAsSymbol();\n  }\n\n  if (TargetSym && State->contains<UncheckedDevmPtrSyms>(TargetSym))\
  \ {\n    State = State->remove<UncheckedDevmPtrSyms>(TargetSym);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt\
  \ *S, CheckerContext &C) const {\n  SymbolRef BaseSym = getDereferencedBaseSymbol(S,\
  \ Loc, C);\n  if (!BaseSym)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  if (State->contains<UncheckedDevmPtrSyms>(BaseSym)) {\n    reportBug(C, S);\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect dereference of devm_kzalloc() result without NULL check\",\n \
  \     \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nspi: mchp-pci1xxx: Fix a possible null pointer dereference\
  \ in pci1xxx_spi_probe\n\nIn function pci1xxxx_spi_probe, there is a potential null\
  \ pointer that\nmay be caused by a failed memory allocation by the function devm_kzalloc.\n\
  Hence, a null pointer check needs to be added to prevent null pointer\ndereferencing\
  \ later in the code.\n\nTo fix this issue, spi_bus->spi_int[iter] should be checked.\
  \ The memory\nallocated by devm_kzalloc will be automatically released, so just\
  \ directly\nreturn -ENOMEM without worrying about memory leaks.\n\nFixes: 1cc0cbea7167\
  \ (\"spi: microchip: pci1xxxx: Add driver for SPI controller of PCI1XXXX PCIe switch\"\
  )\nSigned-off-by: Huai-Yuan Liu <qq810974084@gmail.com>\nLink: https://msgid.link/r/20240403014221.969801-1-qq810974084@gmail.com\n\
  Signed-off-by: Mark Brown <broonie@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ pci1xxxx_spi_probe in drivers/spi/spi-pci1xxxx.c\nstatic int pci1xxxx_spi_probe(struct\
  \ pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tu8 hw_inst_cnt, iter, start,\
  \ only_sec_inst;\n\tstruct pci1xxxx_spi_internal *spi_sub_ptr;\n\tstruct device\
  \ *dev = &pdev->dev;\n\tstruct pci1xxxx_spi *spi_bus;\n\tstruct spi_controller *spi_host;\n\
  \tu32 regval;\n\tint ret;\n\n\thw_inst_cnt = ent->driver_data & 0x0f;\n\tstart =\
  \ (ent->driver_data & 0xf0) >> 4;\n\tif (start == 1)\n\t\tonly_sec_inst = 1;\n\t\
  else\n\t\tonly_sec_inst = 0;\n\n\tspi_bus = devm_kzalloc(&pdev->dev,\n\t\t\t   \
  \    struct_size(spi_bus, spi_int, hw_inst_cnt),\n\t\t\t       GFP_KERNEL);\n\t\
  if (!spi_bus)\n\t\treturn -ENOMEM;\n\n\tspi_bus->dev = pdev;\n\tspi_bus->total_hw_instances\
  \ = hw_inst_cnt;\n\tpci_set_master(pdev);\n\n\tfor (iter = 0; iter < hw_inst_cnt;\
  \ iter++) {\n\t\tspi_bus->spi_int[iter] = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t\t\
  \      sizeof(struct pci1xxxx_spi_internal),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\
  \tspi_sub_ptr = spi_bus->spi_int[iter];\n\t\tspi_sub_ptr->spi_host = devm_spi_alloc_host(dev,\
  \ sizeof(struct spi_controller));\n\t\tif (!spi_sub_ptr->spi_host)\n\t\t\treturn\
  \ -ENOMEM;\n\n\t\tspi_sub_ptr->parent = spi_bus;\n\t\tspi_sub_ptr->spi_xfer_in_progress\
  \ = false;\n\n\t\tif (!iter) {\n\t\t\tret = pcim_enable_device(pdev);\n\t\t\tif\
  \ (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tret = pci_request_regions(pdev, DRV_NAME);\n\
  \t\t\tif (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tspi_bus->reg_base = pcim_iomap(pdev,\
  \ 0, pci_resource_len(pdev, 0));\n\t\t\tif (!spi_bus->reg_base) {\n\t\t\t\tret =\
  \ -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret = pci_alloc_irq_vectors(pdev,\
  \ hw_inst_cnt, hw_inst_cnt,\n\t\t\t\t\t\t    PCI_IRQ_ALL_TYPES);\n\t\t\tif (ret\
  \ < 0) {\n\t\t\t\tdev_err(&pdev->dev, \"Error allocating MSI vectors\\n\");\n\t\t\
  \t\tgoto error;\n\t\t\t}\n\n\t\t\tinit_completion(&spi_sub_ptr->spi_xfer_done);\n\
  \t\t\t/* Initialize Interrupts - SPI_INT */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ +\n\t\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\t\
  regval &= ~SPI_INTR;\n\t\t\twritel(regval, spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\
  \t\t\tspi_sub_ptr->irq = pci_irq_vector(pdev, 0);\n\n\t\t\tret = devm_request_irq(&pdev->dev,\
  \ spi_sub_ptr->irq,\n\t\t\t\t\t       pci1xxxx_spi_isr, PCI1XXXX_IRQ_FLAGS,\n\t\t\
  \t\t\t       pci_name(pdev), spi_sub_ptr);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev,\
  \ \"Unable to request irq : %d\",\n\t\t\t\t\tspi_sub_ptr->irq);\n\t\t\t\tret = -ENODEV;\n\
  \t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret = pci1xxxx_spi_dma_init(spi_bus, spi_sub_ptr->irq);\n\
  \t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\tgoto error;\n\n\t\t\t/* This register\
  \ is only applicable for 1st instance */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ + SPI_PCI_CTRL_REG_OFFSET(0));\n\t\t\tif (!only_sec_inst)\n\t\t\t\tregval |= (BIT(4));\n\
  \t\t\telse\n\t\t\t\tregval &= ~(BIT(4));\n\n\t\t\twritel(regval, spi_bus->reg_base\
  \ + SPI_PCI_CTRL_REG_OFFSET(0));\n\t\t}\n\n\t\tspi_sub_ptr->hw_inst = start++;\n\
  \n\t\tif (iter == 1) {\n\t\t\tinit_completion(&spi_sub_ptr->spi_xfer_done);\n\t\t\
  \t/* Initialize Interrupts - SPI_INT */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\t\
  regval &= ~SPI_INTR;\n\t\t\twritel(regval, spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\
  \t\t\tspi_sub_ptr->irq = pci_irq_vector(pdev, iter);\n\t\t\tret = devm_request_irq(&pdev->dev,\
  \ spi_sub_ptr->irq,\n\t\t\t\t\t       pci1xxxx_spi_isr, PCI1XXXX_IRQ_FLAGS,\n\t\t\
  \t\t\t       pci_name(pdev), spi_sub_ptr);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev,\
  \ \"Unable to request irq : %d\",\n\t\t\t\t\tspi_sub_ptr->irq);\n\t\t\t\tret = -ENODEV;\n\
  \t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tspi_host = spi_sub_ptr->spi_host;\n\t\
  \tspi_host->num_chipselect = SPI_CHIP_SEL_COUNT;\n\t\tspi_host->mode_bits = SPI_MODE_0\
  \ | SPI_MODE_3 | SPI_RX_DUAL |\n\t\t\t\t      SPI_TX_DUAL | SPI_LOOP;\n\t\tspi_host->can_dma\
  \ = pci1xxxx_spi_can_dma;\n\t\tspi_host->transfer_one = pci1xxxx_spi_transfer_one;\n\
  \n\t\tspi_host->set_cs = pci1xxxx_spi_set_cs;\n\t\tspi_host->bits_per_word_mask\
  \ = SPI_BPW_MASK(8);\n\t\tspi_host->max_speed_hz = PCI1XXXX_SPI_MAX_CLOCK_HZ;\n\t\
  \tspi_host->min_speed_hz = PCI1XXXX_SPI_MIN_CLOCK_HZ;\n\t\tspi_host->flags = SPI_CONTROLLER_MUST_TX;\n\
  \t\tspi_controller_set_devdata(spi_host, spi_sub_ptr);\n\t\tret = devm_spi_register_controller(dev,\
  \ spi_host);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\tpci_set_drvdata(pdev, spi_bus);\n\
  \n\treturn 0;\n\nerror:\n\tpci_release_regions(pdev);\n\treturn ret;\n}\n```\n\n\
  ## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/spi/spi-pci1xxxx.c b/drivers/spi/spi-pci1xxxx.c\n\
  index 969965d7bc98..cc18d320370f 100644\n--- a/drivers/spi/spi-pci1xxxx.c\n+++ b/drivers/spi/spi-pci1xxxx.c\n\
  @@ -725,6 +725,8 @@ static int pci1xxxx_spi_probe(struct pci_dev *pdev, const struct\
  \ pci_device_id *\n \t\tspi_bus->spi_int[iter] = devm_kzalloc(&pdev->dev,\n \t\t\
  \t\t\t\t      sizeof(struct pci1xxxx_spi_internal),\n \t\t\t\t\t\t      GFP_KERNEL);\n\
  +\t\tif (!spi_bus->spi_int[iter])\n+\t\t\treturn -ENOMEM;\n \t\tspi_sub_ptr = spi_bus->spi_int[iter];\n\
  \ \t\tspi_sub_ptr->spi_host = devm_spi_alloc_host(dev, sizeof(struct spi_controller));\n\
  \ \t\tif (!spi_sub_ptr->spi_host)\n```\n"
pattern: '## Bug Pattern


  Allocating a per-instance structure with devm_kzalloc() and immediately dereferencing
  it without checking for NULL. If the allocation fails, the subsequent dereference
  causes a NULL pointer dereference.


  Typical pattern:

  ```

  ptr_array[i] = devm_kzalloc(dev, sizeof(*ptr_array[i]), GFP_KERNEL);

  /* Missing: if (!ptr_array[i]) return -ENOMEM; */

  local = ptr_array[i];

  local->field = ...;  // potential NULL dereference

  ```'
plan: "1) Program state customizations\n\n- REGISTER_SET_WITH_PROGRAMSTATE(UncheckedDevmPtrSyms,\
  \ SymbolRef)\n  - Purpose: Track pointer symbols returned from devm_kzalloc that\
  \ have not been NULL-checked yet.\n  - Rationale: Symbols flow through assignments/aliases\
  \ naturally; using SymbolRef avoids complicated alias maps and keeps the logic simple.\
  \ Any later dereference using that symbol (via p->field, *p, etc.) can be detected\
  \ without explicitly tracking every aliasing region.\n\nNo other program state maps/traits\
  \ are needed.\n\n\n2) Callbacks and how to implement them\n\nStep A \u2014 Record\
  \ devm_kzalloc returns as \u201Cmust-check\u201D\n- Callback: checkPostCall\n- What\
  \ to do:\n  - Identify the callee by name \"devm_kzalloc\" (via Call.getCalleeIdentifier()->getName()).\n\
  \  - Obtain the return SVal: SVal Ret = Call.getReturnValue().\n  - Extract the\
  \ SymbolRef: if (const SymbolRef Sym = Ret.getAsSymbol())\n      - State = State->add<UncheckedDevmPtrSyms>(Sym)\n\
  \      - C.addTransition(State)\n- Notes:\n  - We track by symbol so that NULL-checks\
  \ and dereferences on any alias of the returned value are naturally handled without\
  \ an explicit alias map.\n\nStep B \u2014 Consider common NULL-checks as \u201C\
  checked\u201D\n- Callback: checkBranchCondition\n- What to do:\n  - Parse the condition\
  \ and try to get the pointer expression being tested; handle the following shapes:\n\
  \    - UnaryOperator \u2018!\u2019 (UO_LNot): if (isa<UnaryOperator>(Cond) && getOpcode()==UO_LNot),\
  \ get the operand expression E.\n    - BinaryOperator \u2018==\u2019 or \u2018!=\u2019\
  \ with NULL on one side: get the non-NULL operand E.\n    - Plain pointer-as-condition:\
  \ a single Expr E of pointer type (e.g., if (ptr)).\n  - For the identified pointer\
  \ expression E:\n    - SVal V = Ctx.getState()->getSVal(E, Ctx.getLocationContext()).\n\
  \    - SymbolRef Sym = V.getAsSymbol(). If Sym is in UncheckedDevmPtrSyms:\n   \
  \   - Remove it from the set to mark it \u201Cchecked\u201D: State = State->remove<UncheckedDevmPtrSyms>(Sym).\n\
  \      - Ctx.addTransition(State).\n- Notes:\n  - This treats a pointer test as\
  \ a gate that ensures subsequent dereferences are safe on the surviving path(s).\
  \ For simplicity, we mark it checked upon seeing the condition, which is appropriate\
  \ for patterns like if (!p) return -ENOMEM; p->field = ...; found in the kernel.\n\
  \nStep C \u2014 Report dereference of unchecked devm_kzalloc result\n- Callback:\
  \ checkLocation\n- Goal: Detect dereferences of pointers whose symbols are still\
  \ in UncheckedDevmPtrSyms.\n- How:\n  - First try to extract the pointer symbol\
  \ from the AST node S where the load/store happens:\n    - If S is a MemberExpr\
  \ with isArrow()==true, get the base expression BaseE.\n    - Else if S is a UnaryOperator\
  \ with opcode UO_Deref, get its operand BaseE.\n    - Else, fallback to the memory\
  \ region path: if Loc is loc::MemRegionVal MRV, get MRV->getRegion()->getBaseRegion();\
  \ if it is a SymbolicRegion, grab its Symbol.\n  - Compute SVal BaseV = State->getSVal(BaseE,\
  \ C.getLocationContext()); then SymbolRef Sym = BaseV.getAsSymbol() (or from the\
  \ SymbolicRegion fallback).\n  - If Sym is in UncheckedDevmPtrSyms:\n    - Generate\
  \ a non-fatal error node and emit a bug:\n      - Message: \"devm_kzalloc() result\
  \ may be NULL and is dereferenced without check\"\n    - Optionally remove Sym from\
  \ UncheckedDevmPtrSyms to avoid duplicate reports on the same path.\n- Notes:\n\
  \  - This catches the target pattern spi_sub_ptr = spi_bus->spi_int[iter]; spi_sub_ptr->spi_host\
  \ = ...; because the underlying symbol is the same as the devm_kzalloc return and\
  \ will be detected when dereferencing via ->.\n\nStep D \u2014 Optional robustness\
  \ for function calls that dereference pointer params (not required for this pattern)\n\
  - Callback: checkPreCall\n- If you want to be slightly more general, use functionKnownToDeref\
  \ to detect calls that dereference pointer arguments. For each dereferenced param,\
  \ extract its SVal/SymbolRef. If the symbol is in UncheckedDevmPtrSyms, report the\
  \ same bug. This is optional for the requested pattern.\n\n3) Heuristics/Utilities\
  \ to use\n\n- Use Call.getCalleeIdentifier()->getName() == \"devm_kzalloc\" to identify\
  \ the allocator.\n- Use CheckerContext::getState()->getSVal(expr, LC) to get the\
  \ SVal of an expression.\n- Use SVal.getAsSymbol() to map expressions/aliases back\
  \ to the same underlying symbol.\n- If extracting the symbol from the expression\
  \ fails in checkLocation, fallback to the MemRegion path by inspecting loc::MemRegionVal\
  \ and SymbolicRegion.\n- Use the provided findSpecificTypeInParents/findSpecificTypeInChildren\
  \ helpers only if needed to find a base expression for dereference nodes, but prefer\
  \ directly casting S to MemberExpr/UnaryOperator where possible.\n\n4) Bug report\n\
  \n- When reporting in checkLocation (or optional checkPreCall), create a PathSensitiveBugReport\
  \ with a short message:\n  - Title: \"Possible NULL dereference\"\n  - Message:\
  \ \"devm_kzalloc() result may be NULL and is dereferenced without check\"\n- Attach\
  \ the current statement S as the location. Use generateNonFatalErrorNode and C.emitReport.\n\
  \n5) Summary of control flow\n\n- devm_kzalloc return => symbol inserted into UncheckedDevmPtrSyms\
  \ (unchecked).\n- Any NULL-check on any alias of that pointer => the same symbol\
  \ is removed from the set (checked).\n- Any dereference via -> or * using that symbol\
  \ while it remains in the set => report the bug.\n\nThis directly targets the pattern:\n\
  \  ptr_array[i] = devm_kzalloc(...);\n  // missing: if (!ptr_array[i]) return -ENOMEM;\n\
  \  local = ptr_array[i];\n  local->field = ...  // report here."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"\
  clang/AST/Stmt.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing\
  \ namespace ento;\nusing namespace taint;\n\n// Track unchecked symbols returned\
  \ by devm_kzalloc.\nREGISTER_SET_WITH_PROGRAMSTATE(UncheckedDevmPtrSyms, SymbolRef)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n      check::PostCall,\n\
  \      check::BranchCondition,\n      check::Location\n    > {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker() : BT(new BugType(this, \"Possible NULL dereference\"\
  , \"Memory Error\")) {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  void checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const;\n  void checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext\
  \ &C) const;\n\nprivate:\n  // Extract the base pointer symbol that is being dereferenced\
  \ by statement S.\n  SymbolRef getDereferencedBaseSymbol(const Stmt *S, SVal Loc,\
  \ CheckerContext &C) const;\n\n  void reportBug(CheckerContext &C, const Stmt *S)\
  \ const;\n};\n\nSymbolRef SAGenTestChecker::getDereferencedBaseSymbol(const Stmt\
  \ *S, SVal Loc,\n                                                      CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  const LocationContext\
  \ *LCtx = C.getLocationContext();\n\n  // Case 1: p->field\n  if (const auto *ME\
  \ = dyn_cast_or_null<MemberExpr>(S)) {\n    if (ME->isArrow()) {\n      const Expr\
  \ *BaseE = ME->getBase();\n      if (BaseE) {\n        SVal BaseV = State->getSVal(BaseE,\
  \ LCtx);\n        if (SymbolRef Sym = BaseV.getAsSymbol())\n          return Sym;\n\
  \        if (const MemRegion *MR = BaseV.getAsRegion()) {\n          MR = MR->getBaseRegion();\n\
  \          if (const auto *SR = dyn_cast<SymbolicRegion>(MR))\n            return\
  \ SR->getSymbol();\n        }\n      }\n    }\n  }\n\n  // Case 2: *p\n  if (const\
  \ auto *UO = dyn_cast_or_null<UnaryOperator>(S)) {\n    if (UO->getOpcode() == UO_Deref)\
  \ {\n      const Expr *BaseE = UO->getSubExpr();\n      if (BaseE) {\n        SVal\
  \ BaseV = State->getSVal(BaseE, LCtx);\n        if (SymbolRef Sym = BaseV.getAsSymbol())\n\
  \          return Sym;\n        if (const MemRegion *MR = BaseV.getAsRegion()) {\n\
  \          MR = MR->getBaseRegion();\n          if (const auto *SR = dyn_cast<SymbolicRegion>(MR))\n\
  \            return SR->getSymbol();\n        }\n      }\n    }\n  }\n\n  // Fallback:\
  \ derive from location region.\n  if (const MemRegion *MR = Loc.getAsRegion()) {\n\
  \    MR = MR->getBaseRegion();\n    if (const auto *SR = dyn_cast<SymbolicRegion>(MR))\n\
  \      return SR->getSymbol();\n  }\n\n  return nullptr;\n}\n\nvoid SAGenTestChecker::reportBug(CheckerContext\
  \ &C, const Stmt *S) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"devm_kzalloc() result may be NULL and is dereferenced without check\"\
  , N);\n  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  const Expr *OriginExpr = Call.getOriginExpr();\n  if (!OriginExpr)\n\
  \    return;\n\n  // Only track devm_kzalloc results.\n  if (!ExprHasName(OriginExpr,\
  \ \"devm_kzalloc\", C))\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  SVal Ret = Call.getReturnValue();\n  if (SymbolRef Sym = Ret.getAsSymbol()) {\n\
  \    State = State->add<UncheckedDevmPtrSyms>(Sym);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n  if (!CondE)\
  \ {\n    return;\n  }\n\n  ProgramStateRef State = C.getState();\n  const LocationContext\
  \ *LCtx = C.getLocationContext();\n  SymbolRef TargetSym = nullptr;\n\n  // Handle:\
  \ if (!ptr)\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE)) {\n    if (UO->getOpcode()\
  \ == UO_LNot) {\n      const Expr *SubE = UO->getSubExpr();\n      if (SubE) {\n\
  \        SVal SV = State->getSVal(SubE, LCtx);\n        TargetSym = SV.getAsSymbol();\n\
  \      }\n    }\n  }\n  // Handle: if (ptr == NULL) or if (ptr != NULL)\n  else\
  \ if (const auto *BO = dyn_cast<BinaryOperator>(CondE)) {\n    BinaryOperator::Opcode\
  \ Op = BO->getOpcode();\n    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr\
  \ *LHS = BO->getLHS();\n      const Expr *RHS = BO->getRHS();\n      if (LHS &&\
  \ RHS) {\n        bool LHSIsNull = LHS->IgnoreParenImpCasts()->isNullPointerConstant(C.getASTContext(),\n\
  \                                         Expr::NPC_ValueDependentIsNull);\n   \
  \     bool RHSIsNull = RHS->IgnoreParenImpCasts()->isNullPointerConstant(C.getASTContext(),\n\
  \                                         Expr::NPC_ValueDependentIsNull);\n   \
  \     const Expr *PtrExpr = nullptr;\n        if (LHSIsNull && !RHSIsNull)\n   \
  \       PtrExpr = RHS;\n        else if (RHSIsNull && !LHSIsNull)\n          PtrExpr\
  \ = LHS;\n\n        if (PtrExpr) {\n          SVal SV = State->getSVal(PtrExpr,\
  \ LCtx);\n          TargetSym = SV.getAsSymbol();\n        }\n      }\n    }\n \
  \ }\n  // Handle: if (ptr)\n  else {\n    SVal SV = State->getSVal(CondE, LCtx);\n\
  \    TargetSym = SV.getAsSymbol();\n  }\n\n  if (TargetSym && State->contains<UncheckedDevmPtrSyms>(TargetSym))\
  \ {\n    State = State->remove<UncheckedDevmPtrSyms>(TargetSym);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt\
  \ *S, CheckerContext &C) const {\n  SymbolRef BaseSym = getDereferencedBaseSymbol(S,\
  \ Loc, C);\n  if (!BaseSym)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  if (State->contains<UncheckedDevmPtrSyms>(BaseSym)) {\n    reportBug(C, S);\n\
  \  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detect dereference of devm_kzalloc() result without NULL check\",\n \
  \     \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
