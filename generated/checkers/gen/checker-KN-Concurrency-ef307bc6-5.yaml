_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: ef307bc6ef04e8c1ea843231db58e3afaafa9fa6
commit_type: Concurrency
index: 5
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/Expr.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nusing\
  \ namespace clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_SET_WITH_PROGRAMSTATE(HeldLocks,\
  \ const MemRegion*)\nREGISTER_MAP_WITH_PROGRAMSTATE(FieldToLock, const MemRegion*,\
  \ const MemRegion*)\nREGISTER_SET_WITH_PROGRAMSTATE(FieldsUsedUnderLock, const MemRegion*)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::BeginFunction,\n\
  \        check::PostCall,\n        check::BranchCondition,\n        check::Bind>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Clearing pointer field outside lock\", \"Concurrency\"\
  )) {}\n\n      void checkBeginFunction(CheckerContext &C) const;\n      void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      static bool calleeIsOneOf(const CallEvent &Call, CheckerContext &C,\n   \
  \                             std::initializer_list<const char*> Names);\n\n   \
  \   static const MemRegion* getRegionForExpr(const Expr *E, CheckerContext &C);\n\
  \n      static const MemRegion* pickAnyHeldLock(ProgramStateRef State);\n\n    \
  \  static const MemberExpr* findPtrMemberInExpr(const Stmt *S);\n      static const\
  \ MemRegion* getPtrFieldRegionFromStmt(const Stmt *S, CheckerContext &C);\n\n  \
  \    static bool isNullPtrRHS(const Stmt *S, CheckerContext &C, SVal Val);\n\n \
  \     void handleLockAcquire(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void handleLockRelease(const CallEvent &Call, CheckerContext &C) const;\n\
  \n      void recordUseUnderLock(const CallEvent &Call, CheckerContext &C) const;\n\
  \n      void reportRace(const Stmt *Store, CheckerContext &C) const;\n};\n\nbool\
  \ SAGenTestChecker::calleeIsOneOf(const CallEvent &Call, CheckerContext &C,\n  \
  \                                   std::initializer_list<const char*> Names) {\n\
  \  const Expr *OE = Call.getOriginExpr();\n  if (!OE) return false;\n  for (const\
  \ char *N : Names) {\n    if (ExprHasName(OE, N, C))\n      return true;\n  }\n\
  \  return false;\n}\n\nconst MemRegion* SAGenTestChecker::getRegionForExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return nullptr;\n  const MemRegion *MR\
  \ = getMemRegionFromExpr(E, C);\n  if (!MR) return nullptr;\n  MR = MR->getBaseRegion();\n\
  \  return MR;\n}\n\nconst MemRegion* SAGenTestChecker::pickAnyHeldLock(ProgramStateRef\
  \ State) {\n  auto Locks = State->get<HeldLocks>();\n  for (auto I = Locks.begin(),\
  \ E = Locks.end(); I != E; ++I) {\n    if (*I)\n      return *I;\n  }\n  return\
  \ nullptr;\n}\n\nconst MemberExpr* SAGenTestChecker::findPtrMemberInExpr(const Stmt\
  \ *S) {\n  if (!S) return nullptr;\n  const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(S);\n\
  \  if (!ME) return nullptr;\n  QualType QT = ME->getType();\n  if (QT.isNull())\
  \ return nullptr;\n  if (!QT->isPointerType())\n    return nullptr;\n  return ME;\n\
  }\n\nconst MemRegion* SAGenTestChecker::getPtrFieldRegionFromStmt(const Stmt *S,\
  \ CheckerContext &C) {\n  const MemberExpr *ME = findPtrMemberInExpr(S);\n  if (!ME)\
  \ return nullptr;\n  return getRegionForExpr(ME, C);\n}\n\nbool SAGenTestChecker::isNullPtrRHS(const\
  \ Stmt *S, CheckerContext &C, SVal Val) {\n  // Prefer semantic check on RHS if\
  \ this is an assignment.\n  if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S))\
  \ {\n    if (BO->isAssignmentOp()) {\n      const Expr *RHS = BO->getRHS();\n  \
  \    if (RHS && RHS->isNullPointerConstant(C.getASTContext(),\n                \
  \                            Expr::NPC_ValueDependentIsNull)) {\n        return\
  \ true;\n      }\n    }\n  }\n  // Fallback to SVal check: is it a concrete null\
  \ location?\n  if (auto LC = Val.getAs<loc::ConcreteInt>()) {\n    return LC->getValue().isZero();\n\
  \  }\n  if (auto NC = Val.getAs<nonloc::ConcreteInt>()) {\n    return NC->getValue().isZero();\n\
  \  }\n  return false;\n}\n\nvoid SAGenTestChecker::handleLockAcquire(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  // Acquire functions: first argument is the\
  \ lock expression.\n  if (!calleeIsOneOf(Call, C, {\"spin_lock\", \"spin_lock_irqsave\"\
  , \"spin_lock_bh\",\n                               \"mutex_lock\", \"raw_spin_lock\"\
  }))\n    return;\n\n  if (Call.getNumArgs() == 0)\n    return;\n\n  const Expr *Arg0\
  \ = Call.getArgExpr(0);\n  const MemRegion *LR = getRegionForExpr(Arg0, C);\n  if\
  \ (!LR)\n    return;\n\n  ProgramStateRef State = C.getState();\n  State = State->add<HeldLocks>(LR);\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::handleLockRelease(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!calleeIsOneOf(Call, C, {\"\
  spin_unlock\", \"spin_unlock_irqrestore\", \"spin_unlock_bh\",\n               \
  \                \"mutex_unlock\", \"raw_spin_unlock\"}))\n    return;\n\n  if (Call.getNumArgs()\
  \ == 0)\n    return;\n\n  const Expr *Arg0 = Call.getArgExpr(0);\n  const MemRegion\
  \ *LR = getRegionForExpr(Arg0, C);\n  if (!LR)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  State = State->remove<HeldLocks>(LR);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::recordUseUnderLock(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  auto Locks = State->get<HeldLocks>();\n\
  \  bool AnyHeld = (Locks.begin() != Locks.end());\n  if (!AnyHeld)\n    return;\n\
  \n  // Skip if this call itself is a lock/unlock.\n  if (calleeIsOneOf(Call, C,\
  \ {\"spin_lock\", \"spin_lock_irqsave\", \"spin_lock_bh\",\n                   \
  \           \"mutex_lock\", \"raw_spin_lock\",\n                              \"\
  spin_unlock\", \"spin_unlock_irqrestore\", \"spin_unlock_bh\",\n               \
  \               \"mutex_unlock\", \"raw_spin_unlock\"}))\n    return;\n\n  // Determine\
  \ which arguments to inspect. Prefer known-dereferencing params.\n  llvm::SmallVector<unsigned,\
  \ 4> DerefParams;\n  bool HasKnown = functionKnownToDeref(Call, DerefParams);\n\n\
  \  auto processArg = [&](unsigned Idx, ProgramStateRef St) -> ProgramStateRef {\n\
  \    if (Idx >= Call.getNumArgs())\n      return St;\n    const Expr *ArgE = Call.getArgExpr(Idx);\n\
  \    const MemRegion *FR = getPtrFieldRegionFromStmt(ArgE, C);\n    if (!FR)\n \
  \     return St;\n\n    // Only mark as \"used under lock\" if we already know which\
  \ lock protects it\n    // and that lock is currently held.\n    const MemRegion\
  \ *ProtectingLock = St->get<FieldToLock>(FR);\n    if (!ProtectingLock)\n      return\
  \ St;\n\n    bool Holding = false;\n    for (auto I = Locks.begin(), E = Locks.end();\
  \ I != E; ++I) {\n      if (*I == ProtectingLock) { Holding = true; break; }\n \
  \   }\n    if (!Holding)\n      return St;\n\n    St = St->add<FieldsUsedUnderLock>(FR);\n\
  \    return St;\n  };\n\n  if (HasKnown && !DerefParams.empty()) {\n    for (unsigned\
  \ Idx : DerefParams) {\n      State = processArg(Idx, State);\n    }\n  } else {\n\
  \    // Conservatively process all args, but only member pointer fields will match.\n\
  \    for (unsigned i = 0; i < Call.getNumArgs(); ++i) {\n      State = processArg(i,\
  \ State);\n    }\n  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::reportRace(const\
  \ Stmt *Store, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Clearing pointer field outside its lock; may race with locked check/use\
  \ and cause NULL dereference\", N);\n  if (Store)\n    R->addRange(Store->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  // No special initialization needed; state is path-sensitive.\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  // Update lock state\n  handleLockAcquire(Call, C);\n  handleLockRelease(Call,\
  \ C);\n  // Record potential use under lock\n  recordUseUnderLock(Call, C);\n}\n\
  \nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!Condition)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  const MemRegion *Held = pickAnyHeldLock(State);\n  if (!Held)\n    return;\n\n\
  \  // Look for pointer-typed member expr in the condition.\n  const MemRegion *FR\
  \ = getPtrFieldRegionFromStmt(Condition, C);\n  if (!FR)\n    return;\n\n  // If\
  \ not already mapped, associate this field with the currently held lock.\n  if (!State->get<FieldToLock>(FR))\
  \ {\n    State = State->set<FieldToLock>(FR, Held);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  // Only interested in assignments of NULL to a pointer field (member).\n\
  \  if (!S)\n    return;\n\n  if (!isNullPtrRHS(S, C, Val))\n    return;\n\n  const\
  \ auto *BO = dyn_cast<BinaryOperator>(S);\n  if (!BO || !BO->isAssignmentOp())\n\
  \    return;\n\n  const Expr *LHS = BO->getLHS();\n  const MemRegion *FR = getPtrFieldRegionFromStmt(LHS,\
  \ C);\n  if (!FR)\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  //\
  \ The field must have been associated with a protecting lock under which it was\
  \ checked.\n  const MemRegion *ProtectingLock = State->get<FieldToLock>(FR);\n \
  \ if (!ProtectingLock)\n    return;\n\n  // And it must have been actually used\
  \ under that lock.\n  bool WasUsed = false;\n  auto UsedSet = State->get<FieldsUsedUnderLock>();\n\
  \  for (auto I = UsedSet.begin(), E = UsedSet.end(); I != E; ++I) {\n    if (*I\
  \ == FR) { WasUsed = true; break; }\n  }\n  if (!WasUsed)\n    return;\n\n  // Now,\
  \ if we are clearing it to NULL while NOT holding the protecting lock, report.\n\
  \  bool Holding = false;\n  auto Locks = State->get<HeldLocks>();\n  for (auto I\
  \ = Locks.begin(), E = Locks.end(); I != E; ++I) {\n    if (*I == ProtectingLock)\
  \ { Holding = true; break; }\n  }\n  if (!Holding) {\n    reportRace(S, C);\n  }\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects clearing a pointer field to NULL outside its protecting lock\
  \ after it was checked/used under the lock\",\n      \"\");\n}\n\nextern \"C\" const\
  \ char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nusb: dwc2: fix possible NULL pointer dereference caused\
  \ by driver concurrency\n\nIn _dwc2_hcd_urb_enqueue(), \"urb->hcpriv = NULL\" is\
  \ executed without\nholding the lock \"hsotg->lock\". In _dwc2_hcd_urb_dequeue():\n\
  \n    spin_lock_irqsave(&hsotg->lock, flags);\n    ...\n\tif (!urb->hcpriv) {\n\t\
  \tdev_dbg(hsotg->dev, \"## urb->hcpriv is NULL ##\\n\");\n\t\tgoto out;\n\t}\n \
  \   rc = dwc2_hcd_urb_dequeue(hsotg, urb->hcpriv); // Use urb->hcpriv\n    ...\n\
  out:\n    spin_unlock_irqrestore(&hsotg->lock, flags);\n\nWhen _dwc2_hcd_urb_enqueue()\
  \ and _dwc2_hcd_urb_dequeue() are\nconcurrently executed, the NULL check of \"urb->hcpriv\"\
  \ can be executed\nbefore \"urb->hcpriv = NULL\". After urb->hcpriv is NULL, it\
  \ can be used\nin the function call to dwc2_hcd_urb_dequeue(), which can cause a\
  \ NULL\npointer dereference.\n\nThis possible bug is found by an experimental static\
  \ analysis tool\ndeveloped by myself. This tool analyzes the locking APIs to extract\n\
  function pairs that can be concurrently executed, and then analyzes the\ninstructions\
  \ in the paired functions to identify possible concurrency\nbugs including data\
  \ races and atomicity violations. The above possible\nbug is reported, when my tool\
  \ analyzes the source code of Linux 6.5.\n\nTo fix this possible bug, \"urb->hcpriv\
  \ = NULL\" should be executed with\nholding the lock \"hsotg->lock\". After using\
  \ this patch, my tool never\nreports the possible bug, with the kernelconfiguration\
  \ allyesconfig for\nx86_64. Because I have no associated hardware, I cannot test\
  \ the patch\nin runtime testing, and just verify it according to the code logic.\n\
  \nFixes: 33ad261aa62b (\"usb: dwc2: host: spinlock urb_enqueue\")\nSigned-off-by:\
  \ Jia-Ju Bai <baijiaju@buaa.edu.cn>\nLink: https://lore.kernel.org/r/20230926024404.832096-1-baijiaju@buaa.edu.cn\n\
  Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n\n## Buggy Code\n\
  \n```c\n// Function: _dwc2_hcd_urb_enqueue in drivers/usb/dwc2/hcd.c\nstatic int\
  \ _dwc2_hcd_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\t gfp_t mem_flags)\n\
  {\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tstruct usb_host_endpoint\
  \ *ep = urb->ep;\n\tstruct dwc2_hcd_urb *dwc2_urb;\n\tint i;\n\tint retval;\n\t\
  int alloc_bandwidth = 0;\n\tu8 ep_type = 0;\n\tu32 tflags = 0;\n\tvoid *buf;\n\t\
  unsigned long flags;\n\tstruct dwc2_qh *qh;\n\tbool qh_allocated = false;\n\tstruct\
  \ dwc2_qtd *qtd;\n\tstruct dwc2_gregs_backup *gr;\n\n\tgr = &hsotg->gr_backup;\n\
  \n\tif (dbg_urb(urb)) {\n\t\tdev_vdbg(hsotg->dev, \"DWC OTG HCD URB Enqueue\\n\"\
  );\n\t\tdwc2_dump_urb_info(hcd, urb, \"urb_enqueue\");\n\t}\n\n\tif (hsotg->hibernated)\
  \ {\n\t\tif (gr->gotgctl & GOTGCTL_CURMODE_HOST)\n\t\t\tretval = dwc2_exit_hibernation(hsotg,\
  \ 0, 0, 1);\n\t\telse\n\t\t\tretval = dwc2_exit_hibernation(hsotg, 0, 0, 0);\n\n\
  \t\tif (retval)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit hibernation failed.\\\
  n\");\n\t}\n\n\tif (hsotg->in_ppd) {\n\t\tretval = dwc2_exit_partial_power_down(hsotg,\
  \ 0, true);\n\t\tif (retval)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit partial_power_down\
  \ failed\\n\");\n\t}\n\n\tif (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_NONE\
  \ &&\n\t    hsotg->bus_suspended) {\n\t\tif (dwc2_is_device_mode(hsotg))\n\t\t\t\
  dwc2_gadget_exit_clock_gating(hsotg, 0);\n\t\telse\n\t\t\tdwc2_host_exit_clock_gating(hsotg,\
  \ 0);\n\t}\n\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tif (usb_pipetype(urb->pipe) ==\
  \ PIPE_ISOCHRONOUS ||\n\t    usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {\n\t\t\
  spin_lock_irqsave(&hsotg->lock, flags);\n\t\tif (!dwc2_hcd_is_bandwidth_allocated(hsotg,\
  \ ep))\n\t\t\talloc_bandwidth = 1;\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\
  \t}\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_CONTROL:\n\t\tep_type =\
  \ USB_ENDPOINT_XFER_CONTROL;\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\t\tep_type\
  \ = USB_ENDPOINT_XFER_ISOC;\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tep_type = USB_ENDPOINT_XFER_BULK;\n\
  \t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tep_type = USB_ENDPOINT_XFER_INT;\n\t\tbreak;\n\
  \t}\n\n\tdwc2_urb = dwc2_hcd_urb_alloc(hsotg, urb->number_of_packets,\n\t\t\t\t\
  \      mem_flags);\n\tif (!dwc2_urb)\n\t\treturn -ENOMEM;\n\n\tdwc2_hcd_urb_set_pipeinfo(hsotg,\
  \ dwc2_urb, usb_pipedevice(urb->pipe),\n\t\t\t\t  usb_pipeendpoint(urb->pipe), ep_type,\n\
  \t\t\t\t  usb_pipein(urb->pipe),\n\t\t\t\t  usb_endpoint_maxp(&ep->desc),\n\t\t\t\
  \t  usb_endpoint_maxp_mult(&ep->desc));\n\n\tbuf = urb->transfer_buffer;\n\n\tif\
  \ (hcd_uses_dma(hcd)) {\n\t\tif (!buf && (urb->transfer_dma & 3)) {\n\t\t\tdev_err(hsotg->dev,\n\
  \t\t\t\t\"%s: unaligned transfer with no transfer_buffer\",\n\t\t\t\t__func__);\n\
  \t\t\tretval = -EINVAL;\n\t\t\tgoto fail0;\n\t\t}\n\t}\n\n\tif (!(urb->transfer_flags\
  \ & URB_NO_INTERRUPT))\n\t\ttflags |= URB_GIVEBACK_ASAP;\n\tif (urb->transfer_flags\
  \ & URB_ZERO_PACKET)\n\t\ttflags |= URB_SEND_ZERO_PACKET;\n\n\tdwc2_urb->priv =\
  \ urb;\n\tdwc2_urb->buf = buf;\n\tdwc2_urb->dma = urb->transfer_dma;\n\tdwc2_urb->length\
  \ = urb->transfer_buffer_length;\n\tdwc2_urb->setup_packet = urb->setup_packet;\n\
  \tdwc2_urb->setup_dma = urb->setup_dma;\n\tdwc2_urb->flags = tflags;\n\tdwc2_urb->interval\
  \ = urb->interval;\n\tdwc2_urb->status = -EINPROGRESS;\n\n\tfor (i = 0; i < urb->number_of_packets;\
  \ ++i)\n\t\tdwc2_hcd_urb_set_iso_desc_params(dwc2_urb, i,\n\t\t\t\t\t\t urb->iso_frame_desc[i].offset,\n\
  \t\t\t\t\t\t urb->iso_frame_desc[i].length);\n\n\turb->hcpriv = dwc2_urb;\n\tqh\
  \ = (struct dwc2_qh *)ep->hcpriv;\n\t/* Create QH for the endpoint if it doesn't\
  \ exist */\n\tif (!qh) {\n\t\tqh = dwc2_hcd_qh_create(hsotg, dwc2_urb, mem_flags);\n\
  \t\tif (!qh) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail0;\n\t\t}\n\t\tep->hcpriv\
  \ = qh;\n\t\tqh_allocated = true;\n\t}\n\n\tqtd = kzalloc(sizeof(*qtd), mem_flags);\n\
  \tif (!qtd) {\n\t\tretval = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tspin_lock_irqsave(&hsotg->lock,\
  \ flags);\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval)\n\t\tgoto\
  \ fail2;\n\n\tretval = dwc2_hcd_urb_enqueue(hsotg, dwc2_urb, qh, qtd);\n\tif (retval)\n\
  \t\tgoto fail3;\n\n\tif (alloc_bandwidth) {\n\t\tdwc2_allocate_bus_bandwidth(hcd,\n\
  \t\t\t\tdwc2_hcd_get_ep_bandwidth(hsotg, ep),\n\t\t\t\turb);\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock,\
  \ flags);\n\n\treturn 0;\n\nfail3:\n\tdwc2_urb->priv = NULL;\n\tusb_hcd_unlink_urb_from_ep(hcd,\
  \ urb);\n\tif (qh_allocated && qh->channel && qh->channel->qh == qh)\n\t\tqh->channel->qh\
  \ = NULL;\nfail2:\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\turb->hcpriv\
  \ = NULL;\n\tkfree(qtd);\nfail1:\n\tif (qh_allocated) {\n\t\tstruct dwc2_qtd *qtd2,\
  \ *qtd2_tmp;\n\n\t\tep->hcpriv = NULL;\n\t\tdwc2_hcd_qh_unlink(hsotg, qh);\n\t\t\
  /* Free each QTD in the QH's QTD list */\n\t\tlist_for_each_entry_safe(qtd2, qtd2_tmp,\
  \ &qh->qtd_list,\n\t\t\t\t\t qtd_list_entry)\n\t\t\tdwc2_hcd_qtd_unlink_and_free(hsotg,\
  \ qtd2, qh);\n\t\tdwc2_hcd_qh_free(hsotg, qh);\n\t}\nfail0:\n\tkfree(dwc2_urb);\n\
  \n\treturn retval;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/usb/dwc2/hcd.c\
  \ b/drivers/usb/dwc2/hcd.c\nindex 657f1f659ffa..35c7a4df8e71 100644\n--- a/drivers/usb/dwc2/hcd.c\n\
  +++ b/drivers/usb/dwc2/hcd.c\n@@ -4769,8 +4769,8 @@ static int _dwc2_hcd_urb_enqueue(struct\
  \ usb_hcd *hcd, struct urb *urb,\n \tif (qh_allocated && qh->channel && qh->channel->qh\
  \ == qh)\n \t\tqh->channel->qh = NULL;\n fail2:\n-\tspin_unlock_irqrestore(&hsotg->lock,\
  \ flags);\n \turb->hcpriv = NULL;\n+\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\
  \ \tkfree(qtd);\n fail1:\n \tif (qh_allocated) {\n```\n"
pattern: "## Bug Pattern\n\nUpdating a shared pointer field outside the lock that\
  \ protects it, while other code checks and uses that pointer under the lock, causing\
  \ a check-then-use race. Concretely:\n\n- Reader path:\n  - spin_lock(&L);\n  -\
  \ if (obj->ptr) use(obj->ptr);\n  - spin_unlock(&L);\n\n- Writer path:\n  - obj->ptr\
  \ = NULL;   // done without holding L (or after releasing L)\n\nBecause the writer\
  \ clears obj->ptr without holding the same lock L, the reader can observe obj->ptr\
  \ as non-NULL at the check and then have it become NULL before the use, leading\
  \ to a NULL pointer dereference."
plan: "Plan\n\n1) Program state\n\n- REGISTER_SET_WITH_PROGRAMSTATE(HeldLocks, const\
  \ MemRegion*)\n  - Tracks the set of lock objects currently held (e.g., &hsotg->lock).\n\
  \n- REGISTER_MAP_WITH_PROGRAMSTATE(FieldToLock, const MemRegion*, const MemRegion*)\n\
  \  - Maps a specific pointer field region (e.g., region of urb->hcpriv) to the lock\
  \ region under which it has been checked/guarded.\n\n- REGISTER_SET_WITH_PROGRAMSTATE(FieldsUsedUnderLock,\
  \ const MemRegion*)\n  - Tracks fields (same MemRegion* as keys in FieldToLock)\
  \ that are actually used under the lock (e.g., passed to a function or dereferenced)\
  \ after being checked.\n\nRationale:\n- We only warn when all three hold: (a) field\
  \ is known to be protected by a specific lock (FieldToLock), (b) it is actually\
  \ used under that lock (FieldsUsedUnderLock), and (c) it is later cleared to NULL\
  \ while that lock is not held (HeldLocks does not contain the protecting lock).\
  \ This matches the target race with low false positives.\n\n\n2) Helper recognizers\
  \ and utilities\n\n- Recognize lock acquire/release calls:\n  - Acquire names: \"\
  spin_lock\", \"spin_lock_irqsave\", \"spin_lock_bh\", \"mutex_lock\", \"raw_spin_lock\"\
  .\n  - Release names: \"spin_unlock\", \"spin_unlock_irqrestore\", \"spin_unlock_bh\"\
  , \"mutex_unlock\", \"raw_spin_unlock\".\n  - Extract the lock region from the 1st\
  \ argument:\n    - Strip implicit/paren/addr-of (&) from arg0.\n    - Use getMemRegionFromExpr\
  \ on the underlying lock expression (e.g., hsotg->lock).\n    - If a valid MemRegion\
  \ is found, that is the lock identity to add/remove in HeldLocks.\n\n- Extract a\
  \ field region from a MemberExpr:\n  - For expressions like obj->field (MemberExpr),\
  \ call getMemRegionFromExpr to get the FieldRegion. This uniquely identifies (Base,\
  \ FieldDecl) pair and is stable for both reads and writes.\n\n- Detect null constants\
  \ on assignment:\n  - In checkBind, test whether Val is a null pointer constant.\
  \ Prefer SVal predicates (e.g., Val.isZeroConstant() or checking for a loc::ConcreteInt\
  \ with zero). If unavailable, fall back to inspecting the RHS expression via S and\
  \ EvaluateExprToInt to confirm zero.\n\n- Find a pointer field check in a boolean\
  \ condition:\n  - In checkBranchCondition, use findSpecificTypeInChildren<MemberExpr>(Condition)\
  \ to find a MemberExpr used in the condition. If the MemberExpr type is a pointer\
  \ type and the condition is a nullness style test (any of: if (ptr), if (!ptr),\
  \ if (ptr == NULL), if (ptr != NULL)), we treat this as a \u201Ccheck\u201D.\n \
  \   - You can heuristically accept any pointer-typed MemberExpr appearing in the\
  \ condition as a check, which keeps the implementation simple.\n\n\n3) Callback\
  \ functions and logic\n\n- checkBeginFunction\n  - Initialize/clear any per-function\
  \ bookkeeping if needed (optional; the program state is path-sensitive and starts\
  \ empty, but explicitly clearing can help).\n\n- checkPostCall\n  - Lock acquire:\n\
  \    - If the callee is one of the Acquire names, extract the lock region and add\
  \ it to HeldLocks.\n  - Lock release:\n    - If the callee is one of the Release\
  \ names, extract the lock region and remove it from HeldLocks.\n  - Record \u201C\
  use under lock\u201D:\n    - If HeldLocks is non-empty, iterate over call arguments:\n\
  \      - For each argument, find a MemberExpr with findSpecificTypeInChildren<MemberExpr>(ArgExpr).\n\
  \      - If found and its type is a pointer, get its FieldRegion via getMemRegionFromExpr.\n\
  \      - If FieldRegion exists in FieldToLock and the protecting lock for that field\
  \ is still in HeldLocks, add FieldRegion to FieldsUsedUnderLock.\n    - Optionally,\
  \ also use functionKnownToDeref(Call, DerefParams) to further focus only on calls\
  \ that are likely to dereference pointer parameters. If DerefParams is non-empty,\
  \ limit \u201Cuse under lock\u201D recording to arguments at those indices. If no\
  \ deref info is available, conservatively record any pointer field argument as a\
  \ use.\n\n- checkBranchCondition\n  - If HeldLocks is empty, do nothing.\n  - Otherwise,\
  \ find a pointer-typed MemberExpr in the condition (as above).\n    - Compute FieldRegion\
  \ for this MemberExpr.\n    - Choose a protecting lock from HeldLocks (e.g., the\
  \ first one in the set).\n    - Insert FieldToLock[FieldRegion] = ChosenLockRegion\
  \ if not already present.\n  - This marks that this field is guarded/checked under\
  \ the lock within this critical section.\n\n- checkBind\n  - Triggered on all stores\
  \ (assignments).\n  - Extract LHS region:\n    - If Loc.getAsRegion() yields a FieldRegion\
  \ (e.g., urb->hcpriv), call it FR.\n  - Extract assigned value:\n    - If Val is\
  \ a null pointer constant (zero), continue; else return.\n  - Decide if this is\
  \ a \u201Cclear outside lock\u201D:\n    - If FieldToLock contains FR mapped to\
  \ LR (protecting lock), and LR is NOT present in HeldLocks at this program point,\
  \ and FR is present in FieldsUsedUnderLock, then this is the target pattern: clearing\
  \ a field that is checked-and-used under LR, but the clear happens without LR held.\n\
  \    - Report a bug.\n  - Rationale for the FieldsUsedUnderLock requirement: reduces\
  \ false positives by ensuring that the field is not just checked but actually used\
  \ under the lock.\n\n- checkEndFunction\n  - Optional: cleanup/reset per-function\
  \ state (not strictly necessary).\n\n\n4) Bug report\n\n- When the condition in\
  \ checkBind is met, create a non-fatal error node and emit a PathSensitiveBugReport\
  \ with a concise message:\n  - \u201CClearing pointer field outside its lock; may\
  \ race with locked check/use and cause NULL dereference.\u201D\n- Highlight:\n \
  \ - The assignment statement that writes NULL (primary location).\n  - Optionally,\
  \ add a note at the location where the field was checked/used under lock (using\
  \ tracked FieldRegion and last known S) to help the user understand the race pattern.\n\
  \n\n5) Notes and heuristics to keep it simple and effective\n\n- The checker only\
  \ needs intraprocedural reasoning:\n  - If a function checks/uses a field under\
  \ a lock and later clears it to NULL after unlocking (as in the provided patch),\
  \ it will be flagged.\n- Locks identity:\n  - Locks are distinguished by the MemRegion\
  \ obtained from the first argument of the lock/unlock calls. This robustly handles\
  \ cases like &hsotg->lock.\n- Multiple locks:\n  - If multiple locks are held, we\
  \ bind the field to one specific lock present when it was first checked (the field-to-lock\
  \ association). Later clears must hold that same lock to be considered safe.\n-\
  \ Conservatism vs precision:\n  - Requiring both \u201Cchecked under lock\u201D\
  \ and \u201Cused under lock\u201D before flagging keeps the warning focused on the\
  \ check-then-use race pattern instead of all unprotected clears.\n\n\n6) Minimal\
  \ use of provided utilities\n\n- findSpecificTypeInChildren<T>(S): to extract MemberExpr\
  \ from branch conditions and call arguments.\n- getMemRegionFromExpr(E, C): to obtain\
  \ lock MemRegion (from lock API arg) and field MemRegion (from MemberExpr).\n- EvaluateExprToInt:\
  \ only if needed as a fallback to confirm the RHS is zero when detecting null assignments\
  \ (prefer SVal zero checks).\n- functionKnownToDeref: optional precision to only\
  \ record \u201Cuse\u201D for calls that likely dereference pointer arguments.\n\n\
  \n7) Chosen Clang SA callbacks summary\n\n- checkBeginFunction: optional clearing.\n\
  - checkPostCall: handle lock acquire/release; record \u201Cuse under lock\u201D\
  \ for call arguments.\n- checkBranchCondition: record \u201Cchecked under lock\u201D\
  \ mapping FieldToLock.\n- checkBind: detect \u201Cfield = NULL\u201D outside the\
  \ protecting lock and report.\n- checkEndFunction: optional clearing.\n\nThis plan\
  \ directly catches the pattern in the target patch: urb->hcpriv is checked and used\
  \ under spin_lock_irqsave; later, urb->hcpriv = NULL happens after spin_unlock_irqrestore,\
  \ triggering the warning."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/Expr.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include\
  \ <initializer_list>\n#include <memory>\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\nREGISTER_SET_WITH_PROGRAMSTATE(HeldLocks, const\
  \ MemRegion*)\nREGISTER_MAP_WITH_PROGRAMSTATE(FieldToLock, const MemRegion*, const\
  \ MemRegion*)\nREGISTER_SET_WITH_PROGRAMSTATE(FieldsUsedUnderLock, const MemRegion*)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::BeginFunction,\n\
  \        check::PostCall,\n        check::BranchCondition,\n        check::Bind>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Clearing pointer field outside lock\", \"Concurrency\"\
  )) {}\n\n      void checkBeginFunction(CheckerContext &C) const;\n      void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const;\n\n   private:\n      // Helpers\n\
  \      static bool calleeIsOneOf(const CallEvent &Call, CheckerContext &C,\n   \
  \                             std::initializer_list<const char*> Names);\n\n   \
  \   static const MemRegion* getRegionForExpr(const Expr *E, CheckerContext &C);\n\
  \n      static const MemRegion* pickAnyHeldLock(ProgramStateRef State);\n\n    \
  \  static const MemberExpr* findPtrMemberInExpr(const Stmt *S);\n      static const\
  \ MemRegion* getPtrFieldRegionFromStmt(const Stmt *S, CheckerContext &C);\n\n  \
  \    static bool isNullPtrRHS(const Stmt *S, CheckerContext &C, SVal Val);\n\n \
  \     void handleLockAcquire(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void handleLockRelease(const CallEvent &Call, CheckerContext &C) const;\n\
  \n      void recordUseUnderLock(const CallEvent &Call, CheckerContext &C) const;\n\
  \n      void reportRace(const Stmt *Store, CheckerContext &C) const;\n};\n\nbool\
  \ SAGenTestChecker::calleeIsOneOf(const CallEvent &Call, CheckerContext &C,\n  \
  \                                   std::initializer_list<const char*> Names) {\n\
  \  const Expr *OE = Call.getOriginExpr();\n  if (!OE) return false;\n  for (const\
  \ char *N : Names) {\n    if (ExprHasName(OE, N, C))\n      return true;\n  }\n\
  \  return false;\n}\n\nconst MemRegion* SAGenTestChecker::getRegionForExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return nullptr;\n  const MemRegion *MR\
  \ = getMemRegionFromExpr(E, C);\n  if (!MR) return nullptr;\n  MR = MR->getBaseRegion();\n\
  \  return MR;\n}\n\nconst MemRegion* SAGenTestChecker::pickAnyHeldLock(ProgramStateRef\
  \ State) {\n  auto Locks = State->get<HeldLocks>();\n  for (auto I = Locks.begin(),\
  \ E = Locks.end(); I != E; ++I) {\n    if (*I)\n      return *I;\n  }\n  return\
  \ nullptr;\n}\n\nconst MemberExpr* SAGenTestChecker::findPtrMemberInExpr(const Stmt\
  \ *S) {\n  if (!S) return nullptr;\n  const MemberExpr *ME = findSpecificTypeInChildren<MemberExpr>(S);\n\
  \  if (!ME) return nullptr;\n  QualType QT = ME->getType();\n  if (QT.isNull())\
  \ return nullptr;\n  if (!QT->isPointerType())\n    return nullptr;\n  return ME;\n\
  }\n\nconst MemRegion* SAGenTestChecker::getPtrFieldRegionFromStmt(const Stmt *S,\
  \ CheckerContext &C) {\n  const MemberExpr *ME = findPtrMemberInExpr(S);\n  if (!ME)\
  \ return nullptr;\n  return getRegionForExpr(ME, C);\n}\n\nbool SAGenTestChecker::isNullPtrRHS(const\
  \ Stmt *S, CheckerContext &C, SVal Val) {\n  // Prefer semantic check on RHS if\
  \ this is an assignment.\n  if (const auto *BO = dyn_cast_or_null<BinaryOperator>(S))\
  \ {\n    if (BO->isAssignmentOp()) {\n      const Expr *RHS = BO->getRHS();\n  \
  \    if (RHS && RHS->isNullPointerConstant(C.getASTContext(),\n                \
  \                            Expr::NPC_ValueDependentIsNull)) {\n        return\
  \ true;\n      }\n    }\n  }\n  // Fallback to SVal check: is it a concrete null\
  \ location?\n  if (auto LC = Val.getAs<loc::ConcreteInt>()) {\n    return LC->getValue().isZero();\n\
  \  }\n  if (auto NC = Val.getAs<nonloc::ConcreteInt>()) {\n    return NC->getValue().isZero();\n\
  \  }\n  return false;\n}\n\nvoid SAGenTestChecker::handleLockAcquire(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  // Acquire functions: first argument is the\
  \ lock expression.\n  if (!calleeIsOneOf(Call, C, {\"spin_lock\", \"spin_lock_irqsave\"\
  , \"spin_lock_bh\",\n                               \"mutex_lock\", \"raw_spin_lock\"\
  }))\n    return;\n\n  if (Call.getNumArgs() == 0)\n    return;\n\n  const Expr *Arg0\
  \ = Call.getArgExpr(0);\n  const MemRegion *LR = getRegionForExpr(Arg0, C);\n  if\
  \ (!LR)\n    return;\n\n  ProgramStateRef State = C.getState();\n  State = State->add<HeldLocks>(LR);\n\
  \  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::handleLockRelease(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!calleeIsOneOf(Call, C, {\"\
  spin_unlock\", \"spin_unlock_irqrestore\", \"spin_unlock_bh\",\n               \
  \                \"mutex_unlock\", \"raw_spin_unlock\"}))\n    return;\n\n  if (Call.getNumArgs()\
  \ == 0)\n    return;\n\n  const Expr *Arg0 = Call.getArgExpr(0);\n  const MemRegion\
  \ *LR = getRegionForExpr(Arg0, C);\n  if (!LR)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  State = State->remove<HeldLocks>(LR);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::recordUseUnderLock(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  auto Locks = State->get<HeldLocks>();\n\
  \  bool AnyHeld = (Locks.begin() != Locks.end());\n  if (!AnyHeld)\n    return;\n\
  \n  // Skip if this call itself is a lock/unlock.\n  if (calleeIsOneOf(Call, C,\
  \ {\"spin_lock\", \"spin_lock_irqsave\", \"spin_lock_bh\",\n                   \
  \           \"mutex_lock\", \"raw_spin_lock\",\n                              \"\
  spin_unlock\", \"spin_unlock_irqrestore\", \"spin_unlock_bh\",\n               \
  \               \"mutex_unlock\", \"raw_spin_unlock\"}))\n    return;\n\n  // Determine\
  \ which arguments to inspect. Prefer known-dereferencing params.\n  llvm::SmallVector<unsigned,\
  \ 4> DerefParams;\n  bool HasKnown = functionKnownToDeref(Call, DerefParams);\n\n\
  \  auto processArg = [&](unsigned Idx, ProgramStateRef St) -> ProgramStateRef {\n\
  \    if (Idx >= Call.getNumArgs())\n      return St;\n    const Expr *ArgE = Call.getArgExpr(Idx);\n\
  \    const MemRegion *FR = getPtrFieldRegionFromStmt(ArgE, C);\n    if (!FR)\n \
  \     return St;\n\n    // Only mark as \"used under lock\" if we already know which\
  \ lock protects it\n    // and that lock is currently held.\n    const MemRegion\
  \ *ProtectingLock = nullptr;\n    if (const MemRegion *const *PL = St->get<FieldToLock>(FR))\n\
  \      ProtectingLock = *PL;\n    if (!ProtectingLock)\n      return St;\n\n   \
  \ bool Holding = false;\n    for (auto I = Locks.begin(), E = Locks.end(); I !=\
  \ E; ++I) {\n      if (*I == ProtectingLock) { Holding = true; break; }\n    }\n\
  \    if (!Holding)\n      return St;\n\n    St = St->add<FieldsUsedUnderLock>(FR);\n\
  \    return St;\n  };\n\n  if (HasKnown && !DerefParams.empty()) {\n    for (unsigned\
  \ Idx : DerefParams) {\n      State = processArg(Idx, State);\n    }\n  } else {\n\
  \    // Conservatively process all args, but only member pointer fields will match.\n\
  \    for (unsigned i = 0; i < Call.getNumArgs(); ++i) {\n      State = processArg(i,\
  \ State);\n    }\n  }\n\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::reportRace(const\
  \ Stmt *Store, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Clearing pointer field outside its lock; may race with locked check/use\
  \ and cause NULL dereference\", N);\n  if (Store)\n    R->addRange(Store->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBeginFunction(CheckerContext\
  \ &C) const {\n  // No special initialization needed; state is path-sensitive.\n\
  }\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  // Update lock state\n  handleLockAcquire(Call, C);\n  handleLockRelease(Call,\
  \ C);\n  // Record potential use under lock\n  recordUseUnderLock(Call, C);\n}\n\
  \nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!Condition)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  const MemRegion *Held = pickAnyHeldLock(State);\n  if (!Held)\n    return;\n\n\
  \  // Look for pointer-typed member expr in the condition.\n  const MemRegion *FR\
  \ = getPtrFieldRegionFromStmt(Condition, C);\n  if (!FR)\n    return;\n\n  // If\
  \ not already mapped, associate this field with the currently held lock.\n  if (!State->get<FieldToLock>(FR))\
  \ {\n    State = State->set<FieldToLock>(FR, Held);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  // Only interested in assignments of NULL to a pointer field (member).\n\
  \  if (!S)\n    return;\n\n  if (!isNullPtrRHS(S, C, Val))\n    return;\n\n  const\
  \ auto *BO = dyn_cast<BinaryOperator>(S);\n  if (!BO || !BO->isAssignmentOp())\n\
  \    return;\n\n  const Expr *LHS = BO->getLHS();\n  const MemRegion *FR = getPtrFieldRegionFromStmt(LHS,\
  \ C);\n  if (!FR)\n    return;\n\n  ProgramStateRef State = C.getState();\n\n  //\
  \ The field must have been associated with a protecting lock under which it was\
  \ checked.\n  const MemRegion *ProtectingLock = nullptr;\n  if (const MemRegion\
  \ *const *PL = State->get<FieldToLock>(FR))\n    ProtectingLock = *PL;\n  if (!ProtectingLock)\n\
  \    return;\n\n  // And it must have been actually used under that lock.\n  bool\
  \ WasUsed = false;\n  auto UsedSet = State->get<FieldsUsedUnderLock>();\n  for (auto\
  \ I = UsedSet.begin(), E = UsedSet.end(); I != E; ++I) {\n    if (*I == FR) { WasUsed\
  \ = true; break; }\n  }\n  if (!WasUsed)\n    return;\n\n  // Now, if we are clearing\
  \ it to NULL while NOT holding the protecting lock, report.\n  bool Holding = false;\n\
  \  auto Locks = State->get<HeldLocks>();\n  for (auto I = Locks.begin(), E = Locks.end();\
  \ I != E; ++I) {\n    if (*I == ProtectingLock) { Holding = true; break; }\n  }\n\
  \  if (!Holding) {\n    reportRace(S, C);\n  }\n}\n\n} // end anonymous namespace\n\
  \nextern \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects clearing a pointer field to\
  \ NULL outside its protecting lock after it was checked/used under the lock\",\n\
  \      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
