_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: e651faa2fba4d387aa00b3c02e9c10232852d2ef
commit_type: Misuse
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ state is needed.\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unsafe user array duplication size\", \"API Misuse\"\
  )) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \n   private:\n      bool isManualArrayByteCalc(const Expr *E, CheckerContext &C)\
  \ const;\n};\n\nbool SAGenTestChecker::isManualArrayByteCalc(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E)\n    return false;\n\n  const Expr *IE = E->IgnoreParenImpCasts();\n\
  \n  // Pattern 1: explicit use of array_size(...)\n  if (ExprHasName(IE, \"array_size\"\
  , C))\n    return true;\n\n  // Pattern 2: count * sizeof(T) or sizeof(T) * count\n\
  \  const BinaryOperator *BO = dyn_cast<BinaryOperator>(IE);\n  if (!BO) {\n    //\
  \ Search downwards for a multiplication if the immediate node isn't a BO\n    BO\
  \ = findSpecificTypeInChildren<BinaryOperator>(IE);\n  }\n\n  if (BO && BO->getOpcode()\
  \ == BO_Mul) {\n    const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n    const\
  \ Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n\n    const auto *UL = dyn_cast<UnaryExprOrTypeTraitExpr>(L);\n\
  \    const auto *UR = dyn_cast<UnaryExprOrTypeTraitExpr>(R);\n\n    if ((UL && UL->getKind()\
  \ == UETT_SizeOf) ||\n        (UR && UR->getKind() == UETT_SizeOf)) {\n      return\
  \ true;\n    }\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return;\n\n  // Only consider the legacy two-argument functions.\n\
  \  if (Call.getNumArgs() < 2)\n    return;\n\n  bool IsMemdupUser = ExprHasName(Origin,\
  \ \"memdup_user\", C) && Call.getNumArgs() == 2;\n  bool IsVmemdupUser = ExprHasName(Origin,\
  \ \"vmemdup_user\", C) && Call.getNumArgs() == 2;\n\n  if (!IsMemdupUser && !IsVmemdupUser)\n\
  \    return;\n\n  const Expr *SizeArg = Call.getArgExpr(1);\n  if (!SizeArg)\n \
  \   return;\n\n  if (!isManualArrayByteCalc(SizeArg, C))\n    return;\n\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  const char *Msg\
  \ = IsVmemdupUser\n                      ? \"Use vmemdup_array_user() instead of\
  \ manual size multiplication or array_size(); avoids overflow.\"\n             \
  \         : \"Use memdup_array_user() instead of manual size multiplication; avoids\
  \ overflow.\";\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg,\
  \ N);\n  R->addRange(SizeArg->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects manual size calculations passed to memdup_user/vmemdup_user;\
  \ suggest *_array_user variants\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrivers/tty/vt: use standard array-copy-functions\n\
  \ntty/vt currently uses memdup_user() and vmemdup_array_user() to copy\nuserspace\
  \ arrays.\n\nWhereas there is no danger of overflowing, the call to vmemdup_user()\n\
  currently utilizes array_size() to calculate the array size\nnevertheless. This\
  \ is not useful because array_size() would return\nSIZE_MAX and pass it to vmemdup_user()\
  \ in case of (the impossible)\noverflow.\n\nstring.h from the core-API now provides\
  \ the wrappers memdup_array_user()\nand vmemdup_array_user() to copy userspace arrays\
  \ in a standardized\nmanner. Additionally, they also perform generic overflow-checks.\n\
  \nUse these wrappers to make it more obvious and readable that arrays are\nbeing\
  \ copied.\n\nAs we are at it, remove two unnecessary empty lines.\n\nSuggested-by:\
  \ Dave Airlie <airlied@redhat.com>\nSigned-off-by: Philipp Stanner <pstanner@redhat.com>\n\
  Link: https://lore.kernel.org/r/20231103111207.74621-2-pstanner@redhat.com\nSigned-off-by:\
  \ Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ vt_do_diacrit in drivers/tty/vt/keyboard.c\nint vt_do_diacrit(unsigned int cmd,\
  \ void __user *udp, int perm)\n{\n\tunsigned long flags;\n\tint asize;\n\tint ret\
  \ = 0;\n\n\tswitch (cmd) {\n\tcase KDGKBDIACR:\n\t{\n\t\tstruct kbdiacrs __user\
  \ *a = udp;\n\t\tstruct kbdiacr *dia;\n\t\tint i;\n\n\t\tdia = kmalloc_array(MAX_DIACR,\
  \ sizeof(struct kbdiacr),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!dia)\n\t\t\treturn\
  \ -ENOMEM;\n\n\t\t/* Lock the diacriticals table, make a copy and then\n\t\t   copy\
  \ it after we unlock */\n\t\tspin_lock_irqsave(&kbd_event_lock, flags);\n\n\t\t\
  asize = accent_table_size;\n\t\tfor (i = 0; i < asize; i++) {\n\t\t\tdia[i].diacr\
  \ = conv_uni_to_8bit(\n\t\t\t\t\t\taccent_table[i].diacr);\n\t\t\tdia[i].base =\
  \ conv_uni_to_8bit(\n\t\t\t\t\t\taccent_table[i].base);\n\t\t\tdia[i].result = conv_uni_to_8bit(\n\
  \t\t\t\t\t\taccent_table[i].result);\n\t\t}\n\t\tspin_unlock_irqrestore(&kbd_event_lock,\
  \ flags);\n\n\t\tif (put_user(asize, &a->kb_cnt))\n\t\t\tret = -EFAULT;\n\t\telse\
  \  if (copy_to_user(a->kbdiacr, dia,\n\t\t\t\tasize * sizeof(struct kbdiacr)))\n\
  \t\t\tret = -EFAULT;\n\t\tkfree(dia);\n\t\treturn ret;\n\t}\n\tcase KDGKBDIACRUC:\n\
  \t{\n\t\tstruct kbdiacrsuc __user *a = udp;\n\t\tvoid *buf;\n\n\t\tbuf = kmalloc_array(MAX_DIACR,\
  \ sizeof(struct kbdiacruc),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (buf == NULL)\n\
  \t\t\treturn -ENOMEM;\n\n\t\t/* Lock the diacriticals table, make a copy and then\n\
  \t\t   copy it after we unlock */\n\t\tspin_lock_irqsave(&kbd_event_lock, flags);\n\
  \n\t\tasize = accent_table_size;\n\t\tmemcpy(buf, accent_table, asize * sizeof(struct\
  \ kbdiacruc));\n\n\t\tspin_unlock_irqrestore(&kbd_event_lock, flags);\n\n\t\tif\
  \ (put_user(asize, &a->kb_cnt))\n\t\t\tret = -EFAULT;\n\t\telse if (copy_to_user(a->kbdiacruc,\
  \ buf,\n\t\t\t\tasize*sizeof(struct kbdiacruc)))\n\t\t\tret = -EFAULT;\n\t\tkfree(buf);\n\
  \t\treturn ret;\n\t}\n\n\tcase KDSKBDIACR:\n\t{\n\t\tstruct kbdiacrs __user *a =\
  \ udp;\n\t\tstruct kbdiacr *dia = NULL;\n\t\tunsigned int ct;\n\t\tint i;\n\n\t\t\
  if (!perm)\n\t\t\treturn -EPERM;\n\t\tif (get_user(ct, &a->kb_cnt))\n\t\t\treturn\
  \ -EFAULT;\n\t\tif (ct >= MAX_DIACR)\n\t\t\treturn -EINVAL;\n\n\t\tif (ct) {\n\n\
  \t\t\tdia = memdup_user(a->kbdiacr,\n\t\t\t\t\tsizeof(struct kbdiacr) * ct);\n\t\
  \t\tif (IS_ERR(dia))\n\t\t\t\treturn PTR_ERR(dia);\n\n\t\t}\n\n\t\tspin_lock_irqsave(&kbd_event_lock,\
  \ flags);\n\t\taccent_table_size = ct;\n\t\tfor (i = 0; i < ct; i++) {\n\t\t\taccent_table[i].diacr\
  \ =\n\t\t\t\t\tconv_8bit_to_uni(dia[i].diacr);\n\t\t\taccent_table[i].base =\n\t\
  \t\t\t\tconv_8bit_to_uni(dia[i].base);\n\t\t\taccent_table[i].result =\n\t\t\t\t\
  \tconv_8bit_to_uni(dia[i].result);\n\t\t}\n\t\tspin_unlock_irqrestore(&kbd_event_lock,\
  \ flags);\n\t\tkfree(dia);\n\t\treturn 0;\n\t}\n\n\tcase KDSKBDIACRUC:\n\t{\n\t\t\
  struct kbdiacrsuc __user *a = udp;\n\t\tunsigned int ct;\n\t\tvoid *buf = NULL;\n\
  \n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(ct, &a->kb_cnt))\n\t\t\
  \treturn -EFAULT;\n\n\t\tif (ct >= MAX_DIACR)\n\t\t\treturn -EINVAL;\n\n\t\tif (ct)\
  \ {\n\t\t\tbuf = memdup_user(a->kbdiacruc,\n\t\t\t\t\t  ct * sizeof(struct kbdiacruc));\n\
  \t\t\tif (IS_ERR(buf))\n\t\t\t\treturn PTR_ERR(buf);\n\t\t} \n\t\tspin_lock_irqsave(&kbd_event_lock,\
  \ flags);\n\t\tif (ct)\n\t\t\tmemcpy(accent_table, buf,\n\t\t\t\t\tct * sizeof(struct\
  \ kbdiacruc));\n\t\taccent_table_size = ct;\n\t\tspin_unlock_irqrestore(&kbd_event_lock,\
  \ flags);\n\t\tkfree(buf);\n\t\treturn 0;\n\t}\n\t}\n\treturn ret;\n}\n```\n\n```c\n\
  // Function: con_set_unimap in drivers/tty/vt/consolemap.c\nint con_set_unimap(struct\
  \ vc_data *vc, ushort ct, struct unipair __user *list)\n{\n\tint err = 0, err1;\n\
  \tstruct uni_pagedict *dict;\n\tstruct unipair *unilist, *plist;\n\n\tif (!ct)\n\
  \t\treturn 0;\n\n\tunilist = vmemdup_user(list, array_size(sizeof(*unilist), ct));\n\
  \tif (IS_ERR(unilist))\n\t\treturn PTR_ERR(unilist);\n\n\tconsole_lock();\n\n\t\
  /* Save original vc_unipagdir_loc in case we allocate a new one */\n\tdict = *vc->uni_pagedict_loc;\n\
  \tif (!dict) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (dict->refcount\
  \ > 1) {\n\t\tdict = con_unshare_unimap(vc, dict);\n\t\tif (IS_ERR(dict)) {\n\t\t\
  \terr = PTR_ERR(dict);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else if (dict == dflt)\
  \ {\n\t\tdflt = NULL;\n\t}\n\n\t/*\n\t * Insert user specified unicode pairs into\
  \ new table.\n\t */\n\tfor (plist = unilist; ct; ct--, plist++) {\n\t\terr1 = con_insert_unipair(dict,\
  \ plist->unicode, plist->fontpos);\n\t\tif (err1)\n\t\t\terr = err1;\n\t}\n\n\t\
  /*\n\t * Merge with fontmaps of any other virtual consoles.\n\t */\n\tif (con_unify_unimap(vc,\
  \ dict))\n\t\tgoto out_unlock;\n\n\tfor (enum translation_map m = FIRST_MAP; m <=\
  \ LAST_MAP; m++)\n\t\tset_inverse_transl(vc, dict, m);\n\tset_inverse_trans_unicode(dict);\n\
  \nout_unlock:\n\tconsole_unlock();\n\tkvfree(unilist);\n\treturn err;\n}\n```\n\n\
  ## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/tty/vt/consolemap.c b/drivers/tty/vt/consolemap.c\n\
  index 5e39a4f430ee..82d70083fead 100644\n--- a/drivers/tty/vt/consolemap.c\n+++\
  \ b/drivers/tty/vt/consolemap.c\n@@ -644,7 +644,7 @@ int con_set_unimap(struct vc_data\
  \ *vc, ushort ct, struct unipair __user *list)\n \tif (!ct)\n \t\treturn 0;\n \n\
  -\tunilist = vmemdup_user(list, array_size(sizeof(*unilist), ct));\n+\tunilist =\
  \ vmemdup_array_user(list, ct, sizeof(*unilist));\n \tif (IS_ERR(unilist))\n \t\t\
  return PTR_ERR(unilist);\n \ndiff --git a/drivers/tty/vt/keyboard.c b/drivers/tty/vt/keyboard.c\n\
  index 12a192e1196b..a2116e135a82 100644\n--- a/drivers/tty/vt/keyboard.c\n+++ b/drivers/tty/vt/keyboard.c\n\
  @@ -1772,12 +1772,10 @@ int vt_do_diacrit(unsigned int cmd, void __user *udp, int\
  \ perm)\n \t\t\treturn -EINVAL;\n \n \t\tif (ct) {\n-\n-\t\t\tdia = memdup_user(a->kbdiacr,\n\
  -\t\t\t\t\tsizeof(struct kbdiacr) * ct);\n+\t\t\tdia = memdup_array_user(a->kbdiacr,\n\
  +\t\t\t\t\t\tct, sizeof(struct kbdiacr));\n \t\t\tif (IS_ERR(dia))\n \t\t\t\treturn\
  \ PTR_ERR(dia);\n-\n \t\t}\n \n \t\tspin_lock_irqsave(&kbd_event_lock, flags);\n\
  @@ -1811,8 +1809,8 @@ int vt_do_diacrit(unsigned int cmd, void __user *udp, int\
  \ perm)\n \t\t\treturn -EINVAL;\n \n \t\tif (ct) {\n-\t\t\tbuf = memdup_user(a->kbdiacruc,\n\
  -\t\t\t\t\t  ct * sizeof(struct kbdiacruc));\n+\t\t\tbuf = memdup_array_user(a->kbdiacruc,\n\
  +\t\t\t\t\t\tct, sizeof(struct kbdiacruc));\n \t\t\tif (IS_ERR(buf))\n \t\t\t\t\
  return PTR_ERR(buf);\n \t\t} \n```\n"
pattern: '## Bug Pattern


  Manually computing the byte size for duplicating a user-provided array and passing
  it to memdup_user()/vmemdup_user(), e.g.:


  - ptr = memdup_user(userp, count * sizeof(*userp));

  - ptr = vmemdup_user(userp, array_size(count, sizeof(*userp)));


  This risks integer overflow in the size calculation. In particular, array_size()
  returns SIZE_MAX on overflow, but vmemdup_user() does not treat SIZE_MAX as an overflow
  indicator and will attempt a huge allocation instead of failing cleanly. The correct
  pattern is to use memdup_array_user()/vmemdup_array_user(), which perform checked
  multiplication and properly detect/handle overflows.'
plan: "1) Program state\n- No custom program state is needed. The bug is detectable\
  \ purely from the call syntax/AST of a single call site.\n\n2) Callback functions\n\
  - Use only checkPreCall. This is sufficient to inspect each call, identify unsafe\
  \ size expressions, and report.\n\n3) Detailed implementation\n\nA. Recognize the\
  \ target functions\n- In checkPreCall, get the callee identifier:\n  - const IdentifierInfo\
  \ *ID = Call.getCalleeIdentifier(); if (!ID) return;\n  - StringRef Name = ID->getName();\n\
  - If Name is not exactly \"memdup_user\" or \"vmemdup_user\", return; otherwise\
  \ continue.\n- Do not warn for memdup_array_user/vmemdup_array_user; we only target\
  \ the legacy functions above.\n\nB. Extract arguments and pattern-match the size\
  \ expression\n- These APIs have the following signatures:\n  - memdup_user(void\
  \ __user *src, size_t len)\n  - vmemdup_user(const void __user *src, size_t len)\n\
  - Size argument index is 1. Get the size expression:\n  - const Expr *SizeArg =\
  \ Call.getArgExpr(1);\n\nC. Detect \u201Cmanual array size multiplication\u201D\
  \ or use of array_size()\n- Implement a small helper inside the checker:\n\n  bool\
  \ isManualArrayByteCalc(const Expr *E, CheckerContext &C) {\n    if (!E) return\
  \ false;\n    E = E->IgnoreParenImpCasts();\n\n    // 1) array_size(...) detected\
  \ via source text\n    if (ExprHasName(E, \"array_size\"))\n      return true;\n\
  \n    // 2) count * sizeof(T) or sizeof(T) * count\n    // Find any BinaryOperator\
  \ under this expression\n    if (const auto *BO = findSpecificTypeInChildren<BinaryOperator>(E))\
  \ {\n      if (BO->getOpcode() == BO_Mul) {\n        const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n\
  \        const Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n        if (isa<UnaryExprOrTypeTraitExpr>(L)\
  \ || isa<UnaryExprOrTypeTraitExpr>(R)) {\n          // UnaryExprOrTypeTraitExpr\
  \ with kind UETT_SizeOf is what we want\n          const auto *U1 = dyn_cast<UnaryExprOrTypeTraitExpr>(L);\n\
  \          const auto *U2 = dyn_cast<UnaryExprOrTypeTraitExpr>(R);\n          if\
  \ ((U1 && U1->getKind() == UETT_SizeOf) ||\n              (U2 && U2->getKind() ==\
  \ UETT_SizeOf))\n            return true;\n        }\n      }\n    }\n\n    return\
  \ false;\n  }\n\n- Rationale:\n  - We catch the common unsafe pattern: ct * sizeof(T)\
  \ or sizeof(T) * ct.\n  - We also catch the explicit usage of array_size(...) via\
  \ ExprHasName, which is sufficient since array_size is a macro/function-like construct\
  \ whose name appears in the source text even if it expands away in the AST.\n\n\
  D. Generate the diagnostic when found\n- If isManualArrayByteCalc(SizeArg, C) returns\
  \ true:\n  - Create (or reuse) a BugType:\n    - e.g., std::unique_ptr<BugType>\
  \ BT = std::make_unique<BugType>(this, \"Unsafe user array duplication size\", \"\
  API Misuse\");\n    - Store BT as a member to reuse.\n  - Generate a non-fatal error\
  \ node: ExplodedNode *N = C.generateNonFatalErrorNode();\n  - If N is null, return.\n\
  \  - Form a short, clear message:\n    - If Name == \"vmemdup_user\":\n      \"\
  Use vmemdup_array_user() instead of manual size multiplication or array_size();\
  \ avoids overflow.\"\n    - Else (Name == \"memdup_user\"):\n      \"Use memdup_array_user()\
  \ instead of manual size multiplication; avoids overflow.\"\n  - Create and emit\
  \ report:\n    - auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg, N);\n\
  \    - R->addRange(SizeArg->getSourceRange());\n    - C.emitReport(std::move(R));\n\
  \nE. Notes to reduce false positives (already covered by pattern):\n- We do not\
  \ warn when the safer wrappers are already used, because we only match memdup_user/vmemdup_user.\n\
  - We require either:\n  - A binary \u2018*\u2019 that includes a sizeof(...) on\
  \ one side, or\n  - The source text contains \"array_size(\".\n  This keeps the\
  \ checker specific to the target pattern and reduces noise.\n- No need to model\
  \ values or perform assumptions; this checker is syntactic/structural.\n\n4) Summary\
  \ of the flow\n- checkPreCall:\n  - If callee is memdup_user or vmemdup_user:\n\
  \    - Analyze argument #1 (size).\n    - If size is built by count * sizeof(T)\
  \ (any order), or contains array_size(...), report:\n      - Suggest memdup_array_user()\
  \ for memdup_user.\n      - Suggest vmemdup_array_user() for vmemdup_user.\n\n5)\
  \ Utility functions used\n- findSpecificTypeInChildren to locate a BinaryOperator\
  \ under the size expression.\n- ExprHasName to detect presence of \u201Carray_size(\u201D\
  \ in the original source text."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ state is needed.\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Unsafe user array duplication size\", \"API Misuse\"\
  )) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \n   private:\n      bool isManualArrayByteCalc(const Expr *E, CheckerContext &C)\
  \ const;\n};\n\nbool SAGenTestChecker::isManualArrayByteCalc(const Expr *E, CheckerContext\
  \ &C) const {\n  if (!E)\n    return false;\n\n  const Expr *IE = E->IgnoreParenImpCasts();\n\
  \n  // Pattern 1: explicit use of array_size(...)\n  if (ExprHasName(IE, \"array_size\"\
  , C))\n    return true;\n\n  // Pattern 2: count * sizeof(T) or sizeof(T) * count\n\
  \  const BinaryOperator *BO = dyn_cast<BinaryOperator>(IE);\n  if (!BO) {\n    //\
  \ Search downwards for a multiplication if the immediate node isn't a BO\n    BO\
  \ = findSpecificTypeInChildren<BinaryOperator>(IE);\n  }\n\n  if (BO && BO->getOpcode()\
  \ == BO_Mul) {\n    const Expr *L = BO->getLHS()->IgnoreParenImpCasts();\n    const\
  \ Expr *R = BO->getRHS()->IgnoreParenImpCasts();\n\n    const auto *UL = dyn_cast<UnaryExprOrTypeTraitExpr>(L);\n\
  \    const auto *UR = dyn_cast<UnaryExprOrTypeTraitExpr>(R);\n\n    if ((UL && UL->getKind()\
  \ == UETT_SizeOf) ||\n        (UR && UR->getKind() == UETT_SizeOf)) {\n      return\
  \ true;\n    }\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return;\n\n  // Only consider the legacy two-argument functions.\n\
  \  if (Call.getNumArgs() < 2)\n    return;\n\n  bool IsMemdupUser = ExprHasName(Origin,\
  \ \"memdup_user\", C) && Call.getNumArgs() == 2;\n  bool IsVmemdupUser = ExprHasName(Origin,\
  \ \"vmemdup_user\", C) && Call.getNumArgs() == 2;\n\n  if (!IsMemdupUser && !IsVmemdupUser)\n\
  \    return;\n\n  const Expr *SizeArg = Call.getArgExpr(1);\n  if (!SizeArg)\n \
  \   return;\n\n  if (!isManualArrayByteCalc(SizeArg, C))\n    return;\n\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  const char *Msg\
  \ = IsVmemdupUser\n                      ? \"Use vmemdup_array_user() instead of\
  \ manual size multiplication or array_size(); avoids overflow.\"\n             \
  \         : \"Use memdup_array_user() instead of manual size multiplication; avoids\
  \ overflow.\";\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg,\
  \ N);\n  R->addRange(SizeArg->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects manual size calculations passed to memdup_user/vmemdup_user;\
  \ suggest *_array_user variants\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 2
tp_score: 2
