_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: d313eb8b77557a6d5855f42d2234bd592c7b50dd
commit_type: Uninit-Data
index: 4
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Attr.h\"\n#include \"\
  clang/AST/Decl.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/RecordLayout.h\"\
  \n#include \"clang/AST/Type.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <utility>\n\
  \nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program\
  \ state maps\nREGISTER_MAP_WITH_PROGRAMSTATE(ZeroedStructs, const MemRegion *, bool)\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion *, const MemRegion *)\n\
  \nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::Bind,\n\
  \        check::PostCall,\n        check::PreCall> {\n\n  mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this,\n         \
  \              \"Kernel info leak: copying stack struct with padding\",\n      \
  \                 \"Security\")) {}\n\n  void checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const;\n  void checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n  void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\nprivate:\n  // Helpers\n  const VarRegion *resolveBaseStructVarRegion(const\
  \ Expr *PtrArg,\n                                              CheckerContext &C)\
  \ const;\n  bool lenMatchesStructSize(const Expr *LenArg, QualType StructTy,\n \
  \                           CheckerContext &C) const;\n  bool recordHasImplicitPadding(const\
  \ RecordDecl *RD,\n                                ASTContext &AC) const;\n  bool\
  \ isZeroingCall(const CallEvent &Call,\n                     unsigned &PtrIdx, unsigned\
  \ &ValIdx, unsigned &LenIdx,\n                     bool &ValueIsZero, bool &NeedValueCheck)\
  \ const;\n  bool isCopyOutCall(const CallEvent &Call,\n                     unsigned\
  \ &LenIdx, unsigned &PtrIdx,\n                     CheckerContext &C) const;\n};\n\
  \n// Return the base VarRegion of a local struct variable that PtrArg refers to,\n\
  // optionally via a pointer alias. Returns nullptr if not resolvable.\nconst VarRegion\
  \ *SAGenTestChecker::resolveBaseStructVarRegion(const Expr *PtrArg,\n          \
  \                                                    CheckerContext &C) const {\n\
  \  if (!PtrArg)\n    return nullptr;\n\n  const MemRegion *R = getMemRegionFromExpr(PtrArg,\
  \ C);\n  if (!R)\n    return nullptr;\n\n  R = R->getBaseRegion();\n  if (!R)\n\
  \    return nullptr;\n\n  ProgramStateRef State = C.getState();\n\n  // If R is\
  \ a VarRegion, check if it is a local struct variable directly.\n  if (const auto\
  \ *VR = dyn_cast<VarRegion>(R)) {\n    const VarDecl *VD = VR->getDecl();\n    if\
  \ (!VD)\n      return nullptr;\n\n    if (VD->isLocalVarDecl() && !VD->hasGlobalStorage())\
  \ {\n      QualType QT = VD->getType();\n      if (const RecordType *RT = QT->getAs<RecordType>())\
  \ {\n        if (const RecordDecl *RD = dyn_cast_or_null<RecordDecl>(RT->getDecl()))\
  \ {\n          if (RD->isStruct())\n            return VR;\n        }\n      }\n\
  \    }\n\n    // If it's a local pointer var, try alias map.\n    if (VD->getType()->isPointerType())\
  \ {\n      const MemRegion *Aliased = State->get<PtrAliasMap>(VR);\n      if (const\
  \ auto *AliasedVR = dyn_cast_or_null<VarRegion>(Aliased)) {\n        const VarDecl\
  \ *AVD = AliasedVR->getDecl();\n        if (!AVD)\n          return nullptr;\n \
  \       if (AVD->isLocalVarDecl() && !AVD->hasGlobalStorage()) {\n          QualType\
  \ QT = AVD->getType();\n          if (const RecordType *RT = QT->getAs<RecordType>())\
  \ {\n            if (const RecordDecl *RD = dyn_cast_or_null<RecordDecl>(RT->getDecl()))\
  \ {\n              if (RD->isStruct())\n                return AliasedVR;\n    \
  \        }\n          }\n        }\n      }\n    }\n  }\n\n  // Not a direct VarRegion\
  \ or couldn't resolve to a struct var.\n  return nullptr;\n}\n\n// Check if LenArg\
  \ equals sizeof(StructTy).\nbool SAGenTestChecker::lenMatchesStructSize(const Expr\
  \ *LenArg,\n                                            QualType StructTy,\n   \
  \                                         CheckerContext &C) const {\n  if (!LenArg)\n\
  \    return false;\n\n  ASTContext &AC = C.getASTContext();\n  QualType CanonStructTy\
  \ = AC.getCanonicalType(StructTy);\n\n  const Expr *LE = LenArg->IgnoreParenCasts();\n\
  \  if (const auto *U = dyn_cast<UnaryExprOrTypeTraitExpr>(LE)) {\n    if (U->getKind()\
  \ == UETT_SizeOf) {\n      QualType SizeofTy;\n      if (U->isArgumentType())\n\
  \        SizeofTy = U->getArgumentType();\n      else if (const Expr *ArgE = U->getArgumentExpr())\n\
  \        SizeofTy = ArgE->getType();\n\n      if (!SizeofTy.isNull()) {\n      \
  \  QualType CanonSizeofTy = AC.getCanonicalType(SizeofTy);\n        if (AC.hasSameUnqualifiedType(CanonSizeofTy,\
  \ CanonStructTy))\n          return true;\n      }\n    }\n  }\n\n  // Fallback:\
  \ evaluate LenArg to int and compare to size in bytes.\n  llvm::APSInt LenVal;\n\
  \  if (EvaluateExprToInt(LenVal, LenArg, C)) {\n    uint64_t Len = LenVal.getZExtValue();\n\
  \    uint64_t StructSize = AC.getTypeSizeInChars(StructTy).getQuantity();\n    return\
  \ Len == StructSize;\n  }\n\n  return false;\n}\n\n// Determine whether a record\
  \ has implicit padding (interior or trailing).\nbool SAGenTestChecker::recordHasImplicitPadding(const\
  \ RecordDecl *RD,\n                                                ASTContext &AC)\
  \ const {\n  if (!RD)\n    return false;\n  if (!RD->isStruct())\n    return false;\n\
  \  RD = RD->getDefinition();\n  if (!RD)\n    return false;\n\n  const ASTRecordLayout\
  \ &L = AC.getASTRecordLayout(RD);\n\n  uint64_t LastEndBits = 0;\n  unsigned Index\
  \ = 0;\n  for (const FieldDecl *FD : RD->fields()) {\n    if (!FD)\n      continue;\n\
  \    uint64_t FieldOffsetBits = L.getFieldOffset(Index);\n    uint64_t FieldSizeBits\
  \ = AC.getTypeSize(FD->getType());\n    if (FieldOffsetBits > LastEndBits)\n   \
  \   return true; // interior padding\n    LastEndBits = FieldOffsetBits + FieldSizeBits;\n\
  \    ++Index;\n  }\n\n  uint64_t TotalBits = L.getSize().getQuantity() * 8ULL;\n\
  \  if (TotalBits > LastEndBits)\n    return true; // trailing padding\n\n  return\
  \ false;\n}\n\n// Identify zeroing calls. Returns true and fills indices if recognized.\n\
  // For memset/__builtin_memset: PtrIdx=0, ValIdx=1, LenIdx=2, NeedValueCheck=true,\
  \ ValueIsZero if value is proven zero.\n// For memzero_explicit: PtrIdx=0, LenIdx=1,\
  \ NeedValueCheck=false (implicitly zero).\n// For bzero: PtrIdx=0, LenIdx=1, NeedValueCheck=false\
  \ (implicitly zero).\nbool SAGenTestChecker::isZeroingCall(const CallEvent &Call,\n\
  \                                     unsigned &PtrIdx, unsigned &ValIdx, unsigned\
  \ &LenIdx,\n                                     bool &ValueIsZero, bool &NeedValueCheck)\
  \ const {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return\
  \ false;\n\n  if (ExprHasName(Origin, \"memset\", Call.getState()->getStateManager().getOwningEngine()->getCheckerManager()->getContext())\
  \ ||\n      ExprHasName(Origin, \"__builtin_memset\",\n                  Call.getState()->getStateManager().getOwningEngine()->getCheckerManager()->getContext()))\
  \ {\n    if (Call.getNumArgs() < 3)\n      return false;\n    PtrIdx = 0; ValIdx\
  \ = 1; LenIdx = 2;\n    NeedValueCheck = true;\n    ValueIsZero = false;\n    return\
  \ true;\n  }\n\n  if (ExprHasName(Origin, \"memzero_explicit\",\n              \
  \    Call.getState()->getStateManager().getOwningEngine()->getCheckerManager()->getContext()))\
  \ {\n    if (Call.getNumArgs() < 2)\n      return false;\n    PtrIdx = 0; LenIdx\
  \ = 1;\n    NeedValueCheck = false;\n    ValueIsZero = true;\n    ValIdx = UINT_MAX;\n\
  \    return true;\n  }\n\n  if (ExprHasName(Origin, \"bzero\",\n               \
  \   Call.getState()->getStateManager().getOwningEngine()->getCheckerManager()->getContext()))\
  \ {\n    if (Call.getNumArgs() < 2)\n      return false;\n    PtrIdx = 0; LenIdx\
  \ = 1;\n    NeedValueCheck = false;\n    ValueIsZero = true;\n    ValIdx = UINT_MAX;\n\
  \    return true;\n  }\n\n  return false;\n}\n\n// Identify copy-out functions to\
  \ user space or netlink, and provide indices.\nbool SAGenTestChecker::isCopyOutCall(const\
  \ CallEvent &Call,\n                                     unsigned &LenIdx, unsigned\
  \ &PtrIdx,\n                                     CheckerContext &C) const {\n  struct\
  \ CopySig { const char *Name; unsigned Len; unsigned Ptr; };\n  static const CopySig\
  \ Table[] = {\n      {\"nla_put\", 2, 3},\n      {\"nla_put_64bit\", 2, 3},\n  \
  \    {\"nla_put_nohdr\", 1, 2},\n      {\"copy_to_user\", 2, 1},\n      {\"copy_to_user_nofault\"\
  , 2, 1},\n      {\"copy_to_iter\", 2, 1},\n  };\n\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  for (const auto &E : Table) {\n    if (ExprHasName(Origin,\
  \ E.Name, C)) {\n      if (Call.getNumArgs() <= std::max(E.Len, E.Ptr))\n      \
  \  return false;\n      LenIdx = E.Len;\n      PtrIdx = E.Ptr;\n      return true;\n\
  \    }\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  const MemRegion *LHSR = Loc.getAsRegion();\n  if (!LHSR)\n    return;\n  LHSR\
  \ = LHSR->getBaseRegion();\n  if (!LHSR)\n    return;\n\n  const auto *LHSVR = dyn_cast<VarRegion>(LHSR);\n\
  \  if (!LHSVR)\n    return;\n\n  const VarDecl *LHSVD = LHSVR->getDecl();\n  if\
  \ (!LHSVD)\n    return;\n  if (!LHSVD->getType()->isPointerType())\n    return;\
  \ // Track only pointer variables on LHS\n\n  const MemRegion *RHSR = Val.getAsRegion();\n\
  \  if (!RHSR)\n    return;\n  RHSR = RHSR->getBaseRegion();\n  if (!RHSR)\n    return;\n\
  \n  // Case 1: RHS is another pointer var with an existing alias\n  if (const auto\
  \ *RHSVR = dyn_cast<VarRegion>(RHSR)) {\n    const VarDecl *RHSVD = RHSVR->getDecl();\n\
  \    if (!RHSVD)\n      return;\n\n    // If RHS is a pointer variable with an alias\
  \ mapping, propagate it.\n    if (RHSVD->getType()->isPointerType()) {\n      if\
  \ (const MemRegion *Aliased = State->get<PtrAliasMap>(RHSVR)) {\n        State =\
  \ State->set<PtrAliasMap>(LHSVR, Aliased);\n        C.addTransition(State);\n  \
  \      return;\n      }\n    }\n\n    // Case 2: RHS is a local struct variable\
  \ (taking its address assigned to LHS)\n    if (RHSVD->isLocalVarDecl() && !RHSVD->hasGlobalStorage())\
  \ {\n      QualType QT = RHSVD->getType();\n      if (const RecordType *RT = QT->getAs<RecordType>())\
  \ {\n        if (const RecordDecl *RD = dyn_cast_or_null<RecordDecl>(RT->getDecl()))\
  \ {\n          if (RD->isStruct()) {\n            State = State->set<PtrAliasMap>(LHSVR,\
  \ RHSVR);\n            C.addTransition(State);\n            return;\n          }\n\
  \        }\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  unsigned PtrIdx = 0, ValIdx = 0, LenIdx = 0;\n  bool ValueIsZero = false, NeedValueCheck\
  \ = false;\n\n  if (!isZeroingCall(Call, PtrIdx, ValIdx, LenIdx, ValueIsZero, NeedValueCheck))\n\
  \    return;\n\n  // Check value is zero for memset variants that require it.\n\
  \  if (NeedValueCheck) {\n    const Expr *ValE = Call.getArgExpr(ValIdx);\n    if\
  \ (!ValE)\n      return;\n    llvm::APSInt V;\n    if (!EvaluateExprToInt(V, ValE,\
  \ C))\n      return;\n    if (V != 0)\n      return; // Not zeroing\n    ValueIsZero\
  \ = true;\n  }\n\n  if (!ValueIsZero)\n    return;\n\n  // Resolve target struct\
  \ var region\n  const Expr *PtrE = Call.getArgExpr(PtrIdx);\n  if (!PtrE)\n    return;\n\
  \  const VarRegion *VR = resolveBaseStructVarRegion(PtrE, C);\n  if (!VR)\n    return;\n\
  \n  const VarDecl *VD = VR->getDecl();\n  if (!VD)\n    return;\n\n  QualType StructTy\
  \ = VD->getType();\n  if (!StructTy->isRecordType())\n    return;\n\n  // Size check:\
  \ ensure full-object zeroing\n  const Expr *LenE = Call.getArgExpr(LenIdx);\n  if\
  \ (!lenMatchesStructSize(LenE, StructTy, C))\n    return;\n\n  // Mark as fully\
  \ zeroed\n  State = State->set<ZeroedStructs>(VR, true);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n\n  unsigned LenIdx = 0, PtrIdx\
  \ = 0;\n  if (!isCopyOutCall(Call, LenIdx, PtrIdx, C))\n    return;\n\n  const Expr\
  \ *PtrE = Call.getArgExpr(PtrIdx);\n  const Expr *LenE = Call.getArgExpr(LenIdx);\n\
  \  if (!PtrE || !LenE)\n    return;\n\n  const VarRegion *VR = resolveBaseStructVarRegion(PtrE,\
  \ C);\n  if (!VR)\n    return;\n\n  const VarDecl *VD = VR->getDecl();\n  if (!VD)\n\
  \    return;\n  if (!(VD->isLocalVarDecl() && !VD->hasGlobalStorage()))\n    return;\n\
  \n  QualType StructTy = VD->getType();\n  const RecordType *RT = StructTy->getAs<RecordType>();\n\
  \  if (!RT)\n    return;\n  const RecordDecl *RD = dyn_cast_or_null<RecordDecl>(RT->getDecl());\n\
  \  if (!RD || !RD->isStruct())\n    return;\n\n  // Verify length matches sizeof(struct)\n\
  \  if (!lenMatchesStructSize(LenE, StructTy, C))\n    return;\n\n  // Verify the\
  \ struct layout has implicit padding\n  if (!recordHasImplicitPadding(RD, C.getASTContext()))\n\
  \    return;\n\n  // If not marked as zeroed, report\n  const bool *Zeroed = State->get<ZeroedStructs>(VR);\n\
  \  if (!Zeroed || *Zeroed == false) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Stack struct with padding copied with sizeof; missing zero-init\
  \ (info leak)\", N);\n    if (const Stmt *S = Call.getOriginExpr())\n      R->addRange(S->getSourceRange());\n\
  \    C.emitReport(std::move(R));\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects copying of partially initialized\
  \ stack structs with padding to user space (info leak)\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/sched: act_skbmod: prevent kernel-infoleak\n\n\
  syzbot found that tcf_skbmod_dump() was copying four bytes\nfrom kernel stack to\
  \ user space [1].\n\nThe issue here is that 'struct tc_skbmod' has a four bytes\
  \ hole.\n\nWe need to clear the structure before filling fields.\n\n[1]\nBUG: KMSAN:\
  \ kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in copy_to_user_iter lib/iov_iter.c:24 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \ BUG: KMSAN: kernel-infoleak in iterate_and_advance2 include/linux/iov_iter.h:245\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in iterate_and_advance include/linux/iov_iter.h:271\
  \ [inline]\n BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n  copy_to_user_iter\
  \ lib/iov_iter.c:24 [inline]\n  iterate_ubuf include/linux/iov_iter.h:29 [inline]\n\
  \  iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\n  iterate_and_advance\
  \ include/linux/iov_iter.h:271 [inline]\n  _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n\
  \  copy_to_iter include/linux/uio.h:196 [inline]\n  simple_copy_to_iter net/core/datagram.c:532\
  \ [inline]\n  __skb_datagram_iter+0x185/0x1000 net/core/datagram.c:420\n  skb_copy_datagram_iter+0x5c/0x200\
  \ net/core/datagram.c:546\n  skb_copy_datagram_msg include/linux/skbuff.h:4050 [inline]\n\
  \  netlink_recvmsg+0x432/0x1610 net/netlink/af_netlink.c:1962\n  sock_recvmsg_nosec\
  \ net/socket.c:1046 [inline]\n  sock_recvmsg+0x2c4/0x340 net/socket.c:1068\n  __sys_recvfrom+0x35a/0x5f0\
  \ net/socket.c:2242\n  __do_sys_recvfrom net/socket.c:2260 [inline]\n  __se_sys_recvfrom\
  \ net/socket.c:2256 [inline]\n  __x64_sys_recvfrom+0x126/0x1d0 net/socket.c:2256\n\
  \ do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nUninit\
  \ was stored to memory at:\n  pskb_expand_head+0x30f/0x19d0 net/core/skbuff.c:2253\n\
  \  netlink_trim+0x2c2/0x330 net/netlink/af_netlink.c:1317\n  netlink_unicast+0x9f/0x1260\
  \ net/netlink/af_netlink.c:1351\n  nlmsg_unicast include/net/netlink.h:1144 [inline]\n\
  \  nlmsg_notify+0x21d/0x2f0 net/netlink/af_netlink.c:2610\n  rtnetlink_send+0x73/0x90\
  \ net/core/rtnetlink.c:741\n  rtnetlink_maybe_send include/linux/rtnetlink.h:17\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2048 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x146e/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nUninit was stored to memory at:\n  __nla_put lib/nlattr.c:1041 [inline]\n  nla_put+0x1c6/0x230\
  \ lib/nlattr.c:1099\n  tcf_skbmod_dump+0x23f/0xc20 net/sched/act_skbmod.c:256\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n  tcf_action_dump+0x1fd/0x460 net/sched/act_api.c:1251\n\
  \  tca_get_fill+0x519/0x7a0 net/sched/act_api.c:1628\n  tcf_add_notify_msg net/sched/act_api.c:2023\
  \ [inline]\n  tcf_add_notify net/sched/act_api.c:2042 [inline]\n  tcf_action_add\
  \ net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x1365/0x19d0 net/sched/act_api.c:2119\n\
  \  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650\
  \ net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n\
  \  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260\
  \ net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n\
  \  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n\
  \  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n\
  \  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676\
  \ [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0\
  \ net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\
  \nLocal variable opt created at:\n  tcf_skbmod_dump+0x9d/0xc20 net/sched/act_skbmod.c:244\n\
  \  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970\
  \ net/sched/act_api.c:1227\n\nBytes 188-191 of 248 are uninitialized\nMemory access\
  \ of size 248 starts at ffff888117697680\nData copied to user address 00007ffe56d855f0\n\
  \nFixes: 86da71b57383 (\"net_sched: Introduce skbmod action\")\nSigned-off-by: Eric\
  \ Dumazet <edumazet@google.com>\nAcked-by: Jamal Hadi Salim <jhs@mojatatu.com>\n\
  Link: https://lore.kernel.org/r/20240403130908.93421-1-edumazet@google.com\nSigned-off-by:\
  \ Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: tcf_skbmod_dump\
  \ in net/sched/act_skbmod.c\nstatic int tcf_skbmod_dump(struct sk_buff *skb, struct\
  \ tc_action *a,\n\t\t\t   int bind, int ref)\n{\n\tstruct tcf_skbmod *d = to_skbmod(a);\n\
  \tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_skbmod_params  *p;\n\t\
  struct tc_skbmod opt = {\n\t\t.index   = d->tcf_index,\n\t\t.refcnt  = refcount_read(&d->tcf_refcnt)\
  \ - ref,\n\t\t.bindcnt = atomic_read(&d->tcf_bindcnt) - bind,\n\t};\n\tstruct tcf_t\
  \ t;\n\n\tspin_lock_bh(&d->tcf_lock);\n\topt.action = d->tcf_action;\n\tp = rcu_dereference_protected(d->skbmod_p,\n\
  \t\t\t\t      lockdep_is_held(&d->tcf_lock));\n\topt.flags  = p->flags;\n\tif (nla_put(skb,\
  \ TCA_SKBMOD_PARMS, sizeof(opt), &opt))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_DMAC) &&\n\t    nla_put(skb, TCA_SKBMOD_DMAC, ETH_ALEN, p->eth_dst))\n\
  \t\tgoto nla_put_failure;\n\tif ((p->flags & SKBMOD_F_SMAC) &&\n\t    nla_put(skb,\
  \ TCA_SKBMOD_SMAC, ETH_ALEN, p->eth_src))\n\t\tgoto nla_put_failure;\n\tif ((p->flags\
  \ & SKBMOD_F_ETYPE) &&\n\t    nla_put_u16(skb, TCA_SKBMOD_ETYPE, ntohs(p->eth_type)))\n\
  \t\tgoto nla_put_failure;\n\n\ttcf_tm_dump(&t, &d->tcf_tm);\n\tif (nla_put_64bit(skb,\
  \ TCA_SKBMOD_TM, sizeof(t), &t, TCA_SKBMOD_PAD))\n\t\tgoto nla_put_failure;\n\n\t\
  spin_unlock_bh(&d->tcf_lock);\n\treturn skb->len;\nnla_put_failure:\n\tspin_unlock_bh(&d->tcf_lock);\n\
  \tnlmsg_trim(skb, b);\n\treturn -1;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff\
  \ --git a/net/sched/act_skbmod.c b/net/sched/act_skbmod.c\nindex 39945b139c48..cd0accaf844a\
  \ 100644\n--- a/net/sched/act_skbmod.c\n+++ b/net/sched/act_skbmod.c\n@@ -241,13\
  \ +241,13 @@ static int tcf_skbmod_dump(struct sk_buff *skb, struct tc_action *a,\n\
  \ \tstruct tcf_skbmod *d = to_skbmod(a);\n \tunsigned char *b = skb_tail_pointer(skb);\n\
  \ \tstruct tcf_skbmod_params  *p;\n-\tstruct tc_skbmod opt = {\n-\t\t.index   =\
  \ d->tcf_index,\n-\t\t.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n-\t\t.bindcnt\
  \ = atomic_read(&d->tcf_bindcnt) - bind,\n-\t};\n+\tstruct tc_skbmod opt;\n \tstruct\
  \ tcf_t t;\n \n+\tmemset(&opt, 0, sizeof(opt));\n+\topt.index   = d->tcf_index;\n\
  +\topt.refcnt  = refcount_read(&d->tcf_refcnt) - ref,\n+\topt.bindcnt = atomic_read(&d->tcf_bindcnt)\
  \ - bind;\n \tspin_lock_bh(&d->tcf_lock);\n \topt.action = d->tcf_action;\n \tp\
  \ = rcu_dereference_protected(d->skbmod_p,\n```\n"
pattern: '## Bug Pattern


  Partially initialized stack struct (with padding/holes) is copied to user space
  with sizeof(struct), leaking uninitialized bytes. Example pattern:


  - Define and set only some fields of a struct on the stack (e.g., via designated
  initializer or selective assignments).

  - The struct has implicit padding/holes due to alignment.

  - Pass the entire struct to user (e.g., nla_put(..., sizeof(s), &s) or copy_to_user(...,
  &s, sizeof(s))) without zeroing it first.


  Fix is to zero-initialize the whole struct (e.g., memset(&s, 0, sizeof(s))) before
  filling fields, or otherwise ensure all bytes are initialized.'
plan: "1) Program state\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(ZeroedStructs, const MemRegion\
  \ *, bool)\n  - Tracks stack-struct variables that are known to have been fully\
  \ zeroed. Maps the VarRegion of the stack variable to true when we prove a full\
  \ memset(\u20260, sizeof(var/type)) happened. Absence from the map means \u201C\
  not proven fully zeroed\u201D.\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap,\
  \ const MemRegion *, const MemRegion *)\n  - Tracks simple pointer aliases so we\
  \ can resolve calls like ptr = &s; \u2026 copy_to_user(\u2026, ptr, sizeof(s));.\
  \ Maps a pointer variable region (LHS) to the VarRegion of the struct variable it\
  \ points to (base region).\n\nNo other traits needed.\n\n\n2) Callback selection\
  \ and implementation\n\nA) checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const\n\nGoal: Track aliases from pointer variables to the base VarRegion\
  \ of a stack struct.\n\n- If Loc is a MemRegion (LHS) and refers to a pointer-typed\
  \ variable (VarRegion of a local pointer var), and Val is a loc::MemRegionVal:\n\
  \  - Extract RHS region R from Val.\n  - Reduce R to its base-most super region\
  \ and check if it is a VarRegion (VR) of a local, non-global VarDecl whose type\
  \ is a RecordType (struct).\n  - If yes, update PtrAliasMap[LHS_VarRegion] = VR.\n\
  - If Val is a MemRegionVal whose base maps to another pointer var already in PtrAliasMap,\
  \ transitively update:\n  - If RHS region is a VarRegion of pointer type that\u2019\
  s present in PtrAliasMap, set PtrAliasMap[LHS] = PtrAliasMap[RHS].\n- Do not add\
  \ entries for fields or array elements; only map when we know it points to the complete\
  \ struct object (i.e., the MemRegion is a VarRegion, not FieldRegion/ElementRegion).\n\
  - Do not erase entries here; the analyzer will naturally invalidate as paths end.\n\
  \nHelpers:\n- Use getAsRegion/isa<VarRegion>/isa<SubRegion> to normalize to base\
  \ (walk super-regions until top).\n- Check VarDecl->isLocalVarDecl() && !VarDecl->hasGlobalStorage().\n\
  - Check that the VarDecl type is a RecordType and is a struct (RecordDecl::isStruct()).\n\
  \n\nB) checkPostCall(const CallEvent &Call, CheckerContext &C) const\n\nGoal: Mark\
  \ struct variables as fully zeroed when we see a full memset to zero.\n\n- Recognize\
  \ zeroing functions:\n  - Names: \"memset\", \"__builtin_memset\", \"memzero_explicit\"\
  , \"bzero\".\n- Extract args: ptr, value (or implicit 0 for bzero), size.\n- ptr:\
  \ Try to resolve the base VarRegion of the struct variable being zeroed:\n  - First,\
  \ get MemRegion from the first argument using getMemRegionFromExpr.\n  - If it\u2019\
  s a VarRegion (VR) to a local struct, use it directly.\n  - Else if it\u2019s a\
  \ VarRegion for a pointer variable (pointer-to-void or pointer-to-struct), consult\
  \ PtrAliasMap to get the aliased struct VarRegion (VR). If found, use that.\n  -\
  \ If the region is FieldRegion/ElementRegion or otherwise not a full VarRegion,\
  \ bail.\n- value: Use EvaluateExprToInt to ensure it is zero (for memset/memzero_explicit).\
  \ For bzero we can skip value check.\n- size: Prove it equals the full size of the\
  \ struct type:\n  - If it is a UnaryExprOrTypeTraitExpr sizeof(T) or sizeof(var),\
  \ extract the type T and ensure it equals the struct variable\u2019s type (after\
  \ desugaring).\n  - Otherwise try EvaluateExprToInt and compare the integer to ASTContext.getTypeSizeInChars(StructType).getQuantity().\n\
  - If both value==0 and size==sizeof(struct), set ZeroedStructs[VR] = true.\n\nNotes:\n\
  - We only mark \u201Cfully zeroed\u201D on exact, whole-object zeroing. Partial\
  \ sizes or non-zero fill are ignored.\n- This is intentionally conservative to minimize\
  \ false negatives.\n\n\nC) checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const\n\nGoal: Detect copies of a possibly partially initialized stack struct\
  \ (with padding) to user space with a length equal to sizeof(struct).\n\n- Maintain\
  \ a small internal table of known \u201Ccopy-out\u201D functions and the indices\
  \ of the pointer and length parameters:\n  - { \"nla_put\",          LenIdx=2, PtrIdx=3\
  \ }\n  - { \"nla_put_64bit\",    LenIdx=2, PtrIdx=3 }\n  - { \"nla_put_nohdr\",\
  \    LenIdx=1, PtrIdx=2 }\n  - { \"copy_to_user\",     LenIdx=2, PtrIdx=1 }    \
  \  // from\n  - { \"copy_to_user_nofault\", LenIdx=2, PtrIdx=1 }\n  - { \"copy_to_iter\"\
  ,     LenIdx=2, PtrIdx=1 }      // from\n- If Call.callee name matches one of the\
  \ above:\n  - Let PtrArg = Call.getArgExpr(PtrIdx), LenArg = Call.getArgExpr(LenIdx).\n\
  \  - Resolve the struct VarRegion and its type:\n    - Try getMemRegionFromExpr(PtrArg).\n\
  \    - If region is a VarRegion (VR) and the VarDecl is local non-global and of\
  \ struct type, keep VR.\n    - Else if region is a pointer VarRegion, consult PtrAliasMap\
  \ to find the aliased struct VarRegion (VR).\n    - If you cannot resolve a struct\
  \ VarRegion (i.e., FieldRegion, ElementRegion, globals, heap, non-struct), bail.\n\
  \  - Check that the length equals the full size of the struct object:\n    - If\
  \ LenArg is a sizeof expression on the same variable/type, accept.\n    - Else EvaluateExprToInt\
  \ and compare to ASTContext.getTypeSizeInChars(StructType).getQuantity().\n    -\
  \ If sizes differ, bail.\n  - Check that the struct type actually has implicit padding\
  \ and is not packed:\n    - RecordDecl must be a struct (not union).\n    - If RecordDecl\
  \ has PackedAttr (or isPacked()), bail (no padding).\n    - Compute padding with\
  \ ASTContext.getASTRecordLayout(RD):\n      - Interior padding exists if for any\
  \ field i>0, layout.getFieldOffset(i) > prevFieldEndBit.\n      - Trailing padding\
  \ exists if layout.getSize() > lastFieldEndBit.\n      - If neither interior nor\
  \ trailing padding, bail (no leak risk).\n  - If we got here: we are copying exactly\
  \ sizeof(struct) bytes of a stack struct that has padding.\n    - Look up ZeroedStructs[VR]:\n\
  \      - If present and true, OK (already zeroed); do nothing.\n      - Otherwise,\
  \ report a bug.\n\nBug report:\n- Create a BugType once: \u201CKernel info leak:\
  \ copying stack struct with padding\u201D.\n- Message: \u201CStack struct with padding\
  \ copied with sizeof; missing zero-init (info leak)\u201D.\n- Attach the report\
  \ to the call expression (highlight the length or data argument).\n- Use generateNonFatalErrorNode\
  \ and PathSensitiveBugReport.\n\n\n3) Key helper logic (internal methods you\u2019\
  ll implement)\n\n- resolveBaseStructVarRegion(const Expr *PtrArg, CheckerContext\
  \ &C) -> const VarRegion*\n  - Try getMemRegionFromExpr(PtrArg).\n  - If VarRegion\
  \ and its VarDecl is a local struct, return it.\n  - If VarRegion of a pointer variable,\
  \ look up in PtrAliasMap to get the struct VarRegion, return it if local struct.\n\
  \  - Otherwise return nullptr.\n\n- lenMatchesStructSize(const Expr *LenArg, QualType\
  \ StructTy, CheckerContext &C) -> bool\n  - If LenArg is a UnaryExprOrTypeTraitExpr\
  \ sizeof: check that the operand type (or expr type) equals StructTy after desugaring.\n\
  \  - Else EvaluateExprToInt and compare to ASTContext.getTypeSizeInChars(StructTy).getQuantity().\n\
  \n- recordHasImplicitPadding(const RecordDecl *RD, ASTContext &AC) -> bool\n  -\
  \ If RD has PackedAttr or isPacked() return false.\n  - Use ASTRecordLayout L =\
  \ AC.getASTRecordLayout(RD).\n  - Iterate fields in declaration order:\n    - Track\
  \ lastEnd = 0.\n    - For each field i: curOff = L.getFieldOffset(i), curEnd = curOff\
  \ + AC.getTypeSize(Fi->getType()).\n    - If curOff > lastEnd, interior padding\
  \ detected -> return true.\n    - lastEnd = curEnd.\n  - If L.getSize() > lastEnd,\
  \ trailing padding -> return true.\n  - Else return false.\n\n- isZeroingCall(const\
  \ CallEvent &Call) -> bool\n  - Name in {\"memset\", \"__builtin_memset\", \"memzero_explicit\"\
  , \"bzero\"}.\n\n- isCopyOutCall(const CallEvent &Call, unsigned &LenIdx, unsigned\
  \ &PtrIdx) -> bool\n  - Lookup in the small table above; fill indices if found.\n\
  \n\n4) Notes and conservative choices\n\n- We only consider explicit whole-object\
  \ memset/memzero/bzero as sufficient zero-initialization. Initializers like = {},\
  \ designated initializers, or field-by-field assignments are treated as insufficient\
  \ because padding may remain uninitialized.\n- We only warn when:\n  - The pointer\
  \ refers to a complete local stack struct object (not a field/element/global/heap),\n\
  \  - The length equals exactly sizeof(that struct),\n  - And the struct layout has\
  \ implicit padding (and is not packed).\n  These filters keep false positives low\
  \ and match the target pattern precisely.\n- Alias tracking is intentionally simple\
  \ (pointer variables to stack struct VarRegions via checkBind). That covers common\
  \ idioms like void *p = &s;. If alias cannot be resolved, the checker stays silent.\n\
  \n\n5) Chosen callbacks summary\n\n- checkBind: build PtrAliasMap.\n- checkPostCall:\
  \ detect full zeroing of a stack struct and mark ZeroedStructs.\n- checkPreCall:\
  \ detect copy-out-by-sizeof to user APIs, verify padding, and report if not zeroed.\n\
  \nThis is sufficient to detect the pattern exemplified by tcf_skbmod_dump: passing\
  \ &opt with sizeof(opt) to nla_put while opt is not explicitly zeroed, and struct\
  \ type has padding."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Attr.h\"\n#include \"\
  clang/AST/Decl.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/RecordLayout.h\"\
  \n#include \"clang/AST/Type.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <utility>\n\
  #include <algorithm>\n#include <climits>\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// Program state maps\nREGISTER_MAP_WITH_PROGRAMSTATE(ZeroedStructs,\
  \ const MemRegion *, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion\
  \ *, const MemRegion *)\n\nnamespace {\n\nclass SAGenTestChecker\n  : public Checker<\n\
  \        check::Bind,\n        check::PostCall,\n        check::PreCall> {\n\n \
  \ mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n      :\
  \ BT(new BugType(this,\n                       \"Kernel info leak: copying stack\
  \ struct with padding\",\n                       \"Security\")) {}\n\n  void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n  void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  const VarRegion\
  \ *resolveBaseStructVarRegion(const Expr *PtrArg,\n                            \
  \                  CheckerContext &C) const;\n  bool lenMatchesStructSize(const\
  \ Expr *LenArg, QualType StructTy,\n                            CheckerContext &C)\
  \ const;\n  bool recordHasImplicitPadding(const RecordDecl *RD,\n              \
  \                  ASTContext &AC) const;\n  bool isZeroingCall(const CallEvent\
  \ &Call,\n                     unsigned &PtrIdx, unsigned &ValIdx, unsigned &LenIdx,\n\
  \                     bool &ValueIsZero, bool &NeedValueCheck,\n               \
  \      CheckerContext &C) const;\n  bool isCopyOutCall(const CallEvent &Call,\n\
  \                     unsigned &LenIdx, unsigned &PtrIdx,\n                    \
  \ CheckerContext &C) const;\n};\n\n// Return the base VarRegion of a local struct\
  \ variable that PtrArg refers to,\n// optionally via a pointer alias. Returns nullptr\
  \ if not resolvable.\nconst VarRegion *SAGenTestChecker::resolveBaseStructVarRegion(const\
  \ Expr *PtrArg,\n                                                              CheckerContext\
  \ &C) const {\n  if (!PtrArg)\n    return nullptr;\n\n  const MemRegion *R = getMemRegionFromExpr(PtrArg,\
  \ C);\n  if (!R)\n    return nullptr;\n\n  R = R->getBaseRegion();\n  if (!R)\n\
  \    return nullptr;\n\n  ProgramStateRef State = C.getState();\n\n  // If R is\
  \ a VarRegion, check if it is a local struct variable directly.\n  if (const auto\
  \ *VR = dyn_cast<VarRegion>(R)) {\n    const VarDecl *VD = VR->getDecl();\n    if\
  \ (!VD)\n      return nullptr;\n\n    if (VD->isLocalVarDecl() && !VD->hasGlobalStorage())\
  \ {\n      QualType QT = VD->getType();\n      if (const RecordType *RT = QT->getAs<RecordType>())\
  \ {\n        if (const RecordDecl *RD = dyn_cast_or_null<RecordDecl>(RT->getDecl()))\
  \ {\n          if (RD->isStruct())\n            return VR;\n        }\n      }\n\
  \    }\n\n    // If it's a local pointer var, try alias map.\n    if (VD->getType()->isPointerType())\
  \ {\n      if (const MemRegion *const *AliasedPtr = State->get<PtrAliasMap>(VR))\
  \ {\n        const MemRegion *Aliased = *AliasedPtr;\n        if (const auto *AliasedVR\
  \ = dyn_cast_or_null<VarRegion>(Aliased)) {\n          const VarDecl *AVD = AliasedVR->getDecl();\n\
  \          if (!AVD)\n            return nullptr;\n          if (AVD->isLocalVarDecl()\
  \ && !AVD->hasGlobalStorage()) {\n            QualType QT = AVD->getType();\n  \
  \          if (const RecordType *RT = QT->getAs<RecordType>()) {\n             \
  \ if (const RecordDecl *RD = dyn_cast_or_null<RecordDecl>(RT->getDecl())) {\n  \
  \              if (RD->isStruct())\n                  return AliasedVR;\n      \
  \        }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Not\
  \ a direct VarRegion or couldn't resolve to a struct var.\n  return nullptr;\n}\n\
  \n// Check if LenArg equals sizeof(StructTy).\nbool SAGenTestChecker::lenMatchesStructSize(const\
  \ Expr *LenArg,\n                                            QualType StructTy,\n\
  \                                            CheckerContext &C) const {\n  if (!LenArg)\n\
  \    return false;\n\n  ASTContext &AC = C.getASTContext();\n  QualType CanonStructTy\
  \ = AC.getCanonicalType(StructTy);\n\n  const Expr *LE = LenArg->IgnoreParenCasts();\n\
  \  if (const auto *U = dyn_cast<UnaryExprOrTypeTraitExpr>(LE)) {\n    if (U->getKind()\
  \ == UETT_SizeOf) {\n      QualType SizeofTy;\n      if (U->isArgumentType())\n\
  \        SizeofTy = U->getArgumentType();\n      else if (const Expr *ArgE = U->getArgumentExpr())\n\
  \        SizeofTy = ArgE->getType();\n\n      if (!SizeofTy.isNull()) {\n      \
  \  QualType CanonSizeofTy = AC.getCanonicalType(SizeofTy);\n        if (AC.hasSameUnqualifiedType(CanonSizeofTy,\
  \ CanonStructTy))\n          return true;\n      }\n    }\n  }\n\n  // Fallback:\
  \ evaluate LenArg to int and compare to size in bytes.\n  llvm::APSInt LenVal;\n\
  \  if (EvaluateExprToInt(LenVal, LenArg, C)) {\n    uint64_t Len = LenVal.getZExtValue();\n\
  \    uint64_t StructSize = AC.getTypeSizeInChars(StructTy).getQuantity();\n    return\
  \ Len == StructSize;\n  }\n\n  return false;\n}\n\n// Determine whether a record\
  \ has implicit padding (interior or trailing).\nbool SAGenTestChecker::recordHasImplicitPadding(const\
  \ RecordDecl *RD,\n                                                ASTContext &AC)\
  \ const {\n  if (!RD)\n    return false;\n  if (!RD->isStruct())\n    return false;\n\
  \  RD = RD->getDefinition();\n  if (!RD)\n    return false;\n\n  const ASTRecordLayout\
  \ &L = AC.getASTRecordLayout(RD);\n\n  uint64_t LastEndBits = 0;\n  unsigned Index\
  \ = 0;\n  for (const FieldDecl *FD : RD->fields()) {\n    if (!FD)\n      continue;\n\
  \    uint64_t FieldOffsetBits = L.getFieldOffset(Index);\n    uint64_t FieldSizeBits\
  \ = AC.getTypeSize(FD->getType());\n    if (FieldOffsetBits > LastEndBits)\n   \
  \   return true; // interior padding\n    LastEndBits = FieldOffsetBits + FieldSizeBits;\n\
  \    ++Index;\n  }\n\n  uint64_t TotalBits = L.getSize().getQuantity() * 8ULL;\n\
  \  if (TotalBits > LastEndBits)\n    return true; // trailing padding\n\n  return\
  \ false;\n}\n\n// Identify zeroing calls. Returns true and fills indices if recognized.\n\
  // For memset/__builtin_memset: PtrIdx=0, ValIdx=1, LenIdx=2, NeedValueCheck=true,\
  \ ValueIsZero if value is proven zero.\n// For memzero_explicit: PtrIdx=0, LenIdx=1,\
  \ NeedValueCheck=false (implicitly zero).\n// For bzero: PtrIdx=0, LenIdx=1, NeedValueCheck=false\
  \ (implicitly zero).\nbool SAGenTestChecker::isZeroingCall(const CallEvent &Call,\n\
  \                                     unsigned &PtrIdx, unsigned &ValIdx, unsigned\
  \ &LenIdx,\n                                     bool &ValueIsZero, bool &NeedValueCheck,\n\
  \                                     CheckerContext &C) const {\n  const Expr *Origin\
  \ = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n\n  if (ExprHasName(Origin,\
  \ \"memset\", C) ||\n      ExprHasName(Origin, \"__builtin_memset\", C)) {\n   \
  \ if (Call.getNumArgs() < 3)\n      return false;\n    PtrIdx = 0; ValIdx = 1; LenIdx\
  \ = 2;\n    NeedValueCheck = true;\n    ValueIsZero = false;\n    return true;\n\
  \  }\n\n  if (ExprHasName(Origin, \"memzero_explicit\", C)) {\n    if (Call.getNumArgs()\
  \ < 2)\n      return false;\n    PtrIdx = 0; LenIdx = 1;\n    NeedValueCheck = false;\n\
  \    ValueIsZero = true;\n    ValIdx = UINT_MAX;\n    return true;\n  }\n\n  if\
  \ (ExprHasName(Origin, \"bzero\", C)) {\n    if (Call.getNumArgs() < 2)\n      return\
  \ false;\n    PtrIdx = 0; LenIdx = 1;\n    NeedValueCheck = false;\n    ValueIsZero\
  \ = true;\n    ValIdx = UINT_MAX;\n    return true;\n  }\n\n  return false;\n}\n\
  \n// Identify copy-out functions to user space or netlink, and provide indices.\n\
  bool SAGenTestChecker::isCopyOutCall(const CallEvent &Call,\n                  \
  \                   unsigned &LenIdx, unsigned &PtrIdx,\n                      \
  \               CheckerContext &C) const {\n  struct CopySig { const char *Name;\
  \ unsigned Len; unsigned Ptr; };\n  static const CopySig Table[] = {\n      {\"\
  nla_put\", 2, 3},\n      {\"nla_put_64bit\", 2, 3},\n      {\"nla_put_nohdr\", 1,\
  \ 2},\n      {\"copy_to_user\", 2, 1},\n      {\"copy_to_user_nofault\", 2, 1},\n\
  \      {\"copy_to_iter\", 2, 1},\n  };\n\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  for (const auto &E : Table) {\n    if (ExprHasName(Origin,\
  \ E.Name, C)) {\n      if (Call.getNumArgs() <= std::max(E.Len, E.Ptr))\n      \
  \  return false;\n      LenIdx = E.Len;\n      PtrIdx = E.Ptr;\n      return true;\n\
  \    }\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal\
  \ Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  const MemRegion *LHSR = Loc.getAsRegion();\n  if (!LHSR)\n    return;\n  LHSR\
  \ = LHSR->getBaseRegion();\n  if (!LHSR)\n    return;\n\n  const auto *LHSVR = dyn_cast<VarRegion>(LHSR);\n\
  \  if (!LHSVR)\n    return;\n\n  const VarDecl *LHSVD = LHSVR->getDecl();\n  if\
  \ (!LHSVD)\n    return;\n  if (!LHSVD->getType()->isPointerType())\n    return;\
  \ // Track only pointer variables on LHS\n\n  const MemRegion *RHSR = Val.getAsRegion();\n\
  \  if (!RHSR)\n    return;\n  RHSR = RHSR->getBaseRegion();\n  if (!RHSR)\n    return;\n\
  \n  // Case 1: RHS is another pointer var with an existing alias\n  if (const auto\
  \ *RHSVR = dyn_cast<VarRegion>(RHSR)) {\n    const VarDecl *RHSVD = RHSVR->getDecl();\n\
  \    if (!RHSVD)\n      return;\n\n    // If RHS is a pointer variable with an alias\
  \ mapping, propagate it.\n    if (RHSVD->getType()->isPointerType()) {\n      if\
  \ (const MemRegion *const *AliasedPtr = State->get<PtrAliasMap>(RHSVR)) {\n    \
  \    const MemRegion *Aliased = *AliasedPtr;\n        State = State->set<PtrAliasMap>(LHSVR,\
  \ Aliased);\n        C.addTransition(State);\n        return;\n      }\n    }\n\n\
  \    // Case 2: RHS is a local struct variable (taking its address assigned to LHS)\n\
  \    if (RHSVD->isLocalVarDecl() && !RHSVD->hasGlobalStorage()) {\n      QualType\
  \ QT = RHSVD->getType();\n      if (const RecordType *RT = QT->getAs<RecordType>())\
  \ {\n        if (const RecordDecl *RD = dyn_cast_or_null<RecordDecl>(RT->getDecl()))\
  \ {\n          if (RD->isStruct()) {\n            State = State->set<PtrAliasMap>(LHSVR,\
  \ RHSVR);\n            C.addTransition(State);\n            return;\n          }\n\
  \        }\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \  unsigned PtrIdx = 0, ValIdx = 0, LenIdx = 0;\n  bool ValueIsZero = false, NeedValueCheck\
  \ = false;\n\n  if (!isZeroingCall(Call, PtrIdx, ValIdx, LenIdx, ValueIsZero, NeedValueCheck,\
  \ C))\n    return;\n\n  // Check value is zero for memset variants that require\
  \ it.\n  if (NeedValueCheck) {\n    const Expr *ValE = Call.getArgExpr(ValIdx);\n\
  \    if (!ValE)\n      return;\n    llvm::APSInt V;\n    if (!EvaluateExprToInt(V,\
  \ ValE, C))\n      return;\n    if (!V.isZero())\n      return; // Not zeroing\n\
  \    ValueIsZero = true;\n  }\n\n  if (!ValueIsZero)\n    return;\n\n  // Resolve\
  \ target struct var region\n  const Expr *PtrE = Call.getArgExpr(PtrIdx);\n  if\
  \ (!PtrE)\n    return;\n  const VarRegion *VR = resolveBaseStructVarRegion(PtrE,\
  \ C);\n  if (!VR)\n    return;\n\n  const VarDecl *VD = VR->getDecl();\n  if (!VD)\n\
  \    return;\n\n  QualType StructTy = VD->getType();\n  if (!StructTy->isRecordType())\n\
  \    return;\n\n  // Size check: ensure full-object zeroing\n  const Expr *LenE\
  \ = Call.getArgExpr(LenIdx);\n  if (!lenMatchesStructSize(LenE, StructTy, C))\n\
  \    return;\n\n  // Mark as fully zeroed\n  State = State->set<ZeroedStructs>(VR,\
  \ true);\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  unsigned LenIdx = 0, PtrIdx = 0;\n  if (!isCopyOutCall(Call, LenIdx, PtrIdx,\
  \ C))\n    return;\n\n  const Expr *PtrE = Call.getArgExpr(PtrIdx);\n  const Expr\
  \ *LenE = Call.getArgExpr(LenIdx);\n  if (!PtrE || !LenE)\n    return;\n\n  const\
  \ VarRegion *VR = resolveBaseStructVarRegion(PtrE, C);\n  if (!VR)\n    return;\n\
  \n  const VarDecl *VD = VR->getDecl();\n  if (!VD)\n    return;\n  if (!(VD->isLocalVarDecl()\
  \ && !VD->hasGlobalStorage()))\n    return;\n\n  QualType StructTy = VD->getType();\n\
  \  const RecordType *RT = StructTy->getAs<RecordType>();\n  if (!RT)\n    return;\n\
  \  const RecordDecl *RD = dyn_cast_or_null<RecordDecl>(RT->getDecl());\n  if (!RD\
  \ || !RD->isStruct())\n    return;\n\n  // Verify length matches sizeof(struct)\n\
  \  if (!lenMatchesStructSize(LenE, StructTy, C))\n    return;\n\n  // Verify the\
  \ struct layout has implicit padding\n  if (!recordHasImplicitPadding(RD, C.getASTContext()))\n\
  \    return;\n\n  // If not marked as zeroed, report\n  const bool *Zeroed = State->get<ZeroedStructs>(VR);\n\
  \  if (!Zeroed || *Zeroed == false) {\n    ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \    if (!N)\n      return;\n\n    auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \        *BT, \"Stack struct with padding copied with sizeof; missing zero-init\
  \ (info leak)\", N);\n    if (const Stmt *S = Call.getOriginExpr())\n      R->addRange(S->getSourceRange());\n\
  \    C.emitReport(std::move(R));\n  }\n}\n\n} // end anonymous namespace\n\nextern\
  \ \"C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects copying of partially initialized\
  \ stack structs with padding to user space (info leak)\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
