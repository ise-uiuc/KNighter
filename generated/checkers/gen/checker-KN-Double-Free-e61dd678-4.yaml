_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: e61dd678601eac53d501dda1eb1bcffec7b11bd6
commit_type: Double-Free
index: 4
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"\
  clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"llvm/ADT/SmallVector.h\"\
  \n#include <vector>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// We store for each base object region the set of its fields that have\
  \ been\n// manually freed (via kfree/kvfree/etc).\nREGISTER_SET_WITH_PROGRAMSTATE(FreedFieldSet,\
  \ const FieldDecl*)\nREGISTER_MAP_WITH_PROGRAMSTATE(ManualFreedMap, const MemRegion*,\
  \ FreedFieldSetTy)\n\nnamespace {\n\nstruct CleanupSpec {\n  const char *FuncName;\n\
  \  unsigned ObjParamIndex;\n  llvm::SmallVector<const char *, 4> FreedFields;\n\
  };\n\nstatic const CleanupSpec CleanupTable[] = {\n    {\"bch2_dev_buckets_free\"\
  , 0, {\"buckets_nouse\"}}\n};\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Double free: manual free then cleanup helper\", \"Memory\
  \ Management\")) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\n   private:\n      // Predicates and helpers\n      static bool\
  \ isCallNamed(const CallEvent &Call, StringRef Name, CheckerContext &C);\n     \
  \ static bool isFreeLike(const CallEvent &Call, CheckerContext &C);\n\n      static\
  \ const CleanupSpec* getCleanupSpec(const CallEvent &Call, CheckerContext &C);\n\
  \n      const FieldDecl* resolveFieldDeclFromObjectParam(const Expr *ObjExpr,\n\
  \                                                       StringRef FieldName,\n \
  \                                                      CheckerContext &C) const;\n\
  \n      void recordManualFreeOfField(const MemRegion *BaseObjReg,\n            \
  \                       const FieldDecl *FD,\n                                 \
  \  CheckerContext &C) const;\n\n      void reportDoubleFree(const CallEvent &Call,\
  \ StringRef FieldName,\n                            StringRef HelperName, CheckerContext\
  \ &C) const;\n};\n\nbool SAGenTestChecker::isCallNamed(const CallEvent &Call, StringRef\
  \ Name, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n  if\
  \ (Origin && ExprHasName(Origin, Name, C))\n    return true;\n  if (const IdentifierInfo\
  \ *ID = Call.getCalleeIdentifier())\n    return ID->getName() == Name;\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::isFreeLike(const CallEvent &Call, CheckerContext\
  \ &C) {\n  static const char *FreeFuncs[] = {\"kfree\", \"kvfree\", \"kfree_sensitive\"\
  , \"vfree\"};\n  for (const char *F : FreeFuncs) {\n    if (isCallNamed(Call, F,\
  \ C))\n      return true;\n  }\n  return false;\n}\n\nconst CleanupSpec* SAGenTestChecker::getCleanupSpec(const\
  \ CallEvent &Call, CheckerContext &C) {\n  for (const auto &Entry : CleanupTable)\
  \ {\n    if (isCallNamed(Call, Entry.FuncName, C))\n      return &Entry;\n  }\n\
  \  return nullptr;\n}\n\nconst FieldDecl* SAGenTestChecker::resolveFieldDeclFromObjectParam(const\
  \ Expr *ObjExpr,\n                                                             \
  \      StringRef FieldName,\n                                                  \
  \                 CheckerContext &C) const {\n  if (!ObjExpr)\n    return nullptr;\n\
  \n  QualType QT = ObjExpr->getType();\n  if (QT.isNull())\n    return nullptr;\n\
  \n  QualType PointeeOrSelf = QT->isPointerType() ? QT->getPointeeType() : QT;\n\
  \  if (PointeeOrSelf.isNull())\n    return nullptr;\n\n  const RecordType *RT =\
  \ PointeeOrSelf->getAs<RecordType>();\n  if (!RT)\n    return nullptr;\n\n  const\
  \ RecordDecl *RD = RT->getDecl();\n  if (!RD)\n    return nullptr;\n\n  for (const\
  \ FieldDecl *FD : RD->fields()) {\n    if (FD && FD->getName().equals(FieldName))\n\
  \      return FD;\n  }\n  return nullptr;\n}\n\nvoid SAGenTestChecker::recordManualFreeOfField(const\
  \ MemRegion *BaseObjReg,\n                                               const FieldDecl\
  \ *FD,\n                                               CheckerContext &C) const\
  \ {\n  if (!BaseObjReg || !FD)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \n  // Get existing set of freed fields for this object, or an empty set.\n  FreedFieldSetTy\
  \ Set;\n  if (const FreedFieldSetTy *Existing = State->get<ManualFreedMap>(BaseObjReg))\n\
  \    Set = *Existing;\n  else\n    Set = State->get_context<FreedFieldSet>().getEmptySet();\n\
  \n  // Add the field to the set.\n  FreedFieldSetTy NewSet = State->get_context<FreedFieldSet>().add(Set,\
  \ FD);\n  if (NewSet != Set) {\n    State = State->set<ManualFreedMap>(BaseObjReg,\
  \ NewSet);\n    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::reportDoubleFree(const\
  \ CallEvent &Call, StringRef FieldName,\n                                      \
  \  StringRef HelperName, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  SmallString<128> Msg;\n  Msg += \"Double free: field\
  \ '\";\n  Msg += FieldName;\n  Msg += \"' freed manually and again by '\";\n  Msg\
  \ += HelperName;\n  Msg += \"'\";\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg.str(), N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n\n  // 1) Handle manual frees\
  \ like kfree(obj->member);\n  if (isFreeLike(Call, C)) {\n    if (Call.getNumArgs()\
  \ >= 1) {\n      const Expr *Arg0 = Call.getArgExpr(0);\n      if (Arg0) {\n   \
  \     // Find the MemberExpr inside the argument expression.\n        const MemberExpr\
  \ *ME = findSpecificTypeInChildren<MemberExpr>(Arg0);\n        if (ME) {\n     \
  \     const ValueDecl *VD = ME->getMemberDecl();\n          const FieldDecl *FD\
  \ = dyn_cast_or_null<FieldDecl>(VD);\n          if (FD) {\n            const Expr\
  \ *BaseE = ME->getBase();\n            if (BaseE) {\n              const MemRegion\
  \ *BaseObjReg = getMemRegionFromExpr(BaseE, C);\n              if (BaseObjReg) {\n\
  \                BaseObjReg = BaseObjReg->getBaseRegion();\n                if (BaseObjReg)\
  \ {\n                  recordManualFreeOfField(BaseObjReg, FD, C);\n           \
  \     }\n              }\n            }\n          }\n        }\n      }\n    }\n\
  \    return;\n  }\n\n  // 2) Handle composite cleanup helpers, e.g. bch2_dev_buckets_free(obj);\n\
  \  if (const CleanupSpec *Spec = getCleanupSpec(Call, C)) {\n    if (Call.getNumArgs()\
  \ > Spec->ObjParamIndex) {\n      const Expr *ObjE = Call.getArgExpr(Spec->ObjParamIndex);\n\
  \      if (!ObjE)\n        return;\n\n      const MemRegion *BaseObjReg = getMemRegionFromExpr(ObjE,\
  \ C);\n      if (!BaseObjReg)\n        return;\n      BaseObjReg = BaseObjReg->getBaseRegion();\n\
  \      if (!BaseObjReg)\n        return;\n\n      const FreedFieldSetTy *FreedSet\
  \ = State->get<ManualFreedMap>(BaseObjReg);\n\n      for (const char *FieldName\
  \ : Spec->FreedFields) {\n        const FieldDecl *FD = resolveFieldDeclFromObjectParam(ObjE,\
  \ FieldName, C);\n        if (!FD)\n          continue;\n\n        if (FreedSet\
  \ && FreedSet->contains(FD)) {\n          reportDoubleFree(Call, FieldName, Spec->FuncName,\
  \ C);\n          // Do not early return; continue to check other fields if any.\n\
  \        }\n      }\n    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"\
  C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects manual free of struct member\
  \ followed by a cleanup helper freeing the same member (double free).\",\n     \
  \ \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbcachefs: Fix double free of ca->buckets_nouse\n\n\
  Reported-by: Dan Carpenter <dan.carpenter@linaro.org>\nFixes: ffcbec6076 (\"bcachefs:\
  \ Kill opts.buckets_nouse\")\nSigned-off-by: Kent Overstreet <kent.overstreet@linux.dev>\n\
  \n## Buggy Code\n\n```c\n// Function: bch2_dev_free in fs/bcachefs/super.c\nstatic\
  \ void bch2_dev_free(struct bch_dev *ca)\n{\n\tcancel_work_sync(&ca->io_error_work);\n\
  \n\tif (ca->kobj.state_in_sysfs &&\n\t    ca->disk_sb.bdev)\n\t\tsysfs_remove_link(bdev_kobj(ca->disk_sb.bdev),\
  \ \"bcachefs\");\n\n\tif (ca->kobj.state_in_sysfs)\n\t\tkobject_del(&ca->kobj);\n\
  \n\tkfree(ca->buckets_nouse);\n\tbch2_free_super(&ca->disk_sb);\n\tbch2_dev_allocator_background_exit(ca);\n\
  \tbch2_dev_journal_exit(ca);\n\n\tfree_percpu(ca->io_done);\n\tbch2_dev_buckets_free(ca);\n\
  \tfree_page((unsigned long) ca->sb_read_scratch);\n\n\tbch2_time_stats_quantiles_exit(&ca->io_latency[WRITE]);\n\
  \tbch2_time_stats_quantiles_exit(&ca->io_latency[READ]);\n\n\tpercpu_ref_exit(&ca->io_ref);\n\
  #ifndef CONFIG_BCACHEFS_DEBUG\n\tpercpu_ref_exit(&ca->ref);\n#endif\n\tkobject_put(&ca->kobj);\n\
  }\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/fs/bcachefs/super.c b/fs/bcachefs/super.c\n\
  index 0455a1001fec..e7fa2de35014 100644\n--- a/fs/bcachefs/super.c\n+++ b/fs/bcachefs/super.c\n\
  @@ -1193,7 +1193,6 @@ static void bch2_dev_free(struct bch_dev *ca)\n \tif (ca->kobj.state_in_sysfs)\n\
  \ \t\tkobject_del(&ca->kobj);\n \n-\tkfree(ca->buckets_nouse);\n \tbch2_free_super(&ca->disk_sb);\n\
  \ \tbch2_dev_allocator_background_exit(ca);\n \tbch2_dev_journal_exit(ca);\n```\n"
pattern: '## Bug Pattern


  Manually freeing a structure member that is also freed by a subsequent composite
  cleanup helper, causing a double free. Specifically, calling kfree(obj->member)
  in a destructor before invoking another cleanup function (e.g., bch2_dev_buckets_free(obj))
  that also frees the same member pointer.'
plan: "Plan\n\n1. Program state\n- Register one program state map to remember which\
  \ struct-field of which object has been freed manually:\n  - REGISTER_MAP_WITH_PROGRAMSTATE(ManualFreedMap,\
  \ std::pair<const MemRegion*, const FieldDecl*>, char)\n  - Key: (BaseObjectRegion,\
  \ FieldDecl*) uniquely identifies the field of a specific object instance.\n  -\
  \ Value: dummy (char) just to mark presence.\n\n- No alias tracking is necessary.\
  \ The analyzer already propagates pointer equivalence across assignments; getMemRegionFromExpr()\
  \ on the base pointer expression will yield the same pointee region across aliases\
  \ on the same path.\n\n2. Known targets\n- Free-like functions set:\n  - {\"kfree\"\
  , \"kvfree\", \"kfree_sensitive\", \"vfree\"} (extendable)\n- Composite cleanup\
  \ helpers table (function summaries), each entry contains:\n  - Function name (callee)\n\
  \  - Parameter index of the object pointer\n  - The list of field names on that\
  \ object that this helper frees\n- Seed the table with:\n  - {\"bch2_dev_buckets_free\"\
  , 0, {\"buckets_nouse\"}}\n- Provide small utilities:\n  - isFreeLike(const CallEvent\
  \ &Call)\n  - const CleanupSpec* getCleanupSpec(const CallEvent &Call) returning\
  \ the table entry or nullptr\n  - const FieldDecl* resolveFieldDeclFromObjectParam(const\
  \ Expr *ObjExpr, StringRef FieldName)\n    - Steps:\n      - Take ObjExpr->IgnoreParenCasts(),\
  \ get its QualType T.\n      - If T is pointer, get pointee PT; if PT is a RecordType,\
  \ get the RecordDecl.\n      - Iterate its FieldDecls to find one with getName()\
  \ == FieldName; return that FieldDecl*.\n\n3. Callback: checkPreCall\n- Goal: record\
  \ \u201Cmanual free of object->field\u201D, and detect when a subsequent cleanup\
  \ helper frees the same field.\n- Steps:\n  A) Handle manual frees\n  - If isFreeLike(Call):\n\
  \    - Let Arg0 = Call.getArgExpr(0)->IgnoreParenCasts().\n    - If Arg0 is a MemberExpr\
  \ ME (either -> or .):\n      - FieldDecl* FD = dyn_cast<FieldDecl>(ME->getMemberDecl());\
  \ if null, return.\n      - const Expr *BaseE = ME->getBase()->IgnoreParenCasts().\n\
  \      - const MemRegion *BaseObjReg = getMemRegionFromExpr(BaseE, C); if null,\
  \ return.\n      - Build key = std::make_pair(BaseObjReg, FD).\n      - Insert key\
  \ into ManualFreedMap. Transition to the new state.\n      - Optional: If you want\
  \ to also detect the reverse order, you can in the future add a second map for \u201C\
  freed by helper\u201D and check/report here; but for the target pattern (manual\
  \ free before helper), this is not needed.\n  B) Handle composite cleanup helpers\n\
  \  - If const CleanupSpec *Spec = getCleanupSpec(Call):\n    - Get the object argument:\
  \ const Expr *ObjE = Call.getArgExpr(Spec->ParamIndex)->IgnoreParenCasts().\n  \
  \  - const MemRegion *BaseObjReg = getMemRegionFromExpr(ObjE, C); if null, return.\n\
  \    - For each FieldName in Spec->FreedFields:\n      - const FieldDecl *FD = resolveFieldDeclFromObjectParam(ObjE,\
  \ FieldName); if null, continue (type not visible or mismatch).\n      - Build key\
  \ = std::make_pair(BaseObjReg, FD).\n      - If key exists in ManualFreedMap:\n\
  \        - Report bug: \u201CDouble free: field '<FieldName>' freed manually and\
  \ again by '<Spec->FuncName>'.\u201D\n        - Create a non-fatal error node and\
  \ emit a PathSensitiveBugReport anchored at the helper call site.\n      - Else:\
  \ do nothing. We only target the pattern \u201Cmanual free then helper free\u201D\
  .\n\n4. Other callbacks\n- Not required. Do not implement checkBind, checkLocation,\
  \ etc. Keep the checker simple and focused on this pattern.\n\n5. Bug report\n-\
  \ Use generateNonFatalErrorNode to create a node, then emit a std::make_unique<PathSensitiveBugReport>.\n\
  - Short message, e.g.:\n  - \u201CDouble free: field 'buckets_nouse' freed manually\
  \ and again by 'bch2_dev_buckets_free'.\u201D\n- Point the primary location to the\
  \ helper call; optionally add a note at the manual free site by storing the SourceRange\
  \ (MemberExpr or the kfree call) in the state along with the map if you want to\
  \ enhance diagnostics, but this is optional for a minimal working checker.\n\n6.\
  \ Notes and matching details\n- Only record manual frees when the free argument\
  \ is a direct MemberExpr; ignore other complex expressions to avoid false positives.\n\
  - On resolving FieldDecl for helper entry, match via the actual pointee record of\
  \ the object parameter at the call site. This allows state keys to use FieldDecl*\
  \ consistently across both sides (manual and helper).\n- Rely on the analyzer\u2019\
  s path-sensitivity to correlate the same object region across aliases and control\
  \ flow without custom alias maps.\n\nSummary of implementation steps\n- Register\
  \ ManualFreedMap in program state.\n- Implement helper predicates isFreeLike and\
  \ getCleanupSpec (table with {\"bch2_dev_buckets_free\", 0, {\"buckets_nouse\"}}).\n\
  - Implement resolveFieldDeclFromObjectParam.\n- In checkPreCall:\n  - If free-like\
  \ + MemberExpr arg: record (BaseObjReg, FieldDecl) in ManualFreedMap.\n  - If cleanup\
  \ helper: derive (BaseObjReg, FieldDecl) for each listed field and check ManualFreedMap;\
  \ if present, report."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"\
  clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"llvm/ADT/SmallVector.h\"\
  \n#include <vector>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// We store for each base object region the set of its fields that have\
  \ been\n// manually freed (via kfree/kvfree/etc).\nREGISTER_SET_WITH_PROGRAMSTATE(FreedFieldSet,\
  \ const FieldDecl*)\nREGISTER_MAP_WITH_PROGRAMSTATE(ManualFreedMap, const MemRegion*,\
  \ FreedFieldSetTy)\n\nnamespace {\n\nstruct CleanupSpec {\n  const char *FuncName;\n\
  \  unsigned ObjParamIndex;\n  llvm::SmallVector<const char *, 4> FreedFields;\n\
  };\n\nstatic const CleanupSpec CleanupTable[] = {\n    {\"bch2_dev_buckets_free\"\
  , 0, {\"buckets_nouse\"}}\n};\n\nclass SAGenTestChecker : public Checker<check::PreCall>\
  \ {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Double free: manual free then cleanup helper\", \"Memory\
  \ Management\")) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const;\n\n   private:\n      // Predicates and helpers\n      static bool\
  \ isCallNamed(const CallEvent &Call, StringRef Name, CheckerContext &C);\n     \
  \ static bool isFreeLike(const CallEvent &Call, CheckerContext &C);\n\n      static\
  \ const CleanupSpec* getCleanupSpec(const CallEvent &Call, CheckerContext &C);\n\
  \n      const FieldDecl* resolveFieldDeclFromObjectParam(const Expr *ObjExpr,\n\
  \                                                       StringRef FieldName,\n \
  \                                                      CheckerContext &C) const;\n\
  \n      void recordManualFreeOfField(const MemRegion *BaseObjReg,\n            \
  \                       const FieldDecl *FD,\n                                 \
  \  CheckerContext &C) const;\n\n      void reportDoubleFree(const CallEvent &Call,\
  \ StringRef FieldName,\n                            StringRef HelperName, CheckerContext\
  \ &C) const;\n};\n\nbool SAGenTestChecker::isCallNamed(const CallEvent &Call, StringRef\
  \ Name, CheckerContext &C) {\n  const Expr *Origin = Call.getOriginExpr();\n  if\
  \ (Origin && ExprHasName(Origin, Name, C))\n    return true;\n  if (const IdentifierInfo\
  \ *ID = Call.getCalleeIdentifier())\n    return ID->getName() == Name;\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::isFreeLike(const CallEvent &Call, CheckerContext\
  \ &C) {\n  static const char *FreeFuncs[] = {\"kfree\", \"kvfree\", \"kfree_sensitive\"\
  , \"vfree\"};\n  for (const char *F : FreeFuncs) {\n    if (isCallNamed(Call, F,\
  \ C))\n      return true;\n  }\n  return false;\n}\n\nconst CleanupSpec* SAGenTestChecker::getCleanupSpec(const\
  \ CallEvent &Call, CheckerContext &C) {\n  for (const auto &Entry : CleanupTable)\
  \ {\n    if (isCallNamed(Call, Entry.FuncName, C))\n      return &Entry;\n  }\n\
  \  return nullptr;\n}\n\nconst FieldDecl* SAGenTestChecker::resolveFieldDeclFromObjectParam(const\
  \ Expr *ObjExpr,\n                                                             \
  \      StringRef FieldName,\n                                                  \
  \                 CheckerContext &C) const {\n  if (!ObjExpr)\n    return nullptr;\n\
  \n  QualType QT = ObjExpr->getType();\n  if (QT.isNull())\n    return nullptr;\n\
  \n  QualType PointeeOrSelf = QT->isPointerType() ? QT->getPointeeType() : QT;\n\
  \  if (PointeeOrSelf.isNull())\n    return nullptr;\n\n  const RecordType *RT =\
  \ PointeeOrSelf->getAs<RecordType>();\n  if (!RT)\n    return nullptr;\n\n  const\
  \ RecordDecl *RD = RT->getDecl();\n  if (!RD)\n    return nullptr;\n\n  for (const\
  \ FieldDecl *FD : RD->fields()) {\n    if (FD && FD->getName().equals(FieldName))\n\
  \      return FD;\n  }\n  return nullptr;\n}\n\nvoid SAGenTestChecker::recordManualFreeOfField(const\
  \ MemRegion *BaseObjReg,\n                                               const FieldDecl\
  \ *FD,\n                                               CheckerContext &C) const\
  \ {\n  if (!BaseObjReg || !FD)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \n  // Get existing set of freed fields for this object, or an empty set.\n  FreedFieldSetTy\
  \ Set = State->get_context<FreedFieldSet>().getEmptySet();\n  if (const FreedFieldSetTy\
  \ *Existing = State->get<ManualFreedMap>(BaseObjReg))\n    Set = *Existing;\n\n\
  \  // Add the field to the set.\n  FreedFieldSetTy NewSet = State->get_context<FreedFieldSet>().add(Set,\
  \ FD);\n  if (NewSet != Set) {\n    State = State->set<ManualFreedMap>(BaseObjReg,\
  \ NewSet);\n    C.addTransition(State);\n  }\n}\n\nvoid SAGenTestChecker::reportDoubleFree(const\
  \ CallEvent &Call, StringRef FieldName,\n                                      \
  \  StringRef HelperName, CheckerContext &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  SmallString<128> Msg;\n  Msg += \"Double free: field\
  \ '\";\n  Msg += FieldName;\n  Msg += \"' freed manually and again by '\";\n  Msg\
  \ += HelperName;\n  Msg += \"'\";\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg.str(), N);\n  R->addRange(Call.getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n\n  // 1) Handle manual frees\
  \ like kfree(obj->member);\n  if (isFreeLike(Call, C)) {\n    if (Call.getNumArgs()\
  \ >= 1) {\n      const Expr *Arg0 = Call.getArgExpr(0);\n      if (Arg0) {\n   \
  \     // Find the MemberExpr inside the argument expression.\n        const MemberExpr\
  \ *ME = findSpecificTypeInChildren<MemberExpr>(Arg0);\n        if (ME) {\n     \
  \     const ValueDecl *VD = ME->getMemberDecl();\n          const FieldDecl *FD\
  \ = dyn_cast_or_null<FieldDecl>(VD);\n          if (FD) {\n            const Expr\
  \ *BaseE = ME->getBase();\n            if (BaseE) {\n              const MemRegion\
  \ *BaseObjReg = getMemRegionFromExpr(BaseE, C);\n              if (BaseObjReg) {\n\
  \                BaseObjReg = BaseObjReg->getBaseRegion();\n                if (BaseObjReg)\
  \ {\n                  recordManualFreeOfField(BaseObjReg, FD, C);\n           \
  \     }\n              }\n            }\n          }\n        }\n      }\n    }\n\
  \    return;\n  }\n\n  // 2) Handle composite cleanup helpers, e.g. bch2_dev_buckets_free(obj);\n\
  \  if (const CleanupSpec *Spec = getCleanupSpec(Call, C)) {\n    if (Call.getNumArgs()\
  \ > Spec->ObjParamIndex) {\n      const Expr *ObjE = Call.getArgExpr(Spec->ObjParamIndex);\n\
  \      if (!ObjE)\n        return;\n\n      const MemRegion *BaseObjReg = getMemRegionFromExpr(ObjE,\
  \ C);\n      if (!BaseObjReg)\n        return;\n      BaseObjReg = BaseObjReg->getBaseRegion();\n\
  \      if (!BaseObjReg)\n        return;\n\n      const FreedFieldSetTy *FreedSet\
  \ = State->get<ManualFreedMap>(BaseObjReg);\n\n      for (const char *FieldName\
  \ : Spec->FreedFields) {\n        const FieldDecl *FD = resolveFieldDeclFromObjectParam(ObjE,\
  \ FieldName, C);\n        if (!FD)\n          continue;\n\n        if (FreedSet\
  \ && FreedSet->contains(FD)) {\n          reportDoubleFree(Call, FieldName, Spec->FuncName,\
  \ C);\n          // Do not early return; continue to check other fields if any.\n\
  \        }\n      }\n    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"\
  C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects manual free of struct member\
  \ followed by a cleanup helper freeing the same member (double free).\",\n     \
  \ \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
