_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: ec1aae190c7729ffdd3603de311dc00f7ff988f9
commit_type: Misuse
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(ZeroInitObjMap,\
  \ const MemRegion*, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(CounterInitBaseMap, const\
  \ MemRegion*, bool)\n\nnamespace {\nclass SAGenTestChecker\n    : public Checker<\n\
  \          check::PostCall,\n          check::PreCall,\n          check::Bind\n\
  \      > {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n\
  \      : BT(new BugType(this, \"Write to flexible array before setting its __counted_by\
  \ counter\",\n                       \"Memory Safety\")) {}\n\n  void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  void checkBind(SVal Loc, SVal Val, const Stmt\
  \ *S, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  static bool isZeroingAlloc(const\
  \ CallEvent &Call, CheckerContext &C);\n  static bool isWriteToFirstParamFunction(const\
  \ CallEvent &Call, CheckerContext &C);\n\n  static const MemRegion *getBaseRegionFromMember(const\
  \ MemberExpr *ME, CheckerContext &C);\n\n  static bool fieldIsFlexibleArray(const\
  \ FieldDecl *FD);\n  static bool fieldHasCountedBy(const FieldDecl *FD);\n\n  static\
  \ const FieldDecl *getCountedByCounterField(const FieldDecl *FAMField);\n  static\
  \ bool isCounterForAnyCountedByField(const FieldDecl *FD, CheckerContext &C);\n\n\
  \  void reportBeforeCounterInit(const CallEvent &Call, const MemberExpr *DstME,\n\
  \                               const FieldDecl *FAMField, CheckerContext &C) const;\n\
  };\n\n// Determine if a call is a zero-initializing allocation.\nbool SAGenTestChecker::isZeroingAlloc(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE)\n    return false;\n\n  // Common kernel zeroing allocators\n  if (ExprHasName(OE,\
  \ \"kzalloc\", C)) return true;\n  if (ExprHasName(OE, \"kcalloc\", C)) return true;\n\
  \  if (ExprHasName(OE, \"kzalloc_array\", C)) return true;\n  if (ExprHasName(OE,\
  \ \"kvzalloc\", C)) return true;\n  if (ExprHasName(OE, \"vzalloc\", C)) return\
  \ true;\n\n  // Device-managed variants (optional, but safe to recognize)\n  if\
  \ (ExprHasName(OE, \"devm_kzalloc\", C)) return true;\n  if (ExprHasName(OE, \"\
  devm_kcalloc\", C)) return true;\n\n  return false;\n}\n\n// Functions that (likely)\
  \ write to their first parameter.\nbool SAGenTestChecker::isWriteToFirstParamFunction(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE)\n    return false;\n\n  // Keep minimal but sufficient for the target\
  \ bug\n  if (ExprHasName(OE, \"memcpy\", C)) return true;\n  if (ExprHasName(OE,\
  \ \"__memcpy\", C)) return true;\n  if (ExprHasName(OE, \"memmove\", C)) return\
  \ true;\n  if (ExprHasName(OE, \"copy_from_user\", C)) return true;\n\n  return\
  \ false;\n}\n\nconst MemRegion *SAGenTestChecker::getBaseRegionFromMember(const\
  \ MemberExpr *ME, CheckerContext &C) {\n  if (!ME)\n    return nullptr;\n\n  //\
  \ Important: do not IgnoreImplicit() before calling getMemRegionFromExpr\n  const\
  \ Expr *BaseE = ME->getBase();\n  if (!BaseE)\n    return nullptr;\n\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(BaseE, C);\n  if (!MR)\n    return nullptr;\n\n  MR\
  \ = MR->getBaseRegion();\n  return MR;\n}\n\nbool SAGenTestChecker::fieldIsFlexibleArray(const\
  \ FieldDecl *FD) {\n  if (!FD)\n    return false;\n  QualType QT = FD->getType();\n\
  \  if (QT.isNull())\n    return false;\n\n  // Flexible array members are incomplete\
  \ arrays in C\n  return QT->isIncompleteArrayType();\n}\n\nbool SAGenTestChecker::fieldHasCountedBy(const\
  \ FieldDecl *FD) {\n  if (!FD)\n    return false;\n  return FD->hasAttr<CountedByAttr>();\n\
  }\n\n// Try to resolve the FieldDecl referenced by the counted_by attribute.\nconst\
  \ FieldDecl *SAGenTestChecker::getCountedByCounterField(const FieldDecl *FAMField)\
  \ {\n  if (!FAMField)\n    return nullptr;\n\n  const auto *Attr = FAMField->getAttr<CountedByAttr>();\n\
  \  if (!Attr)\n    return nullptr;\n\n  // Clang-18 CountedByAttr stores an expression\
  \ referencing the counter field.\n  if (const Expr *E = Attr->getParam()) {\n  \
  \  E = E->IgnoreParenCasts();\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(E))\
  \ {\n      if (const auto *FD = dyn_cast<FieldDecl>(DRE->getDecl()))\n        return\
  \ FD;\n    }\n  }\n  return nullptr;\n}\n\n// Check whether FD is the counter for\
  \ any counted_by FAM field within the same record.\nbool SAGenTestChecker::isCounterForAnyCountedByField(const\
  \ FieldDecl *FD, CheckerContext &C) {\n  if (!FD)\n    return false;\n\n  const\
  \ RecordDecl *RD = FD->getParent();\n  if (!RD)\n    return false;\n\n  for (const\
  \ FieldDecl *F : RD->fields()) {\n    if (!fieldHasCountedBy(F))\n      continue;\n\
  \n    // First try to directly resolve the FieldDecl from the attribute.\n    if\
  \ (const FieldDecl *CounterFD = getCountedByCounterField(F)) {\n      if (CounterFD\
  \ == FD)\n        return true;\n      continue;\n    }\n\n    // Fallback: name-based\
  \ check if attribute param resolution fails.\n    // This is conservative; prefer\
  \ the direct resolution above.\n    if (const auto *Attr = F->getAttr<CountedByAttr>())\
  \ {\n      if (const Expr *E = Attr->getParam()) {\n        if (ExprHasName(E, FD->getName(),\
  \ C))\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::reportBeforeCounterInit(const\
  \ CallEvent &Call, const MemberExpr *DstME,\n                                  \
  \             const FieldDecl *FAMField, CheckerContext &C) const {\n  if (!BT)\n\
  \    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  SmallString<128> Msg;\n  Msg += \"Write to flexible array before\
  \ setting its __counted_by counter\";\n  if (FAMField) {\n    Msg += \" (\";\n \
  \   Msg += FAMField->getName();\n    Msg += \")\";\n  }\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  if (const Expr *OE = Call.getOriginExpr())\n    R->addRange(OE->getSourceRange());\n\
  \  if (DstME)\n    R->addRange(DstME->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// Mark zero-initialized objects when returned from zeroing allocators.\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  if (!isZeroingAlloc(Call, C))\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \n  SVal Ret = Call.getReturnValue();\n  const MemRegion *MR = Ret.getAsRegion();\n\
  \  if (!MR)\n    return;\n\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  State = State->set<ZeroInitObjMap>(MR, true);\n  C.addTransition(State);\n}\n\
  \n// Detect writes to FAM with counted_by before counter init.\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isWriteToFirstParamFunction(Call,\
  \ C))\n    return;\n\n  if (Call.getNumArgs() < 1)\n    return;\n\n  const Expr\
  \ *DstArgE = Call.getArgExpr(0);\n  if (!DstArgE)\n    return;\n\n  // Try to find\
  \ a MemberExpr inside the destination argument, e.g., event->data\n  const MemberExpr\
  \ *DstME = dyn_cast<MemberExpr>(DstArgE->IgnoreParenCasts());\n  if (!DstME)\n \
  \   DstME = findSpecificTypeInChildren<MemberExpr>(DstArgE);\n  if (!DstME)\n  \
  \  return;\n\n  const ValueDecl *VD = DstME->getMemberDecl();\n  const FieldDecl\
  \ *FAMField = dyn_cast_or_null<FieldDecl>(VD);\n  if (!FAMField)\n    return;\n\n\
  \  // Must be a flexible-array member\n  if (!fieldIsFlexibleArray(FAMField))\n\
  \    return;\n\n  // Must have __counted_by attribute\n  if (!fieldHasCountedBy(FAMField))\n\
  \    return;\n\n  // Get the base object region holding this field, e.g., 'event'\n\
  \  const MemRegion *BaseR = getBaseRegionFromMember(DstME, C);\n  if (!BaseR)\n\
  \    return;\n\n  // Only warn for objects we know are zero-initialized by kzalloc/kcalloc/...\n\
  \  ProgramStateRef State = C.getState();\n  const bool *IsZeroed = State->get<ZeroInitObjMap>(BaseR);\n\
  \  if (!IsZeroed || !*IsZeroed)\n    return;\n\n  // Has the (relevant) counter\
  \ field been initialized?\n  const bool *CounterInit = State->get<CounterInitBaseMap>(BaseR);\n\
  \  if (CounterInit && *CounterInit)\n    return;\n\n  // Not initialized yet: report\n\
  \  reportBeforeCounterInit(Call, DstME, FAMField, C);\n}\n\n// Observe assignments\
  \ to fields that are counters of counted_by flexible arrays.\n// When we see e.g.\
  \ \"obj->len = n;\", mark the base object as having initialized\n// the counter.\n\
  void SAGenTestChecker::checkBind(SVal Loc, SVal /*Val*/, const Stmt *S, CheckerContext\
  \ &C) const {\n  const MemRegion *R = Loc.getAsRegion();\n  if (!R)\n    return;\n\
  \n  const FieldRegion *FR = dyn_cast<FieldRegion>(R->getBaseRegion()->getAs<SubRegion>()\
  \ ? R : R);\n  if (!FR)\n    FR = dyn_cast<FieldRegion>(R);\n  if (!FR)\n    return;\n\
  \n  const FieldDecl *FD = FR->getDecl();\n  if (!FD)\n    return;\n\n  // Only consider\
  \ fields that are counters for a counted_by FAM in this record.\n  if (!isCounterForAnyCountedByField(FD,\
  \ C))\n    return;\n\n  // Mark the base object as having its counter initialized.\n\
  \  const MemRegion *BaseR = FR->getSuperRegion();\n  if (!BaseR)\n    return;\n\n\
  \  BaseR = BaseR->getBaseRegion();\n  if (!BaseR)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  State = State->set<CounterInitBaseMap>(BaseR, true);\n\
  \  C.addTransition(State);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects writes to __counted_by flexible\
  \ arrays before initializing their counter (after zeroing alloc)\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nwifi: brcmfmac: fweh: Fix boot crash on Raspberry\
  \ Pi 4\n\nFix boot crash on Raspberry Pi by moving the update to `event->datalen`\n\
  before data is copied into flexible-array member `data` via `memcpy()`.\n\nFlexible-array\
  \ member `data` was annotated with `__counted_by(datalen)`\nin commit 62d19b358088\
  \ (\"wifi: brcmfmac: fweh: Add __counted_by for\nstruct brcmf_fweh_queue_item and\
  \ use struct_size()\"). The intention of\nthis is to gain visibility into the size\
  \ of `data` at run-time through\nits _counter_ (in this case `datalen`), and with\
  \ this have its accesses\nbounds-checked at run-time via CONFIG_FORTIFY_SOURCE and\n\
  CONFIG_UBSAN_BOUNDS.\n\nTo effectively accomplish the above, we shall update the\
  \ counter\n(`datalen`), before the first access to the flexible array (`data`),\n\
  which was also done in the mentioned commit.\n\nHowever, commit edec42821911 (\"\
  wifi: brcmfmac: allow per-vendor event\nhandling\") inadvertently caused a buffer\
  \ overflow, detected by\nFORTIFY_SOURCE. It moved the `event->datalen = datalen;`\
  \ update to after\nthe first `data` access, at which point `event->datalen` was\
  \ not yet\nupdated from zero (after calling `kzalloc()`), leading to the overflow\n\
  issue.\n\nThis fix repositions the `event->datalen = datalen;` update before\naccessing\
  \ `data`, restoring the intended buffer overflow protection. :)\n\nFixes: edec42821911\
  \ (\"wifi: brcmfmac: allow per-vendor event handling\")\nReported-by: Nathan Chancellor\
  \ <nathan@kernel.org>\nCloses: https://gist.github.com/nathanchance/e22f681f3bfc467f15cdf6605021aaa6\n\
  Tested-by: Nathan Chancellor <nathan@kernel.org>\nSigned-off-by: Gustavo A. R. Silva\
  \ <gustavoars@kernel.org>\nReviewed-by: Kees Cook <keescook@chromium.org>\nAcked-by:\
  \ Arend van Spriel <arend.vanspriel@broadcom.com>\nSigned-off-by: Kalle Valo <kvalo@kernel.org>\n\
  Link: https://msgid.link/Zc+3PFCUvLoVlpg8@neat\n\n## Buggy Code\n\n```c\n// Function:\
  \ brcmf_fweh_process_event in drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c\n\
  void brcmf_fweh_process_event(struct brcmf_pub *drvr,\n\t\t\t      struct brcmf_event\
  \ *event_packet,\n\t\t\t      u32 packet_len, gfp_t gfp)\n{\n\tu32 fwevt_idx;\n\t\
  struct brcmf_fweh_info *fweh = drvr->fweh;\n\tstruct brcmf_fweh_queue_item *event;\n\
  \tvoid *data;\n\tu32 datalen;\n\n\t/* get event info */\n\tfwevt_idx = get_unaligned_be32(&event_packet->msg.event_type);\n\
  \tdatalen = get_unaligned_be32(&event_packet->msg.datalen);\n\tdata = &event_packet[1];\n\
  \n\tif (fwevt_idx >= fweh->num_event_codes)\n\t\treturn;\n\n\tif (fwevt_idx != BRCMF_E_IF\
  \ && !fweh->evt_handler[fwevt_idx])\n\t\treturn;\n\n\tif (datalen > BRCMF_DCMD_MAXLEN\
  \ ||\n\t    datalen + sizeof(*event_packet) > packet_len)\n\t\treturn;\n\n\tevent\
  \ = kzalloc(struct_size(event, data, datalen), gfp);\n\tif (!event)\n\t\treturn;\n\
  \n\tevent->code = fwevt_idx;\n\tevent->ifidx = event_packet->msg.ifidx;\n\n\t/*\
  \ use memcpy to get aligned event message */\n\tmemcpy(&event->emsg, &event_packet->msg,\
  \ sizeof(event->emsg));\n\tmemcpy(event->data, data, datalen);\n\tevent->datalen\
  \ = datalen;\n\tmemcpy(event->ifaddr, event_packet->eth.h_dest, ETH_ALEN);\n\n\t\
  brcmf_fweh_queue_event(fweh, event);\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff\
  \ --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c\n\
  index 0774f6c59226..f0b6a7607f16 100644\n--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c\n\
  +++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c\n@@ -497,12 +497,12\
  \ @@ void brcmf_fweh_process_event(struct brcmf_pub *drvr,\n \t\treturn;\n \n \t\
  event->code = fwevt_idx;\n+\tevent->datalen = datalen;\n \tevent->ifidx = event_packet->msg.ifidx;\n\
  \ \n \t/* use memcpy to get aligned event message */\n \tmemcpy(&event->emsg, &event_packet->msg,\
  \ sizeof(event->emsg));\n \tmemcpy(event->data, data, datalen);\n-\tevent->datalen\
  \ = datalen;\n \tmemcpy(event->ifaddr, event_packet->eth.h_dest, ETH_ALEN);\n \n\
  \ \tbrcmf_fweh_queue_event(fweh, event);\n```\n"
pattern: "## Bug Pattern\n\nWriting to a flexible-array member annotated with __counted_by(counter)\
  \ before initializing its counter field.\n\nExample:\nstruct obj {\n    size_t len;\n\
  \    u8 data[] __counted_by(len);\n};\n\nobj = kzalloc(struct_size(obj, data, n),\
  \ GFP_KERNEL);\n/* BUG: len is 0 here due to kzalloc, so FORTIFY/UBSAN see data\
  \ size as 0 */\nmemcpy(obj->data, src, n);\nobj->len = n;\n\nAccesses to data must\
  \ occur only after setting obj->len = n; otherwise, runtime bounds checks (FORTIFY_SOURCE/UBSAN_BOUNDS)\
  \ treat the destination size as zero, flagging an overflow and potentially crashing."
plan: "1) Program State\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(ZeroInitObjMap, const\
  \ MemRegion*, bool)\n  - Tracks base object regions that are known to be zero-initialized\
  \ (e.g., from kzalloc/kcalloc/kvzalloc/vzalloc). Value is always true; presence\
  \ in the map means \u201Cthis object is zeroed\u201D.\n\n- REGISTER_MAP_WITH_PROGRAMSTATE(CounterInitMap,\
  \ const MemRegion*, bool)\n  - Tracks whether a specific counter field (the field\
  \ referenced by __counted_by) in a specific object has been initialized. The key\
  \ must be the FieldRegion of the counter field (i.e., base object + the counter\
  \ FieldDecl). Value true means initialized.\n\nNo alias maps are strictly needed\
  \ if we derive the base object region directly from the MemberExpr of the flexible-array\
  \ member.\n\n\n2) Helper Routines\n\n- bool isZeroingAlloc(const CallEvent &Call)\n\
  \  - Return true for known zero-initializing allocators: kzalloc, kcalloc, kzalloc_array,\
  \ kvzalloc, vzalloc.\n\n- bool isWriteToFirstParamFunction(const CallEvent &Call)\n\
  \  - Return true for functions that write to their first argument: memcpy, __memcpy,\
  \ memmove, copy_from_user. Keep scope minimal to avoid noise.\n\n- const FieldDecl\
  \ *getCountedByCounterField(const FieldDecl *FAMField)\n  - If FAMField has the\
  \ counted_by attribute, return the FieldDecl of the counter field. Use FAMField->hasAttr<CountedByAttr>()\
  \ and attr->getParam() to retrieve the referenced field; resolve that to a FieldDecl\
  \ within the same RecordDecl. If that API is not present, conservatively bail (no\
  \ warning).\n\n- bool isCounterForAnyCountedByField(const FieldDecl *FD)\n  - Scan\
  \ FD->getParent()\u2019s fields; if any flexible-array member field has counted_by(FD),\
  \ return true. Used in checkBind to avoid marking unrelated fields.\n\n- const MemRegion\
  \ *getBaseRegionFromMember(const MemberExpr *ME, CheckerContext &C)\n  - For ME\
  \ referring to \u201Cobj->data\u201D, return the base object region for \u201Cobj\u201D\
  . Use getMemRegionFromExpr(ME->getBase()).\n\n- const FieldRegion *getFieldRegionFor(const\
  \ MemRegion *Base, const FieldDecl *FD, CheckerContext &C)\n  - Using the RegionManager\
  \ from the ProgramState, build a FieldRegion for the given FD on top of the Base\
  \ (cast Base to a suitable TypedValueRegion/DeclRegion if needed). This uniquely\
  \ identifies \u201Cobj->counter\u201D for this particular object.\n\n\n3) Callbacks\
  \ and Logic\n\nA) checkPostCall\n- Purpose: Mark newly created objects as zero-initialized\
  \ when returned from zeroing allocators.\n- Steps:\n  1. If !isZeroingAlloc(Call),\
  \ return.\n  2. Obtain the return SVal: SVal Ret = Call.getReturnValue();\n  3.\
  \ Get the pointee region: const MemRegion *ObjR = Ret.getAsRegion(); If null, return.\n\
  \  4. State = State->set<ZeroInitObjMap>(ObjR, true);\n  5. C.addTransition(State).\n\
  - Notes: We only need to know the region is zeroed; specific counters are initially\
  \ not in CounterInitMap.\n\nB) checkBind\n- Purpose: Detect explicit initialization\
  \ of the counter field (e.g., obj->len = n;).\n- Steps:\n  1. Extract the destination\
  \ location\u2019s region: const MemRegion *R = Loc.getAsRegion(); If null, return.\n\
  \  2. If R is not a FieldRegion, return.\n  3. const FieldDecl *FD = cast<FieldRegion>(R)->getDecl();\n\
  \  4. If !isCounterForAnyCountedByField(FD), return.\n  5. Mark this counter field\
  \ as initialized: State = State->set<CounterInitMap>(R, true);\n  6. C.addTransition(State).\n\
  - Notes: We only mark when the field is a known counter for some counted_by flexible\
  \ array. We do not need to check the value assigned.\n\nC) checkPreCall\n- Purpose:\
  \ Before a write call like memcpy/memmove/copy_from_user, ensure that writes to\
  \ a flexible-array member annotated with __counted_by happen only after its counter\
  \ is initialized.\n- Steps:\n  1. If !isWriteToFirstParamFunction(Call), return.\n\
  \  2. Expr *DstArg = Call.getArgExpr(0); Find the flexible-array member in DstArg:\n\
  \     - Try dyn_cast<MemberExpr>(DstArg->IgnoreParenCasts()).\n     - If null, call\
  \ findSpecificTypeInChildren<MemberExpr>(DstArg). If still null, return.\n  3. const\
  \ MemberExpr *ME = ...\n     - const FieldDecl *FAMField = dyn_cast<FieldDecl>(ME->getMemberDecl());\
  \ If null, return.\n     - Ensure it is a flexible-array member: FAMField->getType()->isIncompleteArrayType().\
  \ If false, return.\n     - Ensure it has counted_by: FAMField->hasAttr<CountedByAttr>().\
  \ If false, return.\n  4. Retrieve the counter FieldDecl: const FieldDecl *CounterFD\
  \ = getCountedByCounterField(FAMField); If null, return.\n  5. Get base object region:\
  \ const MemRegion *BaseR = getBaseRegionFromMember(ME, C); If null, return.\n  6.\
  \ Check if this object is known zero-initialized: if (!State->contains<ZeroInitObjMap>(BaseR))\
  \ return; Only warn for zero-initialized objects (the concrete bug pattern).\n \
  \ 7. Build the FieldRegion for the counter: const FieldRegion *CounterFR = getFieldRegionFor(BaseR,\
  \ CounterFD, C); If null, return.\n  8. If State->lookup<CounterInitMap>(CounterFR)\
  \ is not true:\n     - Generate a non-fatal error node: ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \     - Emit a PathSensitiveBugReport with message like:\n       \"Write to flexible\
  \ array before setting its __counted_by counter\"\n       Optionally include names:\
  \ \"Writing to \u2018<FAMField->getNameAsString()>\u2019 before initializing \u2018\
  <CounterFD->getNameAsString()>\u2019\".\n     - C.emitReport(...)\n- Notes: This\
  \ directly flags the brcmfmac bug where memcpy(event->data, ...) precedes event->datalen\
  \ = datalen; after kzalloc zeroed the object.\n\nD) (Optional) checkLocation\n-\
  \ Purpose: Catch direct stores into the flexible-array member, e.g., obj->data[i]\
  \ = ...;.\n- Steps:\n  1. If IsLoad, return.\n  2. If Loc is an ElementRegion whose\
  \ super-region is a FieldRegion FR on a flexible-array member with counted_by, then\
  \ apply the same logic as in checkPreCall:\n     - Obtain BaseR from FR->getSuperRegion(),\
  \ obtain FAMField and CounterFD, build CounterFR, and check ZeroInitObjMap[BaseR]\
  \ and CounterInitMap[CounterFR]. If zero-initialized and not initialized counter,\
  \ report.\n\n\n4) Additional Details\n\n- How to find the counter from the attribute:\n\
  \  - Use FAMField->getAttr<CountedByAttr>()->getParam() to obtain the referenced\
  \ expression, then resolve to a FieldDecl within the same RecordDecl. If resolution\
  \ is not straightforward or the attribute API differs, fall back to scanning the\
  \ RecordDecl fields for a name match with ExprHasName.\n\n- Minimizing false positives:\n\
  \  - Only warn if the base object is known zero-initialized (via kzalloc/kcalloc/etc.)\
  \ and the specific counter field for the flexible array has not been marked initialized\
  \ on the current path.\n  - Do not warn if we fail to resolve regions or the counted_by\
  \ relation.\n\n- Bug type:\n  - Keep a single BugType member: \"Counted-by flexible\
  \ array write before counter init\".\n  - Short message as required: \"Write to\
  \ flexible array before setting its __counted_by counter\".\n\n\n5) Summary of the\
  \ Flow for the Target Patch\n\n- PostCall on kzalloc marks \u2018event\u2019 object\
  \ region as zero-initialized.\n- PreCall on memcpy detects first argument is event->data,\
  \ confirms it is a flexible array with counted_by(datalen), finds base region (event),\
  \ sees base is zero-initialized and event->datalen not yet set in CounterInitMap,\
  \ and emits a report.\n- Later, when event->datalen = datalen executes, checkBind\
  \ marks the counter initialized, preventing further reports on subsequent writes\
  \ to event->data."
refined_plan: null
repaired_checker_code: "#include <memory>\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/Attr.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/IdentifierTable.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\nREGISTER_MAP_WITH_PROGRAMSTATE(ZeroInitObjMap,\
  \ const MemRegion*, bool)\nREGISTER_MAP_WITH_PROGRAMSTATE(CounterInitBaseMap, const\
  \ MemRegion*, bool)\n\nnamespace {\n\n// SFINAE helpers to adapt to different Clang\
  \ CountedByAttr APIs across versions.\ntemplate <typename AttrT>\nstatic auto tryGetIdentifierFromCountedBy(const\
  \ AttrT *A, int)\n    -> decltype(A->getCountedBy(), (const IdentifierInfo *)nullptr)\
  \ {\n  return A->getCountedBy();\n}\ntemplate <typename AttrT>\nstatic const IdentifierInfo\
  \ *tryGetIdentifierFromCountedBy(const AttrT *, long) {\n  return nullptr;\n}\n\n\
  template <typename AttrT>\nstatic auto tryGetFieldFromCountedBy(const AttrT *A,\
  \ int)\n    -> decltype(static_cast<const FieldDecl *>(A->getCountedByField()),\
  \ (const FieldDecl *)nullptr) {\n  return A->getCountedByField();\n}\ntemplate <typename\
  \ AttrT>\nstatic const FieldDecl *tryGetFieldFromCountedBy(const AttrT *, long)\
  \ {\n  return nullptr;\n}\n\ntemplate <typename AttrT>\nstatic auto tryGetExprFromCountedByExpr(const\
  \ AttrT *A, int)\n    -> decltype(A->getCountedByExpr(), (const Expr *)nullptr)\
  \ {\n  return A->getCountedByExpr();\n}\ntemplate <typename AttrT>\nstatic const\
  \ Expr *tryGetExprFromCountedByExpr(const AttrT *, long) {\n  return nullptr;\n\
  }\n\ntemplate <typename AttrT>\nstatic auto tryGetExprGeneric(const AttrT *A, int)\n\
  \    -> decltype(A->getExpr(), (const Expr *)nullptr) {\n  return A->getExpr();\n\
  }\ntemplate <typename AttrT>\nstatic const Expr *tryGetExprGeneric(const AttrT *,\
  \ long) {\n  return nullptr;\n}\n\ntemplate <typename AttrT>\nstatic auto tryGetArgumentExpr(const\
  \ AttrT *A, int)\n    -> decltype(A->getArgument(), (const Expr *)nullptr) {\n \
  \ return A->getArgument();\n}\ntemplate <typename AttrT>\nstatic const Expr *tryGetArgumentExpr(const\
  \ AttrT *, long) {\n  return nullptr;\n}\n\nclass SAGenTestChecker\n    : public\
  \ Checker<\n          check::PostCall,\n          check::PreCall,\n          check::Bind\n\
  \      > {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n\
  \      : BT(new BugType(this, \"Write to flexible array before setting its __counted_by\
  \ counter\",\n                       \"Memory Safety\")) {}\n\n  void checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const;\n  void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n  void checkBind(SVal Loc, SVal Val, const Stmt\
  \ *S, CheckerContext &C) const;\n\nprivate:\n  // Helpers\n  static bool isZeroingAlloc(const\
  \ CallEvent &Call, CheckerContext &C);\n  static bool isWriteToFirstParamFunction(const\
  \ CallEvent &Call, CheckerContext &C);\n\n  static const MemRegion *getBaseRegionFromMember(const\
  \ MemberExpr *ME, CheckerContext &C);\n\n  static bool fieldIsFlexibleArray(const\
  \ FieldDecl *FD);\n  static bool fieldHasCountedBy(const FieldDecl *FD);\n\n  static\
  \ const FieldDecl *getCountedByCounterField(const FieldDecl *FAMField);\n  static\
  \ bool isCounterForAnyCountedByField(const FieldDecl *FD, CheckerContext &C);\n\n\
  \  void reportBeforeCounterInit(const CallEvent &Call, const MemberExpr *DstME,\n\
  \                               const FieldDecl *FAMField, CheckerContext &C) const;\n\
  };\n\n// Determine if a call is a zero-initializing allocation.\nbool SAGenTestChecker::isZeroingAlloc(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE)\n    return false;\n\n  // Common kernel zeroing allocators\n  if (ExprHasName(OE,\
  \ \"kzalloc\", C)) return true;\n  if (ExprHasName(OE, \"kcalloc\", C)) return true;\n\
  \  if (ExprHasName(OE, \"kzalloc_array\", C)) return true;\n  if (ExprHasName(OE,\
  \ \"kvzalloc\", C)) return true;\n  if (ExprHasName(OE, \"vzalloc\", C)) return\
  \ true;\n\n  // Device-managed variants (optional, but safe to recognize)\n  if\
  \ (ExprHasName(OE, \"devm_kzalloc\", C)) return true;\n  if (ExprHasName(OE, \"\
  devm_kcalloc\", C)) return true;\n\n  return false;\n}\n\n// Functions that (likely)\
  \ write to their first parameter.\nbool SAGenTestChecker::isWriteToFirstParamFunction(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *OE = Call.getOriginExpr();\n\
  \  if (!OE)\n    return false;\n\n  // Keep minimal but sufficient for the target\
  \ bug\n  if (ExprHasName(OE, \"memcpy\", C)) return true;\n  if (ExprHasName(OE,\
  \ \"__memcpy\", C)) return true;\n  if (ExprHasName(OE, \"memmove\", C)) return\
  \ true;\n  if (ExprHasName(OE, \"copy_from_user\", C)) return true;\n\n  return\
  \ false;\n}\n\nconst MemRegion *SAGenTestChecker::getBaseRegionFromMember(const\
  \ MemberExpr *ME, CheckerContext &C) {\n  if (!ME)\n    return nullptr;\n\n  //\
  \ Important: do not IgnoreImplicit() before calling getMemRegionFromExpr\n  const\
  \ Expr *BaseE = ME->getBase();\n  if (!BaseE)\n    return nullptr;\n\n  const MemRegion\
  \ *MR = getMemRegionFromExpr(BaseE, C);\n  if (!MR)\n    return nullptr;\n\n  MR\
  \ = MR->getBaseRegion();\n  return MR;\n}\n\nbool SAGenTestChecker::fieldIsFlexibleArray(const\
  \ FieldDecl *FD) {\n  if (!FD)\n    return false;\n  QualType QT = FD->getType();\n\
  \  if (QT.isNull())\n    return false;\n\n  // Flexible array members are incomplete\
  \ arrays in C\n  return QT->isIncompleteArrayType();\n}\n\nbool SAGenTestChecker::fieldHasCountedBy(const\
  \ FieldDecl *FD) {\n  if (!FD)\n    return false;\n  return FD->hasAttr<CountedByAttr>();\n\
  }\n\n// Try to resolve the FieldDecl referenced by the counted_by attribute.\nconst\
  \ FieldDecl *SAGenTestChecker::getCountedByCounterField(const FieldDecl *FAMField)\
  \ {\n  if (!FAMField)\n    return nullptr;\n\n  const auto *Attr = FAMField->getAttr<CountedByAttr>();\n\
  \  if (!Attr)\n    return nullptr;\n\n  const RecordDecl *RD = FAMField->getParent();\n\
  \  if (!RD)\n    return nullptr;\n\n  // 1) Prefer direct FieldDecl if available\
  \ from the attribute.\n  if (const FieldDecl *FD = tryGetFieldFromCountedBy(Attr,\
  \ 0))\n    return FD;\n\n  // 2) Try IdentifierInfo accessor if available.\n  if\
  \ (const IdentifierInfo *II = tryGetIdentifierFromCountedBy(Attr, 0)) {\n    for\
  \ (const FieldDecl *F : RD->fields()) {\n      if (F->getIdentifier() == II)\n \
  \       return F;\n    }\n  }\n\n  // 3) Try various Expr accessors to resolve to\
  \ a DeclRefExpr to FieldDecl.\n  if (const Expr *E = tryGetExprFromCountedByExpr(Attr,\
  \ 0)) {\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenCasts()))\n\
  \      return dyn_cast<FieldDecl>(DRE->getDecl());\n  }\n  if (const Expr *E = tryGetExprGeneric(Attr,\
  \ 0)) {\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenCasts()))\n\
  \      return dyn_cast<FieldDecl>(DRE->getDecl());\n  }\n  if (const Expr *E = tryGetArgumentExpr(Attr,\
  \ 0)) {\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenCasts()))\n\
  \      return dyn_cast<FieldDecl>(DRE->getDecl());\n  }\n\n  return nullptr;\n}\n\
  \n// Check whether FD is the counter for any counted_by FAM field within the same\
  \ record.\nbool SAGenTestChecker::isCounterForAnyCountedByField(const FieldDecl\
  \ *FD, CheckerContext &C) {\n  if (!FD)\n    return false;\n\n  const RecordDecl\
  \ *RD = FD->getParent();\n  if (!RD)\n    return false;\n\n  for (const FieldDecl\
  \ *F : RD->fields()) {\n    if (!fieldHasCountedBy(F))\n      continue;\n\n    //\
  \ Resolve the FieldDecl from the attribute and compare.\n    if (const FieldDecl\
  \ *CounterFD = getCountedByCounterField(F)) {\n      if (CounterFD == FD)\n    \
  \    return true;\n      continue;\n    }\n  }\n  return false;\n}\n\nvoid SAGenTestChecker::reportBeforeCounterInit(const\
  \ CallEvent &Call, const MemberExpr *DstME,\n                                  \
  \             const FieldDecl *FAMField, CheckerContext &C) const {\n  if (!BT)\n\
  \    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  SmallString<128> Msg;\n  Msg += \"Write to flexible array before\
  \ setting its __counted_by counter\";\n  if (FAMField) {\n    Msg += \" (\";\n \
  \   Msg += FAMField->getName();\n    Msg += \")\";\n  }\n\n  auto R = std::make_unique<PathSensitiveBugReport>(*BT,\
  \ Msg, N);\n  if (const Expr *OE = Call.getOriginExpr())\n    R->addRange(OE->getSourceRange());\n\
  \  if (DstME)\n    R->addRange(DstME->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n// Mark zero-initialized objects when returned from zeroing allocators.\nvoid\
  \ SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const\
  \ {\n  if (!isZeroingAlloc(Call, C))\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \n  SVal Ret = Call.getReturnValue();\n  const MemRegion *MR = Ret.getAsRegion();\n\
  \  if (!MR)\n    return;\n\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  State = State->set<ZeroInitObjMap>(MR, true);\n  C.addTransition(State);\n}\n\
  \n// Detect writes to FAM with counted_by before counter init.\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isWriteToFirstParamFunction(Call,\
  \ C))\n    return;\n\n  if (Call.getNumArgs() < 1)\n    return;\n\n  const Expr\
  \ *DstArgE = Call.getArgExpr(0);\n  if (!DstArgE)\n    return;\n\n  // Try to find\
  \ a MemberExpr inside the destination argument, e.g., event->data\n  const MemberExpr\
  \ *DstME = dyn_cast<MemberExpr>(DstArgE->IgnoreParenCasts());\n  if (!DstME)\n \
  \   DstME = findSpecificTypeInChildren<MemberExpr>(DstArgE);\n  if (!DstME)\n  \
  \  return;\n\n  const ValueDecl *VD = DstME->getMemberDecl();\n  const FieldDecl\
  \ *FAMField = dyn_cast_or_null<FieldDecl>(VD);\n  if (!FAMField)\n    return;\n\n\
  \  // Must be a flexible-array member\n  if (!fieldIsFlexibleArray(FAMField))\n\
  \    return;\n\n  // Must have __counted_by attribute\n  if (!fieldHasCountedBy(FAMField))\n\
  \    return;\n\n  // Get the base object region holding this field, e.g., 'event'\n\
  \  const MemRegion *BaseR = getBaseRegionFromMember(DstME, C);\n  if (!BaseR)\n\
  \    return;\n\n  // Only warn for objects we know are zero-initialized by kzalloc/kcalloc/...\n\
  \  ProgramStateRef State = C.getState();\n  const bool *IsZeroed = State->get<ZeroInitObjMap>(BaseR);\n\
  \  if (!IsZeroed || !*IsZeroed)\n    return;\n\n  // Has the (relevant) counter\
  \ field been initialized?\n  const bool *CounterInit = State->get<CounterInitBaseMap>(BaseR);\n\
  \  if (CounterInit && *CounterInit)\n    return;\n\n  // Not initialized yet: report\n\
  \  reportBeforeCounterInit(Call, DstME, FAMField, C);\n}\n\n// Observe assignments\
  \ to fields that are counters of counted_by flexible arrays.\n// When we see e.g.\
  \ \"obj->len = n;\", mark the base object as having initialized\n// the counter.\n\
  void SAGenTestChecker::checkBind(SVal Loc, SVal /*Val*/, const Stmt * /*S*/, CheckerContext\
  \ &C) const {\n  const MemRegion *R = Loc.getAsRegion();\n  if (!R)\n    return;\n\
  \n  const FieldRegion *FR = dyn_cast<FieldRegion>(R);\n  if (!FR)\n    return;\n\
  \n  const FieldDecl *FD = FR->getDecl();\n  if (!FD)\n    return;\n\n  // Only consider\
  \ fields that are counters for a counted_by FAM in this record.\n  if (!isCounterForAnyCountedByField(FD,\
  \ C))\n    return;\n\n  // Mark the base object as having its counter initialized.\n\
  \  const MemRegion *BaseR = FR->getSuperRegion();\n  if (!BaseR)\n    return;\n\n\
  \  BaseR = BaseR->getBaseRegion();\n  if (!BaseR)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  State = State->set<CounterInitBaseMap>(BaseR, true);\n\
  \  C.addTransition(State);\n}\n\n} // end anonymous namespace\n\nextern \"C\" void\
  \ clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects writes to __counted_by flexible\
  \ arrays before initializing their counter (after zeroing alloc)\",\n      \"\"\
  );\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
