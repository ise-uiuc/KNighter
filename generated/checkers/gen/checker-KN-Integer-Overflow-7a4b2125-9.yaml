_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 7a4b21250bf79eef26543d35bd390448646c536b
commit_type: Integer-Overflow
index: 9
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include <memory>\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// Track variables bound to the\
  \ result of roundup_pow_of_two(arg).\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion *, const Expr *)\n\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::Bind, check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unsafe overflow\
  \ check after roundup_pow_of_two\", \"API Misuse\")) {}\n\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n      static bool is32BitULong(CheckerContext\
  \ &C);\n      static const Expr *extractZeroTestedExpr(const Expr *CondE, CheckerContext\
  \ &C);\n      static bool isRoundupPow2Call(const CallExpr *CE, CheckerContext &C);\n\
  };\n\nbool SAGenTestChecker::is32BitULong(CheckerContext &C) {\n  const ASTContext\
  \ &ACtx = C.getASTContext();\n  return ACtx.getTypeSize(ACtx.UnsignedLongTy) ==\
  \ 32;\n}\n\nbool SAGenTestChecker::isRoundupPow2Call(const CallExpr *CE, CheckerContext\
  \ &C) {\n  if (!CE) return false;\n  const Expr *Callee = CE->getCallee();\n  if\
  \ (!Callee) return false;\n  // Use source text-based match as suggested.\n  return\
  \ ExprHasName(Callee, \"roundup_pow_of_two\", C);\n}\n\nconst Expr *SAGenTestChecker::extractZeroTestedExpr(const\
  \ Expr *CondE, CheckerContext &C) {\n  if (!CondE) return nullptr;\n  const ASTContext\
  \ &ACtx = C.getASTContext();\n  const Expr *E = CondE->IgnoreParenImpCasts();\n\n\
  \  if (const auto *U = dyn_cast<UnaryOperator>(E)) {\n    if (U->getOpcode() ==\
  \ UO_LNot) {\n      return U->getSubExpr()->IgnoreParenImpCasts();\n    }\n  }\n\
  \n  if (const auto *B = dyn_cast<BinaryOperator>(E)) {\n    if (B->getOpcode() ==\
  \ BO_EQ) {\n      const Expr *L = B->getLHS()->IgnoreParenImpCasts();\n      const\
  \ Expr *R = B->getRHS()->IgnoreParenImpCasts();\n\n      llvm::APSInt Val;\n   \
  \   if (EvaluateExprToInt(Val, R, C)) {\n        if (Val == 0)\n          return\
  \ L;\n      }\n      if (EvaluateExprToInt(Val, L, C)) {\n        if (Val == 0)\n\
  \          return R;\n      }\n    }\n  }\n\n  return nullptr;\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  const MemRegion *R = Loc.getAsRegion();\n  if (!R)\n    return;\n\
  \  R = R->getBaseRegion();\n  if (!R)\n    return;\n\n  const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(S);\n\
  \  if (!CE) {\n    // Not binding from a call expression; clear any prior tracking.\n\
  \    State = State->remove<RoundupResMap>(R);\n    C.addTransition(State);\n   \
  \ return;\n  }\n\n  if (isRoundupPow2Call(CE, C)) {\n    if (CE->getNumArgs() >=\
  \ 1) {\n      const Expr *ArgE = CE->getArg(0);\n      if (ArgE) {\n        State\
  \ = State->set<RoundupResMap>(R, ArgE->IgnoreImpCasts());\n        C.addTransition(State);\n\
  \        return;\n      }\n    }\n  }\n\n  // Some other call; clear tracking for\
  \ this region.\n  State = State->remove<RoundupResMap>(R);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!is32BitULong(C))\n    return;\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n\
  \  if (!CondE)\n    return;\n\n  const Expr *X = extractZeroTestedExpr(CondE, C);\n\
  \  if (!X)\n    return;\n\n  // Case 1: Direct call in condition.\n  if (const auto\
  \ *CE = dyn_cast<CallExpr>(X->IgnoreParenImpCasts())) {\n    if (isRoundupPow2Call(CE,\
  \ C)) {\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n      if (!N)\n\
  \        return;\n\n      auto R = std::make_unique<PathSensitiveBugReport>(\n \
  \         *BT,\n          \"roundup_pow_of_two() overflow cannot be detected via\
  \ == 0 on 32-bit; pre-check the input before rounding\",\n          N);\n      R->addRange(Condition->getSourceRange());\n\
  \      C.emitReport(std::move(R));\n      return;\n    }\n  }\n\n  // Case 2: Variable\
  \ that was assigned from roundup_pow_of_two().\n  const MemRegion *MR = getMemRegionFromExpr(X,\
  \ C);\n  if (!MR)\n    return;\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n  const Expr *const *TrackedArg = State->get<RoundupResMap>(MR);\n\
  \  if (!TrackedArg)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto Rpt = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"roundup_pow_of_two() overflow cannot be detected via == 0 on\
  \ 32-bit; pre-check the input before rounding\",\n      N);\n  Rpt->addRange(Condition->getSourceRange());\n\
  \  C.emitReport(std::move(Rpt));\n}\n\n} // end anonymous namespace\n\nextern \"\
  C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Warns when code checks roundup_pow_of_two(x)\
  \ == 0 on 32-bit; pre-check x before rounding\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbpf: Fix stackmap overflow check on 32-bit arches\n\
  \nThe stackmap code relies on roundup_pow_of_two() to compute the number\nof hash\
  \ buckets, and contains an overflow check by checking if the\nresulting value is\
  \ 0. However, on 32-bit arches, the roundup code itself\ncan overflow by doing a\
  \ 32-bit left-shift of an unsigned long value,\nwhich is undefined behaviour, so\
  \ it is not guaranteed to truncate\nneatly. This was triggered by syzbot on the\
  \ DEVMAP_HASH type, which\ncontains the same check, copied from the hashtab code.\n\
  \nThe commit in the fixes tag actually attempted to fix this, but the fix\ndid not\
  \ account for the UB, so the fix only works on CPUs where an\noverflow does result\
  \ in a neat truncation to zero, which is not\nguaranteed. Checking the value before\
  \ rounding does not have this\nproblem.\n\nFixes: 6183f4d3a0a2 (\"bpf: Check for\
  \ integer overflow when using roundup_pow_of_two()\")\nSigned-off-by: Toke H\xF8\
  iland-J\xF8rgensen <toke@redhat.com>\nReviewed-by: Bui Quang Minh <minhquangbui99@gmail.com>\n\
  Message-ID: <20240307120340.99577-4-toke@redhat.com>\nSigned-off-by: Alexei Starovoitov\
  \ <ast@kernel.org>\n\n## Buggy Code\n\n```c\n// Function: stack_map_alloc in kernel/bpf/stackmap.c\n\
  static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n{\n\tu32 value_size\
  \ = attr->value_size;\n\tstruct bpf_stack_map *smap;\n\tu64 cost, n_buckets;\n\t\
  int err;\n\n\tif (attr->map_flags & ~STACK_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size\
  \ != 4 ||\n\t    value_size < 8 || value_size % 8)\n\t\treturn ERR_PTR(-EINVAL);\n\
  \n\tBUILD_BUG_ON(sizeof(struct bpf_stack_build_id) % sizeof(u64));\n\tif (attr->map_flags\
  \ & BPF_F_STACK_BUILD_ID) {\n\t\tif (value_size % sizeof(struct bpf_stack_build_id)\
  \ ||\n\t\t    value_size / sizeof(struct bpf_stack_build_id)\n\t\t    > sysctl_perf_event_max_stack)\n\
  \t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n\
  \t\treturn ERR_PTR(-EINVAL);\n\n\t/* hash table size must be power of 2 */\n\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n\tif (!n_buckets)\n\t\treturn ERR_PTR(-E2BIG);\n\
  \n\tcost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);\n\tsmap\
  \ = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\tif (!smap)\n\t\t\
  return ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&smap->map, attr);\n\tsmap->n_buckets\
  \ = n_buckets;\n\n\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\t\
  if (err)\n\t\tgoto free_smap;\n\n\terr = prealloc_elems_and_freelist(smap);\n\t\
  if (err)\n\t\tgoto put_buffers;\n\n\treturn &smap->map;\n\nput_buffers:\n\tput_callchain_buffers();\n\
  free_smap:\n\tbpf_map_area_free(smap);\n\treturn ERR_PTR(err);\n}\n```\n\n## Bug\
  \ Fix Patch\n\n```diff\ndiff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c\n\
  index dff7ba539701..c99f8e5234ac 100644\n--- a/kernel/bpf/stackmap.c\n+++ b/kernel/bpf/stackmap.c\n\
  @@ -91,11 +91,14 @@ static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n\
  \ \t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n \t\treturn ERR_PTR(-EINVAL);\n\
  \ \n-\t/* hash table size must be power of 2 */\n-\tn_buckets = roundup_pow_of_two(attr->max_entries);\n\
  -\tif (!n_buckets)\n+\t/* hash table size must be power of 2; roundup_pow_of_two()\
  \ can overflow\n+\t * into UB on 32-bit arches, so check that first\n+\t */\n+\t\
  if (attr->max_entries > 1UL << 31)\n \t\treturn ERR_PTR(-E2BIG);\n \n+\tn_buckets\
  \ = roundup_pow_of_two(attr->max_entries);\n+\n \tcost = n_buckets * sizeof(struct\
  \ stack_map_bucket *) + sizeof(*smap);\n \tsmap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\
  \ \tif (!smap)\n```\n"
pattern: '## Bug Pattern


  Relying on roundup_pow_of_two(x) to detect overflow (e.g., by checking the result
  for 0) while passing it an unbounded 32-bit value. On 32-bit arches, roundup_pow_of_two()
  may perform a left shift by BITS_PER_LONG (e.g., 1UL << 32), which is undefined
  behavior; thus the result is not guaranteed to become 0 and the overflow check can
  be bypassed.


  Buggy pattern:

  - n = roundup_pow_of_two(x);

  - if (!n) // assume overflow

  -   error;


  Correct pattern:

  - if (x > 1UL << (BITS_PER_LONG - 1)) // largest representable power-of-two

  -   error;

  - n = roundup_pow_of_two(x);'
plan: "Plan: Detect unsafe overflow check relying on roundup_pow_of_two() result being\
  \ 0 on 32-bit arches\n\n1. Program State\n- Use one map to remember which variables\
  \ hold the result of roundup_pow_of_two():\n  - REGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion*, const Expr*)\n  - Key: the LHS MemRegion being assigned.\n \
  \ - Value: the original input expression passed to roundup_pow_of_two() (for diagnostics).\n\
  - No alias or taint tracking: keep it simple and focus on direct assignments and\
  \ direct calls in conditions.\n\n2. Callbacks and Logic\n\n2.1 checkBind(SVal Loc,\
  \ SVal Val, const Stmt *S, CheckerContext &C)\n- Goal: Track when a variable is\
  \ assigned the result of roundup_pow_of_two(x).\n- Steps:\n  - Get the destination\
  \ MemRegion: const MemRegion *R = Loc.getAsRegion(); if null, return.\n  - Find\
  \ a CallExpr in S using findSpecificTypeInChildren<CallExpr>(S). If none, this is\
  \ a normal bind:\n    - Remove any prior tracking for R: State = State->remove<RoundupResMap>(R);\
  \ C.addTransition(State).\n    - Return.\n  - If there is a CallExpr, check if its\
  \ callee identifier name equals \"roundup_pow_of_two\" (use callee IdentifierInfo\
  \ or fallback to ExprHasName on the textual callee if needed).\n  - If callee matches:\n\
  \    - Extract the argument expression ArgE = CE->getArg(0)->IgnoreImpCasts().\n\
  \    - State = State->set<RoundupResMap>(R, ArgE); C.addTransition(State).\n  -\
  \ Else (other call assigned):\n    - State = State->remove<RoundupResMap>(R); C.addTransition(State).\n\
  \n2.2 checkBranchCondition(const Stmt *Condition, CheckerContext &C)\n- Goal: Flag\
  \ conditions that test the result of roundup_pow_of_two() for zero to detect overflow.\n\
  - Only run on 32-bit unsigned long targets to avoid false positives:\n  - if (C.getASTContext().getTypeSize(C.getASTContext().LongTy)\
  \ != 32) return;\n- Extract the \u201Czero-tested\u201D subexpression X from the\
  \ condition:\n  - Let CondE = dyn_cast<Expr>(Condition)->IgnoreImpCasts().\n  -\
  \ Pattern A (logical not): if (const auto *U = dyn_cast<UnaryOperator>(CondE)) and\
  \ U->getOpcode() == UO_LNot:\n    - X = U->getSubExpr()->IgnoreImpCasts().\n  -\
  \ Pattern B (binary == 0): if (const auto *B = dyn_cast<BinaryOperator>(CondE))\
  \ and B->getOpcode() == BO_EQ:\n    - If RHS is integer constant 0 (use EvaluateExprToInt\
  \ on B->getRHS() and check equals 0), set X = B->getLHS()->IgnoreImpCasts().\n \
  \   - Else if LHS is integer constant 0, set X = B->getRHS()->IgnoreImpCasts().\n\
  \  - If neither pattern matches, return.\n- Determine if X is derived from roundup_pow_of_two():\n\
  \  - Case 1: X is a direct call: if (const CallExpr *CE = dyn_cast<CallExpr>(X))\
  \ and its callee name is \"roundup_pow_of_two\": report.\n  - Case 2: X is a variable/expression\
  \ with a MemRegion:\n    - const MemRegion *R = getMemRegionFromExpr(X, C).\n  \
  \  - If R is null, return.\n    - Look up RoundupResMap[R]. If it exists, report.\n\
  - Emit bug:\n  - Create a non-fatal error node. If null, return.\n  - Use a PathSensitiveBugReport\
  \ with a short message, e.g.:\n    - \"Do not use roundup_pow_of_two(x) == 0 to\
  \ detect overflow on 32-bit; left shift may be undefined. Pre-check x > 1UL << 31\
  \ before rounding.\"\n  - Add range: Condition->getSourceRange().\n  - Optionally\
  \ add a note pointing to the assignment or call site (if RoundupResMap provided\
  \ ArgE or if X was a CallExpr).\n\n3. Helper Checks and Utilities\n- isRoundupPow2Call(const\
  \ CallExpr *CE, CheckerContext &C):\n  - Return true if CE has callee IdentifierInfo\
  \ and name equals \"roundup_pow_of_two\".\n  - If IdentifierInfo is not available\
  \ (macro), optionally fallback using ExprHasName on the callee expression.\n- extractZeroTestedExpr(Expr\
  \ *CondE): Implement logic from 2.2 to return X or nullptr.\n- is32BitULong(CheckerContext\
  \ &C): getTypeSize(LongTy) == 32.\n- Use provided utilities:\n  - findSpecificTypeInChildren\
  \ to detect the CallExpr in checkBind.\n  - EvaluateExprToInt to check for 0 in\
  \ equality comparisons.\n  - getMemRegionFromExpr to map expressions to regions\
  \ for RoundupResMap.\n\n4. Reporting\n- BugType: One BugType instance, e.g., \"\
  Unsafe overflow check after roundup_pow_of_two\".\n- Report message (short and clear):\n\
  \  - \"roundup_pow_of_two() overflow cannot be detected via == 0 on 32-bit; pre-check\
  \ the input before rounding.\"\n\n5. Notes and Scope\n- This checker warns only\
  \ on 32-bit unsigned long targets to match the UB scenario.\n- It detects both:\n\
  \  - Direct condition: if (!roundup_pow_of_two(x)) / if (roundup_pow_of_two(x) ==\
  \ 0)\n  - Indirect via variable: n = roundup_pow_of_two(x); if (!n) ...\n- On any\
  \ re-assignment to a tracked variable, the map entry is removed to avoid stale tracking."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include <memory>\n\nusing namespace clang;\n\
  using namespace ento;\nusing namespace taint;\n\n// Track variables bound to the\
  \ result of roundup_pow_of_two(arg).\nREGISTER_MAP_WITH_PROGRAMSTATE(RoundupResMap,\
  \ const MemRegion *, const Expr *)\n\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::Bind, check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Unsafe overflow\
  \ check after roundup_pow_of_two\", \"API Misuse\")) {}\n\n      void checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n      void checkBranchCondition(const\
  \ Stmt *Condition, CheckerContext &C) const;\n\n   private:\n      static bool is32BitULong(CheckerContext\
  \ &C);\n      static const Expr *extractZeroTestedExpr(const Expr *CondE, CheckerContext\
  \ &C);\n      static bool isRoundupPow2Call(const CallExpr *CE, CheckerContext &C);\n\
  };\n\nbool SAGenTestChecker::is32BitULong(CheckerContext &C) {\n  const ASTContext\
  \ &ACtx = C.getASTContext();\n  return ACtx.getTypeSize(ACtx.UnsignedLongTy) ==\
  \ 32;\n}\n\nbool SAGenTestChecker::isRoundupPow2Call(const CallExpr *CE, CheckerContext\
  \ &C) {\n  if (!CE) return false;\n  const Expr *Callee = CE->getCallee();\n  if\
  \ (!Callee) return false;\n  // Use source text-based match as suggested.\n  return\
  \ ExprHasName(Callee, \"roundup_pow_of_two\", C);\n}\n\nconst Expr *SAGenTestChecker::extractZeroTestedExpr(const\
  \ Expr *CondE, CheckerContext &C) {\n  if (!CondE) return nullptr;\n  const ASTContext\
  \ &ACtx = C.getASTContext();\n  const Expr *E = CondE->IgnoreParenImpCasts();\n\n\
  \  if (const auto *U = dyn_cast<UnaryOperator>(E)) {\n    if (U->getOpcode() ==\
  \ UO_LNot) {\n      return U->getSubExpr()->IgnoreParenImpCasts();\n    }\n  }\n\
  \n  if (const auto *B = dyn_cast<BinaryOperator>(E)) {\n    if (B->getOpcode() ==\
  \ BO_EQ) {\n      const Expr *L = B->getLHS()->IgnoreParenImpCasts();\n      const\
  \ Expr *R = B->getRHS()->IgnoreParenImpCasts();\n\n      llvm::APSInt Val;\n   \
  \   if (EvaluateExprToInt(Val, R, C)) {\n        if (Val == 0)\n          return\
  \ L;\n      }\n      if (EvaluateExprToInt(Val, L, C)) {\n        if (Val == 0)\n\
  \          return R;\n      }\n    }\n  }\n\n  return nullptr;\n}\n\nvoid SAGenTestChecker::checkBind(SVal\
  \ Loc, SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n\n  const MemRegion *R = Loc.getAsRegion();\n  if (!R)\n    return;\n\
  \  R = R->getBaseRegion();\n  if (!R)\n    return;\n\n  const CallExpr *CE = findSpecificTypeInChildren<CallExpr>(S);\n\
  \  if (!CE) {\n    // Not binding from a call expression; clear any prior tracking.\n\
  \    State = State->remove<RoundupResMap>(R);\n    C.addTransition(State);\n   \
  \ return;\n  }\n\n  if (isRoundupPow2Call(CE, C)) {\n    if (CE->getNumArgs() >=\
  \ 1) {\n      const Expr *ArgE = CE->getArg(0);\n      if (ArgE) {\n        State\
  \ = State->set<RoundupResMap>(R, ArgE->IgnoreImpCasts());\n        C.addTransition(State);\n\
  \        return;\n      }\n    }\n  }\n\n  // Some other call; clear tracking for\
  \ this region.\n  State = State->remove<RoundupResMap>(R);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  if (!is32BitULong(C))\n    return;\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n\
  \  if (!CondE)\n    return;\n\n  const Expr *X = extractZeroTestedExpr(CondE, C);\n\
  \  if (!X)\n    return;\n\n  // Case 1: Direct call in condition.\n  if (const auto\
  \ *CE = dyn_cast<CallExpr>(X->IgnoreParenImpCasts())) {\n    if (isRoundupPow2Call(CE,\
  \ C)) {\n      ExplodedNode *N = C.generateNonFatalErrorNode();\n      if (!N)\n\
  \        return;\n\n      auto R = std::make_unique<PathSensitiveBugReport>(\n \
  \         *BT,\n          \"roundup_pow_of_two() overflow cannot be detected via\
  \ == 0 on 32-bit; pre-check the input before rounding\",\n          N);\n      R->addRange(Condition->getSourceRange());\n\
  \      C.emitReport(std::move(R));\n      return;\n    }\n  }\n\n  // Case 2: Variable\
  \ that was assigned from roundup_pow_of_two().\n  const MemRegion *MR = getMemRegionFromExpr(X,\
  \ C);\n  if (!MR)\n    return;\n  MR = MR->getBaseRegion();\n  if (!MR)\n    return;\n\
  \n  ProgramStateRef State = C.getState();\n  const Expr *const *TrackedArg = State->get<RoundupResMap>(MR);\n\
  \  if (!TrackedArg)\n    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto Rpt = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"roundup_pow_of_two() overflow cannot be detected via == 0 on\
  \ 32-bit; pre-check the input before rounding\",\n      N);\n  Rpt->addRange(Condition->getSourceRange());\n\
  \  C.emitReport(std::move(Rpt));\n}\n\n} // end anonymous namespace\n\nextern \"\
  C\" void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Warns when code checks roundup_pow_of_two(x)\
  \ == 0 on 32-bit; pre-check x before rounding\",\n      \"\");\n}\n\nextern \"C\"\
  \ const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
