_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 8bc35475ef1a23b0e224f3242eb11c76cab0ea88
commit_type: Concurrency
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include <string>\n\nusing namespace clang;\nusing namespace ento;\nusing namespace\
  \ taint;\n\n// No custom program state needed.\n\nnamespace {\n\nclass SAGenTestChecker\
  \ : public Checker<check::BranchCondition> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new BugType(this, \"Spurious\
  \ data-race: read before guard\",\n                       \"Concurrency\")) {}\n\
  \n  void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\
  \nprivate:\n  // Helper: find first reference to a VarDecl within an expression.\n\
  \  const VarDecl *findFirstVarDeclUse(const Expr *E) const;\n\n  // Helper: whether\
  \ the expression contains a reference to a specific VarDecl.\n  bool exprContainsVarRef(const\
  \ Expr *E, const VarDecl *VD) const;\n\n  // Helper: get the previous statement\
  \ (sibling) before 'S' inside 'CS'.\n  const Stmt *getPrevSiblingStmt(const Stmt\
  \ *S, const CompoundStmt *CS) const;\n\n  // Helper: From a previous statement,\
  \ try to extract an assignment/initializer\n  // that writes to the given VarDecl.\
  \ If found, set EOut to the RHS/init expr.\n  bool extractExprAssignedToVarFromPrev(const\
  \ Stmt *Prev, const VarDecl *VD,\n                                        const\
  \ Expr *&EOut) const;\n\n  // Heuristic: does E look like a non-atomic shared-field\
  \ read (e.g. *work_data_bits(work), ->data)?\n  bool looksLikeSharedFieldRead(const\
  \ Expr *E, CheckerContext &C) const;\n\n  // Heuristic: is the left side of && a\
  \ guard (e.g., from_cancel), or are we\n  // in a function with name containing\
  \ \"flush_work\"?\n  bool isGuardOrFlushWorkContext(const Expr *LHS, const IfStmt\
  \ *IS,\n                                 CheckerContext &C) const;\n\n  // Utility:\
  \ find a MemberExpr child and check if its member name equals \"data\".\n  bool\
  \ containsMemberNamedData(const Expr *E) const;\n\n  // Utility: find a dereference\
  \ operator in expression.\n  bool containsDeref(const Expr *E) const;\n};\n\n//\
  \ -------------------- Helper implementations --------------------\n\nconst VarDecl\
  \ *SAGenTestChecker::findFirstVarDeclUse(const Expr *E) const {\n  if (!E)\n   \
  \ return nullptr;\n\n  class Visitor : public RecursiveASTVisitor<Visitor> {\n \
  \ public:\n    const VarDecl *Result = nullptr;\n\n    bool VisitDeclRefExpr(const\
  \ DeclRefExpr *DRE) {\n      if (!Result) {\n        if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n          Result = VD;\n          return false; // stop traversal\n       \
  \ }\n      }\n      return true;\n    }\n  } V;\n\n  // We need a non-const Stmt*\
  \ for the visitor's TraverseStmt.\n  const_cast<Expr *>(E)->IgnoreParenImpCasts();\n\
  \  V.TraverseStmt(const_cast<Expr *>(E));\n  return V.Result;\n}\n\nbool SAGenTestChecker::exprContainsVarRef(const\
  \ Expr *E,\n                                          const VarDecl *Target) const\
  \ {\n  if (!E || !Target)\n    return false;\n\n  class Visitor : public RecursiveASTVisitor<Visitor>\
  \ {\n  public:\n    const VarDecl *Target = nullptr;\n    bool Found = false;\n\n\
  \    bool VisitDeclRefExpr(const DeclRefExpr *DRE) {\n      if (Found)\n       \
  \ return false;\n      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n\
  \        if (VD == Target) {\n          Found = true;\n          return false;\n\
  \        }\n      }\n      return true;\n    }\n  } V;\n\n  V.Target = Target;\n\
  \  V.TraverseStmt(const_cast<Expr *>(E));\n  return V.Found;\n}\n\nconst Stmt *SAGenTestChecker::getPrevSiblingStmt(const\
  \ Stmt *S,\n                                                 const CompoundStmt\
  \ *CS) const {\n  if (!S || !CS)\n    return nullptr;\n\n  const Stmt *Prev = nullptr;\n\
  \  for (const Stmt *Child : CS->body()) {\n    if (Child == S)\n      return Prev;\n\
  \    Prev = Child;\n  }\n  return nullptr;\n}\n\nbool SAGenTestChecker::extractExprAssignedToVarFromPrev(const\
  \ Stmt *Prev,\n                                                        const VarDecl\
  \ *VD,\n                                                        const Expr *&EOut)\
  \ const {\n  EOut = nullptr;\n  if (!Prev || !VD)\n    return false;\n\n  // Case\
  \ 1: V = E;  (BinaryOperator assignment)\n  if (const auto *BO = dyn_cast<BinaryOperator>(Prev))\
  \ {\n    if (BO->getOpcode() == BO_Assign) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS)) {\n        if (DRE->getDecl()\
  \ == VD) {\n          EOut = BO->getRHS()->IgnoreParenImpCasts();\n          return\
  \ EOut != nullptr;\n        }\n      }\n    }\n  }\n\n  // Case 2: type V = E; (DeclStmt\
  \ with initializer)\n  if (const auto *DS = dyn_cast<DeclStmt>(Prev)) {\n    if\
  \ (DS->isSingleDecl()) {\n      if (const auto *D = dyn_cast<VarDecl>(DS->getSingleDecl()))\
  \ {\n        if (D == VD) {\n          if (const Expr *Init = D->getInit()) {\n\
  \            EOut = Init->IgnoreParenImpCasts();\n            return EOut != nullptr;\n\
  \          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::containsMemberNamedData(const\
  \ Expr *E) const {\n  if (!E)\n    return false;\n\n  class Visitor : public RecursiveASTVisitor<Visitor>\
  \ {\n  public:\n    bool Found = false;\n    bool VisitMemberExpr(const MemberExpr\
  \ *ME) {\n      if (Found)\n        return false;\n      if (ME->getMemberNameInfo().getAsString()\
  \ == \"data\") {\n        Found = true;\n        return false;\n      }\n      return\
  \ true;\n    }\n  } V;\n\n  V.TraverseStmt(const_cast<Expr *>(E));\n  return V.Found;\n\
  }\n\nbool SAGenTestChecker::containsDeref(const Expr *E) const {\n  if (!E)\n  \
  \  return false;\n\n  class Visitor : public RecursiveASTVisitor<Visitor> {\n  public:\n\
  \    bool Found = false;\n    bool VisitUnaryOperator(const UnaryOperator *UO) {\n\
  \      if (Found)\n        return false;\n      if (UO->getOpcode() == UO_Deref)\
  \ {\n        Found = true;\n        return false;\n      }\n      return true;\n\
  \    }\n  } V;\n\n  V.TraverseStmt(const_cast<Expr *>(E));\n  return V.Found;\n\
  }\n\nbool SAGenTestChecker::looksLikeSharedFieldRead(const Expr *E,\n          \
  \                                      CheckerContext &C) const {\n  if (!E)\n \
  \   return false;\n\n  // Exclude known-safe atomic/qualified reads to limit false\
  \ positives.\n  if (ExprHasName(E, \"READ_ONCE\", C) || ExprHasName(E, \"atomic\"\
  , C) ||\n      ExprHasName(E, \"smp_load\", C))\n    return false;\n\n  // Direct\
  \ name heuristics.\n  if (ExprHasName(E, \"work_data_bits\", C) || ExprHasName(E,\
  \ \"->data\", C) ||\n      ExprHasName(E, \".data\", C))\n    return true;\n\n \
  \ // Structural heuristics.\n  if (containsMemberNamedData(E))\n    return true;\n\
  \n  if (containsDeref(E))\n    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::isGuardOrFlushWorkContext(const\
  \ Expr *LHS,\n                                                 const IfStmt *IS,\n\
  \                                                 CheckerContext &C) const {\n \
  \ if (!IS)\n    return false;\n\n  // If LHS contains \"cancel\" (as in from_cancel),\
  \ treat it as a guard.\n  if (LHS && ExprHasName(LHS, \"cancel\", C))\n    return\
  \ true;\n\n  // Otherwise allow in functions with names containing \"flush_work\"\
  .\n  const FunctionDecl *FD = findSpecificTypeInParents<FunctionDecl>(IS, C);\n\
  \  if (FD) {\n    std::string Name = FD->getNameAsString();\n    if (Name.find(\"\
  flush_work\") != std::string::npos)\n      return true;\n  }\n\n  return false;\n\
  }\n\n// -------------------- Main check --------------------\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition,\n                                            CheckerContext &C)\
  \ const {\n  if (!Condition)\n    return;\n\n  // Ensure we are in an if-statement\
  \ condition.\n  const IfStmt *IS = findSpecificTypeInParents<IfStmt>(Condition,\
  \ C);\n  if (!IS)\n    return;\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n\
  \  if (!CondE)\n    return;\n\n  CondE = CondE->IgnoreParenImpCasts();\n\n  // We\
  \ only target conditions of the form (LHS && RHS).\n  const BinaryOperator *BO =\
  \ dyn_cast<BinaryOperator>(CondE);\n  if (!BO || BO->getOpcode() != BO_LAnd)\n \
  \   return;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  const\
  \ Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n  // Heuristically confirm\
  \ LHS looks like a guard (from_cancel) or we're in\n  // a flush_work-like context.\n\
  \  if (!isGuardOrFlushWorkContext(LHS, IS, C))\n    return;\n\n  // Find a variable\
  \ used on the RHS (e.g., \"data\").\n  const VarDecl *UsedVar = findFirstVarDeclUse(RHS);\n\
  \  if (!UsedVar)\n    return;\n\n  // Ensure the LHS (guard) does not reference\
  \ the same variable.\n  if (exprContainsVarRef(LHS, UsedVar))\n    return;\n\n \
  \ // Locate the previous statement in the same compound block.\n  const CompoundStmt\
  \ *CS = findSpecificTypeInParents<CompoundStmt>(IS, C);\n  if (!CS)\n    return;\n\
  \n  const Stmt *Prev = getPrevSiblingStmt(IS, CS);\n  if (!Prev)\n    return;\n\n\
  \  // From the previous statement, extract an expression that assigns to UsedVar.\n\
  \  const Expr *PrevReadExpr = nullptr;\n  if (!extractExprAssignedToVarFromPrev(Prev,\
  \ UsedVar, PrevReadExpr))\n    return;\n\n  // The previous expression must look\
  \ like an unsafe shared-field read.\n  if (!looksLikeSharedFieldRead(PrevReadExpr,\
  \ C))\n    return;\n\n  // All checks passed: report the issue.\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Unconditional read of shared field before guard; move the read\
  \ under the if (guard).\",\n      N);\n\n  // Highlight the previous read statement\
  \ or the expression.\n  if (PrevReadExpr)\n    R->addRange(PrevReadExpr->getSourceRange());\n\
  \  else\n    R->addRange(Prev->getSourceRange());\n\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unconditional shared-field reads moved before a guarding condition\
  \ (spurious data-race)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nworkqueue: Fix spruious data race in __flush_work()\n\
  \nWhen flushing a work item for cancellation, __flush_work() knows that it\nexclusively\
  \ owns the work item through its PENDING bit. 134874e2eee9\n(\"workqueue: Allow\
  \ cancel_work_sync() and disable_work() from atomic\ncontexts on BH work items\"\
  ) added a read of @work->data to determine whether\nto use busy wait for BH work\
  \ items that are being canceled. While the read\nis safe when @from_cancel, @work->data\
  \ was read before testing @from_cancel\nto simplify code structure:\n\n\tdata =\
  \ *work_data_bits(work);\n\tif (from_cancel &&\n\t    !WARN_ON_ONCE(data & WORK_STRUCT_PWQ)\
  \ && (data & WORK_OFFQ_BH)) {\n\nWhile the read data was never used if !@from_cancel,\
  \ this could trigger\nKCSAN data race detection spuriously:\n\n  ==================================================================\n\
  \  BUG: KCSAN: data-race in __flush_work / __flush_work\n\n  write to 0xffff8881223aa3e8\
  \ of 8 bytes by task 3998 on cpu 0:\n   instrument_write include/linux/instrumented.h:41\
  \ [inline]\n   ___set_bit include/asm-generic/bitops/instrumented-non-atomic.h:28\
  \ [inline]\n   insert_wq_barrier kernel/workqueue.c:3790 [inline]\n   start_flush_work\
  \ kernel/workqueue.c:4142 [inline]\n   __flush_work+0x30b/0x570 kernel/workqueue.c:4178\n\
  \   flush_work kernel/workqueue.c:4229 [inline]\n   ...\n\n  read to 0xffff8881223aa3e8\
  \ of 8 bytes by task 50 on cpu 1:\n   __flush_work+0x42a/0x570 kernel/workqueue.c:4188\n\
  \   flush_work kernel/workqueue.c:4229 [inline]\n   flush_delayed_work+0x66/0x70\
  \ kernel/workqueue.c:4251\n   ...\n\n  value changed: 0x0000000000400000 -> 0xffff88810006c00d\n\
  \nReorganize the code so that @from_cancel is tested before @work->data is\naccessed.\
  \ The only problem is triggering KCSAN detection spuriously. This\nshouldn't need\
  \ READ_ONCE() or other access qualifiers.\n\nNo functional changes.\n\nSigned-off-by:\
  \ Tejun Heo <tj@kernel.org>\nReported-by: syzbot+b3e4f2f51ed645fd5df2@syzkaller.appspotmail.com\n\
  Fixes: 134874e2eee9 (\"workqueue: Allow cancel_work_sync() and disable_work() from\
  \ atomic contexts on BH work items\")\nLink: http://lkml.kernel.org/r/000000000000ae429e061eea2157@google.com\n\
  Cc: Jens Axboe <axboe@kernel.dk>\n\n## Buggy Code\n\n```c\n// Function: __flush_work\
  \ in kernel/workqueue.c\nstatic bool __flush_work(struct work_struct *work, bool\
  \ from_cancel)\n{\n\tstruct wq_barrier barr;\n\tunsigned long data;\n\n\tif (WARN_ON(!wq_online))\n\
  \t\treturn false;\n\n\tif (WARN_ON(!work->func))\n\t\treturn false;\n\n\tif (!start_flush_work(work,\
  \ &barr, from_cancel))\n\t\treturn false;\n\n\t/*\n\t * start_flush_work() returned\
  \ %true. If @from_cancel is set, we know\n\t * that @work must have been executing\
  \ during start_flush_work() and\n\t * can't currently be queued. Its data must contain\
  \ OFFQ bits. If @work\n\t * was queued on a BH workqueue, we also know that it was\
  \ running in the\n\t * BH context and thus can be busy-waited.\n\t */\n\tdata =\
  \ *work_data_bits(work);\n\tif (from_cancel &&\n\t    !WARN_ON_ONCE(data & WORK_STRUCT_PWQ)\
  \ && (data & WORK_OFFQ_BH)) {\n\t\t/*\n\t\t * On RT, prevent a live lock when %current\
  \ preempted soft\n\t\t * interrupt processing or prevents ksoftirqd from running\
  \ by\n\t\t * keeping flipping BH. If the BH work item runs on a different\n\t\t\
  \ * CPU then this has no effect other than doing the BH\n\t\t * disable/enable dance\
  \ for nothing. This is copied from\n\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  \t\t */\n\t\twhile (!try_wait_for_completion(&barr.done)) {\n\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tlocal_bh_enable();\n\t\t\t} else {\n\t\
  \t\t\tcpu_relax();\n\t\t\t}\n\t\t}\n\t} else {\n\t\twait_for_completion(&barr.done);\n\
  \t}\n\n\tdestroy_work_on_stack(&barr.work);\n\treturn true;\n}\n```\n\n## Bug Fix\
  \ Patch\n\n```diff\ndiff --git a/kernel/workqueue.c b/kernel/workqueue.c\nindex\
  \ d56bd2277e58..ef174d8c1f63 100644\n--- a/kernel/workqueue.c\n+++ b/kernel/workqueue.c\n\
  @@ -4166,7 +4166,6 @@ static bool start_flush_work(struct work_struct *work, struct\
  \ wq_barrier *barr,\n static bool __flush_work(struct work_struct *work, bool from_cancel)\n\
  \ {\n \tstruct wq_barrier barr;\n-\tunsigned long data;\n \n \tif (WARN_ON(!wq_online))\n\
  \ \t\treturn false;\n@@ -4184,29 +4183,35 @@ static bool __flush_work(struct work_struct\
  \ *work, bool from_cancel)\n \t * was queued on a BH workqueue, we also know that\
  \ it was running in the\n \t * BH context and thus can be busy-waited.\n \t */\n\
  -\tdata = *work_data_bits(work);\n-\tif (from_cancel &&\n-\t    !WARN_ON_ONCE(data\
  \ & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_BH)) {\n-\t\t/*\n-\t\t * On RT, prevent\
  \ a live lock when %current preempted soft\n-\t\t * interrupt processing or prevents\
  \ ksoftirqd from running by\n-\t\t * keeping flipping BH. If the BH work item runs\
  \ on a different\n-\t\t * CPU then this has no effect other than doing the BH\n\
  -\t\t * disable/enable dance for nothing. This is copied from\n-\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  -\t\t */\n-\t\twhile (!try_wait_for_completion(&barr.done)) {\n-\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n-\t\t\t\tlocal_bh_disable();\n-\t\t\t\tlocal_bh_enable();\n-\t\t\t} else {\n\
  -\t\t\t\tcpu_relax();\n+\tif (from_cancel) {\n+\t\tunsigned long data = *work_data_bits(work);\n\
  +\n+\t\tif (!WARN_ON_ONCE(data & WORK_STRUCT_PWQ) &&\n+\t\t    (data & WORK_OFFQ_BH))\
  \ {\n+\t\t\t/*\n+\t\t\t * On RT, prevent a live lock when %current preempted\n+\t\
  \t\t * soft interrupt processing or prevents ksoftirqd from\n+\t\t\t * running by\
  \ keeping flipping BH. If the BH work item\n+\t\t\t * runs on a different CPU then\
  \ this has no effect other\n+\t\t\t * than doing the BH disable/enable dance for\
  \ nothing.\n+\t\t\t * This is copied from\n+\t\t\t * kernel/softirq.c::tasklet_unlock_spin_wait().\n\
  +\t\t\t */\n+\t\t\twhile (!try_wait_for_completion(&barr.done)) {\n+\t\t\t\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\
  \ {\n+\t\t\t\t\tlocal_bh_disable();\n+\t\t\t\t\tlocal_bh_enable();\n+\t\t\t\t} else\
  \ {\n+\t\t\t\t\tcpu_relax();\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tgoto out_destroy;\n \t\
  \t}\n-\t} else {\n-\t\twait_for_completion(&barr.done);\n \t}\n \n+\twait_for_completion(&barr.done);\n\
  +\n+out_destroy:\n \tdestroy_work_on_stack(&barr.work);\n \treturn true;\n }\n```\n"
pattern: '## Bug Pattern


  Reading a shared/concurrently-updated field before verifying the condition that
  guarantees safe/exclusive access. Specifically, an unconditional read of work->data
  (which other CPUs may modify) occurs prior to checking from_cancel; even if the
  value is not used when the guard is false, the mere read races with writers and
  triggers KCSAN. The correct pattern is to first check the guard that ensures exclusive/safe
  access and only then read the shared field (or otherwise use atomic/READ_ONCE if
  required).'
plan: "1) Program state\n- No custom program state is necessary. This checker is a\
  \ local, syntactic/data-flow pattern detector around an if-condition. We will not\
  \ model concurrency nor aliasing.\n\n2) Callback functions and implementation steps\n\
  - Use only checkBranchCondition. This is sufficient to inspect if-conditions and\
  \ their immediate surrounding statements.\n\nStep A: Identify the target if-condition\
  \ shape\n- In checkBranchCondition(const Stmt *Condition, CheckerContext &C):\n\
  \  - Get the IfStmt that owns this Condition using findSpecificTypeInParents<IfStmt>(Condition,\
  \ C). If not found, return.\n  - Strip parens/implicits from Condition and dyn_cast\
  \ to BinaryOperator; require opcode BO_LAnd (logical AND). If not &&, return.\n\
  \  - Let LHS = BO->getLHS()->IgnoreParenImpCasts(), RHS = BO->getRHS()->IgnoreParenImpCasts().\n\
  \nStep B: Heuristically confirm the \"guard\" on the left\n- We want cases where\
  \ the left side is a guard that must be evaluated first (as in from_cancel).\n \
  \ - Use ExprHasName(LHS, \"cancel\", C) to recognize typical guard names in this\
  \ kernel pattern (e.g., from_cancel). If false, bail early unless the function name\
  \ hints we are in flush_work:\n    - Retrieve the enclosing function: findSpecificTypeInParents<FunctionDecl>(IfStmt,\
  \ C). If present, require FunctionDecl->getNameAsString() to contain \"flush_work\"\
  . If neither guard-name nor function-name hint matches, return.\n\nStep C: Ensure\
  \ the right side reads a previously preloaded local variable\n- Look for a DeclRefExpr\
  \ to a local VarDecl used within RHS:\n  - Walk RHS to find the first DeclRefExpr\
  \ referencing a VarDecl (prefer the first encountered; treat that as V). If none\
  \ found, return.\n- Now obtain the immediate previous statement in the same compound\
  \ block:\n  - Get the enclosing CompoundStmt via findSpecificTypeInParents<CompoundStmt>(IfStmt,\
  \ C). If missing, return.\n  - Iterate the CompoundStmt\u2019s body to locate the\
  \ position of IfStmt; take the previous non-null statement PrevStmt. If none, return.\n\
  \nStep D: Check that PrevStmt computes V by unconditionally reading the shared field\n\
  - Two accepted forms:\n  1) Assignment statement of the form V = E:\n     - dyn_cast<BinaryOperator>(PrevStmt),\
  \ opcode BO_Assign.\n     - LHS must be DeclRefExpr to the same VarDecl V.\n   \
  \  - Let E = RHS->IgnoreParenImpCasts().\n  2) Declaration with initializer (e.g.,\
  \ unsigned long V = E):\n     - dyn_cast<DeclStmt>(PrevStmt) with a single VarDecl\
  \ D.\n     - D must be the same VarDecl as V, and D->getInit() must exist.\n   \
  \  - Let E = D->getInit()->IgnoreParenImpCasts().\n\n- Heuristically confirm that\
  \ E likely reads a concurrently updated field:\n  - Either:\n    - E contains a\
  \ dereference (findSpecificTypeInChildren<UnaryOperator>(E) with UO_Deref), or\n\
  \    - E contains a MemberExpr reading a field called \"data\" (findSpecificTypeInChildren<MemberExpr>(E)\
  \ and check MemberExpr->getMemberNameInfo().getAsString() == \"data\"), or\n   \
  \ - ExprHasName(E, \"work_data_bits\", C) is true, or ExprHasName(E, \"->data\"\
  , C) or ExprHasName(E, \".data\", C) is true.\n  - And exclude known safe atomic/qualifying\
  \ reads to limit false positives:\n    - If ExprHasName(E, \"READ_ONCE\", C) or\
  \ ExprHasName(E, \"atomic\", C) or ExprHasName(E, \"smp_load\", C) is true, return\
  \ (don\u2019t warn).\n\nStep E: Verify that V is used only inside the guarded RHS\
  \ (optional but helpful noise filter)\n- Check that V appears in RHS (it does by\
  \ construction).\n- Optionally, quickly scan the IfStmt\u2019s condition LHS (should\
  \ not contain V) by searching for DeclRefExpr to V; if found in LHS, return (we\
  \ only want the value used in the RHS conjunct).\n\nStep F: Report\n- If all checks\
  \ above pass, emit a bug report:\n  - Create a BugType once: \u201CSpurious data-race:\
  \ read before guard\u201D.\n  - Create an error node with C.generateNonFatalErrorNode().\n\
  \  - Point the report range at PrevStmt (the unconditional read), or the E expression\
  \ if you prefer a tighter range.\n  - Message: \u201CUnconditional read of shared\
  \ field before guard; move the read under the if (guard).\u201D\n\nNotes and utilities\
  \ used\n- Use findSpecificTypeInParents<IfStmt>(...) to get the IfStmt and CompoundStmt\
  \ context.\n- Use ExprHasName(...) to match \u201Cwork_data_bits\u201D, \u201C->data\u201D\
  , \u201C.data\u201D, and guard hints like \u201Ccancel\u201D.\n- Use findSpecificTypeInChildren<UnaryOperator>\
  \ and findSpecificTypeInChildren<MemberExpr> to quickly detect a deref or field\
  \ access to \u201Cdata\u201D.\n- Keep the pattern strict: the previous statement\
  \ must be the preload of V. This minimizes false positives and matches the kernel\
  \ fix pattern precisely.\n\nSummary of chosen callbacks\n- checkBranchCondition\
  \ only:\n  - Detects pattern: immediate previous statement preloads a local variable\
  \ by dereferencing a shared field (like work->data or *work_data_bits(...)), and\
  \ the if-condition is of the form guard && uses(var), where guard looks like a cancellation\
  \ flag. Reports that the preload should be moved under the guard to avoid spurious\
  \ data races."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include <string>\n#include <memory>\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// No custom program state needed.\n\nnamespace\
  \ {\n\nclass SAGenTestChecker : public Checker<check::BranchCondition> {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n      : BT(new\
  \ BugType(this, \"Spurious data-race: read before guard\",\n                   \
  \    \"Concurrency\")) {}\n\n  void checkBranchCondition(const Stmt *Condition,\
  \ CheckerContext &C) const;\n\nprivate:\n  // Helper: find first reference to a\
  \ VarDecl within an expression.\n  const VarDecl *findFirstVarDeclUse(const Expr\
  \ *E) const;\n\n  // Helper: whether the expression contains a reference to a specific\
  \ VarDecl.\n  bool exprContainsVarRef(const Expr *E, const VarDecl *VD) const;\n\
  \n  // Helper: get the previous statement (sibling) before 'S' inside 'CS'.\n  const\
  \ Stmt *getPrevSiblingStmt(const Stmt *S, const CompoundStmt *CS) const;\n\n  //\
  \ Helper: From a previous statement, try to extract an assignment/initializer\n\
  \  // that writes to the given VarDecl. If found, set EOut to the RHS/init expr.\n\
  \  bool extractExprAssignedToVarFromPrev(const Stmt *Prev, const VarDecl *VD,\n\
  \                                        const Expr *&EOut) const;\n\n  // Heuristic:\
  \ does E look like a non-atomic shared-field read (e.g. *work_data_bits(work), ->data)?\n\
  \  bool looksLikeSharedFieldRead(const Expr *E, CheckerContext &C) const;\n\n  //\
  \ Heuristic: is the left side of && a guard (e.g., from_cancel), or are we\n  //\
  \ in a function with name containing \"flush_work\"?\n  bool isGuardOrFlushWorkContext(const\
  \ Expr *LHS, const IfStmt *IS,\n                                 CheckerContext\
  \ &C) const;\n\n  // Utility: find a MemberExpr child and check if its member name\
  \ equals \"data\".\n  bool containsMemberNamedData(const Expr *E) const;\n\n  //\
  \ Utility: find a dereference operator in expression.\n  bool containsDeref(const\
  \ Expr *E) const;\n};\n\n// -------------------- Helper implementations --------------------\n\
  \nconst VarDecl *SAGenTestChecker::findFirstVarDeclUse(const Expr *E) const {\n\
  \  if (!E)\n    return nullptr;\n\n  class Visitor : public RecursiveASTVisitor<Visitor>\
  \ {\n  public:\n    const VarDecl *Result = nullptr;\n\n    bool VisitDeclRefExpr(const\
  \ DeclRefExpr *DRE) {\n      if (!Result) {\n        if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\
  \ {\n          Result = VD;\n          return false; // stop traversal\n       \
  \ }\n      }\n      return true;\n    }\n  } V;\n\n  // We need a non-const Stmt*\
  \ for the visitor's TraverseStmt.\n  const_cast<Expr *>(E)->IgnoreParenImpCasts();\n\
  \  V.TraverseStmt(const_cast<Expr *>(E));\n  return V.Result;\n}\n\nbool SAGenTestChecker::exprContainsVarRef(const\
  \ Expr *E,\n                                          const VarDecl *Target) const\
  \ {\n  if (!E || !Target)\n    return false;\n\n  class Visitor : public RecursiveASTVisitor<Visitor>\
  \ {\n  public:\n    const VarDecl *Target = nullptr;\n    bool Found = false;\n\n\
  \    bool VisitDeclRefExpr(const DeclRefExpr *DRE) {\n      if (Found)\n       \
  \ return false;\n      if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n\
  \        if (VD == Target) {\n          Found = true;\n          return false;\n\
  \        }\n      }\n      return true;\n    }\n  } V;\n\n  V.Target = Target;\n\
  \  V.TraverseStmt(const_cast<Expr *>(E));\n  return V.Found;\n}\n\nconst Stmt *SAGenTestChecker::getPrevSiblingStmt(const\
  \ Stmt *S,\n                                                 const CompoundStmt\
  \ *CS) const {\n  if (!S || !CS)\n    return nullptr;\n\n  const Stmt *Prev = nullptr;\n\
  \  for (const Stmt *Child : CS->body()) {\n    if (Child == S)\n      return Prev;\n\
  \    Prev = Child;\n  }\n  return nullptr;\n}\n\nbool SAGenTestChecker::extractExprAssignedToVarFromPrev(const\
  \ Stmt *Prev,\n                                                        const VarDecl\
  \ *VD,\n                                                        const Expr *&EOut)\
  \ const {\n  EOut = nullptr;\n  if (!Prev || !VD)\n    return false;\n\n  // Case\
  \ 1: V = E;  (BinaryOperator assignment)\n  if (const auto *BO = dyn_cast<BinaryOperator>(Prev))\
  \ {\n    if (BO->getOpcode() == BO_Assign) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \      if (const auto *DRE = dyn_cast<DeclRefExpr>(LHS)) {\n        if (DRE->getDecl()\
  \ == VD) {\n          EOut = BO->getRHS()->IgnoreParenImpCasts();\n          return\
  \ EOut != nullptr;\n        }\n      }\n    }\n  }\n\n  // Case 2: type V = E; (DeclStmt\
  \ with initializer)\n  if (const auto *DS = dyn_cast<DeclStmt>(Prev)) {\n    if\
  \ (DS->isSingleDecl()) {\n      if (const auto *D = dyn_cast<VarDecl>(DS->getSingleDecl()))\
  \ {\n        if (D == VD) {\n          if (const Expr *Init = D->getInit()) {\n\
  \            EOut = Init->IgnoreParenImpCasts();\n            return EOut != nullptr;\n\
  \          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nbool SAGenTestChecker::containsMemberNamedData(const\
  \ Expr *E) const {\n  if (!E)\n    return false;\n\n  class Visitor : public RecursiveASTVisitor<Visitor>\
  \ {\n  public:\n    bool Found = false;\n    bool VisitMemberExpr(const MemberExpr\
  \ *ME) {\n      if (Found)\n        return false;\n      if (ME->getMemberNameInfo().getAsString()\
  \ == \"data\") {\n        Found = true;\n        return false;\n      }\n      return\
  \ true;\n    }\n  } V;\n\n  V.TraverseStmt(const_cast<Expr *>(E));\n  return V.Found;\n\
  }\n\nbool SAGenTestChecker::containsDeref(const Expr *E) const {\n  if (!E)\n  \
  \  return false;\n\n  class Visitor : public RecursiveASTVisitor<Visitor> {\n  public:\n\
  \    bool Found = false;\n    bool VisitUnaryOperator(const UnaryOperator *UO) {\n\
  \      if (Found)\n        return false;\n      if (UO->getOpcode() == UO_Deref)\
  \ {\n        Found = true;\n        return false;\n      }\n      return true;\n\
  \    }\n  } V;\n\n  V.TraverseStmt(const_cast<Expr *>(E));\n  return V.Found;\n\
  }\n\nbool SAGenTestChecker::looksLikeSharedFieldRead(const Expr *E,\n          \
  \                                      CheckerContext &C) const {\n  if (!E)\n \
  \   return false;\n\n  // Exclude known-safe atomic/qualified reads to limit false\
  \ positives.\n  if (ExprHasName(E, \"READ_ONCE\", C) || ExprHasName(E, \"atomic\"\
  , C) ||\n      ExprHasName(E, \"smp_load\", C))\n    return false;\n\n  // Direct\
  \ name heuristics.\n  if (ExprHasName(E, \"work_data_bits\", C) || ExprHasName(E,\
  \ \"->data\", C) ||\n      ExprHasName(E, \".data\", C))\n    return true;\n\n \
  \ // Structural heuristics.\n  if (containsMemberNamedData(E))\n    return true;\n\
  \n  if (containsDeref(E))\n    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::isGuardOrFlushWorkContext(const\
  \ Expr *LHS,\n                                                 const IfStmt *IS,\n\
  \                                                 CheckerContext &C) const {\n \
  \ if (!IS)\n    return false;\n\n  // If LHS contains \"cancel\" (as in from_cancel),\
  \ treat it as a guard.\n  if (LHS && ExprHasName(LHS, \"cancel\", C))\n    return\
  \ true;\n\n  // Otherwise allow in functions with names containing \"flush_work\"\
  .\n  const Decl *CurDecl = C.getLocationContext()->getDecl();\n  const auto *FD\
  \ = dyn_cast_or_null<FunctionDecl>(CurDecl);\n  if (FD) {\n    std::string Name\
  \ = FD->getNameAsString();\n    if (Name.find(\"flush_work\") != std::string::npos)\n\
  \      return true;\n  }\n\n  return false;\n}\n\n// -------------------- Main check\
  \ --------------------\n\nvoid SAGenTestChecker::checkBranchCondition(const Stmt\
  \ *Condition,\n                                            CheckerContext &C) const\
  \ {\n  if (!Condition)\n    return;\n\n  // Ensure we are in an if-statement condition.\n\
  \  const IfStmt *IS = findSpecificTypeInParents<IfStmt>(Condition, C);\n  if (!IS)\n\
  \    return;\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n\
  \    return;\n\n  CondE = CondE->IgnoreParenImpCasts();\n\n  // We only target conditions\
  \ of the form (LHS && RHS).\n  const BinaryOperator *BO = dyn_cast<BinaryOperator>(CondE);\n\
  \  if (!BO || BO->getOpcode() != BO_LAnd)\n    return;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n\
  \  const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\n  // Heuristically\
  \ confirm LHS looks like a guard (from_cancel) or we're in\n  // a flush_work-like\
  \ context.\n  if (!isGuardOrFlushWorkContext(LHS, IS, C))\n    return;\n\n  // Find\
  \ a variable used on the RHS (e.g., \"data\").\n  const VarDecl *UsedVar = findFirstVarDeclUse(RHS);\n\
  \  if (!UsedVar)\n    return;\n\n  // Ensure the LHS (guard) does not reference\
  \ the same variable.\n  if (exprContainsVarRef(LHS, UsedVar))\n    return;\n\n \
  \ // Locate the previous statement in the same compound block.\n  const CompoundStmt\
  \ *CS = findSpecificTypeInParents<CompoundStmt>(IS, C);\n  if (!CS)\n    return;\n\
  \n  const Stmt *Prev = getPrevSiblingStmt(IS, CS);\n  if (!Prev)\n    return;\n\n\
  \  // From the previous statement, extract an expression that assigns to UsedVar.\n\
  \  const Expr *PrevReadExpr = nullptr;\n  if (!extractExprAssignedToVarFromPrev(Prev,\
  \ UsedVar, PrevReadExpr))\n    return;\n\n  // The previous expression must look\
  \ like an unsafe shared-field read.\n  if (!looksLikeSharedFieldRead(PrevReadExpr,\
  \ C))\n    return;\n\n  // All checks passed: report the issue.\n  ExplodedNode\
  \ *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Unconditional read of shared field before guard; move the read\
  \ under the if (guard).\",\n      N);\n\n  // Highlight the previous read statement\
  \ or the expression.\n  if (PrevReadExpr)\n    R->addRange(PrevReadExpr->getSourceRange());\n\
  \  else\n    R->addRange(Prev->getSourceRange());\n\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects unconditional shared-field reads moved before a guarding condition\
  \ (spurious data-race)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
