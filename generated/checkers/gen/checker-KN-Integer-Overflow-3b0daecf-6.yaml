_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3b0daecfeac0103aba8b293df07a0cbaf8b43f29
commit_type: Integer-Overflow
index: 6
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Track variables that currently hold a size computed as (count * sizeof(...))\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(SizeMulMap, const MemRegion*, bool)\n\nnamespace\
  \ {\nclass SAGenTestChecker : public Checker<\n    check::PreCall,\n    check::Bind\n\
  \  > {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Size multiplication passed to allocator\", \"Memory Allocation\"\
  )) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \n   private:\n      // Helpers\n      static bool isMulBySizeof(const Expr *E,\
  \ const Expr *&CountExpr);\n      static bool isSizeofExpr(const Expr *E);\n   \
  \   static bool matchCallName(const CallEvent &Call, CheckerContext &C, StringRef\
  \ Name);\n      static bool isAllocLike(const CallEvent &Call, CheckerContext &C,\
  \ StringRef &NameOut);\n      static StringRef getArrayAllocatorSuggestion(StringRef\
  \ CalleeName);\n};\n  \n// Check if expression is a sizeof(...) (after stripping\
  \ parens/imp-casts)\nbool SAGenTestChecker::isSizeofExpr(const Expr *E) {\n  if\
  \ (!E) return false;\n  E = E->IgnoreParenImpCasts();\n  if (const auto *U = dyn_cast<UnaryExprOrTypeTraitExpr>(E))\
  \ {\n    return U->getKind() == UETT_SizeOf;\n  }\n  return false;\n}\n\n// Check\
  \ if E is a multiplication where one side is sizeof(...).\n// If true, CountExpr\
  \ is set to the non-sizeof operand.\nbool SAGenTestChecker::isMulBySizeof(const\
  \ Expr *E, const Expr *&CountExpr) {\n  CountExpr = nullptr;\n  if (!E) return false;\n\
  \  E = E->IgnoreParenImpCasts();\n\n  const auto *BO = dyn_cast<BinaryOperator>(E);\n\
  \  if (!BO) return false;\n  if (BO->getOpcode() != BO_Mul) return false;\n\n  const\
  \ Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \n  if (isSizeofExpr(LHS)) {\n    CountExpr = RHS;\n    return true;\n  }\n  if\
  \ (isSizeofExpr(RHS)) {\n    CountExpr = LHS;\n    return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::matchCallName(const CallEvent &Call, CheckerContext\
  \ &C, StringRef Name) {\n  const Expr *OE = Call.getOriginExpr();\n  if (!OE) return\
  \ false;\n  return ExprHasName(OE, Name, C);\n}\n\n// Return true if this is one\
  \ of the kmalloc/kzalloc family that take a byte size.\n// NameOut will be set to\
  \ the matched callee name.\nbool SAGenTestChecker::isAllocLike(const CallEvent &Call,\
  \ CheckerContext &C, StringRef &NameOut) {\n  static const char *Targets[] = {\n\
  \    \"kmalloc\", \"__kmalloc\", \"kzalloc\", \"kvmalloc\", \"kvzalloc\",\n    \"\
  devm_kmalloc\", \"devm_kzalloc\"\n  };\n  for (const char *T : Targets) {\n    if\
  \ (matchCallName(Call, C, T)) {\n      NameOut = T;\n      return true;\n    }\n\
  \  }\n  return false;\n}\n\n// Suggest an array allocator for the given allocator\
  \ name.\nStringRef SAGenTestChecker::getArrayAllocatorSuggestion(StringRef CalleeName)\
  \ {\n  if (CalleeName.equals(\"kzalloc\")) return \"kcalloc\";\n  if (CalleeName.equals(\"\
  devm_kzalloc\")) return \"devm_kcalloc\";\n  if (CalleeName.equals(\"kmalloc\")\
  \ || CalleeName.equals(\"__kmalloc\")) return \"kmalloc_array\";\n  if (CalleeName.equals(\"\
  devm_kmalloc\")) return \"devm_kmalloc_array\";\n  if (CalleeName.equals(\"kvmalloc\"\
  )) return \"kvmalloc_array\";\n  if (CalleeName.equals(\"kvzalloc\")) return \"\
  kvcalloc\";\n  // Default generic suggestion\n  return \"kcalloc/kmalloc_array\"\
  ;\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  StringRef CalleeName;\n  if (!isAllocLike(Call, C, CalleeName))\n\
  \    return;\n\n  // All targeted allocators take size as the first argument.\n\
  \  if (Call.getNumArgs() == 0)\n    return;\n\n  const Expr *SizeArgE = Call.getArgExpr(0);\n\
  \  if (!SizeArgE)\n    return;\n\n  const Expr *CountExpr = nullptr;\n  bool ShouldReport\
  \ = false;\n\n  // 1) Direct pattern: multiplication where one side is sizeof(...)\n\
  \  if (isMulBySizeof(SizeArgE, CountExpr)) {\n    ShouldReport = true;\n  } else\
  \ {\n    // 2) Indirect via variable holding sizeof(...) * count\n    const Expr\
  \ *E = SizeArgE->IgnoreParenImpCasts();\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(E))\
  \ {\n      ProgramStateRef State = C.getState();\n      const MemRegion *MR = getMemRegionFromExpr(DRE,\
  \ C);\n      if (MR) {\n        MR = MR->getBaseRegion();\n        if (MR) {\n \
  \         if (const bool *IsMul = State->get<SizeMulMap>(MR)) {\n            if\
  \ (*IsMul)\n              ShouldReport = true;\n          }\n        }\n      }\n\
  \    }\n  }\n\n  if (!ShouldReport)\n    return;\n\n  // Report: Recommend array\
  \ allocator to avoid overflow.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  SmallString<128> Msg;\n  StringRef Suggest = getArrayAllocatorSuggestion(CalleeName);\n\
  \  Msg.append(\"Use array allocator to avoid overflow; prefer \");\n  Msg.append(Suggest);\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg.str(), N);\n  R->addRange(SizeArgE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc,\
  \ SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State =\
  \ C.getState();\n\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\n\
  \    return;\n  LHSReg = LHSReg->getBaseRegion();\n  if (!LHSReg)\n    return;\n\
  \n  // Only track simple variables (avoid binding to arbitrary memory like *p, p[i],\
  \ etc.)\n  if (!isa<VarRegion>(LHSReg))\n    return;\n\n  // Find an RHS expression\
  \ from the statement context\n  const Expr *RHS = nullptr;\n\n  if (const auto *BO\
  \ = dyn_cast_or_null<BinaryOperator>(S)) {\n    if (BO->isAssignmentOp())\n    \
  \  RHS = BO->getRHS();\n  }\n  if (!RHS) {\n    if (const auto *DS = dyn_cast_or_null<DeclStmt>(S))\
  \ {\n      for (const Decl *D : DS->decls()) {\n        if (const auto *VD = dyn_cast<VarDecl>(D))\
  \ {\n          if (const Expr *Init = VD->getInit())\n            RHS = Init;\n\
  \        }\n      }\n    }\n  }\n  if (!RHS) {\n    if (const auto *BO = findSpecificTypeInParents<BinaryOperator>(S,\
  \ C)) {\n      if (BO->isAssignmentOp())\n        RHS = BO->getRHS();\n    }\n \
  \ }\n  if (!RHS) {\n    if (const auto *DS = findSpecificTypeInParents<DeclStmt>(S,\
  \ C)) {\n      for (const Decl *D : DS->decls()) {\n        if (const auto *VD =\
  \ dyn_cast<VarDecl>(D)) {\n          if (const Expr *Init = VD->getInit())\n   \
  \         RHS = Init;\n        }\n      }\n    }\n  }\n\n  if (!RHS) {\n    // No\
  \ usable RHS expression found, clear any previous mark\n    State = State->remove<SizeMulMap>(LHSReg);\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  const Expr *CountExpr = nullptr;\n\
  \  if (isMulBySizeof(RHS, CountExpr)) {\n    State = State->set<SizeMulMap>(LHSReg,\
  \ true);\n  } else {\n    State = State->remove<SizeMulMap>(LHSReg);\n  }\n  C.addTransition(State);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects size multiplication passed to kmalloc/kzalloc family; suggest\
  \ kcalloc/kmalloc_array\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\namdkfd: use calloc instead of kzalloc to avoid integer\
  \ overflow\n\nThis uses calloc instead of doing the multiplication which might\n\
  overflow.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: kfd_ioctl_get_process_apertures_new in drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\t\t\t\tstruct\
  \ kfd_process *p, void *data)\n{\n\tstruct kfd_ioctl_get_process_apertures_new_args\
  \ *args = data;\n\tstruct kfd_process_device_apertures *pa;\n\tint ret;\n\tint i;\n\
  \n\tdev_dbg(kfd_device, \"get apertures for PASID 0x%x\", p->pasid);\n\n\tif (args->num_of_nodes\
  \ == 0) {\n\t\t/* Return number of nodes, so that user space can alloacate\n\t\t\
  \ * sufficient memory\n\t\t */\n\t\tmutex_lock(&p->mutex);\n\t\targs->num_of_nodes\
  \ = p->n_pdds;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Fill in process-aperture information\
  \ for all available\n\t * nodes, but not more than args->num_of_nodes as that is\n\
  \t * the amount of memory allocated by user\n\t */\n\tpa = kzalloc((sizeof(struct\
  \ kfd_process_device_apertures) *\n\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n\t\
  if (!pa)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&p->mutex);\n\n\tif (!p->n_pdds) {\n\
  \t\targs->num_of_nodes = 0;\n\t\tkfree(pa);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Run\
  \ over all pdd of the process */\n\tfor (i = 0; i < min(p->n_pdds, args->num_of_nodes);\
  \ i++) {\n\t\tstruct kfd_process_device *pdd = p->pdds[i];\n\n\t\tpa[i].gpu_id =\
  \ pdd->dev->id;\n\t\tpa[i].lds_base = pdd->lds_base;\n\t\tpa[i].lds_limit = pdd->lds_limit;\n\
  \t\tpa[i].gpuvm_base = pdd->gpuvm_base;\n\t\tpa[i].gpuvm_limit = pdd->gpuvm_limit;\n\
  \t\tpa[i].scratch_base = pdd->scratch_base;\n\t\tpa[i].scratch_limit = pdd->scratch_limit;\n\
  \n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpu id %u\\n\", pdd->dev->id);\n\t\tdev_dbg(kfd_device,\n\
  \t\t\t\"lds_base %llX\\n\", pdd->lds_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"lds_limit\
  \ %llX\\n\", pdd->lds_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_base %llX\\\
  n\", pdd->gpuvm_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_limit %llX\\n\",\
  \ pdd->gpuvm_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_base %llX\\n\", pdd->scratch_base);\n\
  \t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_limit %llX\\n\", pdd->scratch_limit);\n\
  \t}\n\tmutex_unlock(&p->mutex);\n\n\targs->num_of_nodes = i;\n\tret = copy_to_user(\n\
  \t\t\t(void __user *)args->kfd_process_device_apertures_ptr,\n\t\t\tpa,\n\t\t\t\
  (i * sizeof(struct kfd_process_device_apertures)));\n\tkfree(pa);\n\treturn ret\
  \ ? -EFAULT : 0;\n\nout_unlock:\n\tmutex_unlock(&p->mutex);\n\treturn 0;\n}\n```\n\
  \n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\
  \ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\nindex f9631f4b1a02..55aa74cbc532 100644\n\
  --- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  @@ -779,8 +779,8 @@ static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\
  \ \t * nodes, but not more than args->num_of_nodes as that is\n \t * the amount\
  \ of memory allocated by user\n \t */\n-\tpa = kzalloc((sizeof(struct kfd_process_device_apertures)\
  \ *\n-\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n+\tpa = kcalloc(args->num_of_nodes,\
  \ sizeof(struct kfd_process_device_apertures),\n+\t\t     GFP_KERNEL);\n \tif (!pa)\n\
  \ \t\treturn -ENOMEM;\n \n```\n"
pattern: '## Bug Pattern


  Allocating an array with kmalloc/kzalloc using manual multiplication of count and
  element size without overflow checking:


  p = kzalloc(n * sizeof(*p), GFP_KERNEL);


  If n is large (potentially user-controlled), n * sizeof(*p) can overflow size_t,
  leading to an undersized allocation and subsequent out-of-bounds writes. The correct
  pattern is to use kcalloc(n, sizeof(*p), GFP_KERNEL), which detects overflow.'
plan: "Plan: Detect manual size multiplication passed to kmalloc/kzalloc family (suggest\
  \ kcalloc/kmalloc_array)\n\n1) Program state\n- No custom symbolic reasoning is\
  \ required for a basic checker.\n- Optional precision (recommended, still simple):\
  \ remember locals that were computed as \u201Ccount * sizeof(T)\u201D so later calls\
  \ like kmalloc(sz) are also flagged.\n  - REGISTER_MAP_WITH_PROGRAMSTATE(SizeMulMap,\
  \ const MemRegion *, bool)\n    - Key: region of a scalar variable holding a size\
  \ value.\n    - Value: true indicates the variable\u2019s current value is computed\
  \ as a multiplication by sizeof.\n\n2) Callbacks and implementation steps\n\nA)\
  \ checkPreCall (main detection point)\n- Goal: Catch calls to allocators that take\
  \ a byte-size as their first argument and where that size is computed by multiplication\
  \ with sizeof.\n- Target functions (exact name match via Call.getCalleeIdentifier()):\n\
  \  - Zeroing alloc: kzalloc, kvzalloc, devm_kzalloc\n  - Non-zeroing alloc: kmalloc,\
  \ kvmalloc, devm_kmalloc, __kmalloc\n- For each targeted call:\n  1) Fetch the size\
  \ argument index:\n     - For all targets above, size is argument 0.\n  2) Get the\
  \ Expr* of the size argument and strip parens/imp-casts.\n  3) Detect \u201Cmultiplication\
  \ by sizeof\u201D directly:\n     - If sizeExpr is a BinaryOperator with opcode\
  \ BO_Mul, then check if either LHS or RHS is a sizeof:\n       - sizeof check: dyn_cast<UnaryExprOrTypeTraitExpr>(Op->IgnoreParenImpCasts())\
  \ with getKind() == UETT_SizeOf.\n       - If one operand is sizeof, record the\
  \ other as CountExpr (for optional checks).\n     - If matched, we have a bug pattern.\n\
  \  4) If not matched directly, detect via map:\n     - If sizeExpr is a DeclRefExpr,\
  \ get its MemRegion via getMemRegionFromExpr; if region exists in SizeMulMap with\
  \ true, treat as matched.\n  5) Optional noise reduction:\n     - If you found a\
  \ CountExpr in step 3, attempt EvaluateExprToInt on CountExpr. If it succeeds (constant)\
  \ and is small (e.g., <= 4) you may skip to reduce false positives. Otherwise warn.\
  \ If evaluation fails (symbolic), warn.\n  6) Build a short, clear report:\n   \
  \  - Message: \u201CUse array allocator to avoid overflow: prefer kcalloc/kmalloc_array.\u201D\
  \n     - Tailor recommendation based on callee:\n       - kzalloc or devm_kzalloc\
  \ -> suggest kcalloc or devm_kcalloc\n       - kmalloc or __kmalloc or devm_kmalloc\
  \ -> suggest kmalloc_array or devm_kmalloc_array\n       - kvmalloc -> suggest kvmalloc_array\n\
  \       - kvzalloc -> suggest kvcalloc (or kvmalloc_array if kvcalloc not desired/available)\n\
  \     - Create a non-fatal error node and emit PathSensitiveBugReport.\n     - Highlight\
  \ the size argument range.\n\nB) checkBind (optional precision, simple)\n- Goal:\
  \ Populate SizeMulMap when a variable is assigned a value computed as count * sizeof(T).\
  \ This catches patterns like:\n  - size_t sz = n * sizeof(*p);\n  - pa = kzalloc(sz,\
  \ GFP_KERNEL);\n- Implementation:\n  1) Only handle bindings where destination is\
  \ a region of a local or parameter variable (mem region from Loc).\n  2) Obtain\
  \ the Stmt* S from the callback, and try to find the RHS Expr being bound:\n   \
  \  - Using the Stmt* from checkBind, get the RHS via findSpecificTypeInParents<BinaryOperator>(S,\
  \ C) if needed, or better:\n       - If S is a BinaryOperator with opcode BO_Assign,\
  \ use its RHS.\n       - If S is a DeclStmt with an initialized VarDecl, it won\u2019\
  t be seen here; that case is handled in checkPostStmt (below, optional). For checkBind,\
  \ rely on the analyzer-provided Val\u2019s origin expression: get the ProgramState\
  \ SVal won\u2019t give the AST, so you should inspect S directly.\n  3) If RHS (stripped\
  \ of parens/imp-casts) is BO_Mul and one side is sizeof (same detection as in A.3),\
  \ set SizeMulMap[destRegion] = true; otherwise remove any existing entry for destRegion.\n\
  \nC) checkPostStmt(const DeclStmt *) (optional, complements checkBind)\n- Goal:\
  \ Handle declarations with initializers, e.g. \u201Csize_t sz = n * sizeof(*p);\u201D\
  \n- Implementation:\n  1) For each VarDecl in DeclStmt with an initializer:\n  \
  \   - Obtain the initializer Expr, strip parens/imp-casts.\n     - If it\u2019s\
  \ \u201Cmul by sizeof\u201D as above, get the region of the variable via getMemRegionFromExpr\
  \ on a DeclRefExpr constructed by the analyzer for the VarDecl (or use C.getSVal\
  \ for the initialization site) and set SizeMulMap[region] = true.\n\nD) checkRegionChanges\
  \ (cleanup, optional)\n- When regions are invalidated (e.g., leaving scope), remove\
  \ them from SizeMulMap to keep state tidy.\n\n3) Helper utilities to implement\n\
  - isAllocLike(const CallEvent &Call, StringRef &NameOut):\n  - Return true if callee\
  \ name is one of: {\"kmalloc\",\"kzalloc\",\"kvmalloc\",\"kvzalloc\",\"__kmalloc\"\
  ,\"devm_kmalloc\",\"devm_kzalloc\"}; set NameOut.\n- getArrayAllocatorSuggestion(StringRef\
  \ CalleeName):\n  - Map:\n    - kzalloc -> kcalloc\n    - devm_kzalloc -> devm_kcalloc\n\
  \    - kmalloc, __kmalloc -> kmalloc_array\n    - devm_kmalloc -> devm_kmalloc_array\n\
  \    - kvmalloc -> kvmalloc_array\n    - kvzalloc -> kvcalloc (or kvmalloc_array\
  \ if kvcalloc is not intended; choose kvcalloc if available in your target tree).\n\
  - isMulBySizeof(const Expr *E, const Expr *&CountExprOut):\n  - Return true if E\
  \ is a multiplication and one operand is UETT_SizeOf; set CountExprOut to the non-sizeof\
  \ operand. Ignore parens/imp-casts on both sides.\n\n4) Reporting details\n- Use\
  \ generateNonFatalErrorNode for the bug node.\n- Construct a PathSensitiveBugReport\
  \ with a concise message, suggest the safer API in the text.\n- Add the source range\
  \ of the size argument to the report with addRange.\n- One bug per call site.\n\n\
  5) Notes to keep it simple and effective\n- This checker does not need complex taint\
  \ analysis; it flags the universally risky pattern independent of whether the count\
  \ is user-controlled.\n- The optional SizeMulMap improves coverage when the size\
  \ argument is passed via a temporary variable.\n- Keep the pattern match straightforward:\
  \ binary multiply with a sizeof on either side. This aligns with the real-world\
  \ kernel pattern the patch fixes."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/ASTContext.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Track variables that currently hold a size computed as (count * sizeof(...))\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(SizeMulMap, const MemRegion*, bool)\n\nnamespace\
  \ {\nclass SAGenTestChecker : public Checker<\n    check::PreCall,\n    check::Bind\n\
  \  > {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Size multiplication passed to allocator\", \"Memory Allocation\"\
  )) {}\n\n      void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \n   private:\n      // Helpers\n      static bool isMulBySizeof(const Expr *E,\
  \ const Expr *&CountExpr);\n      static bool isSizeofExpr(const Expr *E);\n   \
  \   static bool matchCallName(const CallEvent &Call, CheckerContext &C, StringRef\
  \ Name);\n      static bool isAllocLike(const CallEvent &Call, CheckerContext &C,\
  \ StringRef &NameOut);\n      static StringRef getArrayAllocatorSuggestion(StringRef\
  \ CalleeName);\n};\n  \n// Check if expression is a sizeof(...) (after stripping\
  \ parens/imp-casts)\nbool SAGenTestChecker::isSizeofExpr(const Expr *E) {\n  if\
  \ (!E) return false;\n  E = E->IgnoreParenImpCasts();\n  if (const auto *U = dyn_cast<UnaryExprOrTypeTraitExpr>(E))\
  \ {\n    return U->getKind() == UETT_SizeOf;\n  }\n  return false;\n}\n\n// Check\
  \ if E is a multiplication where one side is sizeof(...).\n// If true, CountExpr\
  \ is set to the non-sizeof operand.\nbool SAGenTestChecker::isMulBySizeof(const\
  \ Expr *E, const Expr *&CountExpr) {\n  CountExpr = nullptr;\n  if (!E) return false;\n\
  \  E = E->IgnoreParenImpCasts();\n\n  const auto *BO = dyn_cast<BinaryOperator>(E);\n\
  \  if (!BO) return false;\n  if (BO->getOpcode() != BO_Mul) return false;\n\n  const\
  \ Expr *LHS = BO->getLHS()->IgnoreParenImpCasts();\n  const Expr *RHS = BO->getRHS()->IgnoreParenImpCasts();\n\
  \n  if (isSizeofExpr(LHS)) {\n    CountExpr = RHS;\n    return true;\n  }\n  if\
  \ (isSizeofExpr(RHS)) {\n    CountExpr = LHS;\n    return true;\n  }\n  return false;\n\
  }\n\nbool SAGenTestChecker::matchCallName(const CallEvent &Call, CheckerContext\
  \ &C, StringRef Name) {\n  const Expr *OE = Call.getOriginExpr();\n  if (!OE) return\
  \ false;\n  return ExprHasName(OE, Name, C);\n}\n\n// Return true if this is one\
  \ of the kmalloc/kzalloc family that take a byte size.\n// NameOut will be set to\
  \ the matched callee name.\nbool SAGenTestChecker::isAllocLike(const CallEvent &Call,\
  \ CheckerContext &C, StringRef &NameOut) {\n  static const char *Targets[] = {\n\
  \    \"kmalloc\", \"__kmalloc\", \"kzalloc\", \"kvmalloc\", \"kvzalloc\",\n    \"\
  devm_kmalloc\", \"devm_kzalloc\"\n  };\n  for (const char *T : Targets) {\n    if\
  \ (matchCallName(Call, C, T)) {\n      NameOut = T;\n      return true;\n    }\n\
  \  }\n  return false;\n}\n\n// Suggest an array allocator for the given allocator\
  \ name.\nStringRef SAGenTestChecker::getArrayAllocatorSuggestion(StringRef CalleeName)\
  \ {\n  if (CalleeName.equals(\"kzalloc\")) return \"kcalloc\";\n  if (CalleeName.equals(\"\
  devm_kzalloc\")) return \"devm_kcalloc\";\n  if (CalleeName.equals(\"kmalloc\")\
  \ || CalleeName.equals(\"__kmalloc\")) return \"kmalloc_array\";\n  if (CalleeName.equals(\"\
  devm_kmalloc\")) return \"devm_kmalloc_array\";\n  if (CalleeName.equals(\"kvmalloc\"\
  )) return \"kvmalloc_array\";\n  if (CalleeName.equals(\"kvzalloc\")) return \"\
  kvcalloc\";\n  // Default generic suggestion\n  return \"kcalloc/kmalloc_array\"\
  ;\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  StringRef CalleeName;\n  if (!isAllocLike(Call, C, CalleeName))\n\
  \    return;\n\n  // All targeted allocators take size as the first argument.\n\
  \  if (Call.getNumArgs() == 0)\n    return;\n\n  const Expr *SizeArgE = Call.getArgExpr(0);\n\
  \  if (!SizeArgE)\n    return;\n\n  const Expr *CountExpr = nullptr;\n  bool ShouldReport\
  \ = false;\n\n  // 1) Direct pattern: multiplication where one side is sizeof(...)\n\
  \  if (isMulBySizeof(SizeArgE, CountExpr)) {\n    ShouldReport = true;\n  } else\
  \ {\n    // 2) Indirect via variable holding sizeof(...) * count\n    const Expr\
  \ *E = SizeArgE->IgnoreParenImpCasts();\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(E))\
  \ {\n      ProgramStateRef State = C.getState();\n      const MemRegion *MR = getMemRegionFromExpr(DRE,\
  \ C);\n      if (MR) {\n        MR = MR->getBaseRegion();\n        if (MR) {\n \
  \         if (const bool *IsMul = State->get<SizeMulMap>(MR)) {\n            if\
  \ (*IsMul)\n              ShouldReport = true;\n          }\n        }\n      }\n\
  \    }\n  }\n\n  if (!ShouldReport)\n    return;\n\n  // Report: Recommend array\
  \ allocator to avoid overflow.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  SmallString<128> Msg;\n  StringRef Suggest = getArrayAllocatorSuggestion(CalleeName);\n\
  \  Msg.append(\"Use array allocator to avoid overflow; prefer \");\n  Msg.append(Suggest);\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(*BT, Msg.str(), N);\n  R->addRange(SizeArgE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc,\
  \ SVal Val, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State =\
  \ C.getState();\n\n  const MemRegion *LHSReg = Loc.getAsRegion();\n  if (!LHSReg)\n\
  \    return;\n  LHSReg = LHSReg->getBaseRegion();\n  if (!LHSReg)\n    return;\n\
  \n  // Only track simple variables (avoid binding to arbitrary memory like *p, p[i],\
  \ etc.)\n  if (!isa<VarRegion>(LHSReg))\n    return;\n\n  // Find an RHS expression\
  \ from the statement context\n  const Expr *RHS = nullptr;\n\n  if (const auto *BO\
  \ = dyn_cast_or_null<BinaryOperator>(S)) {\n    if (BO->isAssignmentOp())\n    \
  \  RHS = BO->getRHS();\n  }\n  if (!RHS) {\n    if (const auto *DS = dyn_cast_or_null<DeclStmt>(S))\
  \ {\n      for (const Decl *D : DS->decls()) {\n        if (const auto *VD = dyn_cast<VarDecl>(D))\
  \ {\n          if (const Expr *Init = VD->getInit())\n            RHS = Init;\n\
  \        }\n      }\n    }\n  }\n  if (!RHS) {\n    if (const auto *BO = findSpecificTypeInParents<BinaryOperator>(S,\
  \ C)) {\n      if (BO->isAssignmentOp())\n        RHS = BO->getRHS();\n    }\n \
  \ }\n  if (!RHS) {\n    if (const auto *DS = findSpecificTypeInParents<DeclStmt>(S,\
  \ C)) {\n      for (const Decl *D : DS->decls()) {\n        if (const auto *VD =\
  \ dyn_cast<VarDecl>(D)) {\n          if (const Expr *Init = VD->getInit())\n   \
  \         RHS = Init;\n        }\n      }\n    }\n  }\n\n  if (!RHS) {\n    // No\
  \ usable RHS expression found, clear any previous mark\n    State = State->remove<SizeMulMap>(LHSReg);\n\
  \    C.addTransition(State);\n    return;\n  }\n\n  const Expr *CountExpr = nullptr;\n\
  \  if (isMulBySizeof(RHS, CountExpr)) {\n    State = State->set<SizeMulMap>(LHSReg,\
  \ true);\n  } else {\n    State = State->remove<SizeMulMap>(LHSReg);\n  }\n  C.addTransition(State);\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects size multiplication passed to kmalloc/kzalloc family; suggest\
  \ kcalloc/kmalloc_array\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 0
tp_score: 1
