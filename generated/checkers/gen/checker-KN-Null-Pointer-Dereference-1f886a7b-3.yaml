_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 1f886a7bfb3faf4c1021e73f045538008ce7634e
commit_type: Null-Pointer-Dereference
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Basic/SourceManager.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Track symbols that are return values of allocation\
  \ functions that may return NULL.\nREGISTER_SET_WITH_PROGRAMSTATE(MaybeNullAllocSyms,\
  \ SymbolRef)\n// Track pointer storage locations (variables, fields, array elements)\
  \ that currently\n// store a maybe-NULL pointer and have not yet been NULL-checked.\n\
  REGISTER_SET_WITH_PROGRAMSTATE(UncheckedPtrRegions, const MemRegion *)\n\nnamespace\
  \ {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n \
  \       check::Bind,\n        check::BranchCondition,\n        check::Location,\n\
  \        check::PreCall> {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n\
  \  SAGenTestChecker() : BT(new BugType(this, \"Possible NULL dereference\", \"Memory\
  \ Error\")) {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext &C)\
  \ const;\n  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C)\
  \ const;\n  void checkBranchCondition(const Stmt *Condition, CheckerContext &C)\
  \ const;\n  void checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext\
  \ &C) const;\n  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \nprivate:\n  // Helpers\n  bool isMaybeNullAlloc(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  void clearCheckedForExpr(const Expr *E, ProgramStateRef &State,\
  \ CheckerContext &C) const;\n  bool isUncheckedPtrExpr(const Expr *E, ProgramStateRef\
  \ State, CheckerContext &C) const;\n\n  void reportDeref(const Expr *BaseE, const\
  \ Stmt *S, CheckerContext &C) const;\n  void reportUncheckedArg(const CallEvent\
  \ &Call, unsigned ArgIdx, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isMaybeNullAlloc(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Check common kernel allocators that may\
  \ return NULL\n  static const char *Names[] = {\n      \"devm_kzalloc\", \"devm_kmalloc\"\
  , \"devm_kcalloc\",\n      \"kzalloc\", \"kmalloc\", \"kcalloc\"\n  };\n\n  for\
  \ (const char *N : Names) {\n    if (ExprHasName(Origin, N, C))\n      return true;\n\
  \  }\n  return false;\n}\n\nvoid SAGenTestChecker::clearCheckedForExpr(const Expr\
  \ *E, ProgramStateRef &State,\n                                           CheckerContext\
  \ &C) const {\n  if (!E)\n    return;\n  const LocationContext *LCtx = C.getLocationContext();\n\
  \  SVal V = State->getSVal(E, LCtx);\n\n  if (SymbolRef Sym = V.getAsSymbol()) {\n\
  \    if (State->contains<MaybeNullAllocSyms>(Sym)) {\n      State = State->remove<MaybeNullAllocSyms>(Sym);\n\
  \    }\n  }\n\n  // Remove unchecked mark for the storage region if we have it.\n\
  \  if (const MemRegion *MR = getMemRegionFromExpr(E, C)) {\n    MR = MR->getBaseRegion();\n\
  \    if (MR && State->contains<UncheckedPtrRegions>(MR)) {\n      State = State->remove<UncheckedPtrRegions>(MR);\n\
  \    }\n  }\n}\n\nbool SAGenTestChecker::isUncheckedPtrExpr(const Expr *E, ProgramStateRef\
  \ State,\n                                          CheckerContext &C) const {\n\
  \  if (!E)\n    return false;\n\n  const LocationContext *LCtx = C.getLocationContext();\n\
  \  SVal V = State->getSVal(E, LCtx);\n\n  if (SymbolRef Sym = V.getAsSymbol()) {\n\
  \    if (State->contains<MaybeNullAllocSyms>(Sym))\n      return true;\n  }\n\n\
  \  if (const MemRegion *MR = getMemRegionFromExpr(E, C)) {\n    MR = MR->getBaseRegion();\n\
  \    if (MR && State->contains<UncheckedPtrRegions>(MR))\n      return true;\n \
  \ }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\n\
  \  if (!isMaybeNullAlloc(Call, C))\n    return;\n\n  // Mark return symbol as maybe-null\
  \ allocation result.\n  SVal Ret = Call.getReturnValue();\n  if (SymbolRef Sym =\
  \ Ret.getAsSymbol()) {\n    State = State->add<MaybeNullAllocSyms>(Sym);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *DstR\
  \ = Loc.getAsRegion();\n  if (!DstR) {\n    C.addTransition(State);\n    return;\n\
  \  }\n  DstR = DstR->getBaseRegion();\n  if (!DstR) {\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  bool MarkUnchecked = false;\n\n  // Case 1: RHS is a symbol\
  \ that comes from a maybe-null allocation.\n  if (SymbolRef Sym = Val.getAsSymbol())\
  \ {\n    if (State->contains<MaybeNullAllocSyms>(Sym))\n      MarkUnchecked = true;\n\
  \  }\n\n  // Case 2: If RHS is a region that is itself marked as unchecked storage,\
  \ propagate.\n  if (!MarkUnchecked) {\n    if (const MemRegion *SrcR = Val.getAsRegion())\
  \ {\n      SrcR = SrcR->getBaseRegion();\n      if (SrcR && State->contains<UncheckedPtrRegions>(SrcR))\n\
  \        MarkUnchecked = true;\n    }\n  }\n\n  if (MarkUnchecked) {\n    State\
  \ = State->add<UncheckedPtrRegions>(DstR);\n  }\n\n  C.addTransition(State);\n}\n\
  \nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE) {\n    C.addTransition(State);\n    return;\n  }\n\n  CondE = CondE->IgnoreParenCasts();\n\
  \n  // Pattern: if (!ptr) ...\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *SubE = UO->getSubExpr();\n\
  \      if (SubE) {\n        SubE = SubE->IgnoreParenCasts();\n\n        // Also\
  \ handle if (!(ptr = kzalloc(...))) ...\n        if (const auto *BO = dyn_cast<BinaryOperator>(SubE))\
  \ {\n          if (BO->getOpcode() == BO_Assign) {\n            const Expr *LHS\
  \ = BO->getLHS();\n            if (LHS) {\n              clearCheckedForExpr(LHS,\
  \ State, C);\n            }\n          } else {\n            clearCheckedForExpr(SubE,\
  \ State, C);\n          }\n        } else {\n          clearCheckedForExpr(SubE,\
  \ State, C);\n        }\n      }\n      C.addTransition(State);\n      return;\n\
  \    }\n  }\n\n  // Pattern: if (ptr == NULL) or if (ptr != NULL)\n  if (const auto\
  \ *BO = dyn_cast<BinaryOperator>(CondE)) {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n\
  \    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \      const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n      bool LHSIsNull\
  \ = LHS->isNullPointerConstant(C.getASTContext(),\n                            \
  \                      Expr::NPC_ValueDependentIsNull);\n      bool RHSIsNull =\
  \ RHS->isNullPointerConstant(C.getASTContext(),\n                              \
  \                    Expr::NPC_ValueDependentIsNull);\n\n      const Expr *PtrE\
  \ = nullptr;\n      if (LHSIsNull && !RHSIsNull)\n        PtrE = RHS;\n      else\
  \ if (RHSIsNull && !LHSIsNull)\n        PtrE = LHS;\n\n      if (PtrE) {\n     \
  \   clearCheckedForExpr(PtrE, State, C);\n        C.addTransition(State);\n    \
  \    return;\n      }\n    }\n\n    // Pattern: if ((ptr = kzalloc(...))) treat\
  \ as checked too\n    if (BO->getOpcode() == BO_Assign) {\n      const Expr *LHS\
  \ = BO->getLHS();\n      if (LHS) {\n        clearCheckedForExpr(LHS, State, C);\n\
  \        C.addTransition(State);\n        return;\n      }\n    }\n  }\n\n  // Pattern:\
  \ if (ptr) ...\n  // Heuristically consider it a NULL-check and clear.\n  {\n  \
  \  SVal V = State->getSVal(CondE, C.getLocationContext());\n    if (V.getAs<DefinedSVal>())\
  \ {\n      clearCheckedForExpr(CondE, State, C);\n    }\n  }\n\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::reportDeref(const Expr *BaseE, const Stmt *S, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Possible NULL dereference: unchecked result of allocation\", N);\n  if (S)\n\
  \    R->addRange(S->getSourceRange());\n  if (BaseE)\n    R->addRange(BaseE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkLocation(SVal Loc,\
  \ bool IsLoad, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n  if (!S)\n    return;\n\n  // Look for ptr->field\n  if (const\
  \ auto *ME = findSpecificTypeInChildren<MemberExpr>(S)) {\n    if (ME && ME->isArrow())\
  \ {\n      const Expr *BaseE = ME->getBase();\n      if (isUncheckedPtrExpr(BaseE,\
  \ State, C)) {\n        reportDeref(BaseE, S, C);\n        return;\n      }\n  \
  \  }\n  }\n\n  // Also check if S itself is a MemberExpr\n  if (const auto *ME =\
  \ dyn_cast<MemberExpr>(S)) {\n    if (ME->isArrow()) {\n      const Expr *BaseE\
  \ = ME->getBase();\n      if (isUncheckedPtrExpr(BaseE, State, C)) {\n        reportDeref(BaseE,\
  \ S, C);\n        return;\n      }\n    }\n  }\n\n  // Look for *ptr dereference\n\
  \  if (const auto *UO = findSpecificTypeInChildren<UnaryOperator>(S)) {\n    if\
  \ (UO && UO->getOpcode() == UO_Deref) {\n      const Expr *PtrE = UO->getSubExpr();\n\
  \      if (isUncheckedPtrExpr(PtrE, State, C)) {\n        reportDeref(PtrE, S, C);\n\
  \        return;\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::reportUncheckedArg(const\
  \ CallEvent &Call, unsigned ArgIdx,\n                                          CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"\
  Unchecked possibly-NULL pointer passed to a function that dereferences it\", N);\n\
  \  R->addRange(Call.getSourceRange());\n  if (ArgIdx < Call.getNumArgs())\n    R->addRange(Call.getArgExpr(ArgIdx)->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  llvm::SmallVector<unsigned, 4> DerefParams;\n\
  \  if (!functionKnownToDeref(Call, DerefParams))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  for (unsigned Idx : DerefParams) {\n    if (Idx >= Call.getNumArgs())\n\
  \      continue;\n    const Expr *ArgE = Call.getArgExpr(Idx);\n    if (!ArgE)\n\
  \      continue;\n    if (isUncheckedPtrExpr(ArgE, State, C)) {\n      reportUncheckedArg(Call,\
  \ Idx, C);\n    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects dereference of possibly-NULL pointers returned by [devm_]k[z/m/c]alloc\
  \ without NULL checks\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nspi: mchp-pci1xxx: Fix a possible null pointer dereference\
  \ in pci1xxx_spi_probe\n\nIn function pci1xxxx_spi_probe, there is a potential null\
  \ pointer that\nmay be caused by a failed memory allocation by the function devm_kzalloc.\n\
  Hence, a null pointer check needs to be added to prevent null pointer\ndereferencing\
  \ later in the code.\n\nTo fix this issue, spi_bus->spi_int[iter] should be checked.\
  \ The memory\nallocated by devm_kzalloc will be automatically released, so just\
  \ directly\nreturn -ENOMEM without worrying about memory leaks.\n\nFixes: 1cc0cbea7167\
  \ (\"spi: microchip: pci1xxxx: Add driver for SPI controller of PCI1XXXX PCIe switch\"\
  )\nSigned-off-by: Huai-Yuan Liu <qq810974084@gmail.com>\nLink: https://msgid.link/r/20240403014221.969801-1-qq810974084@gmail.com\n\
  Signed-off-by: Mark Brown <broonie@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ pci1xxxx_spi_probe in drivers/spi/spi-pci1xxxx.c\nstatic int pci1xxxx_spi_probe(struct\
  \ pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tu8 hw_inst_cnt, iter, start,\
  \ only_sec_inst;\n\tstruct pci1xxxx_spi_internal *spi_sub_ptr;\n\tstruct device\
  \ *dev = &pdev->dev;\n\tstruct pci1xxxx_spi *spi_bus;\n\tstruct spi_controller *spi_host;\n\
  \tu32 regval;\n\tint ret;\n\n\thw_inst_cnt = ent->driver_data & 0x0f;\n\tstart =\
  \ (ent->driver_data & 0xf0) >> 4;\n\tif (start == 1)\n\t\tonly_sec_inst = 1;\n\t\
  else\n\t\tonly_sec_inst = 0;\n\n\tspi_bus = devm_kzalloc(&pdev->dev,\n\t\t\t   \
  \    struct_size(spi_bus, spi_int, hw_inst_cnt),\n\t\t\t       GFP_KERNEL);\n\t\
  if (!spi_bus)\n\t\treturn -ENOMEM;\n\n\tspi_bus->dev = pdev;\n\tspi_bus->total_hw_instances\
  \ = hw_inst_cnt;\n\tpci_set_master(pdev);\n\n\tfor (iter = 0; iter < hw_inst_cnt;\
  \ iter++) {\n\t\tspi_bus->spi_int[iter] = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t\t\
  \      sizeof(struct pci1xxxx_spi_internal),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\
  \tspi_sub_ptr = spi_bus->spi_int[iter];\n\t\tspi_sub_ptr->spi_host = devm_spi_alloc_host(dev,\
  \ sizeof(struct spi_controller));\n\t\tif (!spi_sub_ptr->spi_host)\n\t\t\treturn\
  \ -ENOMEM;\n\n\t\tspi_sub_ptr->parent = spi_bus;\n\t\tspi_sub_ptr->spi_xfer_in_progress\
  \ = false;\n\n\t\tif (!iter) {\n\t\t\tret = pcim_enable_device(pdev);\n\t\t\tif\
  \ (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tret = pci_request_regions(pdev, DRV_NAME);\n\
  \t\t\tif (ret)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tspi_bus->reg_base = pcim_iomap(pdev,\
  \ 0, pci_resource_len(pdev, 0));\n\t\t\tif (!spi_bus->reg_base) {\n\t\t\t\tret =\
  \ -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret = pci_alloc_irq_vectors(pdev,\
  \ hw_inst_cnt, hw_inst_cnt,\n\t\t\t\t\t\t    PCI_IRQ_ALL_TYPES);\n\t\t\tif (ret\
  \ < 0) {\n\t\t\t\tdev_err(&pdev->dev, \"Error allocating MSI vectors\\n\");\n\t\t\
  \t\tgoto error;\n\t\t\t}\n\n\t\t\tinit_completion(&spi_sub_ptr->spi_xfer_done);\n\
  \t\t\t/* Initialize Interrupts - SPI_INT */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ +\n\t\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\t\
  regval &= ~SPI_INTR;\n\t\t\twritel(regval, spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\
  \t\t\tspi_sub_ptr->irq = pci_irq_vector(pdev, 0);\n\n\t\t\tret = devm_request_irq(&pdev->dev,\
  \ spi_sub_ptr->irq,\n\t\t\t\t\t       pci1xxxx_spi_isr, PCI1XXXX_IRQ_FLAGS,\n\t\t\
  \t\t\t       pci_name(pdev), spi_sub_ptr);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev,\
  \ \"Unable to request irq : %d\",\n\t\t\t\t\tspi_sub_ptr->irq);\n\t\t\t\tret = -ENODEV;\n\
  \t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret = pci1xxxx_spi_dma_init(spi_bus, spi_sub_ptr->irq);\n\
  \t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\tgoto error;\n\n\t\t\t/* This register\
  \ is only applicable for 1st instance */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ + SPI_PCI_CTRL_REG_OFFSET(0));\n\t\t\tif (!only_sec_inst)\n\t\t\t\tregval |= (BIT(4));\n\
  \t\t\telse\n\t\t\t\tregval &= ~(BIT(4));\n\n\t\t\twritel(regval, spi_bus->reg_base\
  \ + SPI_PCI_CTRL_REG_OFFSET(0));\n\t\t}\n\n\t\tspi_sub_ptr->hw_inst = start++;\n\
  \n\t\tif (iter == 1) {\n\t\t\tinit_completion(&spi_sub_ptr->spi_xfer_done);\n\t\t\
  \t/* Initialize Interrupts - SPI_INT */\n\t\t\tregval = readl(spi_bus->reg_base\
  \ +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\t\t\t\
  regval &= ~SPI_INTR;\n\t\t\twritel(regval, spi_bus->reg_base +\n\t\t\t       SPI_MST_EVENT_MASK_REG_OFFSET(spi_sub_ptr->hw_inst));\n\
  \t\t\tspi_sub_ptr->irq = pci_irq_vector(pdev, iter);\n\t\t\tret = devm_request_irq(&pdev->dev,\
  \ spi_sub_ptr->irq,\n\t\t\t\t\t       pci1xxxx_spi_isr, PCI1XXXX_IRQ_FLAGS,\n\t\t\
  \t\t\t       pci_name(pdev), spi_sub_ptr);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev,\
  \ \"Unable to request irq : %d\",\n\t\t\t\t\tspi_sub_ptr->irq);\n\t\t\t\tret = -ENODEV;\n\
  \t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tspi_host = spi_sub_ptr->spi_host;\n\t\
  \tspi_host->num_chipselect = SPI_CHIP_SEL_COUNT;\n\t\tspi_host->mode_bits = SPI_MODE_0\
  \ | SPI_MODE_3 | SPI_RX_DUAL |\n\t\t\t\t      SPI_TX_DUAL | SPI_LOOP;\n\t\tspi_host->can_dma\
  \ = pci1xxxx_spi_can_dma;\n\t\tspi_host->transfer_one = pci1xxxx_spi_transfer_one;\n\
  \n\t\tspi_host->set_cs = pci1xxxx_spi_set_cs;\n\t\tspi_host->bits_per_word_mask\
  \ = SPI_BPW_MASK(8);\n\t\tspi_host->max_speed_hz = PCI1XXXX_SPI_MAX_CLOCK_HZ;\n\t\
  \tspi_host->min_speed_hz = PCI1XXXX_SPI_MIN_CLOCK_HZ;\n\t\tspi_host->flags = SPI_CONTROLLER_MUST_TX;\n\
  \t\tspi_controller_set_devdata(spi_host, spi_sub_ptr);\n\t\tret = devm_spi_register_controller(dev,\
  \ spi_host);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\tpci_set_drvdata(pdev, spi_bus);\n\
  \n\treturn 0;\n\nerror:\n\tpci_release_regions(pdev);\n\treturn ret;\n}\n```\n\n\
  ## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/spi/spi-pci1xxxx.c b/drivers/spi/spi-pci1xxxx.c\n\
  index 969965d7bc98..cc18d320370f 100644\n--- a/drivers/spi/spi-pci1xxxx.c\n+++ b/drivers/spi/spi-pci1xxxx.c\n\
  @@ -725,6 +725,8 @@ static int pci1xxxx_spi_probe(struct pci_dev *pdev, const struct\
  \ pci_device_id *\n \t\tspi_bus->spi_int[iter] = devm_kzalloc(&pdev->dev,\n \t\t\
  \t\t\t\t      sizeof(struct pci1xxxx_spi_internal),\n \t\t\t\t\t\t      GFP_KERNEL);\n\
  +\t\tif (!spi_bus->spi_int[iter])\n+\t\t\treturn -ENOMEM;\n \t\tspi_sub_ptr = spi_bus->spi_int[iter];\n\
  \ \t\tspi_sub_ptr->spi_host = devm_spi_alloc_host(dev, sizeof(struct spi_controller));\n\
  \ \t\tif (!spi_sub_ptr->spi_host)\n```\n"
pattern: '## Bug Pattern


  Using devm_kzalloc (or any *_kzalloc/*_kmalloc) to allocate a structure and then
  immediately dereferencing the returned pointer without checking it for NULL. In
  this patch, an array element is allocated inside a loop:


  ptr_array[i] = devm_kzalloc(dev, sizeof(*ptr_array[i]), GFP_KERNEL);

  /* missing: if (!ptr_array[i]) return -ENOMEM; */

  sub = ptr_array[i];

  sub->field = ...;  // NULL pointer dereference if allocation failed


  This missing NULL check after a potentially failing allocation leads to a possible
  NULL pointer dereference.'
plan: "Plan\n\n1) Program state\n- REGISTER_SET_WITH_PROGRAMSTATE(MaybeNullAllocSyms,\
  \ SymbolRef)\n  - Holds symbols that are return values of allocation functions which\
  \ may return NULL and have not yet been NULL-checked.\n- REGISTER_SET_WITH_PROGRAMSTATE(UncheckedPtrRegions,\
  \ const MemRegion *)\n  - Holds pointer storage locations (variables, fields, array\
  \ elements) that currently store a maybe-NULL pointer and have not yet been NULL-checked.\n\
  - No extra traits/maps unless necessary; we will propagate via checkBind and clear\
  \ the state via checkBranchCondition. This keeps the checker simple and focused.\n\
  \n2) Target functions and minimal helpers\n- Allocation functions of interest (extendable\
  \ list):\n  - devm_kzalloc, devm_kmalloc, devm_kcalloc\n  - kzalloc, kmalloc, kcalloc\n\
  - Helper: bool isMaybeNullAlloc(const CallEvent &Call)\n  - Returns true if callee\
  \ name is any of the above.\n- Helper: void clearCheckedForExpr(const Expr *E, ProgramStateRef\
  \ &State, CheckerContext &C)\n  - Given an expression E, remove its SymbolRef from\
  \ MaybeNullAllocSyms (if any) and its MemRegion from UncheckedPtrRegions (if any).\n\
  \  - Implementation:\n    - If SymbolRef Sym = State->getSVal(E, C.getLocationContext()).getAsSymbol():\
  \ State = State->remove<MaybeNullAllocSyms>(Sym);\n    - If const MemRegion *R =\
  \ getMemRegionFromExpr(E, C): State = State->remove<UncheckedPtrRegions>(R).\n\n\
  3) checkPostCall: tag return values of maybe-NULL allocations\n- If isMaybeNullAlloc(Call):\n\
  \  - SVal Ret = Call.getReturnValue();\n  - If SymbolRef Sym = Ret.getAsSymbol():\
  \ add Sym to MaybeNullAllocSyms.\n  - No bug is reported here. We just remember\
  \ the returned pointer may be NULL.\n- This supports both direct deref (devm_kzalloc(...)->field)\
  \ and assignments.\n\n4) checkBind: propagate \u201Cmaybe-NULL and unchecked\u201D\
  \ status through assignments\n- Purpose: capture when the maybe-NULL allocation\
  \ is stored to a region (variable, field, array element) or copied to another pointer\
  \ variable.\n- Get LHS region: If Loc is a loc::MemRegionVal, const MemRegion *DstR\
  \ = Loc.getAsRegion().\n- For RHS:\n  - If RHS has SymbolRef Sym and Sym \u2208\
  \ MaybeNullAllocSyms, then mark DstR as unchecked: State = State->add<UncheckedPtrRegions>(DstR).\n\
  \  - Else if RHS is a loc::MemRegionVal whose region SrcR \u2208 UncheckedPtrRegions,\
  \ then also mark DstR as unchecked (propagate).\n- Note: We do not remove anything\
  \ here. The \u201Ccheck\u201D event will clear entries.\n\n5) checkBranchCondition:\
  \ detect NULL checks and clear the status\n- Goal: detect simple NULL checks and\
  \ consider the pointer as \u201Cchecked\u201D afterwards (regardless of branch direction\
  \ to keep the checker simple and avoid false positives on common \u201Cif (!p) return;\
  \ \u2026\u201D idioms).\n- Analyze the Condition expression to find pointer expressions\
  \ commonly used in NULL checks:\n  - UnaryOperator \u2018!\u2019: if (!ptr)\n  \
  \  - Extract subexpr as ptrE; call clearCheckedForExpr(ptrE, State, C).\n  - BinaryOperator\
  \ \u2018==\u2019 or \u2018!=\u2019 with NULL on either side: if (ptr == NULL), if\
  \ (NULL != ptr)\n    - Identify the non-NULL operand as ptrE; call clearCheckedForExpr(ptrE,\
  \ State, C).\n  - A bare pointer in condition: if (ptr)\n    - Treat this as a check;\
  \ call clearCheckedForExpr(ptr, State, C).\n- Implementation details:\n  - Use dyn_cast\
  \ to UnaryOperator/BinaryOperator; for NULL detect IntegerLiteral 0 or gcc/clang\
  \ NULL macro matches via ExprHasName(E, \"NULL\", C).\n  - After clearing, call\
  \ C.addTransition(State).\n\n6) checkLocation: report dereference of unchecked maybe-NULL\
  \ pointer\n- This is where we recognize that a pointer is dereferenced without a\
  \ prior NULL-check.\n- Triggered on both loads and stores.\n- Identify dereference\
  \ patterns by examining S (the Stmt that caused the memory access):\n  - Look for\
  \ a MemberExpr with isArrow() within S via findSpecificTypeInChildren<MemberExpr>(S)\
  \ or findSpecificTypeInParents<MemberExpr>(S):\n    - Let BaseE = ME->getBase()->IgnoreParenImpCasts();\n\
  \    - Check BaseE for:\n      - SymbolRef Sym = State->getSVal(BaseE, C.getLocationContext()).getAsSymbol();\
  \ if Sym \u2208 MaybeNullAllocSyms, then report.\n      - const MemRegion *R = getMemRegionFromExpr(BaseE,\
  \ C); if R \u2208 UncheckedPtrRegions, then report.\n  - If not found, look for\
  \ UnaryOperator UO_Deref (\u2018*ptr\u2019) similarly:\n    - Let PtrE = UO->getSubExpr()->IgnoreParenImpCasts();\
  \ check Sym and Region as above.\n  - Also consider ArraySubscriptExpr used as a\
  \ pointer (e.g., arr[i]->field):\n    - If BaseE is an ArraySubscriptExpr (or any\
  \ expression) that evaluates to a pointer, use the same Sym/Region checks.\n- If\
  \ any match is found, generate a non-fatal error node and report:\n  - Message:\
  \ \u201CPossible NULL dereference: result of k[z/m/c]alloc() not checked\u201D\n\
  \  - Use std::make_unique<PathSensitiveBugReport>.\n- Notes:\n  - We do not clear\
  \ state here; we only report.\n  - We check both symbol-based and region-based tracking\
  \ to robustly handle direct deref of call results and deref via aliases/array elements.\n\
  \n7) checkPreCall: report when passing unchecked pointers to functions known to\
  \ dereference them\n- Optional but helpful to catch more cases.\n- Use functionKnownToDeref(Call,\
  \ DerefParams).\n- For each parameter index in DerefParams:\n  - Let ArgE = Call.getArgExpr(I)->IgnoreParenImpCasts();\n\
  \  - If ArgE\u2019s Sym \u2208 MaybeNullAllocSyms or its MemRegion \u2208 UncheckedPtrRegions,\
  \ report with a short message:\n    - \u201CUnchecked possibly-NULL pointer passed\
  \ to a function that dereferences it\u201D\n- Do not modify state here.\n\n8) Minor\
  \ robustness details\n- Also mark as checked in checkBranchCondition when we see\
  \ explicit guards in early returns:\n  - Pattern: if (!ptr) return \u2026; We already\
  \ clear on \u201C!ptr\u201D.\n- If you want fewer false negatives, also clear on\
  \ assignment-if-guard patterns:\n  - Pattern: if (!(ptr = kzalloc(...))) return\
  \ -ENOMEM; Detected in checkBranchCondition by scanning child CallExpr and LHS expr;\
  \ then clear LHS with clearCheckedForExpr(LHS, \u2026).\n- Keep the allocation function\
  \ list minimal initially (devm_kzalloc, kzalloc, kmalloc, devm_kmalloc, kcalloc,\
  \ devm_kcalloc) and expand if needed.\n\nSummary of control/data flow\n- Allocation\
  \ returns pointer symbol S \u2192 checkPostCall adds S to MaybeNullAllocSyms.\n\
  - When S is stored (including array element) \u2192 checkBind adds destination region\
  \ R to UncheckedPtrRegions. Symbol also naturally propagates through expressions,\
  \ so deref of either the symbol or region is caught.\n- Any obvious NULL-check on\
  \ an expression E \u2192 checkBranchCondition clears both its symbol and region\
  \ tracking.\n- Any deref (->, *, arr[i]->) on an expression E while its symbol/region\
  \ is still marked unchecked \u2192 checkLocation reports the bug.\n- Passing unchecked\
  \ E to known deref\u2019ing APIs \u2192 checkPreCall reports the bug.\n\nReport\
  \ messages\n- For dereference: \u201CPossible NULL dereference: result of [devm_]k[z/m/c]alloc()\
  \ not checked\u201D\n- For call argument: \u201CUnchecked possibly-NULL pointer\
  \ passed to a function that dereferences it\u201D\n\nThis plan directly catches\
  \ the target pattern in the provided patch: the array element spi_bus->spi_int[iter]\
  \ receives the result of devm_kzalloc, there is no immediate NULL check, it is aliased\
  \ to spi_sub_ptr, and then dereferenced via spi_sub_ptr->spi_host. The checker records\
  \ the allocation symbol, propagates to the array element region on bind, doesn\u2019\
  t see a conditional check, and finally reports at the dereference site."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Basic/SourceManager.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n// Track symbols that are return values of allocation\
  \ functions that may return NULL.\nREGISTER_SET_WITH_PROGRAMSTATE(MaybeNullAllocSyms,\
  \ SymbolRef)\n// Track pointer storage locations (variables, fields, array elements)\
  \ that currently\n// store a maybe-NULL pointer and have not yet been NULL-checked.\n\
  REGISTER_SET_WITH_PROGRAMSTATE(UncheckedPtrRegions, const MemRegion *)\n\nnamespace\
  \ {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PostCall,\n \
  \       check::Bind,\n        check::BranchCondition,\n        check::Location,\n\
  \        check::PreCall> {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n\
  \  SAGenTestChecker() : BT(new BugType(this, \"Possible NULL dereference\", \"Memory\
  \ Error\")) {}\n\n  void checkPostCall(const CallEvent &Call, CheckerContext &C)\
  \ const;\n  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C)\
  \ const;\n  void checkBranchCondition(const Stmt *Condition, CheckerContext &C)\
  \ const;\n  void checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext\
  \ &C) const;\n  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;\n\
  \nprivate:\n  // Helpers\n  bool isMaybeNullAlloc(const CallEvent &Call, CheckerContext\
  \ &C) const;\n  void clearCheckedForExpr(const Expr *E, ProgramStateRef &State,\
  \ CheckerContext &C) const;\n  bool isUncheckedPtrExpr(const Expr *E, ProgramStateRef\
  \ State, CheckerContext &C) const;\n\n  void reportDeref(const Expr *BaseE, const\
  \ Stmt *S, CheckerContext &C) const;\n  void reportUncheckedArg(const CallEvent\
  \ &Call, unsigned ArgIdx, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isMaybeNullAlloc(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  // Check common kernel allocators that may\
  \ return NULL\n  static const char *Names[] = {\n      \"devm_kzalloc\", \"devm_kmalloc\"\
  , \"devm_kcalloc\",\n      \"kzalloc\", \"kmalloc\", \"kcalloc\"\n  };\n\n  for\
  \ (const char *N : Names) {\n    if (ExprHasName(Origin, N, C))\n      return true;\n\
  \  }\n  return false;\n}\n\nvoid SAGenTestChecker::clearCheckedForExpr(const Expr\
  \ *E, ProgramStateRef &State,\n                                           CheckerContext\
  \ &C) const {\n  if (!E)\n    return;\n  const LocationContext *LCtx = C.getLocationContext();\n\
  \  SVal V = State->getSVal(E, LCtx);\n\n  if (SymbolRef Sym = V.getAsSymbol()) {\n\
  \    if (State->contains<MaybeNullAllocSyms>(Sym)) {\n      State = State->remove<MaybeNullAllocSyms>(Sym);\n\
  \    }\n  }\n\n  // Remove unchecked mark for the storage region if we have it.\n\
  \  if (const MemRegion *MR = getMemRegionFromExpr(E, C)) {\n    MR = MR->getBaseRegion();\n\
  \    if (MR && State->contains<UncheckedPtrRegions>(MR)) {\n      State = State->remove<UncheckedPtrRegions>(MR);\n\
  \    }\n  }\n}\n\nbool SAGenTestChecker::isUncheckedPtrExpr(const Expr *E, ProgramStateRef\
  \ State,\n                                          CheckerContext &C) const {\n\
  \  if (!E)\n    return false;\n\n  const LocationContext *LCtx = C.getLocationContext();\n\
  \  SVal V = State->getSVal(E, LCtx);\n\n  if (SymbolRef Sym = V.getAsSymbol()) {\n\
  \    if (State->contains<MaybeNullAllocSyms>(Sym))\n      return true;\n  }\n\n\
  \  if (const MemRegion *MR = getMemRegionFromExpr(E, C)) {\n    MR = MR->getBaseRegion();\n\
  \    if (MR && State->contains<UncheckedPtrRegions>(MR))\n      return true;\n \
  \ }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\n\
  \  if (!isMaybeNullAlloc(Call, C))\n    return;\n\n  // Mark return symbol as maybe-null\
  \ allocation result.\n  SVal Ret = Call.getReturnValue();\n  if (SymbolRef Sym =\
  \ Ret.getAsSymbol()) {\n    State = State->add<MaybeNullAllocSyms>(Sym);\n    C.addTransition(State);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  const MemRegion *DstR\
  \ = Loc.getAsRegion();\n  if (!DstR) {\n    C.addTransition(State);\n    return;\n\
  \  }\n  DstR = DstR->getBaseRegion();\n  if (!DstR) {\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  bool MarkUnchecked = false;\n\n  // Case 1: RHS is a symbol\
  \ that comes from a maybe-null allocation.\n  if (SymbolRef Sym = Val.getAsSymbol())\
  \ {\n    if (State->contains<MaybeNullAllocSyms>(Sym))\n      MarkUnchecked = true;\n\
  \  }\n\n  // Case 2: If RHS is a region that is itself marked as unchecked storage,\
  \ propagate.\n  if (!MarkUnchecked) {\n    if (const MemRegion *SrcR = Val.getAsRegion())\
  \ {\n      SrcR = SrcR->getBaseRegion();\n      if (SrcR && State->contains<UncheckedPtrRegions>(SrcR))\n\
  \        MarkUnchecked = true;\n    }\n  }\n\n  if (MarkUnchecked) {\n    State\
  \ = State->add<UncheckedPtrRegions>(DstR);\n  }\n\n  C.addTransition(State);\n}\n\
  \nvoid SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n  const Expr *CondE = dyn_cast_or_null<Expr>(Condition);\n\
  \  if (!CondE) {\n    C.addTransition(State);\n    return;\n  }\n\n  CondE = CondE->IgnoreParenCasts();\n\
  \n  // Pattern: if (!ptr) ...\n  if (const auto *UO = dyn_cast<UnaryOperator>(CondE))\
  \ {\n    if (UO->getOpcode() == UO_LNot) {\n      const Expr *SubE = UO->getSubExpr();\n\
  \      if (SubE) {\n        SubE = SubE->IgnoreParenCasts();\n\n        // Also\
  \ handle if (!(ptr = kzalloc(...))) ...\n        if (const auto *BO = dyn_cast<BinaryOperator>(SubE))\
  \ {\n          if (BO->getOpcode() == BO_Assign) {\n            const Expr *LHS\
  \ = BO->getLHS();\n            if (LHS) {\n              clearCheckedForExpr(LHS,\
  \ State, C);\n            }\n          } else {\n            clearCheckedForExpr(SubE,\
  \ State, C);\n          }\n        } else {\n          clearCheckedForExpr(SubE,\
  \ State, C);\n        }\n      }\n      C.addTransition(State);\n      return;\n\
  \    }\n  }\n\n  // Pattern: if (ptr == NULL) or if (ptr != NULL)\n  if (const auto\
  \ *BO = dyn_cast<BinaryOperator>(CondE)) {\n    BinaryOperator::Opcode Op = BO->getOpcode();\n\
  \    if (Op == BO_EQ || Op == BO_NE) {\n      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \      const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n      bool LHSIsNull\
  \ = LHS->isNullPointerConstant(C.getASTContext(),\n                            \
  \                      Expr::NPC_ValueDependentIsNull);\n      bool RHSIsNull =\
  \ RHS->isNullPointerConstant(C.getASTContext(),\n                              \
  \                    Expr::NPC_ValueDependentIsNull);\n\n      const Expr *PtrE\
  \ = nullptr;\n      if (LHSIsNull && !RHSIsNull)\n        PtrE = RHS;\n      else\
  \ if (RHSIsNull && !LHSIsNull)\n        PtrE = LHS;\n\n      if (PtrE) {\n     \
  \   clearCheckedForExpr(PtrE, State, C);\n        C.addTransition(State);\n    \
  \    return;\n      }\n    }\n\n    // Pattern: if ((ptr = kzalloc(...))) treat\
  \ as checked too\n    if (BO->getOpcode() == BO_Assign) {\n      const Expr *LHS\
  \ = BO->getLHS();\n      if (LHS) {\n        clearCheckedForExpr(LHS, State, C);\n\
  \        C.addTransition(State);\n        return;\n      }\n    }\n  }\n\n  // Pattern:\
  \ if (ptr) ...\n  // Heuristically consider it a NULL-check and clear.\n  {\n  \
  \  SVal V = State->getSVal(CondE, C.getLocationContext());\n    if (V.getAs<DefinedSVal>())\
  \ {\n      clearCheckedForExpr(CondE, State, C);\n    }\n  }\n\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::reportDeref(const Expr *BaseE, const Stmt *S, CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Possible NULL dereference: unchecked result of allocation\", N);\n  if (S)\n\
  \    R->addRange(S->getSourceRange());\n  if (BaseE)\n    R->addRange(BaseE->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkLocation(SVal Loc,\
  \ bool IsLoad, const Stmt *S, CheckerContext &C) const {\n  ProgramStateRef State\
  \ = C.getState();\n  if (!S)\n    return;\n\n  // Look for ptr->field\n  if (const\
  \ auto *ME = findSpecificTypeInChildren<MemberExpr>(S)) {\n    if (ME && ME->isArrow())\
  \ {\n      const Expr *BaseE = ME->getBase();\n      if (isUncheckedPtrExpr(BaseE,\
  \ State, C)) {\n        reportDeref(BaseE, S, C);\n        return;\n      }\n  \
  \  }\n  }\n\n  // Also check if S itself is a MemberExpr\n  if (const auto *ME =\
  \ dyn_cast<MemberExpr>(S)) {\n    if (ME->isArrow()) {\n      const Expr *BaseE\
  \ = ME->getBase();\n      if (isUncheckedPtrExpr(BaseE, State, C)) {\n        reportDeref(BaseE,\
  \ S, C);\n        return;\n      }\n    }\n  }\n\n  // Look for *ptr dereference\n\
  \  if (const auto *UO = findSpecificTypeInChildren<UnaryOperator>(S)) {\n    if\
  \ (UO && UO->getOpcode() == UO_Deref) {\n      const Expr *PtrE = UO->getSubExpr();\n\
  \      if (isUncheckedPtrExpr(PtrE, State, C)) {\n        reportDeref(PtrE, S, C);\n\
  \        return;\n      }\n    }\n  }\n}\n\nvoid SAGenTestChecker::reportUncheckedArg(const\
  \ CallEvent &Call, unsigned ArgIdx,\n                                          CheckerContext\
  \ &C) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n \
  \   return;\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"\
  Unchecked possibly-NULL pointer passed to a function that dereferences it\", N);\n\
  \  R->addRange(Call.getSourceRange());\n  if (ArgIdx < Call.getNumArgs())\n    R->addRange(Call.getArgExpr(ArgIdx)->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\nvoid SAGenTestChecker::checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const {\n  llvm::SmallVector<unsigned, 4> DerefParams;\n\
  \  if (!functionKnownToDeref(Call, DerefParams))\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  for (unsigned Idx : DerefParams) {\n    if (Idx >= Call.getNumArgs())\n\
  \      continue;\n    const Expr *ArgE = Call.getArgExpr(Idx);\n    if (!ArgE)\n\
  \      continue;\n    if (isUncheckedPtrExpr(ArgE, State, C)) {\n      reportUncheckedArg(Call,\
  \ Idx, C);\n    }\n  }\n}\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects dereference of possibly-NULL pointers returned by [devm_]k[z/m/c]alloc\
  \ without NULL checks\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: -1
tp_score: 1
