_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 63ae548f1054a0b71678d0349c7dc9628ddd42ca
commit_type: Out-of-Bound
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Basic/SourceManager.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ No custom program states needed\n\nnamespace {\n\nclass SAGenTestChecker\n  :\
  \ public Checker<\n        check::PreStmt<ArraySubscriptExpr>\n    > {\n   mutable\
  \ std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\n       \
  \ : BT(new BugType(this, \"Index may exceed TRANSFER_FUNC_POINTS\", \"Array Bounds\"\
  )) {}\n\n      void checkPreStmt(const ArraySubscriptExpr *ASE, CheckerContext &C)\
  \ const;\n\n   private:\n      // Helpers\n      static bool baseIsTfPtsRGB(const\
  \ Expr *Base, CheckerContext &C);\n      static bool getIndexVarName(const Expr\
  \ *IdxE, std::string &OutName);\n      static bool stmtContains(const Stmt *Root,\
  \ const Stmt *Target);\n      static bool branchExits(const Stmt *S);\n      static\
  \ const Stmt* whichBranchContains(const IfStmt *If, const Stmt *Target);\n     \
  \ static bool condMentionsIdxAndTFP(const Expr *Cond, StringRef IdxName, CheckerContext\
  \ &C);\n      static bool hasDominatingGuard(const ArraySubscriptExpr *ASE, StringRef\
  \ IdxName, CheckerContext &C);\n};\n\nbool SAGenTestChecker::baseIsTfPtsRGB(const\
  \ Expr *Base, CheckerContext &C) {\n  if (!Base)\n    return false;\n\n  Base =\
  \ Base->IgnoreParenImpCasts();\n  if (const auto *ME1 = dyn_cast<MemberExpr>(Base))\
  \ {\n    const ValueDecl *VD1 = ME1->getMemberDecl();\n    if (!VD1)\n      return\
  \ false;\n    StringRef Name1 = VD1->getName();\n    bool IsRGB = (Name1 == \"red\"\
  \ || Name1 == \"green\" || Name1 == \"blue\");\n    if (!IsRGB)\n      return false;\n\
  \n    const Expr *B2 = ME1->getBase();\n    if (!B2)\n      return false;\n    B2\
  \ = B2->IgnoreParenImpCasts();\n\n    if (const auto *ME2 = dyn_cast<MemberExpr>(B2))\
  \ {\n      const ValueDecl *VD2 = ME2->getMemberDecl();\n      if (!VD2)\n     \
  \   return false;\n      if (VD2->getName() == \"tf_pts\")\n        return true;\n\
  \    }\n  }\n\n  // Fallback heuristic: look for textual names\n  if (ExprHasName(Base,\
  \ \"tf_pts\", C) &&\n      (ExprHasName(Base, \"red\", C) || ExprHasName(Base, \"\
  green\", C) || ExprHasName(Base, \"blue\", C))) {\n    return true;\n  }\n\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::getIndexVarName(const Expr *IdxE, std::string\
  \ &OutName) {\n  if (!IdxE)\n    return false;\n  IdxE = IdxE->IgnoreParenImpCasts();\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(IdxE)) {\n    if (const auto *VD\
  \ = dyn_cast<VarDecl>(DRE->getDecl())) {\n      OutName = VD->getName().str();\n\
  \      return true;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::stmtContains(const\
  \ Stmt *Root, const Stmt *Target) {\n  if (!Root || !Target)\n    return false;\n\
  \  if (Root == Target)\n    return true;\n  for (const Stmt *Child : Root->children())\
  \ {\n    if (Child && stmtContains(Child, Target))\n      return true;\n  }\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::branchExits(const Stmt *S) {\n  if (!S)\n\
  \    return false;\n  if (isa<ReturnStmt>(S) || isa<BreakStmt>(S))\n    return true;\n\
  \n  // Also consider 'if' branches that exit, and nested structures.\n  for (const\
  \ Stmt *Child : S->children()) {\n    if (Child && branchExits(Child))\n      return\
  \ true;\n  }\n  return false;\n}\n\n// Returns pointer to the branch (Then or Else)\
  \ that contains Target, or nullptr if neither.\nconst Stmt* SAGenTestChecker::whichBranchContains(const\
  \ IfStmt *If, const Stmt *Target) {\n  if (!If || !Target)\n    return nullptr;\n\
  \n  const Stmt *ThenS = If->getThen();\n  const Stmt *ElseS = If->getElse();\n\n\
  \  if (ThenS && stmtContains(ThenS, Target))\n    return ThenS;\n  if (ElseS &&\
  \ stmtContains(ElseS, Target))\n    return ElseS;\n\n  return nullptr;\n}\n\nbool\
  \ SAGenTestChecker::condMentionsIdxAndTFP(const Expr *Cond, StringRef IdxName, CheckerContext\
  \ &C) {\n  if (!Cond)\n    return false;\n  // Check the textual presence of both\
  \ the index variable and TRANSFER_FUNC_POINTS\n  if (!ExprHasName(Cond, IdxName,\
  \ C))\n    return false;\n  if (!ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\", C))\n\
  \    return false;\n  return true;\n}\n\nbool SAGenTestChecker::hasDominatingGuard(const\
  \ ArraySubscriptExpr *ASE, StringRef IdxName, CheckerContext &C) {\n  if (!ASE)\n\
  \    return false;\n\n  // Find the nearest enclosing compound statement\n  const\
  \ CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(ASE, C);\n  if (!CS)\n\
  \    return false;\n\n  // Find the top-level statement inside CS that contains\
  \ ASE\n  int P = -1;\n  const Stmt *TopStmt = nullptr;\n  int idx = 0;\n  for (const\
  \ Stmt *Child : CS->body()) {\n    if (!Child) { ++idx; continue; }\n    if (stmtContains(Child,\
  \ ASE)) {\n      P = idx;\n      TopStmt = Child;\n      break;\n    }\n    ++idx;\n\
  \  }\n\n  if (P == -1 || !TopStmt)\n    return false;\n\n  // Case A: The containing\
  \ top-level statement itself is an IfStmt, and it encloses the access.\n  if (const\
  \ auto *If = dyn_cast<IfStmt>(TopStmt)) {\n    // If the condition mentions index\
  \ and TRANSFER_FUNC_POINTS, and the opposite branch exits -> treated as a guard.\n\
  \    const Stmt *ContainingBranch = whichBranchContains(If, ASE);\n    if (ContainingBranch)\
  \ {\n      const Expr *Cond = If->getCond();\n      if (condMentionsIdxAndTFP(Cond,\
  \ IdxName, C)) {\n        const Stmt *OtherBranch = (ContainingBranch == If->getThen())\
  \ ? If->getElse() : If->getThen();\n        if (OtherBranch && branchExits(OtherBranch))\n\
  \          return true;\n      }\n    }\n  }\n\n  // Case B: Scan previous sibling\
  \ statements in the same compound for a guard if-statement.\n  for (int pi = P -\
  \ 1; pi >= 0; --pi) {\n    const Stmt *Prev = CS->body()[static_cast<unsigned>(pi)];\n\
  \    if (!Prev)\n      continue;\n\n    const auto *If = dyn_cast<IfStmt>(Prev);\n\
  \    if (!If)\n      continue;\n\n    const Expr *Cond = If->getCond();\n    if\
  \ (!condMentionsIdxAndTFP(Cond, IdxName, C))\n      continue;\n\n    // If either\
  \ branch exits, treat this as a guarding check.\n    const Stmt *ThenS = If->getThen();\n\
  \    const Stmt *ElseS = If->getElse();\n    if ((ThenS && branchExits(ThenS)) ||\
  \ (ElseS && branchExits(ElseS)))\n      return true;\n  }\n\n  return false;\n}\n\
  \nvoid SAGenTestChecker::checkPreStmt(const ArraySubscriptExpr *ASE, CheckerContext\
  \ &C) const {\n  if (!ASE)\n    return;\n\n  const Expr *Base = ASE->getBase();\n\
  \  if (!Base)\n    return;\n\n  // Match output_tf->tf_pts.{red,green,blue}[i]\n\
  \  if (!baseIsTfPtsRGB(Base, C))\n    return;\n\n  // Extract index variable name\n\
  \  const Expr *IdxE = ASE->getIdx();\n  std::string IdxName;\n  if (!getIndexVarName(IdxE,\
  \ IdxName))\n    return;\n\n  // Check for a dominating guard that compares index\
  \ with TRANSFER_FUNC_POINTS and exits\n  if (hasDominatingGuard(ASE, IdxName, C))\n\
  \    return;\n\n  // No guard found: report potential OOB\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto Report = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Index may exceed TRANSFER_FUNC_POINTS when indexing LUT array\", N);\n\
  \  SourceRange R = ASE->getSourceRange();\n  Report->addRange(R);\n  C.emitReport(std::move(Report));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects LUT array indexing without validating index against TRANSFER_FUNC_POINTS\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\ndrm/amd/display: Fix potential index out of bounds\
  \ in color transformation function\n\nFixes index out of bounds issue in the color\
  \ transformation function.\nThe issue could occur when the index 'i' exceeds the\
  \ number of transfer\nfunction points (TRANSFER_FUNC_POINTS).\n\nThe fix adds a\
  \ check to ensure 'i' is within bounds before accessing the\ntransfer function points.\
  \ If 'i' is out of bounds, an error message is\nlogged and the function returns\
  \ false to indicate an error.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:405\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.red'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:406\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.green'\
  \ 1025 <= s32max\ndrivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_cm_common.c:407\
  \ cm_helper_translate_curve_to_hw_format() error: buffer overflow 'output_tf->tf_pts.blue'\
  \ 1025 <= s32max\n\nFixes: b629596072e5 (\"drm/amd/display: Build unity lut for\
  \ shaper\")\nCc: Vitaly Prosyak <vitaly.prosyak@amd.com>\nCc: Charlene Liu <Charlene.Liu@amd.com>\n\
  Cc: Harry Wentland <harry.wentland@amd.com>\nCc: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>\n\
  Cc: Roman Li <roman.li@amd.com>\nCc: Aurabindo Pillai <aurabindo.pillai@amd.com>\n\
  Cc: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Srinivasan Shanmugam <srinivasan.shanmugam@amd.com>\n\
  Reviewed-by: Tom Chung <chiahsuan.chung@amd.com>\nSigned-off-by: Alex Deucher <alexander.deucher@amd.com>\n\
  \n## Buggy Code\n\n```c\n// Function: cm_helper_translate_curve_to_hw_format in\
  \ drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nbool cm_helper_translate_curve_to_hw_format(struct\
  \ dc_context *ctx,\n\t\t\t\tconst struct dc_transfer_func *output_tf,\n\t\t\t\t\
  struct pwl_params *lut_params, bool fixpoint)\n{\n\tstruct curve_points3 *corner_points;\n\
  \tstruct pwl_result_data *rgb_resulted;\n\tstruct pwl_result_data *rgb;\n\tstruct\
  \ pwl_result_data *rgb_plus_1;\n\tstruct pwl_result_data *rgb_minus_1;\n\n\tint32_t\
  \ region_start, region_end;\n\tint32_t i;\n\tuint32_t j, k, seg_distr[MAX_REGIONS_NUMBER],\
  \ increment, start_index, hw_points;\n\n\tif (output_tf == NULL || lut_params ==\
  \ NULL || output_tf->type == TF_TYPE_BYPASS)\n\t\treturn false;\n\n\tcorner_points\
  \ = lut_params->corner_points;\n\trgb_resulted = lut_params->rgb_resulted;\n\thw_points\
  \ = 0;\n\n\tmemset(lut_params, 0, sizeof(struct pwl_params));\n\tmemset(seg_distr,\
  \ 0, sizeof(seg_distr));\n\n\tif (output_tf->tf == TRANSFER_FUNCTION_PQ || output_tf->tf\
  \ == TRANSFER_FUNCTION_GAMMA22) {\n\t\t/* 32 segments\n\t\t * segments are from\
  \ 2^-25 to 2^7\n\t\t */\n\t\tfor (i = 0; i < NUMBER_REGIONS ; i++)\n\t\t\tseg_distr[i]\
  \ = 3;\n\n\t\tregion_start = -MAX_LOW_POINT;\n\t\tregion_end   = NUMBER_REGIONS\
  \ - MAX_LOW_POINT;\n\t} else {\n\t\t/* 11 segments\n\t\t * segment is from 2^-10\
  \ to 2^1\n\t\t * There are less than 256 points, for optimization\n\t\t */\n\t\t\
  seg_distr[0] = 3;\n\t\tseg_distr[1] = 4;\n\t\tseg_distr[2] = 4;\n\t\tseg_distr[3]\
  \ = 4;\n\t\tseg_distr[4] = 4;\n\t\tseg_distr[5] = 4;\n\t\tseg_distr[6] = 4;\n\t\t\
  seg_distr[7] = 4;\n\t\tseg_distr[8] = 4;\n\t\tseg_distr[9] = 4;\n\t\tseg_distr[10]\
  \ = 1;\n\n\t\tregion_start = -10;\n\t\tregion_end = 1;\n\t}\n\n\tfor (i = region_end\
  \ - region_start; i < MAX_REGIONS_NUMBER ; i++)\n\t\tseg_distr[i] = -1;\n\n\tfor\
  \ (k = 0; k < MAX_REGIONS_NUMBER; k++) {\n\t\tif (seg_distr[k] != -1)\n\t\t\thw_points\
  \ += (1 << seg_distr[k]);\n\t}\n\n\tj = 0;\n\tfor (k = 0; k < (region_end - region_start);\
  \ k++) {\n\t\tincrement = NUMBER_SW_SEGMENTS / (1 << seg_distr[k]);\n\t\tstart_index\
  \ = (region_start + k + MAX_LOW_POINT) *\n\t\t\t\tNUMBER_SW_SEGMENTS;\n\t\tfor (i\
  \ = start_index; i < start_index + NUMBER_SW_SEGMENTS;\n\t\t\t\ti += increment)\
  \ {\n\t\t\tif (j == hw_points - 1)\n\t\t\t\tbreak;\n\t\t\trgb_resulted[j].red =\
  \ output_tf->tf_pts.red[i];\n\t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n\
  \t\t\trgb_resulted[j].blue = output_tf->tf_pts.blue[i];\n\t\t\tj++;\n\t\t}\n\t}\n\
  \n\t/* last point */\n\tstart_index = (region_end + MAX_LOW_POINT) * NUMBER_SW_SEGMENTS;\n\
  \trgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];\n\trgb_resulted[hw_points\
  \ - 1].green = output_tf->tf_pts.green[start_index];\n\trgb_resulted[hw_points -\
  \ 1].blue = output_tf->tf_pts.blue[start_index];\n\n\trgb_resulted[hw_points].red\
  \ = rgb_resulted[hw_points - 1].red;\n\trgb_resulted[hw_points].green = rgb_resulted[hw_points\
  \ - 1].green;\n\trgb_resulted[hw_points].blue = rgb_resulted[hw_points - 1].blue;\n\
  \n\t// All 3 color channels have same x\n\tcorner_points[0].red.x = dc_fixpt_pow(dc_fixpt_from_int(2),\n\
  \t\t\t\t\t     dc_fixpt_from_int(region_start));\n\tcorner_points[0].green.x = corner_points[0].red.x;\n\
  \tcorner_points[0].blue.x = corner_points[0].red.x;\n\n\tcorner_points[1].red.x\
  \ = dc_fixpt_pow(dc_fixpt_from_int(2),\n\t\t\t\t\t     dc_fixpt_from_int(region_end));\n\
  \tcorner_points[1].green.x = corner_points[1].red.x;\n\tcorner_points[1].blue.x\
  \ = corner_points[1].red.x;\n\n\tcorner_points[0].red.y = rgb_resulted[0].red;\n\
  \tcorner_points[0].green.y = rgb_resulted[0].green;\n\tcorner_points[0].blue.y =\
  \ rgb_resulted[0].blue;\n\n\tcorner_points[0].red.slope = dc_fixpt_div(corner_points[0].red.y,\n\
  \t\t\tcorner_points[0].red.x);\n\tcorner_points[0].green.slope = dc_fixpt_div(corner_points[0].green.y,\n\
  \t\t\tcorner_points[0].green.x);\n\tcorner_points[0].blue.slope = dc_fixpt_div(corner_points[0].blue.y,\n\
  \t\t\tcorner_points[0].blue.x);\n\n\t/* see comment above, m_arrPoints[1].y should\
  \ be the Y value for the\n\t * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints\
  \ - 1)\n\t */\n\tcorner_points[1].red.y = rgb_resulted[hw_points - 1].red;\n\tcorner_points[1].green.y\
  \ = rgb_resulted[hw_points - 1].green;\n\tcorner_points[1].blue.y = rgb_resulted[hw_points\
  \ - 1].blue;\n\tcorner_points[1].red.slope = dc_fixpt_zero;\n\tcorner_points[1].green.slope\
  \ = dc_fixpt_zero;\n\tcorner_points[1].blue.slope = dc_fixpt_zero;\n\n\tif (output_tf->tf\
  \ == TRANSFER_FUNCTION_PQ) {\n\t\t/* for PQ, we want to have a straight line from\
  \ last HW X point,\n\t\t * and the slope to be such that we hit 1.0 at 10000 nits.\n\
  \t\t */\n\t\tconst struct fixed31_32 end_value =\n\t\t\t\tdc_fixpt_from_int(125);\n\
  \n\t\tcorner_points[1].red.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].red.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].red.x));\n\
  \t\tcorner_points[1].green.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].green.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].green.x));\n\
  \t\tcorner_points[1].blue.slope = dc_fixpt_div(\n\t\t\tdc_fixpt_sub(dc_fixpt_one,\
  \ corner_points[1].blue.y),\n\t\t\tdc_fixpt_sub(end_value, corner_points[1].blue.x));\n\
  \t}\n\n\tlut_params->hw_points_num = hw_points;\n\n\tk = 0;\n\tfor (i = 1; i < MAX_REGIONS_NUMBER;\
  \ i++) {\n\t\tif (seg_distr[k] != -1) {\n\t\t\tlut_params->arr_curve_points[k].segments_num\
  \ =\n\t\t\t\t\tseg_distr[k];\n\t\t\tlut_params->arr_curve_points[i].offset =\n\t\
  \t\t\t\tlut_params->arr_curve_points[k].offset + (1 << seg_distr[k]);\n\t\t}\n\t\
  \tk++;\n\t}\n\n\tif (seg_distr[k] != -1)\n\t\tlut_params->arr_curve_points[k].segments_num\
  \ = seg_distr[k];\n\n\trgb = rgb_resulted;\n\trgb_plus_1 = rgb_resulted + 1;\n\t\
  rgb_minus_1 = rgb;\n\n\ti = 1;\n\twhile (i != hw_points + 1) {\n\n\t\tif (i >= hw_points\
  \ - 1) {\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->red, rgb->red))\n\t\t\t\trgb_plus_1->red\
  \ = dc_fixpt_add(rgb->red, rgb_minus_1->delta_red);\n\t\t\tif (dc_fixpt_lt(rgb_plus_1->green,\
  \ rgb->green))\n\t\t\t\trgb_plus_1->green = dc_fixpt_add(rgb->green, rgb_minus_1->delta_green);\n\
  \t\t\tif (dc_fixpt_lt(rgb_plus_1->blue, rgb->blue))\n\t\t\t\trgb_plus_1->blue =\
  \ dc_fixpt_add(rgb->blue, rgb_minus_1->delta_blue);\n\t\t}\n\n\t\trgb->delta_red\
  \   = dc_fixpt_sub(rgb_plus_1->red,   rgb->red);\n\t\trgb->delta_green = dc_fixpt_sub(rgb_plus_1->green,\
  \ rgb->green);\n\t\trgb->delta_blue  = dc_fixpt_sub(rgb_plus_1->blue,  rgb->blue);\n\
  \n\n\t\tif (fixpoint == true) {\n\t\t\tuint32_t red_clamp = dc_fixpt_clamp_u0d14(rgb->delta_red);\n\
  \t\t\tuint32_t green_clamp = dc_fixpt_clamp_u0d14(rgb->delta_green);\n\t\t\tuint32_t\
  \ blue_clamp = dc_fixpt_clamp_u0d14(rgb->delta_blue);\n\n\t\t\tif (red_clamp >>\
  \ 10 || green_clamp >> 10 || blue_clamp >> 10)\n\t\t\t\tDC_LOG_WARNING(\"Losing\
  \ delta precision while programming shaper LUT.\");\n\n\t\t\trgb->delta_red_reg\
  \   = red_clamp & 0x3ff;\n\t\t\trgb->delta_green_reg = green_clamp & 0x3ff;\n\t\t\
  \trgb->delta_blue_reg  = blue_clamp & 0x3ff;\n\t\t\trgb->red_reg         = dc_fixpt_clamp_u0d14(rgb->red);\n\
  \t\t\trgb->green_reg       = dc_fixpt_clamp_u0d14(rgb->green);\n\t\t\trgb->blue_reg\
  \        = dc_fixpt_clamp_u0d14(rgb->blue);\n\t\t}\n\n\t\t++rgb_plus_1;\n\t\trgb_minus_1\
  \ = rgb;\n\t\t++rgb;\n\t\t++i;\n\t}\n\tcm_helper_convert_to_custom_float(rgb_resulted,\n\
  \t\t\t\t\t\tlut_params->corner_points,\n\t\t\t\t\t\thw_points, fixpoint);\n\n\t\
  return true;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\
  \ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\nindex b7e57aa27361..b0d192c6e63e\
  \ 100644\n--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_cm_common.c\n\
  @@ -402,6 +402,11 @@ bool cm_helper_translate_curve_to_hw_format(struct dc_context\
  \ *ctx,\n \t\t\t\ti += increment) {\n \t\t\tif (j == hw_points - 1)\n \t\t\t\tbreak;\n\
  +\t\t\tif (i >= TRANSFER_FUNC_POINTS) {\n+\t\t\t\tDC_LOG_ERROR(\"Index out of bounds:\
  \ i=%d, TRANSFER_FUNC_POINTS=%d\\n\",\n+\t\t\t\t\t     i, TRANSFER_FUNC_POINTS);\n\
  +\t\t\t\treturn false;\n+\t\t\t}\n \t\t\trgb_resulted[j].red = output_tf->tf_pts.red[i];\n\
  \ \t\t\trgb_resulted[j].green = output_tf->tf_pts.green[i];\n \t\t\trgb_resulted[j].blue\
  \ = output_tf->tf_pts.blue[i];\n```\n"
pattern: "## Bug Pattern\n\nIndexing fixed-size LUT arrays with an algorithmically\
  \ computed index without validating it against the array\u2019s maximum size:\n\
  - Accesses like `output_tf->tf_pts.{red,green,blue}[i]` use an `i` derived from\
  \ region/segment math (`start_index`, `increment`) but do not check `i < TRANSFER_FUNC_POINTS`.\n\
  - This can drive `i` beyond the valid range (e.g., for large `start_index` or step\
  \ rounding), causing out-of-bounds reads from the `tf_pts` arrays."
plan: "Plan to detect \u201Calgorithmically computed index not validated against TRANSFER_FUNC_POINTS\u201D\
  \ in LUT array accesses\n\n1. Program state\n- No custom program state is required.\
  \ This checker can be implemented as a syntactic-plus-local-structural analysis\
  \ around array subscripts.\n\n2. Callbacks and high-level flow\n- checkPreStmt(const\
  \ ArraySubscriptExpr *ASE, CheckerContext &C) const\n  - Core detection happens\
  \ here. We:\n    - Identify accesses to the fixed-size LUT arrays tf_pts.{red,green,blue}[i].\n\
  \    - Extract the index expression and its variable name (e.g., \u201Ci\u201D).\n\
  \    - Search for a dominating guard in the nearest enclosing compound statement\
  \ that checks the index against TRANSFER_FUNC_POINTS and exits the path (e.g., return/break)\
  \ when it is out of bounds.\n    - If no such guard is found, emit a bug report.\n\
  \n3. Detailed implementation per callback\n\n- checkPreStmt(const ArraySubscriptExpr\
  \ *ASE, CheckerContext &C)\n  1) Filter to target LUT arrays:\n     - Get the base\
  \ expression: const Expr *Base = ASE->getBase()->IgnoreParenImpCasts().\n     -\
  \ Ensure it is indexing one of tf_pts.{red,green,blue}:\n       - Prefer structural\
  \ check:\n         - Try dyn_cast<MemberExpr>(Base). If success, inspect the field\
  \ name (getMemberDecl()->getName()) and check if it is one of \"red\", \"green\"\
  , \"blue\".\n         - For the base of that MemberExpr, dyn_cast<MemberExpr> again\
  \ and check that inner member name is \"tf_pts\".\n       - As a fallback/heuristic\
  \ (to be robust against implicit casts or macro text), accept Base if:\n       \
  \  - ExprHasName(Base, \"tf_pts\") AND (ExprHasName(Base, \"red\") OR \"green\"\
  \ OR \"blue\").\n     - If neither structural nor heuristic checks match, return.\n\
  \n  2) Extract the index variable name:\n     - const Expr *IdxE = ASE->getIdx()->IgnoreParenImpCasts().\n\
  \     - If IdxE is a DeclRefExpr to a VarDecl, capture the variable name as StringRef\
  \ IdxName = VD->getName().\n     - If IdxE is not a simple variable (e.g., complex\
  \ expression), you can still attempt a heuristic by pulling the source text via\
  \ ExprHasName and searching for an identifier, but to keep it simple and precise,\
  \ only proceed when IdxE is a DeclRefExpr.\n\n  3) Find a dominating bounds check\
  \ against TRANSFER_FUNC_POINTS:\n     - Find the nearest enclosing CompoundStmt\
  \ of ASE:\n       - const CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(ASE,\
  \ C).\n       - If no CompoundStmt is found, report (conservative) or simply return;\
  \ prefer to return to avoid false positives.\n     - Within CS, determine the \u201C\
  containing\u201D top-level statement that has ASE somewhere in its subtree:\n  \
  \     - Iterate for (Stmt *Child : CS->body()) and find the first Child that contains\
  \ ASE in its subtree (you can do a small DFS walk from Child to see if ASE pointer\
  \ is found).\n       - Record the index position P of that Child in the compound\u2019\
  s sequence.\n     - Scan all statements before P (from P-1 down to 0) to find a\
  \ guard IfStmt:\n       - For each previous Stmt Prev:\n         - IfStmt *If =\
  \ dyn_cast<IfStmt>(Prev); if not, continue.\n         - const Expr *Cond = If->getCond();\n\
  \         - Check that Cond mentions both the index name and TRANSFER_FUNC_POINTS:\n\
  \           - ExprHasName(Cond, IdxName) AND ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\"\
  ).\n         - Additionally, confirm that the \u201Cguard\u201D branch exits the\
  \ current flow:\n           - Define a helper bool branchExits(const Stmt *S) that\
  \ recursively searches for a ReturnStmt or BreakStmt within S (any depth).\n   \
  \        - Treat as valid guard if branchExits(If->getThen()) is true OR branchExits(If->getElse())\
  \ is true.\n             - This covers both common styles:\n               - if\
  \ (i >= TRANSFER_FUNC_POINTS) return/break;\n               - if (i < TRANSFER_FUNC_POINTS)\
  \ { \u2026 use array \u2026 } else return/break;\n         - If such a guard is\
  \ found, consider the access protected and stop checking.\n     - If no guard is\
  \ found, report a potential out-of-bounds index.\n\n  4) Emit a report:\n     -\
  \ Create a non-fatal error node with C.generateNonFatalErrorNode().\n     - Use\
  \ a PathSensitiveBugReport with a short message, e.g.:\n       - \u201CIndex may\
  \ exceed TRANSFER_FUNC_POINTS when indexing LUT array.\u201D\n     - Attach the\
  \ ArraySubscriptExpr as the location using addRange(ASE->getSourceRange()) and/or\
  \ mark the array access as the interesting location.\n\n4. Auxiliary helpers to\
  \ implement\n- baseIsTfPtsRGB(const Expr *Base):\n  - Structural approach with MemberExpr\
  \ chain for \".tf_pts.(red|green|blue)\".\n  - Fallback heuristic using ExprHasName(Base,\
  \ \"tf_pts\") and one of channel names.\n\n- getIndexVarName(const Expr *IdxE, StringRef\
  \ &Out):\n  - If DeclRefExpr to VarDecl, set Out = VD->getName() and return true;\
  \ otherwise return false.\n\n- stmtContains(const Stmt *Root, const Stmt *Target):\n\
  \  - Small DFS to determine if Target pointer appears somewhere under Root.\n\n\
  - branchExits(const Stmt *S):\n  - DFS over S to see if a ReturnStmt or BreakStmt\
  \ exists.\n\n- hasDominatingGuard(const Stmt *UseSite, StringRef IdxName, CheckerContext\
  \ &C):\n  - Implements the CompoundStmt scan logic described above.\n\n5. Notes\
  \ and constraints\n- This checker intentionally focuses on the LUT arrays under\
  \ tf_pts and TRANSFER_FUNC_POINTS. It is tuned to the exact bug pattern in the patch:\n\
  \  - Accesses to output_tf->tf_pts.{red,green,blue}[i] created by algorithmic computation\
  \ of i.\n  - Missing explicit guard against TRANSFER_FUNC_POINTS before the access.\n\
  - Heuristic-based detection is used (identifier names and presence of return/break\
  \ in the guard), which keeps the checker simple and practically useful while avoiding\
  \ path-sensitive state machinery.\n- We do not rely on constant folding of TRANSFER_FUNC_POINTS;\
  \ we only require that the condition mentions the macro name (via ExprHasName(...,\
  \ \"TRANSFER_FUNC_POINTS\")).\n- We do not maintain alias/taint maps or track index\
  \ constraints; the goal is to enforce an explicit bounds check pattern around the\
  \ access for this specific LUT case.\n\n6. Callback summary\n- checkPreStmt(ArraySubscriptExpr):\n\
  \  - Detect target base tf_pts.{red,green,blue}.\n  - Extract index var name.\n\
  \  - Search for dominating guard comparing index with TRANSFER_FUNC_POINTS and exiting.\n\
  \  - If absent, report.\n\nThis plan uses the simplest effective approach, avoids\
  \ custom program state, and directly targets the missing-guard bug pattern demonstrated\
  \ in the provided patch."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Basic/SourceManager.h\"\
  \n#include \"llvm/ADT/SmallVector.h\"\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// No custom program states needed\n\nnamespace\
  \ {\n\nclass SAGenTestChecker\n  : public Checker<\n        check::PreStmt<ArraySubscriptExpr>\n\
  \    > {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\n\
  \        : BT(new BugType(this, \"Index may exceed TRANSFER_FUNC_POINTS\", \"Array\
  \ Bounds\")) {}\n\n      void checkPreStmt(const ArraySubscriptExpr *ASE, CheckerContext\
  \ &C) const;\n\n   private:\n      // Helpers\n      static bool baseIsTfPtsRGB(const\
  \ Expr *Base, CheckerContext &C);\n      static bool getIndexVarName(const Expr\
  \ *IdxE, std::string &OutName);\n      static bool stmtContains(const Stmt *Root,\
  \ const Stmt *Target);\n      static bool branchExits(const Stmt *S);\n      static\
  \ const Stmt* whichBranchContains(const IfStmt *If, const Stmt *Target);\n     \
  \ static bool condMentionsIdxAndTFP(const Expr *Cond, StringRef IdxName, CheckerContext\
  \ &C);\n      static bool hasDominatingGuard(const ArraySubscriptExpr *ASE, StringRef\
  \ IdxName, CheckerContext &C);\n};\n\nbool SAGenTestChecker::baseIsTfPtsRGB(const\
  \ Expr *Base, CheckerContext &C) {\n  if (!Base)\n    return false;\n\n  Base =\
  \ Base->IgnoreParenImpCasts();\n  if (const auto *ME1 = dyn_cast<MemberExpr>(Base))\
  \ {\n    const ValueDecl *VD1 = ME1->getMemberDecl();\n    if (!VD1)\n      return\
  \ false;\n    StringRef Name1 = VD1->getName();\n    bool IsRGB = (Name1 == \"red\"\
  \ || Name1 == \"green\" || Name1 == \"blue\");\n    if (!IsRGB)\n      return false;\n\
  \n    const Expr *B2 = ME1->getBase();\n    if (!B2)\n      return false;\n    B2\
  \ = B2->IgnoreParenImpCasts();\n\n    if (const auto *ME2 = dyn_cast<MemberExpr>(B2))\
  \ {\n      const ValueDecl *VD2 = ME2->getMemberDecl();\n      if (!VD2)\n     \
  \   return false;\n      if (VD2->getName() == \"tf_pts\")\n        return true;\n\
  \    }\n  }\n\n  // Fallback heuristic: look for textual names\n  if (ExprHasName(Base,\
  \ \"tf_pts\", C) &&\n      (ExprHasName(Base, \"red\", C) || ExprHasName(Base, \"\
  green\", C) || ExprHasName(Base, \"blue\", C))) {\n    return true;\n  }\n\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::getIndexVarName(const Expr *IdxE, std::string\
  \ &OutName) {\n  if (!IdxE)\n    return false;\n  IdxE = IdxE->IgnoreParenImpCasts();\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(IdxE)) {\n    if (const auto *VD\
  \ = dyn_cast<VarDecl>(DRE->getDecl())) {\n      OutName = VD->getName().str();\n\
  \      return true;\n    }\n  }\n  return false;\n}\n\nbool SAGenTestChecker::stmtContains(const\
  \ Stmt *Root, const Stmt *Target) {\n  if (!Root || !Target)\n    return false;\n\
  \  if (Root == Target)\n    return true;\n  for (const Stmt *Child : Root->children())\
  \ {\n    if (Child && stmtContains(Child, Target))\n      return true;\n  }\n  return\
  \ false;\n}\n\nbool SAGenTestChecker::branchExits(const Stmt *S) {\n  if (!S)\n\
  \    return false;\n  if (isa<ReturnStmt>(S) || isa<BreakStmt>(S))\n    return true;\n\
  \n  // Also consider 'if' branches that exit, and nested structures.\n  for (const\
  \ Stmt *Child : S->children()) {\n    if (Child && branchExits(Child))\n      return\
  \ true;\n  }\n  return false;\n}\n\n// Returns pointer to the branch (Then or Else)\
  \ that contains Target, or nullptr if neither.\nconst Stmt* SAGenTestChecker::whichBranchContains(const\
  \ IfStmt *If, const Stmt *Target) {\n  if (!If || !Target)\n    return nullptr;\n\
  \n  const Stmt *ThenS = If->getThen();\n  const Stmt *ElseS = If->getElse();\n\n\
  \  if (ThenS && stmtContains(ThenS, Target))\n    return ThenS;\n  if (ElseS &&\
  \ stmtContains(ElseS, Target))\n    return ElseS;\n\n  return nullptr;\n}\n\nbool\
  \ SAGenTestChecker::condMentionsIdxAndTFP(const Expr *Cond, StringRef IdxName, CheckerContext\
  \ &C) {\n  if (!Cond)\n    return false;\n  // Check the textual presence of both\
  \ the index variable and TRANSFER_FUNC_POINTS\n  if (!ExprHasName(Cond, IdxName,\
  \ C))\n    return false;\n  if (!ExprHasName(Cond, \"TRANSFER_FUNC_POINTS\", C))\n\
  \    return false;\n  return true;\n}\n\nbool SAGenTestChecker::hasDominatingGuard(const\
  \ ArraySubscriptExpr *ASE, StringRef IdxName, CheckerContext &C) {\n  if (!ASE)\n\
  \    return false;\n\n  // Find the nearest enclosing compound statement\n  const\
  \ CompoundStmt *CS = findSpecificTypeInParents<CompoundStmt>(ASE, C);\n  if (!CS)\n\
  \    return false;\n\n  // Materialize the body statements into an indexable container.\n\
  \  llvm::SmallVector<const Stmt *, 16> BodyStmts;\n  for (const Stmt *S : CS->body())\n\
  \    BodyStmts.push_back(S);\n\n  // Find the top-level statement inside CS that\
  \ contains ASE\n  int P = -1;\n  const Stmt *TopStmt = nullptr;\n  for (size_t i\
  \ = 0; i < BodyStmts.size(); ++i) {\n    const Stmt *Child = BodyStmts[i];\n   \
  \ if (!Child)\n      continue;\n    if (stmtContains(Child, ASE)) {\n      P = static_cast<int>(i);\n\
  \      TopStmt = Child;\n      break;\n    }\n  }\n\n  if (P == -1 || !TopStmt)\n\
  \    return false;\n\n  // Case A: The containing top-level statement itself is\
  \ an IfStmt, and it encloses the access.\n  if (const auto *If = dyn_cast<IfStmt>(TopStmt))\
  \ {\n    // If the condition mentions index and TRANSFER_FUNC_POINTS, and the opposite\
  \ branch exits -> treated as a guard.\n    const Stmt *ContainingBranch = whichBranchContains(If,\
  \ ASE);\n    if (ContainingBranch) {\n      const Expr *Cond = If->getCond();\n\
  \      if (condMentionsIdxAndTFP(Cond, IdxName, C)) {\n        const Stmt *OtherBranch\
  \ = (ContainingBranch == If->getThen()) ? If->getElse() : If->getThen();\n     \
  \   if (OtherBranch && branchExits(OtherBranch))\n          return true;\n     \
  \ }\n    }\n  }\n\n  // Case B: Scan previous sibling statements in the same compound\
  \ for a guard if-statement.\n  for (int pi = P - 1; pi >= 0; --pi) {\n    const\
  \ Stmt *Prev = BodyStmts[static_cast<size_t>(pi)];\n    if (!Prev)\n      continue;\n\
  \n    const auto *If = dyn_cast<IfStmt>(Prev);\n    if (!If)\n      continue;\n\n\
  \    const Expr *Cond = If->getCond();\n    if (!condMentionsIdxAndTFP(Cond, IdxName,\
  \ C))\n      continue;\n\n    // If either branch exits, treat this as a guarding\
  \ check.\n    const Stmt *ThenS = If->getThen();\n    const Stmt *ElseS = If->getElse();\n\
  \    if ((ThenS && branchExits(ThenS)) || (ElseS && branchExits(ElseS)))\n     \
  \ return true;\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreStmt(const\
  \ ArraySubscriptExpr *ASE, CheckerContext &C) const {\n  if (!ASE)\n    return;\n\
  \n  const Expr *Base = ASE->getBase();\n  if (!Base)\n    return;\n\n  // Match\
  \ output_tf->tf_pts.{red,green,blue}[i]\n  if (!baseIsTfPtsRGB(Base, C))\n    return;\n\
  \n  // Extract index variable name\n  const Expr *IdxE = ASE->getIdx();\n  std::string\
  \ IdxName;\n  if (!getIndexVarName(IdxE, IdxName))\n    return;\n\n  // Check for\
  \ a dominating guard that compares index with TRANSFER_FUNC_POINTS and exits\n \
  \ if (hasDominatingGuard(ASE, IdxName, C))\n    return;\n\n  // No guard found:\
  \ report potential OOB\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if\
  \ (!N)\n    return;\n\n  auto Report = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Index may exceed TRANSFER_FUNC_POINTS when indexing LUT array\", N);\n\
  \  SourceRange R = ASE->getSourceRange();\n  Report->addRange(R);\n  C.emitReport(std::move(Report));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects LUT array indexing without validating index against TRANSFER_FUNC_POINTS\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
