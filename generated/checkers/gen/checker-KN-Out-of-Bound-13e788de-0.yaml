_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 13e788deb7348cc88df34bed736c3b3b9927ea52
commit_type: Out-of-Bound
index: 0
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ParentMapContext.h\"\n#include \"clang/Lex/Lexer.h\"\n\n\
  using namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom\
  \ program states needed.\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::BranchCondition>\
  \ {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n \
  \     : BT(new BugType(this, \"Off-by-one bound check\", \"Logic\")) {}\n\n  void\
  \ checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\nprivate:\n\
  \  bool looksLikeMaxBound(const Expr *E, CheckerContext &C) const;\n  bool isEarlyReturnInThen(const\
  \ IfStmt *IS) const;\n};\n\nbool SAGenTestChecker::looksLikeMaxBound(const Expr\
  \ *E,\n                                         CheckerContext &C) const {\n  if\
  \ (!E)\n    return false;\n\n  // If the expression source contains \"MAX\", we\
  \ consider it a bound-like expr.\n  if (ExprHasName(E, \"MAX\", C))\n    return\
  \ true;\n\n  // If it's a DeclRefExpr whose name contains \"MAX\", accept it.\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenCasts())) {\n    if\
  \ (const auto *II = DRE->getDecl()->getIdentifier()) {\n      if (II->getName().contains(\"\
  MAX\"))\n        return true;\n    }\n  }\n\n  // Alternatively, if it folds to\
  \ an integer constant, also accept.\n  llvm::APSInt Dummy;\n  if (EvaluateExprToInt(Dummy,\
  \ E, C))\n    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::isEarlyReturnInThen(const\
  \ IfStmt *IS) const {\n  if (!IS)\n    return false;\n  const Stmt *ThenS = IS->getThen();\n\
  \  if (!ThenS)\n    return false;\n\n  // Look for a ReturnStmt somewhere in the\
  \ Then branch.\n  const ReturnStmt *RS = findSpecificTypeInChildren<ReturnStmt>(ThenS);\n\
  \  return RS != nullptr;\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition,\n                                            CheckerContext &C)\
  \ const {\n  if (!Condition)\n    return;\n\n  // Only consider If conditions.\n\
  \  const IfStmt *IS = findSpecificTypeInParents<IfStmt>(Condition, C);\n  if (!IS)\n\
  \    return;\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n\
  \    return;\n\n  CondE = CondE->IgnoreParenImpCasts();\n\n  // We only consider\
  \ simple relational comparisons.\n  const auto *BO = dyn_cast<BinaryOperator>(CondE);\n\
  \  if (!BO)\n    return;\n\n  BinaryOperator::Opcode Op = BO->getOpcode();\n  if\
  \ (Op != BO_GT && Op != BO_LT)\n    return;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \  const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n  // Normalize to \"Var\
  \ > Bound\".\n  const Expr *VarExpr = nullptr;\n  const Expr *BoundExpr = nullptr;\n\
  \  if (Op == BO_GT) {\n    VarExpr = LHS;\n    BoundExpr = RHS;\n  } else if (Op\
  \ == BO_LT) {\n    // \"A < B\" is equivalent to \"B > A\".\n    VarExpr = RHS;\n\
  \    BoundExpr = LHS;\n  }\n\n  if (!VarExpr || !BoundExpr)\n    return;\n\n  //\
  \ Bound should look like a MAX-like constant or fold to an int.\n  if (!looksLikeMaxBound(BoundExpr,\
  \ C))\n    return;\n\n  // The Then branch should look like an error path with early\
  \ return.\n  if (!isEarlyReturnInThen(IS))\n    return;\n\n  // Skip degenerate\
  \ cases like \"5 > MAX\".\n  if (isa<IntegerLiteral>(VarExpr))\n    return;\n\n\
  \  // Report the likely off-by-one check.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Off-by-one bound check: use '>= MAX' instead of '> MAX' for\
  \ index validation\",\n      N);\n  R->addRange(Condition->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects off-by-one index validation\
  \ using '>' instead of '>=' against MAX-like bounds\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nnet/rds: Fix UBSAN: array-index-out-of-bounds in rds_cmsg_recv\n\
  \nSyzcaller UBSAN crash occurs in rds_cmsg_recv(),\nwhich reads inc->i_rx_lat_trace[j\
  \ + 1] with index 4 (3 + 1),\nbut with array size of 4 (RDS_RX_MAX_TRACES).\nHere\
  \ 'j' is assigned from rs->rs_rx_trace[i] and in-turn from\ntrace.rx_trace_pos[i]\
  \ in rds_recv_track_latency(),\nwith both arrays sized 3 (RDS_MSG_RX_DGRAM_TRACE_MAX).\
  \ So fix the\noff-by-one bounds check in rds_recv_track_latency() to prevent\na\
  \ potential crash in rds_cmsg_recv().\n\nFound by syzcaller:\n=================================================================\n\
  UBSAN: array-index-out-of-bounds in net/rds/recv.c:585:39\nindex 4 is out of range\
  \ for type 'u64 [4]'\nCPU: 1 PID: 8058 Comm: syz-executor228 Not tainted 6.6.0-gd2f51b3516da\
  \ #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996),\nBIOS 1.15.0-1 04/01/2014\n\
  Call Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x136/0x150\
  \ lib/dump_stack.c:106\n ubsan_epilogue lib/ubsan.c:217 [inline]\n __ubsan_handle_out_of_bounds+0xd5/0x130\
  \ lib/ubsan.c:348\n rds_cmsg_recv+0x60d/0x700 net/rds/recv.c:585\n rds_recvmsg+0x3fb/0x1610\
  \ net/rds/recv.c:716\n sock_recvmsg_nosec net/socket.c:1044 [inline]\n sock_recvmsg+0xe2/0x160\
  \ net/socket.c:1066\n __sys_recvfrom+0x1b6/0x2f0 net/socket.c:2246\n __do_sys_recvfrom\
  \ net/socket.c:2264 [inline]\n __se_sys_recvfrom net/socket.c:2260 [inline]\n __x64_sys_recvfrom+0xe0/0x1b0\
  \ net/socket.c:2260\n do_syscall_x64 arch/x86/entry/common.c:51 [inline]\n do_syscall_64+0x40/0x110\
  \ arch/x86/entry/common.c:82\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n==================================================================\n\
  \nFixes: 3289025aedc0 (\"RDS: add receive message trace used by application\")\n\
  Reported-by: Chenyuan Yang <chenyuan0y@gmail.com>\nCloses: https://lore.kernel.org/linux-rdma/CALGdzuoVdq-wtQ4Az9iottBqC5cv9ZhcE5q8N7LfYFvkRsOVcw@mail.gmail.com/\n\
  Signed-off-by: Sharath Srinivasan <sharath.srinivasan@oracle.com>\nReviewed-by:\
  \ Simon Horman <horms@kernel.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n\
  \n## Buggy Code\n\n```c\n// Function: rds_recv_track_latency in net/rds/af_rds.c\n\
  static int rds_recv_track_latency(struct rds_sock *rs, sockptr_t optval,\n\t\t\t\
  \t  int optlen)\n{\n\tstruct rds_rx_trace_so trace;\n\tint i;\n\n\tif (optlen !=\
  \ sizeof(struct rds_rx_trace_so))\n\t\treturn -EFAULT;\n\n\tif (copy_from_sockptr(&trace,\
  \ optval, sizeof(trace)))\n\t\treturn -EFAULT;\n\n\tif (trace.rx_traces > RDS_MSG_RX_DGRAM_TRACE_MAX)\n\
  \t\treturn -EFAULT;\n\n\trs->rs_rx_traces = trace.rx_traces;\n\tfor (i = 0; i <\
  \ rs->rs_rx_traces; i++) {\n\t\tif (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX)\
  \ {\n\t\t\trs->rs_rx_traces = 0;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trs->rs_rx_trace[i]\
  \ = trace.rx_trace_pos[i];\n\t}\n\n\treturn 0;\n}\n```\n\n## Bug Fix Patch\n\n```diff\n\
  diff --git a/net/rds/af_rds.c b/net/rds/af_rds.c\nindex 01c4cdfef45d..8435a20968ef\
  \ 100644\n--- a/net/rds/af_rds.c\n+++ b/net/rds/af_rds.c\n@@ -419,7 +419,7 @@ static\
  \ int rds_recv_track_latency(struct rds_sock *rs, sockptr_t optval,\n \n \trs->rs_rx_traces\
  \ = trace.rx_traces;\n \tfor (i = 0; i < rs->rs_rx_traces; i++) {\n-\t\tif (trace.rx_trace_pos[i]\
  \ > RDS_MSG_RX_DGRAM_TRACE_MAX) {\n+\t\tif (trace.rx_trace_pos[i] >= RDS_MSG_RX_DGRAM_TRACE_MAX)\
  \ {\n \t\t\trs->rs_rx_traces = 0;\n \t\t\treturn -EFAULT;\n \t\t}\n```\n"
pattern: '## Bug Pattern


  Off-by-one index validation: using `if (idx > MAX)` instead of `if (idx >= MAX)`
  when checking user-provided indices against an array bound constant, where the array
  is sized `MAX` and valid indices are `[0..MAX-1]`. This allows `idx == MAX` to pass,
  and subsequent use (e.g., accessing `array[idx]` or `array[idx + 1]`) can cause
  out-of-bounds access.'
plan: "1) Program state\n- No custom program state is required. We can detect this\
  \ pattern locally in the branch condition and avoid tracking across statements.\n\
  \n2) Callbacks to use\n- checkBranchCondition only.\n\n3) Detailed steps\n\nStep\
  \ A: Detect the faulty guard in checkBranchCondition\n- Input: const Stmt *Condition\
  \ is the expression that guards an if/else, while, for, etc. We will only act when\
  \ it is from an IfStmt.\n- Implementation:\n  1) Retrieve the enclosing IfStmt using\
  \ findSpecificTypeInParents<IfStmt>(Condition, C). If not found, return.\n  2) Require\
  \ that Condition is a BinaryOperator with one of these forms:\n     - BO_GT: (LHS\
  \ > RHS)\n     - BO_LT: (LHS < RHS)  // equivalent to RHS > LHS\n     Ignore other\
  \ operators. If it is a BinaryOperator chain (like a &&/||), skip.\n  3) Normalize\
  \ the comparison:\n     - For BO_GT: VarExpr = LHS, BoundExpr = RHS.\n     - For\
  \ BO_LT: VarExpr = RHS, BoundExpr = LHS.  // rewrite \u201CMAX < idx\u201D as \u201C\
  idx > MAX\u201D\n  4) Validate BoundExpr as a \u201CMAX-like bound\u201D:\n    \
  \ - Try to evaluate BoundExpr to an integer using EvaluateExprToInt. If it evaluates,\
  \ keep the value (we don\u2019t strictly need it to report, but this helps in avoiding\
  \ non-integer cases).\n     - Additionally, ensure the bound looks like an upper-bound\
  \ constant:\n       - If BoundExpr\u2019s source text contains \"MAX\" (ExprHasName(BoundExpr,\
  \ \"MAX\", C) == true), or\n       - BoundExpr is a DeclRefExpr and its decl name\
  \ contains \"MAX\" (DRE->getDecl()->getName().contains(\"MAX\")).\n     If neither\
  \ test passes, return (reduces false positives).\n  5) Verify this is an error-guard:\n\
  \     - Grab IfStmt->getThen(). If null, return.\n     - Check whether the Then\
  \ branch contains an early-exit (error) using findSpecificTypeInChildren<ReturnStmt>(IfStmt->getThen()).\n\
  \     - If no ReturnStmt found, optionally accept a stricter guard by also checking\
  \ for a call to common error paths (not required for minimal version). For the simplest\
  \ version, require a ReturnStmt and otherwise return.\n  6) Optional sanity: If\
  \ VarExpr is a literal (not a variable/expression), skip to avoid nonsense.\n  7)\
  \ Report:\n     - Create a BasicBugReport (or PathSensitiveBugReport if you prefer\
  \ a path note) with a short message:\n       \u201COff-by-one bound check: use \u2018\
  >= MAX\u2019 instead of \u2018> MAX\u2019 for index validation.\u201D\n     - Anchor\
  \ it at the condition expression or the operator location.\n     - Use C.emitReport(std::make_unique<BasicBugReport>(...)).\n\
  \nNotes and heuristics\n- This checker purposefully keeps the logic simple and local:\n\
  \  - It flags guards that are highly likely meant to constrain an index to [0..MAX-1]\
  \ but use \u2018> MAX\u2019 instead of \u2018>= MAX\u2019.\n  - It reduces false\
  \ positives by:\n    - Requiring a MAX-like bound token in the source.\n    - Requiring\
  \ the guard lead to an early return in the then-branch (common error-check idiom).\n\
  - No alias or dataflow tracking is needed.\n- No need to inspect later array subscripts;\
  \ the guard itself is the bug in the target patch.\n\n4) Summary of used utilities\
  \ and APIs\n- findSpecificTypeInParents<IfStmt>(Condition, C) to obtain the IfStmt\
  \ from the branch condition.\n- findSpecificTypeInChildren<ReturnStmt>(IfStmt->getThen())\
  \ to confirm it is an error-guard branch.\n- EvaluateExprToInt to ensure the right-hand\
  \ side is an integer constant (best-effort).\n- ExprHasName(BoundExpr, \"MAX\",\
  \ C) to robustly detect \u201CMAX\u201D in the bound\u2019s token text."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/ParentMapContext.h\"\n#include \"clang/Lex/Lexer.h\"\n\n\
  using namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom\
  \ program states needed.\n\nnamespace {\n\nclass SAGenTestChecker : public Checker<check::BranchCondition>\
  \ {\n  mutable std::unique_ptr<BugType> BT;\n\npublic:\n  SAGenTestChecker()\n \
  \     : BT(new BugType(this, \"Off-by-one bound check\", \"Logic\")) {}\n\n  void\
  \ checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;\n\nprivate:\n\
  \  bool looksLikeMaxBound(const Expr *E, CheckerContext &C) const;\n  bool isEarlyReturnInThen(const\
  \ IfStmt *IS) const;\n};\n\nbool SAGenTestChecker::looksLikeMaxBound(const Expr\
  \ *E,\n                                         CheckerContext &C) const {\n  if\
  \ (!E)\n    return false;\n\n  // If the expression source contains \"MAX\", we\
  \ consider it a bound-like expr.\n  if (ExprHasName(E, \"MAX\", C))\n    return\
  \ true;\n\n  // If it's a DeclRefExpr whose name contains \"MAX\", accept it.\n\
  \  if (const auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenCasts())) {\n    if\
  \ (const auto *II = DRE->getDecl()->getIdentifier()) {\n      if (II->getName().contains(\"\
  MAX\"))\n        return true;\n    }\n  }\n\n  // Alternatively, if it folds to\
  \ an integer constant, also accept.\n  llvm::APSInt Dummy;\n  if (EvaluateExprToInt(Dummy,\
  \ E, C))\n    return true;\n\n  return false;\n}\n\nbool SAGenTestChecker::isEarlyReturnInThen(const\
  \ IfStmt *IS) const {\n  if (!IS)\n    return false;\n  const Stmt *ThenS = IS->getThen();\n\
  \  if (!ThenS)\n    return false;\n\n  // Look for a ReturnStmt somewhere in the\
  \ Then branch.\n  const ReturnStmt *RS = findSpecificTypeInChildren<ReturnStmt>(ThenS);\n\
  \  return RS != nullptr;\n}\n\nvoid SAGenTestChecker::checkBranchCondition(const\
  \ Stmt *Condition,\n                                            CheckerContext &C)\
  \ const {\n  if (!Condition)\n    return;\n\n  // Only consider If conditions.\n\
  \  const IfStmt *IS = findSpecificTypeInParents<IfStmt>(Condition, C);\n  if (!IS)\n\
  \    return;\n\n  const Expr *CondE = dyn_cast<Expr>(Condition);\n  if (!CondE)\n\
  \    return;\n\n  CondE = CondE->IgnoreParenImpCasts();\n\n  // We only consider\
  \ simple relational comparisons.\n  const auto *BO = dyn_cast<BinaryOperator>(CondE);\n\
  \  if (!BO)\n    return;\n\n  BinaryOperator::Opcode Op = BO->getOpcode();\n  if\
  \ (Op != BO_GT && Op != BO_LT)\n    return;\n\n  const Expr *LHS = BO->getLHS()->IgnoreParenCasts();\n\
  \  const Expr *RHS = BO->getRHS()->IgnoreParenCasts();\n\n  // Normalize to \"Var\
  \ > Bound\".\n  const Expr *VarExpr = nullptr;\n  const Expr *BoundExpr = nullptr;\n\
  \  if (Op == BO_GT) {\n    VarExpr = LHS;\n    BoundExpr = RHS;\n  } else if (Op\
  \ == BO_LT) {\n    // \"A < B\" is equivalent to \"B > A\".\n    VarExpr = RHS;\n\
  \    BoundExpr = LHS;\n  }\n\n  if (!VarExpr || !BoundExpr)\n    return;\n\n  //\
  \ Bound should look like a MAX-like constant or fold to an int.\n  if (!looksLikeMaxBound(BoundExpr,\
  \ C))\n    return;\n\n  // The Then branch should look like an error path with early\
  \ return.\n  if (!isEarlyReturnInThen(IS))\n    return;\n\n  // Skip degenerate\
  \ cases like \"5 > MAX\".\n  if (isa<IntegerLiteral>(VarExpr))\n    return;\n\n\
  \  // Report the likely off-by-one check.\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT,\n      \"Off-by-one bound check: use '>= MAX' instead of '> MAX' for\
  \ index validation\",\n      N);\n  R->addRange(Condition->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detects off-by-one index validation\
  \ using '>' instead of '>=' against MAX-like bounds\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
