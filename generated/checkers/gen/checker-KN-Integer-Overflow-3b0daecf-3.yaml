_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: 3b0daecfeac0103aba8b293df07a0cbaf8b43f29
commit_type: Integer-Overflow
index: 3
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/APInt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states required for this checker.\n\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n\
  \      SAGenTestChecker() : BT(new BugType(this, \"Potential overflow in kmalloc/kzalloc\
  \ size\", \"Memory Management\")) {}\n\n      void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n   private:\n      bool isKernelAlloc(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      bool isMulOfSizeofAndCount(const\
  \ Expr *E,\n                                 const BinaryOperator *&Mul,\n     \
  \                            const Expr *&SizeOfExpr,\n                        \
  \         const Expr *&CountExpr) const;\n      bool evalToInt(llvm::APSInt &Res,\
  \ const Expr *E, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isKernelAlloc(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  if (ExprHasName(Origin, \"kmalloc\", C))\n\
  \    return true;\n  if (ExprHasName(Origin, \"kzalloc\", C))\n    return true;\n\
  \n  return false;\n}\n\nbool SAGenTestChecker::evalToInt(llvm::APSInt &Res, const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E) return false;\n  return EvaluateExprToInt(Res,\
  \ E, C);\n}\n\n// Try to recognize: <sizeof(...)> * <count> (possibly wrapped in\
  \ casts/parens)\nbool SAGenTestChecker::isMulOfSizeofAndCount(const Expr *E,\n \
  \                                            const BinaryOperator *&Mul,\n     \
  \                                        const Expr *&SizeOfExpr,\n            \
  \                                 const Expr *&CountExpr) const {\n  Mul = nullptr;\n\
  \  SizeOfExpr = nullptr;\n  CountExpr = nullptr;\n\n  if (!E)\n    return false;\n\
  \n  const Expr *Norm = E->IgnoreParenImpCasts();\n  Mul = dyn_cast<BinaryOperator>(Norm);\n\
  \  if (!Mul) {\n    // Fallback: search within children if wrapped further\n   \
  \ Mul = findSpecificTypeInChildren<BinaryOperator>(E);\n  }\n  if (!Mul)\n    return\
  \ false;\n\n  if (Mul->getOpcode() != BO_Mul)\n    return false;\n\n  const Expr\
  \ *L = Mul->getLHS()->IgnoreParenImpCasts();\n  const Expr *R = Mul->getRHS()->IgnoreParenImpCasts();\n\
  \n  const auto *UL = dyn_cast<UnaryExprOrTypeTraitExpr>(L);\n  const auto *UR =\
  \ dyn_cast<UnaryExprOrTypeTraitExpr>(R);\n\n  if (UL && UL->getKind() == UETT_SizeOf)\
  \ {\n    SizeOfExpr = L;\n    CountExpr = R;\n    return true;\n  }\n  if (UR &&\
  \ UR->getKind() == UETT_SizeOf) {\n    SizeOfExpr = R;\n    CountExpr = L;\n   \
  \ return true;\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isKernelAlloc(Call, C))\n\
  \    return;\n\n  if (Call.getNumArgs() < 1)\n    return;\n\n  const Expr *SizeArg\
  \ = Call.getArgExpr(0);\n  if (!SizeArg)\n    return;\n\n  // Step B/C: look for\
  \ sizeof(..) * count pattern in the size argument\n  const BinaryOperator *Mul =\
  \ nullptr;\n  const Expr *SizeOfExpr = nullptr;\n  const Expr *CountExpr = nullptr;\n\
  \  if (!isMulOfSizeofAndCount(SizeArg, Mul, SizeOfExpr, CountExpr))\n    return;\n\
  \n  // Step D: If total size is compile-time constant, don't warn.\n  llvm::APSInt\
  \ TotalConst;\n  if (evalToInt(TotalConst, SizeArg, C))\n    return;\n\n  // Evaluate\
  \ sizeof side (usually constant). If it fails, we keep going conservatively.\n \
  \ llvm::APSInt SizeOfConst;\n  bool HasSizeOfConst = evalToInt(SizeOfConst, SizeOfExpr,\
  \ C);\n\n  // If count side is compile-time constant, consider low risk and don't\
  \ warn.\n  llvm::APSInt CountConst;\n  if (evalToInt(CountConst, CountExpr, C))\n\
  \    return;\n\n  // Step E: Try to prove that the multiplication cannot overflow\
  \ via max bound\n  // Otherwise, report.\n  bool ProvenSafe = false;\n\n  if (HasSizeOfConst)\
  \ {\n    // Try to infer maximal value of count symbolically.\n    ProgramStateRef\
  \ State = C.getState();\n    SVal CountSV = State->getSVal(CountExpr, C.getLocationContext());\n\
  \    SymbolRef Sym = CountSV.getAsSymbol();\n\n    if (Sym) {\n      if (const llvm::APSInt\
  \ *MaxCount = inferSymbolMaxVal(Sym, C)) {\n        // Compute if MaxCount * SizeOfConst\
  \ fits into the bitwidth of the size argument type.\n        unsigned Width = C.getASTContext().getTypeSize(SizeArg->getType());\n\
  \        if (Width == 0)\n          Width = std::max<unsigned>(64, SizeOfConst.getBitWidth());\n\
  \n        // Prepare APInts as unsigned\n        llvm::APInt MaxVal = llvm::APInt::getMaxValue(Width);\n\
  \n        // Zero-extend/truncate operands to Width\n        llvm::APInt SizeAP(Width,\
  \ SizeOfConst.getZExtValue());\n        llvm::APInt CountAP(Width, MaxCount->getZExtValue());\n\
  \n        if (SizeAP == 0) {\n          // Zero size means no overflow and no risk\
  \ (but also nonsense alloc); treat as safe to avoid false positive.\n          ProvenSafe\
  \ = true;\n        } else {\n          // If MaxCount <= MaxVal / Size then product\
  \ cannot overflow.\n          llvm::APInt UB = MaxVal.udiv(SizeAP);\n          if\
  \ (CountAP.ule(UB))\n            ProvenSafe = true;\n        }\n      }\n    }\n\
  \  }\n\n  if (ProvenSafe)\n    return;\n\n  // Report: potentially overflowing kmalloc/kzalloc\
  \ size computation\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Use kcalloc(n, size) to avoid overflow in kmalloc/kzalloc size computation\"\
  , N);\n  R->addRange(SizeArg->getSourceRange());\n  if (CountExpr)\n    R->addRange(CountExpr->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect kmalloc/kzalloc with sizeof(...)\
  \ * count size that may overflow; suggest kcalloc\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\namdkfd: use calloc instead of kzalloc to avoid integer\
  \ overflow\n\nThis uses calloc instead of doing the multiplication which might\n\
  overflow.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n\
  \n## Buggy Code\n\n```c\n// Function: kfd_ioctl_get_process_apertures_new in drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\t\t\t\tstruct\
  \ kfd_process *p, void *data)\n{\n\tstruct kfd_ioctl_get_process_apertures_new_args\
  \ *args = data;\n\tstruct kfd_process_device_apertures *pa;\n\tint ret;\n\tint i;\n\
  \n\tdev_dbg(kfd_device, \"get apertures for PASID 0x%x\", p->pasid);\n\n\tif (args->num_of_nodes\
  \ == 0) {\n\t\t/* Return number of nodes, so that user space can alloacate\n\t\t\
  \ * sufficient memory\n\t\t */\n\t\tmutex_lock(&p->mutex);\n\t\targs->num_of_nodes\
  \ = p->n_pdds;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Fill in process-aperture information\
  \ for all available\n\t * nodes, but not more than args->num_of_nodes as that is\n\
  \t * the amount of memory allocated by user\n\t */\n\tpa = kzalloc((sizeof(struct\
  \ kfd_process_device_apertures) *\n\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n\t\
  if (!pa)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&p->mutex);\n\n\tif (!p->n_pdds) {\n\
  \t\targs->num_of_nodes = 0;\n\t\tkfree(pa);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Run\
  \ over all pdd of the process */\n\tfor (i = 0; i < min(p->n_pdds, args->num_of_nodes);\
  \ i++) {\n\t\tstruct kfd_process_device *pdd = p->pdds[i];\n\n\t\tpa[i].gpu_id =\
  \ pdd->dev->id;\n\t\tpa[i].lds_base = pdd->lds_base;\n\t\tpa[i].lds_limit = pdd->lds_limit;\n\
  \t\tpa[i].gpuvm_base = pdd->gpuvm_base;\n\t\tpa[i].gpuvm_limit = pdd->gpuvm_limit;\n\
  \t\tpa[i].scratch_base = pdd->scratch_base;\n\t\tpa[i].scratch_limit = pdd->scratch_limit;\n\
  \n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpu id %u\\n\", pdd->dev->id);\n\t\tdev_dbg(kfd_device,\n\
  \t\t\t\"lds_base %llX\\n\", pdd->lds_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"lds_limit\
  \ %llX\\n\", pdd->lds_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_base %llX\\\
  n\", pdd->gpuvm_base);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"gpuvm_limit %llX\\n\",\
  \ pdd->gpuvm_limit);\n\t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_base %llX\\n\", pdd->scratch_base);\n\
  \t\tdev_dbg(kfd_device,\n\t\t\t\"scratch_limit %llX\\n\", pdd->scratch_limit);\n\
  \t}\n\tmutex_unlock(&p->mutex);\n\n\targs->num_of_nodes = i;\n\tret = copy_to_user(\n\
  \t\t\t(void __user *)args->kfd_process_device_apertures_ptr,\n\t\t\tpa,\n\t\t\t\
  (i * sizeof(struct kfd_process_device_apertures)));\n\tkfree(pa);\n\treturn ret\
  \ ? -EFAULT : 0;\n\nout_unlock:\n\tmutex_unlock(&p->mutex);\n\treturn 0;\n}\n```\n\
  \n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\
  \ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\nindex f9631f4b1a02..55aa74cbc532 100644\n\
  --- a/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n+++ b/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c\n\
  @@ -779,8 +779,8 @@ static int kfd_ioctl_get_process_apertures_new(struct file *filp,\n\
  \ \t * nodes, but not more than args->num_of_nodes as that is\n \t * the amount\
  \ of memory allocated by user\n \t */\n-\tpa = kzalloc((sizeof(struct kfd_process_device_apertures)\
  \ *\n-\t\t\t\targs->num_of_nodes), GFP_KERNEL);\n+\tpa = kcalloc(args->num_of_nodes,\
  \ sizeof(struct kfd_process_device_apertures),\n+\t\t     GFP_KERNEL);\n \tif (!pa)\n\
  \ \t\treturn -ENOMEM;\n \n```\n"
pattern: '## Bug Pattern


  Allocating an array with kmalloc/kzalloc using manual multiplication of element
  size and count without overflow checking, where the count may come from user input:


  ptr = kzalloc(sizeof(struct elem) * n, GFP_KERNEL);

  /* ... later use ptr[i] for i in [0, n) ... */


  This multiplication can overflow size_t, leading to an under-sized allocation and
  subsequent out-of-bounds writes when populating the array. Use kcalloc(n, sizeof(struct
  elem), GFP_KERNEL) (or explicit overflow-checked helpers) to prevent integer overflow.'
plan: "1) Program state\n- No custom program state is required. This checker is a\
  \ call-site pattern detector that inspects allocation calls and their size expressions\
  \ on the fly.\n\n2) Callback functions\n- Use only checkPreCall.\n\n3) Detailed\
  \ steps\n\nStep A. Identify target allocators in checkPreCall\n- When checkPreCall\
  \ is invoked, inspect the callee name via Call.getCalleeIdentifier()->getName().\n\
  - Only proceed if the function is one of:\n  - \"kmalloc\", \"kzalloc\" (optionally,\
  \ you may include \"__kmalloc\" or \"kvzalloc\" if desired; the core pattern is\
  \ for kmalloc/kzalloc).\n- For these functions, retrieve the first argument (size\
  \ expression) with Call.getArgExpr(0). Let this be ESize.\n\nStep B. Normalize and\
  \ extract a multiplicative size expression\n- Strip parens and implicit casts from\
  \ ESize using ESize = ESize->IgnoreParenImpCasts().\n- Try dyn_cast<BinaryOperator>(ESize);\
  \ if not a BinaryOperator, try findSpecificTypeInChildren<BinaryOperator>(Call.getArgExpr(0))\
  \ to handle wrapping casts/macros. If still not found, return (no bug).\n- If found,\
  \ ensure the operator is multiplication: BinOp->getOpcode() == BO_Mul. If not, return.\n\
  \nStep C. Detect the \u201Csizeof * count\u201D pattern\n- Extract LHS and RHS as\
  \ ELHS = BinOp->getLHS()->IgnoreParenImpCasts(), ERHS = BinOp->getRHS()->IgnoreParenImpCasts().\n\
  - Check if either side is a sizeof expression:\n  - dyn_cast<UnaryExprOrTypeTraitExpr>(ELHS)\
  \ with getKind() == UETT_SizeOf, or\n  - dyn_cast<UnaryExprOrTypeTraitExpr>(ERHS)\
  \ with getKind() == UETT_SizeOf.\n- If neither side is a sizeof expression, return\
  \ (we only warn on the clear sizeof * count pattern; this keeps false positives\
  \ low).\n- Let ESizeOf be the sizeof side; let ECount be the other side.\n\nStep\
  \ D. Filter out trivially safe cases (constant size)\n- Try to evaluate the entire\
  \ size expression ESize to a constant with EvaluateExprToInt(..., ESize, C). If\
  \ it evaluates to a compile-time constant (i.e., APSInt available), do not warn,\
  \ return. Rationale: constant folded size is under the programmer\u2019s control\
  \ and typically not a user-driven overflow risk.\n- Else, evaluate the sizeof side\
  \ ESizeOf to a constant using EvaluateExprToInt(..., ESizeOf, C). This should usually\
  \ succeed; if not, continue but keep the warning conservative.\n\nStep E. Try to\
  \ prove the multiplication cannot overflow; otherwise, warn\n- Attempt to evaluate\
  \ the count side ECount to a constant:\n  - If EvaluateExprToInt(..., ECount, C)\
  \ succeeds, optionally (but simply) skip warning because both factors are known\
  \ and the total size was not constant-folded only due to type/implicit cast wrapping.\
  \ For simplicity, treat constant count as low risk and return without warning.\n\
  - If ECount is not a compile-time constant:\n  - Obtain the symbolic value of ECount:\
  \ SVal CountSV = C.getState()->getSVal(ECount, C.getLocationContext()).\n  - If\
  \ CountSV.getAsSymbol() yields Sym, try inferSymbolMaxVal(Sym, C).\n    - If a max\
  \ value is known (MaxCount), and the product (MaxCount * SizeOfVal) fits into the\
  \ bitwidth of ESize\u2019s type (typically size_t; you can get width via C.getASTContext().getTypeSize(ESize->getType())),\
  \ then consider it safe and return.\n    - If max value is unknown or the product\
  \ may overflow, proceed to report.\n- Heuristic policy (to stay simple and effective):\n\
  \  - If we detect kmalloc/kzalloc with a multiplicative size argument where one\
  \ factor is sizeof(...) and the other is a non-constant expression whose maximum\
  \ cannot be proven safe, emit a warning recommending kcalloc(n, size, flags).\n\
  \  - This matches the given patch pattern and is sufficient to catch common user-count-driven\
  \ allocations.\n\nStep F. Reporting\n- Create a BugType once (e.g., in the checker\u2019\
  s constructor or lazily on first use) with a short name like \"Potential overflow\
  \ in kmalloc/kzalloc size\".\n- Generate a non-fatal error node with generateNonFatalErrorNode().\n\
  - Build a PathSensitiveBugReport with a short message:\n  - \"Use kcalloc(n, size)\
  \ to avoid overflow in kmalloc/kzalloc size computation.\"\n- Highlight the source\
  \ range of the first allocation argument (ESize).\n- Optionally, add an extra note\
  \ range for the count expression (ECount) to point to the likely user-derived factor.\n\
  - Emit the report with C.emitReport(...).\n\n4) Notes and small helpers\n- Function\
  \ matching:\n  - Implement a small helper isKernelAlloc(const CallEvent &Call) that\
  \ returns true if the callee name equals \"kmalloc\" or \"kzalloc\".\n- Multiplication\
  \ extraction:\n  - Prefer direct dyn_cast<BinaryOperator> on the unwrapped size\
  \ expression; if this fails, fall back to findSpecificTypeInChildren<BinaryOperator>(Call.getArgExpr(0))\
  \ to catch cases hidden by casts/macros.\n- sizeof extraction:\n  - Check UnaryExprOrTypeTraitExpr\
  \ on the direct operand. This avoids relying on textual matching and keeps the logic\
  \ robust.\n- Integer evaluation:\n  - Use the provided EvaluateExprToInt utility.\n\
  - Max bound reasoning:\n  - Use inferSymbolMaxVal for simple pruning. If no bounds\
  \ available, warn.\n\nThis minimal, call-site-only checker will reliably flag kmalloc/kzalloc\
  \ calls that compute their size as sizeof(T) * n without overflow checks, and guide\
  \ developers toward kcalloc, matching the target patch and bug pattern."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/Type.h\"\
  \n#include \"clang/Lex/Lexer.h\"\n#include \"llvm/ADT/APInt.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// No custom program\
  \ states required for this checker.\n\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::PreCall> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n\
  \      SAGenTestChecker() : BT(new BugType(this, \"Potential overflow in kmalloc/kzalloc\
  \ size\", \"Memory Management\")) {}\n\n      void checkPreCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n\n   private:\n      bool isKernelAlloc(const\
  \ CallEvent &Call, CheckerContext &C) const;\n      bool isMulOfSizeofAndCount(const\
  \ Expr *E,\n                                 const BinaryOperator *&Mul,\n     \
  \                            const Expr *&SizeOfExpr,\n                        \
  \         const Expr *&CountExpr) const;\n      bool evalToInt(llvm::APSInt &Res,\
  \ const Expr *E, CheckerContext &C) const;\n};\n\nbool SAGenTestChecker::isKernelAlloc(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  const Expr *Origin = Call.getOriginExpr();\n\
  \  if (!Origin)\n    return false;\n\n  if (ExprHasName(Origin, \"kmalloc\", C))\n\
  \    return true;\n  if (ExprHasName(Origin, \"kzalloc\", C))\n    return true;\n\
  \n  return false;\n}\n\nbool SAGenTestChecker::evalToInt(llvm::APSInt &Res, const\
  \ Expr *E, CheckerContext &C) const {\n  if (!E) return false;\n  return EvaluateExprToInt(Res,\
  \ E, C);\n}\n\n// Try to recognize: <sizeof(...)> * <count> (possibly wrapped in\
  \ casts/parens)\nbool SAGenTestChecker::isMulOfSizeofAndCount(const Expr *E,\n \
  \                                            const BinaryOperator *&Mul,\n     \
  \                                        const Expr *&SizeOfExpr,\n            \
  \                                 const Expr *&CountExpr) const {\n  Mul = nullptr;\n\
  \  SizeOfExpr = nullptr;\n  CountExpr = nullptr;\n\n  if (!E)\n    return false;\n\
  \n  const Expr *Norm = E->IgnoreParenImpCasts();\n  Mul = dyn_cast<BinaryOperator>(Norm);\n\
  \  if (!Mul) {\n    // Fallback: search within children if wrapped further\n   \
  \ Mul = findSpecificTypeInChildren<BinaryOperator>(E);\n  }\n  if (!Mul)\n    return\
  \ false;\n\n  if (Mul->getOpcode() != BO_Mul)\n    return false;\n\n  const Expr\
  \ *L = Mul->getLHS()->IgnoreParenImpCasts();\n  const Expr *R = Mul->getRHS()->IgnoreParenImpCasts();\n\
  \n  const auto *UL = dyn_cast<UnaryExprOrTypeTraitExpr>(L);\n  const auto *UR =\
  \ dyn_cast<UnaryExprOrTypeTraitExpr>(R);\n\n  if (UL && UL->getKind() == UETT_SizeOf)\
  \ {\n    SizeOfExpr = L;\n    CountExpr = R;\n    return true;\n  }\n  if (UR &&\
  \ UR->getKind() == UETT_SizeOf) {\n    SizeOfExpr = R;\n    CountExpr = L;\n   \
  \ return true;\n  }\n\n  return false;\n}\n\nvoid SAGenTestChecker::checkPreCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  if (!isKernelAlloc(Call, C))\n\
  \    return;\n\n  if (Call.getNumArgs() < 1)\n    return;\n\n  const Expr *SizeArg\
  \ = Call.getArgExpr(0);\n  if (!SizeArg)\n    return;\n\n  // Step B/C: look for\
  \ sizeof(..) * count pattern in the size argument\n  const BinaryOperator *Mul =\
  \ nullptr;\n  const Expr *SizeOfExpr = nullptr;\n  const Expr *CountExpr = nullptr;\n\
  \  if (!isMulOfSizeofAndCount(SizeArg, Mul, SizeOfExpr, CountExpr))\n    return;\n\
  \n  // Step D: If total size is compile-time constant, don't warn.\n  llvm::APSInt\
  \ TotalConst;\n  if (evalToInt(TotalConst, SizeArg, C))\n    return;\n\n  // Evaluate\
  \ sizeof side (usually constant). If it fails, we keep going conservatively.\n \
  \ llvm::APSInt SizeOfConst;\n  bool HasSizeOfConst = evalToInt(SizeOfConst, SizeOfExpr,\
  \ C);\n\n  // If count side is compile-time constant, consider low risk and don't\
  \ warn.\n  llvm::APSInt CountConst;\n  if (evalToInt(CountConst, CountExpr, C))\n\
  \    return;\n\n  // Step E: Try to prove that the multiplication cannot overflow\
  \ via max bound\n  // Otherwise, report.\n  bool ProvenSafe = false;\n\n  if (HasSizeOfConst)\
  \ {\n    // Try to infer maximal value of count symbolically.\n    ProgramStateRef\
  \ State = C.getState();\n    SVal CountSV = State->getSVal(CountExpr, C.getLocationContext());\n\
  \    SymbolRef Sym = CountSV.getAsSymbol();\n\n    if (Sym) {\n      if (const llvm::APSInt\
  \ *MaxCount = inferSymbolMaxVal(Sym, C)) {\n        // Compute if MaxCount * SizeOfConst\
  \ fits into the bitwidth of the size argument type.\n        unsigned Width = C.getASTContext().getTypeSize(SizeArg->getType());\n\
  \        if (Width == 0)\n          Width = std::max<unsigned>(64, SizeOfConst.getBitWidth());\n\
  \n        // Prepare APInts as unsigned\n        llvm::APInt MaxVal = llvm::APInt::getMaxValue(Width);\n\
  \n        // Zero-extend/truncate operands to Width\n        llvm::APInt SizeAP(Width,\
  \ SizeOfConst.getZExtValue());\n        llvm::APInt CountAP(Width, MaxCount->getZExtValue());\n\
  \n        if (SizeAP == 0) {\n          // Zero size means no overflow and no risk\
  \ (but also nonsense alloc); treat as safe to avoid false positive.\n          ProvenSafe\
  \ = true;\n        } else {\n          // If MaxCount <= MaxVal / Size then product\
  \ cannot overflow.\n          llvm::APInt UB = MaxVal.udiv(SizeAP);\n          if\
  \ (CountAP.ule(UB))\n            ProvenSafe = true;\n        }\n      }\n    }\n\
  \  }\n\n  if (ProvenSafe)\n    return;\n\n  // Report: potentially overflowing kmalloc/kzalloc\
  \ size computation\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Use kcalloc(n, size) to avoid overflow in kmalloc/kzalloc size computation\"\
  , N);\n  R->addRange(SizeArg->getSourceRange());\n  if (CountExpr)\n    R->addRange(CountExpr->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"Detect kmalloc/kzalloc with sizeof(...)\
  \ * count size that may overflow; suggest kcalloc\",\n      \"\");\n}\n\nextern\
  \ \"C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
