_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: ef307bc6ef04e8c1ea843231db58e3afaafa9fa6
commit_type: Concurrency
index: 1
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/Lex/Lexer.h\"\
  \n\nusing namespace clang;\nusing namespace ento;\nusing namespace taint;\n\n//\
  \ Program states\nREGISTER_SET_WITH_PROGRAMSTATE(HeldLocks, const MemRegion*)\n\
  REGISTER_MAP_WITH_PROGRAMSTATE(ProtectedFieldToLock, const MemRegion*, const MemRegion*)\n\
  \nnamespace {\n\nclass SAGenTestChecker : public Checker<check::PostCall, check::Location,\
  \ check::Bind> {\n   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"Inconsistent locking\", \"Concurrency\")) {}\n\n    \
  \  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;\n      void\
  \ checkLocation(SVal Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const;\n\
  \      void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n\
  \n   private:\n\n      // Helpers\n      static bool isSpinLock(const CallEvent\
  \ &Call, CheckerContext &C);\n      static bool isSpinUnlock(const CallEvent &Call,\
  \ CheckerContext &C);\n      static const MemRegion* getLockRegionFromArg(const\
  \ CallEvent &Call, CheckerContext &C);\n      static const MemRegion* getFieldRegionFromExpr(const\
  \ Expr *E, CheckerContext &C);\n      static const MemRegion* getFieldRegionFromLoc(const\
  \ MemRegion *MR);\n      static const MemRegion* getOnlyHeldLock(ProgramStateRef\
  \ State);\n      static bool isNullAssigned(const Stmt *S, CheckerContext &C);\n\
  \n      static void recordFieldUnderOnlyLock(const Expr *ArgE, CheckerContext &C);\n\
  \      static void recordFieldUnderOnlyLockFromLoc(SVal Loc, CheckerContext &C);\n\
  };\n\nbool SAGenTestChecker::isSpinLock(const CallEvent &Call, CheckerContext &C)\
  \ {\n  const Expr *E = Call.getOriginExpr();\n  if (!E) return false;\n  return\
  \ ExprHasName(E, \"spin_lock\", C) ||\n         ExprHasName(E, \"spin_lock_irqsave\"\
  , C) ||\n         ExprHasName(E, \"spin_lock_irq\", C) ||\n         ExprHasName(E,\
  \ \"spin_lock_bh\", C);\n}\n\nbool SAGenTestChecker::isSpinUnlock(const CallEvent\
  \ &Call, CheckerContext &C) {\n  const Expr *E = Call.getOriginExpr();\n  if (!E)\
  \ return false;\n  return ExprHasName(E, \"spin_unlock\", C) ||\n         ExprHasName(E,\
  \ \"spin_unlock_irqrestore\", C) ||\n         ExprHasName(E, \"spin_unlock_irq\"\
  , C) ||\n         ExprHasName(E, \"spin_unlock_bh\", C);\n}\n\nconst MemRegion*\
  \ SAGenTestChecker::getFieldRegionFromLoc(const MemRegion *MR) {\n  if (!MR) return\
  \ nullptr;\n  // Walk up to find a FieldRegion\n  const MemRegion *Cur = MR;\n \
  \ while (Cur) {\n    if (isa<FieldRegion>(Cur))\n      return Cur;\n    Cur = Cur->getSuperRegion();\n\
  \  }\n  return nullptr;\n}\n\nconst MemRegion* SAGenTestChecker::getFieldRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return nullptr;\n\n  // Try directly\
  \ from the expression\n  if (const MemRegion *MR = getMemRegionFromExpr(E, C)) {\n\
  \    if (const MemRegion *FR = getFieldRegionFromLoc(MR))\n      return FR;\n  }\n\
  \n  // Try to find a MemberExpr child and get its region\n  if (const auto *ME =\
  \ findSpecificTypeInChildren<MemberExpr>(E)) {\n    if (const MemRegion *MR2 = getMemRegionFromExpr(ME,\
  \ C)) {\n      if (const MemRegion *FR2 = getFieldRegionFromLoc(MR2))\n        return\
  \ FR2;\n    }\n  }\n  return nullptr;\n}\n\nconst MemRegion* SAGenTestChecker::getLockRegionFromArg(const\
  \ CallEvent &Call, CheckerContext &C) {\n  if (Call.getNumArgs() < 1)\n    return\
  \ nullptr;\n\n  const Expr *ArgE = Call.getArgExpr(0);\n  if (!ArgE)\n    return\
  \ nullptr;\n\n  // If it's &obj->lock, peel off the address-of to get the underlying\
  \ object\n  if (const auto *UO = dyn_cast<UnaryOperator>(ArgE)) {\n    if (UO->getOpcode()\
  \ == UO_AddrOf)\n      ArgE = UO->getSubExpr();\n  }\n\n  const MemRegion *MR =\
  \ getMemRegionFromExpr(ArgE, C);\n  if (!MR)\n    return nullptr;\n\n  // Always\
  \ use base region as per suggestions\n  MR = MR->getBaseRegion();\n  return MR;\n\
  }\n\nconst MemRegion* SAGenTestChecker::getOnlyHeldLock(ProgramStateRef State) {\n\
  \  auto Set = State->get<HeldLocks>();\n  const MemRegion *Only = nullptr;\n  unsigned\
  \ Count = 0;\n  for (auto I = Set.begin(), E = Set.end(); I != E; ++I) {\n    Only\
  \ = *I;\n    ++Count;\n    if (Count > 1)\n      return nullptr;\n  }\n  return\
  \ (Count == 1) ? Only : nullptr;\n}\n\nbool SAGenTestChecker::isNullAssigned(const\
  \ Stmt *S, CheckerContext &C) {\n  const auto *BO = dyn_cast_or_null<BinaryOperator>(S);\n\
  \  if (!BO)\n    return false;\n  if (BO->getOpcode() != BO_Assign)\n    return\
  \ false;\n\n  const Expr *RHS = BO->getRHS();\n  if (!RHS)\n    return false;\n\n\
  \  // Try to evaluate as integer\n  llvm::APSInt Val;\n  if (EvaluateExprToInt(Val,\
  \ RHS, C)) {\n    if (Val == 0)\n      return true;\n  }\n\n  // Fallback: check\
  \ for null pointer constant\n  if (RHS->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull))\n    return true;\n\n  return false;\n}\n\nvoid\
  \ SAGenTestChecker::recordFieldUnderOnlyLock(const Expr *ArgE, CheckerContext &C)\
  \ {\n  if (!ArgE)\n    return;\n  ProgramStateRef State = C.getState();\n  const\
  \ MemRegion *OnlyLock = getOnlyHeldLock(State);\n  if (!OnlyLock)\n    return;\n\
  \n  const MemRegion *FR = getFieldRegionFromExpr(ArgE, C);\n  if (!FR)\n    return;\n\
  \n  // Use the base region of the field as key to follow the suggestion\n  const\
  \ MemRegion *FieldKey = FR->getBaseRegion();\n  if (!FieldKey)\n    return;\n\n\
  \  State = State->set<ProtectedFieldToLock>(FieldKey, OnlyLock);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::recordFieldUnderOnlyLockFromLoc(SVal Loc, CheckerContext\
  \ &C) {\n  const MemRegion *MR = Loc.getAsRegion();\n  if (!MR)\n    return;\n\n\
  \  const MemRegion *FR = getFieldRegionFromLoc(MR);\n  if (!FR)\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n  const MemRegion *OnlyLock = getOnlyHeldLock(State);\n\
  \  if (!OnlyLock)\n    return;\n\n  const MemRegion *FieldKey = FR->getBaseRegion();\n\
  \  if (!FieldKey)\n    return;\n\n  State = State->set<ProtectedFieldToLock>(FieldKey,\
  \ OnlyLock);\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Update held locks\n  if (isSpinLock(Call, C)) {\n    if (const MemRegion\
  \ *LockReg = getLockRegionFromArg(Call, C)) {\n      State = State->add<HeldLocks>(LockReg);\n\
  \      C.addTransition(State);\n    }\n    return;\n  }\n\n  if (isSpinUnlock(Call,\
  \ C)) {\n    if (const MemRegion *LockReg = getLockRegionFromArg(Call, C)) {\n \
  \     State = State->remove<HeldLocks>(LockReg);\n      C.addTransition(State);\n\
  \    }\n    return;\n  }\n\n  // Record fields passed to calls while exactly one\
  \ lock is held\n  const MemRegion *OnlyLock = getOnlyHeldLock(State);\n  if (!OnlyLock)\n\
  \    return;\n\n  // For each argument, if it's a field like obj->ptr, record its\
  \ protecting lock\n  for (unsigned I = 0, N = Call.getNumArgs(); I < N; ++I) {\n\
  \    const Expr *AE = Call.getArgExpr(I);\n    recordFieldUnderOnlyLock(AE, C);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt\
  \ *S, CheckerContext &C) const {\n  if (!IsLoad)\n    return;\n\n  // If exactly\
  \ one lock is held and we are reading a field, record protection\n  recordFieldUnderOnlyLockFromLoc(Loc,\
  \ C);\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S,\
  \ CheckerContext &C) const {\n  // Detect store of NULL to a protected field outside\
  \ its protecting lock\n  const MemRegion *LReg = Loc.getAsRegion();\n  if (!LReg)\n\
  \    return;\n\n  const MemRegion *FR = getFieldRegionFromLoc(LReg);\n  if (!FR)\n\
  \    return;\n\n  if (!isNullAssigned(S, C))\n    return;\n\n  ProgramStateRef State\
  \ = C.getState();\n  const MemRegion *FieldKey = FR->getBaseRegion();\n  if (!FieldKey)\n\
  \    return;\n\n  const MemRegion *ProtLock = State->get<ProtectedFieldToLock>(FieldKey);\n\
  \  if (!ProtLock)\n    return; // We only warn for fields we have seen used under\
  \ a lock\n\n  // Are we currently holding the protecting lock?\n  if (State->contains<HeldLocks>(ProtLock))\n\
  \    return;\n\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n\
  \    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT,\
  \ \"Clearing pointer outside its protecting lock; may race with check-then-use\"\
  , N);\n  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects clearing shared pointers outside protecting spinlock (possible\
  \ check-then-use race)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nusb: dwc2: fix possible NULL pointer dereference caused\
  \ by driver concurrency\n\nIn _dwc2_hcd_urb_enqueue(), \"urb->hcpriv = NULL\" is\
  \ executed without\nholding the lock \"hsotg->lock\". In _dwc2_hcd_urb_dequeue():\n\
  \n    spin_lock_irqsave(&hsotg->lock, flags);\n    ...\n\tif (!urb->hcpriv) {\n\t\
  \tdev_dbg(hsotg->dev, \"## urb->hcpriv is NULL ##\\n\");\n\t\tgoto out;\n\t}\n \
  \   rc = dwc2_hcd_urb_dequeue(hsotg, urb->hcpriv); // Use urb->hcpriv\n    ...\n\
  out:\n    spin_unlock_irqrestore(&hsotg->lock, flags);\n\nWhen _dwc2_hcd_urb_enqueue()\
  \ and _dwc2_hcd_urb_dequeue() are\nconcurrently executed, the NULL check of \"urb->hcpriv\"\
  \ can be executed\nbefore \"urb->hcpriv = NULL\". After urb->hcpriv is NULL, it\
  \ can be used\nin the function call to dwc2_hcd_urb_dequeue(), which can cause a\
  \ NULL\npointer dereference.\n\nThis possible bug is found by an experimental static\
  \ analysis tool\ndeveloped by myself. This tool analyzes the locking APIs to extract\n\
  function pairs that can be concurrently executed, and then analyzes the\ninstructions\
  \ in the paired functions to identify possible concurrency\nbugs including data\
  \ races and atomicity violations. The above possible\nbug is reported, when my tool\
  \ analyzes the source code of Linux 6.5.\n\nTo fix this possible bug, \"urb->hcpriv\
  \ = NULL\" should be executed with\nholding the lock \"hsotg->lock\". After using\
  \ this patch, my tool never\nreports the possible bug, with the kernelconfiguration\
  \ allyesconfig for\nx86_64. Because I have no associated hardware, I cannot test\
  \ the patch\nin runtime testing, and just verify it according to the code logic.\n\
  \nFixes: 33ad261aa62b (\"usb: dwc2: host: spinlock urb_enqueue\")\nSigned-off-by:\
  \ Jia-Ju Bai <baijiaju@buaa.edu.cn>\nLink: https://lore.kernel.org/r/20230926024404.832096-1-baijiaju@buaa.edu.cn\n\
  Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n\n## Buggy Code\n\
  \n```c\n// Function: _dwc2_hcd_urb_enqueue in drivers/usb/dwc2/hcd.c\nstatic int\
  \ _dwc2_hcd_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\t gfp_t mem_flags)\n\
  {\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tstruct usb_host_endpoint\
  \ *ep = urb->ep;\n\tstruct dwc2_hcd_urb *dwc2_urb;\n\tint i;\n\tint retval;\n\t\
  int alloc_bandwidth = 0;\n\tu8 ep_type = 0;\n\tu32 tflags = 0;\n\tvoid *buf;\n\t\
  unsigned long flags;\n\tstruct dwc2_qh *qh;\n\tbool qh_allocated = false;\n\tstruct\
  \ dwc2_qtd *qtd;\n\tstruct dwc2_gregs_backup *gr;\n\n\tgr = &hsotg->gr_backup;\n\
  \n\tif (dbg_urb(urb)) {\n\t\tdev_vdbg(hsotg->dev, \"DWC OTG HCD URB Enqueue\\n\"\
  );\n\t\tdwc2_dump_urb_info(hcd, urb, \"urb_enqueue\");\n\t}\n\n\tif (hsotg->hibernated)\
  \ {\n\t\tif (gr->gotgctl & GOTGCTL_CURMODE_HOST)\n\t\t\tretval = dwc2_exit_hibernation(hsotg,\
  \ 0, 0, 1);\n\t\telse\n\t\t\tretval = dwc2_exit_hibernation(hsotg, 0, 0, 0);\n\n\
  \t\tif (retval)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit hibernation failed.\\\
  n\");\n\t}\n\n\tif (hsotg->in_ppd) {\n\t\tretval = dwc2_exit_partial_power_down(hsotg,\
  \ 0, true);\n\t\tif (retval)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit partial_power_down\
  \ failed\\n\");\n\t}\n\n\tif (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_NONE\
  \ &&\n\t    hsotg->bus_suspended) {\n\t\tif (dwc2_is_device_mode(hsotg))\n\t\t\t\
  dwc2_gadget_exit_clock_gating(hsotg, 0);\n\t\telse\n\t\t\tdwc2_host_exit_clock_gating(hsotg,\
  \ 0);\n\t}\n\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tif (usb_pipetype(urb->pipe) ==\
  \ PIPE_ISOCHRONOUS ||\n\t    usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {\n\t\t\
  spin_lock_irqsave(&hsotg->lock, flags);\n\t\tif (!dwc2_hcd_is_bandwidth_allocated(hsotg,\
  \ ep))\n\t\t\talloc_bandwidth = 1;\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\
  \t}\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_CONTROL:\n\t\tep_type =\
  \ USB_ENDPOINT_XFER_CONTROL;\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\t\tep_type\
  \ = USB_ENDPOINT_XFER_ISOC;\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tep_type = USB_ENDPOINT_XFER_BULK;\n\
  \t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tep_type = USB_ENDPOINT_XFER_INT;\n\t\tbreak;\n\
  \t}\n\n\tdwc2_urb = dwc2_hcd_urb_alloc(hsotg, urb->number_of_packets,\n\t\t\t\t\
  \      mem_flags);\n\tif (!dwc2_urb)\n\t\treturn -ENOMEM;\n\n\tdwc2_hcd_urb_set_pipeinfo(hsotg,\
  \ dwc2_urb, usb_pipedevice(urb->pipe),\n\t\t\t\t  usb_pipeendpoint(urb->pipe), ep_type,\n\
  \t\t\t\t  usb_pipein(urb->pipe),\n\t\t\t\t  usb_endpoint_maxp(&ep->desc),\n\t\t\t\
  \t  usb_endpoint_maxp_mult(&ep->desc));\n\n\tbuf = urb->transfer_buffer;\n\n\tif\
  \ (hcd_uses_dma(hcd)) {\n\t\tif (!buf && (urb->transfer_dma & 3)) {\n\t\t\tdev_err(hsotg->dev,\n\
  \t\t\t\t\"%s: unaligned transfer with no transfer_buffer\",\n\t\t\t\t__func__);\n\
  \t\t\tretval = -EINVAL;\n\t\t\tgoto fail0;\n\t\t}\n\t}\n\n\tif (!(urb->transfer_flags\
  \ & URB_NO_INTERRUPT))\n\t\ttflags |= URB_GIVEBACK_ASAP;\n\tif (urb->transfer_flags\
  \ & URB_ZERO_PACKET)\n\t\ttflags |= URB_SEND_ZERO_PACKET;\n\n\tdwc2_urb->priv =\
  \ urb;\n\tdwc2_urb->buf = buf;\n\tdwc2_urb->dma = urb->transfer_dma;\n\tdwc2_urb->length\
  \ = urb->transfer_buffer_length;\n\tdwc2_urb->setup_packet = urb->setup_packet;\n\
  \tdwc2_urb->setup_dma = urb->setup_dma;\n\tdwc2_urb->flags = tflags;\n\tdwc2_urb->interval\
  \ = urb->interval;\n\tdwc2_urb->status = -EINPROGRESS;\n\n\tfor (i = 0; i < urb->number_of_packets;\
  \ ++i)\n\t\tdwc2_hcd_urb_set_iso_desc_params(dwc2_urb, i,\n\t\t\t\t\t\t urb->iso_frame_desc[i].offset,\n\
  \t\t\t\t\t\t urb->iso_frame_desc[i].length);\n\n\turb->hcpriv = dwc2_urb;\n\tqh\
  \ = (struct dwc2_qh *)ep->hcpriv;\n\t/* Create QH for the endpoint if it doesn't\
  \ exist */\n\tif (!qh) {\n\t\tqh = dwc2_hcd_qh_create(hsotg, dwc2_urb, mem_flags);\n\
  \t\tif (!qh) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail0;\n\t\t}\n\t\tep->hcpriv\
  \ = qh;\n\t\tqh_allocated = true;\n\t}\n\n\tqtd = kzalloc(sizeof(*qtd), mem_flags);\n\
  \tif (!qtd) {\n\t\tretval = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tspin_lock_irqsave(&hsotg->lock,\
  \ flags);\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval)\n\t\tgoto\
  \ fail2;\n\n\tretval = dwc2_hcd_urb_enqueue(hsotg, dwc2_urb, qh, qtd);\n\tif (retval)\n\
  \t\tgoto fail3;\n\n\tif (alloc_bandwidth) {\n\t\tdwc2_allocate_bus_bandwidth(hcd,\n\
  \t\t\t\tdwc2_hcd_get_ep_bandwidth(hsotg, ep),\n\t\t\t\turb);\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock,\
  \ flags);\n\n\treturn 0;\n\nfail3:\n\tdwc2_urb->priv = NULL;\n\tusb_hcd_unlink_urb_from_ep(hcd,\
  \ urb);\n\tif (qh_allocated && qh->channel && qh->channel->qh == qh)\n\t\tqh->channel->qh\
  \ = NULL;\nfail2:\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\turb->hcpriv\
  \ = NULL;\n\tkfree(qtd);\nfail1:\n\tif (qh_allocated) {\n\t\tstruct dwc2_qtd *qtd2,\
  \ *qtd2_tmp;\n\n\t\tep->hcpriv = NULL;\n\t\tdwc2_hcd_qh_unlink(hsotg, qh);\n\t\t\
  /* Free each QTD in the QH's QTD list */\n\t\tlist_for_each_entry_safe(qtd2, qtd2_tmp,\
  \ &qh->qtd_list,\n\t\t\t\t\t qtd_list_entry)\n\t\t\tdwc2_hcd_qtd_unlink_and_free(hsotg,\
  \ qtd2, qh);\n\t\tdwc2_hcd_qh_free(hsotg, qh);\n\t}\nfail0:\n\tkfree(dwc2_urb);\n\
  \n\treturn retval;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/usb/dwc2/hcd.c\
  \ b/drivers/usb/dwc2/hcd.c\nindex 657f1f659ffa..35c7a4df8e71 100644\n--- a/drivers/usb/dwc2/hcd.c\n\
  +++ b/drivers/usb/dwc2/hcd.c\n@@ -4769,8 +4769,8 @@ static int _dwc2_hcd_urb_enqueue(struct\
  \ usb_hcd *hcd, struct urb *urb,\n \tif (qh_allocated && qh->channel && qh->channel->qh\
  \ == qh)\n \t\tqh->channel->qh = NULL;\n fail2:\n-\tspin_unlock_irqrestore(&hsotg->lock,\
  \ flags);\n \turb->hcpriv = NULL;\n+\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\
  \ \tkfree(qtd);\n fail1:\n \tif (qh_allocated) {\n```\n"
pattern: "## Bug Pattern\n\nInconsistent locking on a shared pointer leading to a\
  \ check-then-use race:\n\n- One path reads/checks and then uses a shared pointer\
  \ under a spinlock.\n- Another path clears/modifies the same pointer without holding\
  \ that spinlock (or after unlocking).\n- This allows the pointer to become NULL\
  \ between the reader\u2019s check and use, causing a NULL dereference.\n\nConcrete\
  \ instance:\n- Reader (dequeue) does:\n  spin_lock(&hsotg->lock);\n  if (urb->hcpriv)\n\
  \      use(urb->hcpriv);\n  spin_unlock(&hsotg->lock);\n- Writer (enqueue failure\
  \ path) did:\n  spin_unlock(&hsotg->lock);\n  urb->hcpriv = NULL;  // write outside\
  \ the lock\n\nFix: perform urb->hcpriv = NULL while holding hsotg->lock so all reads/writes\
  \ of the field are serialized by the same lock."
plan: "1) Program state\n\n- REGISTER_SET_WITH_PROGRAMSTATE(HeldLocks, const MemRegion*)\n\
  \  - Tracks the set of lock objects currently held (e.g., the MemRegion of hsotg->lock\
  \ passed to spin_lock/spin_unlock).\n- REGISTER_MAP_WITH_PROGRAMSTATE(ProtectedFieldToLock,\
  \ const MemRegion*, const MemRegion*)\n  - Maps a field\u2019s region (e.g., the\
  \ MemRegion of urb->hcpriv) to the lock region that was observed while this field\
  \ was read/used under lock. This records the \u201Cprotecting lock\u201D for that\
  \ field based on observed usage.\n\n2) Helper utilities\n\n- Recognize lock/unlock\
  \ calls:\n  - isSpinLock(const CallEvent &Call): returns true for \"spin_lock\"\
  , \"spin_lock_irq\", \"spin_lock_irqsave\", \"spin_lock_bh\".\n  - isSpinUnlock(const\
  \ CallEvent &Call): returns true for \"spin_unlock\", \"spin_unlock_irq\", \"spin_unlock_irqrestore\"\
  , \"spin_unlock_bh\".\n- Extract lock region from call:\n  - getLockRegionFromArg(const\
  \ CallEvent &Call): for spin_lock* and spin_unlock*, get MemRegion from first argument.\
  \ If the argument is a UnaryOperator UO_AddrOf, use its subexpression. Use getMemRegionFromExpr\
  \ for the final expression.\n- Identify field regions:\n  - getFieldRegionFromExpr(const\
  \ Expr *E, CheckerContext &C): try getMemRegionFromExpr(E, C); return it if it\u2019\
  s a FieldRegion (or a region whose super-region is a FieldRegion). If not, try findSpecificTypeInChildren<MemberExpr>(E)\
  \ and then get its region.\n- Get the uniquely-held lock (to avoid ambiguity):\n\
  \  - getOnlyHeldLock(ProgramStateRef State): if HeldLocks contains exactly one MemRegion*,\
  \ return it; else return nullptr.\n- Determine RHS is NULL:\n  - isNullAssigned(const\
  \ Stmt *S, CheckerContext &C): if S is a BinaryOperator with opcode BO_Assign, evaluate\
  \ RHS with EvaluateExprToInt and check it equals 0.\n\n3) Callback selection and\
  \ logic\n\nA) checkPostCall(const CallEvent &Call, CheckerContext &C) const\n\n\
  - Update HeldLocks:\n  - If isSpinLock(Call):\n    - LockRegion = getLockRegionFromArg(Call).\n\
  \    - If LockRegion != nullptr: insert it into HeldLocks set in state.\n  - If\
  \ isSpinUnlock(Call):\n    - LockRegion = getLockRegionFromArg(Call).\n    - If\
  \ LockRegion != nullptr: remove it from HeldLocks set in state.\n\n- Record fields\
  \ used under lock via call arguments:\n  - If HeldLocks size is exactly 1 (use getOnlyHeldLock):\n\
  \    - For each argument Arg in Call:\n      - FR = getFieldRegionFromExpr(Arg,\
  \ C).\n      - If FR != nullptr: set ProtectedFieldToLock[FR] = OnlyHeldLock.\n\
  \  - Rationale: Passing a pointer field to a function while holding a single lock\
  \ implies that field is expected to be protected by that lock.\n\nB) checkLocation(SVal\
  \ Loc, bool IsLoad, const Stmt *S, CheckerContext &C) const\n\n- Record reads of\
  \ fields under lock:\n  - If IsLoad and getOnlyHeldLock(State) != nullptr:\n   \
  \ - If Loc.getAsRegion() is a FieldRegion (or has a FieldRegion super-region):\n\
  \      - Record ProtectedFieldToLock[FieldRegion] = OnlyHeldLock.\n  - Rationale:\
  \ Reading a field while holding the lock also establishes the protecting lock for\
  \ that field.\n\nC) checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext\
  \ &C) const\n\n- Detect store of NULL to a protected field outside of its protecting\
  \ lock:\n  - FR = Loc.getAsRegion() (or super-region if needed) as FieldRegion;\
  \ if not a FieldRegion, return.\n  - Check if S is an assignment to NULL: if not\
  \ isNullAssigned(S, C), return.\n  - Look up ProtectedFieldToLock[FR] = PL. If no\
  \ mapping, return (we only warn for fields we have seen used under lock).\n  - Check\
  \ current locks:\n    - If HeldLocks does not contain PL (i.e., !HeldLocks.contains(PL)):\n\
  \      - Report bug: create a non-fatal error node and emit a PathSensitiveBugReport\
  \ with a short message, e.g., \"Clearing shared pointer outside its protecting lock;\
  \ possible check-then-use race\".\n  - Rationale: If a field is known to be accessed\
  \ under a specific lock, clearing it to NULL without holding that lock can race\
  \ with check-then-use on other paths.\n\n4) Optional minor robustness\n\n- Also\
  \ in checkPreCall, for dereferencing functions:\n  - Optionally use functionKnownToDeref(Call,\
  \ DerefParams). For any Arg index in DerefParams, treat Arg as \u201Cused,\u201D\
  \ and record FieldRegion->OnlyHeldLock as above. This can reduce false positives\
  \ for calls that pass pointers but are not used.\n- Handle multiple locks:\n  -\
  \ If multiple locks are held, skip recording the protection (to avoid ambiguity).\
  \ The plan already does this by requiring exactly one held lock when recording.\n\
  - Clean-up:\n  - No special clean-up is required; ProgramState traits are path-sensitive\
  \ and will be discarded at path end.\n\n5) Reporting\n\n- Use a single BugType stored\
  \ as a checker member, created lazily when first reporting.\n- Create reports with:\n\
  \  - generateNonFatalErrorNode() to get node.\n  - PathSensitiveBugReport with message:\
  \ \"Clearing pointer outside its protecting lock; may race with check-then-use\"\
  .\n- Keep messages short and clear as requested.\n\n6) Summary of detection flow\n\
  \n- Learn protecting lock: When a field like urb->hcpriv is read or passed to a\
  \ function under exactly one held lock, record ProtectedFieldToLock[field] = that\
  \ lock.\n- Flag bug: Later, if the same field is assigned NULL and that specific\
  \ lock is not currently held (e.g., just after spin_unlock_irqrestore), emit a warning.\
  \ This captures the inconsistent locking pattern that can lead to a check-then-use\
  \ race and NULL dereference."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\
  \n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\
  \n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\
  #include \"clang/StaticAnalyzer/Checkers/utility.h\"\n#include \"clang/AST/Expr.h\"\
  \n#include \"clang/AST/Decl.h\"\n#include \"clang/Lex/Lexer.h\"\n\nusing namespace\
  \ clang;\nusing namespace ento;\nusing namespace taint;\n\n// Program states\nREGISTER_SET_WITH_PROGRAMSTATE(HeldLocks,\
  \ const MemRegion*)\nREGISTER_MAP_WITH_PROGRAMSTATE(ProtectedFieldToLock, const\
  \ MemRegion*, const MemRegion*)\n\nnamespace {\n\nclass SAGenTestChecker : public\
  \ Checker<check::PostCall, check::Location, check::Bind> {\n   mutable std::unique_ptr<BugType>\
  \ BT;\n\n   public:\n      SAGenTestChecker() : BT(new BugType(this, \"Inconsistent\
  \ locking\", \"Concurrency\")) {}\n\n      void checkPostCall(const CallEvent &Call,\
  \ CheckerContext &C) const;\n      void checkLocation(SVal Loc, bool IsLoad, const\
  \ Stmt *S, CheckerContext &C) const;\n      void checkBind(SVal Loc, SVal Val, const\
  \ Stmt *S, CheckerContext &C) const;\n\n   private:\n\n      // Helpers\n      static\
  \ bool isSpinLock(const CallEvent &Call, CheckerContext &C);\n      static bool\
  \ isSpinUnlock(const CallEvent &Call, CheckerContext &C);\n      static const MemRegion*\
  \ getLockRegionFromArg(const CallEvent &Call, CheckerContext &C);\n      static\
  \ const MemRegion* getFieldRegionFromExpr(const Expr *E, CheckerContext &C);\n \
  \     static const MemRegion* getFieldRegionFromLoc(const MemRegion *MR);\n    \
  \  static const MemRegion* getOnlyHeldLock(ProgramStateRef State);\n      static\
  \ bool isNullAssigned(const Stmt *S, CheckerContext &C);\n\n      static void recordFieldUnderOnlyLock(const\
  \ Expr *ArgE, CheckerContext &C);\n      static void recordFieldUnderOnlyLockFromLoc(SVal\
  \ Loc, CheckerContext &C);\n};\n\nbool SAGenTestChecker::isSpinLock(const CallEvent\
  \ &Call, CheckerContext &C) {\n  const Expr *E = Call.getOriginExpr();\n  if (!E)\
  \ return false;\n  return ExprHasName(E, \"spin_lock\", C) ||\n         ExprHasName(E,\
  \ \"spin_lock_irqsave\", C) ||\n         ExprHasName(E, \"spin_lock_irq\", C) ||\n\
  \         ExprHasName(E, \"spin_lock_bh\", C);\n}\n\nbool SAGenTestChecker::isSpinUnlock(const\
  \ CallEvent &Call, CheckerContext &C) {\n  const Expr *E = Call.getOriginExpr();\n\
  \  if (!E) return false;\n  return ExprHasName(E, \"spin_unlock\", C) ||\n     \
  \    ExprHasName(E, \"spin_unlock_irqrestore\", C) ||\n         ExprHasName(E, \"\
  spin_unlock_irq\", C) ||\n         ExprHasName(E, \"spin_unlock_bh\", C);\n}\n\n\
  const MemRegion* SAGenTestChecker::getFieldRegionFromLoc(const MemRegion *MR) {\n\
  \  if (!MR) return nullptr;\n  // Walk up to find a FieldRegion\n  const MemRegion\
  \ *Cur = MR;\n  while (Cur) {\n    if (isa<FieldRegion>(Cur))\n      return Cur;\n\
  \    if (const auto *SR = dyn_cast<SubRegion>(Cur))\n      Cur = SR->getSuperRegion();\n\
  \    else\n      break;\n  }\n  return nullptr;\n}\n\nconst MemRegion* SAGenTestChecker::getFieldRegionFromExpr(const\
  \ Expr *E, CheckerContext &C) {\n  if (!E) return nullptr;\n\n  // Try directly\
  \ from the expression\n  if (const MemRegion *MR = getMemRegionFromExpr(E, C)) {\n\
  \    if (const MemRegion *FR = getFieldRegionFromLoc(MR))\n      return FR;\n  }\n\
  \n  // Try to find a MemberExpr child and get its region\n  if (const auto *ME =\
  \ findSpecificTypeInChildren<MemberExpr>(E)) {\n    if (const MemRegion *MR2 = getMemRegionFromExpr(ME,\
  \ C)) {\n      if (const MemRegion *FR2 = getFieldRegionFromLoc(MR2))\n        return\
  \ FR2;\n    }\n  }\n  return nullptr;\n}\n\nconst MemRegion* SAGenTestChecker::getLockRegionFromArg(const\
  \ CallEvent &Call, CheckerContext &C) {\n  if (Call.getNumArgs() < 1)\n    return\
  \ nullptr;\n\n  const Expr *ArgE = Call.getArgExpr(0);\n  if (!ArgE)\n    return\
  \ nullptr;\n\n  // If it's &obj->lock, peel off the address-of to get the underlying\
  \ object\n  if (const auto *UO = dyn_cast<UnaryOperator>(ArgE)) {\n    if (UO->getOpcode()\
  \ == UO_AddrOf)\n      ArgE = UO->getSubExpr();\n  }\n\n  const MemRegion *MR =\
  \ getMemRegionFromExpr(ArgE, C);\n  if (!MR)\n    return nullptr;\n\n  // Always\
  \ use base region as per suggestions\n  MR = MR->getBaseRegion();\n  return MR;\n\
  }\n\nconst MemRegion* SAGenTestChecker::getOnlyHeldLock(ProgramStateRef State) {\n\
  \  auto Set = State->get<HeldLocks>();\n  const MemRegion *Only = nullptr;\n  unsigned\
  \ Count = 0;\n  for (auto I = Set.begin(), E = Set.end(); I != E; ++I) {\n    Only\
  \ = *I;\n    ++Count;\n    if (Count > 1)\n      return nullptr;\n  }\n  return\
  \ (Count == 1) ? Only : nullptr;\n}\n\nbool SAGenTestChecker::isNullAssigned(const\
  \ Stmt *S, CheckerContext &C) {\n  const auto *BO = dyn_cast_or_null<BinaryOperator>(S);\n\
  \  if (!BO)\n    return false;\n  if (BO->getOpcode() != BO_Assign)\n    return\
  \ false;\n\n  const Expr *RHS = BO->getRHS();\n  if (!RHS)\n    return false;\n\n\
  \  // Try to evaluate as integer\n  llvm::APSInt Val;\n  if (EvaluateExprToInt(Val,\
  \ RHS, C)) {\n    if (Val == 0)\n      return true;\n  }\n\n  // Fallback: check\
  \ for null pointer constant\n  if (RHS->isNullPointerConstant(C.getASTContext(),\
  \ Expr::NPC_ValueDependentIsNull))\n    return true;\n\n  return false;\n}\n\nvoid\
  \ SAGenTestChecker::recordFieldUnderOnlyLock(const Expr *ArgE, CheckerContext &C)\
  \ {\n  if (!ArgE)\n    return;\n  ProgramStateRef State = C.getState();\n  const\
  \ MemRegion *OnlyLock = getOnlyHeldLock(State);\n  if (!OnlyLock)\n    return;\n\
  \n  const MemRegion *FR = getFieldRegionFromExpr(ArgE, C);\n  if (!FR)\n    return;\n\
  \n  // Use the base region of the field as key to follow the suggestion\n  const\
  \ MemRegion *FieldKey = FR->getBaseRegion();\n  if (!FieldKey)\n    return;\n\n\
  \  State = State->set<ProtectedFieldToLock>(FieldKey, OnlyLock);\n  C.addTransition(State);\n\
  }\n\nvoid SAGenTestChecker::recordFieldUnderOnlyLockFromLoc(SVal Loc, CheckerContext\
  \ &C) {\n  const MemRegion *MR = Loc.getAsRegion();\n  if (!MR)\n    return;\n\n\
  \  const MemRegion *FR = getFieldRegionFromLoc(MR);\n  if (!FR)\n    return;\n\n\
  \  ProgramStateRef State = C.getState();\n  const MemRegion *OnlyLock = getOnlyHeldLock(State);\n\
  \  if (!OnlyLock)\n    return;\n\n  const MemRegion *FieldKey = FR->getBaseRegion();\n\
  \  if (!FieldKey)\n    return;\n\n  State = State->set<ProtectedFieldToLock>(FieldKey,\
  \ OnlyLock);\n  C.addTransition(State);\n}\n\nvoid SAGenTestChecker::checkPostCall(const\
  \ CallEvent &Call, CheckerContext &C) const {\n  ProgramStateRef State = C.getState();\n\
  \n  // Update held locks\n  if (isSpinLock(Call, C)) {\n    if (const MemRegion\
  \ *LockReg = getLockRegionFromArg(Call, C)) {\n      State = State->add<HeldLocks>(LockReg);\n\
  \      C.addTransition(State);\n    }\n    return;\n  }\n\n  if (isSpinUnlock(Call,\
  \ C)) {\n    if (const MemRegion *LockReg = getLockRegionFromArg(Call, C)) {\n \
  \     State = State->remove<HeldLocks>(LockReg);\n      C.addTransition(State);\n\
  \    }\n    return;\n  }\n\n  // Record fields passed to calls while exactly one\
  \ lock is held\n  const MemRegion *OnlyLock = getOnlyHeldLock(State);\n  if (!OnlyLock)\n\
  \    return;\n\n  // For each argument, if it's a field like obj->ptr, record its\
  \ protecting lock\n  for (unsigned I = 0, N = Call.getNumArgs(); I < N; ++I) {\n\
  \    const Expr *AE = Call.getArgExpr(I);\n    recordFieldUnderOnlyLock(AE, C);\n\
  \  }\n}\n\nvoid SAGenTestChecker::checkLocation(SVal Loc, bool IsLoad, const Stmt\
  \ *S, CheckerContext &C) const {\n  if (!IsLoad)\n    return;\n\n  // If exactly\
  \ one lock is held and we are reading a field, record protection\n  recordFieldUnderOnlyLockFromLoc(Loc,\
  \ C);\n}\n\nvoid SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *S,\
  \ CheckerContext &C) const {\n  // Detect store of NULL to a protected field outside\
  \ its protecting lock\n  const MemRegion *LReg = Loc.getAsRegion();\n  if (!LReg)\n\
  \    return;\n\n  const MemRegion *FR = getFieldRegionFromLoc(LReg);\n  if (!FR)\n\
  \    return;\n\n  if (!isNullAssigned(S, C))\n    return;\n\n  ProgramStateRef State\
  \ = C.getState();\n  const MemRegion *FieldKey = FR->getBaseRegion();\n  if (!FieldKey)\n\
  \    return;\n\n  const MemRegion *const *ProtLockPtr = State->get<ProtectedFieldToLock>(FieldKey);\n\
  \  if (!ProtLockPtr)\n    return; // We only warn for fields we have seen used under\
  \ a lock\n  const MemRegion *ProtLock = *ProtLockPtr;\n\n  // Are we currently holding\
  \ the protecting lock?\n  if (State->contains<HeldLocks>(ProtLock))\n    return;\n\
  \n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\n\
  \  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Clearing pointer\
  \ outside its protecting lock; may race with check-then-use\", N);\n  if (S)\n \
  \   R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n}\n\n} //\
  \ end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"Detects clearing shared pointers outside protecting spinlock (possible\
  \ check-then-use race)\",\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[]\
  \ =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 0
