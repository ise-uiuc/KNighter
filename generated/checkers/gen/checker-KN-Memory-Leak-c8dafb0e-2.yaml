_base_result_dir: /scratch/chenyuan-data/knighter-dev/result-gpt-5-0814
commit_id: c8dafb0e4398dacc362832098a04b97da3b0395b
commit_type: Memory-Leak
index: 2
initial_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n{{Add your includes here}}\n\nusing namespace clang;\nusing namespace ento;\n\
  using namespace taint;\n\n{{Customize program states}} // If necessary\n// Map:\
  \ return-symbol of hwrm_req_init() -> req MemRegion*\nREGISTER_MAP_WITH_PROGRAMSTATE(PendingInitMap,\
  \ SymbolRef, const MemRegion *)\n// Set: Acquired req MemRegion*s that require hwrm_req_drop()\
  \ before exit\nREGISTER_SET_WITH_PROGRAMSTATE(AcquiredReqs, const MemRegion *)\n\
  \nnamespace {\n\nstatic bool isCallTo(const CallEvent &Call, StringRef Name, CheckerContext\
  \ &C) {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return\
  \ false;\n  return ExprHasName(Origin, Name, C);\n}\n\n/* The checker callbacks\
  \ are to be decided. */\nclass SAGenTestChecker : public Checker<\n    check::PostCall,\n\
  \    check::PreStmt<ReturnStmt>,\n    check::EndFunction,\n    eval::Assume> {\n\
  \   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ : BT(new BugType(this, \"{{Bug Group}}\", \"{{Bug Type}}\")) {\n        // Fill\
  \ reasonable defaults if template placeholders are used:\n        if (BT->getName().empty())\n\
  \          BT.reset(new BugType(this, \"Missing hwrm_req_drop() after hwrm_req_init()\"\
  , \"Resource management\"));\n      }\n\n      void checkPostCall(const CallEvent\
  \ &Call, CheckerContext &C) const;\n      void checkPreStmt(const ReturnStmt *RS,\
  \ CheckerContext &C) const;\n      void checkEndFunction(const ReturnStmt *RS, CheckerContext\
  \ &C) const;\n      ProgramStateRef evalAssume(ProgramStateRef State, SVal Cond,\
  \ bool Assumption) const;\n\n   private:\n\n      void reportLeak(CheckerContext\
  \ &C, const Stmt *S) const;\n};\n\n{{Your Functions: functions should be complete\
  \ and runable}}\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  // Track hwrm_req_init(bp,\
  \ req, ...)\n  if (isCallTo(Call, \"hwrm_req_init\", C)) {\n    // Ensure we have\
  \ at least 2 args: 0: bp, 1: req\n    if (Call.getNumArgs() < 2)\n      return;\n\
  \n    const Expr *ReqExpr = Call.getArgExpr(1);\n    if (!ReqExpr)\n      return;\n\
  \n    const MemRegion *ReqMR = getMemRegionFromExpr(ReqExpr, C);\n    if (!ReqMR)\n\
  \      return;\n    ReqMR = ReqMR->getBaseRegion();\n    if (!ReqMR)\n      return;\n\
  \n    SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\n    if (!RetSym)\n\
  \      return;\n\n    // Record pending init: we'll determine success in evalAssume\n\
  \    State = State->set<PendingInitMap>(RetSym, ReqMR);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // Track hwrm_req_drop(bp, req)\n  if (isCallTo(Call, \"\
  hwrm_req_drop\", C)) {\n    if (Call.getNumArgs() < 2)\n      return;\n\n    const\
  \ Expr *ReqExpr = Call.getArgExpr(1);\n    if (!ReqExpr)\n      return;\n\n    const\
  \ MemRegion *ReqMR = getMemRegionFromExpr(ReqExpr, C);\n    if (!ReqMR)\n      return;\n\
  \    ReqMR = ReqMR->getBaseRegion();\n    if (!ReqMR)\n      return;\n\n    // On\
  \ drop, remove from acquired set (if present)\n    if (State->contains<AcquiredReqs>(ReqMR))\
  \ {\n      State = State->remove<AcquiredReqs>(ReqMR);\n      C.addTransition(State);\n\
  \    }\n    // Optional cleanup of PendingInitMap by region: not strictly necessary\n\
  \    return;\n  }\n}\n\nProgramStateRef SAGenTestChecker::evalAssume(ProgramStateRef\
  \ State, SVal Cond, bool Assumption) const {\n  if (!State)\n    return State;\n\
  \n  // Handle pattern: if (rc) or if (!rc) or if (rc == 0) / if (rc != 0)\n  if\
  \ (Optional<NonLoc> NL = Cond.getAs<NonLoc>()) {\n    // Case 1: plain symbolic\
  \ value 'rc'\n    if (SymbolRef Sym = NL->getAsSymbol()) {\n      const MemRegion\
  \ *const *PendingReq = State->get<PendingInitMap>(Sym);\n      if (PendingReq) {\n\
  \        // if (rc) with Assumption == false means rc == 0 (success)\n        if\
  \ (!Assumption) {\n          State = State->add<AcquiredReqs>(*PendingReq);\n  \
  \      }\n        // Consume the pending mapping either way\n        State = State->remove<PendingInitMap>(Sym);\n\
  \      }\n      return State;\n    }\n\n    // Case 2: symbolic comparison with\
  \ integer, usually rc == 0 or rc != 0\n    if (const SymExpr *SE = NL->getAsSymExpr())\
  \ {\n      if (const BinarySymExpr *BSE = dyn_cast<BinarySymExpr>(SE)) {\n     \
  \   BinaryOperator::Opcode Op = BSE->getOpcode();\n        // We only care about\
  \ comparisons to zero with a symbol on the LHS\n        if (const SymIntExpr *SIE\
  \ = dyn_cast<SymIntExpr>(BSE)) {\n          SymbolRef Sym = SIE->getLHS();\n   \
  \       const llvm::APSInt &RHS = SIE->getRHS();\n          if (Sym) {\n       \
  \     const MemRegion *const *PendingReq = State->get<PendingInitMap>(Sym);\n  \
  \          if (PendingReq && RHS == 0) {\n              bool SuccessBranch = false;\n\
  \              if (Op == BO_EQ && Assumption)\n                SuccessBranch = true;\
  \        // (rc == 0) assumed true\n              else if (Op == BO_NE && !Assumption)\n\
  \                SuccessBranch = true;        // (rc != 0) assumed false\n\n   \
  \           if (SuccessBranch) {\n                State = State->add<AcquiredReqs>(*PendingReq);\n\
  \              }\n              State = State->remove<PendingInitMap>(Sym);\n  \
  \          }\n          }\n        }\n      }\n    }\n  }\n\n  return State;\n}\n\
  \nvoid SAGenTestChecker::checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const\
  \ {\n  if (!RS)\n    return;\n\n  ProgramStateRef State = C.getState();\n  // If\
  \ any acquired req is still live, report a leak.\n  if (!State->get<AcquiredReqs>().isEmpty())\
  \ {\n    reportLeak(C, RS);\n  }\n}\n\nvoid SAGenTestChecker::checkEndFunction(const\
  \ ReturnStmt *RS, CheckerContext &C) const {\n  // Avoid duplicate report if we're\
  \ ending due to an explicit return;\n  // checkPreStmt(ReturnStmt) already handled\
  \ that case.\n  if (RS)\n    return;\n\n  ProgramStateRef State = C.getState();\n\
  \  if (!State->get<AcquiredReqs>().isEmpty()) {\n    reportLeak(C, nullptr);\n \
  \ }\n}\n\nvoid SAGenTestChecker::reportLeak(CheckerContext &C, const Stmt *S) const\
  \ {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n  if (!N)\n    return;\n\
  \n  auto R = std::make_unique<PathSensitiveBugReport>(\n      *BT, \"Missing hwrm_req_drop()\
  \ after successful hwrm_req_init()\", N);\n  if (S)\n    R->addRange(S->getSourceRange());\n\
  \  C.emitReport(std::move(R));\n}\n\n} // end anonymous namespace\n\nextern \"C\"\
  \ void clang_registerCheckers(CheckerRegistry &registry) {\n  registry.addChecker<SAGenTestChecker>(\n\
  \      \"custom.SAGenTestChecker\",\n      \"{{Checker descriptions to be filled}}\"\
  ,\n      \"\");\n}\n\nextern \"C\" const char clang_analyzerAPIVersionString[] =\n\
  \    CLANG_ANALYZER_API_VERSION_STRING;\n"
patch: "## Patch Description\n\nbnxt_en: Fix possible memory leak when hwrm_req_replace\
  \ fails\n\nWhen hwrm_req_replace() fails, the driver is not invoking bnxt_req_drop()\n\
  which could cause a memory leak.\n\nFixes: bbf33d1d9805 (\"bnxt_en: update all firmware\
  \ calls to use the new APIs\")\nReviewed-by: Pavan Chebbi <pavan.chebbi@broadcom.com>\n\
  Signed-off-by: Kalesh AP <kalesh-anakkur.purayil@broadcom.com>\nSigned-off-by: Michael\
  \ Chan <michael.chan@broadcom.com>\nLink: https://patch.msgid.link/20250104043849.3482067-2-michael.chan@broadcom.com\n\
  Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n\n## Buggy Code\n\n```c\n// Function:\
  \ bnxt_send_msg in drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\nint bnxt_send_msg(struct\
  \ bnxt_en_dev *edev,\n\t\t\t struct bnxt_fw_msg *fw_msg)\n{\n\tstruct net_device\
  \ *dev = edev->net;\n\tstruct bnxt *bp = netdev_priv(dev);\n\tstruct output *resp;\n\
  \tstruct input *req;\n\tu32 resp_len;\n\tint rc;\n\n\tif (bp->fw_reset_state)\n\t\
  \treturn -EBUSY;\n\n\trc = hwrm_req_init(bp, req, 0 /* don't care */);\n\tif (rc)\n\
  \t\treturn rc;\n\n\trc = hwrm_req_replace(bp, req, fw_msg->msg, fw_msg->msg_len);\n\
  \tif (rc)\n\t\treturn rc;\n\n\thwrm_req_timeout(bp, req, fw_msg->timeout);\n\tresp\
  \ = hwrm_req_hold(bp, req);\n\trc = hwrm_req_send(bp, req);\n\tresp_len = le16_to_cpu(resp->resp_len);\n\
  \tif (resp_len) {\n\t\tif (fw_msg->resp_max_len < resp_len)\n\t\t\tresp_len = fw_msg->resp_max_len;\n\
  \n\t\tmemcpy(fw_msg->resp, resp, resp_len);\n\t}\n\thwrm_req_drop(bp, req);\n\t\
  return rc;\n}\n```\n\n## Bug Fix Patch\n\n```diff\ndiff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\
  \ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\nindex b771c84cdd89..0ed26e3a28f4\
  \ 100644\n--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\n+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\n\
  @@ -208,7 +208,7 @@ int bnxt_send_msg(struct bnxt_en_dev *edev,\n \n \trc = hwrm_req_replace(bp,\
  \ req, fw_msg->msg, fw_msg->msg_len);\n \tif (rc)\n-\t\treturn rc;\n+\t\tgoto drop_req;\n\
  \ \n \thwrm_req_timeout(bp, req, fw_msg->timeout);\n \tresp = hwrm_req_hold(bp,\
  \ req);\n@@ -220,6 +220,7 @@ int bnxt_send_msg(struct bnxt_en_dev *edev,\n \n \t\
  \tmemcpy(fw_msg->resp, resp, resp_len);\n \t}\n+drop_req:\n \thwrm_req_drop(bp,\
  \ req);\n \treturn rc;\n }\n```\n"
pattern: "## Bug Pattern\n\nAllocating/initializing an HWRM request with hwrm_req_init()\
  \ and then, on a subsequent failure (e.g., hwrm_req_replace() error), returning\
  \ without calling hwrm_req_drop() to release the request buffer.\n\nPattern example:\n\
  rc = hwrm_req_init(bp, req, ...);\nif (rc)\n    return rc;\n\nrc = hwrm_req_replace(bp,\
  \ req, ...);\nif (rc)\n    return rc;  // BUG: missing hwrm_req_drop(bp, req) ->\
  \ leak\n\nAny exit after a successful hwrm_req_init() must call hwrm_req_drop();\
  \ missing this cleanup on error paths causes a memory leak."
plan: "Plan to detect missing hwrm_req_drop() after successful hwrm_req_init()\n\n\
  1) Program states\n- Register a map to remember which req pointer is associated\
  \ with a particular hwrm_req_init() return symbol:\n  - REGISTER_MAP_WITH_PROGRAMSTATE(PendingInitMap,\
  \ SymbolRef, const MemRegion*)\n    - Key: the SymbolRef of the return value of\
  \ hwrm_req_init()\n    - Value: the MemRegion of the req argument passed to hwrm_req_init()\n\
  - Register a set to track \u201Cacquired\u201D req pointers that must be released\
  \ by hwrm_req_drop() before any exit:\n  - REGISTER_SET_WITH_PROGRAMSTATE(AcquiredReqs,\
  \ const MemRegion*)\n\nRationale:\n- PendingInitMap lets us decide, at the condition\
  \ split, whether hwrm_req_init() succeeded (return == 0).\n- AcquiredReqs tracks\
  \ all req pointers that are live and require hwrm_req_drop().\n\n2) Callback selection\
  \ and implementation details\n\nA) checkPostCall (identify hwrm_req_init and hwrm_req_drop)\n\
  - Detect callee by name via Call.getCalleeIdentifier()->getName().\n- For hwrm_req_init:\n\
  \  - Retrieve the second argument expression (index 1) as the req argument.\n  -\
  \ Obtain its MemRegion using getMemRegionFromExpr(Call.getArgExpr(1), C).\n  - Extract\
  \ the return value symbol: SymbolRef RetSym = Call.getReturnValue().getAsSymbol().\n\
  \  - If both RetSym and req region are valid, add to PendingInitMap[RetSym] = ReqRegion.\n\
  \  - Do not mark it as acquired yet; acquisition is only on the success path (ret\
  \ == 0).\n- For hwrm_req_drop:\n  - Retrieve the second argument (index 1) as the\
  \ req argument and get its MemRegion.\n  - If non-null, remove ReqRegion from AcquiredReqs\
  \ (state = State->remove<AcquiredReqs>(ReqRegion)).\n  - Also remove any entries\
  \ in PendingInitMap that map to this same ReqRegion (iterate map and erase matches)\
  \ to avoid stale pending data.\n\nB) evalAssume (turn a successful init into an\
  \ acquired resource)\n- Purpose: If the engine is assuming a condition that implies\
  \ hwrm_req_init() returned 0, then the req becomes acquired.\n- Obtain Cond\u2019\
  s symbolic form and match against PendingInitMap keys:\n  - Case 1: Condition is\
  \ a plain symbol (e.g., if (rc)):\n    - If Cond.getAsSymbol() returns a symbol\
  \ found in PendingInitMap:\n      - If Assumption == false (meaning rc is false\
  \ => rc == 0), then:\n        - Add the associated ReqRegion to AcquiredReqs.\n\
  \      - In either branch (true or false), remove this symbol from PendingInitMap\
  \ (the check on rc has been consumed).\n  - Case 2: Condition is a SymIntExpr (e.g.,\
  \ rc == 0, rc != 0):\n    - If Cond is NonLoc::SymIntExpr (or equivalent), extract:\n\
  \      - The symbol on one side and the integer constant on the other.\n      -\
  \ Only handle comparisons with zero (== 0 or != 0).\n      - If the symbol is found\
  \ in PendingInitMap and the integer is 0:\n        - If (op == BO_EQ && Assumption\
  \ == true) OR (op == BO_NE && Assumption == false), then success branch (ret ==\
  \ 0):\n          - Add the associated ReqRegion to AcquiredReqs.\n        - Remove\
  \ the symbol from PendingInitMap in either case.\n  - Note: We only need to reliably\
  \ handle the common patterns (if (rc), if (rc != 0), if (rc == 0)). This covers\
  \ the canonical Linux style of checking rc.\n\nC) checkPostCall (optional cleanup\
  \ for \u201Crc\u201D reuse)\n- If you want to be conservative, when you see subsequent\
  \ direct uses of the same rc symbol in other contexts, no action needed\u2014the\
  \ engine\u2019s assumptions will drive evalAssume. No extra work here.\n\nD) checkPreStmt(const\
  \ ReturnStmt *)\n- On every return:\n  - If AcquiredReqs is non-empty, emit a report:\n\
  \    - Message: \"missing hwrm_req_drop() after successful hwrm_req_init()\"\n \
  \   - Create a non-fatal error node and a PathSensitiveBugReport.\n  - This precisely\
  \ flags early returns that leak the request when a prior hwrm_req_init() succeeded,\
  \ but hwrm_req_drop() hasn\u2019t yet been called.\n\nE) checkEndFunction\n- Also\
  \ check at normal function end (implicit return without explicit ReturnStmt):\n\
  \  - If AcquiredReqs is non-empty, emit the same report.\n- This ensures leaks are\
  \ reported even if the function falls through to the end without returning via ReturnStmt.\n\
  \nF) State hygiene (optional)\n- On function begin (checkBeginFunction), ensure\
  \ both PendingInitMap and AcquiredReqs are empty for a new top frame.\n- This prevents\
  \ cross-function contamination.\n\n3) Matching and extraction details\n- Function\
  \ name checks:\n  - hwrm_req_init: create PendingInitMap entry for (ret_sym -> req_region).\n\
  \  - hwrm_req_drop: remove req_region from AcquiredReqs and purge any corresponding\
  \ PendingInitMap entries.\n- Getting the req region:\n  - Use getMemRegionFromExpr(Call.getArgExpr(1),\
  \ C). If null, skip tracking for this call.\n- Handling multiple acquisitions:\n\
  \  - The set can hold multiple req regions. On return/end, if any remain, report\
  \ (optionally, one report per req; simplest: one report if set non-empty).\n- No\
  \ alias tracking needed:\n  - The req pointer variable is passed around as-is in\
  \ these APIs; aliasing is uncommon for this particular pattern.\n\n4) Reporting\n\
  - Use PathSensitiveBugReport with a short message:\n  - \"Missing hwrm_req_drop()\
  \ on error path after hwrm_req_init()\"\n- Attach the ReturnStmt location as the\
  \ primary location.\n- Optionally, add a note at the hwrm_req_init() call site when\
  \ you create the PendingInitMap entry (store SourceLocation in a side map if desired),\
  \ but keep it simple if not needed.\n\n5) Why this works for the target patch\n\
  - After hwrm_req_init() and the immediate \u201Cif (rc) return rc;\u201D:\n  - On\
  \ the false branch (rc == 0), AcquiredReqs records the req.\n- If a later call (e.g.,\
  \ hwrm_req_replace) fails and returns early:\n  - At the ReturnStmt, AcquiredReqs\
  \ is still non-empty because hwrm_req_drop() wasn\u2019t called yet, so we warn.\n\
  - If code uses goto to a label that calls hwrm_req_drop() and then returns:\n  -\
  \ The post-call hook for hwrm_req_drop() clears AcquiredReqs, so no warning is emitted.\n\
  \n6) Used utility functions\n- getMemRegionFromExpr: to resolve the MemRegion of\
  \ the req argument.\n- ExprHasName, findSpecificTypeInParents/Children, EvaluateExprToInt,\
  \ inferSymbolMaxVal, getArraySizeFromExpr, getStringSize: not needed for this pattern.\n\
  \n7) Callbacks summary\n- Must implement:\n  - checkPostCall: track hwrm_req_init\
  \ and hwrm_req_drop.\n  - evalAssume: convert \u201Cinit return == 0\u201D into\
  \ \u201Creq is acquired\u201D.\n  - checkPreStmt(ReturnStmt): report if acquired\
  \ reqs exist at return.\n  - checkEndFunction: report if acquired reqs exist at\
  \ function end.\n- Optional:\n  - checkBeginFunction: clear state at function entry.\n\
  \nThis is the simplest, path-sensitive approach to catch any return path after a\
  \ successful hwrm_req_init() that misses hwrm_req_drop(), including the exact pattern\
  \ fixed by the patch."
refined_plan: null
repaired_checker_code: "#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\
  \n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Checkers/Taint.h\"\
  \n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/Environment.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\
  \n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include\
  \ \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/StaticAnalyzer/Frontend/CheckerRegistry.h\"\
  \n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\
  \n#include \"llvm/Support/raw_ostream.h\"\n#include \"clang/StaticAnalyzer/Checkers/utility.h\"\
  \n#include <memory>\n#include <optional>\n\nusing namespace clang;\nusing namespace\
  \ ento;\nusing namespace taint;\n\n// Map: return-symbol of hwrm_req_init() -> req\
  \ MemRegion*\nREGISTER_MAP_WITH_PROGRAMSTATE(PendingInitMap, SymbolRef, const MemRegion\
  \ *)\n// Set: Acquired req MemRegion*s that require hwrm_req_drop() before exit\n\
  REGISTER_SET_WITH_PROGRAMSTATE(AcquiredReqs, const MemRegion *)\n\nnamespace {\n\
  \nstatic bool isCallTo(const CallEvent &Call, StringRef Name, CheckerContext &C)\
  \ {\n  const Expr *Origin = Call.getOriginExpr();\n  if (!Origin)\n    return false;\n\
  \  return ExprHasName(Origin, Name, C);\n}\n\n/* The checker callbacks are to be\
  \ decided. */\nclass SAGenTestChecker : public Checker<\n    check::PostCall,\n\
  \    check::PreStmt<ReturnStmt>,\n    check::EndFunction,\n    eval::Assume> {\n\
  \   mutable std::unique_ptr<BugType> BT;\n\n   public:\n      SAGenTestChecker()\
  \ {\n        BT = std::make_unique<BugType>(\n            this,\n            \"\
  Missing hwrm_req_drop() after hwrm_req_init()\",\n            \"Resource management\"\
  );\n      }\n\n      void checkPostCall(const CallEvent &Call, CheckerContext &C)\
  \ const;\n      void checkPreStmt(const ReturnStmt *RS, CheckerContext &C) const;\n\
  \      void checkEndFunction(const ReturnStmt *RS, CheckerContext &C) const;\n \
  \     ProgramStateRef evalAssume(ProgramStateRef State, SVal Cond, bool Assumption)\
  \ const;\n\n   private:\n\n      void reportLeak(CheckerContext &C, const Stmt *S)\
  \ const;\n};\n\nvoid SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext\
  \ &C) const {\n  ProgramStateRef State = C.getState();\n\n  // Track hwrm_req_init(bp,\
  \ req, ...)\n  if (isCallTo(Call, \"hwrm_req_init\", C)) {\n    // Ensure we have\
  \ at least 2 args: 0: bp, 1: req\n    if (Call.getNumArgs() < 2)\n      return;\n\
  \n    const Expr *ReqExpr = Call.getArgExpr(1);\n    if (!ReqExpr)\n      return;\n\
  \n    const MemRegion *ReqMR = getMemRegionFromExpr(ReqExpr, C);\n    if (!ReqMR)\n\
  \      return;\n    ReqMR = ReqMR->getBaseRegion();\n    if (!ReqMR)\n      return;\n\
  \n    SymbolRef RetSym = Call.getReturnValue().getAsSymbol();\n    if (!RetSym)\n\
  \      return;\n\n    // Record pending init: we'll determine success in evalAssume\n\
  \    State = State->set<PendingInitMap>(RetSym, ReqMR);\n    C.addTransition(State);\n\
  \    return;\n  }\n\n  // Track hwrm_req_drop(bp, req)\n  if (isCallTo(Call, \"\
  hwrm_req_drop\", C)) {\n    if (Call.getNumArgs() < 2)\n      return;\n\n    const\
  \ Expr *ReqExpr = Call.getArgExpr(1);\n    if (!ReqExpr)\n      return;\n\n    const\
  \ MemRegion *ReqMR = getMemRegionFromExpr(ReqExpr, C);\n    if (!ReqMR)\n      return;\n\
  \    ReqMR = ReqMR->getBaseRegion();\n    if (!ReqMR)\n      return;\n\n    // On\
  \ drop, remove from acquired set (if present)\n    auto Set = State->get<AcquiredReqs>();\n\
  \    if (Set.contains(ReqMR)) {\n      State = State->remove<AcquiredReqs>(ReqMR);\n\
  \      C.addTransition(State);\n    }\n    return;\n  }\n}\n\nProgramStateRef SAGenTestChecker::evalAssume(ProgramStateRef\
  \ State, SVal Cond, bool Assumption) const {\n  if (!State)\n    return State;\n\
  \n  // Handle pattern: if (rc) or if (!rc) or if (rc == 0) / if (rc != 0)\n  if\
  \ (std::optional<NonLoc> NL = Cond.getAs<NonLoc>()) {\n    // Case 1: plain symbolic\
  \ value 'rc'\n    if (SymbolRef Sym = NL->getAsSymbol()) {\n      const MemRegion\
  \ *const *PendingReq = State->get<PendingInitMap>(Sym);\n      if (PendingReq) {\n\
  \        // if (rc) with Assumption == false means rc == 0 (success)\n        if\
  \ (!Assumption) {\n          State = State->add<AcquiredReqs>(*PendingReq);\n  \
  \      }\n        // Consume the pending mapping either way\n        State = State->remove<PendingInitMap>(Sym);\n\
  \      }\n      return State;\n    }\n\n    // Case 2: symbolic comparison with\
  \ integer, usually rc == 0 or rc != 0\n    if (SymbolRef SE = Cond.getAsSymbol())\
  \ {\n      if (const auto *SIE = dyn_cast<SymIntExpr>(SE)) {\n        BinaryOperator::Opcode\
  \ Op = SIE->getOpcode();\n        SymbolRef Sym = SIE->getLHS();\n        const\
  \ llvm::APSInt &RHS = SIE->getRHS();\n        if (Sym) {\n          const MemRegion\
  \ *const *PendingReq = State->get<PendingInitMap>(Sym);\n          if (PendingReq\
  \ && RHS == 0) {\n            bool SuccessBranch = false;\n            if (Op ==\
  \ BO_EQ && Assumption)\n              SuccessBranch = true;        // (rc == 0)\
  \ assumed true\n            else if (Op == BO_NE && !Assumption)\n             \
  \ SuccessBranch = true;        // (rc != 0) assumed false\n\n            if (SuccessBranch)\
  \ {\n              State = State->add<AcquiredReqs>(*PendingReq);\n            }\n\
  \            State = State->remove<PendingInitMap>(Sym);\n          }\n        }\n\
  \      }\n    }\n  }\n\n  return State;\n}\n\nvoid SAGenTestChecker::checkPreStmt(const\
  \ ReturnStmt *RS, CheckerContext &C) const {\n  if (!RS)\n    return;\n\n  ProgramStateRef\
  \ State = C.getState();\n  // If any acquired req is still live, report a leak.\n\
  \  if (!State->get<AcquiredReqs>().isEmpty()) {\n    reportLeak(C, RS);\n  }\n}\n\
  \nvoid SAGenTestChecker::checkEndFunction(const ReturnStmt *RS, CheckerContext &C)\
  \ const {\n  ProgramStateRef State = C.getState();\n  if (!State->get<AcquiredReqs>().isEmpty())\
  \ {\n    reportLeak(C, nullptr);\n  }\n}\n\nvoid SAGenTestChecker::reportLeak(CheckerContext\
  \ &C, const Stmt *S) const {\n  ExplodedNode *N = C.generateNonFatalErrorNode();\n\
  \  if (!N)\n    return;\n\n  auto R = std::make_unique<PathSensitiveBugReport>(\n\
  \      *BT, \"Missing hwrm_req_drop() after successful hwrm_req_init()\", N);\n\
  \  if (S)\n    R->addRange(S->getSourceRange());\n  C.emitReport(std::move(R));\n\
  }\n\n} // end anonymous namespace\n\nextern \"C\" void clang_registerCheckers(CheckerRegistry\
  \ &registry) {\n  registry.addChecker<SAGenTestChecker>(\n      \"custom.SAGenTestChecker\"\
  ,\n      \"{{Checker descriptions to be filled}}\",\n      \"\");\n}\n\nextern \"\
  C\" const char clang_analyzerAPIVersionString[] =\n    CLANG_ANALYZER_API_VERSION_STRING;\n"
tn_score: 1
tp_score: 1
