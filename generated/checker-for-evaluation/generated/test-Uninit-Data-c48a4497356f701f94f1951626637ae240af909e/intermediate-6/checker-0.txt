#include "clang/StaticAnalyzer/Core/BugReporter/BugReporter.h"
#include "clang/StaticAnalyzer/Core/BugReporter/BugType.h"
#include "clang/StaticAnalyzer/Checkers/Taint.h"
#include "clang/StaticAnalyzer/Core/Checker.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/Environment.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h"
#include "clang/StaticAnalyzer/Frontend/CheckerRegistry.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/AST/StmtVisitor.h"
#include "llvm/Support/raw_ostream.h"
#include "clang/StaticAnalyzer/Checkers/utility.h"
// Add any additional includes if needed
#include "clang/Lex/Lexer.h"
#include "clang/AST/Expr.h"

using namespace clang;
using namespace ento;
using namespace taint;

// Customize program states:
// Map to track the initialization (i.e. proper checking) status of firmware pointers.
REGISTER_MAP_WITH_PROGRAMSTATE(FirmwareInitMap, const MemRegion *, bool)
// Map to track pointer aliasing, so that assignment propagates the initialization status.
REGISTER_MAP_WITH_PROGRAMSTATE(PtrAliasMap, const MemRegion*, const MemRegion*)

namespace {

class SAGenTestChecker : public Checker<check::PostCall, check::PreCall, check::BranchCondition, check::Bind> {
  mutable std::unique_ptr<BugType> BT;

public:
  SAGenTestChecker() 
    : BT(new BugType(this, "Uninitialized firmware pointer usage")) {}

  // Callback declarations
  void checkPostCall(const CallEvent &Call, CheckerContext &C) const;
  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;
  void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;
  void checkBind(SVal Loc, SVal Val, const Stmt *StoreE, CheckerContext &C) const;

private:
  // Helper function: Mark the firmware pointer region as checked (i.e. properly verified).
  ProgramStateRef markFirmwareChecked(ProgramStateRef State, const MemRegion *MR) const {
    if (!MR)
      return State;
    MR = MR->getBaseRegion();
    State = State->set<FirmwareInitMap>(MR, true);
    // Also mark any alias if exists.
    if (const MemRegion *Alias = State->get<PtrAliasMap>(MR))
      State = State->set<FirmwareInitMap>(Alias, true);
    return State;
  }

  // Report a bug if an unchecked firmware pointer is being used.
  void reportUninitFirmware(const CallEvent &Call, const MemRegion *MR, CheckerContext &C) const {
    ExplodedNode *N = C.generateNonFatalErrorNode();
    if (!N)
      return;
    auto Report = std::make_unique<PathSensitiveBugReport>(
        *BT, "Firmware pointer may be uninitialized because request_firmware return value was not checked", N);
    Report->addRange(Call.getSourceRange());
    C.emitReport(std::move(Report));
  }
};

/// checkPostCall:
/// Intercept calls to request_firmware.  When a call to request_firmware is seen,
/// mark the firmware pointer (given as the first argument) in the FirmwareInitMap
/// as "unchecked" (false). Later, if it is null-checked, we will update it.
void SAGenTestChecker::checkPostCall(const CallEvent &Call, CheckerContext &C) const {
  ProgramStateRef State = C.getState();
  const Expr *OriginExpr = Call.getOriginExpr();
  if (!OriginExpr)
    return;
  
  // Use ExprHasName to check function name accurately.
  if (!ExprHasName(OriginExpr, "request_firmware", C))
    return;
  
  // The firmware pointer is passed as the first argument (usually "&fw")
  // Get the argument expression.
  if (Call.getNumArgs() < 1)
    return;
  const Expr *FwPtrExpr = Call.getArgExpr(0);
  if (!FwPtrExpr)
    return;
  
  const MemRegion *FwRegion = getMemRegionFromExpr(FwPtrExpr, C);
  if (!FwRegion)
    return;
  
  FwRegion = FwRegion->getBaseRegion();
  // Mark as unchecked (false) because we haven't verified the returned firmware pointer.
  State = State->set<FirmwareInitMap>(FwRegion, false);
  C.addTransition(State);
}

/// checkBind:
/// When a pointer is assigned to another pointer, propagate alias information.
void SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *StoreE, CheckerContext &C) const {
  ProgramStateRef State = C.getState();
  const MemRegion *LHSRegion = Loc.getAsRegion();
  if (!LHSRegion)
    return;
  LHSRegion = LHSRegion->getBaseRegion();
  const MemRegion *RHSRegion = Val.getAsRegion();
  if (!RHSRegion)
    return;
  RHSRegion = RHSRegion->getBaseRegion();

  // Record alias relationship: LHSRegion aliases RHSRegion.
  State = State->set<PtrAliasMap>(LHSRegion, RHSRegion);
  State = State->set<PtrAliasMap>(RHSRegion, LHSRegion);
  C.addTransition(State);
}

/// checkPreCall:
/// Intercept calls to release_firmware.
/// If release_firmware is called on a firmware pointer that is marked as unchecked,
/// then report a bug.
void SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const {
  ProgramStateRef State = C.getState();
  const Expr *OriginExpr = Call.getOriginExpr();
  if (!OriginExpr)
    return;
  
  if (!ExprHasName(OriginExpr, "release_firmware", C))
    return;
  
  // release_firmware typically takes the firmware pointer as its first argument.
  if (Call.getNumArgs() < 1)
    return;
  
  SVal ArgVal = Call.getArgSVal(0);
  const MemRegion *FwRegion = ArgVal.getAsRegion();
  if (!FwRegion)
    return;
  
  FwRegion = FwRegion->getBaseRegion();
  bool UninitFlag = false;
  if (const bool *FlagVal = State->get<FirmwareInitMap>(FwRegion))
    UninitFlag = !(*FlagVal);
  else
    return; // no tracking information, do not warn
  
  if (UninitFlag) {
    reportUninitFirmware(Call, FwRegion, C);
  }
}

/// checkBranchCondition:
/// When a branch condition is evaluated, check if the firmware pointer is being
/// properly checked (for example, if (!fw) or if (fw != NULL)). If so, mark it
/// as "checked" in the FirmwareInitMap.
void SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext &C) const {
  ProgramStateRef State = C.getState();
  const Expr *CondExpr = dyn_cast<Expr>(Condition);
  if (!CondExpr) {
    C.addTransition(State);
    return;
  }
  
  // Remove implicit casts and parens.
  const Expr *CoreExpr = CondExpr->IgnoreParenCasts();
  
  // Look for: if (!fw)
  if (const UnaryOperator *UO = dyn_cast<UnaryOperator>(CoreExpr)) {
    if (UO->getOpcode() == UO_LNot) {
      const Expr *SubExpr = UO->getSubExpr()->IgnoreParenCasts();
      SVal SV = C.getState()->getSVal(SubExpr, C.getLocationContext());
      if (const MemRegion *MR = SV.getAsRegion()) {
        State = markFirmwareChecked(State, MR);
      }
    }
  }
  // Look for binary comparisons: if (fw == NULL) or if (fw != NULL)
  else if (const BinaryOperator *BO = dyn_cast<BinaryOperator>(CoreExpr)) {
    BinaryOperator::Opcode Op = BO->getOpcode();
    if (Op == BO_EQ || Op == BO_NE) {
      const Expr *LHS = BO->getLHS()->IgnoreParenCasts();
      const Expr *RHS = BO->getRHS()->IgnoreParenCasts();
      bool LHSIsNull = LHS->isNullPointerConstant(C.getASTContext(), Expr::NPC_ValueDependentIsNull);
      bool RHSIsNull = RHS->isNullPointerConstant(C.getASTContext(), Expr::NPC_ValueDependentIsNull);
      const Expr *FwExpr = nullptr;
      if (LHSIsNull && !RHSIsNull)
        FwExpr = RHS;
      else if (RHSIsNull && !LHSIsNull)
        FwExpr = LHS;
      if (FwExpr) {
        SVal SV = C.getState()->getSVal(FwExpr, C.getLocationContext());
        if (const MemRegion *MR = SV.getAsRegion())
          State = markFirmwareChecked(State, MR);
      }
    }
  }
  // Also, if the condition is simply "if (fw)" then the firmware pointer is being checked.
  else {
    SVal SV = C.getState()->getSVal(CoreExpr, C.getLocationContext());
    if (const MemRegion *MR = SV.getAsRegion())
      State = markFirmwareChecked(State, MR);
  }
  C.addTransition(State);
}

} // end anonymous namespace

extern "C" void clang_registerCheckers(CheckerRegistry &registry) {
  registry.addChecker<SAGenTestChecker>(
      "custom.SAGenTestChecker", 
      "Detects uninitialized firmware pointer usage due to unchecked request_firmware", 
      "");
}

extern "C" const char clang_analyzerAPIVersionString[] =
    CLANG_ANALYZER_API_VERSION_STRING;
