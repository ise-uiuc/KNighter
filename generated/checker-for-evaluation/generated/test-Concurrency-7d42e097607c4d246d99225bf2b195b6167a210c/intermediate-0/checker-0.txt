#include "clang/AST/Expr.h"
#include "clang/Lex/Lexer.h"
#include "clang/StaticAnalyzer/Core/BugReporter/BugReporter.h"
#include "clang/StaticAnalyzer/Core/BugReporter/BugType.h"
#include "clang/StaticAnalyzer/Checkers/Taint.h"
#include "clang/StaticAnalyzer/Core/Checker.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/Environment.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h"
#include "clang/StaticAnalyzer/Frontend/CheckerRegistry.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/AST/StmtVisitor.h"
#include "llvm/Support/raw_ostream.h"
#include "clang/StaticAnalyzer/Checkers/utility.h"

using namespace clang;
using namespace ento;
using namespace taint;

// Register a program state map to track whether a reset_data structure has already been freed.
// false: not freed yet, true: already freed.
REGISTER_MAP_WITH_PROGRAMSTATE(FreedResetDataMap, const MemRegion*, bool)

namespace {

class SAGenTestChecker : public Checker<check::Bind, check::PreCall, check::BranchCondition> {
  mutable std::unique_ptr<BugType> BT;

public:
  SAGenTestChecker() 
      : BT(new BugType(this, "Double free of reset_data", "Race Condition")) {}

  // In checkBind, we look for the assignment where reset_data is computed via container_of.
  // When we identify such an assignment, we add an entry to FreedResetDataMap with false.
  void checkBind(SVal Loc, SVal Val, const Stmt *StoreE, CheckerContext &C) const;
  
  // In checkPreCall, intercept calls to free functions (e.g. kfree) and update/check our map.
  void checkPreCall(const CallEvent &Call, CheckerContext &C) const;
  
  // Optionally, use checkBranchCondition to track conditions involving completion_done.
  void checkBranchCondition(const Stmt *Condition, CheckerContext &C) const;

private:
  // Helper: Report a double free bug
  void reportDoubleFree(const CallEvent &Call, CheckerContext &C, const MemRegion *MR) const;
};

//
// Implementation of checkBind
//
// Look for bindings that come from a call to container_of. We use the fact that
// the source code text of the expression should contain "container_of" and likely "reset_work".
// If found, we assume the resulting pointer is a reset_data structure that we want to track.
void SAGenTestChecker::checkBind(SVal Loc, SVal Val, const Stmt *StoreE, CheckerContext &C) const {
  if (!StoreE)
    return;

  // Use the utility function to check if the assignment involves container_of.
  // We require the origin expression to mention "container_of" to be conservative.
  if (!ExprHasName(dyn_cast<Expr>(StoreE), "container_of", C))
    return;
  
  // Optionally, further refine by checking for "reset_work" in the source text.
  if (!ExprHasName(dyn_cast<Expr>(StoreE), "reset_work", C))
    return;

  // Retrieve the memory region corresponding to the value being bound.
  const MemRegion *MR = getMemRegionFromExpr(dyn_cast<Expr>(Val.getAs<Expr>()), C);
  if (!MR)
    return;
  
  MR = MR->getBaseRegion();
  if (!MR)
    return;

  // Register this reset_data structure as not freed.
  ProgramStateRef State = C.getState();
  State = State->set<FreedResetDataMap>(MR, false);
  C.addTransition(State);
}

//
// Implementation of checkPreCall
//
// We intercept free calls (e.g. kfree) to update or check the tracking state of reset_data.
// If a free call is attempted on a structure already marked as freed, we report a bug.
void SAGenTestChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const {
  // Use the origin expression to decide if this is a call to kfree.
  const Expr *OriginExpr = Call.getOriginExpr();
  if (!OriginExpr)
    return;
  // Check if the call's source text contains "kfree"
  if (!ExprHasName(OriginExpr, "kfree", C))
    return;
  
  ProgramStateRef State = C.getState();
  
  // We assume the pointer to be freed is the first argument.
  if (Call.getNumArgs() < 1)
    return;
  
  SVal ArgVal = Call.getArgSVal(0);
  const MemRegion *MR = ArgVal.getAsRegion();
  if (!MR)
    return;
  
  MR = MR->getBaseRegion();
  if (!MR)
    return;
  
  // Check our program state to see if this reset_data is being tracked.
  const bool *AlreadyFreed = State->get<FreedResetDataMap>(MR);
  
  if (AlreadyFreed) {
    if (*AlreadyFreed) {
      // Already freed -> report double free.
      reportDoubleFree(Call, C, MR);
      return;
    } else {
      // Mark this reset_data as freed.
      State = State->set<FreedResetDataMap>(MR, true);
      C.addTransition(State);
    }
  }
}

//
// Implementation of checkBranchCondition
//
// Optionally inspect branch conditions to catch conditions involving completion_done().
// When such conditions are seen, we could, for example, log them or update the state.
//
// In our case, if the condition involves "completion_done", we can update the state
// for the reset_data if we identify its use in the conditional that leads to a free.
// (This is optional and for illustration; our primary tracking is via checkBind and checkPreCall.)
void SAGenTestChecker::checkBranchCondition(const Stmt *Condition, CheckerContext &C) const {
  if (!Condition)
    return;
  
  // Look for the call to completion_done by checking the source text.
  if (!ExprHasName(dyn_cast<Expr>(Condition), "completion_done", C))
    return;
  
  // For simplicity, we do not update the state here as our main actions are in checkPreCall.
  // However, one may further refine the analysis here if needed.
  // Just add a state transition.
  C.addTransition(C.getState());
}

//
// Helper to report a double free bug.
//
void SAGenTestChecker::reportDoubleFree(const CallEvent &Call, CheckerContext &C, const MemRegion *MR) const {
  ExplodedNode *N = C.generateNonFatalErrorNode();
  if (!N)
    return;
  
  auto Report = std::make_unique<PathSensitiveBugReport>(
      *BT, "Double free of reset_data detected (race condition)", N);
  Report->addRange(Call.getSourceRange());
  C.emitReport(std::move(Report));
}

} // end anonymous namespace

extern "C" void clang_registerCheckers(CheckerRegistry &registry) {
  registry.addChecker<SAGenTestChecker>(
      "custom.SAGenTestChecker", 
      "Detects race conditions in resetting notification structures (reset_data) via duplicate frees",
      "");
}

extern "C" const char clang_analyzerAPIVersionString[] =
    CLANG_ANALYZER_API_VERSION_STRING;
