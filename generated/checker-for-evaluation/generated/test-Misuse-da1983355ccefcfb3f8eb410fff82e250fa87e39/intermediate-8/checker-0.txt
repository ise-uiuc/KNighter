#include "clang/AST/ASTContext.h"
#include "clang/AST/Expr.h"
#include "clang/AST/ParentMapContext.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/AST/Stmt.h"
#include "clang/Basic/SourceManager.h"
#include "clang/Basic/SourceLocation.h"
#include "clang/Frontend/FrontendActions.h"
#include "clang/StaticAnalyzer/Core/BugReporter/BugReporter.h"
#include "clang/StaticAnalyzer/Core/BugReporter/BugType.h"
#include "clang/StaticAnalyzer/Core/Checker.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h"
#include "clang/StaticAnalyzer/Frontend/CheckerRegistry.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/AnalysisManager.h"
#include "clang/StaticAnalyzer/Core/BugReporter/BasicBugReporter.h"
#include "llvm/Support/raw_ostream.h"
#include "clang/StaticAnalyzer/Checkers/utility.h"

using namespace clang;
using namespace ento;

namespace {

/// Visitor to traverse the function body and record source locations
/// for (1) memcpy call which copies into tz->trips and (2) assignment
/// to tz->num_trips.
class ThermalFunctionVisitor : public RecursiveASTVisitor<ThermalFunctionVisitor> {
public:
  ThermalFunctionVisitor(ASTContext &Ctx)
      : Ctx(Ctx), SM(Ctx.getSourceManager()),
        MemcpyLoc(), NumTripsAssignLoc() {}

  // Visit call expressions to detect memcpy calls.
  bool VisitCallExpr(CallExpr *CE) {
    // Check if the callee is an implicit function decl.
    if (const FunctionDecl *FD = CE->getDirectCallee()) {
      StringRef CalleeName = FD->getName();
      if (CalleeName == "memcpy") {
        // Optionally, we can verify that first argument is tz->trips.
        // For simplicity, record location of memcpy call.
        SourceLocation Loc = CE->getBeginLoc();
        // If not recorded already, record the first memcpy encountered.
        if (MemcpyLoc.isInvalid())
          MemcpyLoc = Loc;
      }
    }
    return true;
  }

  // Visit binary operator to detect assignment to tz->num_trips.
  bool VisitBinaryOperator(BinaryOperator *BO) {
    if (!BO->isAssignmentOp())
      return true;
  
    Expr *LHS = BO->getLHS()->IgnoreParenCasts();
    // Check if LHS is a member expression.
    if (MemberExpr *ME = dyn_cast<MemberExpr>(LHS)) {
      if (const FieldDecl *FD = dyn_cast<FieldDecl>(ME->getMemberDecl())) {
        if (FD->getName() == "num_trips") {
          SourceLocation Loc = BO->getBeginLoc();
          // Record the first assignment to num_trips.
          if (NumTripsAssignLoc.isInvalid())
            NumTripsAssignLoc = Loc;
        }
      }
    }
    return true;
  }

  /// Returns true if both locations were found.
  bool foundBothLocations() const {
    return !MemcpyLoc.isInvalid() && !NumTripsAssignLoc.isInvalid();
  }

  /// Returns true if memcpy call appears before num_trips assignment.
  bool isMemcpyBeforeAssignment() const {
    if (!foundBothLocations())
      return false;
    return SM.isBeforeInTranslationUnit(MemcpyLoc, NumTripsAssignLoc);
  }

  SourceLocation getMemcpyLoc() const { return MemcpyLoc; }
  SourceLocation getNumTripsAssignLoc() const { return NumTripsAssignLoc; }

private:
  ASTContext &Ctx;
  const SourceManager &SM;
  SourceLocation MemcpyLoc;
  SourceLocation NumTripsAssignLoc;
};

class SAGenTestChecker : public Checker<check::ASTCodeBody> {
  mutable std::unique_ptr<BugType> BT;

public:
  SAGenTestChecker() :
      BT(new BugType(this, "Misordered initialization", "Initialization Order")) {}

  void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr,
                        BugReporter &BR) const;

};

void SAGenTestChecker::checkASTCodeBody(const Decl *D, AnalysisManager &Mgr,
                                        BugReporter &BR) const {
  // We only care about function definitions.
  const FunctionDecl *FD = dyn_cast<FunctionDecl>(D);
  if (!FD)
    return;

  // Check that this is the thermal_zone_device_register_with_trips function.
  if (FD->getNameAsString() != "thermal_zone_device_register_with_trips")
    return;

  // Ensure we have a body.
  const Stmt *Body = FD->getBody();
  if (!Body)
    return;

  // Traverse the body to collect the source locations
  ASTContext &Ctx = FD->getASTContext();
  ThermalFunctionVisitor Visitor(Ctx);
  Visitor.TraverseStmt(const_cast<Stmt*>(Body));

  // If both memcpy and assignment were found, check the ordering.
  if (Visitor.foundBothLocations() && Visitor.isMemcpyBeforeAssignment()) {
    // Create a bug report.
    PathDiagnosticLocation Loc =
      PathDiagnosticLocation::createBegin(Visitor.getMemcpyLoc(), BR.getSourceManager());
    auto R = std::make_unique<BasicBugReport>(
        *BT,
        "Misordered initialization: num_trips assigned after memcpy copying to trips buffer",
        FD);
    R->addRange(CharSourceRange::getTokenRange(Visitor.getMemcpyLoc()));
    BR.emitReport(std::move(R));
  }
}

} // end anonymous namespace

extern "C" void clang_registerCheckers(CheckerRegistry &registry) {
  registry.addChecker<SAGenTestChecker>(
      "custom.SAGenTestChecker", 
      "Detects misordering of initialization: num_trips set after memcpy",
      "");
}

extern "C" const char clang_analyzerAPIVersionString[] =
    CLANG_ANALYZER_API_VERSION_STRING;
