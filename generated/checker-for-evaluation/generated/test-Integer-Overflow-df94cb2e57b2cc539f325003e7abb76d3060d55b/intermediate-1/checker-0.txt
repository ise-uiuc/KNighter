#include "clang/StaticAnalyzer/Core/BugReporter/BugReporter.h"
#include "clang/StaticAnalyzer/Core/BugReporter/BugType.h"
#include "clang/StaticAnalyzer/Checkers/Taint.h"
#include "clang/StaticAnalyzer/Core/Checker.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/Environment.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h"
#include "clang/StaticAnalyzer/Frontend/CheckerRegistry.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/AST/StmtVisitor.h"
#include "llvm/Support/raw_ostream.h"
#include "clang/StaticAnalyzer/Checkers/utility.h"
#include "clang/AST/ASTContext.h"
#include "clang/AST/Decl.h"
#include "clang/AST/Stmt.h"
#include "clang/Basic/SourceManager.h"

using namespace clang;
using namespace ento;
using namespace taint;

//
// Custom Checker to detect an insufficient integer type for disk sector counts
// in function "bch2_trans_fs_usage_apply". When a local variable named
// "disk_res_sectors" is declared with an unsigned integer type whose width is
// less than 64 bits, then this might lead to integer overflows in calculations.
//
  
// A helper RecursiveASTVisitor to traverse the function body and find the
// problematic variable declaration.
class DiskSectorsVisitor : public RecursiveASTVisitor<DiskSectorsVisitor> {
  BugReporter &BR;
  const CheckerBase *Checker;

public:
  DiskSectorsVisitor(BugReporter &BR, const CheckerBase *Checker)
      : BR(BR), Checker(Checker) {}

  bool VisitVarDecl(VarDecl *VD) {
    // Look for the variable "disk_res_sectors".
    if (VD->getNameAsString() == "disk_res_sectors") {
      QualType QT = VD->getType();
      // We are interested in unsigned integer types.
      if (QT->isUnsignedIntegerType()) {
        const ASTContext &Ctx = VD->getASTContext();
        // Get the width (in bits) of the declared type.
        uint64_t TypeWidth = Ctx.getTypeSize(QT);
        // If the integer is less than 64 bits wide, this is our bug.
        if (TypeWidth < 64) {
          PathDiagnosticLocation DLoc =
              PathDiagnosticLocation::createBegin(VD, BR.getSourceManager(), Ctx);
          // Report a non-fatal bug.
          std::unique_ptr<BugReport> R = std::make_unique<BugReport>(
              *(new BugType(Checker, "Insufficient integer type for disk sectors", "Integer Overflow")),
              "Disk reserved sectors count type may be insufficient and cause integer overflow", DLoc);
          R->addRange(VD->getSourceRange());
          BR.emitReport(std::move(R));
        }
      }
    }
    return true;
  }
};

namespace {

class SAGenTestChecker : public Checker<check::ASTCodeBody> {
  mutable std::unique_ptr<BugType> BT;
public:
  SAGenTestChecker()
      : BT(new BugType(this,
                       "Insufficient integer type",
                       "Integer Overflow")) {}

  // Callback to check the body of AST declarations.
  void checkASTCodeBody(const Decl *D, AnalysisManager &Mgr, BugReporter &BR) const;
};

void SAGenTestChecker::checkASTCodeBody(const Decl *D,
                                          AnalysisManager &Mgr,
                                          BugReporter &BR) const {
  // We only consider function definitions.
  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {
    if (!FD->hasBody())
      return;

    // Target the function "bch2_trans_fs_usage_apply".
    if (FD->getNameAsString() == "bch2_trans_fs_usage_apply") {
      // Traverse the function body with our visitor.
      DiskSectorsVisitor Visitor(BR, this);
      Visitor.TraverseStmt(FD->getBody());
    }
  }
}

} // end anonymous namespace

extern "C" void clang_registerCheckers(CheckerRegistry &registry) {
  registry.addChecker<SAGenTestChecker>(
      "custom.SAGenTestChecker",
      "Detects use of an insufficient integer type for disk sectors which may cause integer overflow",
      "");
}

extern "C" const char clang_analyzerAPIVersionString[] =
    CLANG_ANALYZER_API_VERSION_STRING;
